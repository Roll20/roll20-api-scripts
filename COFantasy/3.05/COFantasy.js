// Needs the Vector Math scripty
// ------------------ generateRowID code from the Aaron ---------------------
const generateUUID = (function() {
    "use strict";
    let a = 0,
      b = [];
    return function() {
      let c = (new Date()).getTime() + 0,
        d = c === a;
      a = c;
      let e = new Array(8);
      for (let f = 7; 0 <= f; f--) {
        e[f] = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c % 64);
        c = Math.floor(c / 64);
      }
      c = e.join("");
      if (d) {
        let f = 11;
        for (; 0 <= f && 63 === b[f]; f--) {
          b[f] = 0;
        }
        b[f]++;
      } else {
        for (let f = 0; 12 > f; f++) {
          b[f] = Math.floor(64 * Math.random());
        }
      }
      for (let f = 0; 12 > f; f++) {
        c += "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);
      }
      return c;
    };
  }()),

  generateRowID = function() {
    "use strict";
    return generateUUID().replace(/_/g, "Z");
  };
//--------------- end generateRowID ----------------------------------------

const COF_BETA = false;

let COF_loaded = false;

var COFantasy = COFantasy || function() {

  "use strict";

  const versionFiche = 5.01;

  const PIX_PER_UNIT = 70;
  const HISTORY_SIZE = 200;
  const BS_LABEL = 'text-transform: uppercase; display: inline; padding: .2em .6em .3em; font-size: 75%; line-height: 2; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: .25em;';
  const BS_LABEL_SUCCESS = 'background-color: #5cb85c;';
  const BS_LABEL_INFO = 'background-color: #5bc0de;';
  const BS_LABEL_WARNING = 'background-color: #f0ad4e;';
  const BS_LABEL_DANGER = 'background-color: #d9534f;';
  const DEFAULT_DYNAMIC_INIT_IMG = 'https://s3.amazonaws.com/files.d20.io/images/4095816/086YSl3v0Kz3SlDAu245Vg/thumb.png?1400535580';
  const IMG_INVISIBLE = 'https://s3.amazonaws.com/files.d20.io/images/24377109/6L7tn91HZLAQfrLKQI7-Ew/thumb.png?1476950708';

  let markerCatalog = {};
  let eventHistory = [];
  let updateNextInitSet = new Set();

  const flashyInitMarkerScale = 1.6;

  const attaqueAMainsNues = {
    name: 'Mains nues',
    attSkill: '@{ATKCAC}',
    attNbDices: 1,
    attDice: 4,
    attDMBonusCommun: 0,
    attCarBonus: '@{FOR}',
    crit: 20,
    divers: '',
    portee: 0,
    typeDegats: 'contondant',
    options: '--tempDmg',
  };

  const defaultOptions = {
    regles: {
      explications: "Options qui influent sur les r\xE8gles du jeu",
      type: 'options',
      val: {
        divers: {
          explications: "Options diverses",
          type: 'options',
          val: {
            forme_d_arbre_amelioree: {
              explications: "+50% \xE0 l'effet de la peau d'\xE9corce en forme d'arbre.",
              val: true,
              type: 'bool'
            },
            poudre_explosif: {
              explications: "Les armes \xE0 poudre font des d\xE9g\xE2ts explosifs",
              val: true,
              type: 'bool'
            },
            interchangeable_attaque: {
              explications: "La capacit\xE9 interchangeable donne moins de DEF mais plus d'attaque",
              val: true,
              type: 'bool'
            },
            coups_critiques_etendus: {
              explications: "Coup critique \xE0 une attaque d\xE8s qu'elle d\xE9passe DEF + 10",
              val: false,
              type: 'bool'
            },
            echec_critique_boule_de_feu: {
              explications: "Nombre de m\xE8tre dont le centre d'une boule de feu peut \xEAtre d\xE9plac\xE9 de mani\xE8re al\xE9atoire en cas d'\xE9chec critique. La probabilit\xE9 est inversement proportionelle \xE0 la distance.",
              val: 12,
              type: 'int'
            }
          }
        },
        dommages: {
          explications: "R\xE8gles optionnelles sur les dommages",
          type: 'options',
          val: {
            blessures_graves: {
              explications: "Si on arrive \xE0 0 PV, on perd 1PR, et si on a plus de PR, on a une blessure grave.",
              val: true,
              type: 'bool'
            },
            degats_importants: {
              explications: "Si les DMs d\xE9passent CON+niveau en une attaque, on applique aussi la r\xE8gle de blessure grave.",
              val: true,
              type: 'bool'
            },
            dm_minimum: {
              explications: "D\xE9g\xE2ts minimum d'une attaque ou autre source de DM.",
              val: 0,
              type: 'int'
            },
            crit_elementaire: {
              explications: "Les DMs constants d'un autre type que celui de l'arme sont aussi multipli\xE9s en cas de critique",
              val: false,
              type: 'bool'
            },
            max_rune_protection: {
              explications: "Les DMs qu'une rune de protection est capable d'absorber sont limit\xE9s \xE0 10x le rang du forgesort dans la voie des runes",
              val: true,
              type: 'bool'
            }
          }
        },
        haute_DEF: {
          explications: "Options de jeu pour g\xE9rer la haute DEF",
          type: 'options',
          val: {
            usure_DEF: {
              explications: "Malus de -2 en DEF tous les n tours. Mettre \xE0 0 pour ne pas avoir de malus d'usure",
              val: 6,
              type: 'int'
            },
            bonus_attaque_groupe: {
              explications: "Lors d'une attaque de groupe, bonus \xE0 la touche par cr\xE9ature suppl\xE9mentaire",
              val: 2,
              type: 'int'
            },
            crit_attaque_groupe: {
              explications: "Lors d'une attaque de groupe, si le jet de touche d\xE9passe DEF + cette valeur, les dommages sont doubl\xE9s (0 = jamais)",
              val: 5,
              type: 'int'
            }
          }
        },
        initiative: {
          explications: "Options qui influent sur les r\xE8gles du jeu",
          type: 'options',
          val: {
            initiative_variable: {
              explications: "Ajoute 1d6 \xE0 l'initiative, lanc\xE9 une fois par combat par type de cr\xE9ature",
              val: false,
              type: 'bool'
            },
            initiative_variable_individuelle: {
              explications: "Lancer l'initiative variable pour chaque cr\xE9ature (n\xE9cessite d'activer l'Initiative variable)",
              val: false,
              type: 'bool'
            }
          }
        },
        mana: {
          explications: "Options de Mana",
          type: 'options',
          val: {
            mana_totale: {
              explications: "Tous les sorts ont un co\xFBt, celui des temp\xEAtes de mana est multipli\xE9 par 3",
              val: false,
              type: 'bool'
            },
            contrecoup: {
              explications: "Avec la Mana Totale, permet au lanceur de sort de payer un d\xE9ficit de PM en PV (COF p. 181)",
              val: false,
              type: 'bool'
            },
            brulure_de_magie: {
              explications: "Permettre d'utiliser ses PV comme PM (Magie de CO Terres d'Arran, incompatible avec Mana Totale)",
              val: false,
              type: 'bool'
            },
            elixirs_sorts: {
              explications: "Toutes fabrications d'\xE9lixir sont consid\xE9r\xE9es comme des sorts (qui peuvent co\xFBter de la mana)",
              val: true,
              type: 'bool'
            },
          }
        }
      }
    },
    affichage: {
      explications: "Options d'affichage",
      type: 'options',
      val: {
        MJ_voit_actions: {
          explications: "\xC0 chaque nouveau personnage en combat, montre le choix d'actions au MJ, m\xEAme pour les PJs.",
          val: false,
          type: 'bool'
        },
        MJ_valide_affichage_attaques: {
          explications: "Les r\xE9sultats des attaques sont d'abord montr\xE9es au MJ seul, qui peut ensuite les montrer aux joueurs",
          val: false,
          type: 'bool'
        },
        avatar_dans_cadres: {
          explications: "Si faux, on utilise l'image du token.",
          val: true,
          type: 'bool'
        },
        manoeuvres: {
          explications: "Affiche les manoeuvres dans la liste d'actions",
          val: true,
          type: 'bool'
        },
        actions_par_defaut: {
          explications: "Sans ability #Actions#, affiche la liste des abilities",
          val: true,
          type: 'bool'
        },
        montre_def: {
          explications: "montre la DEF des adversaires dans les cadres de combat",
          val: true,
          type: 'bool'
        },
        duree_effets: {
          explications: "Le script indique la dur\xE9e des effets associ\xE9s aux tokens",
          val: false,
          type: 'bool'
        },
        init_dynamique: {
          explications: "Fait appara\xEEtre une aura dynamique sur le token qui a l'initiative",
          val: true,
          type: 'bool'
        },
        markers_personnalises: {
          explications: "Utilisation des markers personnalis\xE9s commen\xE7ant par cof",
          val: true,
          type: 'bool'
        },
        table_crit: {
          explications: "Utilisation d'une table de critiques nomm\xE9e Echec-Critique-Contact",
          val: false,
          type: 'bool'
        },
        depense_mana: {
          explications: "Le script pr\xE9cise la quantit\xE9 de mana utilis\xE9e dans le chat \xE0 chaque fois",
          val: false,
          type: 'bool'
        }
      }
    },
    images: {
      explications: "Images par d\xE9faut",
      type: 'options',
      val: {
        image_init: {
          explications: "Image utilis\xE9e pour indiquer le personnage dont c'est le tour",
          type: 'image',
          val: DEFAULT_DYNAMIC_INIT_IMG
        },
        image_double: {
          explications: 'Image utilis\xE9e pour la capacit\xE9 d\xE9doublement',
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/33854984/q10B3KtWsCxcMczLo4BSUw/thumb.png?1496303265"
        },
        image_ombre: {
          explications: "Image utilis\xE9e pour l'ombre mortelle",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/2781735/LcllgIHvqvu0HAbWdXZbJQ/thumb.png?13900368485"
        },
        image_arbre: {
          explications: "Image utilis\xE9e pour la forme d'arbre",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/52767134/KEGYUXeKnxZr5dbDwQEO4Q/thumb.png?15248300835"
        },
        image_mur_de_force: {
          explication: "Image utilis\xE9e pour un mur de force sph\xE9rique",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/33213510/5r3NGSso1QBJMJewTEKv0A/thumb.png?1495195634"
        },
        prison_vegetale: {
          explication: "Image utilis\xE9e pour un mur de force sph\xE9rique",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/254738719/c97DFw6JlEePDVXBf-MPsA/thumb.png?1636471250"
        },
      }
    },
    sons: {
      explications: "Sons par d\xE9faut",
      type: 'options',
      val: {
        attaque_echec_critique: {
          explication: "Son utilis\xE9 pour les \xE9checs critiques d'attaques",
          type: 'son',
          val: ''
        },
        attaque_reussite_critique: {
          explication: "Son utilis\xE9 pour les r\xE9ussites critiques d'attaques",
          type: 'son',
          val: ''
        }
      }
    },
    macros_a_jour: {
      explications: "Met automatiquement les macros \xE0 jour",
      type: 'bool',
      val: true
    }
  };

  function copyOptions(dst, src) {
    for (let o in src) {
      let opt = src[o];
      let isOption = opt.type == 'options';
      if (dst[o] === undefined) {
        dst[o] = {
          explications: opt.explications,
          val: {},
          type: opt.type,
        };
        if (!isOption) dst[o].val = opt.val;
      }
      if (isOption) copyOptions(dst[o].val, opt.val);
    }
  }

  //Liste de tables par d\xE9faut
  const gameTables = [{
    name: "Echec-Critique-Contact",
    showplayers: false,
    items: [{
      name: "FOR - Bouscul\xE9  : le personnage est renvers\xE9 par son adversaire. Il subit un d\xE9 malus au test de FOR si l\x2019adversaire " +
        "est d\x2019une cat\xE9gorie de taille sup\xE9rieure et b\xE9n\xE9ficie d\x2019un d\xE9 bonus dans le cas inverse. " +
        "Il subit une attaque gratuite de la part d\x2019un adversaire pendant qu\x2019il est \xE9tal\xE9 au sol (-5 en DEF).",
      weight: 1,
    }, {
      name: "DEX - Maladresse : le personnage laisse tomber au sol l'objet avec lequel il attaque. S\x2019il essaye de le ramasser, " +
        "il subit une attaque gratuite.",
      weight: 1,
    }, {
      name: "CON - Coup de mou: le personnage subit l\x2019\xE9tat affaibli pendant 3 rounds. Ou il peut annuler cet \xE9tat en reprenant" +
        "son souffle par une action limit\xE9e.",
      weight: 1,
    }, {
      name: "INT - Erreur tactique : le personnage subit une attaque (gratuite) d\x2019un adversaire \xE0 son contact.",
      weight: 1,
    }, {
      name: "SAG - Distrait : le personnage se laisse distraire et ne voit pas venir la prochaine attaque, " +
        "l\x2019adversaire b\xE9n\xE9ficiera d\x2019un bonus de +10.",
      weight: 1,
    }, {
      name: "CHA - Ridicule : le personnage fait un faux mouvement \xE0 la fois douloureux et ridicule, il subit " +
        "l\x2019\xE9tat \xE9tourdi pendant un round pour reprendre contenance.",
      weight: 1,
    }, {
      name: "Votre arme se brise. S\x2019il s\x2019agit d\x2019une arme magique, le d\xE9 DM est simplement r\xE9duit d'une cat\xE9gorie " +
        "(2d6/d12=>d10=>d8=>d6=>d4=>d3) jusqu\x2019\xE0 la fin du combat.",
      weight: 1,
    }, {
      name: "Une pi\xE8ce d\x2019armure bouge et elle devient plus g\xEAnante que protectrice : malus en DEF et en attaque pour le reste du combat. Cuir : -1, Maille : -2, Plaque -3.",
      weight: 1,
    }, {
      name: "Simple \xE9chec de l'attaque",
      weight: 12,
    }, ],
  }, ];

  var stateCOF = state.COFantasy;
  var reglesOptionelles; // = stateCOF.options.regles.val;

  // List of states:
  const cof_states = {
    assomme: 'status_pummeled',
    mort: 'status_dead',
    surpris: 'status_lightning-helix',
    renverse: 'status_back-pain',
    aveugle: 'status_bleeding-eye',
    affaibli: 'status_half-heart',
    etourdi: 'status_half-haze',
    paralyse: 'status_fishing-net',
    ralenti: 'status_snail',
    immobilise: 'status_cobweb',
    endormi: 'status_sleepy',
    apeure: 'status_screaming',
    invisible: 'status_ninja-mask',
    blesse: 'status_arrowed',
    encombre: 'status_frozen-orb',
    penombre: 'status_archery-target',
    enseveli: 'status_edge-crack'
  };

  //Remplis quand on sait quels sont les markers dans setStateCOF
  var etat_de_marker = {};
  var effet_de_marker = {};

  // Donne le nom de l'attribut, selon qu'il concerne un mook ou un personnage
  // unique
  // perso peut ne pas avoir de token
  function fullAttributeName(perso, attribute, options) {
    if (perso.token && (!options || !options.charAttr)) {
      let link = perso.token.get('bar1_link');
      if (link === '') return attribute + '_' + perso.token.get('name');
    }
    return attribute;
  }

  //Retourne une liste d'attributs
  //personnage peut ne pas avoir de token
  function tokenAttribute(personnage, name) {
    let fullName = fullAttributeName(personnage, name);
    return findObjs({
      _type: 'attribute',
      _characterid: personnage.charId,
      name: fullName
    });
  }

  function charAttribute(charId, name, option) {
    return findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: name
    }, option);
  }

  function attrAsInt(attr, def, defPresent) {
    if (attr.length === 0) return def;
    attr = parseInt(attr[0].get('current'));
    if (isNaN(attr)) {
      if (defPresent !== undefined) return defPresent;
      return def;
    }
    return attr;
  }

  function attrAsBool(attr) {
    if (attr.length === 0) return false;
    attr = attr[0].get('current');
    if (attr == '0' || attr == 'false') return false;
    if (attr) return true;
    return false;
  }

  // Attention, def, la valeur par d\xE9faut, doit \xEAtre la m\xEAme que sur la fiche
  // personnage peut ne pas avoir de token
  function ficheAttribute(personnage, name, def) {
    let attr = charAttribute(personnage.charId, name, {
      caseInsensitive: true
    });
    if (attr.length === 0) return def;
    return attr[0].get('current');
  }

  //personnage peut ne pas avoir de token
  function ficheAttributeAsInt(personnage, name, def, defPresent) {
    let attr = charAttribute(personnage.charId, name, {
      caseInsensitive: true
    });
    if (attr === undefined) return def;
    return attrAsInt(attr, def, defPresent);
  }

  //Il faut une valeur par d\xE9faut, qui correspond \xE0 celle de la fiche
  function ficheAttributeAsBool(personnage, name, def) {
    let attr = charAttribute(personnage.charId, name, {
      caseInsensitive: true
    });
    if (attr.length === 0) return def;
    return attrAsBool(attr);
  }

  //Attention \xE0 ne pas utiliser si l'attribut ne d\xE9pend pas du token
  //defPresent est optionnel
  //personnage peut ne pas avoir de token
  function attributeAsInt(personnage, name, def, defPresent) {
    let attr = tokenAttribute(personnage, name);
    return attrAsInt(attr, def, defPresent);
  }

  //personnage peut ne pas avoir de token
  function attributeAsBool(personnage, name) {
    var attr = tokenAttribute(personnage, name);
    return attrAsBool(attr);
  }

  function charAttributeAsInt(perso, name, def, defPresent) {
    var attr = charAttribute(perso.charId, name);
    return attrAsInt(attr, def, defPresent);
  }

  function charAttributeAsBool(perso, name) {
    var attr = charAttribute(perso.charId, name);
    return attrAsBool(attr);
  }

  function predicateOfRaw(raw) {
    let pred = {};
    let last, assign;
    //On enl\xE8ve d'abord les commentaires
    raw = raw.replace(/\/\/[^\n]*\n/g, ' ');
    raw.split(/,| |\n/).forEach(function(p) {
      p = p.trim();
      if (p === '') return;
      if (p === ':') {
        if (last) assign = true;
        return;
      }
      let i = p.indexOf(':');
      if (i < 0) {
        if (last) {
          if (assign) {
            pred[last] = p;
            assign = false;
          } else pred[last] = true;
        }
        last = p;
        return;
      }
      //p contient ':' mais pas seulement
      if (i === 0) {
        if (last) {
          pred[last] = p.substring(1);
          last = undefined;
        } else {
          last = p.substring(1);
        }
        assign = false;
        return;
      } //p ne commence pas par ':'
      if (last) pred[last] = true;
      if (i == p.length - 1) {
        last = p.substring(0, i);
        assign = true;
      } else {
        pred[p.substring(0, i)] = p.substring(i + 1);
        last = undefined;
        assign = false;
      }
    });
    if (last) pred[last] = true;
    return pred;
  }

  function charPredicateAsBool(charId, name) {
    let raw = '';
    let attr = charAttribute(charId, 'predicats_script', {
      caseInsensitive: true
    });
    if (attr.length > 0) {
      raw = attr[0].get('current');
    }
    let pred = predicateOfRaw(raw);
    return pred[name];
  }

  function getPredicates(perso) {
    if (perso.predicates === undefined) {
      let raw = ficheAttribute(perso, 'predicats_script', '');
      let pred = predicateOfRaw(raw);
      perso.predicates = pred;
    }
    return perso.predicates;
  }

  function predicateAsBool(perso, name) {
    let pred = getPredicates(perso);
    return pred[name];
  }

  function predicateAsInt(perso, name, def, defPresent) {
    let pred = getPredicates(perso);
    let r = pred[name];
    if (r === undefined) return def;
    if (defPresent !== undefined) def = defPresent;
    if (r === true) return def;
    r = parseInt(r);
    if (isNaN(r)) return def;
    return r;
  }

  function predicateOrAttributeAsBool(perso, name) {
    let p = predicateAsBool(perso, name);
    if (p) return p;
    return attributeAsBool(perso, name);
  }

  function error(msg, obj) {
    log(msg);
    log(obj);
    if (msg) {
      try {
        sendChat('COFantasy', msg);
      } catch (e) {
        msg = msg.replace('[', '[ ');
        sendChat('COFantasy', "Message sans jet : " + msg);
      }
    }
  }

  function determineSettingDeJeu() {
    var characters = findObjs({
      _type: 'character'
    });
    var charsGenerique = [];
    var charsArran = [];
    characters.forEach(function(c) {
      var typePerso = charAttribute(c.id, 'type_personnage', {
        caseInsensitive: true
      });
      if (typePerso.length > 0 && typePerso[0].get('current') == 'PNJ')
        return; //Les fiches de PNJ sont les m\xEAmes
      var setting = charAttribute(c.id, 'option_setting', {
        caseInsensitive: true
      });
      if (setting.length === 0) {
        charsGenerique.push(c);
        return;
      }
      if (setting[0].get('current') == 'arran') charsArran.push(c);
      else charsGenerique.push(c);
    });
    if (charsArran.length <= charsGenerique.length) {
      log("Utilisation des r\xE8gles COF g\xE9n\xE9riques");
      if (charsArran.length > 0) {
        error("Attention, des personnages suivent les options de jeu des Terres d'Arran (voir le log pour la liste)", charsArran);
        charsArran.forEach(function(c) {
          var g = getObj('character', c.id);
          if (g) log(g.get('name'));
          else log(c);
        });
        stateCOF.setting_mixte = true;
      }
      return;
    }
    log("Utilisation des r\xE8gles des Terres d'Arran");
    if (charsGenerique.length > 0) {
      error("Attention, des personnages ne suivent pas les options de jeu des Terres d'Arran (voir le log pour la liste)", charsGenerique);
      charsGenerique.forEach(function(c) {
        var g = getObj('character', c.id);
        if (g) log(g.get('name'));
        else log(c);
      });
      stateCOF.setting_mixte = true;
      return;
    }
    stateCOF.setting_arran = true;
  }

  let statusForInitAlly;
  let statusForInitEnemy;

  function registerMarkerEffet(marker, effet) {
    var m = markerCatalog[marker];
    if (m) {
      messageEffetTemp[effet].statusMarker = m.tag;
      effet_de_marker[m.tag] = effet;
    } else {
      log("Marker " + m + " introuvable. Pas de marker pour l'effet " + effet);
    }
  }

  let roundMarker;

  const roundMarkerSpec = {
    represents: '',
    rotation: 0,
    layer: 'map',
    name: 'Init marker',
    aura1_color: '#ff00ff',
    aura2_color: '#00ff00',
    imgsrc: DEFAULT_DYNAMIC_INIT_IMG,
    shownname: false,
    light_hassight: false,
    has_bright_light_vision: false,
    has_night_vision: false,
    is_drawing: true
  };
  let threadSync = 0;

  function removeRoundMarker() {
    if (roundMarker) {
      roundMarker.remove();
      roundMarker = undefined;
      stateCOF.roundMarkerId = undefined;
    } else if (stateCOF.roundMarkerId) {
      let roundMarkers = findObjs({
        _type: 'graphic',
        represents: '',
        name: 'Init marker',
      });
      roundMarkers.forEach(function(rm) {
        rm.remove();
      });
      stateCOF.roundMarkerId = undefined;
    }
  }

  function activateRoundMarker(sync, token) {
    if (!stateCOF.combat) {
      removeRoundMarker();
      threadSync = 0;
      return;
    }
    if (sync != threadSync) return;
    if (token) {
      // Cas sp\xE9ciaux du cavaliers
      let personnage = persoOfId(token.id);
      let monteSur = tokenAttribute(personnage, 'monteSur');
      let estMontePar = tokenAttribute(personnage, 'estMontePar');
      let monture;
      let cavalier;
      if (monteSur.length > 0) {
        cavalier = personnage;
        let montureTokenId = monteSur[0].get("current");
        monture = persoOfId(montureTokenId);
        if (monture !== undefined) token = monture.token;
      } else if (estMontePar.length > 0) {
        monture = personnage;
        let cavalierId = estMontePar[0].get("current");
        cavalier = persoOfId(cavalierId);
      }
      removeRoundMarker();
      roundMarkerSpec._pageid = token.get('pageid');
      let tokenLayer = token.get('layer');
      if (tokenLayer !== 'objects') roundMarkerSpec.layer = tokenLayer;
      else roundMarkerSpec.layer = 'map';
      roundMarkerSpec.left = token.get('left');
      roundMarkerSpec.top = token.get('top');
      let width = (token.get('width') + token.get('height')) / 2 * flashyInitMarkerScale;
      roundMarkerSpec.width = width;
      roundMarkerSpec.height = width;
      roundMarkerSpec.imgsrc = stateCOF.options.images.val.image_init.val;
      var localImage;
      var gmNotes = token.get('gmnotes');
      try {
        gmNotes = _.unescape(decodeURIComponent(gmNotes)).replace('&nbsp;', ' ');
        gmNotes = linesOfNote(gmNotes);
        gmNotes.forEach(function(l) {
          if (localImage) return;
          if (l.startsWith('init_aura:')) {
            roundMarkerSpec.imgsrc = l.substring(10).trim();
            localImage = true;
          }
        });
      } catch (uriError) {
        log("Erreur de d\xE9codage URI dans la note GM de " + token.get('name') + " : " + gmNotes);
      }
      roundMarker = createObj('graphic', roundMarkerSpec);
      if (roundMarker === undefined && localImage) {
        error("Image locale de " + token.get('name') + " incorrecte (" + roundMarkerSpec.imgsrc + ")", gmNotes);
        roundMarkerSpec.imgsrc = stateCOF.options.images.val.image_init.val;
        roundMarker = createObj('graphic', roundMarkerSpec);
      }
      if (roundMarker === undefined && roundMarkerSpec.imgsrc != DEFAULT_DYNAMIC_INIT_IMG) {
        error("Image d'aura d'initiative incorrecte (" + roundMarkerSpec.imgsrc + ")", gmNotes);
        roundMarkerSpec.imgsrc = DEFAULT_DYNAMIC_INIT_IMG;
        roundMarker = createObj('graphic', roundMarkerSpec);
      }
      if (roundMarker === undefined) {
        error("Impossible de cr\xE9er le token pour l'aura dynamique", roundMarkerSpec);
        return false;
      }
      stateCOF.roundMarkerId = roundMarker.id;
      if (roundMarkerSpec.layer === 'map') toFront(roundMarker);
      // Ne pas amener une monture mont\xE9e en avant pour \xE9viter de cacher le cavalier
      if (cavalier && monture) {
        toFront(monture.token);
        toFront(cavalier.token);
      } else {
        toFront(token);
      }
      setTimeout(_.bind(activateRoundMarker, undefined, sync), 200);
    } else if (roundMarker) { //rotation
      let rotation = roundMarker.get('rotation');
      roundMarker.set('rotation', (rotation + 1) % 365);
      let timeout = 100;
      //let page = getObj('page', roundMarker.get('pageid'));
      //if (page && (page.get('dynamic_lighting_enabled') || page.get('showlighting'))) timeout = 2000;
      setTimeout(_.bind(activateRoundMarker, undefined, sync), timeout);
    }
  }

  function removeTokenFlagAura(token) {
    if (stateCOF.options.affichage.val.init_dynamique.val) {
      removeRoundMarker();
      stateCOF.roundMarkerId = undefined;
      return;
    }
    if (aura_token_on_turn) {
      token.set('aura2_radius', '');
      token.set('showplayers_aura2', false);
    } else {
      // Cas des tokens personnalis\xE9s
      if (statusForInitEnemy && statusForInitAlly) {
        token.set(statusForInitAlly, false);
        token.set(statusForInitEnemy, false);
      } else token.set('status_flying-flag', false);
    }
  }

  //Appel\xE9 au lancement du script, mise \xE0 jour de certaines variables globales
  function setStateCOF() {
    stateCOF = state.COFantasy;
    if (stateCOF.roundMarkerId) {
      roundMarker = getObj('graphic', stateCOF.roundMarkerId);
      if (roundMarker === undefined) {
        log("Le marqueur d'init a chang\xE9 d'id");
        let roundMarkers = findObjs({
          _type: 'graphic',
          represents: '',
          name: 'Init marker',
        });
        if (roundMarkers.length > 0) {
          roundMarker = roundMarkers[0];
          stateCOF.roundMarkerId = roundMarker.id;
          roundMarkers.forEach(function(rm) {
            if (rm.id != roundMarker.id) rm.remove();
          });
        } else {
          roundMarker = undefined;
          stateCOF.roundMarkerId = undefined;
        }
      }
    }
    if (stateCOF.combat_pageid) {
      let pageCombat = getObj('page', stateCOF.combat_pageid);
      if (pageCombat === undefined) {
        if (stateCOF.roundMarkerId && roundMarker) {
          stateCOF.combat_pageid = roundMarker.get('pageid');
        } else {
          stateCOF.combat_pageid = Campaign().get('playerpageid');
        }
      }
    }
    if (!stateCOF.personnageCibleCree) {
      //On cherche si un personnage cible existe d\xE9j\xE0
      var persos = findObjs({
        _type: 'character',
        name: 'Cible',
        controlledby: 'all'
      });
      if (persos.length === 0) {
        var pages = findObjs({
          _type: 'page'
        });
        if (pages.length > 0) {
          var pageId = pages[0].id;
          var charCible = createObj('character', {
            name: 'Cible',
            controlledby: 'all',
            inplayerjournals: 'all',
            avatar: 'https://s3.amazonaws.com/files.d20.io/images/33041174/5JdDVh-34C-kZglTE1aq-w/max.png?1494837870',
          });
          if (charCible) {
            var attrPV = charAttribute(charCible.id, 'PV', {
              caseInsensitive: true
            });
            if (attrPV.length > 0) attrPV = attrPV[0];
            else attrPV = createObj('attribute', {
              name: 'PV',
              characterid: charCible.id,
              current: 0,
              max: 0
            });
            var attrType = charAttribute(charCible.id, 'type_personnage', {
              caseInsensitive: true
            });
            if (attrType.length > 0) {
              attrType[0].setWithWorker('current', 'PNJ');
            } else {
              attrType = createObj('attribute', {
                name: 'type_personnage',
                characterid: charCible.id,
                current: 'PJ',
              });
              attrType.setWithWorker('current', 'PNJ');
            }
            var tokenCible = createObj('graphic', {
              name: 'Cible',
              layer: 'objects',
              _pageid: pageId,
              imgsrc: 'https://s3.amazonaws.com/files.d20.io/images/33041174/5JdDVh-34C-kZglTE1aq-w/thumb.png?1494837870',
              represents: charCible.id,
              width: PIX_PER_UNIT,
              height: PIX_PER_UNIT,
              bar1_link: attrPV ? attrPV.id : ''
            });
            if (tokenCible) {
              setDefaultTokenForCharacter(charCible, tokenCible);
              tokenCible.remove();
            }
          }
        }
      }
      stateCOF.personnageCibleCree = true;
    }
    //Cr\xE9ation des tables par d\xE9faut
    if (!stateCOF.tablesCrees) {
      let allTables = findObjs({
        _type: 'rollabletable',
      });
      gameTables.forEach(function(gameTable) {
        let table = allTables.find(function(table) {
          return table.get("name") == gameTable.name;
        });
        if (table === undefined) {
          table = createObj('rollabletable', {
            name: gameTable.name,
            showplayers: gameTable.showplayers,
          });
          gameTable.items.forEach(function(tableItem) {
            tableItem.rollabletableid = table.id;
            createObj('tableitem', tableItem);
          });
        }
      });
      stateCOF.tablesCrees = true;
    }
    // Le setting
    determineSettingDeJeu();
    // Les options de jeu
    if (stateCOF.options === undefined) stateCOF.options = {};
    copyOptions(stateCOF.options, defaultOptions);
    reglesOptionelles = stateCOF.options.regles.val;
    // Les macros utiles en jeu
    if (stateCOF.options.macros_a_jour.val) {
      let macros = findObjs({
        _type: 'macro'
      });
      let players = findObjs({
        _type: 'player'
      });
      let mjs = [];
      players.forEach(function(p) {
        if (playerIsGM(p.id)) mjs.push(p.id);
      });
      var inBar = [];
      if (stateCOF.gameMacros) {
        //Check modified or removed macros
        stateCOF.gameMacros.forEach(function(gm) {
          var ngm = gameMacros.find(function(ngm) {
            return ngm.name == gm.name;
          });
          if (ngm) {
            if (ngm.action == gm.action && ngm.visibleto == gm.visibleto && ngm.istokenaction == gm.istokenaction) return;
            macros.forEach(function(m) {
              if (m.get('name') != ngm.name) return;
              if (ngm.action != gm.action && m.get('action') == gm.action)
                m.set('action', ngm.action);
              if (ngm.visibleto != gm.visibleto && m.get('visibleto') == gm.visibleto)
                m.set('visibleto', ngm.visibleto);
              if (ngm.istokenaction != gm.istokenaction && m.get('istokenaction') == gm.istokenaction)
                m.set('istokenaction', ngm.istokenaction);
              sendChat('COF', '/w GM Macro ' + ngm.name + ' mise \xE0 jour.');
            });
          } else {
            macros.forEach(function(m) {
              if (m.get('name') != gm.name) return;
              if (m.get('action') != gm.action) return;
              m.remove();
              sendChat('COF', '/w GM Macro ' + gm.name + ' effac\xE9e.');
            });
          }
        });
        //Nouvelles macros
        gameMacros.forEach(function(ngm) {
          var gm = stateCOF.gameMacros.find(function(gm) {
            return ngm.name == gm.name;
          });
          if (!gm) {
            var prev =
              macros.find(function(macro) {
                return macro.get('name') == ngm.name;
              });
            if (prev === undefined) {
              sendChat('COF', '/w GM Macro ' + ngm.name + ' cr\xE9\xE9e.');
              if (ngm.inBar) inBar.push(ngm.name);
              mjs.forEach(function(playerId, i) {
                if (i === 0 || ngm.visibleto === '') {
                  ngm.playerid = playerId;
                  createObj('macro', ngm);
                }
              });
            }
          }
        });
      } else {
        //Peut-\xEAtre la premi\xE8re fois, v\xE9rifier les macros
        if (stateCOF.macros) {
          //ancienne version, et on avait copi\xE9 les macros
          //on enl\xE8ve juste Escalier, et on remplace par Monter et Descendre
          let mesc = macros.find(function(m) {
            return m.get('name') == 'Escalier';
          });
          if (mesc) {
            createObj('macro', {
              name: 'Monter',
              action: "!cof-escalier",
              visibleto: '',
              istokenaction: true,
              inBar: false,
              _playerid: mesc.playerid
            });
            createObj('macro', {
              name: 'Descendre',
              action: "!cof-escalier bas",
              visibleto: '',
              istokenaction: true,
              inBar: false,
              _playerid: mesc.playerid
            });
            mesc.remove();
          }
        } else {
          gameMacros.forEach(function(m) {
            let prev =
              macros.find(function(macro) {
                return macro.get('name') == m.name;
              });
            if (prev === undefined) {
              sendChat('COF', '/w GM Macro ' + m.name + ' cr\xE9\xE9e.');
              if (m.inBar) inBar.push(m.name);
              mjs.forEach(function(playerId, i) {
                if (i === 0 || m.visibleto === '') {
                  m.playerid = playerId;
                  createObj('macro', m);
                }
              });
            }
          });
        }
      }
      if (inBar.length > 0) {
        sendChat('COF', "/w GM Macros \xE0 mettre dans la barre d'action du MJ : " + inBar.join(', '));
      }
      stateCOF.gameMacros = gameMacros;
    }
    //Utilisation des markers d'effets temporaires
    for (let effet in messageEffetTemp) {
      var ms = messageEffetTemp[effet].statusMarker;
      if (ms) effet_de_marker[ms] = effet;
    }
    // R\xE9cup\xE9ration des token Markers attach\xE9s \xE0 la campagne image, nom, tag, Id
    const markers = JSON.parse(Campaign().get("token_markers"));
    markers.forEach(function(m) {
      markerCatalog[m.name] = m;
    });
    // Option Markers personnalis\xE9s activ\xE9
    if (stateCOF.options.affichage.val.markers_personnalises.val) {
      const cof_states_perso = {
        assomme: 'status_cof-assomme',
        surpris: 'status_cof-surpris',
        renverse: 'status_cof-renverse',
        aveugle: 'status_cof-aveugle',
        affaibli: 'status_cof-affaibli',
        etourdi: 'status_cof-etourdi',
        paralyse: 'status_cof-paralyse',
        ralenti: 'status_cof-ralenti',
        immobilise: 'status_cof-immobilise',
        endormi: 'status_cof-endormi',
        apeure: 'status_cof-apeure',
        invisible: 'status_cof-invisible',
        blesse: 'status_cof-blesse',
        encombre: 'status_cof-encombre',
        penombre: 'status_cof-penombre',
        //enseveli: 'status_edge-crack' -> \xC0 dessiner
      };
      // On boucle sur la liste des \xE9tats pour v\xE9rifier que les markers sont bien pr\xE9sents !
      let markersAbsents = [];
      let ancientSet = true;
      for (let etat in cof_states_perso) {
        let markerName = cof_states_perso[etat].substring(7);
        let marker_perso = markerCatalog[markerName];
        if (marker_perso) {
          cof_states[etat] = 'status_' + marker_perso.tag;
          ancientSet = false;
        } else {
          markersAbsents.push(markerName);
        }
      }
      // Cas particulier des deux markers d'initiative
      if (markerCatalog['cof-init-ally']) {
        statusForInitAlly = 'status_' + markerCatalog['cof-init-ally'].tag;
      } else {
        markersAbsents.push('cof-init-ally');
      }
      if (markerCatalog['cof-init-enemy']) {
        statusForInitEnemy = 'status_' + markerCatalog['cof-init-enemy'].tag;
      } else {
        markersAbsents.push('cof-init-enemy');
      }
      // Cas des markers d'effet temporaire, 3 cas particuliers :
      // uniquement le tag sans "status_" devant
      registerMarkerEffet('cof-asphyxie', 'asphyxie');
      registerMarkerEffet('cof-saigne', 'saignementsSang');
      registerMarkerEffet('cof-prison-vegetale', 'prisonVegetale');
      if (!ancientSet) {
        markersAbsents.forEach(function(m) {
          log("Marker " + m + " introuvable");
        });
        log("Markers personnalis\xE9s activ\xE9s.");
      } else {
        log("Utilisation des markers par d\xE9faut");
      }
    }
    //Construction de la table markers => etat
    etat_de_marker = {};
    for (var etat in cof_states) {
      var marker = cof_states[etat].substring(7);
      etat_de_marker[marker] = etat;
    }
  }

  function etatRendInactif(etat) {
    var res =
      etat == 'mort' || etat == 'surpris' || etat == 'assomme' ||
      etat == 'etourdi' || etat == 'paralyse' || etat == 'endormi' ||
      etat == 'apeure';
    return res;
  }

  // retourne un tableau contenant la liste des ID de joueurs connect\xE9s controllant le personnage li\xE9 au Token
  function getPlayerIds(perso) {
    var character = getObj('character', perso.charId);
    if (character === undefined) return;
    var charControlledby = character.get('controlledby');
    if (charControlledby === '') return [];
    var playerIds = [];
    charControlledby.split(",").forEach(function(controlledby) {
      var player = getObj('player', controlledby);
      if (player === undefined) return;
      if (player.get('online')) playerIds.push(controlledby);
    });
    return playerIds;
  }

  function characterPageIds(charId) {
    var character = getObj('character', charId);
    if (character === undefined) return;
    var charControlledBy = character.get('controlledby');
    var playersIds = new Set();
    if (charControlledBy !== '') {
      charControlledBy.split(",").forEach(function(controlledby) {
        if (controlledby == 'all') {
          var players = findObjs({
            _type: 'player'
          });
          players.forEach(function(p) {
            if (p.get('online')) playersIds.add(p.id);
          });
        }
        var player = getObj('player', controlledby);
        if (player === undefined) return;
        if (player.get('online')) playersIds.add(controlledby);
      });
    }
    if (playersIds.size === 0) {
      findObjs({
        _type: 'player'
      }).forEach(function(p) {
        if (playerIsGM(p.id)) playersIds.add(p.id);
      });
    }
    let res = new Set();
    playersIds.forEach(function(pid) {
      res.add(getPageId(pid));
    });
    return res;
  }

  //PNJ au sens de la fiche utilis\xE9e, pas forc\xE9ment en jeu
  //perso peut ne pas avoir de token
  function persoEstPNJ(perso) {
    if (perso.pnj) return true;
    else if (perso.pj) return false;
    const typePerso = ficheAttribute(perso, 'type_personnage', 'PJ');
    perso.pnj = (typePerso == 'PNJ');
    perso.pj = !perso.pnj;
    return perso.pnj;
  }

  function getAttackName(attackLabel, perso) {
    const attaques = listAllAttacks(perso);
    const arme = attaques[attackLabel];
    if (arme === undefined) return arme;
    return arme.armenom;
  }

  function getState(personnage, etat) {
    var token = personnage.token;
    var charId = personnage.charId;
    var res = false;
    var attrInvisible = tokenAttribute(personnage, 'tokenInvisible');
    if (attrInvisible.length > 0 && token.id == attrInvisible[0].get('max')) {
      var tokenInvisible = getObj('graphic', attrInvisible[0].get('current'));
      if (tokenInvisible) token = tokenInvisible;
    }
    if (token !== undefined) {
      res = token.get(cof_states[etat]);
      if (token.get('bar1_link') === '') return res;
      // else, look for the character value, if any
      if (charId === undefined) charId = token.get('represents');
      personnage.charId = charId;
    }
    if (charId === '') {
      error("token with a linked bar1 but representing no character", token);
      return false;
    }
    if (etat == 'affaibli') { //special case due to new character sheet
      var de = ficheAttributeAsInt(personnage, 'ETATDE', 20);
      if (de === 20) {
        if (res && token !== undefined) token.set(cof_states[etat], false);
        return false;
      } else if (de === 12) {
        if (!res && token !== undefined) token.set(cof_states[etat], true);
        return true;
      }
    }
    var attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: etat
    });
    if (attr.length === 0) {
      if (res && token !== undefined) token.set(cof_states[etat], false);
      return false;
    }
    if (!res && token !== undefined) token.set(cof_states[etat], true);
    return true;
  }

  //Met le champ field \xE0 value du token dans evt, pour permettre le undo
  function affectToken(token, field, value, evt) {
    evt.affectes = evt.affectes || {};
    var aff = evt.affectes[token.id];
    if (aff === undefined) {
      aff = {
        affecte: token,
        prev: {}
      };
      evt.affectes[token.id] = aff;
    }
    if (aff.prev[field] === undefined) aff.prev[field] = value;
    return aff;
  }

  function estAffaibli(perso) {
    if (perso.affaibli !== undefined) return perso.affaibli;
    if (getState(perso, 'affaibli')) {
      perso.affaibli = true;
      return true;
    }
    if (getState(perso, 'blesse')) {
      perso.affaibli = true;
      return true;
    }
    perso.affaibli = false;
    return false;
  }

  function setToken(token, field, newValue, evt) {
    var prevValue = token.get(field);
    affectToken(token, field, prevValue, evt);
    token.set(field, newValue);
  }

  function isActive(perso) {
    let inactif =
      getState(perso, 'mort') || getState(perso, 'surpris') ||
      getState(perso, 'assomme') || getState(perso, 'etourdi') ||
      getState(perso, 'paralyse') || getState(perso, 'endormi') ||
      getState(perso, 'apeure') || attributeAsBool(perso, 'statueDeBois');
    return !inactif;
  }

  function sendChar(charId, msg, checkAlias) {
    let dest = '';
    if (charId) {
      if (checkAlias) {
        let attrDisplay = charAttribute(charId, 'displayname', {
          caseInsensitive: true
        });
        if (attrDisplay.length > 0 && attrDisplay[0].get('current') == '@{alias}') {
          var attrAlias = charAttribute(charId, 'alias', {
            caseInsensitive: true
          });
          if (attrAlias.length > 0) {
            msg = attrAlias[0].get('current') + ' ' + msg;
          } else {
            dest = 'character|' + charId;
          }
        } else {
          dest = 'character|' + charId;
        }
      } else {
        dest = 'character|' + charId;
      }
    }
    sendChat(dest, msg);
  }

  //Chuchote le message \xE0 tous les joueurs pr\xE9sents qui controllent le
  //personnage, plus le MJ
  function whisperChar(charId, msg) {
    var character = getObj('character', charId);
    if (character) {
      var controlled = character.get('controlledby');
      if (controlled.includes('all')) sendChar(charId, msg);
      else {
        controlled.split(',').forEach(function(c) {
          if (c !== '' && !playerIsGM(c)) {
            var p = getObj('player', c);
            if (p && p.get('online')) {
              sendChar(charId, '/w "' + p.get('_displayname') + '" ' + msg);
            }
          }
        });
        sendChar(charId, "/w GM " + msg);
      }
    } else {
      sendChar(charId, "/w GM " + msg);
    }
  }

  function sendPerso(perso, msg, secret) {
    if (perso.token && perso.token.get('bar1_link') === '') {
      msg = perso.token.get('name') + ' ' + msg;
      if (secret) {
        var character = getObj('character', perso.charId);
        if (character) {
          var controlled = character.get('controlledby');
          if (controlled.includes('all')) sendChat('', msg);
          else {
            controlled.split(',').forEach(function(c) {
              if (c !== '' && !playerIsGM(c)) {
                var p = getObj('player', c);
                if (p && p.get('online')) {
                  sendChat('', '/w "' + p.get('_displayname') + '" ' + msg);
                }
              }
            });
            sendChat('', "/w GM " + msg);
          }
        } else sendChat('', msg);
      } else sendChat('', msg);
    } else {
      if (secret) whisperChar(perso.charId, msg);
      else {
        if (perso.alias === undefined) {
          perso.alias =
            ficheAttribute(perso, 'displayname', '@{character_name}') == '@{alias}';
        }
        if (perso.alias) sendChat('', perso.token.get('name') + ' ' + msg);
        else sendChar(perso.charId, msg);
      }
    }
  }

  const couleurType = {
    'normal': {
      background: '#F1E6DA',
      color: '#000'
    },
    'magique': {
      background: '#FFFFFF',
      color: '#534200'
    },
    'maladie': { //Pour l'instant, comme normal
      background: '#F1E6DA',
      color: '#000'
    },
    'feu': {
      background: '#FF3011',
      color: '#440000'
    },
    'froid': {
      background: '#77FFFF',
      color: '#004444'
    },
    'acide': {
      background: '#80BF40',
      color: '#020401'
    },
    'sonique': {
      background: '#E6CCFF',
      color: '#001144'
    },
    'electrique': {
      background: '#FFFF80',
      color: '#222200'
    },
    'poison': {
      background: '#58000',
      color: '#DDAFF'
    },
    'argent': {
      background: '#F1E6DA',
      color: '#C0C0C0'
    },
    'drain': {
      background: '#0D1201',
      color: '#E8F5C9'
    },
    'energie': {
      background: '#FFEEAA',
      color: '#221100'
    },
  };

  // options: bonus:int, deExplosif:bool, nbDes:int, type
  //Renvoie 1dk + bonus, avec le texte
  //champs val et roll
  function rollDePlus(de, options) {
    options = options || {};
    options.nbDes = options.nbDes || 1;
    let count = options.nbDes;
    let bonus = options.bonus || 0;
    let explose = options.deExplosif || false;
    let texteJetDeTotal = '';
    let jetTotal = 0;
    do {
      let jetDe = randomInteger(de);
      texteJetDeTotal += jetDe;
      jetTotal += jetDe;
      explose = explose && (jetDe === de);
      if (explose) {
        texteJetDeTotal += ',';
      } else {
        count--;
        if (count > 0) {
          texteJetDeTotal += ',';
        }
      }
    } while ((explose || count > 0) && jetTotal < 1000);
    let res = {
      val: jetTotal + bonus
    };
    let style = 'display: inline-block; border-radius: 5px; padding: 0 4px;';
    let type = options.type || 'normal';
    let couleurs = couleurType[type];
    if (couleurs === undefined) couleurs = couleurType.normal;
    style += ' background-color: ' + couleurs.background + ';';
    style += ' color: ' + couleurs.color + ';';
    let msg = '<span style="' + style + '"';
    msg += ' title="' + options.nbDes + 'd' + de;
    if (options.deExplosif) msg += '!';
    if (bonus > 0) {
      msg += '+' + bonus;
      texteJetDeTotal += '+' + bonus;
    } else if (bonus < 0) {
      msg += bonus;
      texteJetDeTotal += bonus;
    }
    msg += ' = ' + texteJetDeTotal + '" class="a inlinerollresult showtip tipsy-n">';
    msg += res.val + "</span>";
    res.roll = msg;
    return res;
  }

  //Si evt est d\xE9fini, alors on consid\xE8re qu'il faut y mettre la valeur actuelle
  function updateCurrentBar(perso, barNumber, val, evt, maxVal) {
    var token = perso.token;
    var prevToken;
    var HTdeclared;
    try {
      HTdeclared = HealthColors;
    } catch (e) {
      if (e.name != "ReferenceError") throw (e);
    }
    if (HTdeclared) {
      //Pour pouvoir annuler les effets de HealthColor sur le statut
      affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
      prevToken = JSON.parse(JSON.stringify(token));
    }
    var fieldv = 'bar' + barNumber + '_value';
    var fieldm;
    if (maxVal) fieldm = 'bar' + barNumber + '_max';
    var attrId = token.get('bar' + barNumber + '_link');
    var attr;
    if (attrId !== '') attr = getObj('attribute', attrId);
    if (attr === undefined) {
      var prevVal = token.get(fieldv);
      if (evt) affectToken(token, fieldv, prevVal, evt);
      token.set(fieldv, val);
      if (maxVal) {
        if (evt) affectToken(token, fieldm, token.get(fieldm), evt);
        token.set(fieldm, val);
      }
      if (HTdeclared) HealthColors.Update(token, prevToken);
      return;
    }
    if (evt) {
      evt.attributes = evt.attributes || [];
      evt.attributes.push({
        attribute: attr,
        current: attr.get('current'),
        max: attr.get('max'),
      });
    }
    let aset = {
      current: val,
      withWorker: true
    };
    if (maxVal) aset.max = maxVal;
    attr.setWithWorker(aset);
    if (HTdeclared) HealthColors.Update(token, prevToken);
    //Gestion du lien des PVs entre familier et son ma\xEEtre
    if (barNumber == 1) {
      let persoLie = charAttribute(perso.charId, 'PVPartagesAvec');
      if (persoLie.length > 0) {
        persoLie = persoLie[0].get('current');
        persoLie = findObjs({
          _type: 'character',
          name: persoLie
        });
        if (persoLie.length > 0) {
          let attrLie = charAttribute(persoLie[0].id, 'pv', {
            caseInsensitive: true
          });
          if (attrLie.length > 0) {
            attrLie = attrLie[0];
            if (evt) {
              evt.attributes.push({
                attribute: attrLie,
                current: attrLie.get('current'),
                max: attrLie.get('max')
              });
            }
            attrLie.setWithWorker(aset);
          }
        }
      }
    }
  }

  function getValeurOfEffet(perso, effet, def, predDef) {
    var attrsVal = tokenAttribute(perso, effet + 'Valeur');
    if (attrsVal.length === 0) {
      if (predDef) return predicateAsInt(perso, predDef, def);
      return def;
    }
    var res = parseInt(attrsVal[0].get('current'));
    if (isNaN(res)) return def;
    return res;
  }

  function getTokenFields(token, pageId, charId) {
    return {
      _pageid: pageId || token.get('pageid'),
      imgsrc: token.get('imgsrc'),
      represents: charId || token.get('represents'),
      left: token.get('left'),
      top: token.get('top'),
      width: token.get('width'),
      height: token.get('height'),
      rotation: token.get('rotation'),
      layer: token.get('layer'),
      flipv: token.get('flipv'),
      fliph: token.get('fliph'),
      name: token.get('name'),
      tooltip: token.get('tooltip'),
      show_tooltip: token.get('show_tooltip'),
      controlledby: token.get('controlledby'),
      bar1_link: token.get('bar1_link'),
      bar2_link: token.get('bar2_link'),
      bar3_link: token.get('bar3_link'),
      bar1_value: token.get('bar1_value'),
      bar2_value: token.get('bar2_value'),
      bar3_value: token.get('bar3_value'),
      bar1_max: token.get('bar1_max'),
      bar2_max: token.get('bar2_max'),
      bar3_max: token.get('bar3_max'),
      bar_location: token.get('bar_location'),
      compact_bar: token.get('compact_bar'),
      aura1_radius: token.get('aura1_radius'),
      aura2_radius: token.get('aura2_radius'),
      aura1_color: token.get('aura1_color'),
      aura2_color: token.get('aura2_color'),
      aura1_square: token.get('aura1_square'),
      aura2_square: token.get('aura2_square'),
      tint_color: token.get('tint_color'),
      statusmarkers: token.get('statusmarkers'),
      showname: token.get('showname'),
      showplayers_name: token.get('showplayers_name'),
      showplayers_bar1: token.get('showplayers_bar1'),
      showplayers_bar2: token.get('showplayers_bar2'),
      showplayers_bar3: token.get('showplayers_bar3'),
      showplayers_aura1: token.get('showplayers_aura1'),
      showplayers_aura2: token.get('showplayers_aura2'),
      playersedit_name: token.get('playersedit_name'),
      playersedit_bar1: token.get('playersedit_bar1'),
      playersedit_bar2: token.get('playersedit_bar2'),
      playersedit_bar3: token.get('playersedit_bar3'),
      playersedit_aura1: token.get('playersedit_aura1'),
      playersedit_aura2: token.get('playersedit_aura2'),
      lastmove: token.get('lastmove'),
      sides: token.get('sides'),
      currentSide: token.get('currentSide'),
      /* Dynamic Lighting */
      has_bright_light_vision: token.get('has_bright_light_vision'),
      has_night_vision: token.get('has_night_vision'),
      night_vision_distance: token.get('night_vision_distance'),
      emits_bright_light: token.get('emits_bright_light'),
      bright_light_distance: token.get('bright_light_distance'),
      emits_low_light: token.get('emits_low_light'),
      low_light_distance: token.get('low_light_distance'),
      light_sensitivity_multiplier: token.get('light_sensitivity_multiplier'),
      night_vision_effect: token.get('night_vision_effect'),
      has_limit_field_of_vision: token.get('has_limit_field_of_vision'),
      limit_field_of_vision_center: token.get('limit_field_of_vision_center'),
      limit_field_of_vision_total: token.get('limit_field_of_vision_total'),
      has_limit_field_of_night_vision: token.get('has_limit_field_of_night_vision'),
      limit_field_of_night_vision_center: token.get('limit_field_of_night_vision_center'),
      limit_field_of_night_vision_total: token.get('limit_field_of_night_vision_total'),
      has_directional_bright_light: token.get('has_directional_bright_light'),
      directional_bright_light_center: token.get('directional_bright_light_center'),
      directional_bright_light_total: token.get('directional_bright_light_total'),
      has_directional_dim_light: token.get('has_directional_dim_light'),
      directional_dim_light_center: token.get('directional_dim_light_center'),
      directional_dim_light_total: token.get('directional_dim_light_total'),
      light_color: token.get('light_color'),
      /* Legacy Dynamic Lighting */
      light_radius: token.get('light_radius'),
      light_dimradius: token.get('light_dimradius'),
      light_otherplayers: token.get('light_otherplayers'),
      light_hassight: token.get('light_hassight'),
      light_angle: token.get('light_angle'),
      light_losangle: token.get('light_losangle'),
      light_multiplier: token.get('light_multiplier'),
      adv_fow_view_distance: token.get('adv_fow_view_distance'),
    };
  }

  //options peut contenir
  // msg: un message \xE0 afficher
  // maxVal: la valeur max de l'attribut
  // secret: le message n'est pas affich\xE9 pour tout le monde.
  // charAttr: si pr\xE9sent, on utilise un attribut de personnage
  // renvoie l'attribut cr\xE9\xE9 ou mis \xE0 jour
  function setTokenAttr(personnage, attribute, value, evt, options) {
    let charId = personnage.charId;
    let token = personnage.token;
    let maxval = '';
    if (options && options.maxVal !== undefined) maxval = options.maxVal;
    if (options && options.msg !== undefined) {
      sendPerso(personnage, options.msg, options.secret);
    }
    evt.attributes = evt.attributes || [];
    let fullAttribute = fullAttributeName(personnage, attribute, options);
    if (fullAttribute === undefined) {
      let args = {
        personnage,
        attribute,
        value,
        options
      };
      let name = 'inconnu';
      if (token) name = token.get('name');
      error("Cr\xE9ation d'un attribut undefined pour " + name, args);
      return;
    }
    let attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: fullAttribute
    });
    if (attr.length === 0) {
      attr = createObj('attribute', {
        characterid: charId,
        name: fullAttribute,
        current: value,
        max: maxval
      });
      evt.attributes.push({
        attribute: attr,
      });
      if (token) {
        let pageId = token.get('pageid');
        switch (attribute) {
          case 'agrandissement':
            let width = token.get('width');
            let height = token.get('height');
            affectToken(token, 'width', width, evt);
            affectToken(token, 'height', height, evt);
            width += width / 2;
            height += height / 2;
            token.set('width', width);
            token.set('height', height);
            break;
          case 'formeDArbre':
            //On copie les PVs pour pouvoir les restaurer \xE0 la fin de l'effet
            setTokenAttr(personnage, 'anciensPV', token.get('bar1_value'), evt, {
              maxVal: token.get('bar1_max')
            });
            //On va cr\xE9er une copie de token, mais avec une image d'arbre
            let tokenFields = getTokenFields(token, pageId, personnage.charId);
            let tokenArbre;
            let imageArbre = findObjs({
              _type: 'attribute',
              _characterid: personnage.charId,
              name: 'tokenFormeDArbre'
            });
            if (imageArbre.length > 0) {
              tokenFields.imgsrc = imageArbre[0].get('current');
              tokenArbre = createObj('graphic', tokenFields);
            }
            if (tokenArbre === undefined) {
              tokenFields.imgsrc = stateCOF.options.images.val.image_arbre.val;
              tokenArbre = createObj('graphic', tokenFields);
            }
            if (tokenArbre) {
              evt.tokens = evt.tokens || [];
              evt.tokens.push(tokenArbre);
              //On met l'ancien token dans le gmlayer, car si l'image vient du marketplace, il est impossible de le recr\xE9er depuis l'API
              setToken(token, 'layer', 'gmlayer', evt);
              setTokenAttr(personnage, 'changementDeToken', true, evt);
              replaceInTurnTracker(token.id, tokenArbre.id, evt);
              personnage.token = tokenArbre;
              token = tokenArbre;
            }
            //On met maintenant les nouveaux PVs
            //selon Kegron http://www.black-book-editions.fr/forums.php?topic_id=4800&tid=245841#msg245841
            let niveau = ficheAttributeAsInt(personnage, 'niveau', 1);
            let nouveauxPVs = getValeurOfEffet(personnage, 'formeDArbre', niveau * 5);
            updateCurrentBar(personnage, 1, nouveauxPVs, evt, nouveauxPVs);
            //L'initiative change
            initPerso(personnage, evt, true);
            break;
          case 'bloqueManoeuvre':
          case 'enveloppePar':
          case 'prisonVegetale':
          case 'statueDeBois':
            nePlusSuivre(personnage, pageId, evt);
            break;
          case 'armeeDesMorts':
            affectToken(personnage.token, "aura2_radius", personnage.token.get("aura2_radius"), evt);
            affectToken(personnage.token, "aura2_color", personnage.token.get("aura2_color"), evt);
            affectToken(personnage.token, "showplayers_aura2", personnage.token.get("showplayers_aura2"), evt);
            personnage.token.set("aura2_radius", 20);
            personnage.token.set("aura2_color", "#b6d7a8");
            personnage.token.set("showplayers_aura2", true);
            break;
          case 'armeeDesMortsPuissant':
            personnage.token.set("aura2_radius", 28);
            break;
          case 'armeeDesMortsTempeteDeManaIntense':
            personnage.token.set("aura2_radius", Math.floor(20 * Math.sqrt(1 + value)));
            break;
        }
      }
      return attr;
    }
    attr = attr[0];
    evt.attributes.push({
      attribute: attr,
      current: attr.get('current'),
      max: attr.get('max')
    });
    attr.set('current', value);
    if (options && options.maxVal !== undefined) attr.set('max', maxval);
    return attr;
  }

  // evt peut \xEAtre undefined
  // options peut avoir les champs msg et secret
  function removeTokenAttr(personnage, attribute, evt, options) {
    attribute = fullAttributeName(personnage, attribute, options);
    let attr = findObjs({
      _type: 'attribute',
      _characterid: personnage.charId,
      name: attribute
    });
    if (attr.length === 0) return;
    if (options && options.msg !== undefined) {
      sendPerso(personnage, options.msg, options.secret);
    }
    attr = attr[0];
    if (evt) {
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attr);
    }
    attr.remove();
  }

  function removeCharAttr(charId, attribute, evt, msg) {
    removeTokenAttr({
      charId: charId
    }, attribute, evt, {
      msg: msg
    });
  }

  //cherche l'attribut attribute de valeur par d\xE9faut def
  //et lui ajoute la valeur val. Cr\xE9e l'attribut si besoin
  //retourne la nouvelle valeur de l'attribut
  function addToAttributeAsInt(perso, attribute, def, val, evt) {
    evt.attributes = evt.attributes || [];
    let fullAttribute = fullAttributeName(perso, attribute);
    let attr = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
      name: fullAttribute
    });
    if (attr.length === 0) {
      attr = createObj('attribute', {
        characterid: perso.charId,
        name: fullAttribute,
        current: def + val,
      });
      evt.attributes.push({
        attribute: attr,
      });
      return def + val;
    }
    attr = attr[0];
    let c = parseInt(attr.get('current'));
    evt.attributes.push({
      attribute: attr,
      current: c
    });
    if (isNaN(c)) c = def;
    c += val;
    attr.set('current', c);
    return c;
  }

  //fonction avec callback, mais synchrone
  // n'ajoute pas evt \xE0 l'historique
  function soigneToken(perso, soins, evt, callTrue, callMax, options) {
    options = options || {};
    let token = perso.token;
    let bar1 = parseInt(token.get("bar1_value"));
    let pvmax = parseInt(token.get("bar1_max"));
    if (isNaN(bar1) || isNaN(pvmax)) {
      error("Soins sur un token sans points de vie", token);
      return;
    }
    let updateBar1;
    if (bar1 >= pvmax) bar1 = pvmax;
    else updateBar1 = true;
    if (soins < 0) soins = 0;
    let nonSoignable = 0;
    //Update des dm suivis
    let attrs = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    let regSuivis = '^DMSuivis([^_]+)';
    let link = token.get('bar1_link');
    if (link === '') regSuivis += "_" + token.get('name') + '$';
    else regSuivis += '$';
    regSuivis = new RegExp(regSuivis);
    var soinsSuivis = soins;
    var soinsImpossible = new Set(options.saufDMType);
    attrs.forEach(function(a) {
      if (soinsSuivis === 0) return;
      var an = a.get('name');
      an = an.match(regSuivis);
      if (an && an.length > 0) {
        var ds = parseInt(a.get('current'));
        if (ds > 0) {
          if (an[0].length < 2) {
            error("Match non trouv\xE9 pour les soins", an);
            return;
          }
          if (soinsImpossible.has(an[1])) {
            nonSoignable += ds;
          } else {
            if (ds > soinsSuivis) {
              evt.attributes = evt.attributes || [];
              evt.attributes.push({
                attribute: a,
                current: ds
              });
              ds -= soinsSuivis;
              a.set('current', ds);
              soinsSuivis = 0;
            } else {
              soinsSuivis -= ds;
              ds = 0;
            }
          }
        } else ds = 0;
        if (ds === 0) {
          evt.deletedAttributes = evt.deletedAttributes || [];
          evt.deletedAttributes.push(a);
          a.remove();
        }
      }
    });
    pvmax -= nonSoignable;
    if (bar1 === 0) {
      if (attributeAsBool(perso, 'etatExsangue')) {
        removeTokenAttr(perso, 'etatExsangue', evt, {
          msg: "retrouve des couleurs"
        });
      } else if (getState(perso, 'mort')) {
        setState(perso, 'renverse', true, evt);
        setState(perso, 'mort', false, evt);
      }
    }
    if (predicateAsBool(perso, 'vieArtificielle')) {
      soins = Math.floor(soins / 2);
    }
    bar1 += soins;
    var soinsEffectifs = soins;
    if (bar1 > pvmax) {
      if (attributeAsBool(perso, 'formeDArbre')) {
        var apv = tokenAttribute(perso, 'anciensPV');
        if (apv.length > 0) {
          apv = apv[0];
          var anciensPV = parseInt(apv.get('current'));
          var anciensMax = parseInt(apv.get('max'));
          if (!(isNaN(anciensPV) || isNaN(anciensMax)) &&
            anciensPV < anciensMax) {
            var soinsTransferes = bar1 - pvmax;
            if (anciensMax - anciensPV < soinsTransferes)
              soinsTransferes = anciensMax - anciensPV;
            anciensPV += soinsTransferes;
            bar1 -= soinsTransferes;
            setTokenAttr(perso, 'anciensPV', anciensPV, evt, {
              maxVal: anciensMax
            });
          }
        }
      }
      // On  cherche si il y a des DM temporaires \xE0 soigner
      if (bar1 > pvmax) {
        let hasMana = (ficheAttributeAsInt(perso, 'PM', 0) > 0);
        let dmgTemp;
        const estMook = token.get('bar1_link') === '';
        if (hasMana) {
          if (estMook) dmgTemp = attributeAsInt(perso, 'DMTEMP', 0);
          else dmgTemp = ficheAttributeAsInt(perso, 'DMTEMP', 0);
        } else {
          dmgTemp = parseInt(token.get('bar2_value'));
          if (isNaN(dmgTemp)) dmgTemp = 0;
        }
        if (dmgTemp > 0) {
          var newDmgTemp = dmgTemp - bar1 + pvmax;
          if (newDmgTemp < 0) {
            newDmgTemp = 0;
            bar1 -= dmgTemp;
          } else bar1 = pvmax;
          if (hasMana) setTokenAttr(perso, 'DMTEMP', newDmgTemp, evt);
          else updateCurrentBar(perso, 2, newDmgTemp, evt);
        }
        soinsEffectifs -= (bar1 - pvmax);
        bar1 = pvmax;
      }
    }
    if (bar1 == pvmax && attributeAsBool(perso, 'osBrises')) {
      removeTokenAttr(perso, 'osBrises', evt, {
        msg: "soigne ses os"
      });
    }
    if (updateBar1) updateCurrentBar(perso, 1, bar1, evt);
    if (soinsEffectifs > 0) {
      if (!options.recuperation) {
        if (attributeAsBool(perso, 'blessureQuiSaigne')) {
          removeTokenAttr(perso, 'blessureQuiSaigne', evt, {
            msg: ": les soins referment la blessure"
          });
          removeTokenAttr(perso, 'blessureQuiSaignePuissant', evt);
          removeTokenAttr(perso, 'blessureQuiSaigneValeur', evt);
          removeTokenAttr(perso, 'blessureQuiSaigneSaveParTour', evt);
          removeTokenAttr(perso, 'blessureQuiSaigneSaveParTourType', evt);
          removeTokenAttr(perso, 'blessureQuiSaigneTempeteDeManaIntense', evt);
          removeTokenAttr(perso, 'blessureQuiSaigneOptions', evt);
        }
        if (attributeAsBool(perso, 'reactionAllergique')) {
          removeTokenAttr(perso, 'reactionAllergique', evt, {
            msg: ": les soins mettent fin \xE0 la r\xE9action allergique"
          });
        }
      }
      if (callTrue) callTrue(soinsEffectifs);
    } else {
      if (callMax) callMax();
    }
  }

  function splitIdName(idn) {
    var pos = idn.indexOf(' ');
    if (pos < 1 || pos >= idn.length) {
      error("IdName mal form\xE9", idn);
      return;
    }
    var name = idn.substring(pos + 1);
    return {
      id: idn.substring(0, pos),
      name: name
    };
  }

  //Renvoie le token et le charId. Si l'id ne correspond \xE0 rien, cherche si
  //on trouve un nom de token, sur la page pass\xE9e en argument (ou sinon
  //sur la page active de la campagne)
  function persoOfId(id, name, pageId) {
    let token = getObj('graphic', id);
    if (token === undefined) {
      if (name === undefined) return undefined;
      if (pageId === undefined) {
        pageId = Campaign().get('playerpageid');
      }
      let tokens = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        name: name
      });
      if (tokens.length === 0) return undefined;
      if (tokens.length > 1) {
        error("Ambig\xFCit\xE9 sur le choix d'un token : il y a " +
          tokens.length + " tokens nomm\xE9s " + name, tokens);
      }
      token = tokens[0];
    }
    var charId = token.get('represents');
    if (charId === '') {
      error("le token s\xE9lectionn\xE9 ne repr\xE9sente pas de personnage", token);
      return undefined;
    }
    return {
      token: token,
      charId: charId
    };
  }

  //Retourne le perso correspondant \xE0 un token id suivi du nom de token
  //Permet d'avoir une information robuste en cas d'interruption du script
  function persoOfIdName(idn, pageId) {
    var sp = splitIdName(idn);
    if (sp === undefined) return;
    var perso = persoOfId(sp.id, sp.name, pageId);
    if (perso === undefined) {
      log("Impossible de trouver le personnage correspondant \xE0 " + sp.name);
      return;
    }
    perso.tokName = perso.token.get('name');
    if (perso.tokName == sp.name) return perso;
    log("En cherchant le token " + idn + ", on trouve " + perso.tokName);
    log(perso);
    return perso;
  }

  function computeScale(pageId) {
    const page = getObj("page", pageId);
    let scale = parseFloat(page.get('scale_number'));
    if (isNaN(scale) || scale <= 0) return 1.0;
    var cellSize = parseFloat(page.get('snapping_increment'));
    if (!isNaN(cellSize) && cellSize > 0) scale /= cellSize;
    const unit = page.get('scale_units');
    switch (unit) {
      case 'ft':
        scale *= 0.3048;
        break;
      case 'cm':
        scale *= 0.01;
        break;
      case 'km':
        scale *= 1000;
        break;
      case 'mi':
        scale *= 1609.34;
        break;
      case 'in':
        scale *= 0.0254;
        break;
    }
    return scale;
  }

  function persoOfToken(token) {
    var charId = token.get('represents');
    if (charId === '') {
      return undefined;
    }
    return {
      token: token,
      charId: charId
    };
  }

  //options peut avoir les champs:
  // - strict1 = true si on consid\xE8re que tok1 doit avoir une taille nulle
  // - strict2
  // - allonge
  function distanceCombat(tok1, tok2, pageId, options) {
    if (pageId === undefined) {
      pageId = tok1.get('pageid');
    }
    options = options || {};
    //perso mont\xE9s
    var pseudoTok1 = tok1;
    if (!options.strict1) {
      var perso1 = persoOfToken(tok1);
      if (perso1) {
        var attrMonture1 = tokenAttribute(perso1, 'monteSur');
        if (attrMonture1.length > 0) {
          var pseudoPerso1 = persoOfId(attrMonture1[0].get('current'), attrMonture1[0].get('max'), pageId);
          if (pseudoPerso1) pseudoTok1 = pseudoPerso1.token;
        }
      }
    }
    var pseudoTok2 = tok2;
    if (!options.strict2) {
      var perso2 = persoOfToken(tok2);
      if (perso2) {
        var attrMonture2 = tokenAttribute(perso2, 'monteSur');
        if (attrMonture2.length > 0) {
          var pseudoPerso2 = persoOfId(attrMonture2[0].get('current'), attrMonture2[0].get('max'), pageId);
          if (pseudoPerso2) pseudoTok2 = pseudoPerso2.token;
        }
      }
    }
    let scale = computeScale(pageId);
    let pt1 = tokenCenter(pseudoTok1);
    let pt2 = tokenCenter(pseudoTok2);
    let distance_pix = VecMath.length(VecMath.vec(pt1, pt2));
    if (!options.strict1) distance_pix -= tokenSize(pseudoTok1, PIX_PER_UNIT / 2);
    if (!options.strict2) distance_pix -= tokenSize(pseudoTok2, PIX_PER_UNIT / 2);
    if (options.allonge) distance_pix -= (options.allonge * PIX_PER_UNIT) / scale;
    if ((!options.strict1 || !options.strict2) && distance_pix < PIX_PER_UNIT * 1.3) return 0; //cases voisines
    return ((distance_pix / PIX_PER_UNIT) * scale);
  }

  //Attention, seulement faire pour les tokens avec une image dans la librairie
  //C'est toujours le cas pour un token cr\xE9\xE9 par le script
  function deleteTokenWithUndo(token, evt) {
    let tokenFields = getTokenFields(token);
    evt.deletedTokens = evt.deletedTokens || [];
    evt.deletedTokens.push(tokenFields);
    token.remove();
  }

  function finDEffet(attr, effet, attrName, charId, evt, options) { //L'effet arrive en fin de vie, doit \xEAtre supprim\xE9
    options = options || {};
    evt.deletedAttributes = evt.deletedAttributes || [];
    var res;
    var newInit = [];
    var efComplet = effetComplet(effet, attrName);
    //Si on a un attrSave, alors on a d\xE9j\xE0 imprim\xE9 le message de fin d'effet
    if (options.attrSave) { //on a un attribut associ\xE9 \xE0 supprimer)
      evt.deletedAttributes.push(options.attrSave);
      options.attrSave.remove();
    } else if (options.gardeAutresAttributs === undefined) { //On cherche si il y en a un
      enleverEffetAttribut(charId, efComplet, attrName, 'SaveParTour', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'SaveParTourType', evt);
    }
    var mEffet = messageEffetTemp[effet];
    if (mEffet === undefined) mEffet = messageEffetCombat[effet];
    if (mEffet && mEffet.statusMarker) {
      iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
        affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
        token.set('status_' + mEffet.statusMarker, false);
      }, {
        tousLesTokens: true
      });
    }
    var character;
    switch (effet) {
      case 'agrandissement': //redonner sa taille normale
        character = getObj('character', charId);
        if (character === undefined) {
          error("Personnage introuvable");
          return;
        }
        character.get('defaulttoken', function(normalToken) {
          if (normalToken === '') return;
          normalToken = JSON.parse(normalToken);
          var largeWidth = normalToken.width + normalToken.width / 2;
          var largeHeight = normalToken.height + normalToken.height / 2;
          iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
            var width = token.get('width');
            var height = token.get('height');
            affectToken(token, 'width', width, evt);
            token.set('width', normalToken.width);
            affectToken(token, 'height', height, evt);
            token.set('height', normalToken.height);
          }, {
            filterAffected: function(token) {
              if (token.get('width') == largeWidth) return true;
              if (token.get('height') == largeHeight) return true;
              return false;
            }
          });
        });
        break;
      case 'aveugleTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'aveugle', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'ralentiTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'ralenti', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'paralyseTemp':
      case 'paralyseGoule':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'paralyse', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'immobiliseTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'immobilise', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'etourdiTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'etourdi', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'affaibliTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'affaibli', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'assommeTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'assomme', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'invisibleTemp':
      case 'intangibleInvisible':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'invisible', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'apeureTemp':
      case 'peurEtourdi':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'apeure', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'ombreMortelle':
      case 'dedoublement':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
          deleteTokenWithUndo(token, evt);
        });
        break;
      case 'murDeForce':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
          let attrM = tokenAttribute({
            charId: charId,
            token: token
          }, 'murDeForceId');
          if (attrM.length === 0) return;
          let imageMur = getObj('graphic', attrM[0].get('current'));
          if (imageMur) {
            imageMur.remove();
          }
          attrM[0].remove();
        });
        break;
      case 'regeneration': //faire les soins restants
        let toursRestant = parseInt(attr.get('current'));
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            let perso = {
              token: token,
              charId: charId
            };
            if (!isNaN(toursRestant) && toursRestant > 0) {
              let regen = getValeurOfEffet(perso, 'regeneration', 3);
              let soins = regen * (toursRestant + attributeAsInt(perso, 'regenerationTempeteDeManaIntense', 0));
              soigneToken(perso, soins, evt,
                function(s) {
                  options.print = function(m) {}; //Pour ne pas afficher le message final.
                  let tempsEffectif = Math.ceil(s / regen);
                  sendPerso(perso, "r\xE9cup\xE8re encore " + s + " PV en " + tempsEffectif + " tours.");
                });
            }
            //R\xE9g\xE9n\xE9ration d'une carac physique affaiblie de 1d4, si il y en a.
            if (attributeAsInt(perso, 'affaiblissementdeconstitution', 0) > 0) {
              let d4 = rollDePlus(4);
              diminueAffaiblissement(perso, 'constitution', d4.val, evt);
              sendPerso(perso, "r\xE9cup\xE8re " + d4.roll + " points de constitution");
            } else if (attributeAsInt(perso, 'affaiblissementdeforce', 0) > 0) {
              let d4 = rollDePlus(4);
              diminueAffaiblissement(perso, 'force', d4.val, evt);
              sendPerso(perso, "r\xE9cup\xE8re " + d4.roll + " points de force");
            } else if (attributeAsInt(perso, 'affaiblissementdedexterite', 0) > 0) {
              let d4 = rollDePlus(4);
              diminueAffaiblissement(perso, 'dexterite', d4.val, evt);
              sendPerso(perso, "r\xE9cup\xE8re " + d4.roll + " points de dext\xE9rit\xE9");
            }
          });
        break;
      case 'demonInvoque':
      case 'predateurConjure':
      case 'arbreAnime':
      case 'objetAnime':
      case 'degradationZombie': //effacer le personnage
        //Dans le cas d'un Zombie, diminuer la limite du n\xE9cromant si n\xE9cessaire
        if (effet == 'degradationZombie') {
          let attrNecromant = charAttribute(charId, 'necromant');
          if (attrNecromant.length > 0) {
            let id = attrNecromant[0].get('current');
            let necromant = persoOfId(id, id, options.pageId);
            if (necromant) {
              let attrNbZombie = tokenAttribute(necromant, 'zombiesControles');
              if (attrNbZombie.length > 0) {
                let nbZombie = attrAsInt(attrNbZombie, 1);
                if (nbZombie > 1)
                  setTokenAttr(necromant, 'zombiesControles', nbZombie - 1, evt);
                else attrNbZombie[0].remove();
              }
            }
          }
        }
        if (effet == 'objetAnime') {
          let attr = charAttribute(charId, 'objetAnimePar');
          if (attr.length > 0) {
            let nid = attr[0].get("current");
            let lanceur = persoOfIdName(nid, options.pageId);
            if (lanceur) {
              let attrNbObjets = tokenAttribute(lanceur, 'niveauDesObjetsAnimes');
              if (attrNbObjets.length > 0) {
                let niveauObjets = ficheAttributeAsInt({
                  charId
                }, 'niveau', 1);
                let nbObjets = attrAsInt(attrNbObjets, niveauObjets);
                if (nbObjets > niveauObjets)
                  setTokenAttr(lanceur, 'niveauDesObjetsAnimes', nbObjets - niveauObjets, evt);
                else attrNbObjets[0].remove();
              }
            }
          }
        }
        //On efface d'abord les attributs et les abilities
        let charAttributes = findObjs({
          _type: 'attribute',
          _characterid: charId
        });
        charAttributes.forEach(
          function(otherAttr) {
            if (otherAttr.id != attr.id) otherAttr.remove();
          }
        );
        let charAbilities = findObjs({
          _type: 'ability',
          _characterid: charId
        });
        charAbilities.forEach(
          function(ab) {
            ab.remove();
          }
        );
        if (effet == 'arbreAnime' || (effet == 'objetAnime' && charPredicateAsBool(charId, 'animeAPartirDExistant'))) {
          iterTokensOfAttribute(charId, options.pageId, effet, attrName,
            function(token) {
              let perso = {
                token: token,
                charId: charId
              };
              let nA = removeFromTurnTracker(perso, evt);
              if (nA) {
                res = res || {};
                res.oldTokenId = token.id;
                res.newTokenId = nA.nextId;
              }
              setToken(token, 'bar1_link', '', evt);
              setToken(token, 'bar1_value', '', evt);
              setToken(token, 'bar1_max', '', evt);
              setToken(token, 'showplayers_bar1', false, evt);
              setToken(token, 'represents', '', evt);
              setToken(token, 'showname', false, evt);
              setToken(token, 'showplayers_name', false, evt);
              setToken(token, 'name', '', evt);
            });
        } else {
          iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
            let perso = {
              token: token,
              charId: charId
            };
            let nP = removeFromTurnTracker(perso, evt);
            if (nP) {
              res = res || {};
              res.oldTokenId = token.id;
              res.newTokenId = nP.nextId;
            }
            deleteTokenWithUndo(token, evt);
          });
        }
        attr.remove();
        if (options.print && mEffet) options.print(mEffet.fin);
        else {
          sendChar(charId, mEffet.fin, true);
          options.print = function(m) {};
        }
        character = getObj('character', charId);
        if (character) {
          evt.deletedCharacters = evt.deletedCharacters || [];
          let deletedChar = {
            id: charId,
            name: character.get('name'),
            avatar: character.get('avatar'),
            attributes: charAttributes,
            abilities: charAbilities,
            allies: []
          };
          // Retrait du perso de toutes les listes d'alli\xE9s
          for (const [perso, alliesPerso] of Object.entries(alliesParPerso)) {
            if (alliesPerso.has(charId)) {
              deletedChar.allies.push(perso);
              alliesPerso.delete(charId);
            }
          }
          character.remove();
          evt.deletedCharacters.push(deletedChar);
        }
        return res; //Pas besoin de faire le reste, car plus de perso
      case 'formeDArbre':
        var iterTokOptions = {
          filterAffected: function(token) {
            return token.get('layer') == 'objects';
          }
        };
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            var perso = {
              token: token,
              charId: charId
            };
            var tokenChange = attributeAsBool(perso, 'changementDeToken');
            if (tokenChange) {
              var tokenMJ =
                findObjs({
                  _type: 'graphic',
                  _subtype: 'token',
                  _pageid: token.get('pageid'),
                  layer: 'gmlayer',
                  represents: charId,
                  name: token.get('name')
                });
              if (tokenMJ.length === 0) return;
              removeTokenAttr(perso, 'changementDeToken', evt);
              var nouveauToken = tokenMJ[0];
              setToken(nouveauToken, 'layer', 'objects', evt);
              setToken(nouveauToken, 'left', token.get('left'), evt);
              setToken(nouveauToken, 'top', token.get('top'), evt);
              setToken(nouveauToken, 'width', token.get('width'), evt);
              setToken(nouveauToken, 'height', token.get('height'), evt);
              setToken(nouveauToken, 'rotation', token.get('rotation'), evt);
              setToken(nouveauToken, 'bar2_value', token.get('bar2_value'), evt);
              setToken(nouveauToken, 'aura1_radius', token.get('aura1_radius'), evt);
              setToken(nouveauToken, 'aura1_color', token.get('aura1_color'), evt);
              setToken(nouveauToken, 'aura1_square', token.get('aura1_square'), evt);
              setToken(nouveauToken, 'showplayers_aura1', token.get('showplayers_aura1'), evt);
              setToken(nouveauToken, 'aura2_radius', token.get('aura2_radius'), evt);
              setToken(nouveauToken, 'aura2_color', token.get('aura2_color'), evt);
              setToken(nouveauToken, 'aura2_square', token.get('aura2_square'), evt);
              setToken(nouveauToken, 'showplayers_aura2', token.get('showplayers_aura2'), evt);
              setToken(nouveauToken, 'statusmarkers', token.get('statusmarkers'), evt);
              setToken(nouveauToken, 'light_angle', token.get('light_angle'), evt);
              setToken(nouveauToken, 'has_limit_field_of_vision', token.get('has_limit_field_of_vision'), evt);
              setToken(nouveauToken, 'has_limit_field_of_night_vision', token.get('has_limit_field_of_night_vision'), evt);
              if (stateCOF.combat) {
                replaceInTurnTracker(token.id, nouveauToken.id, evt);
              }
              res = res || {};
              res.oldTokenId = token.id;
              res.newTokenId = nouveauToken.id;
              res.newToken = nouveauToken;
              deleteTokenWithUndo(token, evt);
              token = nouveauToken;
              perso.token = nouveauToken;
            }
            let apv = tokenAttribute(perso, 'anciensPV');
            if (apv.length > 0) {
              updateCurrentBar(perso, 1, apv[0].get('current'), evt, apv[0].get('max'));
              removeTokenAttr(perso, 'anciensPV', evt);
              if (stateCOF.combat) {
                newInit.push({
                  _id: token.id
                });
              }
            }
          },
          iterTokOptions);
        break;
      case 'agitAZeroPV':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
          let perso = {
            charId: charId,
            token: token
          };
          let pv = token.get('bar1_value');
          if (pv == 0) { //jshint ignore:line
            mort(perso, undefined, evt);
          } else {
            //On note qu'il l'a d\xE9j\xE0 fait pour qu'il ne puisse le refaire dans le combat
            setTokenAttr(perso, 'aAgiAZeroPV', true, evt);
          }
        });
        break;
      case 'forgeron':
      case 'armeEnflammee':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          var perso = {
            token: token,
            charId: charId
          };
          eteindreUneLumiere(perso, options.pageId, undefined, efComplet, evt);
        });
        break;
      case 'effetRetarde':
        if (efComplet.length > 14) {
          var effetRetarde = efComplet.substring(13, efComplet.length - 1);
          if (_.has(cof_states, effetRetarde)) {
            iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
              var perso = {
                token: token,
                charId: charId
              };
              if (getState(perso, 'mort')) return;
              setState(perso, effetRetarde, true, evt);
            });
          } else if (estEffetTemp(effetRetarde)) {
            options.print = function(m) {}; //Pour ne pas afficher le message final.
            var pp = effetRetarde.indexOf('(');
            var mEffetRetarde = (pp > 0) ? messageEffetTemp[effetRetarde.substring(effetRetarde, pp)] : messageEffetTemp[effetRetarde];
            var ef = {
              effet: effetRetarde,
              duree: 1,
              message: mEffetRetarde,
              whisper: true,
            };
            iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
              var perso = {
                token: token,
                charId: charId
              };
              if (getState(perso, 'mort')) return;
              if (!stateCOF.combat) {
                sendChat('', "Il restait un effet retard\xE9 " + effetRetarde + " qui devait se d\xE9clencher pour " + token.get('name'));
                return;
              }
              var duree = getValeurOfEffet(perso, efComplet, 1);
              ef.duree = duree;
              setEffetTemporaire(perso, ef, duree, evt, {});
            });
          } else {
            options.print = function(m) {}; //Pour ne pas afficher le message final.
            iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
              let perso = {
                token: token,
                charId: charId
              };
              if (getState(perso, 'mort')) return;
              let val = true;
              let valAttr = tokenAttribute(perso, efComplet + 'Valeur');
              if (valAttr.length > 0) val = valAttr[0].get('current');
              whisperChar(charId, effetRetarde + ' ' + val);
              setTokenAttr(perso, effetRetarde, val, evt, {});
            });
          }
        }
        break;
      case 'messageRetarde':
        if (efComplet.length > 16) {
          var messageRetarde = efComplet.substring(15, efComplet.length - 1);
          iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
            whisperChar(charId, messageRetarde);
            //Puis on regarde si il y a une valeur \xE0 afficher
            let perso = {
              token: token,
              charId: charId
            };
            let valAttr = tokenAttribute(perso, efComplet + 'Valeur');
            if (valAttr.length > 0)
              whisperChar(charId, valAttr[0].get('current').replace(/_/g, ' '));
          });
        }
        break;
      case 'tenebres':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          //Puis on regarde si il y a une valeur \xE0 afficher
          let perso = {
            token: token,
            charId: charId
          };
          let valAttr = tokenAttribute(perso, efComplet + 'Valeur');
          var tokenTenebres = getObj('graphic', valAttr[0].get('current'));
          if (tokenTenebres) tokenTenebres.remove();
        });
        break;
      case 'armeeDesMorts':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          token.set("aura2_radius", 0);
          if (stateCOF.armeesDesMorts) {
            var index = stateCOF.armeesDesMorts.indexOf(token.id);
            if (index > -1) stateCOF.armeesDesMorts.splice(index, 1);
          }
        });
        break;
      case 'lienDeSang':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          let perso = {
            token: token,
            charId: charId
          };
          let attrsLienDeSangDe = tokenAttribute(perso, "lienDeSangDe");
          if (attrsLienDeSangDe.length > 0) {
            let tokenLie = persoOfId(attrsLienDeSangDe[0].get("current"));
            if (tokenLie) {
              tokenAttribute(tokenLie, "lienDeSangVers").forEach(function(attr) {
                attr.remove();
              });
            }
          }
          attrsLienDeSangDe.forEach(function(attr) {
            attr.remove();
          });
        });
        break;
      default:
    }
    if (options.attrSave === undefined && charId) {
      var estMort = true;
      iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
        estMort = estMort && getState({
          charId: charId,
          token: token
        }, 'mort');
      });
      if (!estMort && mEffet) {
        if (options.print) options.print(mEffet.fin);
        else {
          if (attrName == efComplet)
            sendChar(charId, mEffet.fin, true);
          else {
            var tokenName = attrName.substring(attrName.indexOf('_') + 1);
            sendChat('', tokenName + ' ' + mEffet.fin);
          }
        }
      }
    }
    if (options.gardeAutresAttributs === undefined && charId) {
      enleverEffetAttribut(charId, efComplet, attrName, 'Puissant', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'Valeur', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'TempeteDeManaIntense', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'DureeAccumulee', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'Options', evt);
    }
    evt.deletedAttributes.push(attr);
    attr.remove();
    if (newInit.length > 0) initiative(newInit, evt, true);
    return res;
  }

  //options:
  //fromTemp si on est en train de supprimer un effet temporaire
  function setState(personnage, etat, value, evt, options) {
    let token = personnage.token;
    let charId = personnage.charId;
    if (value && predicateAsBool(personnage, 'immunite_' + etat)) {
      sendPerso(personnage, 'ne peut pas \xEAtre ' + stringOfEtat(etat, personnage));
      return false;
    }
    let aff =
      affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
    if (value && etatRendInactif(etat) && isActive(personnage)) {
      if (etat != 'surpris' || !compagnonPresent(personnage, 'surveillance'))
        removeFromTurnTracker(personnage, evt);
    }
    token.set(cof_states[etat], value);
    if (!value) { //On enl\xE8ve le save si il y en a un
      removeTokenAttr(personnage, etat + 'Save', evt);
    }
    let pageId = token.get('pageid');
    if (etat == 'aveugle') {
      // On change la vision du token
      let page = getObj('page', pageId);
      let udl = page && page.get('dynamic_lighting_enabled');
      if (udl) {
        if (aff.prev.has_limit_field_of_vision === undefined)
          aff.prev.has_limit_field_of_vision = token.get('has_limit_field_of_vision');
        if (aff.prev.has_limit_field_of_night_vision === undefined)
          aff.prev.has_limit_field_of_night_vision = token.get('has_limit_field_of_night_vision');
      } else {
        if (aff.prev.light_losangle === undefined)
          aff.prev.light_losangle = token.get('light_losangle');
      }
      if (value) {
        if (udl) {
          token.set('has_limit_field_of_vision', true);
          token.set('has_limit_field_of_night_vision', true);
        } else {
          token.set('light_losangle', 0);
        }
        //Normalement, ne peut plus suivre personne ?
        //Si il peut parce qu'il touche ou tient une corde, r\xE9utiliser la macro
        //pour suivre
        nePlusSuivre(personnage, pageId, evt);
      } else {
        if (!(options && options.fromTemp))
          removeTokenAttr(personnage, 'aveugleTemp', evt);
        if (udl) {
          token.set('has_limit_field_of_vision', false);
          token.set('has_limit_field_of_night_vision', false);
        } else {
          token.set('light_losangle', 360);
        }
      }
    } else if (etat == 'invisible') {
      let attrInvisible = tokenAttribute(personnage, 'tokenInvisible');
      if (value) {
        if (attrInvisible.length === 0) {
          //On va cr\xE9er une copie de token, mais avec une image invisible et aura visible seulement de ceux qui contr\xF4lent le token
          let tokenFields = getTokenFields(token, pageId, personnage.charId);
          tokenFields.layer = 'objects';
          tokenFields.aura1_radius = 0;
          tokenFields.aura1_color = "#FF9900";
          tokenFields.aura1_square = false;
          tokenFields.showplayers_aura1 = false;
          tokenFields.statusmarkers = "";
          tokenFields.showplayers_name = false;
          tokenFields.showplayers_bar1 = false;
          tokenFields.showplayers_bar2 = false;
          tokenFields.showplayers_bar3 = false;
          tokenFields.imgsrc = IMG_INVISIBLE;
          let tokenInvisible = createObj('graphic', tokenFields);
          if (tokenInvisible) {
            evt.tokens = evt.tokens || [];
            evt.tokens.push(tokenInvisible);
            //On met l'ancien token dans le gmlayer, car si l'image vient du marketplace, il est impossible de le recr\xE9er depuis l'API
            setToken(token, 'layer', 'gmlayer', evt);
            setTokenAttr(personnage, 'tokenInvisible', token.id, evt, {
              maxVal: tokenInvisible.id
            });
            if (stateCOF.options.affichage.val.init_dynamique.val &&
              roundMarker && (
                (!stateCOF.chargeFantastique && stateCOF.activeTokenId == token.id) ||
                (stateCOF.chargeFantastique && stateCOF.chargeFantastique.activeTokenId == token.id))) {
              setToken(roundMarker, 'layer', 'gmlayer', evt);
            }
          }
        }
      } else { //On enl\xE8ve l'\xE9tat invisible
        if (attrInvisible.length > 0) {
          let tokenOriginel = getObj('graphic', attrInvisible[0].get('current'));
          if (!tokenOriginel) {
            if (token.get('layer') == 'gmlayer') tokenOriginel = token;
            else {
              tokenOriginel =
                findObjs({
                  _type: 'graphic',
                  _subtype: 'token',
                  _pageid: token.get('pageid'),
                  layer: 'gmlayer',
                  represents: personnage.charId,
                  name: token.get('name')
                });
              if (tokenOriginel.length > 0) tokenOriginel = tokenOriginel[0];
              else {
                error("Impossible de retrouver le token de d\xE9part de " + token.get('name') + " quand on enl\xE8ve l'\xE9tat invisible", attrInvisible);
                tokenOriginel = false;
              }
            }
          }
          let tokenCourant = getObj('graphic', attrInvisible[0].get('max'));
          if (!tokenCourant) {
            if (token.get('layer') == 'objects') tokenCourant = token;
            else {
              tokenCourant =
                findObjs({
                  _type: 'graphic',
                  _subtype: 'token',
                  _pageid: token.get('pageid'),
                  layer: 'objects',
                  represents: personnage.charId,
                  name: token.get('name')
                });
              if (tokenCourant.length > 0) tokenCourant = tokenCourant[0];
              else {
                error("Impossible de retrouver le token visible de " + token.get('name') + " quand on enl\xE8ve l'\xE9tat invisible", attrInvisible);
                tokenCourant = false;
              }
            }
          }
          removeTokenAttr(personnage, 'tokenInvisible', evt);
          if (!(options && options.fromTemp)) {
            removeTokenAttr(personnage, 'invisibleTemp', evt);
          }
          if (tokenOriginel) {
            setToken(tokenOriginel, 'layer', 'objects', evt);
            if (tokenCourant) {
              setToken(tokenOriginel, 'left', tokenCourant.get('left'), evt);
              setToken(tokenOriginel, 'top', tokenCourant.get('top'), evt);
              setToken(tokenOriginel, 'width', tokenCourant.get('width'), evt);
              setToken(tokenOriginel, 'height', tokenCourant.get('height'), evt);
              setToken(tokenOriginel, 'rotation', tokenCourant.get('rotation'), evt);
              setToken(tokenOriginel, 'flipv', tokenCourant.get('flipv'), evt);
              setToken(tokenOriginel, 'fliph', tokenCourant.get('fliph'), evt);
              setToken(tokenOriginel, 'bar2_value', tokenCourant.get('bar2_value'), evt);
              setToken(tokenOriginel, 'aura2_radius', tokenCourant.get('aura2_radius'), evt);
              setToken(tokenOriginel, 'aura2_color', tokenCourant.get('aura2_color'), evt);
              setToken(tokenOriginel, 'aura2_square', tokenCourant.get('aura2_square'), evt);
              setToken(tokenOriginel, 'showplayers_aura2', tokenCourant.get('showplayers_aura2'), evt);
              setToken(tokenOriginel, 'statusmarkers', tokenCourant.get('statusmarkers'), evt);
              setToken(tokenOriginel, 'light_angle', tokenCourant.get('light_angle'), evt);
              setToken(tokenOriginel, 'has_limit_field_of_vision', tokenCourant.get('has_limit_field_of_vision'), evt);
              setToken(tokenOriginel, 'has_limit_field_of_night_vision', tokenCourant.get('has_limit_field_of_night_vision'), evt);
            }
          }
          if (tokenCourant) deleteTokenWithUndo(tokenCourant, evt);
        }
      }
    } else if (value) {
      switch (etat) {
        case 'mort':
          //On s'assure de mettre les PV de la cible \xE0 0 (pour les insta kills sans dommages)
          if (token.get('bar1_value') > 0) updateCurrentBar(personnage, 1, 0, evt);
          nePlusSuivre(personnage, pageId, evt);
          let persoMonte = tokenAttribute(personnage, 'estMontePar');
          if (persoMonte.length > 0) {
            const cavalier = persoOfId(persoMonte[0].get('current'), persoMonte[0].get('max'), pageId);
            if (cavalier !== undefined) {
              removeTokenAttr(cavalier, 'monteSur', evt);
            }
            removeTokenAttr(personnage, 'estMontePar', evt);
            removeTokenAttr(personnage, 'positionSurMonture', evt);
          }
          //On lib\xE8re les personnages envelopp\xE9s, si il y en a.
          let attrEnveloppe = tokenAttribute(personnage, 'enveloppe');
          attrEnveloppe.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              let envDM = a.get('max');
              if (envDM.startsWith('etreinte')) {
                //On a une \xE9treinte, on enl\xE8ve donc l'\xE9tat immobilis\xE9
                setState(cible, 'immobilise', false, evt);
              }
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'enveloppePar');
              attrCible.forEach(function(a) {
                let cube = persoOfIdName(a.get('current', pageId));
                if (cube === undefined) {
                  evt.deletedAttributes.push(a);
                  a.remove();
                } else if (cube.token.id == personnage.token.id) {
                  sendPerso(cible, 'se lib\xE8re de ' + cube.tokName);
                  toFront(cible.token);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //Si le mort est envelopp\xE9, il est relach\xE9
          attrEnveloppe = tokenAttribute(personnage, 'enveloppePar');
          attrEnveloppe.forEach(function(a) {
            let cube = persoOfIdName(a.get('current'), pageId);
            if (cube) {
              let envDiff = a.get('max');
              if (envDiff.startsWith('etreinte')) {
                //On a une \xE9treinte, on enl\xE8ve donc l'\xE9tat immobilis\xE9
                setState(personnage, 'immobilise', false, evt);
              }
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCube = tokenAttribute(cube, 'enveloppe');
              attrCube.forEach(function(a) {
                let cible = persoOfIdName(a.get('current', pageId));
                if (cible === undefined) {
                  evt.deletedAttributes.push(a);
                  a.remove();
                } else if (cible.token.id == personnage.token.id) {
                  sendPerso(cube, 'relache ' + personnage.tokName);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On lib\xE8re les personnages agripp\xE9s, si il y en a.
          let attrAgrippe = tokenAttribute(personnage, 'agrippe');
          attrAgrippe.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'estAgrippePar');
              attrCible.forEach(function(a) {
                let agrippant = persoOfIdName(a.get('current', pageId));
                if (agrippant.token.id == personnage.token.id) {
                  sendPerso(cible, 'se lib\xE8re de ' + agrippant.tokName);
                  toFront(cible.token);
                  if (a.get('max')) setState(cible, 'immobilise', false, evt);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
              removeTokenAttr(cible, 'agrippeParUnDemon', evt);
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On lib\xE8re les personnages d\xE9vor\xE9s, si il y en a.
          let attrDevore = tokenAttribute(personnage, 'devore');
          attrDevore.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'estDevorePar');
              attrCible.forEach(function(a) {
                let agrippant = persoOfIdName(a.get('current', pageId));
                if (agrippant.token.id == personnage.token.id) {
                  sendPerso(cible, 'se lib\xE8re de ' + agrippant.tokName);
                  toFront(cible.token);
                  setState(cible, 'immobilise', false, evt);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On lib\xE8re les personnages aval\xE9s, si il y en a.
          let attrGobe = tokenAttribute(personnage, 'aGobe');
          attrGobe.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'estGobePar');
              attrCible.forEach(function(a) {
                let gobant = persoOfIdName(a.get('current', pageId));
                if (gobant.token.id == personnage.token.id) {
                  sendPerso(cible, 'peut enfin sortir du ventre de ' + gobant.tokName);
                  toFront(cible.token);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On lib\xE8re les personnages sous \xE9treinte et immolation
          let attrEtreinteImmole = tokenAttribute(personnage, 'etreinteImmole');
          attrEtreinteImmole.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'etreinteImmolePar');
              attrCible.forEach(function(a) {
                let agrippant = persoOfIdName(a.get('current', pageId));
                if (agrippant.token.id == personnage.token.id) {
                  sendPerso(cible, 'se lib\xE8re de ' + agrippant.tokName);
                  toFront(cible.token);
                  setState(cible, 'immobilise', false, evt);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On lib\xE8re les personnages sous \xE9treinte de scorpion
          let attrEtreinteScorpion = tokenAttribute(personnage, 'etreinteScorpionSur');
          attrEtreinteScorpion.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'etreinteScorpionPar');
              let attrRatee = tokenAttribute(cible, 'etreinteScorpionRatee');
              attrCible.forEach(function(a) {
                let agrippant = persoOfIdName(a.get('current', pageId));
                if (agrippant.token.id == personnage.token.id) {
                  sendPerso(cible, 'se lib\xE8re de ' + agrippant.tokName);
                  toFront(cible.token);
                  evt.deletedAttributes.push(a);
                  a.remove();
                  attrRatee.forEach(function(attrR) {
                    evt.deletedAttributes.push(attrR);
                    attrR.remove();
                  });
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On fait l'explosion finale
          if (predicateAsBool(personnage, 'explosionFinale')) {
            let label = predicateAsBool(personnage, 'explosionFinale');
            let character = getObj('character', personnage.charId);
            if (character === undefined) {
              error("Impossible de trouver le personnage de " + personnage.token.get('name'), personnage);
              return;
            }
            let msg = {
              who: 'GM',
              selected: [{
                _id: personnage.token.id
              }]
            };
            let pids = character.get('controlledby');
            pids = pids.split(',');
            if (pids[0] === '' || pids[0] == 'all') {
              pids = findObjs({
                type: 'player'
              }).map(function(p) {
                return p.id;
              });
            }
            if (pids.length > 0) {
              if (pids.length === 0) {
                msg.playerid = pids[0];
              } else {
                msg.playerid = pids.find(playerIsGM);
                if (msg.playerid === undefined) msg.playerid = pids[0];
              }
              msg.content = '!cof-explosion ' + label;
              attaqueExplosion(msg);
            }
          }
          //On termine les effets temporaires li\xE9s au personnage
          let etlAttr = tokenAttribute(personnage, 'effetsTemporairesLies');
          if (etlAttr.length > 0) {
            etlAttr = etlAttr[0];
            evt.deletedAttributes = evt.deletedAttributes || [];
            let etl = etlAttr.get('current').split(',');
            etl.forEach(function(attrId) {
              let attrEffet = getObj('attribute', attrId);
              if (attrEffet === undefined) return;
              let nomAttrEffet = attrEffet.get('name');
              let charId = attrEffet.get('characterid');
              if (estEffetTemp(nomAttrEffet)) {
                finDEffet(attrEffet, effetTempOfAttribute(attrEffet), nomAttrEffet, charId, evt);
              } else if (estEffetCombat(nomAttrEffet)) {
                let mc = messageEffetCombat[effetCombatOfAttribute(attrEffet)].fin;
                if (mc && mc !== '') sendChar(charId, mc, true);
                evt.deletedAttributes.push(attrEffet);
                attrEffet.remove();
              }
            });
            evt.deletedAttributes.push(etlAttr);
            etlAttr.remove();
          }
          if (attributeAsBool(personnage, 'objetAnime')) {
            let attr = tokenAttribute(personnage, 'objetAnime')[0];
            let nom = attr.get('name');
            finDEffet(attr, 'objetAnime', nom, personnage.charId, evt);
          } else if (charAttributeAsBool(personnage, 'armeeConjuree')) {
            removeFromTurnTracker(personnage, evt);
            deleteTokenWithUndo(personnage.token, evt);
            sendPerso(personnage, 'dispara\xEEt');
            let armeeChar = getObj('character', personnage.charId);
            if (armeeChar) {
              evt.deletedCharacters = evt.deletedCharacters || [];
              evt.deletedCharacters.push({
                id: personnage.charId,
                name: armeeChar.get('name'),
                avatar: armeeChar.get('avatar'),
                attributes: findObjs({
                  _type: 'attributes',
                  _characterid: personnage.charId
                }),
                abilities: findObjs({
                  _type: 'ability',
                  _characterid: personnage.charId
                })
              });
              armeeChar.remove();
            }
          } else if (!estNonVivant(personnage)) {
            //Cherche si certains peuvent siphoner l'\xE2me
            let allToks =
              findObjs({
                _type: "graphic",
                _pageid: pageId,
                _subtype: "token",
                layer: "objects"
              });
            //On cherche d'abord si un siphon des \xE2mes est prioritaire
            let prioriteSiphon = [];
            allToks.forEach(function(tok) {
              if (tok.id == token.id) return;
              let p = persoOfToken(tok);
              if (p === undefined) return;
              if (getState(p, 'mort')) return;
              if (distanceCombat(token, tok, pageId) > 20) return;
              if (predicateAsBool(p, 'siphonDesAmes')) {
                prioriteSiphon.push({
                  perso: p,
                  priorite: predicateAsInt(p, 'siphonDesAmesPrioritaire', 0)
                });
              }
            });
            if (prioriteSiphon.length > 0) {
              if (estPJ(personnage)) {
                let siphoneur = prioriteSiphon[0].perso;
                let bonus = predicateAsInt(siphoneur, 'siphonDesAmes', 0);
                let jetSiphon = "(1d6";
                if (bonus > 0) jetSiphon += '+' + bonus;
                jetSiphon += ")";
                sendChat('COF', "/w GM " + personnage.token.get('name') + " est un personnage joueur, possible qu'il ne soit pas vraiment mort mais juste inconscient. Si il est vraiment mort, faire le siphon des \xE2mes par " + siphoneur.token.get('name') + " \xE0 la main " + jetSiphon);
              } else {
                prioriteSiphon.sort(function(a, b) {
                  return b.priorite - a.priorite;
                });
                let fraction = 100;
                let fractionPriorite = fraction;
                let priorite = prioriteSiphon[0].priorite;
                prioriteSiphon.forEach(function(x) {
                  if (x.priorite < priorite) {
                    priorite = x.priorite;
                    fractionPriorite = fraction;
                  }
                  let p = x.perso;
                  if (fractionPriorite < 1) {
                    whisperChar(p.charId, "ne r\xE9ussit pas \xE0 siphoner l'\xE2me de " + token.get('name') + " un autre pouvoir l'a siphon\xE9e avant lui");
                    return;
                  }
                  let bonus = predicateAsInt(p, 'siphonDesAmes', 0);
                  let soin = rollDePlus(6, {
                    bonus: bonus
                  });
                  let soinTotal = soin.val;
                  soin.val = Math.ceil(soin.val * fractionPriorite / 100);
                  soigneToken(p, soin.val, evt,
                    function(s) {
                      let siphMsg = "siphone l'\xE2me de " + token.get('name') +
                        ". " + onGenre(p, 'Il', 'Elle') + " r\xE9cup\xE8re ";
                      if (s == soinTotal) {
                        siphMsg += soin.roll + " pv.";
                        fraction = 0;
                      } else {
                        siphMsg += s + " pv (jet " + soin.roll + ").";
                        fraction -= Math.ceil(s * 100 / soinTotal);
                      }
                      whisperChar(p.charId, siphMsg);
                    },
                    function() {
                      whisperChar(p.charId, "est d\xE9j\xE0 au maximum de point de vie. Il laisse \xE9chapper l'\xE2me de " + token.get('name'));
                    });
                });
              }
            }
          }
          break;
        case 'immobilise':
        case 'surpris':
        case 'assomme':
        case 'etourdi':
        case 'paralyse':
        case 'endormi':
        case 'apeure':
          nePlusSuivre(personnage, pageId, evt);
      }
    } else { //value est false
      if (!(options && options.fromTemp))
        removeTokenAttr(personnage, etat + 'Temp', evt);
    }
    if (token.get('bar1_link') !== '') {
      if (charId === '') {
        error("token with a linked bar1 but representing no character", token);
        return true;
      }
      if (etat == 'affaibli') { //special case due to new character sheet
        var attr =
          findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: 'ETATDE'
          }, {
            caseInsensitive: true
          });
        if (value) {
          if (attr.length === 0) {
            attr =
              createObj('attribute', {
                characterid: charId,
                name: 'ETATDE',
                current: 12
              });
            if (evt.attributes)
              evt.attributes.push({
                attribute: attr,
              });
            else evt.attributes = [{
              attribute: attr,
            }];
          } else {
            attr = attr[0];
            if (parseInt(attr.get('current')) != 12) {
              if (evt.attributes)
                evt.attributes.push({
                  attribute: attr,
                  current: 20
                });
              else evt.attributes = [{
                attribute: attr,
                current: 20
              }];
              attr.set('current', 12);
            }
          }
        } else {
          if (attr.length > 0) {
            attr = attr[0];
            if (parseInt(attr.get('current')) != 20) {
              if (evt.attributes)
                evt.attributes.push({
                  attribute: attr,
                  current: 12
                });
              else evt.attributes = [{
                attribute: attr,
                current: 12
              }];
              attr.set('current', 20);
            }
          }
        }
      } else {
        let attrEtat =
          findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: etat
          });
        if (value) {
          if (attrEtat.length === 0) {
            attrEtat =
              createObj('attribute', {
                characterid: charId,
                name: etat,
                current: value
              });
            if (evt.attributes)
              evt.attributes.push({
                attribute: attrEtat,
              });
            else evt.attributes = [{
              attribute: attrEtat,
            }];
          }
        } else {
          if (attrEtat.length > 0) {
            attrEtat[0].remove();
            if (evt.deletedAttributes) {
              evt.deletedAttributes.push(attrEtat[0]);
            } else {
              evt.deletedAttributes = [attrEtat[0]];
            }
          }
        }
      }
    }
    if (!value && etatRendInactif(etat) && isActive(personnage) ||
      etat == 'aveugle') updateInit(token, evt);
    return true;
  }

  /*
  function logEvents() {
    var l = eventHistory.length;
    log("Historique de taille " + l);
    eventHistory.forEach(function(evt, i) {
      log("evt " + i);
      log(evt);
    });
  }*/

  /* \xC9v\xE9nements, utilis\xE9s pour les undo, en particulier undo pour refaire
   * une action quand une r\xE8gle le permet (utilisation de points de chance, etc..)
   * Champ d'un \xE9v\xE9nement (variables evt en g\xE9n\xE9ral dans le code):
   * id               : identificateur unique (int)
   * type             : description de l'\xE9v\xE9nement (string)
   * affectes         : liste de tokens affect\xE9s par l'\xE9v\xE9nement
   * tokens           : liste des tokens cr\xE9\xE9s
   * deletedTokens    : liste de tokens effac\xE9s
   * !!!!! -> ne garde pas les tokens effac\xE9s si on n'est pas s\xFBr que son image est au bon endroit. Typiquement, on ne va le faire que pour les tokens cr\xE9es dans le script
   * attributes       : liste de attributs cr\xE9\xE9s ou modifi\xE9s
   * deletesAttributes: lites des attributs effac\xE9s
   * characters       : liste des personnages cr\xE9\xE9s
   * characterNames   : liste de character * name
   * defaultTokens    : liste de tokens par d\xE9faut (objet)
   *   (character, defaultToken)
   * deletedCharacters: liste des personnages effac\xE9s
   * combat           : valeur de la variable d'\xE9tat combat
   * combat_pageid    : id de la page o\xF9 se d\xE9roule le combat
   * tour             : valeur du tour de combat (si il a chang\xE9)
   * init             : valeur de l'initiative dans le tour (si elle a chang\xE9)
   * activeTokenId    : id du token actif (si il a chang\xE9)
   * updateNextInitSet: valeur de l'ensemble des tokens dont il faut recalculer l'init
   * turnorder        : le turnorder (si il a chang\xE9)
   * initiativepage   : true si le turnorder est actif
   * personnage       : le perso qui 'fait' l'\xE9v\xE9nement
   * succes           : stoque si l'attaque \xE9tait un succ\xE8s (bool)
   * action           : sauvegarde des param\xE8tres de l'evt, pour la rejouer
   *   - caracteristique : carac test\xE9e (pour un jet)
   *   - titre : titre du jet
   *   - playerId : id du joueur qui a lanc\xE9 l'action
   *   - selected : cibles s\xE9lectionn\xE9s des l'action
   *   - attaquant: personnage attaquant (TODO: voir si doublon avec personnage)
   *   - cibles: liste des cibles d'attaque, avec leurs tags
   *   - weaponStats: stats de l'arme (ou attaque) utilis\xE9e
   *   - rolls: les jets de l'action, pour les avoir \xE0 l'identique
   *     les d\xE9g\xE2ts sont stoqu\xE9s dans chaque cible, dans cible.rollsDmg
   *     - attack: les jets de l'attaque
   *     - etat_e_index_targetid: save pour entrer dans l'\xE9tat e
   *     - effet_e_index_targetid: save pour l'effet e
   *     - attaquant_pietinement_targetid: jet de l'attaquant pour le pi\xE9tinement
   *     - defenseur_pietinement_targetid: jet de du d\xE9fenseur pour le pi\xE9tinement
   *   - options : options de l'action
   * attenteResultat  : permet de savoir que le jet est en attente de d\xE9cision pour savoir si c'est un succ\xE8s ou non (quand il n'y a pas de difficult\xE9 donn\xE9e et que le personnage est sous l'emprise d'une mal\xE9diction)
   */

  function addEvent(evt) {
    if (evt.id) {
      error("Tentative d'ajouter un \xE9v\xE9nement d\xE9j\xE0 dans l'historique", evt);
      return;
    }
    evt.id = stateCOF.eventId++;
    eventHistory.push(evt);
    if (eventHistory.length > HISTORY_SIZE) {
      eventHistory.shift();
    }
  }

  function findEvent(id) {
    return eventHistory.find(function(evt) {
      return (evt.id == id);
    });
  }

  function lastEvent() {
    var l = eventHistory.length;
    if (l === 0) return undefined;
    return eventHistory[l - 1];
  }

  function setDefaultTokenFromSpec(character, spec, token) {
    var oldTokenFields = {};
    for (const field in spec) {
      if (field.startsWith('_')) continue;
      if (field == 'imgsrc' || field == 'represents' || field == 'top' ||
        field == 'left' || field == 'page_id' || field == 'layer' ||
        field == 'lastmove') continue;
      var oldValue = token.get(field);
      if (oldValue == spec[field]) continue;
      oldTokenFields[field] = oldValue;
      token.set(field, spec[field]);
    }
    setDefaultTokenForCharacter(character, token);
    for (const otf in oldTokenFields) {
      token.set(otf, oldTokenFields[otf]);
    }
  }

  //Si evt n'est pas d\xE9fini, annule le dernier evt
  function undoEvent(evt) {
    if (evt === undefined) {
      if (eventHistory.length === 0) {
        sendChat('COF', "/w GM Historique d'\xE9v\xE8nements vide");
        return;
      }
      evt = eventHistory.pop();
    } else {
      eventHistory = eventHistory.filter(function(e) {
        return (e.id != evt.id);
      });
    }
    if (evt === undefined) {
      error("No event to undo", eventHistory);
      return;
    }
    sendChat("COF", "/w GM undo " + evt.type);
    if (evt.affectes) undoTokenEffect(evt);
    if (evt.attributes) {
      // some attributes where modified too
      evt.attributes.forEach(function(attr) {
        if (attr.current === undefined) attr.attribute.remove();
        else {
          var aset = {
            current: attr.current
          };
          if (attr.max !== undefined) aset.max = attr.max;
          if (attr.name !== undefined) aset.name = attr.name;
          if (attr.withWorker) attr.attribute.setWithWorker(aset);
          else attr.attribute.set(aset);
        }
      });
    }
    if (evt.characterNames) {
      evt.characterNames.forEach(function(cn) {
        if (cn.name && cn.character)
          cn.character.set('name', cn.name);
      });
    }
    if (evt.defaultTokens) {
      evt.defaultTokens.forEach(function(dt) {
        //On cherche d'abord un token qui repr\xE9sente dt.character
        var tokens = findObjs({
          _type: 'graphic',
          represents: dt.character.id
        });
        if (tokens.length === 0) return;
        setDefaultTokenFromSpec(dt.character, dt.defaultToken, tokens[0]);
      });
    }
    if (evt.deletedTokens) {
      evt.deletedTokens.forEach(function(token) {
        log("Restoring token " + token.name);
        let t = createObj('graphic', token);
        if (token.layer == 'map') toFront(t);
      });
    }
    if (evt.deletedCharacters) {
      evt.deletedCharacters.forEach(function(character) {
        log("Restoring character " + character.name);
        let newCharacter =
          createObj('character', {
            name: character.name,
            avatar: character.avatar
          });
        let charId = newCharacter.id;
        let tokens = findObjs({
          _type: 'graphic',
          represents: character.id
        });
        tokens.forEach(function(tok) {
          tok.set('represents', charId);
        });
        eventHistory.forEach(function(evt2) {
          if (evt2.characters) {
            evt2.characters = evt2.characters.map(function(oldCharac) {
              if (oldCharac.id == character.id) return newCharacter;
              return oldCharac;
            });
          }
          if (evt2.deletedAttributes) {
            evt2.deletedAttributes.forEach(function(attr) {
              if (attr.get('characterid') == character.id) attr.newCharId = charId;
            });
          }
        });
        if (evt.deletedAttributes) {
          evt.deletedAttributes.forEach(function(attr) {
            if (attr.get('characterid') == character.id) {
              attr.newCharId = charId;
            }
          });
        }
        //Maintenant on remet les attributs
        if (character.attributes) {
          character.attributes.forEach(function(attr) {
            let oldId = attr.id;
            let newAttr = createObj('attribute', {
              characterid: charId,
              name: attr.get('name'),
              current: attr.get('current'),
              max: attr.get('max')
            });
            eventHistory.forEach(function(evt) {
              if (evt.attributes) {
                evt.attributes.forEach(function(attr) {
                  if (attr.attribute.id == oldId) attr.attribute = newAttr;
                });
              }
            });
            tokens.forEach(function(tok) {
              if (tok.get('bar1_link') == oldId)
                tok.set('bar1_link', newAttr.id);
            });
          });
        }
        if (character.abilities) {
          character.abilities.forEach(function(ab) {
            createObj('ability', {
              characterid: charId,
              name: ab.get('name'),
              action: ab.get('action'),
              istokenaction: ab.get('istokenaction')
            });
          });
        }
        // On le remet chez ses alli\xE9s
        if (character.allies.length > 0) {
          Object.values(character.allies).forEach(function(allie) {
            var alliesPerso = alliesParPerso[allie] || new Set();
            alliesPerso.add(charId);
            alliesParPerso[allie] = alliesPerso;
          });
        }
      });
    }
    // deletedAttributes have a quadratic cost in the size of the history
    if (evt.deletedAttributes) {
      evt.deletedAttributes.forEach(function(attr) {
        var oldId = attr.id;
        var nameDel = attr.get('name');
        log("Restoring attribute " + nameDel);
        var newAttr =
          createObj('attribute', {
            characterid: attr.newCharId || attr.get('characterid'),
            name: nameDel,
            current: attr.get('current'),
            max: attr.get('max')
          });
        eventHistory.forEach(function(evt) {
          if (evt.attributes !== undefined) {
            evt.attributes.forEach(function(attr2) {
              if (attr2.attribute && attr2.attribute.id == oldId) attr2.attribute = newAttr;
            });
          }
        });
      });
    }
    if (evt.characters) {
      evt.characters.forEach(function(character) {
        var charId = character.id;
        findObjs({
          _type: 'attribute',
          _characterid: charId
        }).forEach(function(attr) {
          attr.remove();
        });
        findObjs({
          _type: 'ability',
          _characterid: charId
        }).forEach(function(ab) {
          ab.remove();
        });
        character.remove();
      });
    }
    if (evt.tokens) {
      evt.tokens.forEach(function(token) {
        if (stateCOF.tokensTemps) {
          stateCOF.tokensTemps = stateCOF.tokensTemps.filter(function(tt) {
            return tt.tid != token.id;
          });
        }
        token.remove();
      });
    }
    if (evt.movedTokens) {
      evt.movedTokens.forEach(function(movedToken) {
        movedToken.token.set('left', movedToken.oldPosition.left);
        movedToken.token.set('top', movedToken.oldPosition.top);
      });
    }
    if (_.has(evt, 'combat')) stateCOF.combat = evt.combat;
    if (_.has(evt, 'combat_pageid')) stateCOF.combat_pageid = evt.combat_pageid;
    if (_.has(evt, 'tour')) stateCOF.tour = evt.tour;
    if (_.has(evt, 'init')) stateCOF.init = evt.init;
    if (_.has(evt, 'activeTokenId')) {
      stateCOF.activeTokenId = evt.activeTokenId;
      if (stateCOF.options.affichage.val.init_dynamique.val) {
        var activeToken = getObj('graphic', evt.activeTokenId);
        if (activeToken) {
          threadSync++;
          activateRoundMarker(threadSync, activeToken);
        }
      }
    }
    if (_.has(evt, 'updateNextInitSet'))
      updateNextInitSet = evt.updateNextInitSet;
    if (_.has(evt, 'turnorder')) Campaign().set('turnorder', evt.turnorder);
    if (_.has(evt, 'initiativepage'))
      Campaign().set('initiativepage', evt.initiativepage);
    if (evt.chargeFantastique)
      stateCOF.chargeFantastique = evt.chargeFantastique;
    if (evt.deletedTokensTemps && evt.deletedTokensTemps.length > 0) {
      stateCOF.tokensTemps = stateCOF.tokensTemps || [];
      evt.deletedTokensTemps.forEach(function(tt) {
        log("Restoring temp token " + tt.deletedToken.name);
        let t = createObj('graphic', tt.deletedToken);
        if (tt.deletedToken.layer == 'map') toFront(t);
        delete tt.deletedToken;
        tt.tid = t.id;
        stateCOF.tokensTemps.push(tt);
      });
    }
    if (evt.tokensTemps) { //ceux pour lesquels on a diminu\xE9 la dur\xE9e
      evt.tokensTemps.forEach(function(tt) {
        if (tt.tt) tt.tt.duree = tt.ancienneDuree;
      });
    }
  }

  //origin peut \xEAtre un message ou un nom de joueur
  function sendPlayer(origin, msg, playerId) {
    let dest = origin;
    if (origin.who) {
      playerId = playerId || getPlayerIdFromMsg(origin);
      if (playerIsGM(playerId)) dest = 'GM';
      else dest = origin.who;
    }
    if (dest.includes('"')) {
      sendChat('COF', msg);
      log("Impossible d'envoyer des messages priv\xE9s \xE0 " + dest + " car le nom contient des guillemets");
    }
    sendChat('COF', '/w "' + dest + '" ' + msg);
  }

  function sendPlayerAndGM(origin, playerId, msg) {
    sendPlayer(origin, msg, playerId);
    if (playerIsGM(playerId)) return;
    sendChat('COF', '/w GM ' + msg);
  }

  function isCarac(x) {
    switch (x) {
      case 'FOR':
      case 'DEX':
      case 'CON':
      case 'SAG':
      case 'INT':
      case 'CHA':
        return true;
      default:
        return false;
    }
  }

  //msg peut \xEAtre un message ou un playerId
  function peutController(msg, perso) {
    if (msg === undefined) return true;
    let playerId = getPlayerIdFromMsg(msg);
    if (playerIsGM(playerId)) return true;
    if (msg.selected && msg.selected.length > 0) {
      if (perso.token.id == msg.selected[0]._id) return true;
      var selectedPerso = persoOfId(msg.selected[0]._id);
      if (selectedPerso !== undefined && selectedPerso.charId == perso.charId) return true;
    }
    var character = getObj('character', perso.charId);
    if (character === undefined) return false;
    var cb = character.get('controlledby');
    var res = cb.split(',').find(function(pid) {
      if (pid == 'all') return true;
      return (pid == playerId);
    });
    return (res !== undefined);
  }

  // !cof-confirmer-attaque evtid
  function confirmerAttaque(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "Trop tard pour continuer l'attaque, on est hors combat");
      return;
    }
    let cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-confirmer-attaque", cmd);
      return;
    }
    let evt = findEvent(cmd[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
      return;
    }
    let action = evt.action;
    if (action === undefined) {
      error("Erreur interne du bouton de confirmation: l'\xE9v\xE8nement n'a pas d'action", cmd);
      return;
    }
    let options = action.currentOptions || {};
    let playerId = getPlayerIdFromMsg(msg);
    let ctrl = playerIsGM(playerId);
    if (!ctrl && options.preDmg) {
      let tokens = _.allKeys(options.preDmg);
      ctrl = tokens.every(function(tid) {
        let perso = persoOfId(tid);
        if (perso === undefined) return true;
        let character = getObj('character', perso.charId);
        if (character === undefined) return true;
        let cb = character.get('controlledby');
        let res = cb.split(',').find(function(pid) {
          return (pid == 'all' || pid == playerId);
        });
        return (res !== undefined);
      });
    }
    if (!ctrl) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton", playerId);
      return;
    }
    options.rolls = action.rolls;
    options.choices = action.choices || {};
    options.choices.Continuer = true;
    resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, options, evt, action.explications, action.pageId, action.cibles);
  }

  function undoTokenEffect(evt) {
    var HTdeclared;
    try {
      HTdeclared = HealthColors;
    } catch (e) {
      if (e.name != "ReferenceError") throw (e);
    }
    _.each(evt.affectes, function(aff) {
      var prev = aff.prev;
      var tok = aff.affecte;
      if (prev === undefined || tok === undefined) {
        error("Pas d'\xE9tat pr\xE9c\xE9dant", aff);
        return;
      }
      var prevTok;
      if (HTdeclared) prevTok = JSON.parse(JSON.stringify(tok));
      _.each(prev, function(val, key) {
        tok.set(key, val);
      });
      if (HTdeclared) HealthColors.Update(tok, prevTok);
      sendChat("COF", "\xC9tat de " + tok.get("name") + " restaur\xE9.");
    });
  }

  function caracOfMod(m) {
    switch (m) {
      case 'FOR':
        return 'force';
      case 'DEX':
        return 'dexterite';
      case 'CON':
        return 'constitution';
      case 'INT':
        return 'intelligence';
      case 'SAG':
        return 'sagesse';
      case 'CHA':
        return 'charisme';
      default:
        return;
    }
  }

  function PNJCaracOfMod(m) {
    return 'pnj_' + m.toLowerCase();
  }

  //Retourne le mod de la caract\xE9ristque enti\xE8re.
  //si carac n'est pas une carac, retourne 0
  //perso peut ne pas avoir de token ou \xEAtre juste un charId
  function modCarac(perso, carac) {
    if (perso.charId === undefined) perso = {
      charId: perso
    };
    if (persoEstPNJ(perso)) {
      let mod = 0;
      switch (carac) {
        case 'force':
        case 'FORCE':
          mod = ficheAttributeAsInt(perso, 'pnj_for', 0);
          break;
        case 'dexterite':
        case 'DEXTERITE':
          mod = ficheAttributeAsInt(perso, 'pnj_dex', 0);
          break;
        case 'constitution':
        case 'CONSTITUTION':
          mod = ficheAttributeAsInt(perso, 'pnj_con', 0);
          break;
        case 'intelligence':
        case 'INTELLIGENCE':
          mod = ficheAttributeAsInt(perso, 'pnj_int', 0);
          break;
        case 'sagesse':
        case 'SAGESSE':
          mod = ficheAttributeAsInt(perso, 'pnj_sag', 0);
          break;
        case 'charisme':
        case 'CHARISME':
          mod = ficheAttributeAsInt(perso, 'pnj_cha', 0);
          break;
        default:
          return 0;
      }
      return mod - Math.floor(attributeAsInt(perso, 'affaiblissementde' + carac, 0) / 2);
    }
    let valCarac = ficheAttributeAsInt(perso, carac, 10) - attributeAsInt(perso, 'affaiblissementde' + carac, 0);
    let res = Math.floor((valCarac - 10) / 2);
    if ((carac == 'force' || carac == 'FORCE') && attributeAsBool(perso, 'mutationMusclesHypertrophies')) res += 2;
    else if ((carac == 'DEXTERITE' || carac == 'dexterite') && attributeAsBool(perso, 'mutationSilhouetteFiliforme')) res += 4;
    return res;
  }

  function boutonSimple(action, texte, style) {
    action = action.replace(/%/g, '&#37;').replace(/\)/g, '&#41;').replace(/\?/g, '&#63;').replace(/@/g, '&#64;').replace(/\[/g, '&#91;').replace(/]/g, '&#93;').replace(/"/g, '&#34;').replace(/{/g, '&#123;').replace(/}/g, '&#125;').replace(/\|/g, '&#124;');
    action = action.replace(/\'/g, '&apos;'); // escape quotes
    action = action.replace(/:/g, '&amp;#58;'); // double escape colon
    style = style || '';
    return '<a href="' + action + '"' + style + '>' + texte + '</a>';
  }

  // on, remplace tous les selected par @{character name|attr}
  function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
  }

  //Remplace une macro ou ability par sa d\xE9finition (r\xE9cursivement)
  function replaceAction(action, perso, macros, abilities) {
    var remplacement = false;
    if (action.indexOf('#') >= 0) {
      macros = macros || findObjs({
        _type: 'macro'
      });
      macros.forEach(function(m, i) {
        var mName = m.get('name');
        if (mName === '') return;
        mName = '#' + mName;
        if (action.indexOf(mName) >= 0) {
          mName = new RegExp(mName + "\\b", "g");
          action = action.replace(mName, m.get('action'));
          if (!remplacement)
            macros = macros.filter(function(m, k) {
              return (k != i);
            }); //Pour \xE9viter la r\xE9cursion
          remplacement = true;
        }
      });
    }
    if (action.indexOf('%') >= 0) {
      abilities = abilities || findObjs({
        _type: 'ability',
        _characterid: perso.charId
      });
      abilities.forEach(function(a, i) {
        var aName = a.get('name');
        if (aName === '') return;
        var daName = '%' + aName;
        if (action.indexOf(daName) >= 0) {
          action = action.replace(daName, a.get('action'));
          if (!remplacement) abilities = abilities.splice(i); //Pour \xE9viter la r\xE9cursion
          remplacement = true;
        }
        daName = '%{selected|' + aName + '}';
        if (action.indexOf(daName) >= 0) {
          action = action.replace(daName, a.get('action'));
          if (!remplacement)
            abilities = abilities.filter(function(m, k) {
              return (k != i);
            }); //Pour \xE9viter la r\xE9cursion
          remplacement = true;
        }
      });
    }
    if (remplacement) return replaceAction(action, perso, macros, abilities);
    return action;
  }

  function identifierArme(weaponStats, nom, pattern) {
    var p = weaponStats.name.search(pattern);
    if (p >= 0) weaponStats[nom] = true;
    else {
      if (weaponStats.divers) {
        p = weaponStats.divers.search(pattern);
      }
      if (p >= 0) weaponStats[nom] = true;
      else {
        p = weaponStats.modificateurs.search(pattern);
        if (p >= 0) weaponStats[nom] = true;
      }
    }
  }

  function fieldAsString(obj, field, def) {
    var res = obj[field];
    if (res === undefined) return def;
    return res;
  }


  function fieldAsInt(obj, field, def) {
    var res = obj[field];
    if (res === undefined) return def;
    res = parseInt(res);
    if (isNaN(res)) return def;
    return res;
  }

  function getWeaponStats(perso, attackLabel) {
    let weaponStats = {
      name: 'Attaque',
      attSkill: '@{ATKCAC}',
      attNbDices: 1,
      attDice: 4,
      attDMBonusCommun: 0,
      crit: 20,
      divers: '',
      portee: 0,
      typeDegats: 'contondant',
      options: '',
    };
    if (attackLabel === undefined) return weaponStats;
    let attaques = listAllAttacks(perso);
    let att = attaques[attackLabel];
    if (att === undefined) {
      weaponStats.name = attackLabel;
      return weaponStats;
    }
    weaponStats.label = attackLabel;
    weaponStats.name = att.armenom;
    weaponStats.attNbDices = fieldAsInt(att, 'armedmnbde', 1);
    weaponStats.attDice = fieldAsInt(att, 'armedmde', 4);
    weaponStats.crit = fieldAsInt(att, 'armecrit', 20);
    weaponStats.divers = fieldAsString(att, 'armespec', '');
    if (persoEstPNJ(perso)) {
      weaponStats.attSkill = fieldAsInt(att, 'armeatk', 0);
      weaponStats.attDMBonusCommun = fieldAsInt(att, 'armedm', 0);
    } else {
      weaponStats.attSkill = fieldAsString(att, 'armeatk', '@{ATKCAC}');
      weaponStats.attSkillDiv = fieldAsInt(att, 'armeatkdiv', 0);
      weaponStats.attCarBonus = fieldAsString(att, 'armedmcar', '@{FOR}');
      weaponStats.attDMBonusCommun = fieldAsInt(att, 'armedmdiv', 0);
    }
    weaponStats.portee = fieldAsInt(att, 'armeportee', 0);
    weaponStats.typeAttaque = fieldAsString(att, 'armetypeattaque', 'Naturel');
    weaponStats.modificateurs = fieldAsString(att, 'armemodificateurs', '');
    weaponStats.typeDegats = fieldAsString(att, 'armetypedegats', 'tranchant');
    weaponStats.options = fieldAsString(att, 'armeoptions', '');
    weaponStats.options = weaponStats.options.trim();
    switch (weaponStats.typeAttaque) {
      case 'Naturel':
        weaponStats.armeNaturelle = true;
        break;
      case 'Arme 1 main':
        weaponStats.arme = true;
        break;
      case 'Arme 2 mains':
        weaponStats.arme = true;
        weaponStats.deuxMains = true;
        break;
      case 'Sortilege':
        weaponStats.sortilege = true;
        break;
      case 'Arme gauche':
        weaponStats.armeGauche = true;
        break;
      case 'Arme de jet':
        weaponStats.armeDeJet = true;
        weaponStats.tauxDePerte = fieldAsInt(att, 'armejettaux', 0);
        weaponStats.nbArmesDeJet = fieldAsInt(att, 'armejetqte', 1);
        weaponStats.prefixe = att.prefixe; //pour trouver l'attribut
        break;
      default:
        //On cherche si c'est une arme \xE0 2 mains
        var t = weaponStats.name.toLowerCase();
        if (t.includes('2 mains') || t.includes('deux mains')) {
          weaponStats.deuxMains = true;
        } else {
          t = weaponStats.divers;
          if (t) {
            t = t.toLowerCase();
            if (t.includes('2 mains') || t.includes('deux mains')) {
              weaponStats.deuxMains = true;
            }
          }
        }
    }
    //Identification des cat\xE9gories d'armes utilis\xE9es en jeu
    identifierArme(weaponStats, 'arc', /\barc\b/i);
    identifierArme(weaponStats, 'arbalete', /\barbal([e\xE8])te\b/i);
    identifierArme(weaponStats, 'hache', /\bhache\b/i);
    identifierArme(weaponStats, 'marteau', /\bmarteau\b/i);
    identifierArme(weaponStats, 'epieu', /\b[e\xE9]pieu\b/i);
    //Informations dans le champ sp\xE9cial
    var parse = weaponStats.divers.split(' ');
    var lastParsed;
    parse.forEach(function(p) {
      p = p.trim();
      if (p === '') return;
      if (p.startsWith('+') && lastParsed == 'DEF') {
        var bonus = parseInt(p.substring(1));
        if (!isNaN(bonus) && bonus > 0) {
          weaponStats.bonusDef = weaponStats.bonusDef || 0;
          weaponStats.bonusDef += bonus;
          lastParsed = undefined;
          return;
        }
      }
      lastParsed = p;
    });
    return weaponStats;
  }

  //options est un tableaux d'options obtenues par split(' --')
  function actionImpossible(perso, options, defResource) {
    let ai = options.some(function(opt) {
      opt = opt.trim();
      if (opt === '') return false;
      const cmd = opt.split(' ');
      switch (cmd[0]) {
        case 'si':
          let condition = parseCondition(cmd.slice(1));
          switch (condition.type) {
            case 'etat':
              return !getState(perso, condition.etat);
            case 'attribut':
              return !attributeAsBool(perso, condition.attribute);
          }
          return false;
        case 'mana':
          if (cmd.length < 2) return false;
          let mana = parseInt(cmd[1]);
          if (isNaN(mana) || mana < 0) return false;
          return !depenseManaPossible(perso, mana);
        case 'limiteParJour':
          if (cmd.length < 2) return false;
          let limiteParJour = parseInt(cmd[1]);
          if (isNaN(limiteParJour) || limiteParJour < 1) return false;
          let ressourceParJour = defResource;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            ressourceParJour = cmd.join('_');
          }
          ressourceParJour = 'limiteParJour_' + ressourceParJour;
          if (attributeAsInt(perso, ressourceParJour, limiteParJour) > 0) {
            return false;
          }
          //Reste le cas o\xF9 on peut d\xE9passer cette limite par jour
          let depasse = tokenAttribute(perso, 'depasseLimiteParJour_' + ressourceParJour);
          if (depasse.length === 0) return true;
          let coutDepasse = parseInt(depasse[0].get('current'));
          if (isNaN(coutDepasse) || coutDepasse < 0) return true;
          return !depenseManaPossible(perso, coutDepasse);
        case 'limiteParCombat':
          if (cmd.length < 2) return false;
          let limiteParCombat = parseInt(cmd[1]);
          if (isNaN(limiteParCombat) || limiteParCombat < 1) return false;
          let ressourceParCombat = defResource;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            ressourceParCombat = cmd.join('_');
          }
          ressourceParCombat = "limiteParCombat_" + ressourceParCombat;
          return attributeAsInt(perso, ressourceParCombat, limiteParCombat) === 0;
        case 'aussiArmeDeJet':
          if (cmd.length < 2) return false;
          let armeAssociee = getWeaponStats(perso, cmd[1]);
          return armeAssociee && armeAssociee.armeDeJet && armeAssociee.nbArmesDeJet < 1;
      }
      return false;
    });
    return ai;
  }

  //options peut avoir les champs:
  // - ressource, un attribut
  // - overlay
  // - buttonStyle
  // - attackStats
  // et la fonction peut \xE9crire actionImpossible = true dans options.
  function bouton(action, text, perso, options) {
    if (action === undefined || action.trim() === '') return text;
    else action = action.trim();
    options = options || {};
    //Expansion des macros et abilities
    action = replaceAction(action, perso);
    const tid = perso.token.id;
    perso.tokName = perso.tokName || perso.token.get('name');
    if (perso.name === undefined) {
      const character = getObj('character', perso.charId);
      if (character) perso.name = character.get('name');
      else perso.name = perso.tokName;
    }
    //Cas de plusieurs actions apr\xE8s expansion
    let actions = action.split('\n');
    //Cherche le picto et le style
    let style = '';
    let picto = '';
    let groupe; //Pour g\xE9n\xE9rer un bouton d'attaque de groupe. \xC0 revoir
    actions = actions.map(function(act) {
      act = act.trim();
      if (act.startsWith("/as ")) {
        act = "!cof-as" + act.substring(3);
      }
      if (act.charAt(0) == '!') {
        if (act.startsWith('!cof-')) {
          const args = act.split(' --');
          if (actionImpossible(perso, args, '')) options.actionImpossible = true;
          else if (act.startsWith('!cof-soin ') && !act.includes('--limitePar') && !act.includes('--dose')) { //Limitations sp\xE9ficiques
            let rangSoin = predicateAsInt(perso, 'voieDesSoins', 0);
            let cmd = args[0].split(' ');
            if (cmd.includes('leger')) {
              let soinsLegers = attributeAsInt(perso, 'soinsLegers', 0);
              if (soinsLegers >= rangSoin) {
                //Peut-\xEAtre qu'on peut encore d\xE9passer la limite
                if (act.includes('--depasseLimite')) {
                  let d = attributeAsInt(perso, 'depassesoinsLegers', 1);
                  if (depenseManaPossible(perso, d)) {
                    text += " (+" + d + "PM)";
                  } else options.actionImpossible = true;
                } else options.actionImpossible = true;
              }
            } else if (cmd.includes('modere')) {
              let soinsModeres = attributeAsInt(perso, 'soinsModeres', 0);
              if (soinsModeres >= rangSoin) {
                //Peut-\xEAtre qu'on peut encore d\xE9passer la limite
                if (act.includes('--depasseLimite')) {
                  let d = attributeAsInt(perso, 'depassesoinsModeres', 0) + 1;
                  if (depenseManaPossible(perso, d)) {
                    text += "(+" + d + "PM)";
                  } else options.actionImpossible = true;
                } else options.actionImpossible = true;
              }
            }
          }
          if (options.ressource) act += " --decrAttribute " + options.ressource.id;
          if (picto === '') {
            // Pictos : https://wiki.roll20.net/CSS_Wizardry#Pictos
            let typeAction = act.split(' ', 1)[0].substring(5);
            switch (typeAction) {
              case 'attack':
              case 'attaque':
              case 'confirmer-attaque':
              case 'explosion':
                let portee = 0;
                let sortilege;
                let cmd = args.shift().split(' ');
                let attackStats = options.attackStats;
                if (attackStats === undefined) {
                  let attackLabel;
                  if (typeAction == 'explosion' && cmd.length > 1) {
                    attackLabel = cmd[1].trim();
                  } else if (cmd.length > 3) {
                    attackLabel = cmd[3].trim();
                  }
                  if (attackLabel && !attackLabel.startsWith('?{')) {
                    attackStats = getWeaponStats(perso, attackLabel);
                  }
                }
                if (attackStats) {
                  portee = attackStats.portee;
                  sortilege = attackStats.sortilege;
                  if (attackStats.options) {
                    let firstOptionIndex = act.indexOf(' --');
                    if (firstOptionIndex > 0) {
                      act = act.substring(0, firstOptionIndex) + ' --attaqueOptions ' + attackStats.options + act.substring(firstOptionIndex);
                    } else {
                      act += ' --attaqueOptions ' + attackStats.options;
                    }
                  }
                }
                //On cherche la port\xE9e dans les options (\xE7a a la priorit\xE9)
                args.forEach(function(o) {
                  if (o.startsWith('portee ')) {
                    var p = parseInt(o.substring(7));
                    if (!isNaN(p) && p >= 0) portee = p;
                  }
                });
                if (sortilege || act.indexOf(' --sortilege') !== -1) {
                  // attaque magique
                  picto = '<span style="font-family: \'Pictos Three\'">g</span> ';
                  style = 'background-color:#9900ff';
                } else if (portee > 0) {
                  // attaque distance
                  picto = '<span style="font-family: \'Pictos Custom\'">[</span> ';
                  style = 'background-color:#48b92c';
                } else {
                  // attaque contact
                  picto = '<span style="font-family: \'Pictos Custom\'">t</span> ';
                  style = 'background-color:#cc0000';
                }
                break;
              case 'lancer-sort':
              case 'injonction':
              case 'injonction-mortelle':
              case 'attaque-magique':
              case 'tueur-fantasmagorique':
              case 'mot-de-pouvoir-immobilise':
              case 'animation-des-objets':
                picto = '<span style="font-family: \'Pictos Three\'">g</span> ';
                style = 'background-color:#9900ff';
                break;
              case 'soin':
              case 'transe-guerison':
              case 'delivrance':
              case 'guerir':
              case 'guerison':
              case 'consommer-baie':
                picto = '<span style="font-family: \'Pictos\'">k</span> ';
                style = 'background-color:#ffe599;color:#333';
                break;
              case 'effet':
              case 'effet-temp':
              case 'effet-combat':
              case 'set-state':
              case 'lumiere':
                if (act.includes(' --mana')) {
                  picto = '<span style="font-family: \'Pictos Three\'">g</span> ';
                  style = 'background-color:#9900ff';
                } else {
                  picto = '<span style="font-family: \'Pictos\'">S</span> ';
                  style = 'background-color:#4a86e8';
                }
                break;
              case 'fortifiant':
                picto = '<span style="font-family: \'Pictos\'">S</span> ';
                style = 'background-color:#4a86e8';
                break;
              case 'enduire-poison':
                picto = '<span style="font-family: \'Pictos Three\'">i</span> ';
                style = 'background-color:#05461c';
                break;
              case 'desarmer':
                picto = '<span style="font-family: \'Pictos Custom\'">t</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'surprise':
                picto = '<span style="font-family: \'Pictos\'">e</span> ';
                style = 'background-color:#4a86e8';
                break;
              case 'recharger':
                picto = '<span style="font-family: \'Pictos\'">0</span> ';
                style = 'background-color:#e69138';
                break;
              case 'action-defensive':
                picto = '<span style="font-family: \'Pictos Three\'">b</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'manoeuvre':
                picto = '<span style="font-family: \'Pictos Three\'">d</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'attendre':
                picto = '<span style="font-family: \'Pictos\'">t</span> ';
                style = 'background-color:#999999';
                break;
              case 'dmg':
              case 'bouton-echec-total':
                picto = '<span style="font-family: \'Pictos\'">\'</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'peur':
                picto = '<span style="font-family: \'Pictos\'">`</span> ';
                style = 'background-color:#B445FE';
                break;
              case 'consommables':
                picto = '<span style="font-family: \'Pictos\'">b</span> ';
                style = 'background-color:#ce0f69';
                break;
              case 'liste-actions':
                picto = '<span style="font-family: \'Pictos\'">l</span> ';
                style = 'background-color:#272751';
                break;
            }
          }
        } else if (!act.startsWith('!&#13')) return act; //On ne touche pas aux commandes des autres scripts
      } else {
        if (options.ressource) {
          act = "!cof-utilise-consommable " + tid + ' ' + options.ressource.id + ' ' + act;
          picto = '<span style="font-family: \'Pictos\'">b</span> ';
          style = 'background-color:#ce0f69';
        } else {
          act = "!cof-lancer-sort " + act;
          picto = '<span style="font-family: \'Pictos Three\'">g</span> ';
          style = 'background-color:#9900ff';
        }
      }
      if (act.indexOf('@{selected') !== -1) {
        // cas sp\xE9cial pour @{selected|token_id} o\xF9 l'on remplace toutes les occurences par token.id
        act = act.replace(new RegExp(escapeRegExp('@{selected|token_id}'), 'g'), tid);
        act = act.replace(new RegExp(escapeRegExp('@{selected|token_name}'), 'g'), perso.tokName);
        var tmp = act.split('@{selected');
        tmp.forEach(function(elem) {
          if (elem.startsWith('|')) {
            // attribut demand\xE9
            var attribute_name = elem.substring(0, elem.indexOf("}")).substr(1);
            var attrs = findObjs({
              _type: 'attribute',
              _characterid: perso.charId,
              name: attribute_name
            });
            var replacement;
            if (attrs.length === 0)
              replacement = '@{' + perso.name + '|' + attribute_name + '}';
            else
              replacement = attrs[0].get('current');
            act = act.replace(new RegExp(escapeRegExp('@{selected|' + attribute_name + '}'), 'g'), replacement);
          }
        });
      }
      if (act.startsWith('!cof-lancer-sort') && act.indexOf('--lanceur') == -1) {
        act += " --lanceur " + tid;
      }
      if (act.indexOf('@{target|') == -1 &&
        act.indexOf('cof-lancer-sort') == -1 &&
        act.indexOf('cof-surprise') == -1 &&
        act.indexOf('cof-attack') == -1 &&
        act.indexOf('cof-soin') == -1 &&
        act.indexOf('cof-guerison') == -1 &&
        act.indexOf('cof-as ') == -1 &&
        act.indexOf('cof-jouer-son ') == -1 &&
        act.indexOf('cof-utilise-consommable ') == -1 &&
        act.indexOf('--equipe') == -1 &&
        act.indexOf('--enVue') == -1 &&
        act.indexOf('--target ' + tid) == -1) {
        //Si on n'a pas de cible, on fait comme si le token \xE9tait s\xE9lectionn\xE9.
        var add_token = " --target " + tid;
        if (act.indexOf(' --allie') >= 0) {
          if (act.indexOf('--lanceur') == -1)
            add_token = " --lanceur " + tid;
          else add_token = ""; //La cible sont les alli\xE9s de --lanceur.
        }
        if (act.indexOf(' --message ') != -1) act = act.replace(' --message ', add_token + ' --message ');
        else act += add_token;
      }
      return act;
    });
    text = picto + text;
    var buttonStyle = '';
    if (options.buttonStyle) buttonStyle = ' style="' + options.buttonStyle + '"';
    else if (style !== '') buttonStyle = ' style="' + style + '"';
    var overlay = '';
    if (options.overlay) overlay = ' title="' + options.overlay + '"';
    if (actions.length == 1) {
      action = actions[0];
      var toReturn = boutonSimple(action, text, buttonStyle + overlay);
      if (groupe) {
        toReturn += "<br/>" + boutonSimple(action + " --attaqueDeGroupe ?{Attaque en groupe ?}", text + " (groupe)", buttonStyle + overlay);
      }
      return toReturn;
    } else {
      action = "!cof-multi-command " + actions.join(' --cof-multi-command ');
      return boutonSimple(action, text, buttonStyle + overlay);
    }
  }

  function improve_image(image_url) {
    if (image_url) {
      image_url = image_url.replace('/med.png', '/thumb.png');
      image_url = image_url.replace('/max.png', '/thumb.png');
      var index = image_url.indexOf('?');
      if (index > 0) image_url = image_url.substring(0, index);
      return image_url;
    }
  }

  //Fonction s\xE9par\xE9e pour pouvoir envoyer un frame \xE0 plusieurs joueurs
  // playerId peut \xEAtre undefined (en particulier pour envoyer au mj)
  function addFramedHeader(display, playerId, chuchote) {
    let perso1 = display.perso1;
    let perso2 = display.perso2;
    let action = display.action;
    let playerBGColor = '#333';
    let playerTXColor = '#FFF';
    let displayname;
    let player;
    if (playerId) player = getObj('player', playerId);
    if (player !== undefined) {
      playerBGColor = player.get("color");
      playerTXColor = (getBrightness(playerBGColor) < 50) ? "#FFF" : "#000";
      displayname = player.get('displayname');
    }
    let res = '/direct ';
    if (chuchote) {
      let who;
      if (chuchote !== true) who = chuchote;
      else who = displayname;
      if (who) res = '/w "' + who + '" ';
      else chuchote = false;
    }
    var name1, name2 = '';
    var avatar1, avatar2;
    if (perso2) {
      var img2 = improve_image(perso2.token.get('imgsrc'));
      if (stateCOF.options.affichage.val.avatar_dans_cadres.val) {
        var character2 = getObj('character', perso2.charId);
        if (character2) img2 = improve_image(character2.get('avatar')) || img2;
      }
      if (img2) {
        avatar2 = '<img src="' + img2 + '" style="width: 50%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
        name2 = perso2.tokName;
        if (name2 === undefined) name2 = perso2.token.get('name');
        name2 = '<b>' + name2 + '</b>';
      }
    }
    if (perso1) {
      var img1 = improve_image(perso1.token.get('imgsrc'));
      if (stateCOF.options.affichage.val.avatar_dans_cadres.val) {
        var character1 = getObj('character', perso1.charId);
        if (character1) img1 = improve_image(character1.get('avatar')) || img1;
      }
      if (img1) {
        avatar1 = '<img src="' + img1 + '" style="width: ' + (avatar2 ? 50 : 100) + '%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
        if (perso1.tokName) name1 = perso1.tokName;
        else name1 = perso1.token.get('name');
        name1 = '<b>' + name1 + '</b>';
      }
    }
    res +=
      '<div class="all_content" style="-webkit-box-shadow: 2px 2px 5px 0px rgba(0,0,0,0.75); -moz-box-shadow: 2px 2px 5px 0px rgba(0,0,0,0.75); box-shadow: 2px 2px 5px 0px rgba(0,0,0,0.75); border: 1px solid #000; border-radius: 6px; -moz-border-radius: 6px; -webkit-border-radius: 6px; overflow: hidden; position: relative;">';
    if (display.image) {
      res +=
        '<div class="line_header" style="overflow:auto; text-align: center; vertical-align: middle; padding: 5px 5px; border-bottom: 1px solid #000; color: ' + playerTXColor + '; background-color: ' + playerBGColor + ';" title=""> ';
      res += '<img src="' + display.image + '" style="width: ' + 100 + '%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
      res += '</div>';
    } else if (avatar1) {
      res +=
        '<div class="line_header" style="overflow:auto; text-align: center; vertical-align: middle; padding: 5px 5px; border-bottom: 1px solid #000; color: ' + playerTXColor + '; background-color: ' + playerBGColor + ';" title=""> ' +
        '<table>';
      if (avatar2) {
        res +=
          '<tr style="text-align: center">' +
          '<td style="width: 44%; vertical-align: middle;">' + name1 + '</td>' +
          '<td style="width: 12%;height: 28px;line-height: 30px;border: 2px solid #900;border-radius: 100%;position: absolute;margin-top: 25px;font-weight: bold;background-color: #EEE;color: #900;">' + 'VS' + '</td>' +
          '<td style="width: 44%; vertical-align: middle;">' + name2 + '</td>' +
          '</tr>' +
          '<tr style="text-align: center">' +
          '<td style="width: 42%; vertical-align: middle;">' + avatar1 + '</td>' +
          '<td style="width: 16%; vertical-align: middle;">&nbsp;</td>' +
          '<td style="width: 42%; vertical-align: middle;">' + avatar2 + '</td>' +
          '</tr>';
      } else {
        let bar1_info = '',
          bar2_info = '',
          bar3_info = '';
        if (chuchote && peutController(playerId, perso1)) {
          // on chuchote donc on peut afficher les informations concernant les barres du Token
          if (perso1.token.get('bar1_link') === '') {
            bar1_info = '<b>PV</b> : ' + perso1.token.get('bar1_value') + ' / ' + perso1.token.get('bar1_max');
          } else {
            let bar1 = getObj('attribute', perso1.token.get('bar1_link'));
            if (bar1)
              bar1_info = '<b>' + bar1.get('name') + '</b> : ' + bar1.get('current') + ' / ' + bar1.get('max') + '';
          }
          let pvTemporaires = attributeAsInt(perso1, 'PVTemporaires', 0);
          if (pvTemporaires > 0) bar1_info += ' (+' + pvTemporaires + ')';
          if (perso1.token.get('bar2_link') === '') {
            let dmTemp = perso1.token.get('bar2_value');
            if (dmTemp !== '') {
              dmTemp = parseInt(dmTemp);
              if (!isNaN(dmTemp) && dmTemp > 0)
                bar2_info = '<b>DM temp</b> : ' + dmTemp;
            }
          } else {
            let bar2 = findObjs({
              _type: 'attribute',
              _id: perso1.token.get('bar2_link')
            });
            if (bar2 && bar2.length > 0) bar2_info = '<b>' + bar2[0].get('name') + '</b> : ' + bar2[0].get('current') + ' / ' + bar2[0].get('max') + '';
          }
          if (perso1.token.get('bar3_link').length > 0) {
            let bar3 = findObjs({
              _type: 'attribute',
              _id: perso1.token.get('bar3_link')
            });
            if (bar3[0] !== undefined) bar3_info = '<b>' + bar3[0].get('name') + '</b> : ' + bar3[0].get('current') + ' / ' + bar3[0].get('max') + '';
          }
        }
        res +=
          '<tr style="text-align: left">' +
          '<td style="width:25%; vertical-align: middle;">' + avatar1 +
          '</td>' +
          '<td style="width:75%; vertical-align: middle; position: relative;">' +
          '<div>' + name1 + '</div>' +
          '<div style="position: absolute;top: -6px;right: -5px;border: 1px solid #000;background-color: #333;">' +
          '<div style="text-align: right; margin: 0 5px; color: #7cc489">' + bar1_info + '</div>' +
          '<div style="text-align: right; margin: 0 5px; color: #7c9bc4">' + bar2_info + '</div>' +
          '<div style="text-align: right; margin: 0 5px; color: #b21d1d">' + bar3_info + '</div>' +
          '</div>' +
          '</td>' +
          '</tr>';
      }
      res +=
        '</table>' +
        '</div>'; // line_header
    }
    // La ligne de titre
    res +=
      '<div class="line_title" style="font-size: 85%; text-align: left; vertical-align: middle; padding: 5px 5px; border-bottom: 1px solid #000; color: #a94442; background-color: #f2dede;" title=""> ';
    if (display.action_right) {
      res += '<table style="width:100%"><tr><td>' + action + '</td><td style="text-align: right;">' + display.action_right + '</td></tr></table>';
    } else {
      res += action;
    }
    res += '</div>'; // line_title
    res += '<div class="line_content">';
    display.header = res;
  }

  //Si options.chuchote est vrai, la frame est chuchot\xE9e au joueur qui fait l'action
  //Si options.chuchote est un nom, on chuchote la frame \xE0 ce nom
  //Pour retarder la d\xE9cision sur la cible de chuchotement, utiliser options.retarder
  function startFramedDisplay(playerId, action, perso, options) {
    options = options || {};
    if (options.secret) {
      if (playerIsGM(playerId)) {
        if (!options.chuchote) options.chuchote = true;
      } else {
        var character = getObj('character', perso.charId);
        if (character) {
          if (!options.chuchote)
            options.chuchote = '"' + character.get('name') + '"';
          var controledByGM = false;
          var charControlledby = character.get('controlledby');
          charControlledby.split(",").forEach(function(controlledby) {
            if (playerIsGM(controlledby)) controledByGM = true;
          });
          if (!controledByGM) options.retarde = true;
        } else options.retarde = true;
      }
    }
    let display = {
      output: '',
      isOdd: true,
      isfirst: true,
      perso1: perso,
      perso2: options.perso2,
      action: action,
      action_right: options.action_right,
      image: options.image,
      retarde: options.retarde
    };
    if (!options.retarde)
      addFramedHeader(display, playerId, options.chuchote);
    return display;
  }

  function addLineToFramedDisplay(display, line, size, newLine) {
    size = size || 100;
    newLine = (newLine !== undefined) ? newLine : true;
    var background_color, border = '',
      separator = '';
    if (!newLine) display.isOdd = !display.isOdd;
    if (display.isOdd) {
      background_color = "#FFF";
      display.isOdd = false;
    } else {
      background_color = "#f3f3f3";
      display.isOdd = true;
    }
    if (size < 100) background_color = "#fcf8e3";
    if (!display.isfirst) {
      if (newLine) border = "border-top: 1px solid #333;";
    } else display.isfirst = false;
    var formatedLine = '<div style="padding: 0 5px 0; background-color: ' + background_color + '; color: #000;' + border + '">';

    if (!newLine) separator = "border-top: 1px solid #ddd;";
    formatedLine += '<div style="padding: 4px 0; font-size: ' + size + '%;' + separator + '">' + line + '</div>';
    formatedLine += '</div>';
    display.output += formatedLine;
  }

  function startTableInFramedDisplay(display, options) {
    display.output += "<table>";
    display.endColumn = true;
  }

  function endTableInFramedDisplay(display) {
    if (!display.endColumn) display.output += "</tr>";
    display.output += "</table>";
  }

  //newLine indique qu'on commence une nouvelle rang\xE9e
  function addCellInFramedDisplay(display, cell, size, newLine, fond) {
    size = size || 100;
    if (display.endColumn) {
      display.output += '<tr>';
      display.endColumn = false;
    } else if (newLine) display.output += '</tr><tr>';
    var color = '#FFF';
    if (fond) color = "#d3d3d3";
    display.output += '<td style="background-color: ' + color + '; font-size: ' + size + '%;">' + cell + '</td>';
  }

  function endFramedDisplay(display) {
    if (display.header === undefined) {
      error("Pas de titre pour le cadre", display);
      return;
    }
    var res = display.header + display.output;
    res += '</div>'; // line_content
    res += '</div>'; // all_content
    return res;
  }

  function nomLimiteCapa(capa, unite) {
    var nomLimite = 'limitePar';
    switch (unite) {
      case 'tour':
      case 'Tour':
        nomLimite += 'Tour';
        break;
      case 'combat':
      case 'Combat':
        nomLimite += 'Combat';
        break;
      case 'jour':
      case 'Jour':
        nomLimite += 'Jour';
        break;
      default:
        error("Unit\xE9 d'utilisation de capacit\xE9 " + capa + " non reconnue", unite);
        return;
    }
    return nomLimite + '__' + capa;
  }

  function capaciteDisponibleSachantPred(perso, capa, unite) {
    let nomLimite = nomLimiteCapa(capa, unite);
    if (nomLimite === undefined) return false;
    return attributeAsInt(perso, nomLimite, 1) > 0;
  }

  function capaciteDisponible(perso, capa, unite) {
    if (!predicateAsBool(perso, capa)) return false;
    return capaciteDisponibleSachantPred(perso, capa, unite);
  }

  function bonusAuxCompetences(personnage, comp, expliquer) {
    let bonus = 0;
    switch (comp) {
      case 'acrobatie':
      case 'acrobaties':
        if (predicateAsBool(personnage, 'graceFelineVoleur')) {
          let bonusGraceFeline = modCarac(personnage, 'charisme');
          if (bonusGraceFeline > 0) {
            expliquer("Gr\xE2ce f\xE9line : +" + bonusGraceFeline + " en acrobaties");
            bonus += bonusGraceFeline;
          }
        }
        if (predicateAsBool(personnage, 'pirouettes') && malusArmure(personnage) <= 4) {
          expliquer("Pirouettes : +5 en acrobaties");
          bonus += 5;
        }
        break;
      case 'course':
        if (predicateAsBool(personnage, 'graceFelineVoleur')) {
          let bonusGraceFeline = modCarac(personnage, 'charisme');
          if (bonusGraceFeline > 0) {
            expliquer("Gr\xE2ce f\xE9line : +" + bonusGraceFeline + " en course");
            bonus += bonusGraceFeline;
          }
        }
        break;
      case 'danse':
        if (predicateAsBool(personnage, 'pirouettes') && malusArmure(personnage) <= 4) {
          expliquer("Pirouettes : +5 en danse");
          bonus += 5;
        }
        break;
      case 'discr\xE9tion':
      case 'discretion':
        if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
          expliquer("For\xEAt hostile : -5 en discr\xE9tion");
          bonus -= 5;
        }
        break;
      case 'intimidation':
        bonus += bonusArgumentDeTaille(personnage, expliquer);
        if (predicateAsBool(personnage, 'ordreDuChevalierDragon') && attributeAsBool(personnage, 'monteSur')) {
          expliquer("Chevalier Dragon mont\xE9 : +5 en intimidation");
          bonus += 5;
        }
        break;
      case 'escalade':
        if (predicateAsBool(personnage, 'graceFelineVoleur')) {
          let bonusGraceFeline = modCarac(personnage, 'charisme');
          if (bonusGraceFeline > 0) {
            expliquer("Gr\xE2ce f\xE9line : +" + bonusGraceFeline + " en escalade");
            bonus += bonusGraceFeline;
          }
        }
        break;
      case 'n\xE9gociation':
      case 'negociation':
        bonus += bonusArgumentDeTaille(personnage, expliquer);
        break;
      case 'orientation':
        if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
          expliquer("For\xEAt hostile : -5 en orientation");
          bonus -= 5;
        }
        break;
      case 'perception':
        if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
          expliquer("For\xEAt hostile : -5 en perception");
          bonus -= 5;
        }
        if (compagnonPresent(personnage, 'guetteur')) {
          expliquer("Guetteur : +5 en perception");
          bonus += 5;
        }
        break;
      case 'persuasion':
        bonus += bonusArgumentDeTaille(personnage, expliquer);
        if (predicateAsBool(personnage, 'ordreDuChevalierDragon') && attributeAsBool(personnage, 'monteSur')) {
          expliquer("Chevalier Dragon mont\xE9 : +5 en persuasion");
          bonus += 5;
        }
        break;
      case 'saut':
      case 'sauter':
        if (predicateAsBool(personnage, 'graceFelineVoleur')) {
          let bonusGraceFeline = modCarac(personnage, 'charisme');
          if (bonusGraceFeline > 0) {
            expliquer("Gr\xE2ce f\xE9line : +" + bonusGraceFeline + " en saut");
            bonus += bonusGraceFeline;
          }
        }
        break;
      case 'survie':
        if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
          expliquer("For\xEAt hostile : -5 en survie");
          bonus -= 5;
        }
        break;
    }
    return bonus;
  }

  function bonusTestToutesCaracs(personnage, options, testId, evt, expliquer) {
    if (options && options.cacheBonusToutesCaracs) {
      if (options.cacheBonusToutesCaracs.val !== undefined) {
        return options.cacheBonusToutesCaracs.val;
      }
    }
    var bonus = 0;
    if (attributeAsBool(personnage, 'chantDesHeros')) {
      var bonusChantDesHeros = getValeurOfEffet(personnage, 'chantDesHeros', 1);
      var chantDesHerosIntense = attributeAsInt(personnage, 'chantDesHerosTempeteDeManaIntense', 0);
      bonusChantDesHeros += chantDesHerosIntense;
      expliquer("Chant des h\xE9ros : +" + bonusChantDesHeros + " au jet");
      bonus += bonusChantDesHeros;
      if (chantDesHerosIntense && evt)
        removeTokenAttr(personnage, 'chantDesHerosTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'benediction')) {
      var bonusBenediction = getValeurOfEffet(personnage, 'benediction', 1);
      var benedictionIntense = attributeAsInt(personnage, 'benedictionTempeteDeManaIntense', 0);
      bonusBenediction += benedictionIntense;
      expliquer("B\xE9n\xE9diction : +" + bonusBenediction + " au jet");
      bonus += bonusBenediction;
      if (benedictionIntense && evt)
        removeTokenAttr(personnage, 'benedictionTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'lameDeLigneePerdue')) {
      expliquer("Lame de lign\xE9e perdue : -1 au jet");
      bonus -= 1;
    }
    if (attributeAsBool(personnage, 'strangulation')) {
      var malusStrangulation =
        1 + attributeAsInt(personnage, 'dureeStrangulation', 0);
      expliquer("Strangulation : -" + malusStrangulation + " au jet");
      bonus -= malusStrangulation;
    }
    if (attributeAsBool(personnage, 'nueeDInsectes')) {
      var malusNuee = 2 + attributeAsInt(personnage, 'nueeDInsectesTempeteDeManaIntense', 0);
      expliquer("Nu\xE9e d\'insectes : -" + malusNuee + " au jet");
      bonus -= malusNuee;
      if (malusNuee > 2 && evt)
        removeTokenAttr(personnage, 'nueeDInsectesTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'nueeDeCriquets')) {
      var malusNueeCriquets =
        3 + attributeAsInt(personnage, 'nueeDeCriquetsTempeteDeManaIntense', 0);
      expliquer("Nu\xE9e de criquets : -" + malusNueeCriquets + " au jet");
      bonus -= malusNueeCriquets;
      if (malusNueeCriquets > 3 && evt)
        removeTokenAttr(personnage, 'nueeDeCriquetsTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'nueeDeScorpions')) {
      expliquer("Nu\xE9e de scorpions : -3 au jet");
      bonus -= 3;
    }
    if (attributeAsBool(personnage, 'etatExsangue')) {
      expliquer("Exsangue : -2 au jet");
      bonus -= 2;
    }
    if (attributeAsBool(personnage, 'putrefactionOutrTombe')) {
      expliquer("Putr\xE9fi\xE9 : -2 au jet");
      bonus -= 2;
    }
    let fortifie = attributeAsInt(personnage, 'fortifie', 0);
    if (fortifie > 0) {
      expliquer("Fortifi\xE9 : +3 au jet");
      bonus += 3;
      if (evt) {
        fortifie--;
        if (fortifie === 0) {
          removeTokenAttr(personnage, 'fortifie', evt);
        } else {
          setTokenAttr(personnage, 'fortifie', fortifie, evt);
        }
      }
    }
    if (attributeAsBool(personnage, 'ondesCorruptrices') &&
      !predicateAsBool(personnage, 'porteurDuBouclierDeGrabuge') &&
      !attributeAsBool(personnage, 'sangDeLArbreCoeur')) {
      let malusOndesCorruptrices = attributeAsInt(personnage, 'ondesCorruptrices', 2);
      let msgOndesCorruptrices = "Naus\xE9eu" + onGenre(personnage, "x", "se");
      msgOndesCorruptrices += " : -" + malusOndesCorruptrices;
      expliquer(msgOndesCorruptrices + " aux tests");
      bonus -= malusOndesCorruptrices;
    }
    if (attributeAsBool(personnage, 'fievreux')) {
      bonus -= 2;
      expliquer("Fi\xE9vreu" + onGenre(personnage, 'x', 'se') + " : -2 aux tests");
    }
    let bonusCondition = attributeAsInt(personnage, 'modificateurTests', 0);
    if (bonusCondition != 0) {
      bonus += bonusCondition;
      if (bonusCondition > 0) {
        expliquer("Bonus de condition : +" + bonusCondition);
      } else {
        expliquer("P\xE9nalit\xE9 de condition : " + bonusCondition);
      }
    }
    if (options) {
      if (options.bonus) bonus += options.bonus;
      if (options.chanceRollId && options.chanceRollId[testId]) bonus += options.chanceRollId[testId];
      let malusCasque = false;
      if (options.bonusAttrs) {
        options.bonusAttrs.forEach(function(attr) {
          let bonusAttribut = charAttributeAsInt(personnage, attr, 0);
          if (bonusAttribut !== 0) {
            expliquer("Attribut " + attr + " : " + ((bonusAttribut < 0) ? "-" : "+") + bonusAttribut);
            bonus += bonusAttribut;
          }
          if (!options.competence || attr != options.competence.trim().toLowerCase())
            bonus += bonusAuxCompetences(personnage, attr, expliquer);
        });
      }
      if (options.bonusPreds) {
        options.bonusPreds.forEach(function(pred) {
          let bonusPred = predicateAsInt(personnage, pred, 0);
          if (bonusPred !== 0) {
            expliquer("Pr\xE9dicat " + pred + " : " + ((bonusPred < 0) ? "-" : "+") + bonusPred);
            bonus += bonusPred;
          }
        });
      }
      if (malusCasque && ficheAttributeAsBool(personnage, 'casque_on', false)) {
        malusCasque = ficheAttributeAsInt(personnage, 'casque_malus', 0);
        if (malusCasque > 0) {
          expliquer("Malus de casque : -" + malusCasque);
          bonus -= malusCasque;
        }
      }
      if (options.cacheBonusToutesCaracs) {
        options.cacheBonusToutesCaracs.val = bonus;
      }
    }
    return bonus;
  }

  function bonusArgumentDeTaille(perso, expliquer) {
    let bonus = 0;
    if (predicateAsBool(perso, 'argumentDeTaille')) {
      let modFor = modCarac(perso, 'force');
      if (modFor > 0) {
        bonus += modFor;
        expliquer("Argument de taille : +" + modFor);
      }
    }
    let allies = alliesParPerso[perso.charId];
    if (allies === undefined) return bonus;
    const pageId = perso.token.get('pageid');
    const tokens = findObjs({
      _type: 'graphic',
      _subtype: 'token',
      _pageid: pageId,
      layer: 'objects'
    });
    tokens.forEach(function(tok) {
      if (tok.id == perso.token.id) return;
      var ci = tok.get('represents');
      if (ci === '') return;
      if (!allies.has(ci)) return;
      let allie = {
        token: tok,
        charId: ci
      };
      if (!predicateAsBool(allie, 'argumentDeTaille')) return;
      if (distanceCombat(perso.token, tok, pageId) > 0) return;
      let modFor = modCarac(allie, 'force');
      if (modFor <= 0) return;
      bonus += modFor;
      expliquer("Argument de taille de " + tok.get('name') + " : +" + modFor);
    });
    return bonus;
  }

  //expliquer est optionnel, et si pr\xE9sent, il faut msg
  function malusArmure(personnage, expliquer, msg) {
    let malusArmure = 0;
    if (ficheAttributeAsInt(personnage, 'defarmureon', 0))
      malusArmure += ficheAttributeAsInt(personnage, 'defarmuremalus', 0);
    if (ficheAttributeAsInt(personnage, 'defbouclieron', 0))
      malusArmure += ficheAttributeAsInt(personnage, 'defboucliermalus', 0);
    if (expliquer && malusArmure > 0) {
      expliquer("Armure : -" + malusArmure + msg);
    }
    return malusArmure;
  }

  //retourne un entier
  // evt n'est d\xE9fini que si la caract\xE9ristique est effectivement utilis\xE9e
  function bonusTestCarac(carac, personnage, options, testId, evt, explications) {
    const expliquer = function(msg) {
      if (explications) explications.push(msg);
    };
    let bonus = 0;
    // D'abord la partie qui d\xE9pend de la caract\xE9ristique
    if (persoEstPNJ(personnage)) {
      bonus = ficheAttributeAsInt(personnage, PNJCaracOfMod(carac), 0);
    } else {
      bonus = modCarac(personnage, caracOfMod(carac));
      bonus += ficheAttributeAsInt(personnage, carac + "_BONUS", 0);
    }
    expliquer("Bonus de " + carac + " : " + bonus);
    let bonusCarac = bonus;
    let bonusAspectDuDemon;
    let bonusForce;
    switch (carac) {
      case 'DEX':
        if (attributeAsBool(personnage, 'agrandissement')) {
          expliquer("Agrandi : -2 au jet de DEX");
          bonus -= 2;
        }
        if (attributeAsBool(personnage, 'aspectDuDemon')) {
          bonusAspectDuDemon = getValeurOfEffet(personnage, 'aspectDuDemon', 2);
          expliquer("Aspect du d\xE9mon : +" + bonusAspectDuDemon + " au jet de DEX");
          bonus += bonusAspectDuDemon;
        }
        if (attributeAsBool(personnage, 'osBrises')) {
          expliquer("Des os sont bris\xE9s : -2 au jet de DEX");
          bonus -= 2;
        }
        if (attributeAsBool(personnage, 'espaceExigu')) {
          bonusForce = modCarac(personnage, 'force');
          if (bonusForce < 1) bonusForce = 1;
          expliquer("Espace exigu : -" + bonusForce + " au jet de DEX");
          bonus -= bonusForce;
        } else if (attributeAsBool(personnage, 'constructionTailleHumaine')) {
          expliquer("Construction de taille humaine : -1 au jet de DEX");
          bonus -= 1;
        }
        if (attributeAsBool(personnage, 'reactionAllergique')) {
          expliquer("D\xE9mangeaisons : -2 au jet de DEX");
          bonus -= 2;
        }
        break;
      case 'FOR':
        if (attributeAsBool(personnage, 'rayonAffaiblissant')) {
          let malusRayonAffaiblissant = getValeurOfEffet(personnage, 'rayonAffaiblissant', 2);
          expliquer("Affaibli : -" + malusRayonAffaiblissant + " au jet de FOR");
          bonus -= malusRayonAffaiblissant;
        }
        if (attributeAsBool(personnage, 'agrandissement')) {
          expliquer("Agrandi : +2 au jet de FOR");
          bonus += 2;
        }
        if (attributeAsBool(personnage, 'aspectDuDemon')) {
          bonusAspectDuDemon = getValeurOfEffet(personnage, 'aspectDuDemon', 2);
          expliquer("Aspect du d\xE9mon : +" + bonusAspectDuDemon + " au jet de FOR");
          bonus += bonusAspectDuDemon;
        }
        if (attributeAsBool(personnage, 'osBrises')) {
          expliquer("Des os sont bris\xE9s : -2 au jet de FOR");
          bonus -= 2;
        }
        if (attributeAsBool(personnage, 'espaceExigu')) {
          bonusForce = modCarac(personnage, 'force');
          if (bonusForce < 1) bonusForce = 1;
          expliquer("Espace exigu : -" + bonusForce + " au jet de FOR");
          bonus -= bonusForce;
        } else if (attributeAsBool(personnage, 'constructionTailleHumaine')) {
          expliquer("Construction de taille humaine : -1 au jet de FOR");
          bonus -= 1;
        }
        if (predicateAsBool(personnage, 'grosseTete')) {
          let bonusInt;
          if (persoEstPNJ(personnage)) {
            bonusInt = ficheAttributeAsInt(personnage, 'pnj_int', 0);
          } else {
            bonusInt = modCarac(personnage, 'intelligence');
            bonusInt += ficheAttributeAsInt(personnage, "INT_BONUS", 0);
          }
          if (bonusInt > bonusCarac) {
            let msgGrosseTete = "Grosse t\xEAte : ";
            if (bonusInt > 0) msgGrosseTete += '+';
            msgGrosseTete += bonusInt + " au lieu de ";
            if (bonusCarac > 0) msgGrosseTete += '+';
            msgGrosseTete += bonusCarac;
            expliquer(msgGrosseTete);
            bonus += bonusInt - bonusCarac;
          }
        }
        break;
      case 'CHA':
        if (attributeAsBool(personnage, 'aspectDeLaSuccube')) {
          let bonusAspectDeLaSuccube = getValeurOfEffet(personnage, 'aspectDeLaSuccube', 5);
          expliquer("Aspect de la succube : +" + bonusAspectDeLaSuccube + " au jet de CHA");
          bonus += bonusAspectDeLaSuccube;
        }
        if (attributeAsBool(personnage, 'reactionAllergique')) {
          expliquer("Plaques allergiques : -2 au jet de CHA");
          bonus -= 2;
        }
        break;
      case 'CON':
        if (attributeAsBool(personnage, 'mutationSilhouetteMassive')) {
          expliquer("Silhouette massive : +5 au jet de CON");
          bonus += 5;
        }
        if (predicateAsBool(personnage, 'controleDuMetabolisme')) {
          let mod = modCarac(personnage, 'charisme');
          if (mod > 0) {
            expliquer("Controle du m\xE9tabolisme : +" + mod + " au jet de CON");
            bonus += mod;
          }
        }
        if (attributeAsBool(personnage, 'aspectDuDemon')) {
          bonusAspectDuDemon = getValeurOfEffet(personnage, 'aspectDuDemon', 2);
          expliquer("Aspect du d\xE9mon : +" + bonusAspectDuDemon + " au jet de CON");
          bonus += bonusAspectDuDemon;
        }
        break;
    }
    let bonusCompetence;
    if (options && options.competence) {
      let comp = options.competence.trim().toLowerCase();
      let competences = extractRepeating(personnage, 'competences');
      let bestFit = false;
      let competenceTrouvee;
      for (let id in competences) {
        if (bestFit) continue;
        let c = competences[id];
        if (c.comp_nom === undefined) continue;
        if (c.comp_nom.trim().toLowerCase() != comp) continue;
        competenceTrouvee = c;
        bonusCompetence = fieldAsInt(c, 'comp_bonus', 0);
        let compCarac = fieldAsString(c, 'comp_carac', 'FOR');
        if (compCarac == carac) {
          bestFit = true;
        } else if (c.comp_caracs) {
          let caracsLimitees = c.comp_caracs.split(',');
          bestFit = caracsLimitees.includes(carac);
        }
      }
      if (bonusCompetence === undefined) {
        let compSansBlanc = options.competence.toLowerCase().replace(/ /g, '_');
        options.bonusAttrs = options.bonusAttrs || [];
        options.bonusAttrs.push(compSansBlanc);
        options.bonusPreds = options.bonusPreds || [];
        options.bonusPreds.push(compSansBlanc);
      } else {
        let msgComp = "Comp\xE9tence " + options.competence + " : ";
        if (bonusCompetence === 0) {
          msgComp += 0;
        } else {
          bonus += bonusCompetence;
          if (bonusCompetence > 0) msgComp += "+" + bonusCompetence;
          else msgComp += bonusCompetence;
        }
        expliquer(msgComp);
        let malus = fieldAsString(competenceTrouvee, 'comp_malus', '');
        if (malus == 'armure') {
          bonus -= malusArmure(personnage, expliquer, '');
        } else if (malus == 'casque' && ficheAttributeAsBool(personnage, 'casque_on', false)) {
          let malusCasque = ficheAttributeAsInt(personnage, 'casque_malus', 0);
          if (malusCasque > 0) {
            expliquer("Casque : -" + malusCasque);
            bonus -= malusCasque;
          }
        }
      }
      bonus += bonusAuxCompetences(personnage, comp, expliquer);
    }
    if (bonusCompetence === undefined) {
      if (carac == 'DEX') {
        bonus -= malusArmure(personnage, expliquer, ' aux jets de DEX');
      }
    }
    // Puis la partie commune
    options = options || {};
    bonus += bonusTestToutesCaracs(personnage, options, testId, evt, expliquer);
    //Pas besoin de mettre la valeur de caract\xE9ristique si c'est le seul bonus
    if (explications && explications.length == 1) explications.pop();
    return bonus;
  }

  function computeDice(lanceur, options) {
    options = options || {};
    var nbDe = options.nbDe;
    if (nbDe === undefined) nbDe = 1;
    var plusFort = options.plusFort;
    if (plusFort === undefined) plusFort = true;
    var dice = options.dice;
    if (dice === undefined) dice = deTest(lanceur, options.carac);
    if (attributeAsBool(lanceur, 'malediction')) {
      if (plusFort) {
        if (nbDe > 1) nbDe--;
        else {
          nbDe = 2;
          plusFort = false;
        }
      } else nbDe++;
    }
    var de = nbDe + "d" + dice;
    if (nbDe > 1) {
      if (plusFort) de += "kh1";
      else de += "kl1";
    }
    return de;
  }

  // Test de caract\xE9ristique
  // options : bonusAttrs, bonusPreds, bonus, roll
  // Apr\xE8s le test, lance callback(testRes, explications
  // testRes.texte est l'affichage du jet de d\xE9
  // testRes.reussite indique si le jet est r\xE9ussi
  // testRes.echecCritique, testRes.critique pour le type
  // testRes.valeur pour la valeur totale du jet
  // testRes.rerolls pour le texte avec les boutons de rerolls adapt\xE9s.
  // testRes.modifiers pour les boutons qui peuvent \xEAtre activ\xE9s sur le roll, qu'il soit r\xE9ussi ou non.
  // Pour que les boutons de rerolls fonctionnent, le type d'\xE9v\xE8nement doit \xEAtre support\xE9 par redoEvent()
  // ne rajoute pas evt \xE0 l'historique
  function testCaracteristique(personnage, carac, seuil, testId, options, evt, callback) { //asynchrone
    options = options || {};
    let testRes = {};
    let explications = [];
    if (carac == 'SAG' || carac == 'INT' || carac == 'CHA') {
      if (predicateAsBool(personnage, 'sansEsprit')) {
        testRes.reussite = true;
        testRes.texte = "(sans esprit : r\xE9ussite automatique)";
        callback(testRes, explications);
        return;
      }
    }
    let bonusCarac = bonusTestCarac(carac, personnage, options, testId, evt, explications);
    let jetCache = ficheAttributeAsBool(personnage, 'jets_caches', false);
    let testsRatesDuTour;
    let listeTestsRatesDuTour;
    let testDejaRate;
    let adaptable = predicateAsInt(personnage, 'adaptable', 0);
    if (adaptable) {
      testsRatesDuTour = tokenAttribute(personnage, 'testsRatesDuTour');
      if (testsRatesDuTour.length > 0) {
        testsRatesDuTour = testsRatesDuTour[0];
        listeTestsRatesDuTour = testsRatesDuTour.get('current').split(' ');
        let testRate = listeTestsRatesDuTour.includes(testId);
        if (testRate) {
          testDejaRate = true;
          bonusCarac += adaptable;
        } else {
          testRate = testsRatesDuTour.get('max').split(' ').includes(testId);
          if (testRate) {
            bonusCarac += adaptable;
          }
        }
      } else testsRatesDuTour = undefined;
    }
    let carSup = nbreDeTestCarac(carac, personnage);
    let de = computeDice(personnage, {
      nbDe: carSup,
      carac: carac
    });
    if (estAffaibli(personnage) && predicateAsBool(personnage, 'insensibleAffaibli')) bonusCarac -= 2;
    let plageEC = 1;
    let plageECText = '1';
    if (options.plageEchecCritique) {
      plageEC = options.plageEchecCritique;
      if (plageEC > 1) plageECText = '<' + plageEC;
    }
    let rollExpr = "[[" + de + "cs20cf" + plageECText + "]]";
    try {
      sendChat("", rollExpr, function(res) {
        options.rolls = options.rolls || {};
        let roll = options.rolls[testId] || options.roll || res[0].inlinerolls[0];
        roll.token = personnage.token;
        evt.action = evt.action || {};
        evt.action.rolls = evt.action.rolls || {};
        evt.action.rolls[testId] = roll;
        testRes.roll = roll;
        let d20roll = roll.results.total;
        let bonusText = (bonusCarac > 0) ? "+" + bonusCarac : (bonusCarac === 0) ? "" : bonusCarac;
        testRes.texte = jetCache ? d20roll + bonusCarac : buildinline(roll) + bonusText;
        if (d20roll == 20) {
          testRes.reussite = true;
          testRes.critique = true;
        } else if (d20roll <= plageEC) {
          testRes.reussite = false;
          testRes.echecCritique = true;
          diminueMalediction(personnage, evt);
        } else if (d20roll + bonusCarac >= seuil) {
          testRes.reussite = true;
        } else {
          diminueMalediction(personnage, evt);
          testRes.reussite = false;
        }
        testRes.valeur = d20roll + bonusCarac;
        if (adaptable) {
          if (testRes.reussite) {
            if (testsRatesDuTour && listeTestsRatesDuTour) {
              if (listeTestsRatesDuTour.includes(testId)) {
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: testsRatesDuTour,
                  current: testsRatesDuTour.get('current'),
                });
                listeTestsRatesDuTour = listeTestsRatesDuTour.filter(function(i) {
                  return i != testId;
                });
                testsRatesDuTour.set('current', listeTestsRatesDuTour.join(' '));
              }
            }
          } else if (!testDejaRate) {
            if (testsRatesDuTour && listeTestsRatesDuTour) {
              listeTestsRatesDuTour.push(testId);
              evt.attributes = evt.attributes || [];
              evt.attributes.push({
                attribute: testsRatesDuTour,
                current: testsRatesDuTour.get('current'),
              });
              testsRatesDuTour.set('current', listeTestsRatesDuTour.join(' '));
            } else {
              setTokenAttr(personnage, 'testsRatesDuTour', testId, evt);
            }
          }
        }
        testRes.rerolls = '';
        var pc = pointsDeChance(personnage);
        if (!testRes.echecCritique && pc > 0) {
          testRes.rerolls += '<br/>' +
            boutonSimple("!cof-bouton-chance " + evt.id + " " + testId, "Chance") +
            " (reste " + pc + " PC)";
        }
        if (stateCOF.combat && attributeAsBool(personnage, 'runeForgesort_\xE9nergie') &&
          attributeAsInt(personnage, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0 &&
          (carac == 'FOR' || carac == 'CON' || carac == 'DEX')) {
          testRes.rerolls += '<br/>' + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + testId, "Rune d'\xE9nergie");
        }
        if (stateCOF.combat && capaciteDisponible(personnage, 'petitVeinard', 'combat')) {
          testRes.rerolls += '<br/>' + boutonSimple("!cof-bouton-petit-veinard " + evt.id + " " + testId, "Petit veinard");
        }
        if (stateCOF.combat && !testRes.echecCritique &&
          capaciteDisponible(personnage, 'prouesse', 'tour') &&
          (carac == 'FOR' || carac == 'DEX')) {
          testRes.rerolls += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + testId, "Prouesse");
        }
        testRes.modifiers = '';
        if (predicateAsBool(personnage, 'tourDeForce') && carac == 'FOR') {
          testRes.modifiers += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + testId, "Tour de Force");
        }
        let pacteSanglant = predicateAsInt(personnage, 'pacteSanglant', 0);
        if (pacteSanglant >= 3) {
          testRes.modifiers += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + testId, "Pacte sanglant (+3)");
          if (pacteSanglant >= 5) {
            testRes.modifiers += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + testId, "Pacte sanglant (+5)");
          }
        }
        if (jetCache) sendChat('COF', "/w GM Jet cach\xE9 : " + buildinline(roll) + bonusText);
        callback(testRes, explications);
      });
    } catch (e) {
      error("Erreur pendant l'\xE9valuation de " + rollExpr + " dans un test de caract\xE9ristiques");
      log(e.name + ": " + e.message);
    }
  }

  function pointsDeChance(perso) {
    if (!estPJ(perso)) return 0;
    var optionPC = ficheAttributeAsInt(perso, 'option_pc', 1);
    if (optionPC === 0) return 0;
    return ficheAttributeAsInt(perso, 'pc', 3);
  }

  //callback peut prendre en argument une structure avec les champs:
  // - texte: Le texte du jet
  // - total : Le r\xE9sultat total du jet
  // - echecCritique, critique pour indiquer si 1 ou 20
  // - roll: le inlineroll
  function jetCaracteristique(personnage, carac, options, testId, evt, callback) {
    let explications = [];
    let bonusCarac = bonusTestCarac(carac, personnage, options, testId, evt, explications);
    let carSup = nbreDeTestCarac(carac, personnage);
    let jetCache = ficheAttributeAsBool(personnage, 'jets_caches', false);
    let de = computeDice(personnage, {
      nbDe: carSup,
      carac: carac,
      dice: options.dice
    });
    if (estAffaibli(personnage) && predicateAsBool(personnage, 'insensibleAffaibli')) bonusCarac -= 2;
    let bonusText = '';
    if (bonusCarac > 0) {
      bonusText = ' + ' + bonusCarac;
    } else if (bonusCarac < 0) {
      bonusText = ' - ' + (-bonusCarac);
    }
    let plageEC = 1;
    let plageECText = '1';
    if (options && options.plageEchecCritique) {
      plageEC = options.plageEchecCritique;
      if (plageEC > 1) plageECText = '<' + plageEC;
    }
    let rollExpr = "[[" + de + "cs20cf" + plageECText + "]]";
    sendChat("", rollExpr, function(res) {
      options.rolls = options.rolls || {};
      let roll = options.rolls[testId] || res[0].inlinerolls[0];
      evt.action = evt.action || {};
      evt.action.rolls = evt.action.rolls || {};
      evt.action.rolls[testId] = roll;
      roll.token = personnage.token;
      let d20roll = roll.results.total;
      let rtext = jetCache ? d20roll + bonusCarac : buildinline(roll) + bonusText;
      let rt = {
        total: d20roll + bonusCarac,
      };
      if (d20roll <= plageEC) {
        rtext += " -> \xE9chec critique";
        rt.echecCritique = true;
      } else if (d20roll == 20) {
        rtext += " -> r\xE9ussite critique";
        rt.critique = true;
      } else if (bonusCarac !== 0 && !jetCache) rtext += " = " + rt.total;
      rt.texte = rtext;
      rt.roll = roll;
      if (jetCache) sendChat('COF', "/w GM Jet cach\xE9 de caract\xE9ristique : " + buildinline(roll) + bonusText);
      callback(rt, explications);
    });
  }

  function jetPerso(perso, caracteristique, difficulte, titre, playerId, options) {
    options = options || {};
    const evt = options.evt || {
      type: 'jetPerso',
      personnage: perso,
      action: {
        caracteristique: caracteristique,
        difficulte: difficulte,
        titre: titre,
        playerId: playerId,
        options: options
      }
    };
    addEvent(evt);
    let optionsDisplay = {
      secret: options.secret
    };
    const display = startFramedDisplay(playerId, titre, perso, optionsDisplay);
    const testId = 'jet_' + perso.charId + '_' + caracteristique;
    if (difficulte === undefined) {
      jetCaracteristique(perso, caracteristique, options, testId, evt,
        function(rt, explications) {
          addLineToFramedDisplay(display, "<b>R\xE9sultat :</b> " + rt.texte);
          explications.forEach(function(m) {
            addLineToFramedDisplay(display, m, 80);
          });
          addStatistics(playerId, ["Jet de carac", caracteristique], rt.roll);
          // Maintenant, on diminue la mal\xE9diction si le test est un \xE9chec
          let attrMalediction = tokenAttribute(perso, 'malediction');
          if (attrMalediction.length > 0) {
            if (rt.echecCritique)
              diminueMalediction(perso, evt, attrMalediction);
            else if (!rt.critique) {
              var action = "!cof-resultat-jet " + stateCOF.eventId;
              var ligne = "L'action est-elle ";
              ligne += bouton(action + " reussi", "r\xE9ussie", perso);
              ligne += " ou " + bouton(action + " rate", "rat\xE9e", perso);
              ligne += " ?";
              addLineToFramedDisplay(display, ligne);
              evt.attenteResultat = true;
            }
          }
          let boutonsReroll = '';
          let pc = pointsDeChance(perso);
          if (pc > 0 && !rt.echecCritique) {
            boutonsReroll +=
              '<br/>' + boutonSimple("!cof-bouton-chance " + evt.id + " " + testId, "Chance") +
              " (reste " + pc + " PC)";
          }
          if (stateCOF.combat && attributeAsBool(perso, 'runeForgesort_\xE9nergie') &&
            attributeAsInt(perso, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0 &&
            (caracteristique == 'FOR' || caracteristique == 'CON' || caracteristique == 'DEX')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + testId, "Rune d'\xE9nergie");
          }
          if (stateCOF.combat && capaciteDisponible(perso, 'petitVeinard', 'combat')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-bouton-petit-veinard " + evt.id + " " + testId, "Petit veinard");
          }
          if (stateCOF.combat &&
            !rt.echecCritique && capaciteDisponible(perso, 'prouesse', 'tour') &&
            (caracteristique == 'FOR' || caracteristique == 'DEX')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + testId, "Prouesse");
          }
          if (caracteristique == 'FOR' && predicateAsBool(perso, 'tourDeForce')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + testId, "Tour De Force");
          }
          let pacteSanglant = predicateAsInt(perso, 'pacteSanglant', 0);
          if (pacteSanglant >= 3) {
            boutonsReroll += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + testId, "Pacte sanglant (+3)");
            if (pacteSanglant >= 5) {
              boutonsReroll += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + testId, "Pacte sanglant (+5)");
            }
          }
          addLineToFramedDisplay(display, boutonsReroll);
          if (display.retarde) {
            addFramedHeader(display, playerId, true);
            sendChat('', endFramedDisplay(display));
            addFramedHeader(display, undefined, 'gm');
            sendChat('', endFramedDisplay(display));
          } else sendChat('', endFramedDisplay(display));
        });
    } else {
      testCaracteristique(perso, caracteristique, difficulte, testId, options, evt,
        function(tr, explications) {
          addLineToFramedDisplay(display, "<b>R\xE9sultat :</b> " + tr.texte);
          explications.forEach(function(m) {
            addLineToFramedDisplay(display, m, 80);
          });
          if (tr.reussite) {
            addLineToFramedDisplay(display, "C'est r\xE9ussi." + tr.modifiers);
          } else {
            var msgRate = "C'est rat\xE9." + tr.rerolls + tr.modifiers;
            addLineToFramedDisplay(display, msgRate);
          }
          if (display.retarde) {
            addFramedHeader(display, playerId, true);
            sendChat('', endFramedDisplay(display));
            addFramedHeader(display, undefined, 'gm');
            sendChat('', endFramedDisplay(display));
          } else sendChat('', endFramedDisplay(display));
        });
    }
  }

  //Par construction, msg.content ne doit pas contenir d'option --nom,
  //et commencer par !cof-jet
  function boutonsCompetences(display, perso, carac, msg, fond) {
    let action = msg.content;
    action = action.replace(/ --competences /, '');
    action = action.replace(/ --competences/, ''); //au cas o\xF9 ce serait le dernier argument
    var args = action.substring(9); //on enl\xE8ve !cof-jet
    if (!args.startsWith(carac)) action = "!cof-jet " + carac + " " + args;
    let overlay;
    switch (carac) {
      case 'FOR':
        overlay = 'Force';
        break;
      case 'DEX':
        overlay = 'Dext\xE9rit\xE9';
        break;
      case 'CON':
        overlay = 'Constitution';
        break;
      case 'INT':
        overlay = 'Intelligence';
        break;
      case 'SAG':
        overlay = 'Sagesse';
        break;
      case 'CHA':
        overlay = 'Charisme';
        break;
    }
    let charButtonStyle = ' style="border-radius:10px;" title="' + overlay + '"';
    let cell = boutonSimple(action, carac, charButtonStyle);
    addCellInFramedDisplay(display, cell, 60, true, fond);
    let comps = [...listeCompetences[carac].list];
    let competences = extractRepeating(perso, 'competences');
    let compsMinuscules = listeCompetences[carac].elts;
    for (let id in competences) {
      const c = competences[id];
      let compCarac = fieldAsString(c, 'comp_carac', 'FOR');
      if (compCarac != carac) {
        let compCaracs = c.comp_caracs;
        if (compCaracs === undefined) continue;
        compCaracs = compCaracs.split(',');
        if (!compCaracs.includes(carac)) continue;
      }
      let nom = c.comp_nom;
      if (nom === undefined) continue;
      let nomCompMinuscule = nom.trim().toLowerCase();
      if (compsMinuscules.has(nomCompMinuscule)) continue;
      comps.push(nom);
    }
    cell = '';
    let sec = false;
    comps.forEach(function(comp) {
      if (sec) cell += ' ';
      else sec = true;
      let buttonStyle = ' style="background-color:#996600; padding:1px 2px; border-radius:5px;"';
      cell += boutonSimple(action + " --nom " + comp, comp, buttonStyle);
    });
    addCellInFramedDisplay(display, cell, 80, false, fond);
  }

  // prend une distance en m\xE8tre et retourne une distance dans l'unit\xE9
  // utilis\xE9e sur la page du personnage
  function scaleDistance(perso, distance) {
    if (perso.scale) return distance * perso.scale;
    let pageId = perso.pageId;
    if (pageId === undefined) {
      pageId = perso.token.get('pageid');
      perso.pageId = pageId;
    }
    const page = getObj("page", pageId);
    if (page === undefined) {
      perso.scale = 1;
      return distance;
    }
    let unit = page.get('scale_units');
    switch (unit) {
      case 'm':
        perso.scale = 1;
        break;
      case 'ft':
        perso.scale = 3.28084;
        break;
      case 'cm':
        perso.scale = 100;
        break;
      case 'km':
        perso.scale = 0.001;
        break;
      case 'mi':
        perso.scale = 0.000621371;
        break;
      case 'in':
        perso.scale = 39.3701;
        break;
      default:
        sendChat('COF', "Attention, unit\xE9 de mesure de la page (" + unit + ") non reconnue");
        perso.scale = 1;
    }
    return distance * perso.scale;
  }

  function getPageId(playerId) {
    var pageId;
    if (playerIsGM(playerId)) {
      var player = getObj('player', playerId);
      pageId = player.get('lastpage');
    }
    if (pageId === undefined || pageId === "") {
      var pages = Campaign().get('playerspecificpages');
      if (pages && pages[playerId] !== undefined) {
        return pages[playerId];
      }
      return Campaign().get('playerpageid');
    }
    return pageId;
  }

  // si d\xE9fini, callback est appel\xE9 \xE0 chaque \xE9l\xE9ment de selected
  // qui n'est pas un personnage
  // iter seulement sur les \xE9l\xE9ment qui correspondent \xE0 des personnages
  function iterSelected(selected, iter, callback) {
    selected.forEach(function(sel) {
      let token = getObj('graphic', sel._id);
      if (token === undefined) {
        if (callback !== undefined) callback();
        return;
      }
      let charId = token.get('represents');
      if (charId === undefined || charId === "") {
        if (callback !== undefined) callback();
        return;
      }
      iter({
        token: token,
        charId: charId
      });
    });
  }

  function getWalls(page, pageId, murs) {
    if (murs) return murs;
    if (!page.get('lightrestrictmove')) return;
    murs = findObjs({
      _type: 'path',
      _pageid: pageId,
      layer: 'walls'
    });
    murs = murs.map(function(path) {
      var p = {
        angle: path.get('rotation') / 180 * Math.PI,
        width: path.get('width'),
        height: path.get('height'),
        top: path.get('top'),
        left: path.get('left'),
        scaleX: path.get('scaleX'),
        scaleY: path.get('scaleY'),
      };
      var chemin = JSON.parse(path.get('_path'));
      if (chemin.length < 2) return [];
      if (chemin[1][0] != 'L') return [];
      chemin = chemin.map(function(v) {
        return translatePathCoordinates(v[1], v[2], p);
      });
      return chemin;
    });
    return murs;
  }

  // callback(selected, playerId, aoe)
  function getSelected(msg, callback, options) {
    options = options || {};
    let playerId = getPlayerIdFromMsg(msg);
    let pageId;
    if (options.pageId) pageId = options.pageId;
    else pageId = getPageId(playerId);
    let args = msg.content.split(' --');
    let selected = [];
    let enleveAuxSelected = [];
    let count = args.length - 1;
    let called;
    let actif = options.lanceur;
    if (actif === undefined) {
      if (msg.selected !== undefined && msg.selected.length == 1) {
        actif = persoOfId(msg.selected[0]._id, msg.selected[0]._id, pageId);
      }
    }
    let page;
    let murs;
    let pt;
    let aoe;
    let finalCall = function() {
      called = true;
      let seen = new Set();
      let res = selected.filter(function(sel) {
        if (seen.has(sel._id)) return false;
        seen.add(sel._id);
        let interdit = enleveAuxSelected.find(function(i) {
          return (i._id == sel._id);
        });
        return (interdit === undefined);
      });
      callback(res, playerId, aoe);
    };
    if (args.length > 1) {
      args.shift();
      args.forEach(function(cmd) {
        count--;
        const cmdSplit = cmd.split(' ');
        switch (cmdSplit[0]) {
          case 'equipe':
            var nomEquipe = 'Equipe' + cmd.substring(cmd.indexOf(' '));
            var equipes = findObjs({
              _type: 'handout',
              name: nomEquipe
            });
            if (equipes.length === 0) {
              error(nomEquipe + " inconnue", msg.content);
              return;
            }
            if (equipes.length > 1) {
              error("Plus d'une " + nomEquipe, cmd);
            }
            count += equipes.length;
            equipes.forEach(function(equipe) {
              equipe.get('notes', function(note) { //asynchrone
                var persos = charactersInHandout(note, nomEquipe);
                var tokens = findObjs({
                  _type: 'graphic',
                  _subtype: 'token',
                  _pageid: pageId,
                  layer: 'objects'
                });
                let uneCible = false;
                tokens.forEach(function(tok) {
                  let tokCharId = tok.get('represents');
                  if (persos.has(tokCharId)) {
                    uneCible = true;
                    selected.push({
                      _id: tok.id
                    });
                  }
                });
                if (!uneCible) {
                  error("Pas de token de l'" + nomEquipe + " sur la page");
                }
                count--;
                if (count === 0) finalCall();
              });
            });
            return;
          case 'allies':
          case 'saufAllies':
            if (options.ignoreAllies) return;
            let selection = selected;
            let saufAllies = (cmdSplit[0] == 'saufAllies');
            if (saufAllies) selection = enleveAuxSelected;
            let actives = [];
            let allies = new Set();
            // First get the acting token (in msg.selected)
            if (actif) {
              actives = [actif];
              allies = alliesParPerso[actif.charId] || allies;
              if (saufAllies) allies = (new Set(allies)).add(actif.charId);
            } else {
              if (msg.selected === undefined || msg.selected.length === 0) {
                error("Pas d'alli\xE9 car pas de token s\xE9lectionn\xE9", msg);
                return;
              }
              iterSelected(msg.selected, function(personnage) {
                actives.push(personnage);
                let alliesPerso = alliesParPerso[personnage.charId];
                if (alliesPerso) {
                  alliesPerso.forEach(function(ci) {
                    allies.add(ci);
                  });
                }
                if (saufAllies) allies.add(personnage.charId);
              });
            }
            var tokens = findObjs({
              _type: 'graphic',
              _subtype: 'token',
              _pageid: pageId,
              layer: 'objects'
            });
            tokens.forEach(function(tok) {
              var ci = tok.get('represents');
              if (ci === '') return;
              if (!allies.has(ci)) return;
              //On enl\xE8ve le token actif, mais seulement pour allies
              if (cmdSplit[0] == 'allies') {
                if (actives.indexOf(function(perso) {
                    return perso.charId == ci;
                  }) >= 0) return;
              }
              selection.push({
                _id: tok.id
              });
            });
            return;
          case 'self':
            if (actif) {
              selected.push({
                _id: actif.token.id
              });
              return;
            }
            if (msg.selected === undefined) return;
            msg.selected.forEach(function(obj) {
              let inSelf = selected.findIndex(function(o) {
                return (o._id == obj._id);
              });
              if (inSelf < 0) selected.push(obj);
            });
            return;
          case 'target':
            if (cmdSplit.length < 2) {
              error("Il manque l'id de la cible (apr\xE8s --target)", cmd);
              return;
            }
            selected.push({
              _id: cmdSplit[1]
            });
            return;
          case 'disque':
            if (options.ignoreDisque) return;
            if (cmdSplit.length < 3) {
              error("Pas assez d'arguments pour d\xE9finir un disque", cmdSplit);
              return;
            }
            let centre = persoOfId(cmdSplit[1], cmdSplit[1], pageId);
            if (centre === undefined) {
              error("le premier argument du disque n'est pas un token valide", cmdSplit);
              return;
            }
            let tokenCentre = centre.token;
            let rayon = parseInt(cmdSplit[2]);
            if (isNaN(rayon) || rayon < 0) {
              error("Rayon du disque mal d\xE9fini", cmdSplit);
              return;
            }
            let portee;
            if (cmdSplit.length > 3) {
              portee = parseInt(cmdSplit[3]);
              if (isNaN(portee) || portee < 0) {
                error("La port\xE9e du disque est mal form\xE9e", cmdSplit);
                return;
              }
              if (actif === undefined) {
                error("Pas de token s\xE9lectionn\xE9 pour calculer la distance du disque", msg);
                return;
              }
              if (distanceCombat(tokenCentre, actif.token, pageId, {
                  strict1: true
                }) > portee) {
                sendPerso(actif, "Le centre de l'effet est plac\xE9 trop loin (port\xE9e " + portee + " m)");
                return;
              }
            }
            aoe = aoe || {};
            aoe.type = 'disque';
            aoe.centre = tokenCentre;
            aoe.rayon = rayon;
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            let pc;
            if (murs) {
              pc = {
                x: tokenCentre.get('left'),
                y: tokenCentre.get('top')
              };
            }
            let allToksDisque =
              findObjs({
                _type: "graphic",
                _pageid: pageId,
                _subtype: 'token',
                layer: 'objects'
              });
            allToksDisque.forEach(function(obj) {
              if (portee === 0 && obj.id == actif.token.id) return; //on ne se cible pas si le centre de l'aoe est soi-m\xEAme
              let objCharId = obj.get('represents');
              if (objCharId === '') return;
              if (getState({
                  token: obj,
                  charId: objCharId
                }, 'mort')) return; //pas d'effet aux morts
              if (obj.get('bar1_max') == 0) return; // jshint ignore:line
              let objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              let distanceCentre = distanceCombat(tokenCentre, obj, pageId, {
                strict1: true
              });
              if (distanceCentre > rayon) return;
              if (murs) {
                if (obstaclePresent(obj.get('left'), obj.get('top'), pc, murs)) return;
              }
              selected.push({
                _id: obj.id
              });
            });
            if (options.targetFx) {
              spawnFx(tokenCentre.get('left'), tokenCentre.get('top'), options.targetFx, pageId);
            }
            if (tokenCentre.get('bar1_max') == 0) { // jshint ignore:line
              //C'est juste un token utilis\xE9 pour d\xE9finir le disque
              tokenCentre.remove(); //On l'enl\xE8ve, normalement plus besoin
              delete options.targetFx;
            }
            return;
          case 'enVue':
            let observateur = actif;
            if (cmdSplit.length > 1) {
              observateur = persoOfId(cmdSplit[1], cmdSplit[1], pageId);
            }
            if (observateur === undefined) {
              error("Impossible de trouver la personne \xE0 partir de laquelle on s\xE9lectionne les tokens en vue", msg);
              return;
            }
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            if (murs) {
              pt = pt || {
                x: observateur.token.get('left'),
                y: observateur.token.get('top')
              };
            }
            let tokensEnVue = findObjs({
              _type: 'graphic',
              _pageid: pageId,
              _subtype: 'token',
              layer: 'objects'
            });
            tokensEnVue.forEach(function(obj) {
              if (obj.id == actif.token.id) return; //on ne se cible pas si le centre de l'aoe est soi-m\xEAme
              var objCharId = obj.get('represents');
              if (objCharId === '') return;
              if (obj.get('bar1_max') == 0) return; // jshint ignore:line
              var objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              if (murs) {
                if (obstaclePresent(obj.get('left'), obj.get('top'), pt, murs)) return;
              }
              selected.push({
                _id: obj.id
              });
            });
            return;
          case 'alliesEnVue':
            if (actif === undefined) {
              error("Impossible de trouver la personne dont on s\xE9lectionne les lli\xE9s en vue", msg);
              return;
            }
            var alliesEnVue = alliesParPerso[actif.charId];
            if (alliesEnVue === undefined) {
              log("Personnage sans alli\xE9", actif);
              return;
            }
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            if (murs) {
              pt = pt || {
                x: actif.token.get('left'),
                y: actif.token.get('top')
              };
            }
            var tokensAlliesEnVue = findObjs({
              _type: 'graphic',
              _pageid: pageId,
              _subtype: 'token',
              layer: 'objects'
            });
            tokensAlliesEnVue.forEach(function(obj) {
              if (obj.id == actif.token.id) return; //on ne se cible pas si le centre de l'aoe est soi-m\xEAme
              var objCharId = obj.get('represents');
              if (objCharId === '') return;
              if (!alliesEnVue.has(objCharId)) return;
              if (obj.get('bar1_max') == 0) return; // jshint ignore:line
              var objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              if (murs) {
                if (obstaclePresent(obj.get('left'), obj.get('top'), pt, murs)) return;
              }
              selected.push({
                _id: obj.id
              });
            });
            return;
          default:
        }
      });
    }
    if (count === 0) {
      if (selected.length === 0) {
        if (msg.selected) {
          if (!called) {
            let res = msg.selected.filter(function(sel) {
              let interdit = enleveAuxSelected.find(function(i) {
                return (i._id == sel._id);
              });
              return (interdit === undefined);
            });
            callback(res, playerId, aoe);
          }
          return;
        }
        if (!called) callback([], playerId, aoe);
        return;
      }
      if (!called) finalCall();
    }
  }

  //msg peut \xEAtre directement le playerId ou un message
  function getPlayerIdFromMsg(msg) {
    if (msg.playerid === undefined) return msg;
    let playerId = msg.playerid;
    if (playerId == 'API') {
      let nom = msg.who;
      if (nom === undefined) return playerId;
      nom = nom.replace(/ \(GM\)/, '');
      //On regarde si un joueur s'appelle nom
      let players = findObjs({
        type: 'player',
        displayname: nom
      });
      if (players.length === 0) {
        let characters = findObjs({
          type: 'character',
          name: nom
        });
        if (characters.length === 0) {
          error("Impossible de trouver l'id du joueur " + nom, msg);
          return playerId;
        }
        let pids = characters[0].get('controlledby');
        pids = pids.split(',');
        if (pids[0] == 'all') {
          players = findObjs({
            type: 'player'
          });
          playerId = players[0].id;
        } else playerId = pids[0];
      } else playerId = players[0].id;
    }
    return playerId;
  }

  //!cof-jet [carac] [difficulte]
  // - carac : FOR, DEX, CON, INT, SAG, CHA
  // Les tokens s\xE9lectionn\xE9s sont ceux qui doivent faire le jet
  function jet(msg) {
    let opts = msg.content.split(' --');
    let cmd = opts.shift().split(' ');
    let options = {
      bonusAttrs: [],
      bonusPreds: []
    };
    opts.forEach(function(o) {
      let args = o.split(' ');
      switch (args[0]) {
        case 'nom':
          if (args.length < 2) {
            error("Il manque un argument \xE0 l'option " + args[0], opts);
            return;
          }
          args.shift();
          let nom = args.join(' ');
          if (options.nom && options.nom != nom) {
            error("Nom du jet d\xE9fini deux fois !", options.nom);
          }
          options.nom = nom;
          if (options.competence) {
            options.bonusAttrs.push(nom.toLowerCase());
            options.bonusPreds.push(nom.toLowerCase());
          } else options.competence = nom;
          return;
        case 'attribut':
          if (args.length < 2) {
            error("Il manque un argument \xE0 l'option " + args[0], opts);
            return;
          }
          options.bonusAttrs.push(args[1]);
          return;
        case 'predicat':
          if (args.length < 2) {
            error("Il manque un argument \xE0 l'option " + args[0], opts);
            return;
          }
          options.bonusPreds.push(args[1]);
          return;
        case 'bonus':
          if (args.length < 2) {
            error("Il manque un argument \xE0 l'option " + args[0], opts);
            return;
          }
          var bonus = parseInt(args[1]);
          if (isNaN(bonus)) {
            error("Le bonus doit \xEAtre un nombre", opts);
            return;
          }
          options.bonus = (options.bonus || 0) + bonus;
          return;
        case 'secret':
        case 'competences':
          options[args[0]] = true;
          return;
        case 'plageEchecCritique':
          if (args.length < 2) {
            error("Il manque un argument \xE0 l'option " + args[0], opts);
            return;
          }
          var plageEC = parseInt(args[1]);
          if (isNaN(plageEC) || plageEC < 0 || plageEC > 19) {
            error("La plage d'\xE9checs critqiques doit \xEAtre un nombre positif inf\xE9rieur \xE0 19", opts);
            return;
          }
          options.plageEchecCritique = plageEC;
      }
    });
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Utilisation de !cof-jet sans s\xE9lection de token", playerId);
        return;
      }
      if (cmd.length < 2) { //On demande la carac et la comp\xE9tence, si d\xE9finies dans un handout Comp\xE9tence
        if (options.nom) {
          error("Il manque la caract\xE9ristique \xE0 utiliser pour la comp\xE9tence " + options.nom, msg.content);
          return;
        }
        let fond = listeCompetences.nombre > 25;
        iterSelected(selected, function(perso) {
          let display = startFramedDisplay(playerId, "Jet de caract\xE9ristique", perso, {
            chuchote: true
          });
          startTableInFramedDisplay(display);
          boutonsCompetences(display, perso, 'FOR', msg);
          boutonsCompetences(display, perso, 'DEX', msg, fond);
          boutonsCompetences(display, perso, 'CON', msg);
          boutonsCompetences(display, perso, 'SAG', msg, fond);
          boutonsCompetences(display, perso, 'INT', msg);
          boutonsCompetences(display, perso, 'CHA', msg, fond);
          endTableInFramedDisplay(display);
          sendChat('', endFramedDisplay(display));
        }); //fin de iterSelected
        return;
      }
      let caracteristique = cmd[1];
      if (!isCarac(caracteristique)) {
        error("Caracteristique '" + caracteristique + "' non reconnue (FOR, DEX, CON, INT, SAG, CHA).", cmd);
        return;
      }
      if (options.competences && options.nom === undefined) {
        iterSelected(selected, function(perso) {
          let display = startFramedDisplay(playerId, "Jet de " + caracteristique, perso, {
            chuchote: true
          });
          addLineToFramedDisplay(display, "Choisissez la comp\xE9tence");
          startTableInFramedDisplay(display);
          boutonsCompetences(display, perso, caracteristique, msg);
          endTableInFramedDisplay(display);
          sendChat('', endFramedDisplay(display));
        }); //fin de iterSelected
        return;
      }
      let difficulte;
      if (cmd.length > 2) {
        difficulte = parseInt(cmd[2]);
        if (isNaN(difficulte)) difficulte = undefined;
      }
      let titre = "Jet d";
      let nomJet;
      if (options.nom && options.nom.length > 0) {
        nomJet = options.nom;
      } else {
        nomJet = caracOfMod(caracteristique).toLowerCase();
      }
      let nj = nomJet.toLowerCase();
      switch (nj[0]) {
        case 'a':
        case 'e':
        case 'i':
        case 'o':
        case 'u':
          titre += "'<b>";
          break;
        default:
          titre += "e <b>";
      }
      titre += nomJet;
      titre += "</b>";
      if (nj == 'perception') {
        options.bonusAttrs.push('diversionManoeuvreValeur');
      }
      if (options.bonus)
        titre += " (" + ((options.bonus > 0) ? '+' : '') + options.bonus + ")";
      if (difficulte !== undefined) titre += " difficult\xE9 " + difficulte;
      iterSelected(selected, function(perso) {
        jetPerso(perso, caracteristique, difficulte, titre, playerId, options);
      }); //fin de iterSelected
    }); //fin de getSelected
  }

  function resultatJet(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("La fonction !cof-resultat-jet n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("Le jet est trop ancien ou \xE9te annul\xE9", args);
      return;
    }
    if (evt.personnage === undefined) {
      error("Erreur interne ", evt);
      return;
    }
    if (evt.attenteResultat) {
      var message = evt.type + " ";
      if (args[2] == 'rate') {
        diminueMalediction(evt.personnage, evt);
        message += "rat\xE9.";
      } else message += "r\xE9ussi.";
      sendPerso(evt.personnage, message);
      delete evt.attenteResultat;
    } else {
      sendPlayer(msg, "R\xE9sultat d\xE9j\xE0 d\xE9cid\xE9");
    }
  }

  var tempeteDeManaCourante = {
    vide: true
  };

  function ajouterOptionTempete(display, option, texte, restant) {
    var line = texte + " : ";
    if (tempeteDeManaCourante[option])
      line += boutonSimple("!cof-tempete-de-mana -" + option, "Oui");
    else if (restant > 0)
      line += boutonSimple("!cof-tempete-de-mana " + option, "Non");
    else line += "Non";
    addLineToFramedDisplay(display, line);
  }

  function optionsDeTempeteDeMana(msg) {
    if (tempeteDeManaCourante.vide) {
      error("Pas de temp\xEAte de mana en cours", tempeteDeManaCourante);
      return;
    }
    let perso = tempeteDeManaCourante.perso;
    let cmd = msg.content.split(' ');
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'duree':
        case 'portee':
        case 'rapide':
          if (tempeteDeManaCourante[cmd[1]]) break;
          tempeteDeManaCourante[cmd[1]] = true;
          tempeteDeManaCourante.cout++;
          break;
        case '-duree':
        case '-portee':
        case '-rapide':
        case '-altruiste':
          let opt = cmd[1].substring(1);
          if (tempeteDeManaCourante[opt]) {
            tempeteDeManaCourante[opt] = false;
            tempeteDeManaCourante.cout--;
          }
          break;
        case 'altruiste':
          if (cmd.length < 3) {
            error("Il manque l'id du token pour l'option altruiste de la tempete de mana", cmd);
            return;
          }
          let cible = persoOfId(cmd[2]);
          if (cmd[2] == perso.token.id) cible = undefined;
          if (cible) {
            if (!tempeteDeManaCourante.altruiste) tempeteDeManaCourante.cout++;
          } else {
            if (tempeteDeManaCourante.altruiste) tempeteDeManaCourante.cout--;
          }
          tempeteDeManaCourante.altruiste = cible;
          break;
        default:
          let it = parseInt(cmd[1]);
          if (isNaN(it) || it < 0) {
            error("Argument de !cof-tempete-de-mana inconnu", cmd);
            return;
          }
          if (tempeteDeManaCourante.intense === undefined)
            tempeteDeManaCourante.intense = 0;
          tempeteDeManaCourante.cout += it - tempeteDeManaCourante.intense;
          tempeteDeManaCourante.intense = it;
      }
    }
    let title = "Temp\xEAte de mana";
    if (tempeteDeManaCourante.cout) {
      title += " de puissance " + tempeteDeManaCourante.cout;
    }
    let restant = 100;
    if (tempeteDeManaCourante.max) {
      title += " (max " + tempeteDeManaCourante.max + ")";
      restant = tempeteDeManaCourante.max - tempeteDeManaCourante.cout;
    }
    let display = startFramedDisplay(tempeteDeManaCourante.playerId, title, perso, {
      chuchote: true
    });
    if (tempeteDeManaCourante.dureeDeBase &&
      tempeteDeManaCourante.dm === undefined &&
      tempeteDeManaCourante.soins === undefined)
      ajouterOptionTempete(display, "duree", "Dur\xE9e", restant);
    if (tempeteDeManaCourante.porteeDeBase)
      ajouterOptionTempete(display, "portee", "Port\xE9e", restant);
    ajouterOptionTempete(display, "rapide", "Rapide", restant);
    if (tempeteDeManaCourante.altruistePossible) {
      let la = 'Magie altruiste : ';
      if (restant || tempeteDeManaCourante.altruiste) {
        let tla = "S\xE9lectionner";
        if (tempeteDeManaCourante.altruiste) {
          tla = tempeteDeManaCourante.altruiste.token.get('name');
        }
        la += boutonSimple("!cof-tempete-de-mana altruiste @{target|token_id}", tla);
      } else la += 'Non';
      addLineToFramedDisplay(display, la);
    }
    let line = "Magie intense :";
    let magieIntense = 0;
    if (tempeteDeManaCourante.intense)
      magieIntense = tempeteDeManaCourante.intense;
    let maxMagieIntense = magieIntense + restant;
    if (maxMagieIntense > 5 && restant > 0) maxMagieIntense = magieIntense + 1;
    for (var i = 0; i <= maxMagieIntense; i++) {
      if (i == magieIntense) line += " " + i;
      else line += " " + boutonSimple("!cof-tempete-de-mana " + i, i);
    }
    addLineToFramedDisplay(display, line);
    var v = tempeteDeManaCourante.cmd;
    var vopt = '';
    if (tempeteDeManaCourante.cout) {
      vopt = "--tempeteDeMana";
      if (tempeteDeManaCourante.duree) vopt += " duree";
      if (tempeteDeManaCourante.portee) vopt += " portee";
      if (tempeteDeManaCourante.rapide) vopt += " rapide";
      if (tempeteDeManaCourante.altruiste)
        vopt += " altruiste " + tempeteDeManaCourante.altruiste.token.id;
      if (tempeteDeManaCourante.intense)
        vopt += " " + tempeteDeManaCourante.intense;
    }
    v = v.replace(/--tempeteDeMana/, vopt);
    addLineToFramedDisplay(display, boutonSimple(v, "Valider"));
    sendChat("", endFramedDisplay(display));
  }

  function setTempeteDeMana(playerId, perso, cmd, options) {
    tempeteDeManaCourante = {
      perso: perso,
      playerId: playerId,
      cmd: cmd,
      rapide: options.rapide,
      dm: options.dm,
      soins: options.soins,
      intense: options.intense,
      porteeDeBase: options.portee,
      dureeDeBase: options.duree,
      altruistePossible: options.altruiste,
      cout: options.cout || 0
    };
    let max;
    if (options.rang) max = options.rang;
    let mana = options.mana || 0;
    const niveau = ficheAttributeAsInt(perso, 'niveau', 1);
    let cout_par_effet = 1;
    if (reglesOptionelles.mana.val.mana_totale.val) cout_par_effet = 3;
    if (max === undefined || max > niveau - (mana / cout_par_effet))
      max = Math.floor(niveau - (mana / cout_par_effet));
    if (max < 1) {
      sendPerso(perso, "ne peut pas d\xE9penser plus de mana en temp\xEAte de mana (niveau " + niveau + ", mana d\xE9j\xE0 d\xE9pens\xE9e " + mana + ")");
      return;
    }
    tempeteDeManaCourante.max = max;
    optionsDeTempeteDeMana({
      content: '!cof-tempete-de-mana'
    });
  }

  function parseTempeteDeMana(cmd, options) {
    cmd.shift();
    options.tempeteDeMana = {
      cout: 0
    };
    let altruiste = false;
    cmd.forEach(function(ta) {
      switch (ta) {
        case 'portee':
          if (options.tempeteDeManaPortee) break;
          options.tempeteDeMana.cout++;
          options.tempeteDeManaPortee = true;
          altruiste = false;
          break;
        case 'duree':
          if (options.tempeteDeManaDuree) break;
          options.tempeteDeMana.cout++;
          options.tempeteDeManaDuree = true;
          altruiste = false;
          break;
        case 'rapide':
          options.tempeteDeMana.cout++;
          break;
        case 'altruiste':
          options.altruiste = true;
          altruiste = true;
          break;
        default:
          if (altruiste) {
            altruiste = false;
            let cible = persoOfId(ta);
            if (cible) {
              options.tempeteDeMana.cout++;
              options.tempeteDeMana.altruiste = cible;
            }
          } else {
            let intensite = parseInt(ta);
            if (isNaN(ta) || ta <= 0) {
              error("Option de temp\xEAte de mana " + ta + " non reconnue", cmd);
              break;
            }
            options.tempeteDeManaIntense = options.tempeteDeManaIntense || 0;
            options.tempeteDeManaIntense += intensite;
            options.tempeteDeMana.cout += intensite;
          }
      }
    });
    options.mana = options.mana || 0;
    if (reglesOptionelles.mana.val.mana_totale.val)
      options.mana += options.tempeteDeMana.cout * 3;
    else options.mana += options.tempeteDeMana.cout;
  }

  function parseCondition(args) {
    if (args.length > 0 && (args[0] == 'crit' || args[0] == 'critique')) {
      return {
        type: 'critique'
      };
    }
    switch (args[0]) {
      case 'etat':
        if (args.length < 2) {
          error("condition non reconnue", args);
          return;
        }
        if (_.has(cof_states, args[1])) {
          return {
            type: 'etat',
            etat: args[1],
            text: args[1]
          };
        }
        return {
          type: 'attribut',
          attribute: args[1],
          text: args[1]
        };
      case 'etatCible':
        if (args.length < 2) {
          error("condition non reconnue", args);
          return;
        }
        if (_.has(cof_states, args[1])) {
          return {
            type: 'etatCible',
            etat: args[1],
            text: args[1]
          };
        }
        return {
          type: 'attributCible',
          attribute: args[1],
          text: args[1]
        };
      case 'attributCible':
        if (args.length < 3) {
          error("Il manque un argument pour comparer l'attribut de la cible", args);
          return;
        }
        let res = {
          type: 'attributCible',
          attribute: args[1],
          valeur: args[2].toLowerCase(),
          text: args[1] + ' ' + args[2]
        };
        if (args.length > 3) {
          if (args[3] == 'local') {
            res.local = true;
          } else if (args[3] == 'fiche') {
            res.fiche = {};
            if (args.length > 4) {
              res.fiche.def = args[4];
            }
          }
        }
        return res;
      case 'predicatCible':
        if (args.length < 2) {
          error("Il manque le pr\xE9dicat de la cible", args);
          return;
        }
        let valeur;
        if (args.length > 2) valeur = args[2];
        return {
          type: 'predicatCible',
          predicat: args[1],
          valeur: valeur,
          text: args[1] + ' ' + valeur
        };
      case 'typeCible':
        if (args.length < 2) {
          error("Il manque le type de la cible", args);
          return;
        }
        return {
          type: 'typeCible',
          race: args[1],
          text: args[1]
        };
      case 'deAttaque':
        if (args.length < 2) {
          error("condition non reconnue", args);
          return;
        }
        var valeurDeAttaque = parseInt(args[1]);
        if (isNaN(valeurDeAttaque)) {
          error("La condition de d\xE9 d'attaque doit \xEAtre un nombre", args);
          // on continue expr\xE8s pour tomber dans le cas par d\xE9faut
        } else {
          return {
            type: 'deAttaque',
            seuil: valeurDeAttaque,
            text: args[1]
          };
        }
        /* falls through */
      default:
        return {
          type: args[0],
          attribute: args[1],
          text: args[1]
        };
    }
  }

  function closeIte(scope) {
    var ps = scope.parentScope;
    if (ps === undefined) return;
    log("Il manque un endif");
    delete scope.parentScope;
    closeIte(ps);
  }

  function getFx(cmd, argName, obj, funName) {
    if (cmd.length < 2) {
      let errMsg = "Il manque un argument \xE0 l'option --" + argName;
      if (funName) errMsg += " de " + funName;
      sendChat("COF", errMsg);
      return;
    }
    if (cmd[1] == 'custom' && cmd.length > 2) {
      let effet = findObjs({
        _type: 'custfx',
        name: cmd[2]
      });
      if (effet.length === 0) {
        sendChat("COF", "L'effet custom " + cmd[2] + " est inconnu.");
        return;
      }
      obj[argName] = effet[0].id;
    } else obj[argName] = cmd[1];
  }

  //Remplis les champs arme et armeGauche de perso
  //renvoie undefined si aucune arme en main principale
  //renvoie l'arme principale sinon undefined
  function armesEnMain(perso) {
    if (perso.armesEnMain) return perso.arme;
    let labelArme = tokenAttribute(perso, 'armeEnMain');
    if (labelArme.length > 0) {
      let labelArmePrincipale = labelArme[0].get('current');
      if (labelArmePrincipale) perso.arme = getWeaponStats(perso, labelArmePrincipale);
      let labelArmeGauche = labelArme[0].get('max');
      if (labelArmeGauche) perso.armeGauche = getWeaponStats(perso, labelArmeGauche);
      perso.armesEnMain = 'calculee';
      return perso.arme;
    }
    return;
  }

  function parseDmg(expr) {
    let dm = {
      nbDe: 0,
      dice: 4,
      bonus: 0
    };
    let exprDM = expr.trim().toLowerCase();
    let indexD = exprDM.indexOf('d');
    if (indexD > 0) {
      dm.nbDe = parseInt(exprDM.substring(0, indexD));
      if (isNaN(dm.nbDe) || dm.nbDe < 0) {
        error("Expression de d\xE9g\xE2ts " + exprDM + " mal form\xE9e", expr);
        return;
      }
      exprDM = exprDM.substring(indexD + 1);
      indexD = exprDM.search(/[+\-]/);
      if (indexD <= 0) {
        dm.dice = parseInt(exprDM);
        if (isNaN(dm.dice) || dm.dice < 1) {
          error("Nombre de faces incorrect dans l'expression des d\xE9g\xE2ts", expr);
          return;
        }
        return dm;
      }
      exprDM = exprDM.replace('+-', '-');
      dm.dice = parseInt(exprDM.substring(0, indexD));
      if (isNaN(dm.dice) || dm.dice < 1) {
        error("Nombre de faces incorrect dans l'expression des d\xE9g\xE2ts", expr);
        return;
      }
      exprDM = exprDM.substring(indexD).trim();
    }
    dm.bonus = parseInt(exprDM);
    if (isNaN(dm.bonus)) {
      error("Expression de d\xE9g\xE2ts incorrecte", expr);
      return;
    }
    return dm;
  }

  //Retourne un objet avec
  // - carac, et possiblement carac2 (si on a le choix)
  // - seuil
  function parseSave(cmd) {
    if (cmd.length < 3) {
      if (cmd.length > 0)
        error("Usage : --" + cmd[0] + " carac seuil", cmd);
      else
        error("parsing de sauvegarde", cmd);
      return;
    }
    const res = parseCarac(cmd[1]);
    if (res === undefined) {
      error("Le premier argument de save n'est pas une caract\xE9ristique", cmd);
      return;
    }
    res.seuil = parseInt(cmd[2]);
    if (isNaN(res.seuil)) {
      error("Le deuxi\xE8me argument de --psave n'est pas un nombre", cmd);
      return;
    }
    if (cmd.length > 3) {
      let optArgs = cmd.slice(3).join(' ');
      optArgs = optArgs.split(' +');
      optArgs.forEach(function(oa) {
        oa = oa.trim().split(' ');
        switch (oa[0]) {
          case 'carac':
          case 'carac2':
          case 'seuil':
            error("Argument suppl\xE9mentaire de save inconnu", cmd);
            return;
          case 'tempete':
            let ti = 1;
            if (oa.length > 1) {
              ti = parseInt(oa[1]);
              if (isNaN(ti)) ti = 1;
            }
            res.tempete = ti;
            return;
          case 'contact':
            if (oa.length < 2) {
              error("Il manque la difficult\xE9 pour les cibles au contact");
              return;
            }
            let diff = parseInt(oa[1]);
            if (isNaN(diff)) {
              error("La difficult\xE9 pour les cibles au contact n'est pas un nombre");
              return;
            }
            res.contact = diff;
            return;
          default:
            res[oa[0]] = true;
        }
      });
    }
    return res;
  }

  //!cof-attack id_attaquant id_cible label_attaque [options]
  function parseAttack(msg) {
    let optArgs = msg.content.split(' --');
    let args = optArgs[0].split(' ');
    args = args.filter(function(a) {
      return a !== '';
    });
    optArgs.shift();
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-attack: " + msg.content, args);
      return;
    }
    const attaquant = persoOfId(args[1]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-attack n'est pas un token valide", args[1]);
      return;
    }
    let targetToken = getObj('graphic', args[2]);
    if (targetToken === undefined) {
      error("le second argument de !cof-attack doit \xEAtre un token", args[2]);
      return;
    }
    let attackLabel;
    if (args.length > 3) {
      attackLabel = args.slice(3).join(' ').trim();
    }
    let weaponStats = {};
    let attaqueArray;
    try {
      attaqueArray = JSON.parse(attackLabel); //plus document\xE9 depuis 2020
    } catch (e) {}
    if (Array.isArray(attaqueArray) && attaqueArray.length > 4 &&
      attaqueArray[1].length > 1 && attaqueArray[3].length > 3) {
      weaponStats.name = attaqueArray[0].replace(/_/g, ' ');
      weaponStats.attSkill = attaqueArray[1][0];
      weaponStats.attSkillDiv = attaqueArray[1][1];
      weaponStats.crit = attaqueArray[2];
      var weaponDmg = attaqueArray[3];
      weaponStats.attNbDices = weaponDmg[0];
      weaponStats.attDice = weaponDmg[1];
      weaponStats.attCarBonus = weaponDmg[2];
      weaponStats.attDMBonusCommun = weaponDmg[3];
      weaponStats.portee = attaqueArray[4];
      if (attaqueArray.length > 5) {
        weaponStats.divers = attaqueArray[5];
      } else {
        weaponStats.divers = '';
      }
    } else {
      //On trouve l'attaque correspondant au label
      if (attackLabel == -1) { //attaque avec l'arme en main
        weaponStats = armesEnMain(attaquant);
        if (weaponStats === undefined) weaponStats = attaqueAMainsNues;
      } else if (attackLabel == -2) { //attaque avec l'arme en main gauche
        if (attaquant.armesEnMain === undefined) armesEnMain(attaquant);
        weaponStats = attaquant.armeGauche;
        if (weaponStats === undefined)
          weaponStats = getWeaponStats(attaquant, attackLabel);
      } else weaponStats = getWeaponStats(attaquant, attackLabel);
    }
    if (weaponStats === undefined) {
      error("Impossible de trouver l'arme pour l'attaque", attackLabel);
      return;
    }
    if (weaponStats.deuxMains && attributeAsBool(attaquant, 'espaceExigu')) {
      sendPerso(attaquant, "ne peut pas utiliser d'arme \xE0 deux mains dans un espace aussi exigu.");
      return;
    }
    //Si c'est aussi une arme de jet, et que le personnage attaque \xE0 distance, on va utiliser la version arme de jet de l'attaque.
    let msgIndex = msg.content;
    let indexAussiJet = msgIndex.indexOf('--aussiArmeDeJet ');
    if (indexAussiJet == -1) {
      msgIndex = weaponStats.options;
      indexAussiJet = msgIndex.indexOf('--aussiArmeDeJet ');
    }
    if (indexAussiJet > 0) {
      let labelAussiJet = parseInt(msgIndex.substring(indexAussiJet + 17));
      if (isNaN(labelAussiJet)) {
        error("Label --aussiArmeDeJet n'est pas un entier", msgIndex.substring(indexAussiJet + 17));
      } else {
        let armeAssociee = getWeaponStats(attaquant, labelAussiJet);
        if (armeAssociee === undefined) {
          error("Label --aussiArmeDeJet pas une attaque", labelAussiJet);
        } else {
          if (distanceCombat(attaquant.token, targetToken) > 0)
            weaponStats = armeAssociee;
        }
      }
    }
    //Ajout des options de l'arme
    let wo = weaponStats.options.trim();
    //Pour la partie options, il est possible qu'elle soit d\xE9j\xE0 pass\xE9e en ligne de commande
    if (wo !== '' && (optArgs.length < 1 || !optArgs[0].startsWith('attaqueOptions'))) {
      wo = ' ' + wo;
      wo.split(' --').reverse().forEach(function(o) {
        o = o.trim();
        if (o === '') return;
        optArgs.unshift(o);
      });
    }
    if (weaponStats.modificateurs) {
      weaponStats.modificateurs.split(',').reverse().forEach(function(m) {
        m = m.trim();
        if (m === '') return;
        m.split(' ').reverse().forEach(function(m) {
          m = m.trim();
          if (m === '') return;
          optArgs.unshift(m);
        });
      });
    }
    const playerId = getPlayerIdFromMsg(msg);
    const options = {
      sortilege: weaponStats.sortilege,
      hache: weaponStats.hache,
      armeNaturelle: weaponStats.armeNaturelle
    };
    switch (weaponStats.typeDegats) {
      case 'mental':
        options.attaqueMentale = true;
        /* falls through */
      case 'feu':
      case 'froid':
      case 'acide':
      case 'electrique':
      case 'sonique':
      case 'poison':
      case 'maladie':
      case 'drain':
      case 'energie':
        options.type = weaponStats.typeDegats;
        break;
      case 'tranchant':
      case 'percant':
      case 'contondant':
      case 'magique':
        options[weaponStats.typeDegats] = true;
        break;
    }
    var lastEtat; //dernier de etats et effets
    var lastType = options.type; //dernier type de d\xE9g\xE2ts inflig\xE9s
    var scope = options; //Pour les conditionnelles
    optArgs.forEach(function(arg) {
      arg = arg.trim();
      let cmd = arg.split(' ');
      cmd = cmd.filter(function(c) {
        return c !== '';
      });
      if (cmd.length === 0) cmd = [arg];
      switch (cmd[0]) {
        case 'ignoreMoitieRD':
        case 'pressionMortelle':
        case 'tempDmg':
        case 'enflamme':
        case 'malediction':
        case 'pietine':
        case 'percute':
        case 'maxDmg':
        case 'ouvertureMortelle':
        case 'seulementVivant':
        case 'etreinteImmole':
        case 'etreinteScorpion':
        case 'seulementDistance':
          scope[cmd[0]] = true;
          return;
        case 'arc':
        case 'arbalete':
        case 'attaqueAssuree':
        case 'attaqueRisquee':
        case 'attaqueOptions':
        case 'epieu':
        case 'hache':
        case 'marteau':
        case 'affute':
        case 'choc':
        case 'armeDArgent':
        case 'artificiel':
        case 'asDeLaGachette':
        case 'attaqueMentale':
        case 'auto':
        case 'avecd12':
        case 'demiAuto':
        case 'explodeMax':
        case 'explosion':
        case 'feinte':
        case 'ignoreObstacles':
        case 'mainsDEnergie':
        case 'pasDeDmg':
        case 'pointsVitaux':
        case 'poudre':
        case 'metal':
        case 'ferFroid':
        case 'reroll1':
        case 'reroll2':
        case 'semonce':
        case 'sortilege':
        case 'strigeSuce':
        case 'tirDeBarrage':
        case 'test':
        case 'traquenard':
        case 'tueurDeGeants':
        case 'tueurDeGrands':
        case 'grenaille':
        case 'attaqueArmeeConjuree':
        case 'difficultePVmax':
        case 'difficultePV':
        case 'lamesJumelles':
        case 'riposte':
        case 'secret':
        case 'saufAllies':
        case 'tirAveugle':
        case 'attaqueBouclierRenverse':
        case 'runeDePuissance':
        case 'necromancie':
          options[cmd[0]] = true;
          return;
        case 'aussiArmeDeJet':
          if (cmd.length < 2) {
            error("Il faut pr\xE9ciser l'arme associ\xE9e \xE0 celle-ci pour --aussiArmeDeJet", cmd);
            return;
          }
          options.aussiArmeDeJet = cmd[1];
          return;
        case 'm2d20':
        case 'avantage':
          options.avantage = options.avantage || 1;
          options.avantage++;
          return;
        case 'd\xE9savantage':
        case 'desavantage':
          options.avantage = options.avantage || 1;
          options.avantage--;
          return;
        case 'avecd12crit':
          options.avecd12 = {
            crit: true
          };
          return;
        case 'tranchant':
        case 'contondant':
        case 'percant':
          options.contondant = undefined;
          options.percant = undefined;
          options.tranchant = undefined;
          options[cmd[0]] = true;
          return;
        case 'nom':
        case 'special':
          if (cmd.length < 1) {
            error("Il manque le nom apr\xE8s l'option --" + cmd[0], cmd);
            return;
          }
          options[cmd[0]] = cmd.slice(1).join(' ').trim();
          return;
        case 'toucher':
        case 'modifiePortee':
          if (cmd.length < 1) {
            error("Il manque la valeur apr\xE8s l'option --" + cmd[0], cmd);
            return;
          }
          let intArg = parseInt(cmd[1]);
          if (isNaN(intArg)) {
            error("valeur de " + cmd[0] + " incorrecte", cmd);
            return;
          }
          options[cmd[0]] = intArg;
          return;
        case 'crit':
          if (cmd.length < 1) {
            error("Il manque la valeur apr\xE8s l'option --crit", cmd);
            return;
          }
          let crit = parseInt(cmd[1]);
          if (isNaN(crit)) {
            error("valeur de critique incorrecte", cmd);
            return;
          }
          if (crit < 2) crit = 2;
          else if (crit > 20) crit = 20;
          options.crit = crit;
          return;
        case 'dm':
          if (cmd.length < 1) {
            error("Il manque la valeur apr\xE8s l'option --dm", cmd);
            return;
          }
          let dm = parseDmg(cmd.slice(1).join(''));
          if (dm) options.dm = dm;
          return;
        case 'portee':
          if (cmd.length < 1) {
            error("Il manque la valeur apr\xE8s l'option --portee", cmd);
            return;
          }
          let portee = parseInt(cmd[1]);
          if (isNaN(portee) || portee < 0) {
            error("valeur de critique incorrecte", cmd);
            return;
          }
          options.portee = portee;
          return;
        case 'attaqueMagiqueDe':
          if (cmd.length < 1) {
            error("Il manque le nom du personnage apr\xE8s l'option --attaqueMagiqueDe", cmd);
            return;
          }
          let attaqueMagiqueDe = cmd.slice(1).join(' ');
          let ficheAttaqueMagique = findObjs({
            type: 'character',
            name: attaqueMagiqueDe
          });
          if (ficheAttaqueMagique.length === 0) {
            error("Il n'existe pas de personnage nomm\xE9 " + attaqueMagiqueDe, cmd);
            return;
          }
          if (ficheAttaqueMagique.length > 1) {
            error("Attention, il existe plus d'un pesonnage nomm\xE9 " + attaqueMagiqueDe, cmd);
          }
          let amCid = {
            charId: ficheAttaqueMagique[0].id
          };
          let toucher = computeArmeAtk(amCid, '@{ATKMAG}');
          if (isNaN(toucher)) {
            error("Impossible de d\xE9terminer l'attaque de " + attaqueMagiqueDe, toucher);
            return;
          }
          if (options.toucher !== undefined) {
            error("Attention, on a \xE0 la fois une option toucher et une option attaqueMagiqueDe. On ignore l'option --toucher", optArgs);
          }
          options.toucher = toucher;
          return;
        case 'imparable': //deprecated
          options.m2d20 = true;
          return;
        case 'tirDouble':
          if (cmd.length > 1)
            options.tirDouble = {
              label: cmd[1]
            };
          else options.tirDouble = options.tirDouble || true;
          return;
        case 'ignoreRD':
          if (cmd.length < 2) {
            scope.ignoreTouteRD = true;
            return;
          }
          scope.ignoreRD = parseInt(cmd[1]);
          if (isNaN(scope.ignoreRD) || scope.ignoreRD < 1) {
            log("Pas un nombre positif apr\xE8s --ignoreRD, interpr\xE9t\xE9 comme ignore toute la RD");
            scope.ignoreRD = undefined;
            scope.ignoreTouteRD = true;
          }
          return;
        case 'magique':
          var niveauMagie = 1;
          if (cmd.length > 1) {
            niveauMagie = parseInt(cmd[1]);
            if (isNaN(niveauMagie) || niveauMagie < 1) {
              error("Le niveau de magie doit \xEAtre au moins 1", cmd);
              niveauMagie = 1;
            }
          }
          options.magique = niveauMagie;
          return;
        case 'si':
          options.conditionAttaquant = parseCondition(cmd.slice(1));
          return;
        case 'tempsRecharge':
          if (cmd.length < 3) {
            error("Il manque un argument \xE0 l'option --tempsRecharge de !cof-attack", cmd);
            return;
          }
          if (!estEffetTemp(cmd[1])) {
            error("Le premier argument de l'option --tempsRecharge doit \xEAtre un effet temporaire r\xE9pertori\xE9", cmd);
            return;
          }
          var tr = parseInt(cmd[2]);
          if (isNaN(tr)) {
            error("Le deuxi\xE8me argument de l'option --tempsRecharge doit \xEAtre un nombre", cmd);
            return;
          }
          options.tempsRecharge = {
            effet: cmd[1],
            duree: tr
          };
          return;
        case 'plus':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --plus de !cof-attack", cmd);
            return;
          }
          var val = arg.substring(arg.indexOf(' ') + 1);
          scope.additionalDmg = scope.additionalDmg || [];
          scope.additionalDmg.push({
            value: val,
            type: scope.type
          });
          break;
        case 'plusCrit':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --plusCrit de !cof-attack", cmd);
            return;
          }
          let valCrit = arg.substring(arg.indexOf(' ') + 1);
          scope.additionalCritDmg = scope.additionalCritDmg || [];
          scope.additionalCritDmg.push({
            value: valCrit,
            type: scope.type
          });
          break;
        case 'dmSiRate':
        case 'dmCible':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --" + cmd[0] + " de !cof-attack", cmd);
            return;
          }
          let valDm = arg.substring(arg.indexOf(' ') + 1);
          options[cmd[0]] = {
            value: valDm,
            type: scope.type
          };
          break;
        case 'effet':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --effet de !cof-attack", cmd);
            return;
          }
          let effet = cmd[1];
          if (cof_states[effet] && cmd.length > 2) { //remplacer par sa version effet temporaire
            effet += 'Temp';
          }
          if (estEffetTemp(effet)) {
            let duree = 1;
            if (cmd.length > 2) {
              duree = parseInt(cmd[2]);
              if (isNaN(duree) || duree < 1) {
                error(
                  "Le deuxi\xE8me argument de --effet doit \xEAtre un nombre positif",
                  cmd);
                return;
              }
            }
            let m = messageOfEffetTemp(effet);
            lastEtat = {
              effet: effet,
              duree: duree,
              message: m,
              typeDmg: lastType
            };
            scope.seulementVivant = scope.seulementVivant || (m && m.seulementVivant);
          } else if (estEffetCombat(effet)) {
            lastEtat = {
              effet: effet,
              typeDmg: lastType,
              message: messageEffetCombat[effet]
            };
          } else if (estEffetIndetermine(effet)) {
            lastEtat = {
              effet: effet,
              effetIndetermine: true,
              typeDmg: lastType
            };
          } else {
            error(cmd[1] + " n'est pas un effet temporaire r\xE9pertori\xE9", cmd);
            return;
          }
          scope.effets = scope.effets || [];
          scope.effets.push(lastEtat);
          return;
        case 'valeur':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --valeur de !cof-attack", cmd);
            return;
          }
          if (scope.effets === undefined || scope.effets.length === 0) {
            error("Il faut un effet avant l'option --valeur", optArgs);
            return;
          }
          scope.effets[0].valeur = cmd[1];
          if (cmd.length > 2) {
            scope.effets[0].valeurMax = cmd[2];
            if (scope.effets[0].effet && scope.effets[0].effet.startsWith('dotGen(')) {
              scope.effets[0].typeDmg = cmd[2];
            }
          }
          return;
        case 'accumuleDuree':
          if (cmd.length < 2) {
            error("Il manque la valeur en argument de l'option --accumuleDuree", cmd);
            return;
          }
          var accumuleDuree = parseInt(cmd[1]);
          if (isNaN(accumuleDuree) || accumuleDuree < 1) {
            error("On ne peut accumuler qu'on nombre strictement positif d'effets", cmd);
            return;
          }
          if (scope.effets === undefined || scope.effets.length === 0) {
            error("Il faut un effet avant l'option --accumuleValeur", optArgs);
            return;
          }
          scope.effets[0].accumuleDuree = accumuleDuree;
          return;
        case 'optionEffet':
          if (cmd.length < 2) {
            error("Il manque l'option en argument de --optionEffet", cmd);
            return;
          }
          if (scope.effets === undefined || scope.effets.length === 0) {
            error("Il faut un effet avant l'option --optionEffet", optArgs);
            return;
          }
          scope.effets[0].options = scope.effets[0].options || '';
          scope.effets[0].options = ' --' + cmd.slice(1).join(' ') + scope.effets[0].options;
          return;
        case 'etatSi':
        case 'etat':
          if (cmd.length < 3 && cmd[0] == 'etatSi') {
            error("Il manque un argument \xE0 l'option --etatSi de !cof-attack", cmd);
            return;
          } else if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --etat de !cof-attack", cmd);
            return;
          }
          var etat = cmd[1];
          if (!_.has(cof_states, etat)) {
            error("Etat non reconnu", cmd);
            return;
          }
          var condition = 'toujoursVrai';
          if (cmd[0] == 'etatSi') {
            condition = parseCondition(cmd.slice(2));
            if (condition === undefined) return;
          }
          scope.etats = scope.etats || [];
          lastEtat = {
            etat: etat,
            condition: condition,
            typeDmg: lastType
          };
          if (cmd[0] == 'etat' && cmd.length > 3) {
            if (!isCarac(cmd[2]) && (cmd[2].length != 6 ||
                !isCarac(cmd[2].substring(0, 3)) || !isCarac(cmd[2].substring(3, 6)))) {
              error("Caract\xE9ristique du jet de sauvegarde incorrecte", cmd);
              return;
            }
            lastEtat.saveCarac = cmd[2];
            var opposition = persoOfId(cmd[3]);
            if (opposition) {
              lastEtat.saveDifficulte = cmd[3] + ' ' + opposition.token.get('name');
            } else {
              lastEtat.saveDifficulte = parseInt(cmd[3]);
              if (isNaN(lastEtat.saveDifficulte)) {
                error("Difficult\xE9 du jet de sauvegarde incorrecte", cmd);
                delete lastEtat.saveCarac;
                delete lastEtat.saveDifficulte;
              }
            }
          }
          scope.etats.push(lastEtat);
          return;
        case 'peur':
          if (cmd.length < 3) {
            error("Il manque un argument \xE0 l'option --peur de !cof-attack", cmd);
            return;
          }
          scope.peur = {
            seuil: parseInt(cmd[1]),
            duree: parseInt(cmd[2])
          };
          if (isNaN(scope.peur.seuil)) {
            error("Le premier argument de --peur doit \xEAtre un nombre (le seuil)", cmd);
          }
          if (isNaN(scope.peur.duree) || scope.peur.duree <= 0) {
            error("Le deuxi\xE8me argument de --peur doit \xEAtre un nombre positif (la dur\xE9e)", cmd);
          }
          return;
        case 'feu':
        case 'froid':
        case 'acide':
        case 'electrique':
        case 'sonique':
        case 'poison':
        case 'maladie':
        case 'argent':
        case 'drain':
        case 'energie':
          lastType = cmd[0];
          var l = 0;
          if (scope.additionalDmg) l = scope.additionalDmg.length;
          if (l > 0) {
            scope.additionalDmg[l - 1].type = cmd[0];
          } else {
            scope.type = cmd[0];
          }
          return;
        case 'nature':
        case 'naturel':
          scope.nature = true;
          return;
        case 'vampirise':
          var vampirise = 100;
          if (cmd.length > 1) {
            vampirise = parseInt(cmd[1]);
            if (isNaN(vampirise)) {
              error("Il faut un pourcentage entier comme argument \xE0 --vampirise", cmd);
              vampirise = 100;
            }
          }
          scope.vampirise = vampirise;
          return;
        case 'sournoise':
          if (scope.sournoise === undefined) scope.sournoise = 0;
          if (cmd.length < 2) {
            scope.sournoise += predicateAsInt(attaquant, 'attaqueSournoise', 1);
            return;
          }
          scope.sournoise += parseInt(cmd[1]);
          if (isNaN(scope.sournoise) || scope.sournoise < 0) {
            error("L'option --sournoise de !cof-attack attend un argument entier positif", cmd);
            return;
          }
          break;
        case 'disparition':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --disparition de !cof-attack", cmd);
            return;
          }
          let disparition = parseInt(cmd[1]);
          if (isNaN(disparition) || disparition < 0) {
            error("L'option --disparition de !cof-attack attend un argument entier positif", cmd);
            return;
          }
          if (options.disparition === undefined) options.disparition = 0;
          options.disparition += disparition;
          return;
        case 'fx':
          getFx(cmd, 'fx', scope, '!cof-attack');
          return;
        case 'targetFx':
          getFx(cmd, 'targetFx', scope, '!cof-attack');
          return;
        case 'psave':
          let psaveopt = scope;
          let psaveParams = parseSave(cmd);
          if (psaveParams) {
            if (psaveParams.local) {
              let psavel = 0;
              if (scope.additionalDmg) psavel = scope.additionalDmg.length;
              if (psavel > 0) {
                psaveopt = scope.additionalDmg[psavel - 1];
              }
            }
            psaveopt.partialSave = psaveParams;
            psaveopt.attaquant = {...attaquant
            };
          }
          return;
        case 'saveDM':
          let saveDMopt = scope;
          let saveDMParams = parseSave(cmd);
          if (saveDMParams) {
            if (saveDMParams.local) {
              let psavel = 0;
              if (scope.additionalDmg) psavel = scope.additionalDmg.length;
              if (psavel > 0) {
                saveDMopt = scope.additionalDmg[psavel - 1];
              }
            }
            saveDMopt.totalSave = saveDMParams;
            saveDMopt.attaquant = {...attaquant
            };
          }
          return;
        case 'save':
          if (lastEtat) {
            if (lastEtat.save) {
              error("Red\xE9finition de la condition de save pour un effet", optArgs);
            }
            let saveParams = parseSave(cmd);
            if (saveParams) {
              lastEtat.save = saveParams;
              lastEtat.save.entrave =
                lastEtat.etat == 'paralyse' || lastEtat.etat == 'immobilise' || lastEtat.etat == 'ralenti' || (lastEtat.message && lastEtat.message.entrave);
              return;
            }
            return;
          }
          error("Pas d'effet auquel appliquer le save", optArgs);
          return;
        case 'saveParTour':
        case 'saveParJour':
          if (lastEtat) {
            if (lastEtat[cmd[0]]) {
              error("Red\xE9finition de la condition de save pour un effet", optArgs);
            }
            var saveParTourParams = parseSave(cmd);
            if (saveParTourParams) {
              lastEtat[cmd[0]] = saveParTourParams;
              return;
            }
            return;
          }
          error("Pas d'effet auquel appliquer le save", optArgs);
          return;
        case 'retourneEnMain':
          scope.retourneEnMain = {};
          if (cmd.length > 2) {
            let conditionRetour = parseSave(cmd);
            if (conditionRetour) scope.retourneEnMain = conditionRetour;
          }
          return;
        case "mana":
          if (cmd.length < 2) {
            error("Usage : --mana co\xFBt", cmd);
            return;
          }
          var mana = parseInt(cmd[1]);
          if (isNaN(mana) || mana < 0) {
            error("Le co\xFBt en mana doit \xEAtre un nombre positif");
            return;
          }
          if (scope.mana === undefined) scope.mana = 0;
          scope.mana += mana;
          break;
        case 'tempeteDeMana':
          parseTempeteDeMana(cmd, options);
          return;
        case 'rang':
          if (cmd.length < 2) {
            error("Usage : --rang r", cmd);
            return;
          }
          var rang = parseInt(cmd[1]);
          if (isNaN(rang) || rang < 1) {
            error("Le rang doit \xEAtre un nombre positif");
            return;
          }
          scope.rang = rang;
          break;
        case 'bonusAttaque':
        case 'bonusContreBouclier':
          if (cmd.length < 2) {
            error("Usage : --" + cmd[0] + " b", cmd);
            return;
          }
          var bAtt = parseInt(cmd[1]);
          if (isNaN(bAtt)) {
            error("Le bonus (" + cmd[0] + ") doit \xEAtre un nombre");
            return;
          }
          if (scope[cmd[0]] === undefined) scope[cmd[0]] = 0;
          scope[cmd[0]] += bAtt;
          return;
        case 'bonusCritique':
        case 'attaqueDeGroupe':
          if (cmd.length < 2) {
            error("Usage : --" + cmd[0] + " b", cmd);
            return;
          }
          var b2Att = parseInt(cmd[1]);
          if (isNaN(b2Att)) {
            error("Le bonus (" + cmd[0] + ") doit \xEAtre un nombre");
            return;
          }
          if (options[cmd[0]] === undefined) options[cmd[0]] = 0;
          options[cmd[0]] += b2Att;
          return;
        case 'puissant':
          if (cmd.length < 2) {
            scope.puissant = true;
            return;
          }
          switch (cmd[1]) {
            case 'oui':
            case 'Oui':
              scope.puissant = true;
              return;
            case 'non':
            case 'Non':
              scope.puissant = false;
              return;
            case 'duree':
              scope.puissantDuree = true;
              return;
            case 'portee':
              scope.puissantPortee = true;
              return;
            default:
              scope.puissant = attributeAsBool(attaquant, cmd[1] + "Puissant");
          }
          return;
        case 'rate':
        case 'touche':
        case 'critique':
        case 'echecCritique':
        case 'pasDEchecCritique':
          if (options.triche === undefined) {
            options.triche = cmd[0];
          } else {
            error("Option incompatible", optArgs);
          }
          return;
        case 'munition':
          if (cmd.length < 2) {
            error("Pour les munitions, il faut pr\xE9ciser le nom", cmd);
            return;
          }
          var tauxPertes = 100; //Par d\xE9faut, les munitions sont perdues
          if (cmd.length > 2)
            tauxPertes = parseInt(cmd[2]);
          if (isNaN(tauxPertes) || tauxPertes < 0 || tauxPertes > 100) {
            error("Le taux de pertes des munitions doit \xEAtre un nombre entre 0 et 100");
            tauxPertes = 100;
          }
          options.munition = {
            nom: cmd[1],
            taux: tauxPertes
          };
          return;
        case "ligne":
          if (options.aoe) {
            error("Deux options pour d\xE9finir une aoe", args);
            return;
          }
          options.aoe = {
            type: 'ligne'
          };
          return;
        case 'disque':
          if (options.aoe) {
            error("Deux options pour d\xE9finir une aoe", args);
            return;
          }
          if (cmd.length < 2) {
            error("Il manque le rayon du disque", cmd);
            return;
          }
          options.aoe = {
            type: 'disque',
            rayon: parseInt(cmd[1])
          };
          if (isNaN(options.aoe.rayon) || options.aoe.disque < 0) {
            error("le rayon du disque n'est pas un nombre positif", cmd);
            delete options.aoe;
          }
          return;
        case 'cone':
          if (options.aoe) {
            error("Deux options pour d\xE9finir une aoe", args);
            return;
          }
          var angle = 90;
          if (cmd.length > 1) {
            angle = parseInt(cmd[1]);
            if (isNaN(angle) || angle < 0 || angle > 360) {
              error("Param\xE8tre d'angle du cone incorrect", cmd);
              angle = 90;
            }
          }
          options.aoe = {
            type: 'cone',
            angle: angle
          };
          return;
        case 'target':
          if (cmd.length < 2) {
            error("Il manque l'id de la cible", cmd);
            return;
          }
          var targetS = persoOfId(cmd[1]);
          if (targetS === undefined) {
            error("Cible suppl\xE9mentaire invalide", cmd);
            return;
          }
          if (targetToken.id == targetS.token.id) return;
          targetS.tokName = targetS.token.get('name');
          options.ciblesSupplementaires = options.ciblesSupplementaires || [];
          options.ciblesSupplementaires.push(targetS);
          return;
        case 'ciblesDansDisque':
          if (cmd.length < 2) {
            error("Il manque le rayon du disque dans lequel les cibles doivent tnir", cmd);
            return;
          }
          options.ciblesDansDisque = parseInt(cmd[1]);
          if (isNaN(options.ciblesDansDisque) || options.ciblesDansDisque < 1) {
            error("le rayon du disque n'est pas un nombre positif", cmd);
            delete options.ciblesDansDisque;
          }
          return;
        case 'limiteParJour':
          if (cmd.length < 2) {
            error("Il manque la limite journali\xE8re", cmd);
            return;
          }
          let limiteParJour = parseInt(cmd[1]);
          if (isNaN(limiteParJour) || limiteParJour < 1) {
            error("La limite journali\xE8re doit \xEAtre un nombre positif", cmd);
            return;
          }
          scope.limiteParJour = limiteParJour;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            scope.limiteParJourRessource = cmd.join('_');
          }
          return;
        case 'limiteParCombat':
          if (cmd.length < 2) {
            scope.limiteParCombat = 1;
            return;
          }
          let limiteParCombat = parseInt(cmd[1]);
          if (isNaN(limiteParCombat) || limiteParCombat < 1) {
            error("La limite par combat doit \xEAtre un nombre positif", cmd);
            return;
          }
          scope.limiteParCombat = limiteParCombat;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            scope.limiteParCombatRessource = cmd.join('_');
          }
          return;
        case 'decrAttribute':
          if (cmd.length < 2) {
            error("Erreur interne d'une commande g\xE9n\xE9r\xE9e par bouton", cmd);
            return;
          }
          let attr = getObj('attribute', cmd[1]);
          if (attr === undefined) {
            attr = tokenAttribute(attaquant, cmd[1]);
            if (attr.length === 0) {
              log("Attribut \xE0 changer perdu");
              log(cmd);
              return;
            }
            attr = attr[0];
          }
          scope.decrAttribute = attr.id; //Seulement l'id pour pouvoir cloner
          return;
        case 'decrLimitePredicatParTour':
          if (cmd.length < 2) {
            error("Erreur interne d'une commande g\xE9n\xE9r\xE9e par bouton", cmd);
            return;
          }
          scope.decrLimitePredicatParTour = cmd[1];
          return;
        case 'forceMinimum':
          if (cmd.length < 2) {
            error("Il faut indiquer le minimum de force", cmd);
            return;
          }
          let forceMin = parseInt(cmd[1]);
          if (isNaN(forceMin)) {
            error("La force minimum doit \xEAtre un nombre", cmd);
            return;
          }
          scope.forceMinimum = forceMin;
          return;
        case 'incrDmgCoef':
          scope.dmgCoef = (scope.dmgCoef || 1);
          if (cmd.length > 1) {
            var incrDmgCoef = parseInt(cmd[1]);
            if (isNaN(incrDmgCoef)) {
              error("L'option --incrDmgCoef attend un entier", cmd);
              return;
            }
            scope.dmgCoef += incrDmgCoef;
            return;
          }
          scope.dmgCoef++; //Par d\xE9faut, incr\xE9mente de 1
          return;
        case 'diviseDmg':
          scope.diviseDmg = (scope.diviseDmg || 1);
          if (cmd.length > 1) {
            let divise = parseInt(cmd[1]);
            if (isNaN(divise)) {
              error("L'option --diviseDmg attend un entier", cmd);
              return;
            }
            scope.diviseDmg *= divise;
            return;
          }
          scope.diviseDmg *= 2; //Par d\xE9faut, divise par 2
          return;
        case 'divisePortee':
          scope.divisePortee = (scope.divisePortee || 1);
          if (cmd.length > 1) {
            let divise = parseInt(cmd[1]);
            if (isNaN(divise)) {
              error("L'option --divisePortee attend un entier", cmd);
              return;
            }
            scope.divisePortee *= divise;
            return;
          }
          scope.divisePortee *= 2; //Par d\xE9faut, divise par 2
          return;
        case 'incrCritCoef':
          scope.critCoef = (scope.critCoef || 1);
          if (cmd.length > 1) {
            var incrCritCoef = parseInt(cmd[1]);
            if (isNaN(incrCritCoef)) {
              error("L'option --incrCritCoef attend un entier", cmd);
              return;
            }
            scope.critCoef += incrCritCoef;
            return;
          }
          scope.critCoef++; //Par d\xE9faut, incr\xE9mente de 1
          return;
        case 'if':
          var ifCond = parseCondition(cmd.slice(1));
          if (ifCond === undefined) return;
          var ifThen = {
            parentScope: scope
          };
          scope.ite = scope.ite || [];
          scope.ite.push({
            condition: ifCond,
            then: ifThen
          });
          scope = ifThen;
          return;
        case 'ifSaveFails':
          let save = parseSave(cmd);
          if (save === undefined) return;
          let ifSaveThen = {
            parentScope: scope
          };
          scope.ite = scope.ite || [];
          let ifSaveCond = {
            type: 'save',
            saveCond: save,
            typeDmg: lastType
          };
          scope.ite.push({
            condition: ifSaveCond,
            then: ifSaveThen
          });
          scope = ifSaveThen;
          return;
        case "endif":
          var psEndif = scope.parentScope;
          if (psEndif === undefined) {
            error("--endIf sans --if correspondant", cmd);
            return;
          }
          delete scope.parentScope; //To remove circular dependencies in options
          scope = psEndif;
          return;
        case "else":
          var psElse = scope.parentScope;
          if (psElse === undefined) {
            error("--else sans --if correspondant", cmd);
            return;
          }
          var iteL = psElse.ite[psElse.ite.length - 1];
          if (iteL.else) {
            error("Il y a d\xE9j\xE0 un --else pour ce --if", cmd);
            return;
          }
          delete scope.parentScope;
          var ifElse = {
            parentScope: psElse
          };
          iteL.else = ifElse;
          scope = ifElse;
          return;
        case 'message':
          if (cmd.length < 2) {
            error("Il manque le message apr\xE8s --message", cmd);
            return;
          }
          scope.messages = scope.messages || [];
          scope.messages.push(cmd.slice(1).join(' '));
          return;
        case 'allonge':
          if (cmd.length < 2) {
            error("Il manque le message apr\xE8s --allonge", cmd);
            return;
          }
          if (options.allonge !== undefined) {
            log("Red\xE9finition de l'allong");
          }
          options.allonge = parseFloat(cmd[1]);
          if (isNaN(options.allonge)) {
            error("L'argument de --allonge n'est pas un nombre", cmd);
          }
          return;
        case 'enveloppe':
          scope.enveloppe = {
            difficulte: 15,
            type: 'label',
            expression: attackLabel
          };
          if (cmd.length > 1) {
            scope.enveloppe.difficulte = parseInt(cmd[1]);
            if (isNaN(scope.enveloppe.difficulte))
              scope.enveloppe.difficulte = 15;
          }
          if (cmd.length > 3) {
            scope.enveloppe.type = cmd[2];
            scope.enveloppe.expression = cmd[3];
          }
          if (scope.enveloppe.expression === undefined) {
            error("Il n'est pas encore possible d'utiliser l'option --enveloppe sans expression si le label de l'attaque n'est pas d\xE9fini", cmd);
            scope.enveloppe = undefined;
          }
          return;
        case 'etreinte':
          scope.enveloppe = {
            difficulte: 15,
            type: 'etreinte',
            expression: '1d6',
          };
          if (cmd.length > 1) {
            scope.enveloppe.difficulte = parseInt(cmd[1]);
            if (isNaN(scope.enveloppe.difficulte))
              scope.enveloppe.difficulte = 15;
          }
          if (cmd.length > 2) {
            scope.enveloppe.expression = cmd[2];
          }
          return;
        case 'imgAttack':
        case 'imgAttackEchec':
        case 'imgAttackEchecCritique':
        case 'imgAttackEchecClignotement':
        case 'imgAttackSucces':
        case 'imgAttackSuccesChampion':
        case 'imgAttackSuccesCritique':
          if (cmd.length < 1) {
            error("Il manque une image apr\xE8s --" + cmd[0], cmd);
            return;
          }
          options[cmd[0]] = cmd[1];
          return;
        case 'soundAttack':
        case 'soundAttackEchec':
        case 'soundAttackEchecCritique':
        case 'soundAttackEchecClignotement':
        case 'soundAttackSucces':
        case 'soundAttackSuccesChampion':
        case 'soundAttackSuccesCritique':
          if (cmd.length < 1) {
            error("Il manque le son apr\xE8s --" + cmd[0], cmd);
            return;
          }
          options[cmd[0]] = cmd.slice(1).join(' ');
          return;
          //Anciennes variantes, gard\xE9es pour la compatibilit\xE9
        case 'img-attack-echec-critique':
        case 'img-attack-echec':
        case 'img-attack-echec-clignotement':
        case 'img-attack-normal-touch':
        case 'img-attack-succes':
        case 'img-attack-champion-succes':
        case 'img-attack-succes-champion':
        case 'img-attack-succes-critique':
          if (cmd.length < 1) {
            error("Il manque une image apr\xE8s --" + cmd[0], cmd);
            return;
          }
          var imgCmd = cmd[0].replace('-a', 'A').replace('-e', 'E').replace('-c', 'C').replace('-n', 'N').replace('-s', 'S').replace('-t', 'T');
          if (imgCmd == 'imgAttackNormalTouch') imgCmd = 'imgAttackSucces';
          if (imgCmd == 'imgAttackChampionSucces') imgCmd = 'imgAttackSuccesChampion';
          options[imgCmd] = cmd[1];
          return;
        case 'sound-attack-echec-critique':
        case 'sound-attack-echec':
        case 'sound-attack-echec-clignotement':
        case 'sound-attack-normal-touch':
        case 'sound-attack-succes':
        case 'sound-attack-champion-succes':
        case 'sound-attack-succes-champion':
        case 'sound-attack-succes-critique':
          if (cmd.length < 2) {
            error("Il manque le son apr\xE8s --" + cmd[0], cmd);
            return;
          }
          let soundCmd = cmd[0].replace('-a', 'A').replace('-e', 'E').replace('-c', 'C').replace('-n', 'N').replace('-s', 'S').replace('-t', 'T');
          if (soundCmd == 'soundAttackNormalTouch') soundCmd = 'soundAttackSucces';
          if (soundCmd == 'soundAttackChampionSucces') soundCmd = 'soundAttackSuccesChampion';
          options[soundCmd] = cmd.slice(1).join(' ');
          return;
        case 'affaiblirCarac':
          if (cmd.length < 3) {
            error("Usage: --affaiblirCarac carac n", cmd);
            return;
          }
          let carac = cmd[1];
          switch (carac) {
            case 'force':
            case 'dexterite':
            case 'constitution':
            case 'sagesse':
            case 'intelligence':
            case 'charisme':
              break;
            case 'FOR':
              carac = 'force';
              break;
            case 'dext\xE9rit\xE9':
            case 'DEX':
              carac = 'dexterite';
              break;
            case 'CON':
              carac = 'constitution';
              break;
            case 'SAG':
              carac = 'sagesse';
              break;
            case 'INT':
              carac = 'intelligence';
              break;
            case 'CHA':
              carac = 'charisme';
              break;
            default:
              error("Le premier argument de affaiblirCarac n'est pas une caract\xE9ristique", cmd);
              return;
          }
          let valAff = parseInt(cmd[2]);
          if (isNaN(valAff)) {
            error("Le deuxi\xE8me argument de --affaiblirCarac doit \xEAtre un nombre", cmd);
            return;
          }
          if (valAff === 0) return;
          scope.affaiblissementsCarac = scope.affaiblissementsCarac || [];
          scope.affaiblissementsCarac.push({
            carac,
            val: valAff
          });
          return;
        case 'difficulteCarac':
          if (cmd.length < 2) {
            error("Il manque la caract\xE9ristique \xE0 laquelle mesurer le jet d'attaque", cmd);
            return;
          }
          options.difficulteCarac = parseCarac(cmd[1]);
          if (options.difficulteCarac === undefined) {
            error("L'argument de --difficulteCarac n'est pas une caract\xE9ristique", cmd);
          }
          return;
        default:
          let armeMagique = cmd[0].match(/^\+([0-9]+)$/);
          if (armeMagique && armeMagique.length > 0) {
            options.armeMagiquePlus = parseInt(armeMagique[1]);
            if (options.magique === undefined) {
              options.magique = options.armeMagiquePlus;
            } else if (options.magique !== true) {
              options.magique += options.armeMagiquePlus;
            }
          } else {
            error("Argument de !cof-attack '" + arg + "' non reconnu", cmd);
          }
      }
    });
    closeIte(scope); //pour fermer les endif mal form\xE9s et \xE9viter les boucles
    options.additionalDmg = options.additionalDmg || [];
    if (options.tempeteDeMana) {
      if (options.tempeteDeMana.cout === 0) {
        //On demande de pr\xE9ciser les options
        var optMana = {
          mana: options.mana,
          rang: options.rang,
          portee: true //Pour avoir l'option
        };
        if (!options.pasDeDmg) optMana.dm = true;
        if (options.effets) {
          options.effets.forEach(function(ef) {
            if (ef.effet) {
              if (estEffetTemp(ef.effet)) {
                optMana.dm = optMana.dm || (ef.message && ef.message.dm);
                optMana.soins = optMana.soins || (ef.message && ef.message.soins);
                optMana.duree = true;
              }
            } else if (estEffetCombat(ef.effet)) {
              optMana.dm = optMana.dm || messageEffetCombat[ef.effet].dm;
              optMana.soins = optMana.soins || messageEffetCombat[ef.effet].soins;
            }
          });
        }
        if (options.peur && options.peur.duree) optMana.duree = true;
        setTempeteDeMana(playerId, attaquant, msg.content, optMana);
        return;
      } else {
        if (options.rang && options.tempeteDeMana.cout > options.rang) {
          sendPlayerAndGM(msg, playerId, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
        }
      }
    }
    if (options.tempeteDeManaDuree || options.puissantDuree) {
      if (options.pasDeDmg) {
        if (options.peur && options.peur.duree)
          options.peur.duree = options.peur.duree * 2;
        if (options.effets) {
          options.effets.forEach(function(ef) {
            if (ef.effet && ef.duree && !ef.message.dm && !ef.message.soins) {
              ef.duree = ef.duree * 2;
            }
          });
        }
      } else {
        if (options.tempeteDeManaDuree) {
          sendPlayerAndGM(msg, playerId, "Attention, l'option temp\xEAte de mana pour la dur\xE9e n'est pas prise en compte. Utiliser l'option --pasDeDmg si le sort ne fait pas de DM");
          options.tempeteDeManaDuree = false;
          if (options.tempeteDeMana && options.tempeteDeMana.cout)
            options.tempeteDeMana.cout--;
          if (options.mana) {
            if (reglesOptionelles.mana.val.mana_totale.val) options.mana -= 3;
            else options.mana--;
          }
        }
      }
    }
    let playerName = msg.who;
    if (playerIsGM(playerId)) playerName = 'GM';
    attack(playerName, playerId, attaquant, targetToken, weaponStats, options);
  }

  function depenseManaPossible(personnage, cout, msg) {
    if (isNaN(cout) || cout === 0) return {
      cout_nul: true
    };
    var token = personnage.token;
    var charId = personnage.charId;
    var manaAttr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: 'PM'
    }, {
      caseInsensitive: true
    });
    var hasMana = false;
    if (manaAttr.length > 0) {
      var manaMax = parseInt(manaAttr[0].get('max'));
      hasMana = !isNaN(manaMax) && manaMax > 0;
    }
    if (hasMana) {
      var bar2 = parseInt(token.get('bar2_value'));
      if (isNaN(bar2)) {
        if (token.get('bar1_link') === '') bar2 = 0;
        else { //devrait \xEAtre li\xE9 \xE0 la mana courante
          sendPerso(personnage, "*** Attention, la barre de mana du token n'est pas li\xE9e \xE0 la mana de la fiche ***");
          bar2 = parseInt(manaAttr[0].get('current'));
        }
      }
      msg = msg || '';
      if ((reglesOptionelles.mana.val.contrecoup.val && bar2 <= 0) ||
        (!reglesOptionelles.mana.val.contrecoup.val && !reglesOptionelles.mana.val.brulure_de_magie.val && bar2 < cout)) {
        if (msg) sendPerso(personnage, "n'a pas assez de points de mana pour " + msg);
        return false;
      }
      if (bar2 < cout && (reglesOptionelles.mana.val.contrecoup.val ||
          reglesOptionelles.mana.val.brulure_de_magie.val)) {
        let degats = cout - bar2;
        if (reglesOptionelles.mana.val.brulure_de_magie.val) {
          let famille = ficheAttribute(personnage, 'famille', 'aventurier').trim();
          if (famille == "combattant") degats *= 2;
          degats = Math.ceil(degats / predicateAsInt(personnage, 'coefPVMana', 1));
        }
        let bar1 = parseInt(token.get('bar1_value'));
        if (bar1 < degats) {
          if (msg) sendPerso(personnage, "n'a pas assez de points de mana et de PV pour " + msg);
          return false;
        }
        return {
          pm: 0,
          depense_pm: bar2,
          pv: bar1 - degats,
          depense_pv: degats
        };
      }
      return {
        pm: bar2 - cout,
        depense_pm: cout
      };
    }
    sendPerso(personnage, "n'a pas de points de mana, action impossible");
    return false;
  }

  // Fait d\xE9penser de la mana, dep doit contenir une d\xE9pense possible
  function depenseMana(perso, dep, msg, evt) {
    if (!dep || dep.cout_null) return;
    updateCurrentBar(perso, 2, dep.pm, evt);
    msg = msg || '';
    if (dep.depense_pv) {
      var source = reglesOptionelles.mana.val.brulure_de_magie.val ? "de la Br\xFBlure de Magie" : "du Contrecoup";
      updateCurrentBar(perso, 1, dep.pv, evt);
      var pre = 'p';
      if (stateCOF.options.affichage.val.depense_mana.val && dep.depense_pm > 0)
        pre = "d\xE9pense " + dep.depense_pm + " PM et p";
      sendPerso(perso, pre + "erd " + dep.depense_pv + " PV \xE0 cause " + source + " pour " + msg);
    } else {
      if (stateCOF.options.affichage.val.depense_mana.val)
        sendPerso(perso, "d\xE9pense " + dep.depense_pm + " PM pour " + msg);
    }
    var niveau = ficheAttributeAsInt(perso, 'niveau', 1);
    if (reglesOptionelles.mana.val.mana_totale.val) {
      if (dep.depense_pm > niveau * 3) {
        sendPerso(perso, "Attention, la d\xE9pense totale de mana est sup\xE9rieure au niveau * 3");
      }
    } else {
      if (dep.depense_pm > niveau) {
        sendPerso(perso, "Attention, la d\xE9pense totale de mana est sup\xE9rieure au niveau");
      }
    }
    return;
  }

  //renvoie un objet avec le champ carac (+carac2 possible), et undefined si erreur
  function parseCarac(arg) {
    if (arg.length == 3) {
      if (!isCarac(arg)) return;
      return {
        carac: arg
      };
    } else if (arg.length == 6) { //Choix parmis 2 caracs
      let carac = arg.substr(0, 3);
      let carac2 = arg.substr(3, 3);
      if (!isCarac(carac) || !isCarac(carac2)) return;
      return {
        carac,
        carac2
      };
    }
  }


  //Si l'attribut est un mod. de caract\xE9ristique, va chercher le
  //bon attribut, selon que perso est un PNJ ou nom
  function valAttribute(perso, originalAttr, caracAttr) {
    if (caracAttr) {
      if (persoEstPNJ(perso)) {
        return 10 + ficheAttributeAsInt(perso, PNJCaracOfMod(originalAttr), 0) * 2;
      }
      return ficheAttributeAsInt(perso, caracAttr, 0);
    }
    return charAttributeAsInt(perso, originalAttr, 0);
  }

  function testCondition(cond, attaquant, cibles, deAttaque, options) {
    if (cond == 'toujoursVrai') return true;
    switch (cond.type) {
      case 'moins':
        // Au cas o\xF9 on utilise les MOD au lieu de l'attribut de base:
        var caracAttr = caracOfMod(cond.attribute);
        var attackerAttr = valAttribute(attaquant, cond.attribute, caracAttr);
        var resMoins = true;
        cibles.forEach(function(target) {
          if (resMoins) {
            var targetAttr = valAttribute(target, cond.attribute, caracAttr);
            if (targetAttr >= attackerAttr) resMoins = false;
          }
        });
        return resMoins;
      case 'etat':
        return (getState(attaquant, cond.etat));
      case 'etatCible':
        var resEtatCible = true;
        cibles.forEach(function(target) {
          if (resEtatCible && !getState(target, cond.etat))
            resEtatCible = false;
        });
        return resEtatCible;
      case 'attribut':
        if (attributeAsBool(attaquant, cond.attribute)) return true;
        if (cond.attribute == 'armeDArgent') {
          return attributeAsBool(attaquant, 'formeDAnge') && predicateAsInt(attaquant, 'voieDeLArchange', 1) > 2;
        }
        return false;
      case 'attributCible':
        let resAttrCible = true;
        if (cond.valeur === undefined) {
          cibles.forEach(function(target) {
            if (resAttrCible && !attributeAsBool(target, cond.attribute))
              resAttrCible = false;
          });
        } else {
          cibles.forEach(function(target) {
            if (resAttrCible) {
              var attr;
              if (cond.fiche) {
                attr = ficheAttribute(target, cond.attribute, cond.fiche.def);
                if (attr === undefined) {
                  resAttrCible = false;
                  return;
                }
                resAttrCible = (attr + '').toLowerCase() == cond.valeur;
                return;
              }
              if (cond.local) attr = tokenAttribute(target, cond.attribute);
              else attr = charAttribute(target.charId, cond.attribute);
              if (attr.length === 0) {
                resAttrCible = false;
                return;
              }
              resAttrCible = (attr[0].get('current') + '').toLowerCase() == cond.valeur;
            }
          });
        }
        return resAttrCible;
      case 'predicatCible':
        let resp = cibles.every(function(target) {
          if (cond.valeur === undefined) return predicateAsBool(target, cond.predicat);
          return predicateAsBool(target, cond.predicat) == cond.valeur;
        });
        return resp;
      case 'typeCible':
        let rest = cibles.every(function(target) {
          switch (cond.race) {
            case 'animal':
              return estAnimal(target);
            case 'demon':
            case 'd\xE9mon':
              return estDemon(target);
            case 'drow':
            case 'elfe-noir':
              return estElfeNoir(target);
            case 'fee':
            case 'f\xE9e':
              return estFee(target);
            case 'g\xE9ant':
            case 'geant':
              return estGeant(target);
            case 'gobelin':
              return estGobelin(target);
            case 'insecte':
              return estInsecte(target);
            case 'mauvais':
              return estMauvais(target);
            case 'mort-vivant':
              return estMortVivant(target);
            default:
              return raceIs(target, cond.race) || predicateAsBool(target, cond.race);
          }
        });
        return rest;
      case 'deAttaque':
        if (options && options.auto) return false;
        if (deAttaque === undefined) {
          error("Condition de d\xE9 d'attaque non support\xE9e ici", cond);
          return true;
        }
        return deAttaque >= cond.seuil;
      case 'echecCritique':
        if (deAttaque === undefined) {
          error("Condition de d\xE9 d'attaque non support\xE9e ici", cond);
          return true;
        }
        return deAttaque == 1;
      case 'touche':
        return cibles.every(function(target) {
          return target.touche;
        });
      case 'critique':
        return cibles.every(function(target) {
          return target.critique;
        });
      default:
        error("Condition non reconnue", cond);
    }
    return false;
  }

  function estNecromancie(options) {
    return options.necromancie || options.malediction ||
      (options.vampirise && options.sortilege) || options.peur ||
      options.type == 'drain';
  }

  //On copie les champs de scope dans options ou dans target
  function copyBranchOptions(attaquant, branch, options, target, evt, explications, condInTarget) {
    let opt = options;
    if (condInTarget) opt = target;
    for (let field in branch) {
      switch (field) {
        case 'ite':
          break;
        case 'additionalDmg':
        case 'additionalCritDmg':
        case 'effets':
        case 'etats':
        case 'affaiblissementsCarac': //Listes
          opt[field] = opt[field] || [];
          opt[field] = opt[field].concat(branch[field]);
          break;
        case 'sournoise':
        case 'mana':
        case 'bonusAttaque':
        case 'bonusContreBouclier': //num\xE9riques additives
          opt[field] = opt[field] || 0;
          opt[field] += branch[field];
          break;
        case 'dmgCoef':
        case 'critCoef':
          if (opt[field] === undefined) {
            if (condInTarget) opt[field] = 0;
            else opt[field] = 1;
          }
          opt[field] += branch[field] - 1;
          break;
        case 'diviseDmg':
          if (opt[field] === undefined) {
            opt[field] = 1;
          }
          opt[field] *= branch[field];
          break;
        case 'messages':
          if (condInTarget)
            target.messages = target.messages.concat(branch.messages);
          else { /*jshint loopfunc: true */
            branch.messages.forEach(function(m) {
              explications.push(m);
            });
          }
          break;
        case 'decrAttribute':
          let attr = getObj('attribute', branch.decrAttribute);
          if (attr === undefined) {
            error("Attribut introuvable", branch.decrAttribute);
            break;
          }
          let oldval = parseInt(attr.get('current'));
          if (isNaN(oldval) || oldval < 1) {
            sendChar(attr.get('characterid'), "ne peut plus faire cela", true);
            break;
          }
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attr,
            current: oldval,
            max: attr.get('max')
          });
          attr.set('current', oldval - 1);
          break;
        case 'decrLimitePredicatParTour':
          //Ne fait que diminuer l'attribut, n'emp\xEAche pas l'attaque
          let pred = branch.decrLimitePredicatParTour;
          let test = testLimiteUtilisationsCapa(attaquant, pred, 'tour',
            "ne peut plus utiliser " + pred + " ce tour",
            "Attaque impossible, pas de pr\xE9dicat " + pred);
          if (test === undefined) break;
          utiliseCapacite(attaquant, test, evt);
          break;
        default:
          opt[field] = branch[field];
      }
    }
  }

  function callIfAllDone(etat, callback) {
    etat.aTraiter--;
    while (etat.aTraiter === 0 && etat.parent) {
      etat = etat.parent;
      etat.aTraiter--;
    }
    if (etat.aTraiter === 0) callback();
  }

  //Evaluation r\xE9cursive des if-then-else
  function evalITE(attaquant, target, deAttaque, options, phase, evt, explications, scope, callback, inTarget, etatParent) {
    etatParent = etatParent || {};
    if (scope.ite === undefined || scope.ite.length < 1) {
      etatParent.aTraiter = 1;
      callIfAllDone(etatParent, callback);
      return;
    }
    etatParent.aTraiter = scope.ite.length;
    scope.ite = scope.ite.filter(function(ite) {
      var condInTarget = inTarget;
      var resCondition;
      if (ite.condition == 'toujoursVrai') resCondition = true;
      switch (ite.condition.type) {
        case 'etat':
        case 'attribut':
          resCondition = testCondition(ite.condition, attaquant, [], deAttaque);
          break;
        case 'deAttaque':
          if (options.auto) {
            resCondition = false;
            break;
          }
          if (deAttaque === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          resCondition = testCondition(ite.condition, attaquant, [], deAttaque);
          break;
        case 'moins':
        case 'etatCible':
        case 'attributCible':
        case 'predicatCible':
        case 'typeCible':
          if (target === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          condInTarget = true;
          resCondition = testCondition(ite.condition, attaquant, [target], deAttaque);
          break;
        case 'critique':
        case 'touche':
          if (phase === 1 && target === undefined) {
            resCondition = false;
            phase = 0;
            break;
          }
          if (target === undefined || target.attaqueCalculee === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          condInTarget = true;
          phase = 0;
          resCondition = testCondition(ite.condition, attaquant, [target], deAttaque);
          break;
        case 'echecCritique':
          if (target === undefined || deAttaque === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          condInTarget = true;
          resCondition = testCondition(ite.condition, attaquant, [target], deAttaque);
          break;
        case 'save':
          if (target === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          var msgPour = " pour r\xE9sister \xE0 un effet";
          var msgRate = ", " + target.tokName + " rate son jet de sauvegarde";
          var saveOpts = {
            msgPour: msgPour,
            msgRate: msgRate,
            attaquant: attaquant,
            rolls: options.rolls,
            sortilege: options.sortilege,
            chanceRollId: options.chanceRollId,
            type: ite.condition.typeDmg,
            necromancie: estNecromancie(options)
          };
          var saveId = condInTarget ? 'ifSave_' + etatParent.aTraiter + '_' + target.token.id :
            'ifSave_' + etatParent.aTraiter + '_' + attaquant.token.id;
          if (phase > 0) { //le save a d\xE9j\xE0 \xE9t\xE9 r\xE9solu
            condInTarget = true;
            resCondition = target.saveResults && target.saveResults[saveId];
            break;
          }
          let expliquer = function(msg) {
            target.messages.push(msg);
          };
          save(ite.condition.saveCond, target, saveId, expliquer, saveOpts, evt,
            function(reussite, rolltext) {
              var branch;
              target.saveResults = target.saveResults || {};
              if (reussite) {
                branch = ite.else;
                target.saveResults[saveId] = true;
              } else {
                branch = ite.then; //on teste si le save est rat\xE9
                target.saveResults[saveId] = false;
              }
              if (branch === undefined) {
                callIfAllDone(etatParent, callback);
                return;
              }
              copyBranchOptions(attaquant, branch, options, target, evt, explications, true);
              let etat = {
                parent: etatParent
              };
              evalITE(attaquant, target, deAttaque, options, 0, evt, explications, branch, callback, condInTarget, etat);
            });
          return true; //on ne fait pas la suite, mais on garde l'ite
        default:
          error("Condition non reconnue", ite.condition);
          resCondition = true;
      }
      var branch;
      if (resCondition) branch = ite.then;
      else branch = ite.else;
      if (branch === undefined) {
        callIfAllDone(etatParent, callback);
        return condInTarget; //On garde l'ite si on d\xE9pend de la cible
      }
      //On copie les champs de scope dans options ou dans target
      if (phase === 0)
        copyBranchOptions(attaquant, branch, options, target, evt, explications, condInTarget);
      let etat = {
        parent: etatParent
      };
      evalITE(attaquant, target, deAttaque, options, phase, evt, explications, branch, callback, condInTarget, etat);
      return condInTarget;
    });
  }

  // Retourne tous les attributs dans attrs, de nom name ou commen\xE7ant par name_
  function allAttributesNamed(attrs, name) {
    let reg = new RegExp("^" + name + "($|_|\\()");
    return attrs.filter(function(obj) {
      let attrName = obj.get('name');
      return reg.test(attrName);
    });
  }

  function removeAllAttributes(name, evt, attrs) {
    if (attrs === undefined) {
      attrs = findObjs({
        _type: 'attribute'
      });
    }
    let attrsNamed = allAttributesNamed(attrs, name);
    if (attrsNamed.length === 0) return attrs;
    if (evt.deletedAttributes === undefined) evt.deletedAttributes = [];
    attrsNamed.forEach(function(attr) {
      evt.deletedAttributes.push(attr);
      attr.remove();
    });
    attrs = attrs.filter(function(attr) {
      let ind = attrsNamed.findIndex(function(nattr) {
        return nattr.id == attr.id;
      });
      return (ind == -1);
    });
    return attrs;
  }

  function onGenre(perso, male, female) {
    let sexe = ficheAttribute(perso, 'sexe', '');
    if (sexe.startsWith('F')) return female;
    return male;
  }

  function messageActivation(perso, message) {
    if (message.activationF) return onGenre(perso, message.activation, message.activationF);
    return message.activation;
  }

  function getValeurStringOfEffet(perso, effet, def, attrDef) {
    var attrsVal = tokenAttribute(perso, effet + 'Valeur');
    if (attrsVal.length === 0) {
      if (attrDef) {
        var attr = charAttribute(perso, attrDef);
        if (attr.length === 0) return def;
        return attr[0].get('current');
      }
      return def;
    }
    return attrsVal[0].get('current');
  }

  // renvoie la valeur du bonus si il y a un capitaine (ou commandant)
  //evt est optionnel
  function aUnCapitaine(cible, evt, pageId) {
    var charId = cible.charId;
    var attrs = findObjs({
      _type: 'attribute',
      _characterid: charId,
    });
    var attrCapitaine = attrs.find(function(a) {
      return (a.get('name') == 'capitaine');
    });
    if (attrCapitaine === undefined) return false;
    if (pageId === undefined) {
      pageId = cible.token.get('pageid');
    }
    var capitaine = persoOfIdName(attrCapitaine.get('current'), pageId);
    if (evt && capitaine === undefined) {
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attrCapitaine);
      attrCapitaine.remove();
    }
    var capitaineActif = attrs.find(function(a) {
      return (a.get('name') == 'capitaineActif');
    });
    if (capitaine && isActive(capitaine)) {
      if (capitaineActif || !evt) return attrCapitaine.get('max');
      setTokenAttr(cible, 'capitaineActif', true, evt, {
        charAttr: true
      });
      iterSelected(tokensEnCombat(), function(perso) {
        if (perso.charId == charId) updateInit(perso.token, evt);
      });
      return attrCapitaine.get('max');
    }
    if (capitaineActif && evt) {
      removeCharAttr(cible.charId, 'capitaineActif', evt);
      iterSelected(tokensEnCombat(), function(perso) {
        if (perso.charId == charId) updateInit(perso.token, evt);
      });
    }
    return false;
  }

  //ne rajoute pas evt \xE0 l'historique
  function persoInit(perso, evt) {
    let initDerivee = charAttribute(perso.charId, 'initiativeDeriveeDe');
    if (initDerivee.length > 0) {
      var charDerive = findObjs({
        _type: 'character',
        name: initDerivee[0].get('current')
      });
      if (charDerive.length > 0) {
        let persoD = {
          charId: charDerive[0].id,
          token: perso.token
        };
        return persoInit(persoD, evt);
      }
    }
    let persoMonte = tokenAttribute(perso, 'estMontePar');
    if (persoMonte.length > 0) {
      let cavalier = persoOfId(persoMonte[0].get('current'), persoMonte[0].get('max'), perso.token.get('pageid'));
      if (cavalier !== undefined) return persoInit(cavalier, evt);
    }
    let init;
    if (persoEstPNJ(perso)) {
      init = ficheAttributeAsInt(perso, 'pnj_init', 10);
    } else {
      init = ficheAttributeAsInt(perso, 'dexterite', 10);
      init += ficheAttributeAsInt(perso, 'INIT_DIV', 0);
      if (stateCOF.setting_arran || stateCOF.setting_mixte)
        init += ficheAttributeAsInt(perso, 'mod_initiative', 0);
    }
    if (attributeAsBool(perso, 'formeDArbre')) init = 7;
    //R\xE8gle optionelle : +1d6, \xE0 lancer en entrant en combat
    if (reglesOptionelles.initiative.val.initiative_variable.val) {
      let bonusVariable;
      let jetPartage;
      if (reglesOptionelles.initiative.val.initiative_variable_individuelle.val) { // Un jet par perso mook
        bonusVariable = attributeAsInt(perso, 'bonusInitVariable', 0);
      } else { //Un seul pour tous les mook du m\xEAme personnage
        bonusVariable = charAttributeAsInt(perso, 'bonusInitVariable', 0);
        jetPartage = true;
      }
      if (bonusVariable === 0) {
        let rollD6 = rollDePlus(6, {
          deExplosif: true
        });
        bonusVariable = rollD6.val;
        let msg = "entre en combat. ";
        let jetCache = ficheAttributeAsBool(perso, 'jets_caches', false);
        let msgSecret = perso.token.get('layer') == 'gmlayer';
        if (!jetCache) {
          msg += onGenre(perso, 'Il', 'Elle') + " fait " + rollD6.roll;
          msg += " \xE0 son jet d'initiative";
        }
        setTokenAttr(perso, 'bonusInitVariable', bonusVariable, evt, {
          msg: msg,
          secret: msgSecret,
          charAttr: jetPartage
        });
      }
      init += bonusVariable;
    }
    if (getState(perso, 'aveugle')) init -= 5;
    // Voie du compagnon animal rang 2 (surveillance)
    init += attributeAsInt(perso, 'bonusInitEmbuscade', 0);
    // Familier
    if (compagnonPresent(perso, 'familier')) init += 2;
    // Sixi\xE8me sens en sort
    if (attributeAsBool(perso, 'sixiemeSens')) init += 2;
    // Voie du chef d'arm\xE9e rangs 2 et 3 (Capitaine)
    var bonusCapitaine = aUnCapitaine(perso, evt);
    if (bonusCapitaine) init += parseInt(bonusCapitaine);
    if (predicateAsBool(perso, 'graceFeline')) {
      init += modCarac(perso, 'charisme');
    }
    if (predicateAsBool(perso, 'sensAffutes')) {
      init += modCarac(perso, 'sagesse');
    }
    if (attributeAsBool(perso, 'masqueDuPredateur')) {
      init += getValeurOfEffet(perso, 'masqueDuPredateur', modCarac(perso, 'sagesse'));
    }
    if (predicateAsBool(perso, 'controleDuMetabolisme')) {
      init += getValeurOfEffet(perso, 'controleDuMetabolisme', modCarac(perso, 'charisme'));
    }
    if (attributeAsBool(perso, 'cadavreAnime')) {
      init -= 2;
    }
    // Voie du pistolero rang 1 (plus vite que son ombre)
    let armeEnMain = tokenAttribute(perso, 'armeEnMain');
    if (armeEnMain.length > 0) {
      let armeL = armeEnMain[0].get('current');
      //L'arme doit \xEAtre charg\xE9e
      let chargeMax = predicateAsInt(perso, 'charge_' + armeL, 0);
      if (chargeMax == 0 || attributeAsInt(perso, 'charge_' + armeL, 0) > 0) {
        init += predicateAsInt(perso, 'initEnMain' + armeL, 0);
      }
    }
    //Intelligence du combat
    if (predicateAsBool(perso, 'intelligenceDuCombat')) {
      init += modCarac(perso, 'intelligence');
    }
    // R\xE9flexes felins de la Voie du pourfendeur
    init += predicateAsInt(perso, 'reflexesFelins', 0);
    //Prescience de l'ensorceleur
    if (attributeAsBool(perso, 'prescienceUtilisee')) init += 10;
    //For\xEAt vivante
    if (attributeAsBool(perso, 'foretVivanteEnnemie')) {
      init -= 5;
    }
    return init;
  }

  //ne rajoute pas evt \xE0 l'historique
  //options: recompute : si pas encore agi, on remet \xE0 sa place dans le turn order
  function initiative(selected, evt, recompute) { //set initiative for selected tokens
    // Toujours appel\xE9 quand on entre en combat
    // Initialise le compteur de tour, si besoin
    // Assumption: all tokens that have not acted yet are those before the turn
    // counter.
    // When initiative for token not present, assumes it has not acted
    // When present, stays in same group, but update position according to
    // current initiative.
    // Tokens appearing before the turn are sorted
    if (!Campaign().get('initiativepage')) evt.initiativepage = false;
    var debutCombat = false;
    if (!stateCOF.combat) { //actions de d\xE9but de combat
      evt.combat = false;
      evt.combat_pageid = stateCOF.combat_pageid;
      stateCOF.combat = true;
      Campaign().set({
        turnorder: JSON.stringify([{
          id: "-1",
          pr: 1,
          custom: "Tour",
          formula: "+1"
        }]),
        initiativepage: true
      });
      evt.tour = stateCOF.tour;
      stateCOF.tour = 1;
      evt.init = stateCOF.init;
      stateCOF.init = 1000;
      removeAllAttributes('transeDeGu\xE9rison', evt);
      debutCombat = true;
    }
    if (!Campaign().get('initiativepage')) {
      Campaign().set('initiativepage', true);
    }
    var to = getTurnOrder(evt);
    if (to.pasAgi.length === 0) { // Fin de tour, on met le tour \xE0 la fin et on retrie
      to.pasAgi = to.dejaAgi;
      to.dejaAgi = [];
    }
    iterSelected(selected, function(perso) {
      stateCOF.combat_pageid = perso.token.get('pageid');
      //Si besoin, on stoque les PVs de d\xE9but de combat
      if (!attributeAsBool(perso, 'PVsDebutCombat')) {
        setTokenAttr(perso, 'PVsDebutCombat', perso.token.get('bar1_value'), evt);
      }
      if (!isActive(perso)) return;
      if (predicateAsBool(perso, 'aucuneActionCombat')) return;
      var init = persoInit(perso, evt);
      // On place le token \xE0 sa place dans la liste du tour
      var dejaIndex =
        to.dejaAgi.findIndex(function(elt) {
          return (elt.id == perso.token.id);
        });
      if (dejaIndex == -1) { //Le personnage doit encore agir
        var push = true;
        to.pasAgi =
          to.pasAgi.filter(function(elt) {
            if (elt.id == perso.token.id) {
              if (recompute) return false; //On enl\xE8ve le perso des pasAgi
              push = false; //Sinon, comme on ne recalcule pas, on le laisse
              return true;
            }
            return true;
          });
        if (push) {
          if (init >= stateCOF.init) { //On ne peut pas remonter le temps.
            init = stateCOF.init - 1;
            updateNextInit(perso);
          }
          to.pasAgi.push({
            id: perso.token.id,
            pr: init,
            custom: ''
          });
        }
      } else {
        to.dejaAgi[dejaIndex].pr = init;
      }
    });
    if (debutCombat) { //On cherche si un des personnages de la carte a la capacit\xE9 Prescience
      var allToks =
        findObjs({
          _type: 'graphic',
          _pageid: stateCOF.combat_pageid,
          _subtype: 'token',
        });
      let prescience = allToks.find(function(tok) {
        let ci = tok.get('represents');
        if (ci === undefined) return false;
        let perso = {
          token: tok,
          charId: ci
        };
        return capaciteDisponible(perso, 'prescience', 'combat');
      });
      if (prescience) { //Il faut stoquer les positions de tous les token pour le retour en arri\xE8re.
        stateCOF.prescience = {
          evt: evt,
          dernieresPositions: []
        };
        allToks.forEach(function(tok) {
          var ci = tok.get('represents');
          if (ci == undefined) return;
          stateCOF.prescience.dernieresPositions.push({
            token: tok,
            left: tok.get('left'),
            top: tok.get('top')
          });
        });
      }
    }
    setTurnOrder(to, evt);
  }

  function initiativeInterface(msg) {
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("Dans !cof-init : rien \xE0 faire, pas de token selectionn\xE9", msg);
        return;
      }
      aura_token_on_turn = msg.content.indexOf('--aura') !== -1;
      let evt = {
        type: 'initiative'
      };
      initiative(selected, evt);
      addEvent(evt);
    });
  }

  function initPerso(personnage, evt, recompute) {
    initiative([{
      _id: personnage.token.id
    }], evt, recompute);
  }

  // triggers sheet workers
  // options peut avoir un champ msg et un champ maxVal
  // renvoie l'attribut
  function setFicheAttr(personnage, attribute, value, evt, options) {
    let charId = personnage.charId;
    if (options && options.msg !== undefined) {
      sendPerso(personnage, options.msg);
    }
    evt.attributes = evt.attributes || [];
    let attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: attribute
    }, {
      caseInsensitive: true
    });
    if (attr.length === 0) {
      var maxval = '';
      if (options && options.maxVal !== undefined) maxval = options.maxVal;
      attr = createObj('attribute', {
        characterid: charId,
        name: attribute,
        current: value,
        max: maxval
      });
      attr.setWithWorker({
        current: value
      });
      evt.attributes.push({
        attribute: attr,
      });
      return attr;
    }
    attr = attr[0];
    evt.attributes.push({
      attribute: attr,
      current: attr.get('current'),
      max: attr.get('max'),
      withWorker: true
    });
    var nv = {
      current: value
    };
    if (options && options.maxVal !== undefined) nv.max = options.maxVal;
    attr.setWithWorker(nv);
    return attr;
  }

  // bonus d'attaque d'un token, ind\xE9pendament des options
  // Mise en commun pour attack et attaque-magique
  function bonusDAttaque(personnage, explications, evt) {
    explications = explications || [];
    var tempAttkMod; // Utilise la barre 3 de l'attaquant
    tempAttkMod = parseInt(personnage.token.get('bar3_value'));
    if (tempAttkMod === undefined || isNaN(tempAttkMod) || tempAttkMod === "") {
      tempAttkMod = 0;
    }
    var attBonus = tempAttkMod;
    var fortifie = attributeAsInt(personnage, 'fortifie', 0);
    if (fortifie > 0) {
      attBonus += 3;
      fortifie--;
      explications.push("Effet du fortifiant => +3 en Attaque. Il sera encore actif pour " + fortifie + " tests");
      if (fortifie === 0) {
        removeTokenAttr(personnage, 'fortifie', evt);
      } else {
        setTokenAttr(personnage, 'fortifie', fortifie, evt);
      }
    }
    attBonus += charAttributeAsInt(personnage, 'actionConcertee', 0);
    if (attributeAsBool(personnage, 'chantDesHeros')) {
      var bonusChantDesHeros = getValeurOfEffet(personnage, 'chantDesHeros', 1);
      var chantDesHerosIntense = attributeAsInt(personnage, 'chantDesHerosTempeteDeManaIntense', 0);
      bonusChantDesHeros += chantDesHerosIntense;
      attBonus += bonusChantDesHeros;
      explications.push("Chant des h\xE9ros => +" + bonusChantDesHeros + " en Attaque");
      if (chantDesHerosIntense)
        removeTokenAttr(personnage, 'chantDesHerosTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'benediction')) {
      var bonusBenediction = getValeurOfEffet(personnage, 'benediction', 1);
      var benedictionIntense = attributeAsInt(personnage, 'benedictionTempeteDeManaIntense', 0);
      bonusBenediction += benedictionIntense;
      attBonus += bonusBenediction;
      explications.push("B\xE9n\xE9diction => +" + bonusBenediction + " en Attaque");
      if (benedictionIntense)
        removeTokenAttr(personnage, 'benedictionTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'lameDeLigneePerdue')) {
      attBonus -= 1;
      explications.push("Lame de lign\xE9e perdue => -1 en Attaque");
    }
    if (attributeAsBool(personnage, 'strangulation')) {
      var malusStrangulation =
        1 + attributeAsInt(personnage, 'dureeStrangulation', 0);
      attBonus -= malusStrangulation;
      explications.push("L'attaquant est \xE9trangl\xE9 => -" + malusStrangulation + " en Attaque");
    }
    if (getState(personnage, 'renverse')) {
      attBonus -= 5;
      explications.push("Attaquant \xE0 terre => -5 en Attaque");
    }
    var attrPosture = tokenAttribute(personnage, 'postureDeCombat');
    if (attrPosture.length > 0) {
      attrPosture = attrPosture[0];
      var posture = attrPosture.get('max');
      var postureVal;
      if (posture.startsWith('ATT')) {
        postureVal = parseInt(attrPosture.get('current'));
        attBonus -= postureVal;
        explications.push("Posture de combat => -" + postureVal + " en Attaque");
      } else if (posture.endsWith('ATT')) {
        postureVal = parseInt(attrPosture.get('current'));
        attBonus += postureVal;
        explications.push("Posture de combat => +" + postureVal + " en Attaque");
      }
    }
    if (attributeAsBool(personnage, 'danseIrresistible')) {
      attBonus -= 4;
      explications.push("En train de danser => -4 en Attaque");
    }
    if (attributeAsBool(personnage, 'cadavreAnime')) {
      attBonus -= 4;
      explications.push("Cadavre anim\xE9 => -2 en Attaque");
    }
    var bonusCapitaine = aUnCapitaine(personnage, evt);
    if (bonusCapitaine) {
      attBonus += parseInt(bonusCapitaine);
      var msgCapitaine = "Un ";
      if (bonusCapitaine > 2) msgCapitaine += "commandant";
      else msgCapitaine += "capitaine";
      msgCapitaine += " donne des ordres => +" + bonusCapitaine + " en Attaque et aux DMs";
      personnage.bonusCapitaine = bonusCapitaine;
      explications.push(msgCapitaine);
    }
    if (attributeAsBool(personnage, 'forceDeGeant')) {
      var bonusForceDeGeant = getValeurOfEffet(personnage, 'forceDeGeant', 2);
      attBonus += bonusForceDeGeant;
      explications.push("Force de g\xE9ant => +" + bonusForceDeGeant + " en Attaque");
    }
    if (attributeAsBool(personnage, 'nueeDInsectes')) {
      var malusNuee =
        2 + attributeAsInt(personnage, 'nueeDInsectesTempeteDeManaIntense', 0);
      attBonus -= malusNuee;
      explications.push("Nu\xE9e d\'insectes => -" + malusNuee + " en Attaque");
      if (malusNuee > 2)
        removeTokenAttr(personnage, 'nueeDInsectesTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'nueeDeCriquets')) {
      var malusNueeCriquets =
        3 + attributeAsInt(personnage, 'nueeDeCriquetsTempeteDeManaIntense', 0);
      attBonus -= malusNueeCriquets;
      explications.push("Nu\xE9e de criquets => -" + malusNueeCriquets + " en Attaque");
      if (malusNueeCriquets > 3)
        removeTokenAttr(personnage, 'nueeDeCriquetsTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'nueeDeScorpions')) {
      attBonus -= 3;
      explications.push("Nu\xE9e de scorpions => -3 en Attaque");
    }
    if (attributeAsBool(personnage, 'etatExsangue')) {
      attBonus -= 2;
      explications.push("Exsangue => -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'armeBrulante')) {
      attBonus -= 2;
      explications.push("Arme br\xFBlante => -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'marcheSylvestre')) {
      attBonus += 2;
      explications.push("Marche sylvestre : +2 en Attaque");
    }
    if (attributeAsBool(personnage, 'prisonVegetale')) {
      attBonus -= getValeurOfEffet(personnage, 'prisonVegetale', 2);
      explications.push("Prison v\xE9g\xE9tale : -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'toiles')) {
      attBonus -= getValeurOfEffet(personnage, 'toiles', 2);
      explications.push("Entrav\xE9 : -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'masqueDuPredateur')) {
      let bonusMasque = getValeurOfEffet(personnage, 'masqueDuPredateur', modCarac(personnage, 'sagesse'));
      let masqueIntense = attributeAsInt(personnage, 'masqueDuPredateurTempeteDeManaIntense', 0);
      bonusMasque += masqueIntense;
      attBonus += bonusMasque;
      explications.push("Masque du pr\xE9dateur : +" + bonusMasque + " en Attaque et DM");
      if (masqueIntense)
        removeTokenAttr(personnage, 'masqueDuPredateurTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'armeSecreteBarde')) {
      attBonus -= 10;
      explications.push("D\xE9stabilis\xE9 par une action de charme => -10 en Attaque");
    }
    if (attributeAsBool(personnage, 'espaceExigu')) {
      let bonusForce = modCarac(personnage, 'force');
      if (bonusForce < 1) bonusForce = 1;
      explications.push("Espace exigu : -" + bonusForce + " en Attaque");
      attBonus -= bonusForce;
    } else if (attributeAsBool(personnage, 'constructionTailleHumaine')) {
      explications.push("Construction de taille humaine : -1 en Attaque");
      attBonus -= 1;
    }
    if (attributeAsBool(personnage, 'agrippeParUnDemon')) {
      explications.push("agripp\xE9 : -3 en Attaque");
      attBonus -= 3;
    }
    if (attributeAsBool(personnage, 'ondesCorruptrices') &&
      !attributeAsBool(personnage, 'sangDeLArbreCoeur') &&
      !predicateAsBool(personnage, 'porteurDuBouclierDeGrabuge')) {
      let malus = attributeAsInt(personnage, 'ondesCorruptrices', 2);
      explications.push("naus\xE9eux : -" + malus + " aux tests");
      attBonus -= malus;
    }
    if (attributeAsBool(personnage, 'inconfort')) {
      let inconfortValeur = attributeAsInt(personnage, 'inconfortValeur', 0);
      attBonus -= inconfortValeur;
      explications.push("G\xEAne due \xE0 l'armure : -" + inconfortValeur);
    }
    if (attributeAsBool(personnage, 'putrefactionOutreTombe')) {
      attBonus -= 2;
      explications.push("Putr\xE9faction => -2 en Attaque");
    }
    return attBonus;
  }

  function rollNumber(s) {
    return parseInt(s.substring(3, s.indexOf(']')));
  }

  //tm doit \xEAtre stateCOF.tenebresMagiques, et bien d\xE9fini.
  function eclaireParFioleDeLumiere(perso, tm) {
    var fio = tm.fioleDeLumiere;
    if (fio === undefined || fio.porteur === undefined) return false;
    return distanceCombat(fio.porteur.token, perso.token) < fio.distance;
  }

  function compagnonPresent(personnage, attribut) {
    let attrs = findObjs({
      _type: 'attribute',
      _characterid: personnage.charId,
      name: attribut
    });
    if (attrs.length > 0) {
      let compagnon = attrs[0].get('current');
      let compToken = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: personnage.token.get('pageid'),
        layer: 'objects',
        name: compagnon
      });
      let res = false;
      compToken.forEach(function(tok) {
        if (res) return;
        let compCharId = tok.get('represents');
        if (compCharId === '') return;
        compagnon = {
          token: tok,
          charId: compCharId
        };
        res = isActive(compagnon);
      });
      return res;
    }
    return false;
  }

  //evt est optionnel
  function defenseOfPerso(attaquant, target, pageId, evt, options) {
    options = options || {};
    if (options.difficultePVmax) {
      let pvmax = parseInt(target.token.get('bar1_max'));
      if (isNaN(pvmax)) {
        error("Points de vie de " + target.token.get('name') + " mal form\xE9s",
          target.token.get('bar1_max'));
        return 0;
      }
      return pvmax;
    } else if (options.difficultePV) {
      let pv = parseInt(target.token.get('bar1_value'));
      if (isNaN(pv)) {
        error("Points de vie de " + target.token.get('name') + " mal form\xE9s",
          target.token.get('bar1_value'));
        return 0;
      }
      return pv;
    } else if (options.difficulteCarac) {
      let carac = caracOfMod(options.difficulteCarac.carac);
      target.messages = target.messages || [];
      let diff = caracCourante(target, carac);
      if (options.difficulteCarac.carac2) {
        let carac2 = caracOfMod(options.difficulteCarac.carac2);
        let diff2 = caracCourante(target, carac2);
        if (diff2 > diff) {
          diff = diff2;
          target.messages.push("Attaque contre " + stringOfCarac(options.difficulteCarac.carac2));
        } else {
          target.messages.push("Attaque contre " + stringOfCarac(options.difficulteCarac.carac));
        }
      } else {
        target.messages.push("Attaque contre " + stringOfCarac(options.difficulteCarac.carac));
      }
      return diff;
    }
    target.tokName = target.tokName || target.token.get('name');
    let defDerivee = charAttribute(target.charId, 'defDeriveeDe');
    if (defDerivee.length > 0) {
      let charDerive = findObjs({
        _type: 'character',
        name: defDerivee[0].get('current')
      });
      if (charDerive.length > 0) {
        target = {
          charId: charDerive[0].id,
          token: target.token,
          tokName: target.tokName,
          messages: target.messages,
          defautCuirasse: target.defautCuirasse,
        };
      }
    }
    let tokenName = target.tokName;
    let explications = target.messages || [];
    let defense = 10;
    if (persoEstPNJ(target)) {
      defense = ficheAttributeAsInt(target, 'pnj_def', 10);
    } else {
      if (target.defautCuirasse === undefined) {
        defense += ficheAttributeAsInt(target, 'defarmure', 0) * ficheAttributeAsInt(target, 'defarmureon', 0);
        defense += ficheAttributeAsInt(target, 'defbouclier', 0) * ficheAttributeAsInt(target, 'defbouclieron', 0);
        if (attributeAsBool(target, 'armureDuMage')) {
          let bonusArmureDuMage = getValeurOfEffet(target, 'armureDuMage', 4);
          if (defense > 12) defense += bonusArmureDuMage / 2; // On a d\xE9j\xE0 une armure physique, \xE7a ne se cumule pas.
          else defense += bonusArmureDuMage;
        }
        if (attributeAsBool(target, 'armureDEau')) {
          let bonusArmureDEau = getValeurOfEffet(target, 'armureDEau', 2);
          defense += bonusArmureDEau;
          explications.push("Armure d'eau : +" + bonusArmureDEau + " en DEF");
        }
        defense += ficheAttributeAsInt(target, 'DEFDIV', 0);
      } // Dans le cas contraire, on n'utilise pas ces bonus
      defense += modCarac(target, 'dexterite');
    }
    if (attributeAsBool(target, 'inconfort')) {
      var inconfortValeur = attributeAsInt(target, "inconfortValeur", 0);
      defense -= inconfortValeur;
      explications.push("L'adversaire est g\xEAn\xE9 par son armure : -" + inconfortValeur + " en DEF");
    }
    let formeDarbre;
    if (attributeAsBool(target, 'formeDArbre')) {
      formeDarbre = true;
      defense = 13;
    }
    if (attributeAsBool(target, 'statueDeBois')) defense = 10;
    // Malus de d\xE9fense global pour les longs combats
    if (reglesOptionelles.haute_DEF.val.usure_DEF.val && stateCOF.combat &&
      !stateCOF.usureOff && stateCOF.tour > 1)
      defense -= (Math.floor((stateCOF.tour - 1) / reglesOptionelles.haute_DEF.val.usure_DEF.val) * 2);
    // Autres modificateurs de d\xE9fense
    defense += attributeAsInt(target, 'defenseTotale', 0);
    let pacifisme = predicateAsInt(target, 'pacifisme', 0, 5);
    if (pacifisme > 0 && !attributeAsBool(target, 'attributDeCombat_pacifismeAnnule'))
      defense += pacifisme;
    if (attributeAsBool(target, 'aspectDuDemon')) {
      defense += getValeurOfEffet(target, 'aspectDuDemon', 2);
    }
    if (attributeAsBool(target, 'peauDEcorce')) {
      var bonusPeau = getValeurOfEffet(target, 'peauDEcorce', 1, 'voieDesVegetaux');
      var peauIntense = attributeAsInt(target, 'peauDEcorceTempeteDeManaIntense', 0);
      bonusPeau += peauIntense;
      if (reglesOptionelles.divers.val.forme_d_arbre_amelioree.val && formeDarbre) {
        bonusPeau = Math.ceil(bonusPeau * 1.5);
      }
      defense += bonusPeau;
      explications.push("Peau d'\xE9corce : +" + bonusPeau + " en DEF");
      if (peauIntense && evt && !options.test)
        removeTokenAttr(target, 'peauDEcorceTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(target, 'champDeProtection')) {
      var bonusChamp =
        getValeurOfEffet(target, 'champDeProtection', 2, 'voieDeLaTelekinesie');
      var champIntense = attributeAsInt(target, 'champDeProtectionTempeteDeManaIntense', 0);
      bonusChamp += champIntense;
      defense += bonusChamp;
      explications.push("Champ de protection : +" + bonusChamp + " en DEF");
      if (champIntense && evt && !options.test)
        removeTokenAttr(target, 'champDeProtectionTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(target, 'mutationCuirasse')) {
      var bonusMutation =
        getValeurOfEffet(target, 'mutationCuirasse', 2, 'voieDesMutations');
      defense += bonusMutation;
      explications.push("Cuirasse : +" + bonusMutation + " en DEF");
    }
    if (attributeAsBool(target, 'sixiemeSens')) {
      defense += 2;
      explications.push("Sixi\xE8me sens : +2 DEF");
    }
    if (getState(target, 'surpris')) defense -= 5;
    if (getState(target, 'renverse')) defense -= 5;
    if (getState(target, 'aveugle') || attributeAsBool(target, 'aveugleManoeuvre')) {
      if (options.contact && predicateAsBool(target, 'radarMental') && attaquant && !estNonVivant(attaquant)) {
        explications.push(tokenName + " est aveugle, mais b\xE9n\xE9ficie de son radar mental");
      } else {
        defense -= 5;
      }
    }
    if (getState(target, 'etourdi') || attributeAsBool(target, 'peurEtourdi'))
      defense -= 5;
    if (getState(target, 'invisible') && attaquant && !attributeAsBool(attaquant, 'detectionDeLInvisible')) {
      if (options.distance) {
        if (options.tirAveugle) {
          explications.push("Cible invisible, mais " + attaquant.tokName + " sait tirer \xE0 l'aveugle");
        } else {
          defense += 10;
          explications.push("Invisible : +10 en DEF");
        }
      } else {
        if (attaquant && predicateAsBool(attaquant, 'radarMental') && !estNonVivant(target)) {
          explications.push("Cible invisible, mais " + attaquant.tokName + " utilise son radar mental");
        } else {
          defense += 5;
          explications.push("Invisible : +5 en DEF");
        }
      }
    }
    defense += attributeAsInt(target, 'bufDEF', 0);
    defense += attributeAsInt(target, 'actionConcertee', 0);
    if (ficheAttributeAsInt(target, 'defarmureon', 0) === 0) {
      defense += predicateAsInt(target, 'vetementsSacres', 0);
      defense += predicateAsInt(target, 'armureDeVent', 0);
      if (!options.distance)
        defense += predicateAsInt(target, 'dentellesEtRapiere', 0);
    }
    defense += predicateAsInt(target, 'esquiveVoleur', 0);
    if (predicateAsBool(target, 'graceFeline')) {
      defense += modCarac(target, 'charisme');
    }
    if (predicateAsBool(target, 'peauDePierre')) {
      defense += modCarac(target, 'constitution');
    }
    if (predicateAsBool(target, 'defenseIntuitive')) {
      defense += modCarac(target, 'sagesse');
    }
    if (predicateAsBool(target, 'intelligenceDuCombat')) {
      defense += modCarac(target, 'intelligence');
    }
    if (attributeAsBool(target, 'armeSecreteBarde')) {
      explications.push(tokenName + " est d\xE9stabilis\xE9 par une action de charme => -10 en DEF");
      defense -= 10;
    }
    if (options.metal && attributeAsBool(target, 'magnetisme')) {
      var magnetisme = getValeurOfEffet(target, 'magnetisme', 5);
      defense += magnetisme;
      explications.push(tokenName + " contr\xF4le le magn\xE9tisme (+" + magnetisme + " DEF)");
    }
    if (attributeAsBool(target, 'diversionManoeuvre')) {
      var diversion = getValeurOfEffet(target, 'diversionManoeuvre', -5);
      defense += diversion;
      explications.push(tokenName + " est victime d'une diversion => " + diversion + " DEF");
    }
    if (options.attaqueMentale && predicateAsBool(target, 'bouclierPsi')) {
      defense += 5;
      explications.push(tokenName + " b\xE9n\xE9ficie d'un bouclier psi => +5 DEF");
    }
    if (attributeAsBool(target, 'monteSur')) {
      if (predicateAsBool(target, 'montureLoyale')) {
        defense += 1;
        explications.push(tokenName + " est sur une monture => +1 DEF");
      }
      if (options.contact && predicateAsBool(target, "horsDePortee")) {
        defense += 5;
        explications.push(tokenName + " est hors de port\xE9e sur sa monture => +5 DEF");
      }
    }
    let attrsProtegePar = findObjs({
      _type: 'attribute',
      _characterid: target.charId,
    });
    attrsProtegePar.forEach(function(attr) {
      var attrName = attr.get('name');
      if (attrName.startsWith('protegePar_')) {
        var nameProtecteur = attr.get('max');
        if (attr.get('bar1_link') === '') {
          if (attrName != 'protegePar_' + nameProtecteur + '_' + tokenName) return;
        } else if (attrName != 'protegePar_' + nameProtecteur) return;
        var protecteur = persoOfId(attr.get('current'), nameProtecteur, pageId);
        if (protecteur === undefined) {
          if (evt) removeTokenAttr(target, 'protegePar_' + nameProtecteur, evt);
          sendPerso(target, "ne peut pas \xEAtre prot\xE9g\xE9 par " + nameProtecteur + " car aucun token le repr\xE9sentant n'est sur la page");
          return;
        }
        if (!isActive(protecteur)) {
          explications.push(nameProtecteur + " n'est pas en \xE9tat de prot\xE9ger " +
            tokenName);
          return;
        }
        let distTargetProtecteur = distanceCombat(target.token, protecteur.token, pageId);
        if (distTargetProtecteur > 0) {
          explications.push(nameProtecteur + " est trop loin de " +
            tokenName + " pour le prot\xE9ger");
          return;
        }
        if (ficheAttributeAsInt(protecteur, 'defbouclieron', 0) === 0) {
          let sujet = onGenre(protecteur, 'il', 'elle');
          explications.push(nameProtecteur +
            " ne porte pas son bouclier, " + sujet + " ne peut pas proteger " +
            tokenName);
          return;
        }
        let defBouclierProtecteur;
        if (persoEstPNJ(protecteur)) defBouclierProtecteur = 2;
        else defBouclierProtecteur = ficheAttributeAsInt(protecteur, 'defbouclier', 0);
        defense += defBouclierProtecteur;
        explications.push(nameProtecteur + " prot\xE8ge " +
          tokenName + " de son bouclier (+" + defBouclierProtecteur + " DEF)");
      }
    });
    let attrPosture = tokenAttribute(target, 'postureDeCombat');
    if (attrPosture.length > 0) {
      attrPosture = attrPosture[0];
      let posture = attrPosture.get('max');
      let postureVal;
      if (posture.startsWith('DEF')) {
        postureVal = parseInt(attrPosture.get('current'));
        defense -= postureVal;
        explications.push("Posture de combat => -" + postureVal + " DEF");
      } else if (posture.endsWith('DEF')) {
        postureVal = parseInt(attrPosture.get('current'));
        defense += postureVal;
        explications.push("Posture de combat => +" + postureVal + " DEF");
      }
    }
    let attrAttaqueAOutrance = tokenAttribute(target, 'attaqueAOutrance');
    if (attrAttaqueAOutrance.length > 0) {
      attrAttaqueAOutrance = attrAttaqueAOutrance[0];
      var attaqueAOutranceVal = parseInt(attrAttaqueAOutrance.get('current'));
      defense -= attaqueAOutranceVal;
      explications.push("Attaque \xE0 outrance => -" + attaqueAOutranceVal + " DEF");
    }
    let instinctSurvie = predicateAsInt(target, 'instinctDeSurvie', 0);
    if (instinctSurvie > 0 && target.token.get('bar1_value') <= instinctSurvie)
      defense += 5;
    if (attributeAsBool(target, 'danseIrresistible')) {
      defense -= 4;
      explications.push("En train de danser => -4 DEF");
    }
    if (options.sortilege)
      defense += predicateAsInt(target, 'DEF_magie', 0);
    if (attributeAsBool(target, 'marcheSylvestre')) {
      defense += 2;
      explications.push("Marche sylvestre => +2 DEF");
    }
    if (attributeAsBool(target, 'prisonVegetale')) {
      defense -= getValeurOfEffet(target, 'prisonVegetale', 2);
      explications.push("Prison v\xE9g\xE9tale => -2 DEF");
    }
    if (attributeAsBool(target, 'toiles')) {
      defense -= getValeurOfEffet(target, 'toiles', 2);
      explications.push("Entrav\xE9 => -2 DEF");
    }
    if (attributeAsBool(target, 'protectionContreLeMal') &&
      (attaquant && estMauvais(attaquant))) {
      var bonusProtectionContreLeMal = getValeurOfEffet(target, 'protectionContreLeMal', 2);
      defense += bonusProtectionContreLeMal;
      explications.push("Protection contre le mal => +" + bonusProtectionContreLeMal + " DEF");
    }
    var rageBerserk = tokenAttribute(target, 'rageDuBerserk');
    if (rageBerserk.length > 0) {
      rageBerserk = rageBerserk[0].get('current');
      var modRage;
      var msgRage;
      if (rageBerserk == 'furie') {
        modRage = -6;
        msgRage = "Furie";
      } else {
        modRage = -4;
        msgRage = "Rage";
      }
      if (predicateAsBool(target, 'rageDuBerserkAmelioree')) {
        modRage /= 2;
      }
      explications.push(msgRage + " du berserk => " + modRage + " DEF");
      defense += modRage;
    }
    let combatEnPhalange = predicateAsBool(target, 'combatEnPhalange');
    if (combatEnPhalange || capaciteDisponible(target, 'esquiveFatale', 'combat')) {
      let tokensContact = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        layer: 'objects'
      });
      tokensContact = tokensContact.filter(function(tok) {
        if (tok.id == target.token.id) return false;
        return distanceCombat(target.token, tok, pageId) === 0;
      });
      let tokensAllies = [];
      let tokensEnnemis = [];
      let allies = alliesParPerso[target.charId] || new Set();
      tokensContact.forEach(function(tok) {
        let ci = tok.get('represents');
        if (ci === '') return; //next token au contact
        if (!isActive({
            token: tok,
            charId: ci
          })) return;
        if (allies.has(ci)) tokensAllies.push(tok);
        else tokensEnnemis.push(tok);
      });
      target.ennemisAuContact = tokensEnnemis;
      target.alliesAuContact = tokensAllies;
      if (combatEnPhalange) {
        let defensePhalange = 0;
        tokensEnnemis.forEach(function(tokE) {
          let alliesAuContact = tokensAllies.filter(function(tokA) {
            return distanceCombat(tokE, tokA, pageId) === 0;
          });
          if (alliesAuContact.length > defensePhalange)
            defensePhalange = alliesAuContact.length;
        });
        if (defensePhalange > 0) {
          defense += defensePhalange;
          explications.push("Combat en phalange => +" + defensePhalange + " DEF");
        }
      }
    }
    if (attributeAsBool(target, 'espaceExigu')) {
      let bonusForce = modCarac(target, 'force');
      if (bonusForce < 1) bonusForce = 1;
      explications.push("Espace exigu : -" + bonusForce + " en DEF");
      defense -= bonusForce;
    } else if (attributeAsBool(target, 'constructionTailleHumaine')) {
      explications.push("Construction de taille humaine : -1 en DEF");
      defense -= 1;
    }
    if (attributeAsBool(target, 'attaqueRisquee')) {
      defense -= 4;
      explications.push("Suite \xE0 une attaque risqu\xE9e, -4 en DEF");
    }
    //gestion de l'\xE9pieu
    if (attaquant) {
      let armeTarget = armesEnMain(target); //peuple target.arme et armeGauche
      if (armeTarget && armeTarget.epieu) {
        let armeAttaquant = tokenAttribute(attaquant, 'armeEnMain');
        if (armeAttaquant.length === 0) {
          defense += 2;
          explications.push("\xC9pieu contre une attaque sans arme => +2 DEF");
        }
      }
    }
    if (options.distance) {
      var bonusCouvert = attributeAsInt(target, 'bonusCouvert');
      if (bonusCouvert) {
        if (attaquant && predicateAsBool(attaquant, 'joliCoup')) {
          explications.push("Cible \xE0 couvert, mais " + attaquant.tokName + " sait bien viser");
        } else {
          defense += bonusCouvert;
          explications.push("Cible \xE0 couvert => +" + bonusCouvert + " DEF");
        }
      }
      if (attributeAsBool(target, 'progresserACouvert')) {
        if (attaquant && predicateAsBool(attaquant, 'joliCoup')) {
          explications.push("Cible \xE0 couvert de bouclier, mais " + attaquant.tokName + " sait bien viser");
        } else {
          defense += 5;
          explications.push("Cible \xE0 couvert de bouclier => +5 DEF");
        }
      }
    }
    //Chair \xE0 canon
    if (capaciteDisponible(target, 'chairACanon', 'tour')) {
      let tokensChairACanon = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        layer: 'objects'
      });
      target.chairACanon = tokensChairACanon.filter(function(tok) {
        if (tok.id == target.token.id) return false;
        let tokCharId = tok.get('represents');
        if (tokCharId === '') return false;
        if (distanceCombat(target.token, tok, pageId) > 3) return false;
        let pChair = {
          token: tok,
          charId: tokCharId,
        };
        if (getState(pChair, 'mort')) return;
        let tokAttrs = charAttribute(tokCharId, 'chairACanonDe');
        let estChair = tokAttrs.find(function(a) {
          let chairACanonDe = a.get('current').split(",");
          return chairACanonDe.find(function(b) {
            let trimmed = b.trim();
            return trimmed == target.tokName || trimmed == target.name;
          });
        });
        return estChair;
      });
      if (target.chairACanon.length > 0) {
        defense += 5;
        explications.push(target.chairACanon[0].get('name') + " aide " + target.tokName + "! => +5 DEF");
      }
    }
    let bonusCapitaine = aUnCapitaine(target, evt, pageId);
    if (bonusCapitaine && bonusCapitaine > 2) {
      defense += parseInt(bonusCapitaine);
      explications.push(tokenName + " suit les ordres de son commandant => +" + bonusCapitaine + " en DEF");
    }
    if (attaquant && predicateAsBool(target, 'reduireLaDistance')) {
      switch (taillePersonnage(attaquant, 4)) {
        case 5:
          defense += 2;
          explications.push(target.tokName + " r\xE9duit la distance => +2 en DEF");
          break;
        case 6:
          defense += 3;
          explications.push(target.tokName + " r\xE9duit la distance => +3 en DEF");
          break;
        case 7:
          defense += 4;
          explications.push(target.tokName + " r\xE9duit la distance => +4 en DEF");
      }
    }
    if (attaquant && predicateAsBool(target, 'insignifiant')) {
      switch (taillePersonnage(attaquant, 4)) {
        case 5:
          defense += 2;
          explications.push(target.tokName + " insignifiant => +2 en DEF");
          break;
        case 6:
        case 7:
          defense += 4;
          explications.push(target.tokName + " insignifiant => +4 en DEF");
      }
    }
    if (attributeAsBool(target, 'etreinteImmole')) {
      defense -= 5;
      explications.push(target.tokName + " \xE9treint quelqu'un => -5 en DEF");
    }
    if (attributeAsBool(target, 'etreinteScorpionRatee')) {
      defense -= 5;
      explications.push(target.tokName + " est \xE9treint par un scorpion => -5 DEF");
    }
    if (attaquant && predicateAsBool(target, 'langageSombreHetre') && estElfeNoir(attaquant)) {
      defense += 1;
      explications.push(target.tokName + " comprend le langage sombre => +1 en DEF");
    }
    if (attributeAsBool(target, 'presenceGlaciale')) {
      var defenseGlaciale = getValeurOfEffet(target, 'presenceGlaciale', 4);
      explications.push("Pr\xE9sence glaciale => +" + defenseGlaciale + " en DEF");
      defense += defenseGlaciale;
    }
    if (attributeAsBool(target, 'cyclone')) {
      explications.push("Cyclone => +5 en DEF");
      defense += 5;
    }
    if (options.pacteSanglantDef && options.pacteSanglantDef[target.token.id]) {
      explications.push("Pacte Sanglant => +" + options.pacteSanglantDef[target.token.id] + " en DEF");
      defense += options.pacteSanglantDef[target.token.id];
    }
    if (options.expertDuCombatDEF && options.expertDuCombatDEF[target.token.id]) {
      explications.push("Expert du combat => +" + options.expertDuCombatDEF[target.token.id].roll + " en DEF");
      defense += options.expertDuCombatDEF[target.token.id].val;
    }
    var defArme = charAttributeAsInt(target, 'armeBonusDef', 0);
    if (defArme > 0) {
      explications.push("Arme de parade en main => +" + defArme + " en DEF");
      defense += defArme;
    }
    defArme = charAttributeAsInt(target, 'armeGaucheBonusDef', 0);
    if (defArme > 0) {
      explications.push("Arme de parade en main gauche => +" + defArme + " en DEF");
      defense += defArme;
    }
    if (attributeAsBool(target, 'prescienceUtilisee')) {
      explications.push("Prescience => +10 en DEF");
      defense += 10;
    }
    if (options.contact && attributeAsBool(target, 'tenirADistance')) {
      explications.push("Tient l'ennemi \xE0 distance => +5 en DEF");
      defense += 5;
    }
    var tm = stateCOF.tenebresMagiques;
    if (tm) {
      if (estDemon(target)) {
        if (eclaireParFioleDeLumiere(target, tm)) {
          explications.push("Aveugl\xE9 par la fiole de lumi\xE8re => -2 en DEF");
          defense -= 2;
        }
      } else if (attaquant &&
        !eclaireParFioleDeLumiere(attaquant, tm)) {
        explications.push("T\xE9n\xE8bres magiques => -5 en DEF");
        defense -= 5;
      }
    }
    if (attributeAsBool(target, 'agrippeParUnDemon')) {
      explications.push("agripp\xE9 => -3 en DEF");
      defense -= 3;
    }
    if (estNecromancie(options) && attributeAsBool(target, 'sangDeLArbreCoeur')) {
      explications.push("Sang de l'Arbre-Coeur => +5 en DEF");
      defense += 5;
    }
    if (predicateAsBool(target, 'liberateurDeDorn') && estGeant(attaquant)) {
      explications.push(target, 'Lib\xE9rateur de Dorn => +2 en DEF');
      defense += 2;
    }
    let pirouettes = predicateAsInt(target, 'pirouettes', 0);
    if (pirouettes > 0) {
      if (malusArmure(target) > 4) {
        explications.push(target, 'Armure lourde, pas de pirouette');
      } else {
        explications.push(target, 'Pirouettes => +' + pirouettes + ' en DEF');
        defense += pirouettes;
      }
    }
    if (attributeAsBool(target, 'danseDesLames') && malusArmure(target) <= 4) {
      explications.push(target, 'Danse des lames => +2 en DEF');
      defense += 2;
    }
    return defense;
  }

  // renvoie l'attribut cr\xE9\xE9 ou mis \xE0 jour
  function setAttrDuree(perso, attr, duree, evt, msg, secret) {
    var options = {
      maxVal: getInit(),
      secret: secret
    };
    if (msg) options.msg = msg;
    return setTokenAttr(perso, attr, duree, evt, options);
  }
  //Bonus en Attaque qui ne d\xE9pendent pas du d\xE9fenseur
  //attaquant doit avoir un champ tokName
  function bonusAttaqueA(attaquant, weaponName, evt, explications, options) {
    var attBonus = 0;
    if (options.bonusAttaque) attBonus += options.bonusAttaque;
    if (options.armeMagiquePlus) attBonus += options.armeMagiquePlus;
    attBonus += bonusDAttaque(attaquant, explications, evt);
    if (options.tirDouble) {
      attBonus += 2;
      if (options.tirDouble.stats && options.tirDouble.stats.name) {
        explications.push(attaquant.tokName + " tire avec " +
          weaponName + " et " + options.tirDouble.stats.name + " \xE0 la fois !");
      } else {
        explications.push(attaquant.tokName + " tire avec 2 " +
          weaponName + "s \xE0 la fois !");
      }
    }
    if (options.chance) {
      attBonus += options.chance;
      var pc = options.chance / 10;
      explications.push(pc + " point" + ((pc > 1) ? "s" : "") + " de chance d\xE9pens\xE9 => +" + options.chance + " en Attaque");
    }
    if (options.semonce) {
      attBonus += 5;
    }
    if (!options.pasDeDmg && !options.feinte) {
      if (ficheAttributeAsBool(attaquant, 'attaque_en_puissance_check')) {
        options.attaqueEnPuissance = ficheAttributeAsInt(attaquant, 'attaque_en_puissance', 1);
      }
      if (!options.auto && options.attaqueEnPuissance) {
        attBonus -= 5 * options.attaqueEnPuissance;
        explications.push("Attaque en puissance => -" + (5 * options.attaqueEnPuissance) + " en Attaque et +" + options.attaqueEnPuissance + options.d6 + " DM");
      }
      if (ficheAttributeAsBool(attaquant, 'attaque_assuree_check')) {
        options.attaqueAssuree = true;
      }
      if (options.attaqueAssuree) {
        attBonus += 5;
        explications.push("Attaque assur\xE9e => +5 en Attaque et DM/2");
      }
      if (ficheAttributeAsBool(attaquant, 'attaque_dm_temp_check')) {
        options.attaqueDmTemp = true;
      }
      if (options.attaqueDmTemp && !options.tempDmg && !options.sortilege && (options.contact || !options.percant)) {
        options.tempDmg = true;
        if (!options.choc) {
          attBonus -= 2;
          explications.push("Attaque pour assommer => -2 en Attaque");
        }
      }
    }
    if (persoEstPNJ(attaquant) && options.attaqueDeGroupe === undefined) {
      options.attaqueDeGroupe = ficheAttributeAsInt(attaquant, 'attaque_de_groupe', 1);
    }
    if (options.attaqueDeGroupe > 1) {
      var bonusTouche = reglesOptionelles.haute_DEF.val.bonus_attaque_groupe.val * (options.attaqueDeGroupe - 1);
      attBonus += bonusTouche;
      explications.push("Attaque en groupe => +" + bonusTouche + " en Attaque");
    }
    if (attributeAsBool(attaquant, 'criDuPredateur')) {
      attBonus += 1;
      explications.push("Cri du pr\xE9dateur => +1 en attaque");
    }
    if (attributeAsBool(attaquant, 'baroudHonneurActif')) {
      attBonus += 5;
      explications.push(attaquant.tokName + " porte une derni\xE8re attaque et s'effondre");
      mort(attaquant, function(m) {
        explications.push(m);
      }, evt);
      removeTokenAttr(attaquant, 'baroudHonneurActif', evt);
    }
    if (options.sortilege && attributeAsBool(attaquant, 'zoneDeSilence')) {
      attBonus -= 2;
      explications.push("Zone de silence => -2 en Attaque Magique");
    }
    if (attributeAsBool(attaquant, 'monteSur')) {
      if (!options.distance) {
        let cavalierEm = predicateAsInt(attaquant, 'cavalierEmerite');
        if (cavalierEm) {
          attBonus += cavalierEm;
          let explCavalierEmerite = "avalier \xE9m\xE9rite => +" + cavalierEm + " en Attaque";
          if (options.displayName) {
            explCavalierEmerite = attaquant.tokName + " est un c" + explCavalierEmerite;
          } else {
            explCavalierEmerite = 'C' + explCavalierEmerite;
          }
          explications.push(explCavalierEmerite);
        }
      }
      if (predicateAsBool(attaquant, 'montureLoyale')) {
        attBonus += 1;
        explications.push("Monture loyale => +1 en Attaque");
      }
    }
    if (options.frappeDuVide) {
      attBonus += 2;
      if (options.pasDeDmg)
        explications.push("Frappe du vide => +2 en Attaque");
      else
        explications.push("Frappe du vide => +2 en Attaque et +1d6 DM");
    }
    if (attributeAsBool(attaquant, 'reactionViolente')) {
      attBonus += 2;
      if (options.pasDeDmg)
        explications.push("R\xE9action violente => +2 en Attaque");
      else {
        explications.push("R\xE9action violente => +2 en Attaque et +1d6 DM");
        options.reactionViolente = true;
      }
    }
    if (options.contact) {
      if (attributeAsBool(attaquant, 'rayonAffaiblissant')) {
        options.rayonAffaiblissant = getValeurOfEffet(attaquant, 'rayonAffaiblissant', 2);
        if (options.rayonAffaiblissant < 0) options.rayonAffaiblissant = 1;
        attBonus -= options.rayonAffaiblissant;
        var msgRA = "Rayon affaiblissant => -" + options.rayonAffaiblissant + " en Attaque";
        if (options.pasDeDmg) explications.push(msgRA);
        else explications.push(msgRA + " et aux DM");
      }
      if (attributeAsBool(attaquant, 'enrage')) {
        attBonus += 5;
        if (options.pasDeDmg)
          explications.push("Enrag\xE9 => +5 en Attaque");
        else
          explications.push("Enrag\xE9 => +5 en Attaque et +1d6 DM");
      }
      if (attributeAsBool(attaquant, 'aspectDuDemon')) {
        attBonus += getValeurOfEffet(attaquant, 'aspectDuDemon', 2);
        explications.push("Aspect de d\xE9mon => +2 en Attaque");
      }
      let rageBerserk = tokenAttribute(attaquant, 'rageDuBerserk');
      if (rageBerserk.length > 0) {
        rageBerserk = rageBerserk[0].get('current');
        if (rageBerserk == 'furie') {
          attBonus += 3;
          if (options.pasDeDmg)
            explications.push("Furie du berserk : +3 en Attaque");
          else
            explications.push("Furie du berserk : +3 en Attaque et +2d6 aux DM");
          options.rageBerserk = 2;
        } else {
          attBonus += 2;
          if (options.pasDeDmg)
            explications.push("Rage du berserk : +2 en Attaque");
          else
            explications.push("Rage du berserk : +2 en Attaque et +1d6 aux DM");
          options.rageBerserk = 1;
        }
      }
      if (ficheAttributeAsBool(attaquant, 'attaque_risquee_check')) {
        options.attaqueRisquee = true;
      }
      if (options.attaqueRisquee) {
        attBonus += 2;
        explications.push("Attaque risqu\xE9e => +2 en Attaque");
        if (!options.test) {
          setAttrDuree(attaquant, 'attaqueRisquee', 1, evt);
        }
      }
      if (predicateAsBool(attaquant, 'ambidextreDuelliste')) {
        if (attaquant.armesEnMain === undefined) armesEnMain(attaquant);
        if (attaquant.armeGauche && attaquant.armeGauche.portee === 0) {
          let dmArmeGauche = modCarac(attaquant, 'dexterite');
          let bonusArmeGauche = 0;
          if (attaquant.armeGauche.bonusDef) {
            if (attaquant.pnj) {
              bonusArmeGauche = attaquant.armeGauche.attSkill;
            } else {
              bonusArmeGauche = attaquant.armeGauche.attSkillDiv;
            }
            dmArmeGauche += attaquant.armeGauche.attDMBonusCommun;
          }
          let typeDMGauche = 'normal';
          switch (attaquant.armeGauche.typeDegats) {
            case 'feu':
            case 'froid':
            case 'acide':
            case 'electrique':
            case 'sonique':
            case 'poison':
            case 'maladie':
            case 'magique':
            case 'drain':
            case 'energie':
              typeDMGauche = attaquant.armeGauche.typeDegats;
          }
          if (typeDMGauche == 'normal' && attaquant.armeGauche.modificateurs &&
            attaquant.armeGauche.modificateurs.includes("magique")) {
            typeDMGauche = 'magique';
          }
          attaquant.additionalDmg = attaquant.additionalDmg || [];
          attaquant.additionalDmg.push({
            type: typeDMGauche,
            value: dmArmeGauche
          });
          attBonus += bonusArmeGauche;
          var msgAmbidextre = "Attaque ambidextre => +";
          if (bonusArmeGauche) {
            msgAmbidextre += bonusArmeGauche + " en attaque";
            if (options.pasDeDmg) explications.push(msgAmbidextre);
            else msgAmbidextre += " et +";
          }
          if (!options.pasDeDmg)
            explications.push(msgAmbidextre + dmArmeGauche + " aux DMs");
        }
      }
    }
    let frenesie = predicateAsInt(attaquant, 'frenesie', 0);
    let pv;
    if (frenesie > 0) {
      pv = parseInt(attaquant.token.get('bar1_value'));
      if (pv <= frenesie) {
        attBonus += 2;
        explications.push("Fr\xE9n\xE9sie => +2 en Attaque");
      }
    }
    if (predicateAsBool(attaquant, 'hausserLeTon')) {
      if (pv === undefined)
        pv = parseInt(attaquant.token.get('bar1_value'));
      if (pv <= parseInt(attaquant.token.get('bar1_max') / 2)) {
        attBonus += 5;
        let msgHausserLeTon = "Hausse le ton => +5 en Attaque";
        if (!options.pasDeDmg) {
          msgHausserLeTon += " et +1d6 DM";
          attaquant.additionalDmg = attaquant.additionalDmg || [];
          attaquant.additionalDmg.push({
            type: options.type || 'normal',
            value: '1d6'
          });
        }
        explications.push(msgHausserLeTon);
      }
    }
    if (options.lamesJumelles) {
      let force = modCarac(attaquant, 'force');
      if (force < 2) {
        attBonus += force - 2;
        explications.push("Lames jumelles => " + (force - 2) + " en Attaque");
      }
    }
    if (attributeAsBool(attaquant, 'bonusAttaqueTemp')) {
      let bonusTemp = getValeurOfEffet(attaquant, 'bonusAttaqueTemp', 5);
      attBonus += bonusTemp;
      explications.push("Bonus d'attaque temporaire de " + bonusTemp);
    }
    if (stateCOF.chargeFantastique &&
      stateCOF.chargeFantastique.tokenAttaque == attaquant.token.id) {
      attBonus += 3;
      let msgCharge = "Charge fantastique => +3 en Attaque";
      if (!options.pasDeDmg) {
        msgCharge += " et +1d6 DM";
        attaquant.additionalDmg = attaquant.additionalDmg || [];
        attaquant.additionalDmg.push({
          type: options.type || 'normal',
          value: '1d6'
        });
      }
      explications.push(msgCharge);
    }
    if (attributeAsBool(attaquant, 'enerve')) {
      attBonus -= 2;
      explications.push("Attaquant \xE9nerv\xE9 => -2 en Attaque");
    }
    if (attributeAsBool(attaquant, 'osBrises')) {
      attBonus -= 2;
      explications.push("Des os sont bris\xE9s => -2 en Attaque");
    }
    var attrGobe = tokenAttribute(attaquant, 'estGobePar');
    if (attrGobe.length > 0) {
      var gobant = persoOfIdName(attrGobe[0].get('current'), attaquant.token.get('pageid'));
      if (gobant === undefined) {
        error("Attribut estGobePar mal form\xE9", attrGobe[0].get('current'));
        attrGobe[0].remove();
      } else {
        attBonus -= 5;
        explications.push("Attaquant dans le ventre de " + gobant.token.get('name') + " => -5 en Att. et DM/2");
        options.attaqueEnEtantGobe = true;
      }
    }
    if (attributeAsBool(attaquant, 'noyade')) {
      attBonus -= 3;
      options.noyade = true;
      explications.push("L'attaquant se noie => -3 en Att. et DMs");
    }
    if ((options.marteau || options.hache) && predicateAsBool(attaquant, 'hachesEtMarteaux')) {
      attBonus += 1;
      options.bonusDM = options.bonusDM || 0;
      options.bonusDM += 1;
      explications.push("Haches et marteaux => +1 en Att. et DM");
    }
    if (attributeAsBool(attaquant, 'fievreux')) {
      attBonus -= 2;
      options.fievreux = true;
      explications.push("Fi\xE9vreu" + onGenre(attaquant, 'x', 'se') + " => -2 en Att. et DM");
    }
    if (options.expertDuCombatTouche) {
      let valDesExpert = options.rolls.expertDuCombatTouche || rollDePlus(6);
      evt.action.rolls.expertDuCombatTouche = valDesExpert;
      attBonus += valDesExpert.val;
      explications.push("Expert du combat => +" + valDesExpert.roll + " en Attaque");
    }
    if (options.expertDuCombatDM && !options.pasDeDmg) {
      let valDesExpert = options.rolls.expertDuCombatDM || rollDePlus(6);
      evt.action.rolls.expertDuCombatDM = valDesExpert;
      options.expertDuCombatDMSpec = {
        type: "normal",
        value: "1d6",
        total: valDesExpert.val,
        display: valDesExpert.roll
      };
      explications.push("Expert du combat => +" + valDesExpert.roll + " aux DM");
    }
    if (attributeAsBool(attaquant, 'danseDesLames') && malusArmure(attaquant) <= 4) {
      explications.push(attaquant, 'Danse des lames => +2 en attaque');
      attBonus += 2;
    }
    return attBonus;
  }

  //Bonus d'attaque qui d\xE9pendent de la cible
  // si options.aoe, target doit avoir un champ tokName
  function bonusAttaqueD(attaquant, target, portee, pageId, evt, explications, options) {
    attaquant.tokName = attaquant.tokName || attaquant.token.get('name');
    let attBonus = 0;
    if (target.bonusAttaque) attBonus += target.bonusAttaque;
    if (getState(attaquant, 'aveugle')) {
      if (options.distance) {
        if (options.tirAveugle) {
          explications.push("Attaquant aveugl\xE9, mais il sait tirer \xE0 l'aveugle");
        } else {
          attBonus -= 10;
          explications.push("Attaquant aveugl\xE9 => -10 en Attaque \xE0 distance");
        }
      } else {
        if (!predicateAsBool(attaquant, 'radarMental') || estNonVivant(target)) {
          attBonus -= 5;
          explications.push("Attaquant aveugl\xE9 => -5 en Attaque");
        }
      }
    } else if (attributeAsBool(attaquant, 'aveugleManoeuvre')) {
      if (options.distance || !predicateAsBool(attaquant, 'radarMental') || estNonVivant(target)) {
        attBonus -= 5;
        options.aveugleManoeuvre = true;
        if (options.pasDeDmg)
          explications.push("Attaquant aveugl\xE9 => -5 en Attaque");
        else
          explications.push("Attaquant aveugl\xE9 => -5 en Attaque et aux DM");
      }
    } else if (getState(attaquant, 'invisible') && !attributeAsBool(target, 'detectionDeLInvisible')) {
      attBonus += 5;
      explications.push("Attaque venant d'un personnage invisible => +5 en Attaque");
    } else if (options.distance && getState(attaquant, 'penombre')) {
      if (options.tirAveugle) {
        explications.push("Attaquant dans la p\xE9nombre, mais il sait tirer \xE0 l'aveugle");
      } else {
        attBonus -= 5;
        explications.push("Attaquant dans la p\xE9nombre => -5 en Attaque \xE0 distance");
      }
    }
    if (options.mainsDEnergie) {
      if (options.aoe) error("Mains d'\xE9nergie n'est pas compatible avec les AOE", options.aoe);
      // On v\xE9rifie si la cible porte une armure
      let targetArmorDef = 0;
      if (persoEstPNJ(target)) {
        if (ficheAttributeAsBool(target, 'defarmureon', false)) targetArmorDef = 5;
      } else {
        targetArmorDef = parseInt(getAttrByName(target.charId, "defarmure"));
      }
      if (isNaN(targetArmorDef) || targetArmorDef === 0) {
        attBonus += 2;
        explications.push("Mains d'\xE9nergie => +2 en Attaque (cible sans armure)");
      } else {
        var bonusMain = Math.min(5, 2 + targetArmorDef);
        attBonus += bonusMain;
        explications.push("Mains d'\xE9nergie => +" + bonusMain + " en Attaque");
      }
    }
    if (options.aoe === undefined && options.auto === undefined && portee > 0) {
      attBonus -=
        malusDistance(attaquant, target.token, target.distance, portee, pageId,
          explications, options.ignoreObstacles);
    }
    var chasseurEmerite =
      predicateAsBool(attaquant, 'chasseurEmerite') && estAnimal(target);
    if (chasseurEmerite) {
      attBonus += 2;
      var explChasseurEmerite = "hasseur \xE9m\xE9rite => +2 en Attaque";
      if (options.displayName) {
        explChasseurEmerite = attaquant.tokName + ' est un c' + explChasseurEmerite;
      } else {
        explChasseurEmerite = 'C' + explChasseurEmerite;
      }
      if (!options.pasDeDmg) explChasseurEmerite += " et aux DM";
      if (options.aoe) explChasseurEmerite += " contre " + target.tokName;
      explications.push(explChasseurEmerite);
      target.chasseurEmerite = true;
    }
    let ennemiJureAttr = findObjs({
      _type: 'attribute',
      _characterid: attaquant.charId,
      name: 'ennemiJure'
    });
    let ennemiJure = false;
    if (ennemiJureAttr.length != 0) {
      let races = ennemiJureAttr[0].get('current');
      races.split(",").forEach(function(race) {
        race = race.trim();
        if (race === '') return;
        switch (race) {
          case 'mort-vivant':
            if (estMortVivant(target)) ennemiJure = true;
            break;
          case 'geant':
          case 'g\xE9ant':
            if (estGeant(target)) ennemiJure = true;
            break;
          case 'animal':
            if (estAnimal(target)) ennemiJure = true;
            break;
          case 'gobelin':
            if (estGobelin(target)) ennemiJure = true;
            break;
          default:
            if (raceIs(target, race)) ennemiJure = true;
        }
      });
    }
    if (ennemiJure) {
      let ejSag = modCarac(attaquant, 'sagesse');
      attBonus += ejSag;
      let explEnnemiJure = "Attaque sur ennemi jur\xE9 => +" + ejSag + " en attaque";
      if (!options.pasDeDmg) explEnnemiJure += " et +1d6 aux DM";
      if (options.aoe) explEnnemiJure += " contre " + target.tokName;
      explications.push(explEnnemiJure);
      target.ennemiJure = true;
    }
    if (options.armeDArgent) {
      if (estMortVivant(target) || estDemon(target)) {
        attBonus += 2;
        if (options.pasDeDmg)
          explications.push("Arme en argent => +2 en attaque");
        else
          explications.push("Arme en argent => +2 en attaque et +1d6 aux DM");
        target.armeDArgent = true;
      }
    }
    let bonusContreBouclier = options.bonusContreBouclier || 0;
    if (target.bonusContreBouclier) bonusContreBouclier += target.bonusContreBouclier;
    if (bonusContreBouclier) {
      if (ficheAttributeAsInt(target, 'defbouclieron', 0)) {
        attBonus += bonusContreBouclier;
        explications.push("L'adversaire porte un bouclier => " + ((bonusContreBouclier > 0) ? '+' : '') + bonusContreBouclier + " en attaque");
      }
    }
    if (options.tueurDeGeants && estGeant(target)) {
      attBonus += 2;
      if (options.pasDeDmg)
        explications.push("Tueur de g\xE9ant => +2 en Attaque");
      else
        explications.push("Tueur de g\xE9ant => +2 att. et 2d6 DM");
      target.tueurDeGeants = true;
    }
    let attrFeinte = tokenAttribute(target, 'feinte_' + attaquant.tokName);
    if (attrFeinte.length > 0 && attrFeinte[0].get('current')) {
      let bonusFeinte = predicateAsInt(attaquant, 'bonusFeinte', 5);
      attBonus += bonusFeinte;
      let msgFeinte = "Feinte => +" + bonusFeinte + " en attaque";
      let niveauTouche = attrFeinte[0].get('max');
      if (niveauTouche > 0) { //La feinte avait touch\xE9 cette cible
        let faireMouche = predicateAsInt(attaquant, 'faireMouche', 0);
        if (faireMouche > 0) {
          if (options.contact && !options.pasDeDmg) {
            target.faireMouche = faireMouche * niveauTouche;
            msgFeinte += " et peut faire mouche";
          }
        } else {
          let desFeinte = predicateAsInt(attaquant, 'nbDesFeinte', 2);
          desFeinte *= niveauTouche;
          target.feinte = desFeinte;
          if (!options.pasDeDmg) msgFeinte += " et +" + desFeinte + "d6 DM";
        }
      }
      explications.push(msgFeinte);
    }
    if (attributeAsBool(target, 'expose')) {
      var attrsExposeValeur = tokenAttribute(target, "exposeValeur");
      let expose = false;
      attrsExposeValeur.forEach(function testExpose(attr) {
        if (attr.get("current") == attaquant.token.id) expose = true;
      });
      if (expose) {
        attBonus += 10;
        explications.push("L'adversaire est expos\xE9 : +10");
      }
    }
    if (options.contact) {
      if ((attributeAsBool(target, 'criDeGuerre') ||
          attributeAsBool(target, 'criDuPredateur')) &&
        ficheAttributeAsInt(attaquant, 'force', 10) <= ficheAttributeAsInt(target, 'force', 10) &&
        parseInt(attaquant.token.get("bar1_max")) <= parseInt(target.token.get("bar1_max"))) {
        attBonus -= 2;
        explications.push("Effray\xE9 => -2 en Attaque");
      }
    }
    var attrAgrippe = tokenAttribute(attaquant, 'agrippe');
    attrAgrippe.forEach(function(a) {
      var cibleAgrippee = persoOfIdName(a.get('current'), pageId);
      if (cibleAgrippee && cibleAgrippee.id == target.id &&
        !attributeAsBool(cibleAgrippee, 'agrippeParUnDemon')) {
        attBonus += 5;
        if (options.pasDeDmg)
          explications.push("Cible agripp\xE9e => +5 em Attaque");
        else
          explications.push("Cible agripp\xE9e => +5 att. et 1d6 DM");
        target.estAgrippee = true;
      }
    });
    if (reglesOptionelles.divers.val.interchangeable_attaque.val) {
      if (interchangeable(target.token, attaquant, pageId).result) {
        attBonus += 3;
        explications.push("Attaque en meute => +3 en Attaque et +2 en DEF");
      }
    }
    if (predicateAsBool(attaquant, 'combatEnPhalange')) {
      let tokensContact = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        layer: 'objects'
      });
      //On compte tokens au contact de l'attaquant et du d\xE9fenseur et alli\xE9s de l'attaquant
      let allies = alliesParPerso[attaquant.charId];
      if (allies) {
        let alliesAuContact = 0;
        tokensContact.forEach(function(tok) {
          if (tok.id == attaquant.token.id) return;
          if (distanceCombat(target.token, tok, pageId) > 0) return;
          if (distanceCombat(attaquant.token, tok, pageId) > 0) return;
          let ci = tok.get('represents');
          if (ci === '') return;
          if (!isActive({
              token: tok,
              charId: ci
            })) return;
          if (allies.has(ci)) alliesAuContact++;
        });
        if (alliesAuContact > 0) {
          attBonus += alliesAuContact;
          explications.push("Combat en phalange => +" + alliesAuContact + " en Attaque");
        }
      }
    }
    if (options.attaqueEnMeute) {
      var attaqueParMeute = tokenAttribute(target, 'attaqueParMeute');
      if (attaqueParMeute.length > 0) {
        attaqueParMeute = attaqueParMeute[0];
        var attaqueParMeuteCur = attaqueParMeute.get('current');
        var contientAttaquant;
        var autreAttaquant;
        attaqueParMeuteCur.split(' ').forEach(function(mi) {
          if (mi == attaquant.token.id) {
            contientAttaquant = true;
            return;
          }
          autreAttaquant = true;
        });
        if (autreAttaquant) {
          attBonus += options.attaqueEnMeute;
          explications.push("Attaque en meute => +" + options.attaqueEnMeute + " pour toucher");
        }
        if (!contientAttaquant) {
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attaqueParMeute,
            current: attaqueParMeuteCur
          });
          if (attaqueParMeuteCur === '') attaqueParMeuteCur = attaquant.token.id;
          else attaqueParMeuteCur += ' ' + attaquant.token.id;
          attaqueParMeute.set('current', attaqueParMeuteCur);
        }
      } else {
        setTokenAttr(target, 'attaqueParMeute', attaquant.token.id, evt);
      }
    }
    let tm = stateCOF.tenebresMagiques;
    if (tm) {
      if (estDemon(attaquant)) {
        if (eclaireParFioleDeLumiere(attaquant, tm)) {
          explications.push("Aveugl\xE9 par la fiole de lumi\xE8re => -2 en Attaque");
          attBonus -= 2;
        }
      } else if (!eclaireParFioleDeLumiere(target, tm)) {
        var riposte;
        if (tm.attaques && tm.attaques[target.token.id]) {
          riposte = tm.attaques[target.token.id].some(function(cible) {
            return cible.token.id == attaquant.token.id;
          });
        }
        if (riposte) {
          explications.push("Riposte dans le noir => -2 en attaque et aux DMs");
          attBonus -= 2;
          target.attaqueDansLeNoir = 2;
        } else {
          explications.push("Attaque dans le noir => -5 en attaque et aux DMs");
          attBonus -= 5;
          target.attaqueDansLeNoir = 5;
        }

      }
    }
    if (predicateAsBool(attaquant, 'liberateurDeDorn') && estGeant(target)) {
      attBonus += 2;
      if (options.pasDeDmg) {
        explications.push("Lib\xE9rateur de Dorn => +2 en attaque");
      } else {
        explications.push("Lib\xE9rateur de Dorn => +2 en attaque et +2d6 DM");
        target.cibleLiberateurDeDorn = true;
      }
    }
    if (predicateAsBool(attaquant, 'liberateurDeKerserac') && (estGeant(target) || estInsecte(target) || estElfeNoir(target))) {
      attBonus += 2;
      if (options.pasDeDmg) {
        explications.push("Lib\xE9rateur de Kerserac => +2 en attaque");
      } else {
        explications.push("Lib\xE9rateur de Kerserac => +2 en attaque et +1d6 DM");
        target.cibleLiberateurDeKerserac = true;
      }
    }
    if (predicateAsBool(attaquant, 'liberateurDAnathazerin') && (estInsecte(target) || estElfeNoir(target))) {
      attBonus += 2;
      if (options.pasDeDmg) {
        explications.push("Lib\xE9rateur d'Anathazer\xEFn => +2 en attaque");
      } else {
        explications.push("Lib\xE9rateur d'Anathazer\xEFn => +2 en attaque et +2d6 DM");
        target.cibleLiberateurDAnathazerin = true;
      }
    }
    if (predicateAsBool(attaquant, 'tenacite')) {
      let bonus = attributeAsInt(target, 'attributDeCombat_tenaciteDe' + attaquant.tokName, 0);
      if (bonus > 0) {
        explications.push("T\xE9nacit\xE9 => +" + bonus + " en attaque");
        attBonus += bonus;
      }
    }
    let attrMeneurCible = tokenAttribute(target, 'meneurDHommesCible');
    if (attrMeneurCible.length > 0) {
      let meneurTokenId = attrMeneurCible[0].get('current');
      let meneurDHommes = persoOfId(meneurTokenId, meneurTokenId, pageId);
      if (meneurDHommes && alliesParPerso[meneurDHommes.charId] &&
        alliesParPerso[meneurDHommes.charId].has(attaquant.charId)) {
        attBonus += 2;
        if (!options.pasDeDmg) target.cibleMeneurDHommes = true;
        explications.push(meneurDHommes.token.get('name') + " a d\xE9sign\xE9 " + target.tokName +
          " comme la cible des attaques du groupe : +2 attaque, +1d6 DM");
      }
    }
    return attBonus;
  }

  function diminueMalediction(lanceur, evt, attr) {
    var attrMalediction = attr || tokenAttribute(lanceur, 'malediction');
    if (attrMalediction.length > 0) {
      attrMalediction = attrMalediction[0];
      var nbMaudit = parseInt(attrMalediction.get('current'));
      if (isNaN(nbMaudit) || nbMaudit < 2) {
        evt.deletedAttributes = evt.deletedAttributes || [];
        evt.deletedAttributes.push(attrMalediction);
        attrMalediction.remove();
      } else {
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attrMalediction,
          current: nbMaudit
        });
        attrMalediction.set('current', nbMaudit - 1);
      }
    }
  }

  function attributesOfClass(perso, classeEffet) {
    var attrs = findObjs({
      _type: 'attribute',
      _characterid: perso.charId
    });
    var res = [];
    attrs.forEach(function(attr) {
      var attrName = attr.get('name');
      var ice = attrName.indexOf('ClasseEffet');
      if (ice < 1) return;
      if (attr.get('current') == classeEffet) {
        var baseAttrName = attrName.replace(/ClasseEffet/, '');
        var baseAttr = attrs.find(function(a) {
          return (a.get('name') == baseAttrName);
        });
        if (baseAttr === undefined) {
          error("On a un attribut " + attrName + ", mais pas d'attribut " + baseAttrName + " pour " + perso.token.get('name'), classeEffet);
          attr.remove();
          return;
        }
        res.push({
          baseAttribute: baseAttr,
          classAttribute: attr
        });
      }
    });
    if (res.length === 0) {
      var ace = tokenAttribute(perso, classeEffet);
      if (ace.length > 0) {
        error(perso.token.get('name') + " a une classe d'effets " + classeEffet + " mais pas d'effet associ\xE9", ace);
        ace[0].remove();
      }
    }
    return res;
  }

  //Retourne true si il existe une limite qui emp\xEAche de lancer le sort
  //N'ajoute pas l'\xE9v\xE9nement \xE0 l'historique
  function limiteRessources(personnage, options, defResource, msg, evt, explications) {
    let depMana = {
      cout_null: true
    };
    if (options.magieEnArmureMana && personnage) {
      options.mana = options.mana || 0;
      let m = malusArmure(personnage);
      if (reglesOptionelles.mana.val.mana_totale.val) options.mana += m;
      //Le plus coh\xE9rent avec la mana totale consiste \xE0 diviser ce malus par 3,
      //arrondi au sup\xE9rieur
      else options.mana += Math.ceil(m / 3);
    }
    if (options.mana) {
      if (personnage) {
        depMana = depenseManaPossible(personnage, options.mana, msg);
        if (!depMana) return true;
      } else {
        error("Impossible de savoir qui doit d\xE9penser de la mana", options);
        return true;
      }
    }
    let ressource = '';
    if (defResource !== undefined) ressource = defResource;
    let utilisations;
    if (options.limiteParJour) {
      if (personnage) {
        if (options.limiteParJourRessource)
          ressource = "limiteParJour_" + options.limiteParJourRessource;
        else
          ressource = "limiteParJour_" + defResource;
        utilisations =
          attributeAsInt(personnage, ressource, options.limiteParJour);
        if (utilisations === 0) {
          sendPerso(personnage, "ne peut plus faire cette action aujourd'hui", options.secret);
          return true;
        }
        setTokenAttr(personnage, ressource, utilisations - 1, evt);
        if (options.limiteParJourRessource) {
          let msgJour = personnage.token.get('name') + " ";
          if (utilisations < 2) msgJour += "ne pourra plus utiliser ";
          else {
            msgJour += "pourra encore utiliser ";
            if (utilisations == 2) msgJour += "une fois ";
            else msgJour += (utilisations - 1) + " fois ";
          }
          msgJour += options.limiteParJourRessource + " aujourd'hui.";
          if (explications) {
            stateCOF.afterDisplay = stateCOF.afterDisplay || [];
            stateCOF.afterDisplay.push({
              msg: msgJour,
              destinataire: personnage
            });
          } else sendPerso(personnage, msgJour, true);
        }
      } else {
        error("Impossible de savoir \xE0 qui appliquer la limite journali\xE8re", options);
        return true;
      }
    }
    if (options.limiteParCombat) {
      if (personnage) {
        if (!stateCOF.combat) {
          sendPerso(personnage, "ne peut pas faire cette action en dehors des combats", options.secret);
          return true;
        }
        if (options.limiteParCombatRessource)
          ressource = "limiteParCombat_" + options.limiteParCombatRessource;
        else
          ressource = "limiteParCombat_" + defResource;
        utilisations =
          attributeAsInt(personnage, ressource, options.limiteParCombat);
        if (utilisations === 0) {
          let msgToSend = "ne peut plus faire cette action pour ce combat";
          sendPerso(personnage, msgToSend, options.secret);
          return true;
        }
        setTokenAttr(personnage, ressource, utilisations - 1, evt);
        if (options.limiteParCombatRessource) {
          let msgCombat = personnage.token.get('name') + " ";
          if (utilisations < 2) msgCombat += "ne pourra plus utiliser ";
          else {
            msgCombat += "pourra encore utiliser ";
            if (utilisations == 2) msgCombat += "une fois ";
            else msgCombat += (utilisations - 1) + " fois ";
          }
          msgCombat += options.limiteParCombatRessource + " durant ce combat.";
          if (explications) {
            stateCOF.afterDisplay = stateCOF.afterDisplay || [];
            stateCOF.afterDisplay.push({
              msg: msgCombat,
              destinataire: personnage
            });
          } else sendPerso(personnage, msgCombat, true);
        }
      } else {
        error("Impossible de savoir \xE0 qui appliquer la limite par combat", options);
        return true;
      }
    }
    if (options.limiteParTour) {
      if (personnage) {
        if (!stateCOF.combat) {
          sendPerso(personnage, "ne peut pas faire cette action en dehors des combats", options.secret);
          return true;
        }
        if (options.limiteParTourRessource)
          ressource = "limiteParTour_" + options.limiteParTourRessource;
        else
          ressource = "limiteParTour_" + defResource;
        utilisations = attributeAsInt(personnage, ressource, options.limiteParTour);
        if (utilisations === 0) {
          let msgToSend = "ne peut plus faire cette action pour ce tour";
          sendPerso(personnage, msgToSend, options.secret);
          return true;
        }
        setTokenAttr(personnage, ressource, utilisations - 1, evt);
        if (options.limiteParTourRessource) {
          let msgCombat = personnage.token.get('name') + " ";
          if (utilisations < 2) msgCombat += "ne pourra plus utiliser ";
          else {
            msgCombat += "pourra encore utiliser ";
            if (utilisations == 2) msgCombat += "une fois ";
            else msgCombat += (utilisations - 1) + " fois ";
          }
          msgCombat += options.limiteParTourRessource + " durant ce tour.";
          if (explications) {
            stateCOF.afterDisplay = stateCOF.afterDisplay || [];
            stateCOF.afterDisplay.push({
              msg: msgCombat,
              destinataire: personnage
            });
          } else sendPerso(personnage, msgCombat, options.secret);
        }
      } else {
        error("Impossible de savoir \xE0 qui appliquer la limite par tour", options);
        return true;
      }
    }
    if (options.dose) {
      if (personnage) {
        let nomDose = options.dose.replace(/_/g, ' ');
        let doses = attributeAsInt(personnage, 'dose_' + options.dose, 0);
        if (doses === 0) {
          sendPerso(personnage, "n'a plus de " + nomDose, options.secret);
          return true;
        }
        setTokenAttr(personnage, 'dose_' + options.dose, doses - 1, evt);
      } else {
        error("Impossible de savoir qui doit d\xE9penser la dose", options);
        return true;
      }
    }
    if (options.limiteAttribut) {
      if (personnage) {
        let nomAttr = options.limiteAttribut.nom;
        let currentAttr = attributeAsInt(personnage, nomAttr, 0);
        if (currentAttr >= options.limiteAttribut.limite) {
          if (options.depasseLimite) {
            options.mana = options.mana || 0;
            let cout = options.depasseLimite;
            let step = cout;
            let depasseAttr = tokenAttribute(personnage, 'depasse' + nomAttr);
            if (depasseAttr.length > 0) {
              depasseAttr = depasseAttr[0];
              cout = parseInt(depasseAttr.get('current'));
              if (isNaN(cout) || cout < 1) cout = 1;
              step = parseInt(depasseAttr.get('max'));
              if (isNaN(step) || step < 1) step = 1;
              evt.attributes = evt.attributes || [];
              evt.attributes.push({
                attribute: depasseAttr,
                current: cout
              });
            } else {
              depasseAttr = setTokenAttr(personnage, 'depasse' + nomAttr, cout, evt, {
                maxVal: cout
              });
            }
            options.mana += cout;
            depMana = depenseManaPossible(personnage, options.mana, msg);
            if (!depMana) return true;
            depasseAttr.set('current', cout + step);
          } else {
            sendPerso(personnage, options.limiteAttribut.message, options.secret);
            return true;
          }
        }
        setTokenAttr(personnage, nomAttr, currentAttr + 1, evt);
      } else {
        error("Impossible de savoir \xE0 qui appliquer la limitation", options);
        return true;
      }
    }
    if (options.decrAttribute) {
      let attr = getObj('attribute', options.decrAttribute);
      if (attr === undefined) {
        error("Attribut introuvable", options.decrAttribute);
        return true;
      }
      var oldval = parseInt(attr.get('current'));
      if (isNaN(oldval) || oldval < 1) {
        var expliquer = sendChar;
        if (options.secret) expliquer = whisperChar;
        expliquer(attr.get('characterid'), "ne peut plus faire cela", true);
        return true;
      }
      evt.attributes = evt.attributes || [];
      evt.attributes.push({
        attribute: attr,
        current: oldval,
        max: attr.get('max')
      });
      attr.set('current', oldval - 1);
    }
    if (options.decrLimitePredicatParTour) {
      let pred = options.decrLimitePredicatParTour;
      if (personnage) {
        let test = testLimiteUtilisationsCapa(personnage, pred, 'tour',
          "ne peut plus utiliser " + pred + " ce tour",
          "Action impossible, pas de pr\xE9dicat " + pred);
        if (test === undefined) return true;
        utiliseCapacite(personnage, test, evt);
      } else {
        error("Impossible de savoir \xE0 qui appliquer la limitation du pr\xE9dicat " + pred, options);
        return true;
      }
    }
    if (personnage) depenseMana(personnage, depMana, msg, evt);
    return false;
  }

  //asynchrone
  //callback(resultat, crit, roll1, roll2):
  // resultat peut \xEAtre 0, 1 ou 2 : 0 = match null, 1 le perso 1 gagne, 2 le perso 2 gagne.
  // crit peut \xEAtre 1 si un des deux perso a fait une r\xE9ussite critique et pas l'autre, -1 si un des personnage a fait un \xE9chec critique et pas l'autre, et 0 sinon
  function testOppose(rollId, perso1, carac1, options1, perso2, carac2, options2, explications, evt, callback) {
    if (carac2 === undefined) carac2 = carac1;
    var nom1 = perso1.token.get('name');
    var nom2 = perso2.token.get('name');
    jetCaracteristique(perso1, carac1, options1, rollId + "_roll1", evt, function(rt1, expl1) {
      jetCaracteristique(perso2, carac2, options2, rollId + "_roll2", evt, function(rt2, expl2) {
        var reussite;
        var crit = 0;
        if (rt1.total > rt2.total) reussite = 1;
        else if (rt2.total > rt1.total) reussite = 2;
        else reussite = 0;
        if (rt1.echecCritique) {
          if (!rt2.echecCritique) {
            reussite = 2;
            crit = -1;
          }
        } else if (rt2.echecCritique) {
          reussite = 1;
          crit = -1;
        } else if (rt1.critique) {
          if (!rt2.critique) {
            reussite = 1;
            crit = 1;
          }
        } else if (rt2.critique) {
          reussite = 2;
          crit = 1;
        }
        switch (reussite) {
          case 1:
            diminueMalediction(perso2, evt);
            break;
          case 2:
            diminueMalediction(perso1, evt);
            break;
        }
        let texte1 = "Jet de " + carac1 + " de " + nom1 + " : " + rt1.texte;
        if (reussite == 2) {
          if ((carac1 == 'FOR' || carac1 == 'DEX' || carac1 == 'CON') &&
            attributeAsBool(perso1, 'runeForgesort_\xE9nergie') &&
            attributeAsInt(perso1, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0) {
            texte1 += "<br/>" + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + rollId + "_roll1", "Rune d'\xE9nergie");
          }
          if (!rt1.echecCritique && !rt2.critique) {
            let pcPerso1 = pointsDeChance(perso1);
            if (pcPerso1 > 0)
              texte1 += "<br/>" + boutonSimple("!cof-bouton-chance " +
                evt.id + " " + rollId + "_roll1", "Chance") + " (reste " + pcPerso1 + " PC)";
            if (stateCOF.combat && capaciteDisponible(perso1, 'prouesse', 'tour') &&
              (carac1 == 'FOR' || carac1 == 'DEX')) {
              texte1 += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + rollId + "_roll1", "Prouesse");
            }
            if (predicateAsBool(perso1, 'tourDeForce') && carac1 == 'FOR') {
              texte1 += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + rollId + "_roll1", "Tour de force");
            }
            let pacteSanglant = predicateAsInt(perso1, 'pacteSanglant', 0);
            if (pacteSanglant >= 3) {
              texte1 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + rollId + "_roll1", "Pacte sanglant (+3)");
              if (pacteSanglant >= 5) {
                texte1 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + rollId + "_roll1", "Pacte sanglant (+5)");
              }
            }
          }
        }
        explications.push(texte1);
        expl1.forEach(function(m) {
          explications.push(m);
        });
        let texte2 = "Jet de " + carac2 + " de " + nom2 + " : " + rt2.texte;
        if (reussite == 1) {
          if ((carac2 == 'FOR' || carac2 == 'DEX' || carac2 == 'CON') &&
            attributeAsBool(perso2, 'runeForgesort_\xE9nergie') &&
            attributeAsInt(perso2, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0) {
            texte2 += "<br/>" + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + rollId + "_roll2", "Rune d'\xE9nergie");
          }
          if (!rt2.echecCritique && !rt1.critique) {
            let pcPerso2 = pointsDeChance(perso2);
            if (pcPerso2 > 0)
              texte2 += "<br/>" + boutonSimple("!cof-bouton-chance " +
                evt.id + " " + rollId + "_roll2", "Chance") + " (reste " + pcPerso2 + " PC)";
            if (stateCOF.combat && capaciteDisponible(perso2, 'prouesse', 'tour') &&
              (carac2 == 'FOR' || carac2 == 'DEX')) {
              texte2 += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + rollId + "_roll2", "Prouesse");
            }
            if (predicateAsBool(perso2, 'tourDeForce') && carac2 == 'FOR') {
              texte2 += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + rollId + "_roll2", "Tour de force");
            }
            let pacteSanglant = predicateAsInt(perso2, 'pacteSanglant', 0);
            if (pacteSanglant >= 3) {
              texte2 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + rollId + "_roll2", "Pacte sanglant (+3)");
              if (pacteSanglant >= 5) {
                texte2 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + rollId + "_roll2", "Pacte sanglant (+5)");
              }
            }
          }
        }
        explications.push(texte2);
        expl2.forEach(function(m) {
          explications.push(m);
        });
        callback(reussite, crit, rt1.roll, rt2.roll);
      }); //Fin du jet du deuxi\xE8me perso
    }); //Fin du jet du premier perso
  }

  //renvoie le nom de l'arme si l'arme est d\xE9j\xE0 tenue en main
  // options.seulementDroite permet de ne rengainer que l'arme droite
  function degainerArme(perso, labelArme, evt, options) {
    let pageId = perso.pageId;
    if (pageId === undefined) {
      pageId = perso.token.get('pageid');
      perso.pageId = pageId;
    }
    options = options || {};
    let nouvelleArme;
    if (options.weaponStats) nouvelleArme = options.weaponStats;
    else if (labelArme && labelArme !== '') nouvelleArme = getWeaponStats(perso, labelArme);
    if (nouvelleArme && nouvelleArme.armeGauche) options.gauche = true;
    //D'abord, on rengaine l'arme en main, si besoin.
    let armeActuelle = tokenAttribute(perso, 'armeEnMain');
    let labelArmeActuelle;
    let labelArmeActuelleGauche = '';
    let ancienneArme;
    let message = perso.token.get('name') + " ";
    if (armeActuelle.length > 0) {
      armeActuelle = armeActuelle[0];
      if (options.gauche) labelArmeActuelleGauche = armeActuelle.get('max');
      else {
        labelArmeActuelle = armeActuelle.get('current');
        labelArmeActuelleGauche = armeActuelle.get('max');
      }
      if (labelArmeActuelle == labelArme ||
        (options.gauche && labelArmeActuelleGauche == labelArme)) {
        //Pas besoin de d\xE9gainer. Pas de message ?
        if (options.weaponStats) return options.weaponStats.name;
        if (nouvelleArme) return nouvelleArme.name;
        return;
      }
      //On d\xE9gaine une nouvelle arme
      if (labelArmeActuelle) {
        ancienneArme = getWeaponStats(perso, labelArmeActuelle);
        if (ancienneArme === undefined) {
          error("Impossible de trouver l'arme en main", labelArmeActuelle);
          return;
        }
        if (attributeAsBool(perso, 'forgeron(' + labelArmeActuelle + ')')) {
          finDEffetDeNom(perso, 'forgeron(' + labelArmeActuelle + ')', evt);
        }
        if (ancienneArme.bonusDef) {
          var attrBonusDef = tokenAttribute(perso, 'armeBonusDef');
          if (attrBonusDef.length > 0) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(attrBonusDef[0]);
            attrBonusDef[0].remove();
          }
        }
        if (options.messages) message += "rengaine " + ancienneArme.name + " et ";
        else sendPerso(perso, "rengaine " + ancienneArme.name, options.secret);
        if (predicateAsInt(perso, "initEnMain" + labelArmeActuelle, 0) > 0)
          updateNextInit(perso);
        if (predicateAsBool(perso, 'eclaire_' + labelArmeActuelle)) {
          eteindreUneLumiere(perso, pageId, undefined, 'eclaire_' + labelArmeActuelle, evt);
        }
      }
      if ((!nouvelleArme || nouvelleArme.deuxMains || options.gauche) &&
        labelArmeActuelleGauche) {
        let ancienneArmeGauche = getWeaponStats(perso, labelArmeActuelleGauche);
        if (ancienneArmeGauche === undefined) {
          error("Impossible de trouver l'arme en main gauch", labelArmeActuelleGauche);
          return;
        }
        if (attributeAsBool(perso, 'forgeron(' + labelArmeActuelleGauche + ')')) {
          finDEffetDeNom(perso, 'forgeron(' + labelArmeActuelleGauche + ')', evt);
        }
        if (ancienneArmeGauche.bonusDef) {
          var attrBonusDefGauche = tokenAttribute(perso, 'armeGaucheBonusDef');
          if (attrBonusDefGauche.length > 0) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(attrBonusDefGauche[0]);
            attrBonusDefGauche[0].remove();
          }
        }
        if (options.messages) {
          if (ancienneArme) message += ancienneArmeGauche.name + " et ";
          else message += "rengaine " + ancienneArmeGauche.name + " et ";
        } else sendPerso(perso, "rengaine " + ancienneArmeGauche.name, options.secret);
        if (predicateAsBool(perso, 'eclaire_' + labelArmeActuelleGauche)) {
          eteindreUneLumiere(perso, pageId, undefined, 'eclaire_' + labelArmeActuelleGauche, evt);
        }
      }
    } else armeActuelle = undefined;
    //Puis on d\xE9gaine
    //mais on v\xE9rifie que l'arme existe, sinon c'est juste un ordre de rengainer
    if (nouvelleArme === undefined) {
      if (armeActuelle) {
        if (options.seulementDroite && labelArmeActuelleGauche) {
          setTokenAttr(perso, 'armeEnMain', '', evt);
        } else if (options.gauche && labelArmeActuelle) {
          setTokenAttr(perso, 'armeEnMain', labelArmeActuelle, evt, {
            maxVal: ''
          });
        } else {
          removeTokenAttr(perso, 'armeEnMain', evt);
        }
      }
      return;
    }
    if (nouvelleArme.bonusDef) {
      if (nouvelleArme.armeGauche) {
        setTokenAttr(perso, 'armeGaucheBonusDef', nouvelleArme.bonusDef, evt);
      } else {
        setTokenAttr(perso, 'armeBonusDef', nouvelleArme.bonusDef, evt);
      }
    }
    if (nouvelleArme.deuxMains) {
      if (ficheAttributeAsInt(perso, 'defbouclieron', 0)) {
        sendPerso(perso, "enl\xE8ve son bouclier", options.secret);
        setFicheAttr(perso, 'defbouclieron', 0, evt);
      }
    } else if (ancienneArme && (ancienneArme.deuxMains || options.gauche)) {
      if (ficheAttributeAsBool(perso, 'defbouclier', false) &&
        !ficheAttributeAsInt(perso, 'defbouclieron', 0)) {
        sendPerso(perso, "remet son bouclier", options.secret);
        setFicheAttr(perso, 'defbouclieron', 1, evt);
      }
    }
    if (armeActuelle) { //On avait une arme en main
      evt.attributes = evt.attributes || [];
      let evtAttr = {
        attribute: armeActuelle,
      };
      if (options.gauche) {
        evtAttr.current = armeActuelle.get('current');
        evtAttr.max = labelArmeActuelle;
        evt.attributes.push(evtAttr);
        armeActuelle.set('max', labelArme);
      } else {
        evtAttr.current = labelArmeActuelle;
        evtAttr.max = labelArmeActuelleGauche;
        evt.attributes.push(evtAttr);
        armeActuelle.set('current', labelArme);
      }
    } else { //On n'avait pas d'arme en main
      if (stateCOF.combat && nouvelleArme && nouvelleArme.portee === 0 &&
        predicateAsBool(perso, 'frappeDuVide') &&
        !attributeAsBool(perso, 'limiteParCombat_dejaFrappeContact')) {
        setTokenAttr(perso, 'limiteParTour_frappeDuVidePossible', true, evt);
      }
      if (options.gauche) {
        setTokenAttr(perso, 'armeEnMain', '', evt, {
          maxVal: labelArme
        });
      } else {
        setTokenAttr(perso, 'armeEnMain', labelArme, evt);
      }
    }
    if (options.messages) {
      message += "d\xE9gaine " + nouvelleArme.name;
      options.messages.push(message);
    } else sendPerso(perso, "d\xE9gaine " + nouvelleArme.name, options.secret);
    let eclaire = 'eclaire_' + labelArme;
    let radius = predicateAsInt(perso, eclaire, 0);
    if (radius > 0) {
      let dimRadius = predicateAsInt(perso, 'eclaireFaible_' + labelArme, radius);
      if (dimRadius >= radius) dimRadius = '';
      ajouteUneLumiere(perso, eclaire, radius, dimRadius, evt);
    }
    if (predicateAsInt(perso, "initEnMain" + labelArme, 0) > 0)
      updateNextInit(perso);
  }

  //targetToken est soit un token, soit une structure avec un champs cibles qui contient toutes les cibles
  function attack(playerName, playerId, attaquant, targetToken, weaponStats, options) {
    // Attacker and target infos
    let attackingToken = attaquant.token;
    let attackingCharId = attaquant.charId;
    attaquant.tokName = attaquant.tokName || attaquant.token.get("name");
    let attacker = getObj("character", attackingCharId);
    if (attacker === undefined) {
      error("Unexpected undefined 1", attacker);
      return;
    }
    attaquant.name = attaquant.name || attacker.get("name");
    let pageId = attaquant.token.get('pageid');
    let weaponName = options.nom || weaponStats.name;
    //Options automatically set by some attributes
    if (attributeAsBool(attaquant, 'paralysieRoublard')) {
      if (attributeAsBool(attaquant, 'enrage')) {
        sendPerso(attaquant, "est trop enrag\xE9 pour sentir la douleur");
      } else if (predicateAsBool(attaquant, 'proprioception')) {
        sendPerso(attaquant, "est immunis\xE9 \xE0 la douleur");
      } else {
        sendPerso(attaquant, "ne peut pas attaquer car il est paralys\xE9 de douleur");
        return;
      }
    }
    let deFauchage = predicateAsInt(attaquant, 'fauchage', 0, 15);
    if (!options.redo && deFauchage > 0) {
      let tailleFauchage = predicateAsInt(attaquant, 'tailleFauchage', 0);
      if (tailleFauchage < 1)
        tailleFauchage = taillePersonnage(attaquant, 4);
      let seuilFauchage = 10 + modCarac(attaquant, 'force');
      options.etats = options.etats || [];
      options.etats.push({
        etat: 'renverse',
        condition: {
          type: 'deAttaque',
          seuil: deFauchage
        },
        save: {
          carac: 'FOR',
          carac2: 'DEX',
          seuil: seuilFauchage,
          fauchage: tailleFauchage
        }
      });
    }
    if (options.toucher !== undefined) {
      weaponStats.attSkill = options.toucher;
      weaponStats.attSkillDiv = 0;
    }
    if (options.crit !== undefined) {
      weaponStats.crit = options.crit;
    }
    if (options.dm) {
      weaponStats.attNbDices = options.dm.nbDe;
      weaponStats.attDice = options.dm.dice;
      weaponStats.attDMBonusCommun = options.dm.bonus;
    }
    if (options.portee !== undefined) {
      weaponStats.portee = options.portee;
    }
    if (options.divisePortee) {
      weaponStats.portee /= options.divisePortee;
    }
    if (options.modifiePortee) {
      weaponStats.portee += options.modifiePortee;
    }
    if (weaponStats.epieu) {
      options.epieu = true;
    }
    weaponStats.attSkillDiv = parseInt(weaponStats.attSkillDiv);
    weaponStats.attNbDices = parseInt(weaponStats.attNbDices);
    weaponStats.attDice = parseInt(weaponStats.attDice);
    options.d6 = 'd6';
    if (predicateAsBool(attaquant, 'tropPetit')) {
      options.d6 = 'd4';
      if (weaponStats.divers && weaponStats.divers.includes('d3')) {
        weaponStats.attDice = 3;
      }
    }
    weaponStats.attDMBonusCommun = parseInt(weaponStats.attDMBonusCommun);
    weaponStats.crit = parseInt(weaponStats.crit);
    let portee = weaponStats.portee;
    if (options.tirDouble && options.tirDouble.label) {
      let stats2 = getWeaponStats(attaquant, options.tirDouble.label);
      if (stats2 === undefined) {
        error("Pas d'arme de label " + options.tirDouble.label + " pour le tir double", attaquant);
        return;
      }
      let tdSkillDiv = parseInt(stats2.attSkillDiv);
      if (!isNaN(tdSkillDiv) && tdSkillDiv < weaponStats.attSkillDiv)
        weaponStats.attSkillDiv = tdSkillDiv;
      stats2.attDMBonusCommun = parseInt(stats2.attDMBonusCommun);
      stats2.attNbDices = parseInt(stats2.attNbDices);
      stats2.attDice = parseInt(stats2.attDice);
      if (stats2.divers && stats2.divers.includes('d3')) stats2.attDice = 3;
      options.tirDouble.stats = stats2;
    }
    //Pour les explosions, la port\xE9e est 0 mais avec un disque
    if (options.explosion) {
      if (options.aoe === undefined) {
        options.aoe = {
          type: 'disque',
          rayon: portee
        };
      } else if (options.aoe.type != 'disque') {
        error("Option explosion ignor\xE9e, car l'attaque est une aoe qui n'est pas un disque", options);
      }
    }
    if (portee > 0) {
      options.distance = true;
      if (attributeAsBool(attaquant, 'rageDuBerserk')) {
        sendPerso(attaquant, "est en rage du berserk, il ne veut attaquer qu'au contact");
        return;
      }
      if (options.puissantPortee || options.tempeteDeManaPortee) {
        portee = portee * 2;
        weaponStats.portee = portee;
      }
    } else {
      options.contact = true;
    }
    //Pour l'option grenaille implicite, il faut v\xE9rifier que toutes les charge de l'arme sont des charges de grenaille
    let chargesArme = [];
    let attackLabel = weaponStats.label;
    if (attackLabel) {
      chargesArme = findObjs({
        _type: 'attribute',
        _characterid: attackingCharId,
        name: "charge_" + attackLabel
      });
      if (!options.grenaille && chargesArme.length > 0) {
        let chargesGrenaille = findObjs({
          _type: 'attribute',
          _characterid: attackingCharId,
          name: "chargeGrenaille_" + attackLabel
        });
        if (chargesGrenaille.length > 0) {
          let chargesTotales = parseInt(chargesArme[0].get('current'));
          if (!isNaN(chargesTotales)) {
            let grenailles = parseInt(chargesGrenaille[0].get('current'));
            if (!isNaN(grenailles) && grenailles >= chargesTotales)
              options.grenaille = true;
          }
        }
      }
    }
    if (options.grenaille) {
      portee = portee / 10;
      options.aoe = options.aoe || {
        type: 'cone',
        angle: 90
      };
      weaponStats.attDice -= 2;
      weaponStats.attDMBonusCommun = Math.ceil(weaponStats.attDMBonusCommun / 2);
      if (weaponStats.attDice < 0) weaponStats.attDice = 0;
      if (options.tirDouble && options.tirDouble.stats) {
        options.tirDouble.stats.attDice -= 2;
        if (options.tirDouble.stats.attDice < 0) options.tirDouble.stats.attDice = 0;
      }
      options.auto = true;
      let effet = findObjs({
        _type: 'custfx',
        name: 'grenaille ' + portee
      });
      if (effet.length === 0) {
        effet = createObj('custfx', {
          name: 'grenaille ' + portee,
          definition: {
            "angle": -1,
            "angleRandom": 45,
            "duration": 8,
            "emissionRate": 40,
            "endColour": [130, 130, 130, 0],
            "endColourRandom": [10, 10, 10, 0],
            "lifeSpan": portee * 5,
            "lifeSpanRandom": portee / 2,
            "maxParticles": 200,
            "size": 10,
            "sizeRandom": 3,
            "speed": 12,
            "speedRandom": 3,
            "startColour": [25, 25, 25, 1],
            "startColourRandom": [7, 7, 7, 0.5]
          }
        });
      } else effet = effet[0];
      options.fx = options.fx || effet.id;
    }
    //D\xE9termination de la (ou des) cible(s)
    let nomCiblePrincipale; //Utilise pour le cas mono-cible
    let cibles = [];
    if (options.redo) { //Dans ce cas les cibles sont pr\xE9cis\xE9es dans targetToken
      cibles = targetToken;
      if (cibles.length === 0) {
        error("Attaque sans cible", targetToken);
        return;
      } else if (cibles.length == 1) targetToken = cibles[0].token;
      nomCiblePrincipale = cibles[0].tokName;
    } else {
      let murs;
      let pc;
      let page;
      nomCiblePrincipale = targetToken.get('name');
      if (options.aoe) {
        //cas de la boule de feu qui fait un \xE9chec critique : on d\xE9place la cible si elle est artificielle
        if (!options.redo && options.demiAuto &&
          (!options.triche || options.triche == 'echecCritique') &&
          targetToken.get('bar1_max') == 0) { // jshint ignore:line
          let dice = 20;
          if (options.avecd12 ||
            (estAffaibli(attaquant) && !predicateAsBool(attaquant, 'insensibleAffaibli')) ||
            getState(attaquant, 'immobilise') ||
            attributeAsBool(attaquant, 'mortMaisNAbandonnePas') ||
            attributeAsInt(attaquant, 'niveauEbriete', 0) > 0
          ) {
            dice = 12;
          }
          if (randomInteger(dice) == 1 ||
            (options.triche && options.triche == 'echecCritique')) {
            options.triche = 'echecCritique';
            let left = targetToken.get('left');
            let top = targetToken.get('top');
            pc = {
              x: left,
              y: top,
            };
            let angle = Math.random() * 2 * Math.PI;
            let distance = Math.random() * reglesOptionelles.divers.val.echec_critique_boule_de_feu.val * PIX_PER_UNIT / computeScale(pageId);
            pc.x = Math.round(left + Math.cos(angle) * distance);
            pc.y = Math.round(top + Math.sin(angle) * distance);
            page = page || getObj("page", pageId);
            let width = page.get('width') * PIX_PER_UNIT;
            let height = page.get('height') * PIX_PER_UNIT;
            if (pc.x < 0) pc.x = 0;
            if (pc.y < 0) pc.y = 0;
            if (pc.x > width) pc.y = width;
            if (pc.y > height) pc.y = height;
            murs = getWalls(page, pageId, murs);
            if (murs) {
              if (obstaclePresent(left, top, pc, murs)) {
                angle = Math.random() * 2 * Math.PI;
                distance = (Math.random() * reglesOptionelles.divers.val.echec_critique_boule_de_feu.val * PIX_PER_UNIT / computeScale(pageId)) / 2;
                pc.x = Math.round(left + Math.cos(angle) * distance);
                pc.y = Math.round(top + Math.sin(angle) * distance);
                if (pc.x < 0) pc.x = 0;
                if (pc.y < 0) pc.y = 0;
                if (pc.x > width) pc.y = width;
                if (pc.y > height) pc.y = height;
                if (obstaclePresent(left, top, pc, murs)) {
                  pc.x = left;
                  pc.y = top;
                }
              }
            }
            targetToken.set('left', pc.x);
            targetToken.set('top', pc.y);
          } else {
            if (options.triche === undefined) options.triche = 'pasDEchecCritique';
          }
        }
        if (options.targetFx) {
          spawnFx(targetToken.get('left'), targetToken.get('top'), options.targetFx, pageId);
        }
        if (options.dmCible) {
          options.dmCible.target = targetToken;
        }
        let distanceTarget =
          distanceCombat(targetToken, attackingToken, pageId, {
            strict1: true,
            strict2: true
          });
        let pta = tokenCenter(attackingToken);
        let ptt = tokenCenter(targetToken);
        switch (options.aoe.type) {
          case 'ligne':
            if (distanceTarget < portee) { //la ligne va plus loin que la cible
              let scale = portee * 1.0 / distanceTarget;
              ptt = [
                Math.round((ptt[0] - pta[0]) * scale) + pta[0],
                Math.round((ptt[1] - pta[1]) * scale) + pta[1]
              ];
            }
            if (targetToken.get('bar1_max') == 0) { // jshint ignore:line
              //C'est juste un token utilis\xE9 pour d\xE9finir la ligne
              if (options.fx) {
                let p1e = {
                  x: attackingToken.get('left'),
                  y: attackingToken.get('top'),
                };
                let p2e = {
                  x: targetToken.get('left'),
                  y: targetToken.get('top'),
                };
                spawnFxBetweenPoints(p1e, p2e, options.fx, pageId);
              }
              cibles = [];
              targetToken.remove(); //On l'enl\xE8ve, normalement plus besoin
            }
            let allToks =
              findObjs({
                _type: 'graphic',
                _pageid: pageId,
                _subtype: 'token',
                layer: 'objects'
              });
            allToks.forEach(function(obj) {
              if (obj.id == attackingToken.id) return; //on ne se cible pas
              let objCharId = obj.get('represents');
              if (objCharId === '') return;
              let cible = {
                token: obj,
                charId: objCharId
              };
              if (getState(cible, 'mort')) return; //pas de d\xE9g\xE2ts aux morts
              let pt = tokenCenter(obj);
              let distToTrajectory = VecMath.ptSegDist(pt, pta, ptt);
              if (distToTrajectory > (obj.get('width') + obj.get('height')) / 4 + PIX_PER_UNIT / 4)
                return;
              cible.tokName = obj.get('name');
              let objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              cible.name = objChar.get('name');
              cibles.push(cible);
            });
            break;
          case 'disque':
            if (distanceTarget > portee) {
              sendPlayer(playerName,
                "Le centre du disque vis\xE9 est trop loin pour " + weaponName +
                " (distance " + distanceTarget + ", port\xE9e " + portee + ")",
                playerId);
              return;
            }
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            if (murs) {
              pc = {
                x: ptt[0],
                y: ptt[1],
              };
            }
            let allToksDisque =
              findObjs({
                _type: "graphic",
                _pageid: pageId,
                _subtype: "token",
                layer: "objects"
              });
            allToksDisque.forEach(function(obj) {
              if ((options.explosion || portee === 0) &&
                obj.id == attackingToken.id) return; //on ne se cible pas si le centre de l'aoe est soi-m\xEAme
              if (obj.get('bar1_max') == 0) return; // jshint ignore:line
              let objCharId = obj.get('represents');
              if (objCharId === '') return;
              let cible = {
                token: obj,
                charId: objCharId
              };
              if (getState(cible, 'mort')) return; //pas de d\xE9g\xE2ts aux morts
              let distanceCentre =
                distanceCombat(targetToken, obj, pageId, {
                  strict1: true
                });
              if (distanceCentre > options.aoe.rayon) return;
              let objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              if (murs) {
                if (obstaclePresent(obj.get('left'), obj.get('top'), pc, murs)) return;
              }
              cible.name = objChar.get('name');
              cible.tokName = obj.get('name');
              cibles.push(cible);
            });
            if (targetToken.get('bar1_max') == 0) { // jshint ignore:line
              //C'est juste un token utilis\xE9 pour d\xE9finir le disque
              targetToken.remove(); //On l'enl\xE8ve, normalement plus besoin
            }
            // La nouvelle port\xE9e (pour ne rien \xE9liminer \xE0 l'\xE9tape suivante
            portee += options.aoe.rayon;
            break;
          case 'cone':
            if (options.fx) {
              var p1eC = {
                x: attackingToken.get('left'),
                y: attackingToken.get('top'),
              };
              var p2eC = {
                x: targetToken.get('left'),
                y: targetToken.get('top'),
              };
              spawnFxBetweenPoints(p1eC, p2eC, options.fx, pageId);
            }
            var vecCentre = VecMath.normalize(VecMath.vec(pta, ptt));
            var cosAngle = Math.cos(options.aoe.angle * Math.PI / 360.0);
            //Pour \xE9viter des artfacts d'arrondi:
            cosAngle = (Math.floor(cosAngle * 1000000)) / 1000000;
            if (targetToken.get('bar1_max') == 0) { // jshint ignore:line
              //C'est juste un token utilis\xE9 pour d\xE9finir le cone
              cibles = [];
              targetToken.remove(); //On l'enl\xE8ve, normalement plus besoin
            }
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            if (murs) {
              pc = {
                x: pta[0],
                y: pta[1],
              };
            }
            var allToksCone =
              findObjs({
                _type: "graphic",
                _pageid: pageId,
                _subtype: "token",
                layer: "objects"
              });
            allToksCone.forEach(function(obj) {
              if (obj.id == attackingToken.id) return; //on ne se cible pas
              var objCharId = obj.get('represents');
              if (objCharId === '') return;
              var cible = {
                token: obj,
                charId: objCharId
              };
              if (getState(cible, 'mort')) return; //pas de d\xE9g\xE2ts aux morts
              var pt = tokenCenter(obj);
              var vecObj = VecMath.normalize(VecMath.vec(pta, pt));
              if (VecMath.dot(vecCentre, vecObj) < cosAngle) return;
              // La distance sera compar\xE9e \xE0 la port\xE9e plus loin
              var objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              if (murs) {
                if (obstaclePresent(pt[0], pt[1], pc, murs)) return;
              }
              cible.name = objChar.get('name');
              cible.tokName = obj.get('name');
              cibles.push(cible);
            });
            break;
          default:
            error("aoe inconnue", options.aoe);
            return;
        }
      } else {
        if (attackingToken.id == targetToken.id && !options.echecTotal) { //m\xEAme token pour attaquant et cible
          sendPerso(attaquant,
            "s'attaque " + onGenre(attaquant, "lui", "elle") +
            "-m\xEAme ? Probablement une erreur \xE0 la s\xE9lection de la cible. On annule");
          return;
        }
        let targetCharId = targetToken.get("represents");
        if (targetCharId === "") {
          error("Le token cibl\xE9 (" + nomCiblePrincipale + ") doit repr\xE9senter un personnage ", targetToken);
          return;
        }
        var targetChar = getObj("character", targetCharId);
        if (targetChar === undefined) {
          error("Unexpected undefined 2", targetChar);
          return;
        }
        cibles = [{
          token: targetToken,
          charId: targetCharId,
          name: targetChar.get('name'),
          tokName: nomCiblePrincipale
        }];
      }
      if (options.ciblesSupplementaires) {
        options.ciblesSupplementaires.forEach(function(c) {
          var i = cibles.some(function(t) {
            return (t.token.id == c.token.id);
          });
          if (!i) cibles.push(c);
        });
      }
    }
    //Les conditions qui peuvent emp\xEAcher l'attaque
    if (options.conditionAttaquant !== undefined) {
      if (!testCondition(options.conditionAttaquant, attaquant, cibles)) {
        sendPerso(attaquant, "ne peut pas utiliser " + weaponName);
        return;
      }
    }
    if (options.avecd12 && ((estAffaibli(attaquant) && !predicateAsBool(attaquant, 'insensibleAffaibli')) || getState(attaquant, 'immobilise'))) {
      sendPerso(attaquant, "ne peut pas utiliser cette capacit\xE9 quand il est affaibli.");
      return;
    }
    if (options.forceMinimum &&
      caracCourante(attaquant, 'force') < options.forceMinimum) {
      sendPerso("n'est pas assez fort pour utiliser cette attaque (force minimum " + options.forceMinimum + ")");
      return;
    }
    //dernieresCiblesAttaquees contient en current les cibles attaqu\xE9es, et en max les cibles sur lesquelles on a fait des ripostes
    let attrCiblesAttaquees = tokenAttribute(attaquant, 'dernieresCiblesAttaquees');
    let ripostesDuTour = new Set();
    if (attrCiblesAttaquees.length > 0) {
      ripostesDuTour = new Set(attrCiblesAttaquees[0].get('max').split(' '));
    }
    let tm = stateCOF.tenebresMagiques;
    if (tm && estDemon(attaquant)) {
      tm.attaques = tm.attaques || {};
      tm.attaques[attaquant.token.id] = cibles;
    }
    cibles = cibles.filter(function(target) {
      if (getState(target, 'enseveli')) {
        sendPlayer(playerName, "impossible d'attaquer un personnage enseveli", playerId);
        return false;
      }
      if (attributeAsBool(target, 'ombreMortelle')) {
        sendPlayer(playerName, "impossible d'attaquer une ombre", playerId);
        return false;
      }
      if (options.seulementVivant && estNonVivant(target)) {
        sendPlayer(playerName, "cette attaque n'affecte que les cr\xE9atures vivantes", playerId);
        return false;
      }
      if (options.attaqueMentale && predicateAsBool(target, 'sansEsprit')) {
        sendPlayer(playerName, "cette attaque n'affecte que les cr\xE9atures pensantes", playerId);
        return false;
      }
      if (options.pointsVitaux && estNonVivant(target)) {
        sendPlayer(playerName, "La cible n'est pas vraiment vivante : " + attaquant.name + " ne trouve pas de points vitaux", playerId);
        return false;
      }
      if (attributeAsBool(attaquant, 'tenuADistanceManoeuvre(' + target.token.id + ')')) {
        sendPerso(attaquant, "est tenu \xE0 distance de " + target.tokName + ", " + onGenre(attaquant, "il", "elle") + " ne peut pas l'attaquer ce tour.");
        return false;
      }
      if (charAttributeAsBool(target, 'armeeConjuree')) {
        return options.attaqueArmeeConjuree;
      }
      if (ripostesDuTour.has(target.token.id)) {
        sendPerso(attaquant, "a d\xE9j\xE0 fait une riposte contre " + target.tokName);
        return false;
      }
      return true;
    });
    if (cibles.length === 0) return;
    if (!options.redo) {
      //Prise en compte de la distance
      let optDistance = {};
      if (options.contact) optDistance.allonge = options.allonge;
      // Si l'attaquant est mont\xE9, distance mesur\xE9e \xE0 partir de sa monture
      let pseudoAttackingToken = attackingToken;
      let attrMonture = tokenAttribute(attaquant, 'monteSur');
      if (attrMonture.length > 0) {
        let pseudoAttacker =
          persoOfId(attrMonture[0].get('current'), attrMonture[0].get('max'), pageId);
        if (pseudoAttacker) pseudoAttackingToken = pseudoAttacker.token;
      }
      cibles = cibles.filter(function(target) {
        // Si la cible est mont\xE9e, distance mesur\xE9e vers sa monture
        let pseudoTargetToken = target.token;
        attrMonture = tokenAttribute(target, 'monteSur');
        if (attrMonture.length > 0) {
          let pseudoTarget =
            persoOfId(attrMonture[0].get('current'), attrMonture[0].get('max'), pageId);
          if (pseudoTarget) pseudoTargetToken = pseudoTarget.token;
        }
        target.distance =
          distanceCombat(pseudoAttackingToken, pseudoTargetToken, pageId, optDistance);
        if (options.intercepter || options.interposer) return true;
        if (target.distance > portee && target.msgEsquiveFatale === undefined && !(target.chairACanon || target.intercepter)) {
          if (options.aoe || options.auto) return false; //distance stricte
          if (target.distance > (predicateAsBool(attaquant, 'tirParabolique') ? 3 : 2) * portee) return false;
          // On peut aller jusqu'\xE0 2x portee si unique cible et jet d'attaque, 3x si le personnage a Tir Parabolique
          return true;
        }
        if (target.distance === 0 && options.seulementDistance) {
          sendPerso(attaquant, "est trop proche de " + target.token.get('name') + " pour cette attaque");
          return false;
        }
        return true;
      });
    }
    //On enl\xE8ve les alli\xE9s si l'option saufAllies est active
    if (options.saufAllies) {
      var allies = new Set();
      allies = alliesParPerso[attaquant.charId] || allies;
      allies = (new Set(allies)).add(attaquant.charId);
      cibles = cibles.filter(function(target) {
        return !(allies.has(target.charId));
      });
    }
    //On v\xE9rifie que les cibles sont assez proches les unes des autres
    if (options.ciblesDansDisque && cibles.length > 1) {
      let l1, l2, t1, t2;
      cibles.forEach(function(target) {
        let l = target.token.get('left');
        let t = target.token.get('top');
        if (l1 === undefined || l1 > l) l1 = l;
        if (l2 === undefined || l2 < l) l2 = l;
        if (t1 === undefined || t1 > t) t1 = t;
        if (t2 === undefined || t2 < t) t2 = t;
      });
      let maxpix = options.ciblesDansDisque * PIX_PER_UNIT / computeScale(pageId);
      if ((l2 - l1) > 2 * maxpix || (t2 - t1) > 2 * maxpix) {
        sendPlayer(playerName, "Cibles trop \xE9loign\xE9es les unes des autres");
        return;
      }
      //On calcule la longueur des diagonales du rectangle minimal
      let diag = Math.sqrt((l2 - l1) * (l2 - l1) + (t2 - t1) * (t2 - t1));
      if (diag > maxpix) {
        var centre = [(l1 + l2) / 2, (t1 + t2) / 2];
        //C'est approch\xE9, mais s\xFBrement assez bon pour ce qui nous occupe
        var tropLoin = cibles.some(function(target) {
          var pt = tokenCenter(target.token);
          return (VecMath.length(VecMath.vec(centre, pt)) > maxpix + 1);
        });
        if (tropLoin) {
          sendPlayer(playerName, "Cibles trop \xE9loign\xE9es les unes des autres");
          return;
        }
      }
    }
    if (cibles.length === 0) {
      if (options.aoe) {
        sendPlayer(playerName, "aucune cible dans l'aire d'effet de " + weaponName + ", action annul\xE9e",
          playerId);
        return;
      }
      if (!options.seulementDistance) {
        sendPerso(attaquant, "est hors de port\xE9e de " + nomCiblePrincipale + " pour une attaque utilisant " + weaponName + ", action annul\xE9e");
      }
      return;
    }
    //On enl\xE8ve les doublons de cibles qui partagent leurs PVs;
    let ciblesAvecPVsPartages = new Set();
    //va aussi peupler le champ name des cibles
    cibles = cibles.filter(function(target, index) {
      if (target.name === undefined) {
        let targetChar = getObj('character', target.charId);
        if (targetChar === undefined) return false;
        target.name = targetChar.get('name');
      }
      if (ciblesAvecPVsPartages.has(target.name)) return false;
      let ciblePartagee = charAttribute(target.charId, 'PVPartagesAvec');
      if (ciblePartagee.length > 0) {
        if (charAttributeAsBool(target, 'familier') || charAttributeAsBool(target, 'guetteur')) {
          //c'est le personnage qui a un familier, on le garde en cible prioritaire
          ciblePartagee.forEach(function(attr) {
            ciblesAvecPVsPartages.add(attr.get('current'));
          });
        } else if (persoEstPNJ(target)) {
          //cible la moins prioritaire, on l'enl\xE8ve si on trouve un autre repr\xE9sentant
          let representantPresent = cibles.find(function(target2, index2) {
            if (index2 <= index) return false; //d\xE9j\xE0 trait\xE9
            if (target2.name === undefined) {
              let target2Char = getObj('character', target2.charId);
              if (target2Char === undefined) return false;
              target2.name = target2Char.get('name');
            }
            return ciblePartagee.find(function(attr) {
              return attr.get('current') == target2.name;
            });
          });
          if (representantPresent) return false;
        } else {
          //N'a pas de familier mais n'est pas un PNJ
          //On cherche si il existe un autre perso plus prioritaire.
          let representantFamilier = cibles.find(function(target2, index2) {
            if (index2 < index) return false; //d\xE9j\xE0 trait\xE9
            if (target2.name === undefined) {
              let target2Char = getObj('character', target2.charId);
              if (target2Char === undefined) return false;
              target2.name = target2Char.get('name');
            }
            let estPartagee = ciblePartagee.find(function(cn) {
              return cn == target2.name;
            });
            if (!estPartagee) return false;
            return charAttributeAsBool(target2, 'familier') ||
              charAttributeAsBool(target2, 'guetteur');
          });
          if (representantFamilier) return false;
          ciblePartagee.forEach(function(attr) {
            ciblesAvecPVsPartages.add(attr.get('current'));
          });
        }
      }
      return true;
    });
    let evt = options.evt || {
      type: "Attaque",
      action: {
        playerName: playerName,
        playerId: playerId,
        attaquant: attaquant,
        cibles: cibles,
        weaponStats: weaponStats,
        options: options
      }
    };
    if (options.attaqueArmeeConjuree) {
      setAttrDuree(attaquant, 'attaqueArmeeConjuree', 1, evt);
    }
    evt.action = evt.action || {
      options: JSON.parse(JSON.stringify(options)) //pour la chance etc.
    };
    if (options.tempsRecharge) {
      if (attributeAsBool(attaquant, options.tempsRecharge.effet)) {
        sendPerso(attaquant, "ne peut pas encore utiliser cette attaque");
        return;
      }
      if (options.tempsRecharge.duree > 0) {
        setAttrDuree(attaquant, options.tempsRecharge.effet, options.tempsRecharge.duree, evt);
      }
    }
    //On met \xE0 jour l'arme en main, si n\xE9cessaire
    if (weaponStats.arme || weaponStats.armeGauche || (weaponStats.divers && weaponStats.divers.toLowerCase().includes('arme'))) {
      options.weaponStats = weaponStats;
      options.messages = options.messages || [];
      let arme = armesEnMain(attaquant);
      if ((!arme || arme.label != attackLabel) && (!attaquant.armeGauche || attaquant.armeGauche.label != attackLabel))
        degainerArme(attaquant, attackLabel, evt, options);
    }
    if (options.contact && predicateAsBool(attaquant, 'frappeDuVide')) {
      if (attributeAsBool(attaquant, 'limiteParTour_frappeDuVidePossible'))
        options.frappeDuVide = true;
      //Il faut noter la premi\xE8re attaque au contact
      setTokenAttr(attaquant, 'limiteParCombat_dejaFrappeContact', true, evt);
    }
    let riposte = predicateAsBool(attaquant, 'riposte');
    let attaqueEnMeute = predicateAsInt(attaquant, 'attaqueEnMeute', 0);
    if (attaqueEnMeute > 0) options.attaqueEnMeute = attaqueEnMeute;
    let attrLienEpique = charAttribute(attaquant.charId, 'lienEpique');
    if (attrLienEpique.length > 0) {
      options.lienEpique = attrLienEpique[0].get('current');
    }
    if (riposte || options.attaqueEnMeute || options.lienEpique) {
      //Dans ce cas, il faut stoquer les cibles attaqu\xE9es
      //(dans le cas de riposte, pour ne pas les re-proposer en riposte
      let listeCibles =
        cibles.map(function(target) {
          return target.token.id;
        }).join(' ');
      if (attrCiblesAttaquees.length === 0) {
        if (options.riposte) {
          setTokenAttr(attaquant, 'dernieresCiblesAttaquees', '', evt, {
            maxVal: listeCibles
          });
        } else {
          setTokenAttr(attaquant, 'dernieresCiblesAttaquees', listeCibles, evt);
        }
      } else { //L'attribut existe d\xE9j\xE0
        attrCiblesAttaquees = attrCiblesAttaquees[0];
        evt.attributes = evt.attributes || [];
        var attaquesDuTour = attrCiblesAttaquees.get('current');
        ripostesDuTour = attrCiblesAttaquees.get('max');
        evt.attributes.push({
          attribute: attrCiblesAttaquees,
          current: attaquesDuTour,
          max: ripostesDuTour,
        });
        if (options.riposte) {
          if (ripostesDuTour === '') ripostesDuTour = listeCibles;
          else ripostesDuTour += ' ' + listeCibles;
          attrCiblesAttaquees.set('max', ripostesDuTour);
        } else {
          if (attaquesDuTour === '') attaquesDuTour = listeCibles;
          else attaquesDuTour += ' ' + listeCibles;
          attrCiblesAttaquees.set('current', attaquesDuTour);
        }
      }
    }
    addEvent(evt);
    //On fait les tests pour les cibles qui b\xE9n\xE9ficieraient d'un sanctuaire
    let ciblesATraiter = cibles.length;
    let cibleTraitee = function() {
      ciblesATraiter--;
      if (ciblesATraiter === 0) {
        let explications = [];
        if (options.messages) explications = [...options.messages];
        evalITE(attaquant, undefined, undefined, options, 0, evt, explications, options, function() {
          resoudreAttaque(attaquant, cibles, attackLabel, weaponName, weaponStats, playerId, pageId, evt, explications, options, chargesArme);
        });
      }
    };
    var attaqueImpossible = false;
    if (predicateAsBool(attaquant, 'chatimentDuMale')) options.chatimentDuMale = true;
    cibles.forEach(function(cible) {
      if (attaqueImpossible) return;
      cible.messages = [];
      if (options.chatimentDuMale && onGenre(cible, true, false)) cible.chatimentDuMale = true;
      let evalSanctuaire = function() {
        if (attributeAsBool(cible, 'sanctuaire')) {
          let testId = 'sanctuaire_' + cible.token.id;
          testCaracteristique(attaquant, 'SAG', 15, testId, options, evt, function(tr) {
            if (tr.reussite) {
              cible.messages.push(attaquant.tokName + " r\xE9ussi \xE0 passer outre le sanctuaire de " + cible.tokName + " (jet de SAG " + tr.texte + "&ge;15)" + tr.modifiers);
              cibleTraitee();
            } else {
              var msgRate = "ne peut se r\xE9soudre \xE0 attaquer " + cible.tokName + " (sanctuaire, jet de SAG " + tr.texte + "< 15)" + tr.rerolls + tr.modifiers;
              sendPerso(attaquant, msgRate);
              attaqueImpossible = true;
            }
          });
        } else {
          cibleTraitee();
        }
      };
      // Attaque de Disparition avec jet oppos\xE9
      if (options.disparition) {
        //L'immunit\xE9 aux attaques sournoise est test\xE9e plus loin et ne devrait
        //pas emp\xEAcher le bonus de +5 \xE0 l'attaque.
        let rollId = 'disparition_' + cible.token.id;
        let options1 = {...options
        };
        options1.competence = 'discr\xE9tion';
        let options2 = {...options
        };
        options2.competence = 'perception';
        testOppose(rollId, attaquant, "DEX", options1, cible, "SAG", options2,
          cible.messages, evt,
          function(resultat, crit, rt1, rt2) {
            if (resultat != 2) {
              cible.messages.push(attaquant.tokName + " r\xE9apparait \xE0 c\xF4t\xE9 de " + cible.tokName + " et lui porte une attaque mortelle !");
              // rajout des bonus de sournoise
              options.bonusAttaque = (options.bonusAttaque || 0) + 5;
              options.sournoise = options.sournoise || 0;
              options.sournoise += options.disparition;
              evalSanctuaire();
            } else {
              cible.messages.push(cible.tokName + " rep\xE8re " + attaquant.tokName + " \xE0 temps pour r\xE9agir.");
              evalSanctuaire();
            }
          }); //fin de testOppose (asynchrone)
      } else evalSanctuaire();
    });
  }

  // On affiche les options d'attaque \xE0 droite
  function afficherOptionsAttaque(perso, opt_display) {
    var action_opts = '!cof-options-d-attaque --target ' + perso.token.id;
    var text_opts = '';
    if (persoEstPNJ(perso) && ficheAttributeAsInt(perso, 'attaque_de_groupe', 1) > 1) {
      text_opts = "Groupe de " + ficheAttributeAsInt(perso, 'attaque_de_groupe', 1);
    }
    if (ficheAttributeAsInt(perso, 'attaque_en_puissance_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "En puissance " + ficheAttributeAsInt(perso, 'attaque_en_puissance', 1);
    }
    if (ficheAttributeAsInt(perso, 'attaque_risquee_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "Risqu\xE9e";
    }
    if (ficheAttributeAsInt(perso, 'attaque_assuree_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "Assur\xE9e";
    }
    if (ficheAttributeAsInt(perso, 'attaque_dm_temp_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "Pour assommer";
    }
    if (text_opts === '') text_opts = 'Options';
    opt_display.action_right =
      boutonSimple(action_opts, text_opts,
        'style="color: #a94442; background-color: #f2dede;"');
  }

  //perso peut ne pas avoir de token
  function extractRepeating(perso, repeatingSection) {
    const reg = new RegExp("^(repeating_" + repeatingSection + "_[^_]*_)(.*)$");
    const attributes = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    let rawList = {};
    attributes.forEach(function(a) {
      const m = reg.exec(a.get('name'));
      if (!m) return;
      rawList[m[1]] = rawList[m[1]] || {};
      rawList[m[1]][m[2]] = a.get('current');
    });
    return rawList;
  }

  //perso peut ne pas avoir de token
  function listAllAttacks(perso) {
    if (perso.toutesLesAttaques) return perso.toutesLesAttaques;
    let rawList;
    if (persoEstPNJ(perso)) rawList = extractRepeating(perso, 'pnjatk');
    else rawList = extractRepeating(perso, 'armes');
    let liste = {}; //liste tri\xE9e par label d'attaque
    for (let pref in rawList) {
      let ra = rawList[pref];
      if (ra.armelabel === undefined) ra.armelabel = 0;
      if (liste[ra.armelabel]) {
        error("Plusieurs attaques de label " + ra.armelabel, ra);
        continue;
      }
      ra.prefixe = pref;
      liste[ra.armelabel] = ra;
    }
    perso.toutesLesAttaques = liste;
    return liste;
  }

  function sortedActionList(perso, listNumber) {
    let actions = [];
    let rawActions = extractRepeating(perso, 'actions' + listNumber);
    for (let pref in rawActions) {
      let ra = rawActions[pref];
      if (ra.actiontitre === undefined) ra.actiontitre = ' ';
      if (ra.actionmontree === undefined || parseInt(ra.actionmontree) === 1) {
        let rang = parseInt(ra.actionrang);
        if (isNaN(rang) || rang < 0) rang = 0;
        if (actions[rang]) {
          error("Plusieurs actions de m\xEAme rang " + rang + " dans la liste d'actions du tour", ra);
          continue;
        }
        actions[rang] = ra;
      }
    }
    return actions;
  }

  // on r\xE9cup\xE8re la valeur de l'action dont chaque Macro #/Ability % est mis dans un tableau 'action'
  //Pour chaque action, on a une commande, un texte et des options.
  //On appelle f(commande, texte, macros, option)
  //actionsDuTour peut \xEAtre un nombre entre 0 et 4 (listes sur la fiche), ou
  //  une ability
  function treatActions(perso, actionsDuTour, abilities, f) {
    let actions; // La liste des actions
    let options = '';
    switch (actionsDuTour) {
      case 0:
        actions = sortedActionList(perso, '');
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        actions = sortedActionList(perso, actionsDuTour);
        options = ficheAttribute(perso, 'optionslisteactions' + actionsDuTour, '');
        if (options.startsWith('-')) options = ' ' + options;
        break;
      default:
        actions = actionsDuTour.get('action')
          .replace(/\n/gm, '').replace(/\r/gm, '')
          .replace(/%#([^#]*)#/g, '\n!cof-liste-actions $1')
          .replace(/\/\/%/g, '\n\/\/')
          .replace(/\/\/#/g, '\n\/\/')
          .replace(/\/\/!/g, '\n\/\/')
          .replace(/%/g, '\n%').replace(/#/g, '\n#').replace(/!/g, '\n!')
          .split('\n');
    }
    let actionsAAfficher;
    if (actions.length > 0) {
      // Toutes les Macros
      const macros = findObjs({
        _type: 'macro'
      });
      let found;
      let command;
      actions.forEach(function(action) {
        if (!action) return;
        let actionCode;
        let actionTextFinal;
        if (action.actiontitre !== undefined) {
          switch (action.actiontype) {
            case 'action':
            case undefined:
              if (action.actioncode) {
                actionCode = action.actioncode;
                actionTextFinal = action.actiontitre;
              } else {
                actionCode = action.actiontitre;
              }
              break;
            case 'liste':
              f('!cof-liste-actions ' + action.actiontitre, action.actiontitre, macros);
              found = true;
              return;
            default:
              error("Type d'action non reconnu " + action.actiontype, action);
              return;
          }
        } else {
          actionCode = action.trim();
          if (actionCode === '') return;
          if (actionCode.startsWith('//')) return; //commented out line
        }
        let actionCommands = actionCode.split(' ');
        actionCommands = actionCommands.filter(function(c) {
          return c !== '';
        });
        if (actionCommands.length === 0) return;
        let actionCmd = actionCommands[0];
        let actionText = actionTextFinal || actionCmd.replace(/-/g, ' ').replace(/_/g, ' ');
        found = false;
        switch (actionCmd.charAt(0)) {
          case '%':
            // Ability
            actionCmd = actionCmd.substr(1);
            if (!actionTextFinal) actionText = actionText.substr(1);
            abilities.forEach(function(abilitie, index) {
              if (found) return;
              if (abilitie.get('name') === actionCmd) {
                // l'ability existe
                found = true;
                command = abilitie.get('action').trim();
                if (actionCommands.length > 1) {
                  //On rajoute les options de l'ability
                  command += actionCode.substr(actionCode.indexOf(' '));
                }
                command += options;
                f(command, actionText, macros);
              }
            });
            break;
          case '#':
            // Macro
            //D'abord le cas de #Attaque
            if (actionCmd == '#Attaque' && actionCommands.length > 1) {
              found = true;
              let attackLabel = actionCommands[1].trim();
              let attackStats;
              if (attackLabel == -1) { //attaque avec l'arme en main
                attackStats = armesEnMain(perso);
                if (attackStats === undefined) attackStats = attaqueAMainsNues;
              } else if (attackLabel == -2) { //attaque avec l'arme en main gauche
                if (perso.armesEnMain === undefined) armesEnMain(perso);
                attackStats = perso.armeGauche;
                if (!attackStats) return;
              } else {
                attackStats = getWeaponStats(perso, attackLabel);
                if (!attackStats) {
                  error("Impossible de trouver l'arme de label " + attackLabel, actionCommands);
                  return;
                }
              }
              if (!actionTextFinal) actionText = attackStats.name;
              actionCode += options;
              f(actionCode, actionText, macros, {
                attackStats
              });
            } else {
              actionCmd = actionCmd.substr(1);
              if (!actionTextFinal) actionText = actionText.substr(1);
              macros.forEach(function(macro, index) {
                if (found) return;
                if (macro.get('name') === actionCmd) {
                  found = true;
                  command = macro.get('action').trim();
                  if (actionCommands.length > 1) {
                    //On rajoute les options de la macro
                    command += actionCode.substr(actionCode.indexOf(' '));
                  }
                  command += options;
                  f(command, actionText, macros);
                }
              });
            }
            break;
          case '!':
            switch (actionCmd.toLowerCase()) {
              case '!options':
                found = true;
                if (actionCommands.length > 1) {
                  options = actionCode.substring(8); //d\xE9marre par ' '
                }
                break;
              case '!attaques':
                found = true;
                f('liste des attaques', '', macros, options);
                break;
              case '!arme-en-main':
                found = true;
                let attOptions = '';
                if (actionCommands.length > 1)
                  attOptions = ' ' + actionCommands.slice(1).join(' ');
                attOptions += options;
                let attackStats = armesEnMain(perso);
                if (attackStats === undefined) {
                  let {
                    attaqueNaturelleNonVisible
                  } = listeDesArmes(perso);
                  if (attaqueNaturelleNonVisible) attackStats = getWeaponStats(perso, attaqueNaturelleNonVisible.armelabel);
                }
                command = '!cof-attack ' + perso.token.id + ' @{target|token_id} ';
                if (attackStats) {
                  command += attackStats.label + attOptions;
                  if (!actionTextFinal) actionText = attackStats.name;
                  f(command, actionText, macros, {
                    attackStats
                  });
                } else {
                  command += argsAttaqueAMainsNues(perso) + attOptions;
                  if (!actionTextFinal) actionText = 'Mains nues';
                  f(command, actionText, macros);
                }
                break;
              default:
                // commande API
                if (!actionTextFinal && actionCommands.length > 1) {
                  actionText = actionCommands[1].replace(/-/g, ' ').replace(/_/g, ' ');
                }
                command = actionCode + options;
                f(command, actionText, macros);
                found = true;
            }
            break;
          default: //On affiche juste le titre
            f('', actionCode, macros);
            found = true;
        }
        if (found) {
          actionsAAfficher = true;
        } else {
          // Si on n'a toujours rien trouv\xE9, on ajoute un petit log
          log('Ability et macro non trouv\xE9 : ' + actionCode);
        }
      });
    }
    return actionsAAfficher;
  }

  function displayAttaqueOpportunite(vid, cibles, type, action, option) {
    let attaquant = persoOfId(vid);
    if (attaquant === undefined) {
      error("Impossible de retrouver le personnage qui pouvait faire une attaque " + type, vid);
      return;
    }
    if (!isActive(attaquant)) return;
    let abilities = findObjs({
      _type: 'ability',
      _characterid: attaquant.charId,
    });
    let actions = findListeActions(attaquant, action, abilities);
    if (actions === undefined) {
      if (action == 'Ripostes') {
        actions = findListeActions(attaquant, 'ActionsRiposte', abilities);
      } else if (action == 'Attaques en traitre') {
        actions = findListeActions(attaquant, 'AttaqueEnTraitre', abilities);
        if (actions === undefined)
          actions = findListeActions(attaquant, 'Attaques en tra\xEEtre', abilities);
      }
    }
    let actionsOpportunite = [];
    if (actions) {
      treatActions(attaquant, actions, abilities, function(command, text, macros, options) {
        if (command == 'liste des attaques') {
          actionsOpportunite.push({
            listeActions: true,
            options: options
          });
        } else {
          command = replaceAction(command, attaquant, macros, abilities);
          if (command.startsWith('!cof-attack')) {
            actionsOpportunite.push({
              command: command,
              text: text,
              options: options
            });
          }
        }
      });
      actionsOpportunite.reverse();
    } else {
      //On affiche l'attaque avec l'arme en main + les attaques naturelles coch\xE9es
      let listeAttaques = listAllAttacks(attaquant);
      for (let label in listeAttaques) {
        let arme = listeAttaques[label];
        if (parseInt(arme.armeactionvisible) === 0) continue;
        if (arme.armetypeattaque == 'Naturel' || arme.armetypeattaque === 'undefined') {
          actionsOpportunite.push({
            command: '!cof-attack @{selected|token_id} @{target|token_id} ' + label,
            text: arme.armenom,
          });
        }
      }
      actionsOpportunite.push({
        command: '!cof-attack @{selected|token_id} @{target|token_id} -1',
        text: "Attaque avec l'arme en main"
      });
    }
    let opt_display = {
      chuchote: true,
      retarde: true,
    };
    afficherOptionsAttaque(attaquant, opt_display);
    //On cr\xE9e un display sans le header
    let display =
      startFramedDisplay(undefined, "Attaque " + type + " possible", attaquant, opt_display);
    cibles.forEach(function(target) {
      target.tokName = target.tokName || target.token.get('name');
      if (target.name === undefined) {
        let targetChar = getObj('character', target.charId);
        if (targetChar === undefined) {
          error('Impossible de trouver le personnage repr\xE9sentant ' + target.tokName, target);
          return;
        }
        target.name = targetChar.get('name');
      }
      addLineToFramedDisplay(display, "contre " + target.tokName, 100, true);
      actionsOpportunite.forEach(function(action) {
        let opt = action.options;
        if (opt) {
          if (option) opt = option + opt;
        } else opt = option;
        if (action.listeActions) {
          let l = listeAttaquesVisibles(attaquant, {
            ligneOptions: opt,
            target: target.token.id
          });
          addLineToFramedDisplay(display, l);
          return;
        }
        var cmd = action.command.replace(/@\{target\|token_id\}/g, target.token.id);
        cmd = cmd.replace(/@\{target\|token_name\}/g, target.tokName);
        cmd = cmd.replace(/@\{target\|/g, '@{' + target.name + '|');
        if (opt) cmd += ' ' + opt;
        addLineToFramedDisplay(display, bouton(cmd, action.text, attaquant));
      });
    });
    // on envoie la liste aux joueurs qui g\xE8rent l'attaquant
    var playerIds = getPlayerIds(attaquant);
    playerIds.forEach(function(playerid) {
      addFramedHeader(display, playerid, true);
      sendChat('', endFramedDisplay(display));
    });
    if (playerIds.length === 0) {
      addFramedHeader(display, undefined, 'gm');
      sendChat('', endFramedDisplay(display));
    }
  }

  function ajouteDe6Crit(x, first) {
    let bonusCrit = rollDePlus(6);
    if (first) x.dmgDisplay = "(" + x.dmgDisplay + ")";
    x.dmgDisplay += '+' + bonusCrit.roll;
    x.dmgTotal += bonusCrit.val;
  }

  function immuniseAuType(target, dmgType, attaquant) {
    if (predicateAsBool(target, 'immunite_' + dmgType)) return true;
    switch (dmgType) {
      case 'poison':
        if (attributeAsBool(target, 'sangDeLArbreCoeur')) return true;
        if (predicateOrAttributeAsBool(target, 'controleSanguin')) return true;
        if (attaquant && predicateAsBool(target, 'sangDeFerIf')) {
          return estElfeNoir(attaquant) || estInsecte(attaquant);
        }
        return false;
      case 'froid':
        return attributeAsBool(target, 'presenceGlaciale');
      case 'maladie':
        return attributeAsBool(target, 'sangDeLArbreCoeur');
      case 'drain':
        return predicateAsInt(target, 'voieDeLArchange', 1) > 2 && attributeAsBool(target, 'formeDAnge');
    }
    return false;
  }

  function immuniseAsphyxie(target, expliquer) {
    if (predicateAsBool(target, 'creatureArtificielle') ||
      estNonVivant(target)) {
      if (expliquer) expliquer("L'asphyxie est sans effet sur une cr\xE9ature non-vivante");
      return true;
    } else if (estDemon(target)) {
      if (expliquer) expliquer("L'asphyxie est sans effet sur un d\xE9mon");
      return true;
    }
    return false;
  }

  // Fonction asynchrone
  // displayRes est optionnel, et peut avoir 2 arguments
  // - un texte affichant le jet de d\xE9g\xE2ts
  // - la valeur finale des d\xE9g\xE2ts inflig\xE9s
  // crit est un bool\xE9en, il augmente de 1 (ou options.critCoef) le coefficient (option.dmgCoef) et active certains effets
  function dealDamage(target, dmg, otherDmg, evt, crit, options, explications, displayRes) {
    if (target.tokName === undefined) target.tokName = target.token.get('name');
    if (options === undefined) options = {};
    let expliquer = function(msg) {
      if (explications) explications.push(msg);
      else sendPerso(target, msg);
    };
    if (options.interposer) {
      return dealDamageAfterOthers(target, crit, {}, evt, expliquer, displayRes, options.interposer, dmg.display, false);
    }
    if ((attributeAsBool(target, 'intangible') && attributeAsInt(target, 'intangibleValeur', 1)) ||
      (attributeAsBool(target, 'intangibleInvisible') && attributeAsInt(target, 'intangibleInvisibleValeur', 1)) ||
      attributeAsBool(target, 'ombreMortelle') ||
      (options.aoe === undefined &&
        attributeAsBool(target, 'formeGazeuse'))) {
      expliquer("L'attaque passe \xE0 travers de " + target.tokName);
      if (displayRes) displayRes('0', 0, 0);
      return 0;
    }
    if (options.asphyxie) {
      if (immuniseAsphyxie(target, expliquer)) {
        if (displayRes) displayRes('0', 0, 0);
        return 0;
      }
    }
    if (!options.magique && !options.sortilege && dmg.type != 'magique' &&
      predicateOrAttributeAsBool(target, 'immunite_nonMagique')) {
      expliquer("L'attaque ne semble pas affecter " + target.tokName);
      if (displayRes) displayRes('0', 0, 0);
      return 0;
    }
    let dmgCoef = options.dmgCoef || 1;
    if (target.dmgCoef) dmgCoef += target.dmgCoef;
    if (options.ferFroid && (estDemon(target) || estFee(target))) dmgCoef += 1;
    let diviseDmg = options.diviseDmg || 1;
    if (target.diviseDmg) diviseDmg *= target.diviseDmg;
    if (options.attaqueEnEtantGobe) diviseDmg *= 2;
    if (options.attaqueDeGroupeDmgCoef) {
      dmgCoef++;
      expliquer("Attaque en groupe > DEF +" + reglesOptionelles.haute_DEF.val.crit_attaque_groupe.val + " => DMGx" + (crit ? "3" : "2"));
    }
    let critCoef = 1;
    if (crit) {
      if (attributeAsBool(target, 'danseDesLames')) {
        removeTokenAttr(target, 'danseDesLames', evt);
        expliquer("Le coup critique fait sortir de la transe de danse des lames");
      }
      if (predicateAsBool(target, 'armureLourdeGuerrier') &&
        ficheAttributeAsBool(target, 'defarmureon', false) &&
        ficheAttributeAsInt(target, 'defarmure', 0) >= 8) {
        expliquer("L'armure lourde de " + target.token.get('name') + " lui permet d'ignorer les d\xE9g\xE2ts critiques");
      } else {
        if (options.critCoef) critCoef = options.critCoef;
        if (target.critCoef) critCoef += target.critCoef;
        dmgCoef += critCoef;
        if (predicateAsBool(target, 'armureProtection') && ficheAttributeAsBool(target, 'defarmureon', false)) {
          expliquer("L'armure de protection de " + target.token.get('name') + " le prot\xE8ge du critique");
          diviseDmg++;
        }
        if (predicateAsBool(target, 'bouclierProtection') && ficheAttributeAsBool(target, 'defbouclieron', false)) {
          expliquer("Le bouclier de protection de " + target.token.get('name') + " le prot\xE8ge du critique");
          diviseDmg++;
        }
      }
    }
    otherDmg = otherDmg || [];
    let dmgDisplay = dmg.display;
    let dmgTotal = dmg.total;
    if (dmgTotal < 1 && !(dmg.value && dmg.value.startsWith('0'))) {
      dmgDisplay += ' -> 1';
      dmgTotal = 1;
    }
    let showTotal = false;
    if (dmgCoef > 1) {
      dmgDisplay += " X " + dmgCoef;
      dmgTotal = dmgTotal * dmgCoef;
      showTotal = true;
    }
    if (diviseDmg > 1) {
      if (showTotal) dmgDisplay = '(' + dmgDisplay + ')';
      dmgDisplay += " / " + diviseDmg;
      dmgTotal = Math.ceil(dmgTotal / diviseDmg);
      showTotal = true;
    }
    if (crit) {
      let messageCrit = charAttribute(target.charId, 'messageSiCritique');
      if (messageCrit.length > 0) {
        messageCrit = messageCrit[0].get('current');
        expliquer(messageCrit);
      }
      if (predicateAsBool(target, 'memePasMal')) {
        options.memePasMal = (dmgTotal / dmgCoef) * critCoef;
      }
      let firstBonusCritique = true;
      let x = {
        dmgDisplay: dmgDisplay,
        dmgTotal: dmgTotal
      };
      if (options.affute) {
        ajouteDe6Crit(x, firstBonusCritique);
        firstBonusCritique = false;
      }
      if (options.tirFatal) {
        ajouteDe6Crit(x, firstBonusCritique);
        if (options.tirFatal > 1) {
          ajouteDe6Crit(x, false);
        }
      }
      if (target.additionalCritDmg) {
        target.additionalCritDmg.forEach(function(dmSpec) {
          if (firstBonusCritique) {
            x.dmgDisplay = "(" + x.dmgDisplay + ")";
            firstBonusCritique = false;
          }
          x.dmgDisplay += '+' + dmSpec.display;
          x.dmgTotal += dmSpec.total;
        });
      }
      if (options.memePasMal !== undefined) {
        options.memePasMal += x.dmgTotal - dmgTotal;
      }
      dmgDisplay = x.dmgDisplay;
      dmgTotal = x.dmgTotal;
    }
    //On trie les DM suppl\xE9mentaires selon leur type
    let dmgParType = {};
    otherDmg.forEach(function(d) {
      if (_.has(dmgParType, d.type)) dmgParType[d.type].push(d);
      else dmgParType[d.type] = [d];
    });
    // Dommages de m\xEAme type que le principal, mais \xE0 part, donc non affect\xE9s par les critiques
    let mainDmgType = dmg.type;
    let dmgExtra = dmgParType[mainDmgType];
    if (dmgExtra && dmgExtra.length > 0 && !immuniseAuType(target, mainDmgType, options.attaquant)) {
      if (dmgCoef > 1) dmgDisplay = "(" + dmgDisplay + ")";
      showTotal = true;
      let count = dmgExtra.length;
      dmgExtra.forEach(function(d) {
        count--;
        if (d.totalSave && d.totalSave.tempete && options.tempeteDeManaIntense) {
          d.totalSave.seuil += d.totalSave.tempete * options.tempeteDeManaIntense;
        }
        if (d.partialSave && d.partialSave.tempete && options.tempeteDeManaIntense) {
          d.partialSave.seuil += d.partialSave.tempete * options.tempeteDeManaIntense;
        }
        partialSave(d, target, false, d.display, d.total, expliquer, evt,
          function(res) {
            if (res) {
              dmgTotal += res.total;
              dmgDisplay += "+" + res.dmgDisplay;
            } else {
              dmgTotal += d.total;
              dmgDisplay += "+" + d.display;
            }
            if (count === 0) dealDamageAfterDmgExtra(target, mainDmgType, dmgTotal, dmgDisplay, showTotal, dmgParType, dmgExtra, crit, options, evt, expliquer, displayRes);
          });
      });
    } else {
      return dealDamageAfterDmgExtra(target, mainDmgType, dmgTotal, dmgDisplay, showTotal, dmgParType, dmgExtra, crit, options, evt, expliquer, displayRes);
    }
  }

  // Effets quand on rentre en combat
  // attaquant est optionnel
  // ne rajoute pas evt \xE0 l'historique
  function entrerEnCombat(attaquant, cibles, explications, evt) {
    let selected = [];
    if (attaquant) {
      selected.push({
        _id: attaquant.token.id
      });
      let attrAttInvisible = tokenAttribute(attaquant, 'tokenInvisible');
      if (attrAttInvisible.length > 0 && attaquant.token.id == attrAttInvisible[0].get('max')) {
        let tokenAttInvisible = getObj('graphic', attrAttInvisible[0].get('current'));
        if (tokenAttInvisible) selected = [{
          _id: tokenAttInvisible.id
        }];
      }
      if (getState(attaquant, 'invisible') && !predicateAsBool(attaquant, 'invisibleEnCombat')) {
        attaquant.tokName = attaquant.tokName || attaquant.token.get('name');
        explications.push(attaquant.tokName + " redevient visible");
        setState(attaquant, 'invisible', false, evt);
      }
      if (predicateAsBool(attaquant, 'pacifisme') &&
        !attributeAsBool(attaquant, 'attributDeCombat_pacifismeAnnule')) {
        setTokenAttr(attaquant, 'attributDeCombat_pacifismeAnnule', true, evt);
        sendPerso(attaquant, "perd son pacifisme");
      }
      if (attributeAsBool(attaquant, 'sanctuaire')) {
        explications.push(attaquant.token.get('name') + " met fin aux conditions du sanctuaire");
        removeTokenAttr(attaquant, 'sanctuaire', evt);
      }
    }
    cibles.forEach(function(target) {
      let token = target.token;
      let attrInvisible = tokenAttribute(target, 'tokenInvisible');
      if (attrInvisible.length > 0 && target.token.id == attrInvisible[0].get('max')) {
        let tokenInvisible = getObj('graphic', attrInvisible[0].get('current'));
        if (tokenInvisible) token = tokenInvisible;
      }
      selected.push({
        _id: token.id
      });
    });
    initiative(selected, evt); //ne recalcule pas l'init
  }

  //capa est le nom d'un pr\xE9dicat. Si le pr\xE9dicat est num\xE9rique, cela donne
  //la limite, sinon la limite est 1
  // retourne
  // - utilisations: les nombre d'utilisations restantes,
  // - nomLimite: le nom de l'attribut qui stoque l'utilisation
  // - attribut: si il y a un attribut, l'attribut en question.
  function testLimiteUtilisationsCapa(perso, capa, unite, msgPlusDispo, msgPasCapa) {
    let limite = predicateAsInt(perso, capa, 0, 1);
    if (limite === 0) {
      if (msgPasCapa) sendPerso(perso, msgPasCapa);
      return;
    }
    let nomLimite = nomLimiteCapa(capa, unite);
    if (nomLimite === undefined) return;
    let utilisations = limite;
    let attribut = tokenAttribute(perso, nomLimite);
    if (attribut.length === 0) {
      attribut = undefined;
    } else {
      attribut = attribut[0];
      utilisations = parseInt(attribut.get('current'));
      if (isNaN(utilisations)) {
        error("Resource pour " + capa + " mal form\xE9e", attribut);
        return;
      }
    }
    if (utilisations < 1) {
      if (msgPlusDispo) {
        sendPerso(perso, msgPlusDispo);
      }
      return;
    }
    return {
      utilisations,
      attribut,
      nomLimite
    };
  }

  function utiliseCapacite(perso, t, evt) {
    evt.attributes = evt.attributes || [];
    if (t.attribut) {
      evt.attributes.push({
        attribute: t.attribut,
        current: t.utilisations
      });
      t.attribut.set('current', t.utilisations - 1);
    } else {
      setTokenAttr(perso, t.nomLimite, t.utilisations - 1, evt);
    }
  }

  //L'argument weaponStats est optionnel
  function critEnAttaque(attaquant, weaponStats, options) {
    let crit = 20;
    if (weaponStats) crit = weaponStats.crit;
    if (isNaN(crit) || crit < 1 || crit > 20) {
      error("Le critique n'est pas un nombre entre 1 et 20", crit);
      crit = 20;
    }
    if (predicateAsBool(attaquant, 'scienceDuCritique') ||
      (!options.distance && !options.sortilege &&
        (predicateAsBool(attaquant, 'morsureDuSerpent') || predicateAsBool(attaquant, 'briseurDOs'))) ||
      (crit == 20 && predicateAsBool(attaquant, 'ecuyer'))) crit -= 1;
    if (options.bonusCritique) crit -= options.bonusCritique;
    if (options.affute) crit -= 1;
    if (options.contact && predicateAsBool(attaquant, 'frappeChirurgicale'))
      crit -= modCarac(attaquant, 'intelligence');
    let armeTirFatal = predicateAsBool(attaquant, 'tirFatal');
    if (armeTirFatal) {
      if (armeTirFatal === true) armeTirFatal = 'arc';
      if (options[armeTirFatal] || weaponStats[armeTirFatal]) {
        crit -= modCarac(attaquant, 'sagesse');
        options.tirFatal = 1;
        if (predicateAsInt(attaquant, 'voieDeLArcEtDuCheval', 3) > 4)
          options.tirFatal = 2;
      }
    }
    if (crit < 2) crit = 2;
    return crit;
  }

  //attaquant peut ne pas avoir de token
  function computeArmeAtkPNJ(attaquant, x) {
    let atk;
    let listeAttaquesPNJ;
    let oatk;
    switch (x) {
      case '@{ATKCAC}':
        let atkcac;
        listeAttaquesPNJ = listAllAttacks(attaquant);
        for (let label in listeAttaquesPNJ) {
          let att = listeAttaquesPNJ[label];
          if (atk === undefined) {
            atk = fieldAsInt(att, 'armeatk', 0);
            oatk = atk;
          }
          let portee = fieldAsInt(att, 'armeportee', 0);
          if (portee > 0) continue;
          let typeat = fieldAsString(att, 'armetypeattaque', 'Naturel');
          switch (typeat) {
            case 'Sortilege':
            case 'Arme de jet':
              break;
            default:
              if (oatk === undefined) oatk = fieldAsInt(att, 'armeatk', 0);
              if (atkcac === undefined) atkcac = oatk;
              if (oatk > atkcac) atkcac = oatk;
          }
        }
        if (atkcac === undefined) {
          if (atk === undefined)
            atkcac = ficheAttributeAsInt(attaquant, 'niveau', 0) + 1 + modCarac(attaquant, 'force');
          else atkcac = atk;
        }
        return atkcac;
      case '@{ATKTIR}':
        let atktir;
        listeAttaquesPNJ = listAllAttacks(attaquant);
        for (let label in listeAttaquesPNJ) {
          let att = listeAttaquesPNJ[label];
          if (atk === undefined) {
            atk = fieldAsInt(att, 'armeatk', 0);
            oatk = atk;
          }
          let portee = fieldAsInt(att, 'armeportee', 0);
          if (portee === 0) continue;
          let typeat = fieldAsString(att, 'armetypeattaque', 'Naturel');
          if (typeat == 'Sortilege') continue;
          if (oatk === undefined) oatk = fieldAsInt(att, 'armeatk', 0);
          if (atktir === undefined) atktir = oatk;
          if (oatk > atktir) atktir = oatk;
        }
        if (atktir === undefined) {
          if (atk === undefined)
            atktir = ficheAttributeAsInt(attaquant, 'niveau', 0) + 1 + modCarac(attaquant, 'dexterite');
          else atktir = atk;
        }
        return atktir;
      case '@{ATKMAG}':
        let atkmag;
        listeAttaquesPNJ = listAllAttacks(attaquant);
        for (let label in listeAttaquesPNJ) {
          let att = listeAttaquesPNJ[label];
          if (atk === undefined) {
            atk = fieldAsInt(att, 'armeatk', 0);
            oatk = atk;
          }
          let typeat = fieldAsString(att, 'armetypeattaque', 'Naturel');
          if (typeat != 'Sortilege') continue;
          if (oatk === undefined) oatk = fieldAsInt(att, 'armeatk', 0);
          if (atkmag === undefined) atkmag = oatk;
          if (oatk > atkmag) atkmag = oatk;
        }
        if (atkmag === undefined) {
          if (atk === undefined)
            atkmag = ficheAttributeAsInt(attaquant, 'niveau', 0) + 1 + modCarac(attaquant, 'sagesse');
          else atkmag = atk;
        }
        return atkmag;
      default:
        return x;
    }
  }

  //attaquant peut ne pas avoir de token
  function computeArmeAtk(attaquant, x) {
    if (x === undefined) return '';
    if (persoEstPNJ(attaquant)) return computeArmeAtkPNJ(attaquant, x);
    let attDiv;
    let attCar;
    switch (x) {
      case '@{ATKCAC}':
        attDiv = ficheAttributeAsInt(attaquant, 'ATKCAC_DIV', 0);
        if (stateCOF.setting_arran ||
          (stateCOF.setting_mixte && ficheAttribute(attaquant, 'option_setting', 'generique') == 'arran')) {
          attDiv += ficheAttributeAsInt(attaquant, 'mod_atkcac', 0);
          attCar = '@{FOR}';
        } else {
          attCar = getAttrByName(attaquant.charId, 'ATKCAC_CARAC');
        }
        break;
      case '@{ATKTIR}':
        attDiv = ficheAttributeAsInt(attaquant, 'ATKTIR_DIV', 0);
        if (stateCOF.setting_arran ||
          (stateCOF.setting_mixte && ficheAttribute(attaquant, 'option_setting', 'generique') == 'arran')) {
          attDiv += ficheAttributeAsInt(attaquant, 'mod_atktir', 0);
          attCar = '@{DEX}';
        } else {
          attCar = getAttrByName(attaquant.charId, 'ATKTIR_CARAC');
        }
        break;
      case '@{ATKMAG}':
        attDiv = ficheAttributeAsInt(attaquant, 'ATKMAG_DIV', 0);
        if (stateCOF.setting_arran ||
          (stateCOF.setting_mixte && ficheAttribute(attaquant, 'option_setting', 'generique') == 'arran')) {
          attDiv += ficheAttributeAsInt(attaquant, 'mod_atkmag', 0);
          attCar = '@{INT}';
        } else {
          attCar = getAttrByName(attaquant.charId, 'ATKMAG_CARAC');
        }
        break;
      default:
        return x;
    }
    attCar = computeCarExpression(attaquant, attCar);
    if (attCar === undefined) return x;
    return attCar + ficheAttributeAsInt(attaquant, 'niveau', 1) + attDiv;
  }

  //Retourne le label de l'attaque \xE0 l'arme de jet.
  function estAussiArmeDeJet(options) {
    if (options.startsWith('-')) options = ' ' + options;
    options = options.split(' --');
    for (let opt of options) {
      opt = opt.trim();
      if (opt === '') continue;
      opt = opt.split(' ');
      if (opt.length < 2) continue;
      if (opt[0] == 'aussiArmeDeJet') return opt[1];
    }
    return;
  }

  function degainerArmeLancee(attaquant, attackLabel, evt) {
    let arme = armesEnMain(attaquant);
    if (arme && arme.options && estAussiArmeDeJet(arme.options) == attackLabel) {
      degainerArme(attaquant, '', evt, {
        seulementDroite: true
      });
    } else if (attaquant.armeGauche && attaquant.armeGauche.options && estAussiArmeDeJet(attaquant.armeGauche.options) == attackLabel) {
      degainerArme(attaquant, '', evt, {
        gauche: true
      });
    }
  }

  //attaquant doit avoir un champ tokName
  function increaseTenacite(attaquant, target, evt) {
    if (!predicateAsBool(attaquant, 'tenacite')) return;
    let attr = 'attributDeCombat_tenaciteDe' + attaquant.tokName;
    let bonus = attributeAsInt(target, attr, 0);
    if (bonus > 2) return;
    if (bonus === 0) bonus = 2;
    else bonus = 5;
    setTokenAttr(target, attr, bonus, evt);
  }

  function resetTenacite(attaquant, target, evt) {
    if (!predicateAsBool(attaquant, 'tenacite')) return;
    let attr = tokenAttribute(target, 'attributDeCombat_tenaciteDe' + attaquant.tokName);
    if (attr.length === 0) return;
    evt.deletedAttributes = evt.deletedAttributes || [];
    deleteAttribute(attr[0], evt);
  }

  //attaquant doit avoir un champ name
  function attackExpression(attaquant, nbDe, dice, crit, plusFort, weaponStats) {
    let de = computeDice(attaquant, {
      nbDe: nbDe,
      dice: dice,
      plusFort: plusFort
    });
    let attackRollExpr = "[[" + de + "cs>" + crit + "cf1]]";
    let attSkillDiv = weaponStats.attSkillDiv;
    if (isNaN(attSkillDiv)) attSkillDiv = 0;
    let attSkillDivTxt = "";
    if (attSkillDiv > 0) attSkillDivTxt = " + " + attSkillDiv;
    else if (attSkillDiv < 0) attSkillDivTxt += attSkillDiv;
    let attackSkillExpr = addOrigin(attaquant.name, "[[" + computeArmeAtk(attaquant, weaponStats.attSkill) + attSkillDivTxt + "]]");
    return attackRollExpr + " " + attackSkillExpr;
  }

  //N'ajoute pas evt \xE0 l'historique
  function resoudreAttaque(attaquant, cibles, attackLabel, weaponName, weaponStats, playerId, pageId, evt, explications, options, chargesArme) {
    let attackingCharId = attaquant.charId;
    let attackingToken = attaquant.token;
    let attackerTokName = attaquant.tokName;
    attaquant.additionalDmg = [...options.additionalDmg]; // Reset du calcul des dommages additionnels li\xE9s \xE0 l'attaquant
    let sujetAttaquant = onGenre(attaquant, 'il', 'elle');
    if (options.contact) {
      //Prise en compte du corps \xE9l\xE9mentaire
      let typeCorpsElem = predicateAsBool(attaquant, 'corpsElementaire');
      if (typeCorpsElem && typeCorpsElem !== true) {
        let nbDes = predicateAsInt(attaquant, 'nbCorpsElementaire', 1);
        attaquant.additionalDmg.push({
          type: typeCorpsElem,
          value: nbDes + 'd6',
        });
        explications.push("Corps de " + typeCorpsElem + " => +" + nbDes + "d6 DM");
      }
    }
    const estMook = attackingToken.get('bar1_link') === '';
    // Les armes de jet
    if (weaponStats.armeDeJet && !estMook) {
      if (weaponStats.nbArmesDeJet < 1) {
        sendPerso(attaquant, "plus de " + weaponName + " \xE0 lancer.");
        return;
      }
      let attrName = weaponStats.prefixe + 'armejetqte';
      let attr = findObjs({
        _type: 'attribute',
        _characterid: attackingCharId,
        name: attrName
      }, {
        caseInsensitive: true
      });
      evt.attributes = evt.attributes || [];
      let max = 1;
      if (attr.length > 0) {
        attr = attr[0];
        if (attr.length > 1) {
          error("Plus d'un attribut pour la quantit\xE9 d'armes de jet", attr);
          attr[1].remove();
        }
        max = parseInt(attr.get('max'));
        if (isNaN(max) || max < 1) {
          error("Maximum de " + weaponName + " mal form\xE9, v\xE9rifier sur la fiche", attr);
          max = 1;
        }
        evt.attributes.push({
          attribute: attr,
          current: weaponStats.nbArmesDeJet,
          max: max
        });
      } else {
        attr = createObj('attribute', {
          characterid: attackingCharId,
          name: attrName,
          current: 1,
          max: 1
        });
        evt.attributes.push({
          attribute: attr,
        });
      }
      //On cherche si l'arme est empoison\xE9e
      let poisonAttr = tokenAttribute(attaquant, 'poisonRapide_' + attackLabel);
      if (poisonAttr.length > 0) {
        poisonAttr = poisonAttr[0];
        let infosPoisonMunitions = poisonAttr.get('max');
        let infosPoisonMunitionsIndex = infosPoisonMunitions.indexOf(' ');
        let seuilMunitionsEmpoisonnees = parseInt(infosPoisonMunitions.substring(0, infosPoisonMunitionsIndex));
        let nombreMunitionsEmpoisonnees = parseInt(infosPoisonMunitions.substring(infosPoisonMunitionsIndex + 1));
        if (!isNaN(seuilMunitionsEmpoisonnees) && !isNaN(nombreMunitionsEmpoisonnees) && nombreMunitionsEmpoisonnees > 0) {
          attaquant.additionalDmg.push({
            type: 'poison',
            value: poisonAttr.get('current'),
            partialSave: {
              carac: 'CON',
              seuil: seuilMunitionsEmpoisonnees
            }
          });
          explications.push("L'arme est empoisonn\xE9e");
          if (nombreMunitionsEmpoisonnees == 1) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(poisonAttr);
            poisonAttr.remove();
          } else {
            evt.attributes.push({
              attribute: poisonAttr,
              current: poisonAttr.get('current'),
              max: infosPoisonMunitions
            });
            poisonAttr.set('max', seuilMunitionsEmpoisonnees + ' ' + (nombreMunitionsEmpoisonnees - 1));
          }
        }
      }
      let restant = weaponStats.nbArmesDeJet;
      if (randomInteger(100) < weaponStats.tauxDePerte) {
        if (weaponStats.tauxDePerte < 100)
          explications.push(weaponName + " n'est pas r\xE9cup\xE9rable");
        attr.set('max', max - 1);
        options.armeDeJetPerdue = true;
      }
      restant--;
      attr.set('current', restant);
      if (!options.armeDeJetPerdue) { //pr\xE9pare pour un \xE9ventuel retour en main
        options.attrArmeDeJet = {
          attribute: attr,
          restant: restant
        };
      } else {
        if (restant === 0) {
          degainerArmeLancee(attaquant, attackLabel, evt);
        }
        explications.push("Il reste " + restant + " " + weaponName + " \xE0 " + attackerTokName);
      }
    }
    if (options.aussiArmeDeJet && !estMook) {
      let armeAssociee = getWeaponStats(attaquant, options.aussiArmeDeJet);
      if (armeAssociee && armeAssociee.armeDeJet) {
        if (armeAssociee.nbArmesDeJet < 1) {
          sendPerso(attaquant, "a d\xE9j\xE0 lanc\xE9 tous ses " + weaponName);
          return;
        }
      } else {
        error("L'arme de label " + options.aussiArmeDeJet + " n'est pas une arme de jet, option ignor\xE9e", armeAssociee);
      }
    }
    // Munitions
    if (options.munition) {
      if (estMook) {
        error("Les munitions ne sont pas support\xE9es pour les tokens qui ne sont pas li\xE9es \xE0 un personnage", attackingToken);
      }
      var munitionsAttr = findObjs({
        _type: 'attribute',
        _characterid: attackingCharId,
        name: 'munition_' + options.munition.nom
      });
      if (munitionsAttr.length === 0) {
        sendPerso(attaquant, ": Pas de munition nomm\xE9e " + options.munition.nom);
        return;
      }
      munitionsAttr = munitionsAttr[0];
      var munitions = munitionsAttr.get('current');
      if (munitions < 1 || (options.tirDouble && munitions < 2)) {
        sendPerso(attaquant,
          "ne peut pas utiliser cette attaque, car " + sujetAttaquant +
          " n'a plus de " + options.munition.nom.replace(/_/g, ' '));
        return;
      }
      var munitionsMax = parseInt(munitionsAttr.get('max'));
      if (isNaN(munitionsMax)) {
        error("Attribut de munitions mal form\xE9", munitionsMax);
        return;
      }
      evt.attributes = evt.attributes || [];
      evt.attributes.push({
        attribute: munitionsAttr,
        current: munitions,
        max: munitionsMax
      });
      //On cherche si la munition est empoisonn\xE9e
      let poisonAttr = tokenAttribute(attaquant, 'poisonRapide_munition_' + options.munition.nom);
      if (poisonAttr.length > 0) {
        poisonAttr = poisonAttr[0];
        var infosPoisonMunitions = poisonAttr.get('max');
        var infosPoisonMunitionsIndex = infosPoisonMunitions.indexOf(' ');
        var seuilMunitionsEmpoisonnees = parseInt(infosPoisonMunitions.substring(0, infosPoisonMunitionsIndex));
        var nombreMunitionsEmpoisonnees = parseInt(infosPoisonMunitions.substring(infosPoisonMunitionsIndex + 1));
        if (!isNaN(seuilMunitionsEmpoisonnees) && !isNaN(nombreMunitionsEmpoisonnees) && nombreMunitionsEmpoisonnees > 0) {
          attaquant.additionalDmg.push({
            type: 'poison',
            value: poisonAttr.get('current'),
            partialSave: {
              carac: 'CON',
              seuil: seuilMunitionsEmpoisonnees
            }
          });
          explications.push("L'arme est empoisonn\xE9e");
          if (nombreMunitionsEmpoisonnees == 1) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(poisonAttr);
            poisonAttr.remove();
          } else {
            evt.attributes.push({
              attribute: poisonAttr,
              current: poisonAttr.get('current'),
              max: infosPoisonMunitions
            });
            poisonAttr.set('max', seuilMunitionsEmpoisonnees + ' ' + (nombreMunitionsEmpoisonnees - 1));
          }
        }
      }
      munitions--;
      if (randomInteger(100) < options.munition.taux) munitionsMax--;
      if (options.tirDouble) {
        munitions--;
        if (randomInteger(100) < options.munition.taux) munitionsMax--;
      }
      explications.push("Il reste " + munitions + " " +
        options.munition.nom.replace(/_/g, ' ') + " \xE0 " + attackerTokName);
      munitionsAttr.set('current', munitions);
      munitionsAttr.set('max', munitionsMax);
    }
    // Armes charg\xE9es
    if (options.semonce === undefined && options.tirDeBarrage === undefined) {
      if (attackLabel && predicateAsBool(attaquant, 'charge_' + attackLabel)) {
        let currentCharge = 0;
        if (chargesArme.length > 0) {
          currentCharge = parseInt(chargesArme[0].get('current'));
        }
        if (isNaN(currentCharge) || currentCharge < 1) {
          sendPerso(attaquant, "ne peut pas attaquer avec " + weaponName + " car elle n'est pas charg\xE9e");
          return;
        }
        if (options.tirDouble &&
          (!options.tirDouble.stats || options.tirDouble.label == attackLabel) &&
          currentCharge < 2) {
          sendPerso(attaquant,
            "ne peut pas faire de tir double avec ses" + weaponName + "s car " +
            sujetAttaquant + " n'en a pas au moins 2 charg\xE9es");
          return;
        }
        evt.attributes = evt.attributes || [];
        if (attackLabel && options.grenaille) {
          var chargesGrenaille = tokenAttribute(attaquant, 'chargeGrenaille_' + attackLabel);
          if (chargesGrenaille.length > 0) {
            var currentChargeGrenaille = parseInt(chargesGrenaille[0].get('current'));
            if (isNaN(currentChargeGrenaille) || currentChargeGrenaille < 1) {
              sendPerso(attaquant, "ne peut pas attaquer avec " + weaponName + " car elle n'est pas charg\xE9e en grenaille");
              return;
            }
            if (options.tirDouble &&
              (!options.tirDouble.stats || options.tirDouble.label == attackLabel) &&
              currentChargeGrenaille < 2) {
              sendPerso(attaquant,
                "ne peut pas faire de tir double de grenaille avec ses" + weaponName + "s car " +
                sujetAttaquant + " n'en a pas au moins 2 charg\xE9es de grenaille");
              return;
            }
            evt.attributes.push({
              attribute: chargesGrenaille[0],
              current: currentChargeGrenaille
            });
            if (options.tirDouble &&
              (!options.tirDouble.stats || options.tirDouble.label == attackLabel)
            ) currentChargeGrenaille -= 2;
            else currentChargeGrenaille -= 1;
            chargesGrenaille[0].set('current', currentChargeGrenaille);
          }
        }
        evt.attributes.push({
          attribute: chargesArme[0],
          current: currentCharge
        });
        if (options.tirDouble &&
          (!options.tirDouble.stats || options.tirDouble.label == attackLabel)) currentCharge -= 2;
        else currentCharge -= 1;
        chargesArme[0].set('current', currentCharge);
        if (currentCharge === 0 &&
          predicateAsInt(attaquant, "initEnMain" + attackLabel, 0) > 0) {
          updateNextInit(attaquant);
        }
      }
      if (options.tirDouble && options.tirDouble.label && options.tirDouble.label != attackLabel) {
        let secondLabel = options.tirDouble.label;
        let secondNom = options.tirDouble.stats.name;
        let chargesSecondeArme = findObjs({
          _type: 'attribute',
          _characterid: attackingCharId,
          name: "charge_" + secondLabel
        });
        if (chargesSecondeArme.length > 0) {
          let currentCharge2 = parseInt(chargesSecondeArme[0].get('current'));
          if (isNaN(currentCharge2) || currentCharge2 < 1) {
            sendPerso(attaquant, "ne peut pas faire de tir double avec " + secondNom + " car ce n'est pas charg\xE9");
            return;
          }
          evt.attributes = evt.attributes || [];
          if (options.grenaille) {
            let chargesGrenaille2 = tokenAttribute(attaquant, 'chargeGrenaille_' + secondLabel);
            if (chargesGrenaille2.length > 0) {
              let currentChargeGrenaille2 = parseInt(chargesGrenaille2[0].get('current'));
              if (isNaN(currentChargeGrenaille2) || currentChargeGrenaille2 < 1) {
                sendPerso(attaquant, "ne peut pas faire de tir double avec " + secondNom + " car ce n'est pas charg\xE9 en grenaille");
                return;
              }
              evt.attributes.push({
                attribute: chargesGrenaille2[0],
                current: currentChargeGrenaille2
              });
              currentChargeGrenaille2 -= 1;
              chargesGrenaille2[0].set('current', currentChargeGrenaille2);
            }
          }
          evt.attributes.push({
            attribute: chargesSecondeArme[0],
            current: currentCharge2
          });
          chargesArme[0].set('current', currentCharge2 - 1);
          if (currentCharge2 == 1 &&
            predicateAsInt(attaquant, "initEnMain" + secondLabel, 0) > 0) {
            updateNextInit(attaquant);
          }
        }
      }
    }
    if (limiteRessources(attaquant, options, attackLabel, weaponName, evt, explications)) {
      return;
    }
    // Effets quand on rentre en combat
    entrerEnCombat(attaquant, cibles, explications, evt);
    // On commence par le jet d'attaque de base : juste le ou les d\xE9s d'attaque
    // et le modificateur d'arme et de caract\xE9ritiques qui apparaissent dans
    // la description de l'attaque. Il faut quand m\xEAme tenir compte des
    // chances de critique
    var crit = critEnAttaque(attaquant, weaponStats, options);
    var dice = 20;
    var malusAttaque = 0;
    if (!options.auto) {
      if (estAffaibli(attaquant)) {
        if (predicateAsBool(attaquant, 'insensibleAffaibli')) {
          malusAttaque = -2;
          explications.push("Attaquant affaibli, mais insensible => -2 en Attaque");
        } else {
          dice = 12;
          explications.push("Attaquant affaibli => D12 au lieu de D20 en Attaque");
        }
      } else if (getState(attaquant, 'immobilise')) {
        dice = 12;
        explications.push("Attaquant immobilis\xE9 => D12 au lieu de D20 en Attaque");
      } else if (attributeAsBool(attaquant, 'mortMaisNAbandonnePas')) {
        dice = 12;
        explications.push("Attaquant mort mais n'abandonne pas => D12 au lieu de D20 en Attaque");
      } else {
        var ebriete = attributeAsInt(attaquant, 'niveauEbriete', 0);
        if (ebriete > 0) {
          if (options.distance || options.sortilege || ebriete > 1) {
            dice = 12;
            if (ebriete > 3) ebriete = 3;
            explications.push("Attaquant " + niveauxEbriete[ebriete] + " => D12 au lieu de D20 en Attaque");
          }
        }
      }
    }
    if (options.avecd12) {
      dice = 12;
      if (options.avecd12.crit) crit = Math.floor(crit / 2) + 3;
    }
    var nbDe = 1;
    var plusFort = true;
    if (options.avantage !== undefined) {
      if (options.avantage > 0) nbDe = options.avantage;
      else {
        nbDe = 2 - options.avantage; //d\xE9savantage
        plusFort = false;
      }
    }
    // toEvaluateAttack inlines
    // 0: attack roll
    // 1: attack skill expression
    // 2: d\xE9 de poudre
    let toEvaluateAttack =
      attackExpression(attaquant, nbDe, dice, crit, plusFort, weaponStats);
    if (options.poudre) toEvaluateAttack += " [[1d20]]";
    try {
      sendChat('', toEvaluateAttack, function(resAttack) {
        let rollsAttack = resAttack[0];
        if (options.rolls && options.rolls.attack)
          rollsAttack = options.rolls.attack;
        let afterEvaluateAttack = rollsAttack.content.split(' ');
        let attRollNumber = rollNumber(afterEvaluateAttack[0]);
        let attSkillNumber = rollNumber(afterEvaluateAttack[1]);
        let d20roll = rollsAttack.inlinerolls[attRollNumber].results.total;
        let attSkill = rollsAttack.inlinerolls[attSkillNumber].results.total;
        evt.type = 'Attaque';
        evt.succes = true;
        evt.action.playerId = playerId;
        evt.action.attaquant = attaquant;
        evt.action.cibles = cibles;
        evt.action.weaponStats = weaponStats;
        evt.action.rolls = evt.action.rolls || {};
        evt.action.rolls.attack = rollsAttack;
        // debut de la partie affichage
        let action = "<b>Arme</b> : ";
        if (options.sortilege) action = "<b>Sort</b> : ";
        let label_type = BS_LABEL_INFO;
        let target = cibles[0];
        if (options.aoe || cibles.length > 1) {
          target = undefined;
          label_type = BS_LABEL_WARNING;
        }
        action += "<span style='" + BS_LABEL + " " + label_type + "; text-transform: none; font-size: 100%;'>" + weaponName + "</span>";
        let display = startFramedDisplay(playerId, action, attaquant, {
          perso2: target,
          chuchote: options.secret,
          retarde: options.secret,
          auto: options.auto || options.ouvertureMortelle
        });
        // Cas des armes \xE0 poudre
        if (options.poudre && !predicateAsBool(attaquant, 'chimiste')) {
          let poudreNumber = rollNumber(afterEvaluateAttack[2]);
          let dePoudre = rollsAttack.inlinerolls[poudreNumber].results.total;
          explications.push(
            "D\xE9 de poudre : " + buildinline(rollsAttack.inlinerolls[poudreNumber]));
          if (dePoudre === 1) {
            evt.succes = false;
            if (d20roll === 1) {
              explications.push(
                weaponName + " explose ! L'arme est compl\xE8tement d\xE9truite");
              sendChat("", "[[2d6]]", function(res) {
                var rolls = res[0];
                var explRoll = rolls.inlinerolls[0];
                var r = {
                  total: explRoll.results.total,
                  type: 'normal',
                  display: buildinline(explRoll, 'normal')
                };
                dealDamage(attaquant, r, [], evt, false, options, explications,
                  function(dmgDisplay, dmg) {
                    var dmgMsg = "<b>Dommages pour " + attackerTokName + " :</b> " +
                      dmgDisplay;
                    addLineToFramedDisplay(display, dmgMsg);
                    finaliseDisplay(display, explications, evt, attaquant, cibles, options);
                  });
              });
            } else {
              explications.push(
                "La poudre explose dans " + weaponName +
                ". L'arme est inutilisable jusqu'\xE0 la fin du combat");
              sendChat("", "[[1d6]]", function(res) {
                var rolls = res[0];
                var explRoll = rolls.inlinerolls[0];
                var r = {
                  total: explRoll.results.total,
                  type: 'normal',
                  display: buildinline(explRoll, 'normal')
                };
                dealDamage(attaquant, r, [], evt, false, options, explications,
                  function(dmgDisplay, dmg) {
                    var dmgMsg =
                      "<b>Dommages pour " + attackerTokName + " :</b> " +
                      dmgDisplay;
                    addLineToFramedDisplay(display, dmgMsg);
                    finaliseDisplay(display, explications, evt, attaquant, cibles, options);
                  });
              });
            }
            return;
          } else if (d20roll == dePoudre) {
            evt.succes = false;
            addLineToFramedDisplay(display,
              "<b>Attaque :</b> " +
              buildinline(rollsAttack.inlinerolls[attRollNumber]));
            explications.push(weaponName + " fait long feu, le coup ne part pas");
            finaliseDisplay(display, explications, evt, attaquant, cibles, options);
            return;
          }
        }
        if (!options.auto && d20roll > 14) {
          if (predicateAsBool(attaquant, 'saisirEtBroyer')) {
            options.saisirEtBroyer = true;
          } else if (predicateAsBool(attaquant, 'projection')) {
            options.projection = true;
          }
        }
        //Modificateurs en Attaque qui ne d\xE9pendent pas de la cible
        var attBonusCommun =
          bonusAttaqueA(attaquant, weaponName, evt, explications, options);
        attBonusCommun += malusAttaque;
        if (options.traquenard) {
          if (attributeAsBool(attaquant, 'traquenardImpossible')) {
            sendPerso(attaquant, "ne peut pas faire de traquenard, car ce n'est pas sa premi\xE8re attaque du combat");
            return;
          }
          options.traquenard = persoInit(attaquant, evt);
        }
        if (predicateAsBool(attaquant, 'traquenard') && !attributeAsBool(attaquant, 'traquenardImpossible')) {
          setTokenAttr(attaquant, 'traquenardImpossible', true, evt);
        }
        if (options.feinte) explications.push("Mais c'\xE9tait une feinte...");
        var mainDmgType = options.type || 'normal';
        if (options.sortilege) options.ignoreObstacles = true;
        var echecCritique;
        //Calcul des cibles touch\xE9es
        //(et on ajuste le jet pour la triche)
        let ciblesTouchees = [];
        let count = cibles.length;
        cibles.forEach(function(target) {
          // reset les champs de target qui vont \xEAtre recalcul\xE9s
          target.additionalDmg = [];
          target.effets = [];
          target.dmgCoef = 0;
          target.critCoef = 0;
          target.diviseDmg = 1;
          if (attributeAsBool(attaquant, 'menaceManoeuvre(' + target.token.id + ')')) {
            explications.push(attaquant.tokName + " attaque " + target.tokName + " malgr\xE9 la menace. " + target.tokName + " a droit \xE0 une attaque au contact gratuite.");
            removeTokenAttr(attaquant, 'menaceManoeuvre(' + target.token.id + ')', evt);
            setTokenAttr(attaquant, 'attaqueMalgreMenace(' + target.token.id + ')', 1, evt);
          } else if (attributeAsBool(attaquant, 'menaceManoeuvre(' + target.token.id + ',crit)')) {
            explications.push(attaquant.tokName + " attaque " + target.tokName + " malgr\xE9 la menace. " + target.tokName + " a droit \xE0 une attaque au contact gratuite (DM x 2 !).");
            removeTokenAttr(attaquant, 'menaceManoeuvre(' + target.token.id + ',crit)', evt);
            setTokenAttr(attaquant, 'attaqueMalgreMenace(' + target.token.id + ')', 2, evt);
          }
          var amm = 'attaqueMalgreMenace(' + attaquant.token.id + ')';
          if (options.contact && cibles.length == 1) {
            if (attributeAsBool(target, amm)) {
              target.messages.push('Attaque automatique suite \xE0 une menace ignor\xE9e');
              options.auto = true;
              if (attributeAsInt(target, amm, 1) > 1) options.dmFoisDeux = true;
              target.additionalDmg.push({
                type: mainDmgType,
                value: '1d6'
              });
              removeTokenAttr(target, amm, evt);
            }
          }
          evalITE(attaquant, target, d20roll, options, 0, evt, explications, options, function() {
            target.ignoreTouteRD = target.ignoreTouteRD || options.ignoreTouteRD;
            target.ignoreRD = target.ignoreRD || options.ignoreRD;
            target.ignoreMoitieRD = target.ignoreMoitieRD || options.ignoreMoitieRD;
            target.tempDmg = target.tempDmg || options.tempDmg;
            target.enflamme = target.enflamme || options.enflamme;
            target.malediction = target.malediction || options.malediction;
            target.pietine = target.pietine || options.pietine;
            target.percute = target.percute || options.percute;
            target.maxDmg = target.maxDmg || options.maxDmg;
            //Les bonus d'attaque qui d\xE9pendent de la cible
            let bad = 0;
            if (!options.auto) bad = bonusAttaqueD(attaquant, target, weaponStats.portee, pageId, evt, target.messages, options);
            let attBonus = attBonusCommun + bad;
            if (options.traquenard) {
              var initTarg = persoInit(target, evt);
              if (options.traquenard >= initTarg) {
                attBonus += 2;
                target.additionalDmg.push({
                  type: mainDmgType,
                  value: '2' + options.d6
                });
                target.messages.push(attackerTokName + " fait un traquenard \xE0 " + target.tokName);
              } else {
                target.messages.push(attackerTokName + " n'est pas assez rapide pour faire un traquenard \xE0 " + target.tokName);
              }
            }
            let defautCuirasse =
              tokenAttribute(target, 'defautDansLaCuirasse_' + attackerTokName);
            target.crit = crit;
            if (defautCuirasse.length > 0) {
              target.defautCuirasse = true;
              if (target.crit > 2) target.crit -= 1;
            }
            //Defense de la cible
            let defense = 0;
            if (!options.auto) defense = defenseOfPerso(attaquant, target, pageId, evt, options);
            let interchange;
            if (options.aoe === undefined) {
              interchange = interchangeable(attackingToken, target, pageId);
              if (interchange.result) {
                if (reglesOptionelles.divers.val.interchangeable_attaque.val) {
                  defense += 2;
                } else {
                  defense += 5;
                }
              }
            }
            if (target.msgEsquiveFatale) {
              target.messages.push(target.msgEsquiveFatale);
            }
            if (options.etreinteImmole && attributeAsBool(target, 'etreinteImmolePar')) {
              options.auto = true;
              target.etreinteImmole = true;
            }
            let touche = true;
            let critique = false;
            // Calcule si touch\xE9, et les messages de d\xE9gats et attaque
            if (options.auto) {
              addAttackSound("soundAttackSucces", weaponStats.divers, options);
            } else if (!options.interposer) {
              let triche = options.triche || options.interventionDivine;
              if (triche) {
                switch (triche) {
                  case "rate":
                    if (d20roll >= target.crit) {
                      if (target.crit < 2) d20roll = 1;
                      else d20roll = randomInteger(target.crit - 1);
                    }
                    if ((d20roll + attSkill + attBonus) >= defense) {
                      let maxd20roll = defense - attSkill - attBonus - 1;
                      if (maxd20roll >= target.crit) maxd20roll = target.crit - 1;
                      if (maxd20roll < 2) d20roll = 1;
                      else d20roll = randomInteger(maxd20roll);
                    }
                    break;
                  case "touche":
                    if (d20roll == 1) d20roll = randomInteger(dice - 1) + 1;
                    if ((d20roll + attSkill + attBonus) < defense) {
                      var mind20roll = defense - attSkill - attBonus - 1;
                      if (mind20roll < 1) mind20roll = 1;
                      if (mind20roll >= dice) d20roll = dice;
                      else d20roll = randomInteger(dice - mind20roll) + mind20roll;
                    }
                    break;
                  case "critique":
                    if (d20roll < target.crit) {
                      if (target.crit <= dice) d20roll = randomInteger(dice - target.crit + 1) + target.crit - 1;
                      else d20roll = dice;
                    }
                    break;
                  case "echecCritique":
                    if (d20roll > 1) d20roll = 1;
                    break;
                  case 'pasDEchecCritique':
                    if (d20roll == 1) d20roll = randomInteger(dice - 1) + 1;
                    break;
                  default:
                    error("Option inconnue", triche);
                }
                // now adjust the roll
                var attackInlineRoll = rollsAttack.inlinerolls[attRollNumber];
                attackInlineRoll.results.total = d20roll;
                attackInlineRoll.results.rolls.forEach(function(roll) {
                  if (roll.type == 'R' && roll.results.length == 1) {
                    roll.results[0].v = d20roll;
                  }
                });
              }
              var targetd20roll = d20roll;
              if (target.chatimentDuMale) {
                target.chatimentDuMaleRoll = target.chatimentDuMaleRoll || randomInteger(dice);
                target.chatimentDuMaleLowRoll = target.chatimentDuMaleRoll;
                target.messages.push("B\xE9n\xE9diction de Ma\xEBdra => relance \xE0 " + target.chatimentDuMaleRoll + " du jet d'attaque contre un m\xE2le");
                if (target.chatimentDuMaleRoll > targetd20roll) {
                  targetd20roll = target.chatimentDuMaleRoll;
                  target.chatimentDuMaleLowRoll = target.d20roll;
                }
              }
              var attackRoll = targetd20roll + attSkill + attBonus;
              target.attackRoll = attackRoll;
              var attackResult; // string
              var paralyse = false;
              if (getState(target, 'paralyse')) {
                paralyse = true;
                if (!options.attaqueAssuree)
                  target.messages.push("Cible paralys\xE9e => r\xE9ussite critique automatique");
              }
              if (targetd20roll >= 15) {
                if (predicateAsBool(attaquant, 'champion'))
                  options.champion = true;
                if (options.contact) {
                  if (predicateAsBool(attaquant, 'agripper'))
                    options.agripper = true;
                  if (predicateAsBool(attaquant, 'devorer'))
                    options.devorer = true;
                  if (predicateAsBool(attaquant, 'gober'))
                    options.gober = true;
                }
                if (options.etreinteImmole) {
                  setTokenAttr(attaquant, 'etreinteImmole', target.token.id + ' ' + target.tokName, evt);
                  setTokenAttr(target, 'etreinteImmolePar', attaquant.token.id + ' ' + attaquant.tokName, evt);
                  setState(target, 'immobilise', true, evt);
                  target.messages.push(attaquant.tokName + " \xE9treint " + target.tokName + " et s'immole !");
                  target.etreinteImmole = true;
                }
                if (options.etreinteScorpion) {
                  setTokenAttr(attaquant, 'etreinteScorpionSur', target.token.id + ' ' + target.tokName, evt);
                  setTokenAttr(target, 'etreinteScorpionPar', attaquant.token.id + ' ' + attaquant.tokName, evt);
                  target.messages.push(attaquant.tokName + " \xE9treint " + target.tokName + " !");
                }
              }
              if (targetd20roll >= 17 && options.contact &&
                predicateAsBool(attaquant, 'crocEnJambe')) {
                if (targetd20roll >= 19 || !estQuadrupede(target)) {
                  setState(target, 'renverse', true, evt);
                  target.messages.push("tombe par terre");
                }
              }
              if (options.attaqueDeGroupe > 1 &&
                reglesOptionelles.haute_DEF.val.crit_attaque_groupe.val > 0 &&
                attackRoll >= (defense + reglesOptionelles.haute_DEF.val.crit_attaque_groupe.val)) {
                options.attaqueDeGroupeDmgCoef = true;
              }
              let faireMouche;
              if (targetd20roll == 1 && options.chance === undefined) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_DANGER + "'><b>\xE9chec&nbsp;critique</b></span>";
                attackResult += addAttackImg("imgAttackEchecCritique", weaponStats.divers, options);
                addAttackSound('soundAttackEchecCritique', weaponStats.divers, options);
                if (options.demiAuto) {
                  target.partialSaveAuto = true;
                  evt.succes = false;
                } else if (options.dmSiRate) {
                  target.dmRate = true;
                  evt.succes = false;
                } else touche = false;
                echecCritique = true;
                increaseTenacite(attaquant, target, evt);
              } else if ((paralyse || options.ouvertureMortelle || targetd20roll == 20 ||
                  (targetd20roll >= target.crit && attackRoll >= defense) ||
                  (reglesOptionelles.divers.val.coups_critiques_etendus.val && attackRoll > defense + 9)) && !options.attaqueAssuree) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>r\xE9ussite critique</b></span>";
                attackResult += addAttackImg("imgAttackSuccesCritique", weaponStats.divers, options);
                addAttackSound('soundAttackSuccesCritique', weaponStats.divers, options);
                touche = true;
                critique = true;
                if (options.contact) {
                  if (attributeAsBool(target, 'enerve')) {
                    if (faireMouche === undefined)
                      faireMouche = predicateAsInt(attaquant, 'faireMouche', 0);
                    if (faireMouche > 0) target.faireMouche = (target.faireMouche || 0) + faireMouche;
                  }
                  if (predicateAsBool(attaquant, 'briseurDOs')) {
                    target.osBrises = true;
                  }
                }
                resetTenacite(attaquant, target, evt);
              } else if (options.champion || targetd20roll == 20 || paralyse) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succ\xE8s</b></span>";
                attackResult += addAttackImg("imgAttackSuccesChampion", weaponStats.divers, options);
                addAttackSound("soundAttackSuccesChampion", weaponStats.divers, options);
                resetTenacite(attaquant, target, evt);
              } else if (attackRoll < defense && targetd20roll < target.crit) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>\xE9chec</b></span>";
                attackResult += addAttackImg("imgAttackEchec", weaponStats.divers, options);
                addAttackSound('soundAttackEchec', weaponStats.divers, options);
                evt.succes = false;
                if (options.demiAuto) {
                  target.partialSaveAuto = true;
                } else if (options.dmSiRate) {
                  target.dmRate = true;
                  evt.succes = false;
                } else touche = false;
                increaseTenacite(attaquant, target, evt);
              } else if (targetd20roll % 2 && attributeAsBool(target, 'clignotement')) {
                target.messages.push(target.tokName + " dispara\xEEt au moment o\xF9 l'attaque aurait du l" + onGenre(target, 'e', 'a') + " toucher");
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>\xE9chec</b></span>";
                attackResult += addAttackImg("imgAttackEchecClignotement", weaponStats.divers, options);
                addAttackSound('soundAttackEchecClignotement', weaponStats.divers, options);
                target.clignotement = true;
                if (options.demiAuto) {
                  target.partialSaveAuto = true;
                } else if (options.dmSiRate) {
                  target.dmRate = true;
                  evt.succes = false;
                } else touche = false;
              } else { // Touch\xE9 normal
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succ\xE8s</b></span>";
                attackResult += addAttackImg("imgAttackSucces", weaponStats.divers, options);
                addAttackSound("soundAttackSucces", weaponStats.divers, options);
                resetTenacite(attaquant, target, evt);
              }
              let attRollValue;
              let bonusTexte = '';
              if (attSkill > 0) bonusTexte += "+" + attSkill;
              else if (attSkill < 0) bonusTexte += attSkill;
              if (attBonus > 0) bonusTexte += "+" + attBonus;
              else if (attBonus < 0) bonusTexte += attBonus;
              if (ficheAttributeAsBool(attaquant, 'jets_caches', false)) {
                attRollValue = attackRoll;
                sendChat('COF', "/w GM Jet cach\xE9 d'attaque : " + buildinline(rollsAttack.inlinerolls[attRollNumber]) + bonusTexte);
              } else {
                attRollValue = buildinline(rollsAttack.inlinerolls[attRollNumber]) + bonusTexte;
              }
              var line = "<b>Attaque</b> ";
              if (options.aoe || cibles.length > 1) {
                line += "contre <b>" + target.tokName + "</b> ";
              }
              line += ":<br>";
              line += attRollValue + ' ';
              if (stateCOF.options.affichage.val.montre_def.val) {
                line += "vs <b>" + defense + "</b> ";
              }
              line += attackResult;
              if (options.test) line += " (" + attackRoll + ")";
              target.attackMessage = line;
              if (touche) {
                if (options.asDeLaGachette && attackRoll > 24) {
                  target.messages.push("As de la gachette => + 1" + options.d6 + " aux DM");
                  target.additionalDmg.push({
                    type: mainDmgType,
                    value: '1' + options.d6
                  });
                }
                //Botte mortelle (barde et duelliste)
                if (options.contact && !options.feinte && !options.attaqueAssuree && !options.pasDeDmg && attackRoll > defense + 4 &&
                  predicateAsBool(attaquant, 'botteMortelle')) {
                  if (faireMouche === undefined)
                    faireMouche = predicateAsInt(attaquant, 'faireMouche', 0);
                  if (faireMouche > 0) { //botte mortelle du duelliste
                    if (target.faireMouche) {
                      var bonusBotteMortelle = Math.floor((attackRoll - defense) / 5) + options.d6;
                      target.messages.push("Botte mortelle => + " + bonusBotteMortelle + " aux DM");
                      target.additionalDmg.push({
                        type: mainDmgType,
                        value: bonusBotteMortelle
                      });
                    } else if (attackRoll > defense + 9) {
                      target.messages.push("Botte mortelle => l'attaque fait mouche");
                      target.faireMouche = faireMouche;
                    }
                  } else if (attackRoll > defense + 9) { //botte mortelle du barde
                    target.messages.push("Botte mortelle => + 2" + options.d6 + " aux DM");
                    target.additionalDmg.push({
                      type: mainDmgType,
                      value: '2' + options.d6
                    });
                  }
                }
                if (target.chatimentDuMale) {
                  if (target.chatimentDuMaleLowRoll + attSkill + attBonus >= defense) {
                    target.additionalDmg.push({
                      type: mainDmgType,
                      value: '2' + options.d6
                    });
                    target.messages.push("Ch\xE2timent du m\xE2le => +2d6 DM");
                  }
                }
                if (attributeAsBool(target, 'momentDePerfection')) {
                  target.messages.push("Gr\xE2ce \xE0 son instant de perfection, " + target.tokName + " \xE9vite le coup !");
                  touche = false;
                  evt.succes = false;
                }
              } else { //Effet si on ne touche pas
                if (attributeAsBool(attaquant, 'momentDePerfection')) {
                  target.messages.push("Gr\xE2ce \xE0 son instant de perfection, " + attaquant.tokName + " touche !");
                  touche = true;
                  evt.succes = true;
                } else {
                  // Draw failed effect
                  if (_.has(options, "fx") && options.distance) {
                    var p1 = {
                      x: attackingToken.get('left'),
                      y: attackingToken.get('top')
                    };
                    var p2 = {
                      x: target.token.get('left'),
                      y: target.token.get('top')
                    };
                    // Compute some gaussian deviation in [0, 1]
                    var dev =
                      (Math.random() + Math.random() + Math.random() + Math.random() +
                        Math.random() + 1) / 6;
                    // take into account by how far we miss
                    dev = dev * (targetd20roll == 1) ? 2 : ((attackRoll - defense) / 20);
                    if (Math.random() > 0.5) dev = -dev;
                    p2.x += dev * (p2.y - p1.y);
                    p2.y += dev * (p2.x - p1.x);
                    spawnFxBetweenPoints(p1, p2, options.fx, pageId);
                  }
                  if (target.clignotement === undefined) {
                    evt.succes = false;
                    diminueMalediction(attaquant, evt);
                  }
                }
              }
            }
            target.touche = touche;
            target.critique = critique;
            target.attaqueCalculee = true;
            if (options.aoe === undefined && interchange.targets.length > 1) { //any target can be affected
              var n = randomInteger(interchange.targets.length);
              target.token = interchange.targets[n - 1];
            }
            if (target.touche) {
              if (attributeAsBool(target, 'imageDecalee')) {
                if (target.rollImageDecalee === undefined) {
                  target.rollImageDecalee = rollDePlus(6);
                }
                var id = target.rollImageDecalee;
                if (id.val > 4) {
                  target.touche = false;
                  target.messages.push(id.roll + ": l'attaque passe \xE0 travers l'image de " + target.tokName);
                } else {
                  target.messages.push(id.roll + ": malgr\xE9 l'image l\xE9g\xE8rement d\xE9cal\xE9e de " + target.tokName + " l'attaque touche");
                }
              } else if (predicateAsBool(target, 'estUneIllusion')) {
                target.touche = false;
                target.messages.push(target.tokName + " disparait et se mat\xE9rialise un peu plus loin");
              }
            }
            if (target.touche) {
              ciblesTouchees.push(target);
              //Possibilit\xE9s d'annuler l'attaque
              if (!options.pasDeDmg && isActive(target) &&
                attributeAsBool(target, 'runeForgesort_protection') &&
                attributeAsInt(target, 'limiteParCombat_runeForgesort_protection', 1) > 0) {
                options.preDmg = options.preDmg || {};
                options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                options.preDmg[target.token.id].runeForgesort_protection = true;
              }
              if (!options.auto) {
                //Seulement si elle n'est pas automatiquement r\xE9ussie
                if (isActive(target)) {
                  if (!options.pasDeDmg && options.contact && !options.ignoreTouteRD) {
                    if (attributeAsBool(target, 'encaisserUnCoup')) {
                      options.preDmg = options.preDmg || {};
                      options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                      options.preDmg[target.token.id].encaisserUnCoup = true;
                    }
                    if (ficheAttributeAsInt(target, 'defbouclieron', 0) > 0) {
                      let test = testLimiteUtilisationsCapa(target, 'devierLesCoups', 'tour');
                      if (test) {
                        options.preDmg = options.preDmg || {};
                        options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                        options.preDmg[target.token.id].devierLesCoups = test;
                      }
                    }
                  }
                  if (options.distance && !options.sortilege && !options.poudre && cibles.length == 1 && !target.critique) {
                    let test = testLimiteUtilisationsCapa(target, 'paradeDeProjectiles', 'tour');
                    if (test) {
                      options.preDmg = options.preDmg || {};
                      options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                      options.preDmg[target.token.id].paradeDeProjectiles = test;
                    }
                  }
                  if (options.contact &&
                    capaciteDisponible(target, 'paradeAuBouclier', 'tour') &&
                    ficheAttributeAsInt(target, 'defbouclieron', 0) > 0) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].paradeAuBouclier = true;
                  }
                  if (capaciteDisponible(target, 'esquiveAcrobatique', 'tour')) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].esquiveAcrobatique = true;
                  }
                  if (predicateAsBool(target, 'expertDuCombat') &&
                    attributeAsInt(target, 'limiteParCombat_expertDuCombat', 1) > 0 &&
                    attributeAsInt(target, 'limiteParTour_expertDuCombat', 1) > 0 &&
                    (!options.expertDuCombatDEF || !options.expertDuCombatDEF[target.token.id])) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].expertDuCombatDEF = true;
                  }
                  if (!options.sortilege && !options.aoe &&
                    capaciteDisponible(target, 'paradeMagistrale', 'tour')) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].paradeMagistrale = true;
                  }
                  if (!options.aoe && capaciteDisponible(target, 'esquiveFatale', 'combat')) {
                    if (target.ennemisAuContact === undefined) {
                      error(target.token.get('name') + " a la possibilit\xE9 d'une esquive fatale, mais les ennemis au contact ne sont pas calcul\xE9s", target);
                    } else {
                      var ciblesEsquiveFatale = target.ennemisAuContact.filter(function(tok) {
                        return (tok.id != attaquant.token.id);
                      });
                      if (ciblesEsquiveFatale.length > 0) {
                        options.preDmg = options.preDmg || {};
                        options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                        options.preDmg[target.token.id].esquiveFatale = ciblesEsquiveFatale;
                      }
                    }
                  }
                  if (options.sortilege) {
                    if (attributeAsBool(target, 'absorberUnSort') &&
                      ficheAttributeAsInt(target, 'defbouclieron', 0) == 1) {
                      options.preDmg = options.preDmg || {};
                      options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                      options.preDmg[target.token.id].absorberUnSort = true;
                    }
                  } else {
                    if (attributeAsBool(target, 'absorberUnCoup') &&
                      ficheAttributeAsInt(target, 'defbouclieron', 0) == 1) {
                      options.preDmg = options.preDmg || {};
                      options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                      options.preDmg[target.token.id].absorberUnCoup = true;
                    }
                  }
                }
                if (options.sortilege) {
                  if (capaciteDisponible(target, 'resistanceALaMagieBarbare', 'tour')) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].resistanceALaMagieBarbare = true;
                  }
                  if (attributeAsBool(target, 'cercleDeProtection')) {
                    var attrs = tokenAttribute(target, 'cercleDeProtectionValeur');
                    if (attrs.length > 0) {
                      var protecteur = persoOfId(attrs[0].get('current'));
                      if (protecteur) {
                        if (attributeAsInt(protecteur, "cercleDeProtectionActif", 0) > 0) {
                          options.preDmg = options.preDmg || {};
                          options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                          options.preDmg[target.token.id].cercleDeProtection = true;
                          options.preDmg[target.token.id].cercleDeProtectionDe = protecteur.token.get("name");
                        }
                      }
                    }
                  }
                }
              }
              if (capaciteDisponible(target, 'chairACanon', 'tour') &&
                target.chairACanon && target.chairACanon.length > 0) {
                options.preDmg = options.preDmg || {};
                options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                options.preDmg[target.token.id].chairACanon = target.chairACanon;
              }
              //Interception par un alli\xE9
              let alliesAvecInterception = [];
              if (target.alliesAuContact === undefined) {
                let allies = alliesParPerso[target.charId] || new Set();
                let tokensContact;
                allies.forEach(function(ci) {
                  if (charPredicateAsBool(ci, 'intercepter')) {
                    if (tokensContact === undefined) {
                      tokensContact = findObjs({
                        _type: 'graphic',
                        _subtype: 'token',
                        _pageid: pageId,
                        layer: 'objects'
                      });
                      tokensContact = tokensContact.filter(function(tok) {
                        if (tok.id == target.token.id) return false;
                        return distanceCombat(target.token, tok, pageId) === 0;
                      });
                    }
                    tokensContact.forEach(function(tok) {
                      if (tok.get('represents') != ci) return;
                      let perso = {
                        token: tok,
                        charId: ci
                      };
                      if (!isActive(perso)) return;
                      if (!capaciteDisponible(perso, 'intercepter', 'tour')) return;
                      alliesAvecInterception.push(perso);
                    });
                  }
                });
              } else {
                target.alliesAuContact.forEach(function(tok) {
                  let perso = {
                    token: tok,
                    charId: tok.get('represents')
                  };
                  if (!isActive(perso)) return;
                  if (!capaciteDisponible(perso, 'intercepter', 'tour')) return;
                  alliesAvecInterception.push(perso);
                });
              }
              //On enl\xE8ve les alli\xE9s qui sont cibles de l'attaque
              alliesAvecInterception = alliesAvecInterception.filter(function(p) {
                return cibles.every(function(c) {
                  return c.token.id != p.token.id;
                });
              });
              if (alliesAvecInterception.length > 0) {
                options.preDmg = options.preDmg || {};
                options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                options.preDmg[target.token.id].alliesAvecInterception = alliesAvecInterception;
              }
            }
            if (options.feinte) {
              let niveauTouche = 0;
              if (target.touche) niveauTouche = 1;
              if (target.critique) niveauTouche = 2;
              setTokenAttr(target, 'feinte_' + attaquant.tokName, 0, evt, {
                maxVal: niveauTouche
              });
            }
            count--;
            if (count === 0) {
              if (ciblesTouchees.length > 0 && !options.maxDmg && evt.action.weaponStats) {
                let al = evt.action.weaponStats.label;
                if ((options.runeDePuissance &&
                    attributeAsInt(attaquant, 'limiteParCombat_runeDePuissance' + al, 1)) ||
                  (attributeAsBool(attaquant, 'runeForgesort_puissance(' + al + ')') &&
                    attributeAsInt(attaquant, 'limiteParCombat_runeForgesort_puissance(' + al + ')', 1))) {
                  options.preDmg = options.preDmg || {};
                  options.preDmg.runeDePuissance = al;
                }
              }
              resolvePreDmgOptions(attaquant, ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles);
            }
          });
        }); //fin de d\xE9termination de toucher des cibles
      }); // fin du jet d'attaque asynchrone
    } catch (e) {
      error("Erreur pendant l'\xE9valuation de " + toEvaluateAttack + " du test d'attaque", weaponStats);
      log(e.name + ": " + e.message);
    }
  }

  function eForFemale(perso) {
    return onGenre(perso, '', 'e');
  }

  function stringOfEtat(etat, perso) {
    if (etat == 'invisible') return etat;
    else if (etat == 'penombre') return "dans la p\xE9nombre";
    var etext = etat;
    if (etat.endsWith('e')) {
      etext = etat.substring(0, etat.length - 1) + '\xE9';
    }
    if (perso === undefined) return etext;
    return etext + eForFemale(perso);
  }

  function findAttackParam(attackParam, divers, options) {
    let param = options[attackParam];
    if (param) return param;
    let subParam = attackParam;
    let subParamIndex = subParam.indexOf('C');
    if (subParamIndex > 0) {
      subParam = subParam.substring(0, subParamIndex);
      param = options[subParam];
      if (param) return param;
    }
    subParamIndex = subParam.indexOf('E');
    if (subParamIndex > 0) {
      subParam = subParam.substring(0, subParamIndex);
      param = options[subParam];
      if (param) return param;
    }
    subParamIndex = subParam.indexOf('S');
    if (subParamIndex > 0) {
      subParam = subParam.substring(0, subParamIndex);
      param = options[subParam];
      if (param) return param;
    }
    let tag = attackParam.replace(/[A-Z]/g, function(c) {
      return '-' + c.toLowerCase();
    });
    tag = '[' + tag + ']';
    if (divers.includes(tag)) {
      let soundAttack = divers.split(tag);
      if (soundAttack.length > 2) {
        param = soundAttack[1];
      }
    }
    return param;
  }

  function playSound(sound) {
    var AMdeclared;
    try {
      AMdeclared = Roll20AM;
    } catch (e) {
      if (e.name != "ReferenceError") throw (e);
    }
    if (AMdeclared) {
      //With Roll20 Audio Master
      sendChat("GM", "!roll20AM --audio,play,nomenu|" + sound);
    } else {
      var jukebox = findObjs({
        type: 'jukeboxtrack',
        title: sound
      });
      jukebox.forEach(function(track) {
        track.set({
          playing: true,
          softstop: false
        });
      });
    }
  }

  function addAttackSound(attackParam, divers, options) {
    let sound = findAttackParam(attackParam, divers, options);
    if (!sound) {
      switch (attackParam) {
        case 'soundAttackEchecCritique':
          sound = stateCOF.options.sons.val.attaque_echec_critique.val;
          break;
        case 'soundAttackSuccesCritique':
          sound = stateCOF.options.sons.val.attaque_reussite_critique.val;
          break;
      }
    }
    if (sound) playSound(sound);
  }

  function addAttackImg(attackParam, divers, options) {
    let img = findAttackParam(attackParam, divers, options);
    if (img !== '' && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
      let newLineimg = '<span style="padding: 4px 0;" >  ';
      newLineimg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
      newLineimg += '</span>';
      return newLineimg;
    }
    return '';
  }

  function computeAttackDice(d, maxDmg, options) {
    if (isNaN(d) || d < 0) {
      error("D\xE9 d'attaque incorrect", d);
      return 0;
    }
    let attDice = d;
    if (options.puissant) {
      attDice += 2;
    }
    if (maxDmg) return attDice; //Dans ce cas, pas de reroll ni d'explosion
    if (options.reroll1) attDice += "r1";
    if (options.reroll2) attDice += "r2";
    if (options.explodeMax) attDice += '!';
    else if (options.poudre && reglesOptionelles.divers.val.poudre_explosif.val) attDice += '!p';
    return attDice;
  }

  function computeMainDmgRollExpr(attaquant, target, weaponStats, attNbDices, attDMBonus, options) {
    let attDMArme = weaponStats.attDMBonusCommun;
    if (isNaN(attDMArme) || attDMArme === 0) attDMArme = '';
    else if (attDMArme > 0) attDMArme = '+' + attDMArme;
    attDMBonus = attDMArme + attDMBonus;
    let attNbDicesCible = attNbDices;
    let attDiceCible = computeAttackDice(weaponStats.attDice, target.maxDmg, options);
    let attCarBonusCible =
      computeAttackCarBonus(attaquant, weaponStats.attCarBonus);
    if (options.epieu && !ficheAttributeAsBool(target, 'defarmureon', false)) {
      attNbDicesCible++;
    }
    if (target.pressionMortelle) {
      attNbDicesCible = 1;
      attDiceCible = 6; //TODO : have an option for that
      attCarBonusCible = '';
    }
    if (!options.sortilege && predicateAsBool(target, 'immuniteAuxArmes')) {
      if (options.magique) {
        attNbDicesCible = options.magique;
        attDiceCible = '6';
        attCarBonusCible = modCarac(attaquant, 'sagesse');
        if (attCarBonusCible < 1) attCarBonusCible = '';
        else attCarBonusCible = " +" + attCarBonusCible;
      } else {
        target.messages.push(target.tokName + " semble immunis\xE9 aux armes ordinaires");
        attNbDicesCible = 0;
        attCarBonusCible = "";
        attDMBonus = "";
      }
    }
    let symbde = 'd';
    if (target.maxDmg) symbde = '*';
    return addOrigin(attaquant.name, attNbDicesCible + symbde + attDiceCible + attCarBonusCible + attDMBonus);
  }

  //retourne le mod de la caract\xE9ristique x, undefined si ce n'en est pas une
  function computeCarExpression(perso, x) {
    switch (x) {
      case '@{FOR}':
        return modCarac(perso, 'force');
      case '@{DEX}':
        return modCarac(perso, 'dexterite');
      case '@{CON}':
        return modCarac(perso, 'constitution');
      case '@{INT}':
        return modCarac(perso, 'intelligence');
      case '@{SAG}':
        return modCarac(perso, 'sagesse');
      case '@{CHA}':
        return modCarac(perso, 'charisme');
      default:
        return;
    }
  }

  function addEffetTemporaireLie(perso, attr, evt) {
    var etlAttr = tokenAttribute(perso, 'effetsTemporairesLies');
    if (etlAttr.length === 0) {
      etl = '';
      etlAttr = createObj('attribute', {
        characterid: perso.charId,
        name: 'effetsTemporairesLies',
        current: attr.id,
      });
      evt.attributes.push({
        attribute: etlAttr,
      });
      return;
    }
    etlAttr = etlAttr[0];
    var etl = etlAttr.get('current');
    evt.attributes.push({
      attribute: etlAttr,
      current: etl
    });
    if (etl === '') etl = attr.id;
    else etl += ',' + attr.id;
    etlAttr.set('current', etl);
  }

  function computeAttackCarBonus(attaquant, x) {
    if (x === undefined) return '';
    var attCarBonus = x;
    if (isNaN(attCarBonus)) {
      var simplerAttCarBonus = computeCarExpression(attaquant, x);
      if (simplerAttCarBonus !== undefined) {
        attCarBonus = simplerAttCarBonus;
      }
    }
    if (attCarBonus === "0" || attCarBonus === 0) attCarBonus = "";
    else attCarBonus = " + " + attCarBonus;
    return attCarBonus;
  }

  //Met un effet temporaire sur target. L'effet temporaire est sp\xE9cifi\xE9 dans ef
  // - effet : le nom de l'effet
  // - whisper : true si on doit chuchoter l'effet, undefined si on n'affiche pas
  // - duree : true si c'est un effet \xE0 dur\xE9e en tours
  // - effetIndetermine : true si l'effet a une dur\xE9e ind\xE9termin\xE9e (pas combat)
  // - accumuleDuree : si la dur\xE9e peut s'accumuler
  // - typeDmg : le type de d\xE9g\xE2ts associ\xE9 \xE0 l'effet, si pertinent
  // - message : la structure de messages (venant de messageEffetTemp ou autre)
  //   - dm : l'effet fait des d\xE9g\xE2ts
  //   - visible : l'effet est visible
  //   - prejudiciable : l'effet est pr\xE9judiciable (et donc cible de d\xE9livrance)
  //   - statusMarker : marker associ\xE9 \xE0 l'effet
  // - pasDeMessageDActivation : pour ne pas afficher le message d'activation
  // - image : lien d'une image \xE0 afficher
  // - valeur : valeur associ\xE9e \xE0 l'effet
  // - valeurMax : champ max de l'attribut valeur associ\xE9 \xE0 l'effet
  // - saveParTour : caract\xE9ristiques du save par tour, si besoin.
  // - attaquant : la personne \xE0 l'origine de l'effet
  // - options : des options \xE0 mettre dans l'attribut d'options
  function setEffetTemporaire(target, ef, duree, evt, options) {
    if (ef.effet == 'dedoublement') {
      if (attributeAsBool(target, 'dedouble') ||
        attributeAsBool(target, 'dedoublement')) {
        if (ef.whisper !== undefined) {
          whisperChar(target.charId, "a d\xE9j\xE0 \xE9t\xE9 d\xE9doubl\xE9 pendant ce combat");
        } else {
          target.messages.push(target.tokName + " a d\xE9j\xE0 \xE9t\xE9 d\xE9doubl\xE9 pendant ce combat");
        }
        return;
      }
      let dedoubleMsg =
        "Un double translucide de " + target.tokName + " appara\xEEt.";
      if (ef.attaquant) {
        if (ef.attaquant.tokName === undefined) ef.attaquant.tokName = ef.attaquant.token.get('name');
        dedoubleMsg += " Il est aux ordres de " + ef.attaquant.tokName;
      }
      if (stateCOF.options.affichage.val.duree_effets.val) dedoubleMsg += " (" + duree + " tours)";
      if (ef.whisper !== undefined) {
        if (ef.whisper === true) {
          whisperChar(target.charId, dedoubleMsg);
        } else {
          sendChar(target.charId, ef.whisper + dedoubleMsg);
        }
      } else {
        target.messages.push(dedoubleMsg);
      }
      setTokenAttr(target, 'dedouble', true, evt);
      copieToken(target, undefined, stateCOF.options.images.val.image_double.val,
        "Double de " + target.tokName, 'dedoublement', duree,
        target.token.get('pageid'), evt);
      return;
    }
    if (predicateAsBool(target, 'immunite_' + ef.effet)) {
      if (ef.whisper !== undefined) {
        if (ef.whisper === true) {
          whisperChar(target.charId, "ne peut pas \xEAtre affect\xE9 par l'effet de " + ef.effet);
        } else {
          sendChar(target.charId, ef.whisper + "ne peut pas \xEAtre affect\xE9 par l'effet de " + ef.effet);
        }
      } else {
        target.messages.push(target.tokName + " ne peut pas \xEAtre affect\xE9 par l'effet de " + ef.effet);
      }
      return;
    }
    if (ef.effet == 'saignementsSang' && predicateAsBool(target, 'immuniteSaignement')) {
      if (ef.whisper !== undefined) {
        if (ef.whisper === true) {
          whisperChar(target.charId, "ne peut pas saigner");
        } else {
          sendChar(target.charId, ef.whisper + "ne peut pas saigner");
        }
      } else {
        target.messages.push(target.tokName + " ne peut pas saigner");
      }
      return;
    }
    if (ef.effet === 'lienDeSang') {
      if (ef.attaquant === undefined) {
        error("Effet de lien de sans sans attaquant", ef);
        return;
      }
      setTokenAttr(ef.attaquant, 'lienDeSangVers', target.token.id, evt);
      setTokenAttr(target, 'lienDeSangDe', ef.attaquant.token.id, evt);
    }
    if (ef.duree) {
      if (ef.typeDmg && (!ef.message || !ef.message.dm) && predicateAsBool(target, 'diviseEffet_' + ef.typeDmg)) {
        duree = Math.ceil(duree / 2);
      }
      if (ef.accumuleDuree) {
        if (ef.accumuleDuree > 1 && attributeAsBool(target, ef.effet)) {
          let accumuleAttr = tokenAttribute(target, ef.effet + 'DureeAccumulee');
          if (accumuleAttr.length === 0) {
            setTokenAttr(target, ef.effet + 'DureeAccumulee', duree, evt);
          } else {
            accumuleAttr = accumuleAttr[0];
            let dureeAccumulee = accumuleAttr.get('current') + '';
            if (dureeAccumulee.split(',').length < ef.accumuleDuree - 1) {
              evt.attributes = evt.attributes || [];
              evt.attributes.push({
                attribute: accumuleAttr,
                current: dureeAccumulee
              });
              accumuleAttr.set('current', duree + ',' + dureeAccumulee);
            }
          }
          return; //Pas besoin de r\xE9appliquer, effet toujours en cours
        }
      }
      let targetMsg = '';
      if (ef.message && !ef.pasDeMessageDActivation) {
        let msgAct = messageActivation(target, ef.message);
        if (ef.whisper === undefined) {
          targetMsg = target.tokName + " " + msgAct;
        } else if (ef.whisper !== true) {
          targetMsg = ef.whisper + msgAct;
        }
        if (stateCOF.options.affichage.val.duree_effets.val) targetMsg += " (" + duree + " tours)";
        let img = ef.image;
        if (img !== "" && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
          let newLineimg = '<span style="padding: 4px 0;" >  ';
          newLineimg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
          newLineimg += '</span>';
          targetMsg += newLineimg;
        }
        if (ef.whisper === undefined) {
          target.messages.push(targetMsg);
          targetMsg = undefined;
        }
      }
      var secret = !(ef.message && ef.message.visible);
      var attrEffet = setAttrDuree(target, ef.effet, duree, evt, targetMsg, secret);
      if (ef.attaquant && options.mana !== undefined && ef.message && ef.message.prejudiciable) {
        addEffetTemporaireLie(ef.attaquant, attrEffet, evt);
      }
      switch (ef.effet) {
        case 'apeureTemp':
          setState(target, 'apeure', true, evt);
          break;
        case 'aveugleTemp':
          setState(target, 'aveugle', true, evt);
          break;
        case 'ralentiTemp':
          setState(target, 'ralenti', true, evt);
          break;
        case 'paralyseTemp':
        case 'paralyseGoule':
          setState(target, 'paralyse', true, evt);
          break;
        case 'immobiliseTemp':
          setState(target, 'immobilise', true, evt);
          break;
        case 'etourdiTemp':
          setState(target, 'etourdi', true, evt);
          break;
        case 'affaibliTemp':
          setState(target, 'affaibli', true, evt);
          break;
        case 'assommeTemp':
          setState(target, 'assomme', true, evt);
          break;
        case 'invisibleTemp':
        case 'intangibleInvisible':
          setState(target, 'invisible', true, evt);
          break;
        case 'aspectDuDemon':
          //On retire l'autre aspect du N\xE9cromancien si il est pr\xE9sent
          finDEffetDeNom(target, "aspectDeLaSuccube", evt);
          break;
        case 'aspectDeLaSuccube':
          finDEffetDeNom(target, "aspectDuDemon", evt);
          break;
        case 'peauDePierreMag':
          if (ef.valeur === undefined) {
            let lanceur = target;
            if (ef.attaquant) lanceur = ef.attaquant;
            let rd = 5 + modCarac(lanceur, 'intelligence');
            let absorbe = 40;
            if (options.tempeteDeManaIntense) {
              rd += options.tempeteDeManaIntense;
              absorbe += options.tempeteDeManaIntense * 5;
            }
            setTokenAttr(target, 'peauDePierreMagValeur', rd, evt, {
              maxVal: absorbe
            });
          }
          break;
      }
      if (ef.message && ef.message.statusMarker) {
        affectToken(target.token, 'statusmarkers', target.token.get('statusmarkers'), evt);
        target.token.set('status_' + ef.message.statusMarker, true);
      }
    } else if (ef.effetIndetermine) {
      target.messages.push(target.tokName + " " + messageEffetIndetermine[ef.effet].activation);
      setTokenAttr(target, ef.effet, true, evt);
    } else { //On a un effet de combat
      let effetC = messageEffetCombat[ef.effet];
      target.messages.push(target.tokName + " " + effetC.activation);
      let attrEffetCombat = setTokenAttr(target, ef.effet, true, evt);
      if (ef.attaquant && options.mana !== undefined && effetC.prejudiciable) {
        addEffetTemporaireLie(ef.attaquant, attrEffetCombat, evt);
      }
    }
    if (ef.valeur !== undefined) {
      setTokenAttr(target, ef.effet + 'Valeur', ef.valeur, evt, {
        maxVal: ef.valeurMax
      });
    }
    if (ef.options !== undefined) {
      setTokenAttr(target, ef.effet + 'Options', ef.options, evt);
    }
    if (options.tempeteDeManaIntense)
      setTokenAttr(target, ef.effet + 'TempeteDeManaIntense', options.tempeteDeManaIntense, evt);
    if (ef.saveParTour) {
      setTokenAttr(target, ef.effet + 'SaveParTour',
        ef.saveParTour.carac, evt, {
          maxVal: ef.saveParTour.seuil
        });
      if (ef.typeDmg)
        setTokenAttr(target, ef.effet + 'SaveParTourType', ef.typeDmg, evt);
    }
  }

  // Applique toutes les options de preDmg d\xE9j\xE0 s\xE9lectionn\xE9es
  // Retourne vrai si l'option "continuer" a d\xE9j\xE0 \xE9t\xE9 choisie
  function resolvePreDmgOptions(attaquant, ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles) {
    //Sauvegarde de l'\xE9tat pour pouvoir relancer au niveau de cette fonction
    evt.action.currentOptions = options;
    evt.action.echecCritique = echecCritique;
    evt.action.attackLabel = attackLabel;
    evt.action.attackd20roll = d20roll;
    evt.action.display = JSON.parse(JSON.stringify(display));
    evt.action.display.perso1 = display.perso1;
    evt.action.display.perso2 = display.perso2;
    evt.action.explications = JSON.parse(JSON.stringify(explications));
    evt.action.pageId = pageId;
    evt.action.ciblesTouchees = ciblesTouchees;
    evt.action.choices = options.choices;
    if (ciblesTouchees.length === 0) {
      attackDealDmg(attaquant, evt.action.ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles);
      return;
    }
    if (evt.action.choices === undefined) {
      if (options.preDmg) {
        addLineToFramedDisplay(display, "<b>Attaque :</b> Touche !");
        finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique);
        return;
      } else {
        attackDealDmg(attaquant, evt.action.ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles);
        return;
      }
    }
    var continuer = evt.action.choices.Continuer;
    var nbCibles = ciblesTouchees.length;
    ciblesTouchees.forEach(function(cible) {
      var finaliseTarget = function() {
        nbCibles--;
        if (nbCibles === 0) {
          if (continuer) {
            delete options.preDmg;
          }
          if (options.preDmg || options.preDmgAnnule) {
            addLineToFramedDisplay(display, "<b>Attaque :</b> Touche !");
            finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique);
            return;
          } else {
            attackDealDmg(attaquant, evt.action.ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles);
          }
        }
      };
      var preDmgToken = evt.action.choices[cible.token.id];
      if (preDmgToken !== undefined) {
        var termineCible = false;
        if (preDmgToken.encaisserUnCoup) {
          appliquerEncaisserUnCoup(cible, options, evt);
        }
        if (preDmgToken.devierLesCoups) {
          appliquerDevierLesCoups(cible, preDmgToken.devierLesCoups, options, evt);
        }
        if (preDmgToken.paradeDeProjectiles) {
          appliquerParadeProjectiles(cible, preDmgToken.paradeDeProjectiles, options, evt);
          explications.push(cible.token.get("name") + " pare le projectile !");
          finaliseTarget();
        }
        if (preDmgToken.runeForgesort_protection) {
          appliquerRuneDeProtection(cible, options, evt);
          finaliseTarget();
        }
        if (preDmgToken.evitementGenerique && preDmgToken.evitementGenerique.length > 0) {
          var nbEvitementsGenerique = preDmgToken.evitementGenerique.length;
          var finaliseTargetPreDmg = function(msg, generalMsg) {
            if (generalMsg !== '' && !continuer && !termineCible) { // rerolls uniquement si pas termin\xE9
              explications.push(msg + generalMsg);
            } else {
              cible.messages.push(msg);
            }
            nbEvitementsGenerique--;
            if (nbEvitementsGenerique === 0) {
              finaliseTarget();
            }
          };
          preDmgToken.evitementGenerique.forEach(function(evitementGenerique) {
            appliquerEvitementGenerique(cible, evitementGenerique, pageId,
              options, evt, finaliseTargetPreDmg);
          });
        } else {
          finaliseTarget();
        }
      } else {
        finaliseTarget();
      }
    });
  }

  function attaqueNeTouchePas(attaquant, echecCritique, weaponStats, display, options, evt, explications, pageId, cibles) {
    finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique);
    if (echecCritique) {
      if (stateCOF.options.affichage.val.table_crit.val)
        sendChat('COF', "[[1t[Echec-Critique-Contact]]]");
      else sendChat('COF', "/w GM " + suggererEchecCritique(attaquant, weaponStats, cibles, options, evt));
    }
  }

  function attackDealDmg(attaquant, ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles) {
    cibles.forEach(function(target) {
      if (options.test || options.feinte || !target.touche) {
        //On a fini avec cette cible, on imprime ce qui la concerne
        if (target.attackMessage)
          addLineToFramedDisplay(display, target.attackMessage);
        target.messages.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
      }
    });
    let attackerTokName = attaquant.tokName;
    if (ciblesTouchees.length === 0 || options.test || options.feinte) {
      //\xC9valuation finale pour le cas o\xF9 l'attaque a rat\xE9
      evalITE(attaquant, undefined, d20roll, options, 1, evt, explications, options, function() {
        if (options.attrArmeDeJet) {
          if (options.retourneEnMain) {
            if (options.retourneEnMain.carac) {
              explications.push(weaponStats.name + " retourne vers son lanceur");
              let optAttrape = {
                msgPour: " pour rattraper son arme"
              };
              let sid = 'retourEnMain_' + attaquant.charId;
              let expliquer = function(msg) {
                explications.push(msg);
              };
              save(options.retourneEnMain, attaquant, sid, expliquer, optAttrape, evt, function(reussite, rolltext) {
                if (reussite) {
                  options.attrArmeDeJet.attribute.set('current', options.attrArmeDeJet.restant + 1);
                  explications.push(attackerTokName + " rattrape " + weaponStats.name);
                } else {
                  explications.push("Rat\xE9 ! Il reste " + options.attrArmeDeJet.restant + " " + weaponStats.name + " \xE0 " + attackerTokName);
                  if (options.attrArmeDeJet.restant === 0) {
                    degainerArmeLancee(attaquant, attackLabel, evt);
                  }
                }
                attaqueNeTouchePas(attaquant, echecCritique, weaponStats, display, options, evt, explications, pageId, cibles);
              });
              return;
            }
            options.attrArmeDeJet.attribute.set('current', options.attrArmeDeJet.restant + 1);
            explications.push(weaponStats.name + " retourne dans la main de son lanceur");
          } else {
            explications.push("Il reste " + options.attrArmeDeJet.restant + " " + weaponStats.name + " \xE0 " + attackerTokName);
            if (options.attrArmeDeJet.restant === 0) {
              degainerArmeLancee(attaquant, attackLabel, evt);
            }
          }
        }
        attaqueNeTouchePas(attaquant, echecCritique, weaponStats, display, options, evt, explications, pageId, cibles);
      });
      return;
    }
    const attackingCharId = attaquant.charId;
    const attackingToken = attaquant.token;
    options.attaquant = attaquant;
    //Les d\xE9g\xE2ts
    //D\xE9g\xE2ts insrits sur la ligne de l'arme
    let mainDmgType = options.type || 'normal';
    let attNbDices = weaponStats.attNbDices;
    if (isNaN(attNbDices) || attNbDices < 0) {
      error("D\xE9s de l'attaque incorrect", attNbDices);
      return;
    }
    if (attNbDices) {
      if (options.tempeteDeManaIntense) {
        attNbDices += options.tempeteDeManaIntense;
      } else if (options.conditionAttaquant &&
        options.conditionAttaquant.type == 'attribut') {
        var attrtdmi =
          options.conditionAttaquant.attribute + "TempeteDeManaIntense";
        var tdmCond = attributeAsInt(attaquant, attrtdmi, 0);
        if (tdmCond) {
          attNbDices += tdmCond;
          removeTokenAttr(attaquant, attrtdmi, evt);
        }
      }
    }
    // Les autres modifications aux d\xE9g\xE2ts qui ne d\xE9pendent pas de la cible
    let attDMBonusCommun = '';
    if (options.armeMagiquePlus) {
      attDMBonusCommun += " +" + options.armeMagiquePlus;
    }
    if (options.rayonAffaiblissant) {
      attDMBonusCommun += " -" + options.rayonAffaiblissant;
    }
    if (options.noyade && weaponStats.arme) {
      attDMBonusCommun += " - 3";
    }
    if (options.fievreux && weaponStats.arme) {
      attDMBonusCommun += " - 2";
    }
    if (options.reactionViolente) {
      attDMBonusCommun += " + 2";
    }
    if (attributeAsBool(attaquant, 'masqueDuPredateur')) {
      let bonusMasque = getValeurOfEffet(attaquant, 'masqueDuPredateur', modCarac(attaquant, 'sagesse'));
      if (bonusMasque > 0) attDMBonusCommun += " +" + bonusMasque;
    }
    if (options.bonusDM) {
      attDMBonusCommun += " +" + options.bonusDM;
    }
    if (options.rageBerserk) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: options.rageBerserk + options.d6
      });
    }
    if (attributeAsBool(attaquant, 'enrage')) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: '1' + options.d6
      });
    }
    if (options.contact && attributeAsBool(attaquant, 'memePasMalBonus')) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: '1' + options.d6,
      });
      explications.push("M\xEAme pas mal => +1" + options.d6 + " DM");
    }
    if (!options.auto && options.attaqueEnPuissance) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: options.attaqueEnPuissance + options.d6
      });
    }
    let attrPosture = tokenAttribute(attaquant, 'postureDeCombat');
    if (attrPosture.length > 0) {
      attrPosture = attrPosture[0];
      let posture = attrPosture.get('max');
      let postureVal;
      if (posture.startsWith('DM')) {
        postureVal = parseInt(attrPosture.get('current'));
        attDMBonusCommun += " -" + postureVal;
        explications.push("Posture de combat => -" + postureVal + " DM");
      } else if (posture.endsWith('DM')) {
        postureVal = parseInt(attrPosture.get('current'));
        attDMBonusCommun += " +" + postureVal;
        explications.push("Posture de combat => +" + postureVal + " DM");
      }
    }
    let attrAttaqueAOutrance = tokenAttribute(attaquant, 'attaqueAOutrance');
    if (attrAttaqueAOutrance.length > 0) {
      attrAttaqueAOutrance = attrAttaqueAOutrance[0];
      let attaqueAOutranceVal = parseInt(attrAttaqueAOutrance.get('current'));
      if (attaqueAOutranceVal == 2) {
        attaquant.additionalDmg.push({
          type: mainDmgType,
          value: '1' + options.d6
        });
        explications.push("Attaque \xE0 outrance => +1d6 DM");
      } else if (attaqueAOutranceVal == 5) {
        attaquant.additionalDmg.push({
          type: mainDmgType,
          value: '2' + options.d6
        });
        explications.push("Attaque \xE0 outrance => +2d6 DM");
      }
    }
    if (attaquant.bonusCapitaine) attDMBonusCommun += " +" + attaquant.bonusCapitaine;
    // Les autres sources de d\xE9g\xE2ts
    if (options.distance) {
      if (options.semonce) {
        attaquant.additionalDmg.push({
          type: mainDmgType,
          value: '1' + options.d6
        });
        explications.push("Tir de semonce => +5 en Attaque et +1" + options.d6 + " aux DM");
      }
    } else { //bonus aux attaques de contact
      if (attributeAsBool(attaquant, 'agrandissement')) {
        attDMBonusCommun += "+2";
        explications.push("Agrandissement => +2 aux DM");
      }
      if (attributeAsBool(attaquant, 'forceDeGeant')) {
        let bonusForceDeGeant = getValeurOfEffet(attaquant, 'forceDeGeant', 2);
        attDMBonusCommun += "+" + bonusForceDeGeant;
        explications.push("Force de g\xE9ant => +" + bonusForceDeGeant + " aux DM");
      }
      if (options.frappeDuVide) {
        attaquant.additionalDmg.push({
          type: mainDmgType,
          value: '1' + options.d6
        });
      }
    }
    let nAEF = 0;
    if (attackLabel) {
      let attrForgeron = 'forgeron(' + attackLabel + ')';
      if (attributeAsBool(attaquant, attrForgeron)) {
        let feuForgeron =
          getValeurOfEffet(attaquant, attrForgeron, 1, 'voieDuMetal');
        let feuForgeronIntense = attributeAsInt(attaquant, attrForgeron + 'TempeteDeManaIntense', 0);
        if (feuForgeronIntense) {
          feuForgeron = feuForgeron * (1 + feuForgeronIntense);
          removeTokenAttr(attaquant, attrForgeron + 'TempeteDeManaIntense', evt);
        }
        attaquant.additionalDmg.push({
          type: 'feu',
          value: feuForgeron
        });
      }
      let attrAEF = 'armeEnflammee(' + attackLabel + ')';
      if (attributeAsBool(attaquant, attrAEF)) {
        nAEF = 1;
        let AEFIntense = attributeAsInt(attaquant, attrAEF + 'TempeteDeManaIntense', 0);
        if (AEFIntense) {
          nAEF += AEFIntense;
          removeTokenAttr(attaquant, attrAEF + 'TempeteDeManaIntense', evt);
        }
      }
    }
    if (nAEF === 0 && attributeAsBool(attaquant, 'armesEnflammees')) {
      nAEF = 1;
      let AsEFIntense = attributeAsInt(attaquant, 'armesEnflammeesTempeteDeManaIntense', 0);
      if (AsEFIntense) {
        nAEF += AsEFIntense;
        removeTokenAttr(attaquant, 'armesEnflammeesTempeteDeManaIntense', evt);
      }
    }
    if (nAEF > 0) {
      attaquant.additionalDmg.push({
        type: 'feu',
        value: nAEF + 'd6'
      });
    }
    if (attackLabel && (attackingToken.get('bar1_link') === '' || !weaponStats.armeDeJet)) {
      let poisonAttr = tokenAttribute(attaquant, 'poisonRapide_' + attackLabel);
      if (poisonAttr.length > 0) {
        poisonAttr = poisonAttr[0];
        attaquant.additionalDmg.push({
          type: 'poison',
          value: poisonAttr.get('current'),
          partialSave: {
            carac: 'CON',
            seuil: poisonAttr.get('max')
          }
        });
        explications.push("L'arme est empoisonn\xE9e");
        evt.deletedAttributes = evt.deletedAttributes || [];
        evt.deletedAttributes.push(poisonAttr);
        poisonAttr.remove();
      }
      var attrDmgArme = 'dmgArme(' + attackLabel + ')';
      if (attributeAsBool(attaquant, attrDmgArme)) {
        var dmgArme = {
          type: mainDmgType,
          value: '1' + options.d6
        };
        var valDmgArme = tokenAttribute(attaquant, attrDmgArme + 'Valeur');
        if (valDmgArme.length > 0) {
          dmgArme.value = valDmgArme[0].get('current');
          var dmgArmeType = valDmgArme[0].get('max');
          if (dmgArmeType !== '') dmgArme.type = dmgArmeType;
        }
        attaquant.additionalDmg.push(dmgArme);
        explications.push("Arme enduite => +" + dmgArme.value + " aux DM");
      }
    }
    if (options.champion) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: '1' + options.d6
      });
      var msgChampion =
        attaquant.tokName + " est un" + eForFemale(attaquant) + " champion" +
        onGenre(attaquant, '', 'ne') + ", son attaque porte !";
      explications.push(msgChampion);
    }
    /////////////////////////////////////////////////////////////////
    //Tout ce qui d\xE9pend de la cible
    var ciblesCount = ciblesTouchees.length; //Pour l'asynchronie
    var attaquesEnTraitrePossibles = {};
    let finCibles = function() {
      ciblesCount--;
      if (ciblesCount === 0) {
        ciblesTouchees.forEach(function(target) {
          if (target.attackMessage) {
            addLineToFramedDisplay(display, target.attackMessage);
          } else if (options.aoe) { //par exemple si attaque automatique
            addLineToFramedDisplay(display, "<b>" + target.tokName + "</b> :");
          }
          if (target.dmgMessage) addLineToFramedDisplay(display, target.dmgMessage, 100, false);
          target.messages.forEach(function(expl) {
            addLineToFramedDisplay(display, expl, 80);
          });
          if (target.osBrises) {
            addLineToFramedDisplay(display, target.tokName + " a des os bris\xE9s ");
            setTokenAttr(target, 'osBrises', true, evt);
          }
        });
        finaliseDisplay(display, explications, evt, attaquant, cibles, options);
        for (let vid in attaquesEnTraitrePossibles) {
          let voleur = persoOfId(vid);
          if (voleur === undefined) continue;
          if (capaciteDisponible(voleur, 'attaqueEnTraitre')) {
            displayAttaqueOpportunite(vid, attaquesEnTraitrePossibles[vid], "en tra\xEEtre", 'Attaques en traitre', '--decrLimitePredicatParTour attaqueEnTraitre');
          }
        }
      }
    };
    //Le lien \xE9pique (+1d6 DM si les 2 attaquent la m\xEAme cible
    var attaqueParLienEpique = new Set();
    if (options.lienEpique) {
      //On cherche les autres personnages avec le m\xEAme lien \xE9pique
      var allChars = findObjs({
        type: 'character'
      });
      allChars.forEach(function(ch) {
        if (ch.id == attackingCharId) return;
        let attrLienEpique = charAttribute(ch.id, 'lienEpique');
        if (attrLienEpique.length === 0) return;
        if (attrLienEpique[0].get('current') != options.lienEpique) return;
        let attrCibles = charAttribute(ch.id, 'dernieresCiblesAttaquees');
        if (attrCibles.length === 0) return;
        let ciblesAttaquees = attrCibles[0].get('current');
        if (ciblesAttaquees === '') return;
        ciblesAttaquees.split(' ').forEach(function(ci) {
          attaqueParLienEpique.add(ci);
        });
      });
    }
    ciblesTouchees.forEach(function(target) {
      //l'\xE9valuation finale des conditions quand on sait si l'attaque a touch\xE9.
      evalITE(attaquant, target, d20roll, options, 1, evt, explications, options, function() {
        target.attaquant = attaquant;
        if (options.attrArmeDeJet) {
          if (options.retourneEnMain) {
            options.attrArmeDeJet.attribute.set('current', options.attrArmeDeJet.restant + 1);
            explications.push(weaponStats.name + " retourne dans la main de son lanceur");
          } else {
            explications.push("Il reste " + options.attrArmeDeJet.restant + " " + weaponStats.name + " \xE0 " + attackerTokName);
            if (options.attrArmeDeJet.restant === 0) {
              degainerArmeLancee(attaquant, attackLabel, evt);
            }
          }
          options.attrArmeDeJet = undefined;
        }
        if (options.enveloppe !== undefined) {
          if (options.enveloppe.type == 'etreinte' && attributeAsBool(target, 'armureDEau')) {
            target.messages.push("L'armure d'eau emp\xEAche " + target.tokName + " d'\xEAtre \xE9treint");
          } else {
            var ligneEnveloppe = attaquant.tokName + " peut ";
            var commandeEnvelopper =
              '!cof-enveloppement ' + attaquant.token.id + ' ' + target.token.id + ' ' +
              options.enveloppe.difficulte + ' ' +
              options.enveloppe.type + ' ' + options.enveloppe.expression;
            var verbeEnv = 'envelopper';
            if (options.enveloppe.type == 'etreinte') verbeEnv = '\xE9treindre';
            ligneEnveloppe += boutonSimple(commandeEnvelopper, verbeEnv);
            ligneEnveloppe += target.tokName;
            target.messages.push(ligneEnveloppe);
          }
        }
        if (options.agripper) {
          if (attributeAsBool(target, 'armureDEau')) {
            target.messages.push("L'armure d'eau emp\xEAche " + target.tokName + " d'\xEAtre aggrip\xE9");
          } else {
            let immobilise = estAussiGrandQue(attaquant, target);
            setTokenAttr(attaquant, 'agrippe', target.token.id + ' ' + target.tokName, evt);
            setTokenAttr(target, 'estAgrippePar', attaquant.token.id + ' ' + attaquant.tokName, evt, {
              maxVal: immobilise
            });
            if (immobilise) setState(target, 'immobilise', true, evt);
            target.messages.push("est agripp\xE9");
          }
        }
        if (options.devorer) {
          target.messages.push(attaquant.tokName + " saisit " + target.tokName + " entre ses crocs et ses griffes");
          if (attackLabel) {
            let cmdAttaqueGratuite = '!cof-attack ' + attaquant.token.id + ' ' + target.token.id + ' ' + attackLabel;
            target.messages.push(boutonSimple(cmdAttaqueGratuite, 'Attaque gratuite'));
          } else {
            target.messages.push(attaquant.tokName + " a droit \xE0 une attaque gratuite contre " + target.tokName);
          }
          let attackerForce = valAttribute(attaquant, 'FOR', 'force');
          let targetForce = valAttribute(target, 'FOR', 'force');
          if (targetForce <= attackerForce) {
            if (attributeAsBool(target, 'armureDEau')) {
              target.messages.push("L'armure d'eau emp\xEAche " + target.tokName + " d'\xEAtre saisi");
            } else {
              setState(target, 'renverse', true, evt);
              setState(target, 'immobilise', true, evt);
              setTokenAttr(attaquant, 'devore', target.token.id + ' ' + target.tokName, evt);
              setTokenAttr(target, 'estDevorePar', attaquant.token.id + ' ' + attaquant.tokName, evt);
            }
          }
        }
        if (options.saisirEtBroyer) {
          target.messages.push(attaquant.tokName + " soul\xE8ve " + target.tokName + " gesticulant" + eForFemale(target));
          if (attackLabel) {
            var cmdAttaqueGratuiteSaisi = '!cof-attack ' + attaquant.token.id + ' ' + target.token.id + ' ' + attackLabel + ' --bonusAttaque 5';
            target.messages.push(boutonSimple(cmdAttaqueGratuiteSaisi, 'Attaque gratuite'));
          } else {
            target.messages.push(attaquant.tokName + " a droit \xE0 une attaque gratuite contre " + target.tokName);
          }
          if (valAttribute(target, 'FOR', 'force') < valAttribute(attaquant, 'FOR', 'force')) {
            options.rolls = options.rolls || [];
            let distanceSaisiProjete = options.rolls['distanceSaisiProjection_' + target.token.id] ||
              rollDePlus(6, {
                nbDes: 2
              });
            evt.action.rolls['distanceSaisiProjection_' + target.token.id] = distanceSaisiProjete;
            if (predicateAsBool(target, 'inderacinable')) {
              distanceSaisiProjete.val /= 2;
              distanceSaisiProjete.roll = '(' + distanceSaisiProjete.roll + ')/2 = ' + distanceSaisiProjete.val;
            }
            target.additionalDmg.push({
              type: 'normal',
              value: Math.floor(distanceSaisiProjete.val)
            });
            target.messages.push(target.tokName + " est projet\xE9" + eForFemale(target) + " sur " + distanceSaisiProjete.roll + " m\xE8tres");
          }
        }
        if (options.projection && taillePersonnage(attaquant, 4) > taillePersonnage(target, 4)) {
          let bonusProjection = 5 - taillePersonnage(target, 4);
          options.rolls = options.rolls || [];
          let distanceProjetee =
            options.rolls['distanceProjection_' + target.token.id] ||
            rollDePlus(6, {
              bonus: bonusProjection
            }).val;
          evt.action.rolls['distanceProjection_' + target.token.id] = distanceProjetee;
          var dmgProjection = "3d6";
          if (predicateAsBool(target, 'inderacinable')) {
            distanceProjetee /= 2;
            dmgProjection = "floor(" + dmgProjection + "/2)";
          }
          target.effets.push({
            effet: 'etourdiTemp',
            duree: 100,
            message: messageOfEffetTemp('etourdiTemp'),
            save: {
              carac: 'CON',
              seuil: 15
            },
            saveParTour: {
              carac: 'CON',
              seuil: 15
            }
          });
          target.additionalDmg.push({
            type: 'normal',
            value: dmgProjection
          });
          target.messages.push(target.tokName + " est projet\xE9 sur " + distanceProjetee + " m\xE8tres");
        }
        if (options.gober && taillePersonnage(attaquant, 4) > taillePersonnage(target, 4)) {
          //On utilise la liste d'effets pour pouvoir g\xE9rer les jets asynchrones
          target.effets.push({
            gober: true,
            save: true
          });
        }
        var attDMBonus = attDMBonusCommun;
        //Les modificateurs de d\xE9g\xE2ts qui d\xE9pendent de la cible
        if (target.tempDmg) {
          let forceTarg = modCarac(target, 'force');
          if (forceTarg < 0) {
            attDMBonus += " +" + (-forceTarg);
          } else {
            attDMBonus += " -" + forceTarg;
          }
        }
        if (options.pressionMortelle || target.pressionMortelle) {
          let pMortelle = tokenAttribute(target, 'pressionMortelle');
          if (pMortelle.length === 0) {
            sendPerso(attaquant, "essaie une pression mortelle, mais aucun point vital de " + target.tokName + " n'a encore \xE9t\xE9 affect\xE9");
            ciblesCount--;
            return;
          }
          target.pressionMortelle = pMortelle;
          attDMBonus = "+ " + pMortelle[0].get('current');
        }
        if (options.distance && !options.grenaille) {
          let tirPrecis = predicateAsInt(attaquant, 'tirPrecis', 0);
          if (tirPrecis > 0) {
            let modDex = modCarac(attaquant, 'dexterite');
            if (target.distance <= 5 * modDex) {
              attDMBonus += " + " + tirPrecis;
              target.messages.push("Tir pr\xE9cis : +" + tirPrecis + " DM");
            }
          }
        }
        let sournoise = options.sournoise || 0;
        if (target.sournoise) sournoise += target.sournoise;
        if (target.critique && sournoise === 0 && predicateAsBool(attaquant, 'botteSecrete')) {
          sournoise = predicateAsInt(attaquant, 'attaqueSournoise', 1);
          target.messages.push("Botte secr\xE8te !");
        }
        if (sournoise) {
          let limiteSournoisesParTour = predicateAsInt(attaquant, 'sournoisesParTour', 1);
          let nbSournoises = attributeAsInt(attaquant, 'limiteParTour_sournoises', limiteSournoisesParTour);
          if (nbSournoises < 1) {
            explications.push("Plus d'attaque sournoise possible ce tour");
          } else {
            setTokenAttr(attaquant, 'limiteParTour_sournoises', nbSournoises - 1, evt);
            if (predicateAsBool(target, 'immuniteAuxSournoises')) {
              target.messages.push(target.tokName + " est immunis\xE9" + eForFemale(target) + " aux attaques sournoises");
            } else {
              if (options.ouvertureMortelle) {
                target.messages.push("Ouverture mortelle => + 2 x " + sournoise + options.d6 + " DM");
                sournoise = sournoise * 2;
              } else {
                target.messages.push("Attaque sournoise => +" + sournoise + options.d6 + " DM");
              }
              var valueSournoise = sournoise + options.d6;
              if (predicateAsBool(target, 'armureProtection') && ficheAttributeAsBool(target, 'defarmureon', false)) {
                target.messages.push("L'armure de protection de " + target.token.get('name') + " r\xE9duit l'attaque sournoise");
                valueSournoise = "ceil(" + valueSournoise + "/2)";
              } else if (predicateAsBool(target, 'bouclierProtection') && ficheAttributeAsInt(target, 'defbouclieron', 0)) {
                target.messages.push("Le bouclier de protection de " + target.token.get('name') + " r\xE9duit l'attaque sournoise");
                valueSournoise = "ceil(" + valueSournoise + "/2)";
              }
              target.additionalDmg.push({
                type: mainDmgType,
                value: valueSournoise
              });
            }
          }
        }
        if (target.faireMouche) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: target.faireMouche + options.d6
          });
          target.messages.push(attaquant.tokName + " profite de l'ouverture et son attaque fait mouche !");
        }
        if (target.chasseurEmerite) {
          attDMBonus += "+2";
        }
        if (target.attaqueDansLeNoir) {
          attDMBonus += '-' + target.attaqueDansLeNoir;
        }
        if (target.ennemiJure) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1' + options.d6
          });
        }
        if (target.cibleLiberateurDeDorn) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '2' + options.d6
          });
        }
        if (target.cibleLiberateurDeKerserac) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1' + options.d6
          });
        }
        if (target.cibleLiberateurDAnathazerin) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '2' + options.d6
          });
        }
        if (target.tueurDeGeants) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '2' + options.d6
          });
        }
        if (target.cibleMeneurDHommes) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1' + options.d6
          });
        }
        if (target.armeDArgent) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1d6'
          });
        }
        if (target.estAgrippee) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1d6'
          });
        }
        if (options.lienEpique && attaqueParLienEpique.has(target.token.id)) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1' + options.d6
          });
          target.messages.push("Lien \xE9pique => + 1" + options.d6 + " DM");
        }
        if (target.feinte) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: target.feinte + options.d6
          });
        }
        var targetTaille = taillePersonnage(target, 4);
        if (options.tueurDeGrands) {
          if (targetTaille == 5) {
            target.additionalDmg.push({
              type: mainDmgType,
              value: '1d6'
            });
            target.messages.push("Cible grande => +1d6 DM");
          } else if (targetTaille > 5) {
            target.additionalDmg.push({
              type: mainDmgType,
              value: '2d6'
            });
            target.messages.push("Cible \xE9norme => +2d6 DM");
          }
        }
        if (options.contact && weaponStats.deuxMains && targetTaille > 4) {
          if (predicateAsBool(attaquant, 'bucheron')) {
            if (targetTaille == 5) {
              target.additionalDmg.push({
                type: mainDmgType,
                value: '1d6'
              });
              target.messages.push("Arme tenue \xE0 2 mains => +1d6 DM");
            } else if (targetTaille > 5) {
              target.additionalDmg.push({
                type: mainDmgType,
                value: '2d6'
              });
              target.messages.push("Arme tenue \xE0 2 mains et cible \xE9norme => +2d6 DM");
            }
          }
          if (predicateAsBool(attaquant, "grosMonstreGrosseArme")) {
            options.puissant = true;
            target.messages.push("Gros Monstre, grosse arme => d\xE9g\xE2ts de base augment\xE9s");
          }
        }
        if (attributeAsBool(target, "hemorragie") && !options.sortilege && !options.armeNaturelle) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1d6'
          });
          target.messages.push("H\xE9morragie => +1d6 DM");
        }
        if (!options.pasDeDmg) {
          let loupParmiLesLoups = predicateAsInt(attaquant, 'loupParmiLesLoups', 0);
          if (loupParmiLesLoups > 0 && estHumanoide(target)) {
            attDMBonus += "+" + loupParmiLesLoups;
            target.messages.push("Loup parmi les loups : +" + loupParmiLesLoups + " DM");
          }
          if (predicateAsBool(attaquant, 'langageSombreHetre') && estElfeNoir(target)) {
            attDMBonus += "+1";
            target.messages.push("Langage sombre : +1 DM");
          }
        }
        if (predicateAsBool(attaquant, 'laissez-le-moi') &&
          attributeAsBool(target, 'seulContreTous_leader')) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1d6'
          });
          target.messages.push("Cible de " + attackerTokName + " : +1d6 DM");
        }
        //Bonus aux DMs dus au d\xE9fi samoura\xEF
        let defiSamouraiAttr = tokenAttribute(attaquant, 'defiSamourai');
        if (defiSamouraiAttr.length > 0) {
          defiSamouraiAttr = defiSamouraiAttr[0];
          let cibleDefi = defiSamouraiAttr.get('max');
          if (cibleDefi.startsWith(target.token.id)) cibleDefi = true;
          else {
            let cibleDefiSep = cibleDefi.indexOf(' ');
            let cibleDefiName = cibleDefi.substring(cibleDefiSep + 1);
            if (cibleDefiName == target.tokName) {
              let cibleDefiId = cibleDefi.substring(0, cibleDefiSep);
              cibleDefi = persoOfId(cibleDefiId, cibleDefiName, pageId);
              cibleDefi = cibleDefi === undefined || cibleDefi.id == target.id;
            } else cibleDefi = false;
          }
          if (cibleDefi) {
            let bonusDefi = parseInt(defiSamouraiAttr.get('current'));
            target.additionalDmg.push({
              type: mainDmgType,
              value: bonusDefi
            });
            target.messages.push(attackerTokName + " b\xE9n\xE9ficie d'un bonus de +" + bonusDefi + " aux DMs contre " + target.tokName);
          }
        }
        if (attributeAsBool(attaquant, 'ombreMortelle') ||
          attributeAsBool(attaquant, 'dedoublement') ||
          (charAttributeAsBool(attaquant, 'armeeConjuree') && attributeAsBool(target, 'attaqueArmeeConjuree'))) {
          if (options.divise) options.divise *= 2;
          else options.divise = 2;
        }
        if (options.attaqueAssuree || options.echecTotal) {
          if (options.divise) options.divise *= 2;
          else options.divise = 2;
        }
        var mainDmgRollExpr;
        if (target.dmRate) {
          mainDmgRollExpr = options.dmSiRate.value;
          mainDmgType = options.dmSiRate.type;
        } else if (options.dmCible && options.dmCible.target && options.dmCible.target.id === target.token.id) {
          mainDmgRollExpr = options.dmCible.value;
          mainDmgType = options.dmCible.type;
        } else {
          mainDmgRollExpr = computeMainDmgRollExpr(attaquant, target, weaponStats, attNbDices,
            attDMBonus, options);
        }
        //Additional damage
        var additionalDmg = attaquant.additionalDmg.concat(target.additionalDmg);
        //On enl\xE8ve les DM qui ne passent pas les conditions
        additionalDmg = additionalDmg.filter(function(dmSpec) {
          if (dmSpec.conditions === undefined) return true;
          return dmSpec.conditions.every(function(cond) {
            return testCondition(cond, attaquant, [target], d20roll, options);
          });
        });
        if (!options.sortilege && !options.magique &&
          predicateAsBool(target, 'immuniteAuxArmes')) {
          additionalDmg = additionalDmg.filter(function(dmSpec) {
            switch (dmSpec.type) {
              case undefined:
              case 'normal':
              case 'poison':
              case 'maladie':
                return false;
              default:
                return true;
            }
          });
        }
        if (options.tirDouble || options.tirDeBarrage || options.dmFoisDeux) {
          if (options.tirDouble && options.tirDouble.stats) {
            var stats2 = options.tirDouble.stats;
            mainDmgRollExpr += " +" +
              computeMainDmgRollExpr(attaquant, target, stats2, stats2.attNbDices,
                attDMBonus, options);
          } else {
            mainDmgRollExpr += " +" + mainDmgRollExpr;
          }
          additionalDmg.forEach(function(dmSpec) {
            dmSpec.value += " +" + dmSpec.Value;
          });
        }
        if (target.etreinteImmole) {
          additionalDmg.push({
            value: mainDmgRollExpr,
            type: 'feu'
          });
        }
        let extraDmgRollExpr = "";
        additionalDmg = additionalDmg.filter(function(dmSpec) {
          dmSpec.type = dmSpec.type || 'normal';
          if (dmSpec.type != mainDmgType || isNaN(dmSpec.value)) {
            extraDmgRollExpr += " [[" + dmSpec.value + "]]";
            return true;
          }
          // We have the same type and a constant -> should be multiplied by crit
          mainDmgRollExpr += " + " + dmSpec.value;
          return false;
        });
        // On ajoute le jet pour les d\xE9g\xE2ts de critiques suppl\xE9mentaires
        if (target.critique && options.additionalCritDmg) {
          options.additionalCritDmg.forEach(function(dmSpec) {
            extraDmgRollExpr += " [[" + dmSpec.value + "]]";
          });
        }
        if (options.maxDmg && options.runeDePuissance) {
          extraDmgRollExpr = extraDmgRollExpr.replace(/\[\[(\d+)d([\d\+\-]+)\]\]/g, '[[$1*$2]]');
        }
        if (options.aveugleManoeuvre) {
          mainDmgRollExpr += " -5";
        }
        let mainDmgRoll = {
          type: mainDmgType,
          value: mainDmgRollExpr
        };
        // toEvaluateDmg inlines
        // 0 : roll de d\xE9g\xE2ts principaux
        // 1+ : les rolls de d\xE9g\xE2ts suppl\xE9mentaires
        // 1+nb d\xE9g\xE2ts suppl\xE9mentaires + : rolls de d\xE9g\xE2ts critiques
        var toEvaluateDmg = "[[" + mainDmgRollExpr + "]]" + extraDmgRollExpr;
        sendChat('', toEvaluateDmg, function(resDmg) {
          let rollsDmg = target.rollsDmg || resDmg[0];
          let afterEvaluateDmg = rollsDmg.content.split(' ');
          let mainDmgRollNumber = rollNumber(afterEvaluateDmg[0]);
          mainDmgRoll.total = rollsDmg.inlinerolls[mainDmgRollNumber].results.total;
          mainDmgRoll.display = buildinline(rollsDmg.inlinerolls[mainDmgRollNumber], mainDmgType, options.magique);
          if (target.critique && options.additionalCritDmg) {
            var firstCritRoll = 1 + additionalDmg.length;
            target.additionalCritDmg = [];
            var rollsCrit = resDmg[0];
            if (target.rollsDmg && target.rollsDmg.length >= firstCritRoll + options.additinalCritDmg.length)
              rollsCrit = target.rollsDmg;
            options.additionalCritDmg.forEach(function(dmSpec, i) {
              var rRoll = rollsCrit.inlinerolls[rollNumber(afterEvaluateDmg[i + firstCritRoll])];
              if (rRoll) {
                target.additionalCritDmg.push(dmSpec);
                dmSpec.total = dmSpec.total || rRoll.results.total;
                var addDmType = dmSpec.type || 'normal';
                dmSpec.display = dmSpec.display || buildinline(rRoll, addDmType, options.magique);
              } else { //l'expression de DM additionel est mal form\xE9e
                error("Expression de d\xE9g\xE2ts de critiques mal form\xE9e : " + options.additionalCritDmg[i].value, options.additionalCritDmg[i]);
              }
            });
            if (target.additionalCritDmg.length === 0) delete target.additionalCritDmg;
          }
          var correctAdditionalDmg = [];
          additionalDmg.forEach(function(dmSpec, i) {
            var rRoll = rollsDmg.inlinerolls[rollNumber(afterEvaluateDmg[i + 1])];
            if (rRoll) {
              correctAdditionalDmg.push(dmSpec);
              dmSpec.total = dmSpec.total || rRoll.results.total;
              var addDmType = dmSpec.type;
              dmSpec.display = dmSpec.display || buildinline(rRoll, addDmType, options.magique);
            } else { //l'expression de DM additionel est mal form\xE9e
              error("Expression de d\xE9g\xE2ts suppl\xE9mentaires mal form\xE9e : " + additionalDmg[i].value, additionalDmg[i]);
            }
          });
          if (options.expertDuCombatDMSpec) {
            correctAdditionalDmg.push(options.expertDuCombatDMSpec);
          }
          additionalDmg = correctAdditionalDmg;
          if (target.touche) { //Devrait \xEAtre inutile ?
            if (options.tirDeBarrage) target.messages.push("Tir de barrage : undo si la cible d\xE9cide de ne pas bouger");
            if (options.pointsVitaux) target.messages.push(attackerTokName + " vise des points vitaux mais ne semble pas faire de d\xE9g\xE2ts");
            if (options.pressionMortelle || target.pressionMortelle) {
              removeTokenAttr(target, 'pressionMortelle', evt);
              target.messages.push(attackerTokName + " lib\xE8re la pression des points vitaux, l'effet est d\xE9vastateur !");
              spawnFx(target.token.get('left'), target.token.get('top'), 'bomb-death', pageId);
            }
            if (options.pasDeDmg === undefined) { //si l'attaque fait des DM, possibilit\xE9 d'attaque en tra\xEEtre
              if (attaquant.alliesAvecAttaqueEnTraitre === undefined) {
                attaquant.alliesAvecAttaqueEnTraitre = [];
                //On cherche tous les alli\xE9s ayant l'attaque en traitre
                const allies = alliesParPerso[attaquant.charId] || new Set();
                allies.forEach(function(ci) {
                  if (!charPredicateAsBool(ci, 'attaqueEnTraitre')) return;
                  let tokens = findObjs({
                    _type: 'graphic',
                    _subtype: 'token',
                    _pageid: pageId,
                    represents: ci
                  });
                  tokens.forEach(function(tok) {
                    let perso = {
                      charId: ci,
                      token: tok
                    };
                    if (capaciteDisponibleSachantPred(perso, 'attaqueEnTraitre', 'tour')) {
                      attaquant.alliesAvecAttaqueEnTraitre.push(tok);
                    }
                  });
                });
              }
              attaquant.alliesAvecAttaqueEnTraitre.forEach(function(tok) {
                if (tok.id == target.id) return;
                if (distanceCombat(target.token, tok, pageId) === 0) {
                  var aetp = attaquesEnTraitrePossibles[tok.id];
                  if (aetp === undefined) {
                    aetp = [];
                    attaquesEnTraitrePossibles[tok.id] = aetp;
                  }
                  aetp.push(target);
                }
              });
            }
            // change l'\xE9tat de la cible, si sp\xE9cifi\xE9
            if (target.enflamme) {
              var enflammePuissance = 1;
              if (options.puissant) enflammePuissance = 2;
              setTokenAttr(target, 'enflamme', enflammePuissance, evt);
              target.messages.push(target.tokName + " prend feu !");
            }
            if (target.malediction) {
              setTokenAttr(target, 'malediction', 3, evt);
              target.messages.push(target.tokName + " est maudit...");
            }
            if (options.attaqueBouclierRenverse && weaponStats.attDice == 4 &&
              rollsDmg.inlinerolls[mainDmgRollNumber].results.rolls[0].results[0].v >= 4) {
              target.etats = target.etats || [];
              target.etats.push({
                etat: 'renverse',
                condition: {
                  type: "moins",
                  attribute: "FOR",
                  text: 'force'
                }
              });
            }
            // Draw effect, if any
            if (options.fx) {
              //Pour les cones, on fait un seul effet, car c'est bien g\xE9r\xE9.
              if (!options.aoe || options.aoe.type != 'cone') {
                let p1e = {
                  x: attackingToken.get('left'),
                  y: attackingToken.get('top'),
                };
                let p2e = {
                  x: target.token.get('left'),
                  y: target.token.get('top'),
                };
                spawnFxBetweenPoints(p1e, p2e, options.fx, pageId);
              }
            }
            if (options.targetFx && !options.aoe) {
              spawnFx(target.token.get('left'), target.token.get('top'), options.targetFx, pageId);
            }
            target.rollsDmg = rollsDmg;
            let affaiblissements = options.affaiblissementsCarac;
            if (target.affaiblissementsCarac) {
              if (affaiblissements)
                affaiblissements = affaiblissements.concat(target.affaiblissementsCarac);
              else affaiblissements = target.affaiblissementsCarac;
            }
            if (affaiblissements) {
              let expliquer = function(s) {
                target.messages.push(s);
              };
              affaiblissements.forEach(function(aff) {
                affaiblirCaracPerso(target, aff.carac, aff.val, expliquer, evt);
              });
            }
            // Compte le nombre de saves pour la synchronisation
            // (On ne compte pas les psave, g\xE9r\xE9s dans dealDamage)
            let saves = 0;
            //ajoute les \xE9tats sans save \xE0 la cible
            let etats = options.etats;
            if (target.etats) {
              if (etats) etats = etats.concat(target.etats);
              else etats = target.etats;
            }
            if (etats) {
              etats.forEach(function(ce) {
                if (options.sortilege &&
                  ((predicateAsBool(target, 'liberteDAction') && (
                      ce.etat == 'apeure' ||
                      ce.etat == 'endormi' ||
                      ce.etat == 'etourdi' ||
                      ce.etat == 'immobilise' ||
                      ce.etat == 'paralyse' ||
                      ce.etat == 'ralenti'
                    )) ||
                    (predicateAsBool(target, 'actionLibre') && (ce.etat == 'ralenti' || ce.etat == 'immobilise' || ce.etat == 'paralyse')) ||
                    (predicateAsInt(target, 'voieDeLArchange', 1) > 1 && (ce.etat == 'ralenti' || ce.etat == 'immobilise') && attributeAsBool(target, 'formeDAnge'))
                  )) {
                  target.messages.push(target.tokName + " reste libre de ses mouvements !");
                  return;
                }
                if (ce.save) {
                  saves++;
                  return; //on le fera plus tard
                }
                if (testCondition(ce.condition, attaquant, [target], d20roll, options)) {
                  setState(target, ce.etat, true, evt);
                  let msgEtat;
                  if (ce.etat == 'mort')
                    msgEtat = 'tu\xE9' + eForFemale(target);
                  else
                    msgEtat = stringOfEtat(ce.etat, target);
                  target.messages.push(target.tokName + " est " + msgEtat + " par l'attaque");
                  if (ce.saveCarac) {
                    setTokenAttr(target, ce.etat + 'Save', ce.saveCarac, evt, {
                      maxVal: ce.saveDifficulte
                    });
                  }
                } else {
                  if (ce.condition.type == "moins") {
                    target.messages.push(
                      "Gr\xE2ce \xE0 sa " + ce.condition.text + ", " + target.tokName +
                      " n'est pas " + stringOfEtat(ce.etat, target));
                  }
                }
              });
            }
            let savesEffets = 0;
            // Ajoute les effets sans save \xE0 la cible
            let effets = options.effets;
            if (target.effets) {
              if (effets) effets = effets.concat(target.effets);
              else effets = target.effets;
            }
            if (effets) {
              effets.forEach(function(ef) {
                if (options.sortilege &&
                  (predicateAsBool(target, 'liberteDAction') && (
                    ef.effet == 'apeureTemp' ||
                    ef.effet == 'endormiTemp' ||
                    ef.effet == 'etourdiTemp' ||
                    ef.effet == 'immobiliseTemp' ||
                    ef.effet == 'paralyseTemp' ||
                    ef.effet == 'paralyseGoule' ||
                    ef.effet == 'ralentiTemp' ||
                    ef.entrave
                  )) ||
                  (predicateAsBool(target, 'actionLibre') && (
                    ef.effet == 'ralentiTemp' ||
                    ef.effet == 'immobiliseTemp' ||
                    ef.effet == 'paralyseTemp')) ||
                  ef.effet == 'paralyseGoule' ||
                  (ef.entrave && ef.effet != 'paralyseTemp' && ef.effet != 'paralyseGoule' && predicateAsInt(target, 'voieDeLArchange', 1) > 1 && attributeAsBool(target, 'formeDAnge'))
                ) {
                  target.messages.push(target.tokName + " reste libre de ses mouvements !");
                  return;
                }
                if (ef.effet == 'paralyseGoule' &&
                  (estElfe(target) ||
                    (predicateAsInt(target, 'voieDeLArchange', 1) > 2 && attributeAsBool(target, 'formeDAnge')))
                ) {
                  target.messages.push(target.tokName + " est immunis\xE9 \xE0 la paralysie des goules");
                  return;
                }
                if (ef.effet == 'affaibliTemp' && estMortVivant(attaquant) && predicateAsInt(target, 'voieDeLArchange', 1) > 2 && attributeAsBool(target, 'formeDAnge')) {
                  target.messages.push(target.tokName + " est insensible aux affaiblissements des morts-vivants.");
                  return;
                }
                if (ef.save) {
                  saves++;
                  savesEffets++;
                  return; //on le fera plus tard
                }
                if (ef.typeDmg && immuniseAuType(target, ef.typeDmg, attaquant)) {
                  if (!target['msgImmunite_' + ef.typeDmg]) {
                    target.messages.push(target.tokName + " ne semble pas affect\xE9 par " + stringOfType(ef.typeDmg));
                    target['msgImmunite_' + ef.typeDmg] = true;
                  }
                  return;
                }
                ef.attaquant = attaquant;
                setEffetTemporaire(target, ef, ef.duree, evt, options);
              });
            }
            // Tout ce qui se passe apr\xE8s les saves (autres que saves de diminution des dmg
            let afterSaves = function() {
              if (saves > 0) return; //On n'a pas encore fait tous les saves
              if (target.utiliseRuneProtection) {
                target.messages.push(target.tokName + " utilise sa Rune de Protection pour annuler les dommages");
                addToAttributeAsInt(target, 'limiteParCombat_runeForgesort_protection', 1, -1, evt);
                // Pas de d\xE9g\xE2ts, donc pas d'appel \xE0 dealDamage
                finCibles();
              } else if (options.pasDeDmg ||
                (additionalDmg.length === 0 && mainDmgRoll.total === 0 && attNbDices === 0)) {
                // Pas de d\xE9g\xE2ts, donc pas d'appel \xE0 dealDamage
                finCibles();
              } else {
                dealDamage(target, mainDmgRoll, additionalDmg, evt, target.critique,
                  options, target.messages,
                  function(dmgDisplay, dmg, dmgDrain) {
                    if (options.strigeSuce) {
                      var suce = attributeAsInt(attaquant, 'strigeSuce', 0);
                      if (suce === 0) {
                        setTokenAttr(attaquant, 'bufDEF', -3, evt);
                        target.messages.push(
                          attackerTokName + " s'agrippe \xE0 " + target.tokName +
                          " et commence \xE0 lui sucer le sang");
                      }
                      if (suce + dmg >= 6) {
                        target.messages.push(
                          "Repus, " + attackerTokName + " se d\xE9tache et s'envole");
                        target.messages.push(target.tokName + " se sent un peu faible...");
                        setState(target, 'affaibli', true, evt);
                        var defbuf = attributeAsInt(attaquant, 'bufDEF', 0);
                        if (defbuf === -3) {
                          removeTokenAttr(attaquant, 'bufDEF', evt);
                        } else if (defbuf !== 0) {
                          setTokenAttr(attaquant, 'bufDEF', defbuf + 3, evt);
                        }
                      } else {
                        setTokenAttr(attaquant, 'strigeSuce', suce + dmg, evt);
                        if (suce > 0)
                          target.messages.push(
                            attackerTokName + " continue \xE0 sucer le sang de " + target.tokName);
                      }
                    }
                    if (dmgDrain || (dmg > 0 && (options.vampirise || target.vampirise))) {
                      let pcVampirise = target.vampirise || options.vampirise;
                      let soinsVamp = dmgDrain || 0;
                      if (pcVampirise) soinsVamp += Math.ceil(dmg * pcVampirise / 100);
                      soigneToken(attaquant, soinsVamp, evt, function(soins) {
                        target.messages.push(
                          "L'attaque soigne " + attackerTokName + " de " + soins + " PV");
                      });
                    }
                    let absorptionEnergie = predicateAsInt(attaquant, 'absorptionEnergie', 0);
                    if (absorptionEnergie > 0) {
                      if (estMortVivant(attaquant) && predicateAsInt(target, 'voieDeLArchange', 1) > 2 && attributeAsBool(target, 'formeDAnge')) {
                        target.messages.push(target.tokName + "n'est pas affect\xE9" + eForFemale(target) + " par l'absorption d'\xE9nergie");
                      } else {
                        soigneToken(attaquant, absorptionEnergie, evt, function(soins) {
                          target.messages.push(
                            "L'attaque soigne " + attackerTokName + " de " + soins + " PV");
                        });
                      }
                    }
                    target.dmgMessage = "<b>DM :</b> ";
                    if (ficheAttributeAsBool(attaquant, 'jets_caches', false)) {
                      target.dmgMessage += dmg;
                      sendChat('COF', "/w GM Jet cach\xE9 de dommages : " + dmgDisplay);
                    } else {
                      target.dmgMessage += dmgDisplay;
                    }
                    if (options.contact) {
                      //Les DMs automatiques en cas de toucher une cible
                      if (attributeAsBool(target, 'sousTension')) {
                        ciblesCount++;
                        let exprSousTension = '[[' + getValeurStringOfEffet(target, 'sousTension', '1d6') + ']]';
                        sendChat('', exprSousTension, function(res) {
                          let rolls = res[0];
                          let explRoll = rolls.inlinerolls[0];
                          let r = {
                            total: explRoll.results.total,
                            type: 'electrique',
                            display: buildinline(explRoll, 'electrique', true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg, dmgDrain) {
                              let dmgMsg =
                                "<b>D\xE9charge \xE9lectrique sur " + attackerTokName + " :</b> " +
                                dmgDisplay;
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      }
                      if (attributeAsBool(target, 'sangMordant')) {
                        ciblesCount++;
                        sendChat("", "[[1d6]]", function(res) {
                          let rolls = res[0];
                          let explRoll = rolls.inlinerolls[0];
                          let r = {
                            total: explRoll.results.total,
                            type: 'acide',
                            display: buildinline(explRoll, 'acide', true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg, dmgDrain) {
                              var dmgMsg =
                                "<b>Le sang acide gicle sur " + attackerTokName + " :</b> " +
                                dmgDisplay + " DM";
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      }
                      if (options.armeNaturelle && attributeAsBool(target, 'presenceGlaciale')) {
                        ciblesCount++;
                        var exprPresenceGlaciale = '[[';
                        var attrsPGValeur = tokenAttribute(target, 'presenceGlacialeValeur');
                        if (attrsPGValeur.length === 0) exprPresenceGlaciale += '1d6';
                        else exprPresenceGlaciale += attrsPGValeur[0].get('max');
                        exprPresenceGlaciale += ']]';
                        sendChat("", exprPresenceGlaciale, function(res) {
                          var rolls = res[0];
                          var explRoll = rolls.inlinerolls[0];
                          var r = {
                            total: explRoll.results.total,
                            type: 'froid',
                            display: buildinline(explRoll, 'froid', true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg, dmgDrain) {
                              let dmgMsg =
                                "<b>" + attackerTokName + " est glac\xE9 :</b> " +
                                dmgDisplay + " DM";
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      }
                      let attrDmSiToucheContact = findObjs({
                        _type: 'attribute',
                        _characterid: target.charId,
                        name: 'dmSiToucheContact'
                      });
                      attrDmSiToucheContact.forEach(function(dstc) {
                        ciblesCount++;
                        sendChat("", "[[" + dstc.get('current') + "]]", function(res) {
                          let rolls = res[0];
                          let explRoll = rolls.inlinerolls[0];
                          let type = dstc.get('max');
                          let r = {
                            total: explRoll.results.total,
                            type: type,
                            display: buildinline(explRoll, type, true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg, dmgDrain) {
                              let dmgMsg =
                                "<b>" + attackerTokName + " subit :</b> " +
                                dmgDisplay + " DM en touchant " + target.tokName;
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      });
                      let typeCorpsElem = predicateAsBool(target, 'corpsElementaire');
                      if (typeCorpsElem && typeCorpsElem !== true) {
                        ciblesCount++;
                        let nbDes = predicateAsInt(target, 'nbCorpsElementaire', 1);
                        let dm = rollDePlus(6, {
                          type: typeCorpsElem,
                          nbDes
                        });
                        let r = {
                          type: typeCorpsElem,
                          display: dm.roll,
                          total: dm.val
                        };
                        dealDamage(attaquant, r, [], evt, false, options,
                          target.messages,
                          function(dmgDisplay, dmg, dmgDrain) {
                            let dmgMsg =
                              "<b>" + attackerTokName + " subit :</b> " +
                              dmgDisplay + " DM en touchant " + target.tokName;
                            target.messages.push(dmgMsg);
                            finCibles();
                          });
                      }
                    }
                    finCibles();
                  });
              }
            };
            let expliquer = function(msg) {
              target.messages.push(msg);
            };
            //Ajoute les \xE9tats avec save \xE0 la cible
            var etatsAvecSave = function() {
              if (savesEffets > 0) return; //On n'a pas encore fini avec les effets
              if (etats && saves > 0) {
                etats.forEach(function(ce, index) {
                  if (ce.save) {
                    if (testCondition(ce.condition, attaquant, [target], d20roll, options)) {
                      var msgPour = " pour r\xE9sister \xE0 un effet";
                      var msgEtat;
                      if (ce.etat == 'mort')
                        msgEtat = 'tu\xE9' + eForFemale(target);
                      else
                        msgEtat = stringOfEtat(ce.etat, target);
                      var msgRate = ", " + target.tokName + " est " + msgEtat + " par l'attaque";
                      var saveOpts = {
                        msgPour: msgPour,
                        msgRate: msgRate,
                        attaquant: attaquant,
                        sortilege: options.sortilege,
                        rolls: options.rolls,
                        chanceRollId: options.chanceRollId,
                        type: ce.typeDmg,
                        necromancie: estNecromancie(options)
                      };
                      var rollId = 'etat_' + ce.etat + index + '_' + target.token.id;
                      save(ce.save, target, rollId, expliquer, saveOpts, evt,
                        function(reussite, rolltext) {
                          if (!reussite) {
                            setState(target, ce.etat, true, evt);
                            if (ce.saveCarac) {
                              setTokenAttr(target, ce.etat + 'Save', ce.saveCarac, evt, {
                                maxVal: ce.saveDifficulte
                              });
                            }
                          }
                          saves--;
                          afterSaves();
                        });
                    } else {
                      if (ce.condition.type == "moins") {
                        target.messages.push(
                          "Gr\xE2ce \xE0 sa " + ce.condition.text + ", " + target.tokName +
                          " n'est pas " + stringOfEtat(ce.etat, target));
                      }
                      saves--;
                      afterSaves();
                    }
                  }
                });
              } else afterSaves();
            };
            // Ajoute les effets avec save \xE0 la cible
            var effetsAvecSave = function() {
              if (effets && savesEffets > 0) {
                effets.forEach(function(ef, index) {
                  if (ef.save) {
                    if (ef.gober) {
                      var rollIdGober = 'gober_' + target.token.id;
                      testOppose(rollIdGober, target, 'FOR', options, attaquant, 'FOR',
                        options, target.messages, evt,
                        function(resultat, crit, rt1, rt2) {
                          if (resultat == 2) {
                            target.messages.push(target.tokName + " est enti\xE8rement aval\xE9 par " + attackerTokName);
                            setTokenAttr(attaquant, 'aGobe', target.token.id + ' ' + target.tokName, evt);
                            setTokenAttr(target, 'estGobePar', attaquant.token.id + ' ' + attaquant.tokName, evt);
                            evt.movedTokens = evt.movedTokens || [];
                            evt.movedTokens.push({
                              token: target.token,
                              oldPosition: {
                                left: target.token.get('left'),
                                top: target.token.get('top'),
                              },
                              newPosition: {
                                left: attaquant.token.get('left'),
                                top: attaquant.token.get('top'),
                              }
                            });
                            target.token.set('left', attaquant.token.get('left'));
                            target.token.set('top', attaquant.token.get('top'));
                          } else {
                            if (resultat === 0) diminueMalediction(attaquant, evt);
                            target.messages.push(target.tokName + " n'est pas aval\xE9.");
                          }
                          saves--;
                          savesEffets--;
                          etatsAvecSave();
                        });
                    } else {
                      if (ef.typeDmg && immuniseAuType(target, ef.typeDmg, attaquant)) {
                        if (!target['msgImmunite_' + ef.typeDmg]) {
                          target.messages.push(target.tokName + " ne semble pas affect\xE9 par " + stringOfType(ef.typeDmg));
                          target['msgImmunite_' + ef.typeDmg] = true;
                        }
                        saves--;
                        savesEffets--;
                        etatsAvecSave();
                        return;
                      }
                      var msgPour = " pour r\xE9sister \xE0 un effet";
                      var msgRate = ", " + target.tokName + " ";
                      if (ef.duree && ef.message) {
                        msgRate += messageActivation(target, ef.message);
                        if (stateCOF.options.affichage.val.duree_effets.val) msgRate += " (" + ef.duree + " tours)";
                      } else if (ef.effetIndetermine)
                        msgRate += messageEffetIndetermine[ef.effet].activation;
                      else
                        msgRate += messageEffetCombat[ef.effet].activation;
                      ef.pasDeMessageDActivation = true;
                      var saveOpts = {
                        msgPour: msgPour,
                        msgRate: msgRate,
                        attaquant: attaquant,
                        rolls: options.rolls,
                        sortilege: options.sortilege,
                        chanceRollId: options.chanceRollId,
                        type: ef.typeDmg,
                        necromancie: estNecromancie(options)
                      };
                      var rollId = 'effet_' + ef.effet + index + '_' + target.token.id;
                      var duree = ef.duree;
                      save(ef.save, target, rollId, expliquer, saveOpts, evt,
                        function(reussite, rollText) {
                          if (reussite && duree && ef.save.demiDuree) {
                            reussite = false;
                            duree = Math.ceil(duree / 2);
                            if (stateCOF.options.affichage.val.duree_effets.val) expliquer("La dur\xE9e est r\xE9duite \xE0 " + duree + " tours");
                          }
                          if (!reussite) {
                            ef.attaquant = attaquant;
                            setEffetTemporaire(target, ef, duree, evt, options);
                          }
                          saves--;
                          savesEffets--;
                          etatsAvecSave();
                        });
                    }
                  }
                });
              } else etatsAvecSave();
            };
            var effetPietinement = function() {
              if ((target.pietine || target.percute) && estAussiGrandQue(attaquant, target)) {
                var rollId = 'pietinement' + target.token.id;
                testOppose(rollId, target, 'FOR', options, attaquant, 'FOR',
                  options, target.messages, evt,
                  function(resultat, crit, rt1, rt2) {
                    if (resultat == 2) {
                      target.messages.push(target.tokName + " est pi\xE9tin\xE9 par " + attackerTokName + ", dommages doubl\xE9s");
                      setState(target, 'renverse', true, evt);
                      target.dmgCoef = (target.dmgCoef || 0) + 1;
                      target.touche++;
                      if (target.percute) {
                        target.messages.push(target.tokName + " est projet\xE9 \xE0 " +
                          rollDePlus(6, {
                            bonus: 1
                          }).roll + " m\xE8tres");
                        effets = effets || [];
                        effets.push({
                          effet: 'etourdiTemp',
                          duree: 100,
                          message: messageOfEffetTemp('etourdiTemp'),
                          save: {
                            carac: 'CON',
                            seuil: 15
                          },
                          saveParTour: {
                            carac: 'CON',
                            seuil: 15
                          }
                        });
                        savesEffets++;
                      }
                    } else {
                      if (resultat === 0) diminueMalediction(attaquant, evt);
                      target.messages.push(target.tokName + " n'est pas pi\xE9tin\xE9.");
                    }
                    effetsAvecSave();
                  });
              } else effetsAvecSave();
            };
            // Peut faire peur \xE0 la cible
            if (options.peur) {
              peurOneToken(target, options.peur.seuil,
                options.peur.duree, {
                  resisteAvecForce: true
                }, target.messages, evt, effetPietinement);
            } else effetPietinement();
          } else {
            evt.succes = false;
            finCibles();
          }
        });
      });
    }); //Fin de la boucle pour toutes cibles
  }

  function suggererEchecCritique(attaquant, weaponStats, cibles, options, evt) {
    var d12roll = randomInteger(12);
    var estMag = options.sortilege;
    var avecArme = weaponStats.arme;
    var estCac = options.contact;
    var boutonCritique = function(action) {
      var b = boutonSimple(action + " --target " + attaquant.token.id,
        "Appliquer", 'background-color:#cc0000');
      return b;
    };
    var msg;
    switch (d12roll) {
      case 1:
        msg = "\xC9chec total : ";
        if (estMag) {
          msg += "le lanceur de sort perd le contr\xF4le de la magie qu'il canalise et subit 1d4 dommages en retour par rang du sort lanc\xE9. ";
          msg += boutonCritique("!cof-dmg ?{Rang du sort}d4 --ignoreRD");
        } else {
          msg += "l'attaquant se blesse lui-m\xEAme et s'inflige la moiti\xE9 des d\xE9g\xE2ts de son attaque. L'attaquant ne peut plus attaquer ce tour. ";
          msg += boutonCritique("!cof-bouton-echec-total " + evt.id);
        }
        return msg;
      case 2:
        var difficulte = 0;
        if (estCac) {
          var tailleAttaquant = taillePersonnage(attaquant, 4);
          cibles.forEach(function(cible) {
            difficulte = Math.max(difficulte, 12 - ((tailleAttaquant - taillePersonnage(cible, 4)) * 2));
          });
        } else {
          difficulte = 12;
        }
        msg = "Bouscul\xE9 (FOR) : l'attaquant est d\xE9s\xE9quilibr\xE9 par son attaque ";
        msg += boutonCritique("!cof-set-state renverse true --save FOR " + difficulte);
        return msg;
      case 3:
        if (avecArme) {
          msg = "Maladresse (DEX) : l'attaquant laisse \xE9chapper son arme qui tombe hors de port\xE9e imm\xE9diate.";
          msg += boutonCritique("!cof-degainer --save DEX 12");
          return msg;
        }
        msg = "D\xE9s\xE9quilibr\xE9 (DEX) : l'attaquant est Ralenti pendant 3 tours.";
        msg += boutonCritique("!cof-effet-temp ralentiTemp 3 --save DEX 12");
        return msg;
      case 4:
        msg = "Coup de mou (CON) : l'attaquant est affaibli pendant 3 tours, ou jusqu'\xE0 ce qu'il consacre un tour ou 1 PR pour se r\xE9tablir.";
        msg += boutonCritique("!cof-effet-temp affaibliTemp 3 --save CON 12");
        return msg;
      case 5:
        if (estCac) {
          msg = "Erreur tactique (INT) : le personnage provoque une attaque (gratuite) d\x2019un adversaire \xE0 son contact.";
          msg += boutonCritique("!cof-jet INT 12");
        } else if (estMag) {
          msg = "Aveugl\xE9 (INT) : le personnage ne contr\xF4le pas sa puissance et une partie de celle-ci \xE9met un flash qui l'aveugle temporairement.";
          msg += boutonCritique("!cof-effet-temp aveugleTemp 3 --save INT 12 --saveParTour CON 12");
        } else {
          //TODO : Impl\xE9menter un bouton "mauvais calcul" r\xE9alisant une attaque automatique sur un des Obstacle
          msg = "Mauvais calcul (INT) : le personnage a une chance de toucher une autre cible sur la trajectoire de son tir. D\xE9terminer la cible au hasard et relancer une attaque sur cette nouvelle cible.";
          msg += boutonCritique("!cof-jet INT 12");
        }
        return msg;
      case 6:
        if (estCac) {
          msg = "Expos\xE9 (SAG) : l'adversaire dispose d'un bonus de +10 \xE0 la touche pendant un round.";
          cibles.forEach(function(cible) {
            msg += boutonCritique("!cof-effet-temp expose 1 --valeur " + cible.token.id + " --save SAG 12");
          });
        } else {
          msg = "Distrait (SAG) : le personnage est Ralenti pendant 3 tours ";
          msg += boutonCritique("!cof-effet-temp ralentiTemp 3 --save SAG 12");
        }
        return msg;
      case 7:
        msg = "Ridicule (CHA) : le personnage fait un faux mouvement \xE0 la fois douloureux et ridicule, il subit l\x2019\xE9tat \xE9tourdi pendant un round pour reprendre contenance. ";
        msg += boutonCritique("!cof-effet-temp etourdiTemp 1 --save CHA 12");
        return msg;
      case 8:
        msg = "Inconfort : Une pi\xE8ce d\x2019armure bouge et elle devient plus g\xEAnante que protectrice. Malus en DEF et en attaque pour le reste du combat => Cuir : -1, Maille : -2, Plaque -3. ";
        msg += boutonCritique("!cof-effet-combat inconfort --valeur ?{Malus ?|-1,1|-2,2|-3,3} --save CHA 12");
        return msg;
      default:
        return "L'attaquant s'en tire bien cette fois-ci, pas d'effet particulier";
    }
  }

  function montrerResultatsAttaque(msg) {
    if (stateCOF.currentAttackDisplay) {
      sendChat('', endFramedDisplay(stateCOF.currentAttackDisplay));
      stateCOF.currentAttackDisplay = undefined;
      if (stateCOF.afterDisplay) {
        stateCOF.afterDisplay.forEach(function(d) {
          sendPerso(d.destinataire, d.msg, true);
        });
        stateCOF.afterDisplay = undefined;
      }
    } else {
      sendPlayer(msg, "Pas de r\xE9sultat d'attaque \xE0 montrer");
    }
  }

  function sendDisplay(display, perso, autres, options) {
    if (stateCOF.options.affichage.val.MJ_valide_affichage_attaques.val) {
      let players = findObjs({
        _type: 'player'
      });
      let joueur;
      let gm;
      players.forEach(function(p) {
        if (!p.get('online')) return;
        if (playerIsGM(p.id)) gm = true;
        else joueur = true;
      });
      if (gm && joueur) {
        stateCOF.currentAttackDisplay = {...display
        };
        addLineToFramedDisplay(display, boutonSimple('!cof-montrer-resultats-attaque', "Montrer aux joueurs"));
        addFramedHeader(display, undefined, 'gm');
        sendChat('', endFramedDisplay(display));
        return;
      }
    }
    if (options === undefined || !options.secret) {
      sendChat('', endFramedDisplay(display));
    } else {
      let playerIds = getPlayerIds(perso);
      playerIds.forEach(function(playerid) {
        addFramedHeader(display, playerid, true);
        sendChat('', endFramedDisplay(display));
      });
      addFramedHeader(display, undefined, 'gm');
      sendChat('', endFramedDisplay(display));
      autres.forEach(function(target) {
        let addPlayers = getPlayerIds(target);
        addPlayers.forEach(function(nid) {
          if (!playerIds.includes(nid)) {
            playerIds.push(nid);
            addFramedHeader(display, nid, true);
            sendChat('', endFramedDisplay(display));
          }
        });
      });
    }
    if (stateCOF.afterDisplay) {
      stateCOF.afterDisplay.forEach(function(d) {
        sendPerso(d.destinataire, d.msg, true);
      });
      stateCOF.afterDisplay = undefined;
    }
  }

  //Affichage final d'une attaque
  // attaquant est optionnel, mais si il est pr\xE9sent, cibles doit \xEAtre un tableau et options un objet
  function finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique) {
    echecCritique = echecCritique || false;
    explications.forEach(function(expl) {
      addLineToFramedDisplay(display, expl, 80);
    });
    if (evt.action) {
      let perso = evt.action.attaquant;
      evt.personnage = perso;
      if (options.preDmg) {
        let cerclesDeProtection = [];
        cibles.forEach(function(target) {
          let preDmgToken = options.preDmg[target.token.id];
          let action;
          if (preDmgToken !== undefined) {
            let nbBoutons = 0;
            let line = target.tokName + " peut :";
            if (preDmgToken.encaisserUnCoup) {
              line += "<br/>" +
                boutonSimple(
                  "!cof-encaisser-un-coup " + evt.id + ' --target ' + target.token.id,
                  "encaisser le coup");
              nbBoutons++;
            }
            if (preDmgToken.devierLesCoups) {
              line += "<br/>" +
                boutonSimple(
                  "!cof-devier-les-coups " + evt.id + ' --target ' + target.token.id,
                  "d\xE9vier les coups");
              nbBoutons++;
            }
            if (preDmgToken.paradeDeProjectiles) {
              line += "<br/>" +
                boutonSimple(
                  "!cof-parade-projectiles " + evt.id + ' --target ' + target.token.id,
                  "parer le projectile");
              nbBoutons++;
            }
            if (preDmgToken.paradeAuBouclier && preDmgToken.paradeAuBouclier !== 'reroll') {
              action = "!cof-parade-au-bouclier " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "tenter une parade au bouclier");
              nbBoutons++;
            }
            if (preDmgToken.esquiveAcrobatique && preDmgToken.esquiveAcrobatique !== 'reroll') {
              action = "!cof-esquive-acrobatique " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "tenter une esquive acrobatique");
              nbBoutons++;
            }
            if (preDmgToken.expertDuCombatDEF) {
              action = "!cof-expert-combat-def " + evt.id + " " + target.token.id;
              line += "<br/>" + boutonSimple(action, "utiliser expert du combat");
              nbBoutons++;
            }
            if (preDmgToken.esquiveFatale) {
              preDmgToken.esquiveFatale.forEach(function(tok) {
                line += "<br/>" +
                  boutonSimple(
                    "!cof-esquive-fatale " + evt.id + ' ' + tok.id,
                    "effectuer une esquive fatale vers " + tok.get('name'));
                nbBoutons++;
              });
            }
            if (preDmgToken.resistanceALaMagieBarbare && preDmgToken.resistanceALaMagieBarbare !== 'reroll') {
              action = "!cof-resister-a-la-magie " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "tenter de r\xE9sister \xE0 la magie");
              nbBoutons++;
            }
            if (preDmgToken.cercleDeProtection && preDmgToken.cercleDeProtectionDe &&
              preDmgToken.cercleDeProtection !== 'reroll') {
              cerclesDeProtection.push({
                nom: preDmgToken.cercleDeProtectionDe,
                target: target
              });
            }
            if (preDmgToken.runeForgesort_protection) {
              line += "<br/>" +
                boutonSimple(
                  "!cof-rune-protection " + evt.id + ' --target ' + target.token.id,
                  "utiliser sa Rune de Protection");
              nbBoutons++;
            }
            if (preDmgToken.chairACanon) {
              preDmgToken.chairACanon.forEach(function(tok) {
                line += "<br/>" + boutonSimple("!cof-chair-a-canon " + target.token.id + ' ' + tok.id + ' ' + evt.id, "utiliser " + tok.get('name') + " comme chair \xE0 canon");
                nbBoutons++;
              });
            }
            if (preDmgToken.alliesAvecInterception) {
              preDmgToken.alliesAvecInterception.forEach(function(perso) {
                let line = "<br/>" + perso.token.get('name') + " peut" + boutonSimple("!cof-intercepter " + evt.id + ' ' + target.token.id + " --target " + perso.token.id, "intercepter") + "l'attaque sur " + target.tokName;
                addLineToFramedDisplay(display, line);
              });
            }
            if (preDmgToken.paradeMagistrale && preDmgToken.paradeMagistrale !== 'reroll') {
              action = "!cof-esquive-magistrale ";
              var actionParade = "esquive acrobatique";
              if (options.contact) {
                if (target.armesEnMain === undefined) armesEnMain(target);
                if (target.arme && !target.arme.portee) {
                  action = "!cof-parade-magistrale ";
                  actionParade = "parade magistrale";
                }
              }
              action += target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "tenter une " + actionParade);
              nbBoutons++;
            }
            if (preDmgToken.absorberUnSort && preDmgToken.absorberUnSort !== 'reroll') {
              action = "!cof-absorber-sort-au-bouclier " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "absorber le sort");
              nbBoutons++;
            }
            if (preDmgToken.absorberUnCoup && preDmgToken.absorberUnCoup !== 'reroll') {
              action = "!cof-absorber-coup-au-bouclier " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "absorber le coup");
              nbBoutons++;
            }
            if (nbBoutons > 0) addLineToFramedDisplay(display, line);
          }
        });
        if (cerclesDeProtection.length > 0) {
          cerclesDeProtection.forEach(function(cercle) {
            addLineToFramedDisplay(display,
              cercle.nom + " peut " + boutonSimple("!cof-cercle-protection " + cercle.target.token.id + ' ' + evt.id,
                "activer le Cercle de Protection"));
          });
        }
        if (options.preDmg.runeDePuissance) {
          let al = options.preDmg.runeDePuissance;
          let permanent = options.runeDePuissance ? ' permanent' : '';
          addLineToFramedDisplay(display,
            boutonSimple("!cof-bouton-rune-puissance " + al + ' ' + evt.id + permanent,
              "Rune de puissance"));
        }
        addLineToFramedDisplay(display, boutonSimple("!cof-confirmer-attaque " + evt.id, "Continuer"));
      } else {
        if (evt.succes === false) {
          var pc = pointsDeChance(perso);
          if (pc > 0 && !echecCritique) {
            addLineToFramedDisplay(display, boutonSimple("!cof-bouton-chance " + evt.id, "Chance") + " (reste " + pc + " PC)");
          }
          if (attributeAsBool(perso, 'runeForgesort_\xE9nergie') &&
            attributeAsInt(perso, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0) {
            addLineToFramedDisplay(display, boutonSimple("!cof-bouton-rune-energie " + evt.id, "Rune d'\xE9nergie"));
          }
          if (capaciteDisponible(perso, 'petitVeinard', 'combat')) {
            addLineToFramedDisplay(display, boutonSimple("!cof-bouton-petit-veinard " + evt.id, "Petit veinard"));
          }
          let pacteSanglant = predicateAsInt(perso, 'pacteSanglant', 0);
          if (pacteSanglant >= 3) {
            addLineToFramedDisplay(display, boutonSimple("!cof-pacte-sanglant " + evt.id + " 3", "Pacte sanglant (+3)"));
            if (pacteSanglant >= 5) {
              addLineToFramedDisplay(display, boutonSimple("!cof-pacte-sanglant " + evt.id + " 5", "Pacte sanglant (+5)"));
            }
          }
          if (predicateAsInt(perso, 'expertDuCombat', 0) > 0 &&
            attributeAsInt(perso, 'limiteParCombat_expertDuCombat', 1) > 0 &&
            attributeAsInt(perso, 'limiteParTour_expertDuCombat', 1) > 0 &&
            !options.expertDuCombatTouche) {
            addLineToFramedDisplay(display, boutonSimple("!cof-expert-combat-touche " + evt.id, "Expert du Combat (Att. +1D6)"));
          }
        } else {
          if (predicateAsInt(perso, 'expertDuCombat', 0) > 2 &&
            attributeAsInt(perso, 'limiteParCombat_expertDuCombat', 1) > 0 &&
            attributeAsInt(perso, 'limiteParTour_expertDuCombat', 1) > 0 &&
            !options.expertDuCombatDM) {
            addLineToFramedDisplay(display, boutonSimple("!cof-expert-combat-dm " + evt.id, "Expert du Combat (DM +1D6)"));
          }
          if (capaciteDisponible(perso, 'kiai', 'combat') &&
            !attributeAsBool(perso, 'rechargeDuKiai')) {
            addLineToFramedDisplay(display,
              boutonSimple("!cof-bouton-pousser-kiai " + evt.id, "Kiai"));
          }
          if (capaciteDisponible(perso, 'petitVeinard', 'combat')) {
            addLineToFramedDisplay(display, boutonSimple("!cof-bouton-petit-veinard " + evt.id, "Petit veinard") + " pour relancer un d\xE9");
          }
        }
        if (options && options.contact && cibles && attaquant &&
          predicateAsBool(attaquant, 'enchainement')) {
          let cibleMorte = cibles.find(function(target) {
            return target.token.get('bar1_value') == 0;
          });
          if (cibleMorte) {
            if (attaquant.ennemisAuContact === undefined) {
              let tokensContact = findObjs({
                _type: 'graphic',
                _subtype: "token",
                _pageid: evt.action.pageId,
                layer: 'objects'
              });
              tokensContact = tokensContact.filter(function(tok) {
                if (tok.id == attaquant.token.id) return false;
                return distanceCombat(attaquant.token, tok, evt.action.pageId) === 0;
              });
              let tokensEnnemis = [];
              let allies = alliesParPerso[attaquant.charId] || new Set();
              tokensContact.forEach(function(tok) {
                let ci = tok.get('represents');
                if (ci === '') return; //next token au contact
                if (!isActive({
                    token: tok,
                    charId: ci
                  })) return;
                if (!allies.has(ci)) tokensEnnemis.push(tok);
              });
              attaquant.ennemisAuContact = tokensEnnemis;
            }
            if (attaquant.ennemisAuContact.length > 0) {
              var msgEnchainement = attaquant.token.get('name') + " a droit \xE0 une attaque au contact gratuite contre ";
              var sep = "";
              var armeEnMain = tokenAttribute(attaquant, 'armeEnMain');
              var act;
              if (armeEnMain.length === 0) {
                armeEnMain = false;
              } else {
                armeEnMain = armeEnMain[0].get('current');
                act = '!cof-attack ' + attaquant.token.id + ' ';
              }
              msgEnchainement += sep;
              attaquant.ennemisAuContact.forEach(function(tok) {
                if (armeEnMain) {
                  msgEnchainement += boutonSimple(act + tok.id + ' ' + armeEnMain, tok.get('name'));
                } else {
                  msgEnchainement += tok.get('name');
                }
                sep = ", ou ";
              });
              addLineToFramedDisplay(display, msgEnchainement);
            }
          }
        }
        if (evt.action.options && !evt.action.options.auto && evt.action.cibles) {
          evt.action.cibles.forEach(function(target) {
            if (!options.pasDeDmg && target.touche &&
              predicateAsBool(target, 'ignorerLaDouleur') &&
              attributeAsInt(target, 'douleurIgnoree', 0) === 0) {
              addLineToFramedDisplay(display, target.tokName + " peut " +
                boutonSimple("!cof-ignorer-la-douleur " + evt.id + ' --target ' + target.token.id, "ignorer la douleur")
              );
            }
            let pacteSanglant = predicateAsInt(target, 'pacteSanglant', 0);
            if (pacteSanglant >= 3) {
              let msg = target.tokName + " fait un Pacte sanglant" + boutonSimple("!cof-pacte-sanglant-def " + evt.id + ' 3 ' + target.token.id, "(+3 DEF)");
              if (pacteSanglant >= 5) {
                msg += boutonSimple("!cof-pacte-sanglant-def " + evt.id + ' 5 ' + target.token.id, "(+5 DEF)");
              }
              addLineToFramedDisplay(display, msg);
            }
          });
        }
      }
    }
    sendDisplay(display, attaquant, cibles, options);
    if (attaquant) {
      cibles.forEach(function(target) {
        if (evt.succes == false && options.contact && capaciteDisponible(target, 'riposteGuerrier', 'tour')) {
          displayAttaqueOpportunite(target.token.id, [attaquant], "de riposte", 'Ripostes', '--decrLimitePredicatParTour riposteGuerrier');
        } else if (attributeAsBool(target, 'seulContreTous')) {
          displayAttaqueOpportunite(target.token.id, [attaquant], "de riposte", 'Ripostes');
        } else if (predicateAsBool(target, 'riposte')) {
          var attrCiblesDeLaCible = tokenAttribute(target, 'dernieresCiblesAttaquees');
          if (attrCiblesDeLaCible.length > 0) {
            var ripostesDuTour =
              attrCiblesDeLaCible[0].get('max').split(' ');
            ripostesDuTour = new Set(ripostesDuTour);
            if (ripostesDuTour.has(attaquant.token.id)) return;
            ripostesDuTour = attrCiblesDeLaCible[0].get('current').split(' ');
            ripostesDuTour = new Set(ripostesDuTour);
            if (ripostesDuTour.has(attaquant.token.id)) return;
          }
          displayAttaqueOpportunite(target.token.id, [attaquant], "de riposte", 'Ripostes', '--riposte');
        }
      });
    }
  }

  // RD sp\xE9cifique au type
  function typeRD(rd, dmgType) {
    if (dmgType === undefined || dmgType == 'normal') return 0;
    return (rd[dmgType] || 0);
  }

  function probaSucces(de, seuil, nbreDe) {
    if (nbreDe == 2) {
      let proba1 = probaSucces(de, seuil, 1);
      return 1 - (1 - proba1) * (1 - proba1);
    }
    if (seuil < 2) seuil = 2; // 1 est toujours un \xE9chec
    else if (seuil > 20) seuil = 20;
    return ((de - seuil) + 1) / de;
  }

  function nbreDeTestCarac(carac, perso) {
    let typeJet = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
      name: carac + '_SUP'
    }, {
      caseInsensitive: true
    });
    if (typeJet.length === 0) return 1;
    typeJet = typeJet[0].get('current');
    switch (typeJet) {
      case '@{JETNORMAL}':
      case '@{jetnormal}':
        return 1;
      case '@{JETSUP}':
      case '@{jetsup}':
      case '@{JETSUPHERO}':
      case '@{jetsuphero}':
        return 2;
      default:
        if (typeJet.startsWith('1d')) return 1;
        if (typeJet.startsWith('2d')) return 2;
        error("Jet inconnu", typeJet);
    }
    return 1;
  }

  // Meilleure carac parmis 2 pour un save.
  function meilleureCarac(carac1, carac2, personnage, seuil) {
    var sansEsprit;
    if (carac1 == 'SAG' || carac1 == 'INT' || carac1 == 'CHA') {
      sansEsprit = predicateAsBool(personnage, 'sansEsprit');
      if (sansEsprit) return carac1;
    }
    if (sansEsprit === undefined &&
      (carac2 == 'SAG' || carac2 == 'INT' || carac2 == 'CHA')) {
      sansEsprit = predicateAsBool(personnage, 'sansEsprit');
      if (sansEsprit) return carac2;
    }
    var options = {
      cacheBonusToutesCaracs: {}
    };
    var bonus1 = bonusTestCarac(carac1, personnage, options);
    if (carac1 == 'DEX') {
      bonus1 += predicateAsInt(personnage, 'reflexesFelins', 0);
      bonus1 += predicateAsInt(personnage, 'esquiveVoleur', 0);
    }
    var bonus2 = bonusTestCarac(carac2, personnage, options);
    if (carac2 == 'DEX') {
      bonus2 += predicateAsInt(personnage, 'reflexesFelins', 0);
      bonus2 += predicateAsInt(personnage, 'esquiveVoleur', 0);
    }
    var nbrDe1 = nbreDeTestCarac(carac1, personnage);
    var nbrDe2 = nbreDeTestCarac(carac2, personnage);
    if (estAffaibli(personnage) && predicateAsBool(personnage, 'insensibleAffaibli')) seuil += 2;
    var de1 = deTest(personnage, carac1);
    var proba1 = probaSucces(de1, seuil - bonus1, nbrDe1);
    var de2 = deTest(personnage, carac2);
    var proba2 = probaSucces(de2, seuil - bonus2, nbrDe2);
    if (proba2 > proba1) return carac2;
    return carac1;
  }

  //s repr\xE9sente le save, avec une carac, une carac2 optionnelle et un seuil
  //expliquer est une fonction qui prend en argument un string et le publie
  // options peut contenir les champs :
  //   - msgPour : message d'explication \xE0 afficher avant le jet
  //   - msgReussite : message \xE0 afficher en cas de r\xE9ussite
  //   - msgRate : message \xE0 afficher si l'action rate
  //   - attaquant : le {charId, token} de l'attaquant contre lequel le save se fait (si il y en a un)
  //   - type : le type de d\xE9g\xE2ts contre lequel on fait le save
  //   - hideSaveTitle : cache le titre du save
  //   - bonus : bonus au jet de save
  // s peut contenir:
  //   - carac : la caract\xE9ristique \xE0 utiliser pour le save
  //   - carac2 : caract\xE9ristique alternative
  //   - seuil : la difficult\xE9 du jet de sauvegarde
  //   - contact : la difficult\xE9 si la cible est au contact de options.attaquant
  //   - fauchage
  //   - entrave (pour les action qui immobilisent, ralentissent ou paralysent)
  //   - necromancie
  //   - sortilege
  function save(s, target, saveId, expliquer, options, evt, afterSave) {
    target.tokName = target.tokName || target.token.get('name');
    if (options.type && immuniseAuType(target, options.type, options.attaquant)) {
      if (!target['msgImmunite_' + options.type]) {
        expliquer(target.tokName + " ne semble pas affect\xE9 par " + stringOfType(options.type));
        target['msgImmunite_' + options.type] = true;
      }
      afterSave(true, '');
      return;
    }
    if (s.fauchage) {
      if (s.fauchage <= taillePersonnage(target, 4)) {
        expliquer(target.tokName + " est trop grand pour \xEAtre fauch\xE9.");
        afterSave(true, '');
        return;
      }
      if (predicateAsBool(target, 'inderacinable')) {
        expliquer(target.tokName + " est ind\xE9racinable.");
        afterSave(true, '');
        return;
      }
    }
    let bonus = options.bonus || 0;
    if (options.attaquant &&
      attributeAsBool(target, 'protectionContreLeMal') &&
      estMauvais(options.attaquant)) {
      let bonusProtectionContreLeMal = getValeurOfEffet(target, 'protectionContreLeMal', 2);
      bonus += bonusProtectionContreLeMal;
      expliquer("Protection contre le mal => +" + bonusProtectionContreLeMal + " au jet de sauvegarde");
    }
    if (s.entrave && predicateAsBool(target, 'actionLibre')) {
      bonus += 5;
      expliquer("Action libre => +5 pour r\xE9sister aux entraves");
    }
    if (options.necromancie && attributeAsBool(target, 'sangDeLArbreCoeur')) {
      bonus += 5;
      expliquer("Sang de l'Arbre-Coeur => +5 pour r\xE9sister \xE0 la n\xE9cromancie");
    }
    if (predicateAsBool(target, 'liberateurDAnathazerin') && options.type == 'poison') {
      bonus += 2;
      expliquer("Lib\xE9rateur d'Anathazer\xEFn => +2 pour r\xE9sister au poison");
    }
    let bonusAttrs = [];
    let bonusPreds = [];
    let seuil = s.seuil;
    if (s.contact && options.attaquant && distanceCombat(options.attaquant.token, target.token) === 0) {
      seuil = s.contact;
    }
    let carac = s.carac;
    //Cas o\xF9 le save peut se faire au choix parmis 2 caracs
    if (s.carac2) {
      carac = meilleureCarac(carac, s.carac2, target, seuil);
    }
    if (carac == 'DEX') {
      bonusPreds.push('reflexesFelins');
      bonusPreds.push('esquiveVoleur');
    }
    if (options.sortilege) {
      bonusPreds.push('resistanceALaMagie');
      if (carac == 'SAG') bonusAttrs.push('bonusSagesseMagie');
    }
    if (options.type) {
      bonusPreds.push('bonusSaveContre_' + options.type);
    }
    if (!options.hideSaveTitle) {
      let title = " Jet de " + carac + " " + seuil;
      if (options.msgPour) title += options.msgPour;
      expliquer(title);
    }
    let optionsTest = {...options
    };
    optionsTest.bonusAttrs = bonusAttrs;
    optionsTest.bonusPreds = bonusPreds;
    optionsTest.bonus = bonus;
    testCaracteristique(target, carac, seuil, saveId, optionsTest, evt,
      function(tr, explications) {
        let smsg = target.tokName + " fait ";
        if (explications.length === 0) {
          smsg += tr.texte;
        } else {
          smsg += '<span title="';
          explications.forEach(function(e, i) {
            if (i > 0) smsg += "&#13;";
            smsg += e;
          });
          smsg += '">' + tr.texte + '</span>';
        }
        if (tr.reussite) {
          smsg += " => r\xE9ussite";
          if (options.msgReussite) smsg += options.msgReussite;
          smsg += tr.modifiers;
        } else {
          smsg += " => \xE9chec";
          if (options.msgRate) smsg += options.msgRate;
          smsg += tr.rerolls + tr.modifiers;
        }
        expliquer(smsg);
        afterSave(tr.reussite, tr.texte);
      });
  }

  function partialSave(ps, target, showTotal, dmgDisplay, total, expliquer, evt, afterSave) {
    let sav = ps.totalSave;
    let totalSave = true;
    if (sav === undefined) {
      sav = ps.partialSave;
      totalSave = false;
    }
    if (sav === undefined) {
      if (target.partialSaveAuto) {
        if (showTotal) dmgDisplay = '(' + dmgDisplay + ')';
        afterSave({
          succes: true,
          dmgDisplay: dmgDisplay + '/2',
          total: Math.ceil(total / 2),
          showTotal: true
        });
        return;
      }
      afterSave();
      return;
    }
    if ((sav.carac == 'CON' || sav.carac2 == 'CON') && estNonVivant(target)) {
      expliquer("Les cr\xE9atures non-vivantes sont immnunis\xE9es aux attaques qui demandent un test de constitution");
      afterSave({
        succes: true,
        dmgDisplay: '0',
        total: 0,
        showTotal: false
      });
      return;
    }
    if (!totalSave && target.partialSaveAuto) {
      if (showTotal) dmgDisplay = '(' + dmgDisplay + ')';
      afterSave({
        succes: true,
        dmgDisplay: dmgDisplay + '/2',
        total: Math.ceil(total / 2),
        showTotal: true
      });
      return;
    }
    let saveOpts = {
      msgPour: " pour r\xE9duire les d\xE9g\xE2ts",
      msgReussite: ", d\xE9g\xE2ts divis\xE9s par 2",
      attaquant: ps.attaquant,
      rolls: ps.rolls,
      chanceRollId: ps.chanceRollId,
      type: ps.type
    };
    if (totalSave) {
      saveOpts.msgPour = " pour \xE9viter les d\xE9g\xE2ts";
      saveOpts.msgReussite = ", d\xE9g\xE2ts \xE9vit\xE9s";
    }
    let saveId = 'parseSave_' + target.token.id;
    save(sav, target, saveId, expliquer, saveOpts, evt,
      function(succes, rollText) {
        if (succes) {
          if (totalSave) {
            dmgDisplay = '0';
            total = 0;
          } else {
            if (showTotal) dmgDisplay = "(" + dmgDisplay + ")";
            dmgDisplay = dmgDisplay + " / 2";
            showTotal = true;
            total = Math.ceil(total / 2);
          }
        }
        afterSave({
          succes: succes,
          dmgDisplay: dmgDisplay,
          total: total,
          showTotal: showTotal
        });
      });
  }

  function getRDS(perso) {
    if (perso.rd) return perso.rd;
    var res = {
      rdt: 0,
      sauf: {}
    };
    //Pour garder un peu de compatibilit\xE9, on regarde encore les attributs RD
    var attrs = perso.attrs;
    if (attrs === undefined) {
      attrs = findObjs({
        _type: "attribute",
        _characterid: perso.charId
      });
      perso.attrs = attrs;
    }
    attrs.forEach(function(a) {
      var name = a.get('name');
      if (!name.startsWith('RD_')) return;
      var rds = parseInt(a.get('current'));
      if (isNaN(rds) || rds === 0) return;
      name = name.substring(3);
      if (name.startsWith('sauf_')) {
        name = name.substr(5);
        res.sauf[name] = res.sauf[name] || 0;
        res.sauf[name] += rds;
        return;
      }
      if (name == 'rdt' || name == 'sauf') return;
      res[name] = res[name] || 0;
      res[name] += rds;
    });
    //Fin compatibilit\xE9
    if (attributeAsBool(perso, 'formeDArbre')) {
      res.sauf.feu_hache = res.sauf.feu_hache || 0;
      res.sauf.feu_hache += 10;
    }
    if (predicateAsBool(perso, 'fievreChene')) res.feu = (res.feu || 0) + 5;
    if (attributeAsBool(perso, 'armureDEau')) {
      res.acide = (res.acide || 0) + 5;
      res.feu = (res.feu || 0) + 5;
    }
    var rd = ficheAttribute(perso, 'RDS', '');
    rd = (rd + '').trim();
    if (rd === '') {
      perso.rd = res;
      return res;
    }
    rd = rd.split(',');
    rd.forEach(function(r) {
      r = r.trim();
      if (r === '') return;
      var rds;
      var index = r.indexOf(':');
      if (index > 0) { //RD \xE0 un type particulier
        var type = r.substring(0, index);
        if (type == 'rdt' || type == 'sauf') return;
        rds = parseInt(r.substring(index + 1));
        if (isNaN(rds) || rds === 0) return;
        res[type] = res[type] || 0;
        res[type] += rds;
        return;
      }
      index = r.indexOf('/');
      if (index > 0) { //RD sauf \xE0 des types
        rds = parseInt(r.substring(0, index));
        if (isNaN(rds) || rds === 0) return;
        var sauf = r.substring(index + 1);
        res.sauf[sauf] = res.sauf[sauf] || 0;
        res.sauf[sauf] += rds;
        return;
      }
      //finalement, RD totale
      rds = parseInt(r);
      if (isNaN(rds) || rds === 0) return;
      res.rdt += rds;
    });
    perso.rd = res;
    return res;
  }

  function applyRDSauf(rds, dmgType, total, display, options, target, showTotal, remainingRD) {
    options = options || {};
    var typeTrouve = function(t) {
      if (t == dmgType) return true;
      if (options[t]) return true;
      switch (t) {
        case 'tranchant':
        case 'contondant':
        case 'percant':
          return options.sortilege || dmgType != 'normal';
        default:
          return false;
      }
    };
    if (total) {
      for (var saufType in rds) {
        if (saufType == '1') break;
        var rd = rds[saufType];
        if (rd === 0) break;
        var types = saufType.split('_');
        if (types.find(typeTrouve)) break;
        if (target.ignoreMoitieRD) rd = parseInt(rd / 2);
        if (target.ignoreRD && rd > 0) {
          if (target.ignoreRD > rd) {
            target.ignoreRD -= rd;
            break;
          } else {
            rd -= target.ignoreRD;
            target.ignoreRD = 0;
          }
        }
        if (remainingRD) rd += remainingRD;
        if (total < rd) {
          display += " - " + total;
          rds[saufType] -= total;
          total = 0;
          showTotal = true;
        } else {
          display += " - " + rd;
          total -= rd;
          rds[saufType] = 0;
          showTotal = true;
        }
      }
    }
    return {
      total: total,
      display: display,
      showTotal: showTotal
    };
  }

  function stringOfType(t) {
    switch (t) {
      case 'acide':
        return "l'acide";
      case 'electrique':
        return "l'\xE9lectricit\xE9";
      case 'soniqe':
        return "le son";
      case 'maladie':
        return "les maladies";
      case 'argent':
        return "l'argent";
      default:
        return 'le ' + t;
    }
  }

  function stringOfCarac(c) {
    switch (c) {
      case 'FOR':
        return "la force";
      case 'DEX':
        return "la dext\xE9rit\xE9";
      case 'CON':
        return "la constitution";
      case 'INT':
        return "l'intelligence";
      case 'SAG':
        return "la sagesse";
      case 'CHA':
        return "le charisme";
    }
  }

  function mitigate(target, dmgType, divide, zero, expliquer, options) {
    if (!options.sortilege && attributeAsBool(target, 'flou')) {
      divide();
    }
    if (options.attaqueMentale && predicateAsBool(target, 'bouclierPsi')) {
      divide();
    }
    if (options.aoe &&
      (predicateAsBool(target, 'protectionDMZone') ||
        predicateAsBool(target, 'protectionDMZone_' + dmgType))) {
      divide();
      expliquer(target.token.get('name') + " est prot\xE9g\xE9 contre les d\xE9g\xE2ts de zone");
    }
    if (predicateOrAttributeAsBool(target, 'resistanceA_' + dmgType) || predicateAsBool(target, 'diviseEffet_' + dmgType)) {
      divide();
    }
    if (predicateOrAttributeAsBool(target, 'resistanceA_nonMagique') && !options.magique && !options.sortilege) {
      divide();
    }
    if (estElementaire(dmgType)) {
      if (predicateAsBool(target, 'invulnerable')) {
        divide();
      }
      switch (dmgType) {
        case 'froid':
          if (attributeAsBool(target, 'masqueMortuaire')) divide();
          if (attributeAsBool(target, 'mutationFourrureViolette')) divide();
          break;
        case 'feu':
          if (attributeAsBool(target, 'presenceGlaciale')) divide();
          if (attributeAsBool(target, 'mutationEcaillesRouges')) divide();
          break;
        case 'acide':
          if (attributeAsBool(target, 'mutationEcaillesRouges')) divide();
          break;
        case 'electrique':
          if (attributeAsBool(target, 'mutationFourrureViolette')) divide();
          break;
      }
    } else if (dmgType == 'poison' || dmgType == 'maladie') {
      if (predicateAsBool(target, 'invulnerable') ||
        predicateAsBool(target, 'creatureArtificielle') ||
        estNonVivant(target)) {
        zero();
      } else if (attributeAsBool(target, 'mutationSangNoir')) {
        divide();
      }
    } else {
      if (options.tranchant && predicateOrAttributeAsBool(target, 'resistanceA_tranchant')) {
        divide();
      } else if (options.percant && predicateOrAttributeAsBool(target, 'resistanceA_percant')) {
        divide();
      } else if (options.contondant && predicateOrAttributeAsBool(target, 'resistanceA_contondant')) {
        divide();
      }
      if (attributeAsBool(target, 'armureMagique')) {
        divide();
      }
      if (options.vampirise && predicateOrAttributeAsBool(target, 'controleSanguin')) {
        expliquer(target.token.get('name') + " contr\xF4le parfaitement son sang");
        divide();
      }
    }
  }
  //On a d\xE9termin\xE9 les DM du type principal(possiblement apr\xE8s save des dmgExtra, maintenant on applique les r\xE9sistances, puis on ajoute les DM d'autres types
  function dealDamageAfterDmgExtra(target, mainDmgType, dmgTotal, dmgDisplay, showTotal, dmgParType, dmgExtra, crit, options, evt, expliquer, displayRes) {
    if (options.pointsVitaux && dmgTotal > 0) { //d\xE9g\xE2ts retard\xE9s pour une pression mortelle
      let pMortelle = tokenAttribute(target, 'pressionMortelle');
      let dmgPMort = dmgTotal;
      let numberPMort = 1;
      if (pMortelle.length > 0) {
        dmgPMort += pMortelle[0].get('current');
        numberPMort += pMortelle[0].get('max');
      }
      setTokenAttr(target, 'pressionMortelle', dmgPMort, evt, {
        maxVal: numberPMort
      });
      dmgTotal = 0;
    }

    if (dmgTotal > 0 && immuniseAuType(target, mainDmgType, options.attaquant)) {
      if (expliquer && !target['msgImmunite_' + mainDmgType]) {
        target.tokName = target.tokName || target.token.get('name');
        expliquer(target.tokName + " ne semble pas affect\xE9 par " + stringOfType(mainDmgType));
        target['msgImmunite_' + mainDmgType] = true;
      }
      dmgTotal = 0;
      dmgDisplay = '0';
      showTotal = false;
    } else if (!target.ignoreTouteRD) {
      var rd = getRDS(target);
      var rdMain = typeRD(rd, mainDmgType);
      if (mainDmgType == 'normal') {
        if (options.tranchant && rd.tranchant) rdMain += rd.tranchant;
        if (options.percant && rd.percant) rdMain += rd.percant;
        if (options.contondant && rd.contondant) rdMain += rd.contondant;
      }
      if (rd.drain && (options.vampirise || target.vampirise) && mainDmgType != 'drain') {
        rdMain += rd.drain;
      }
      if (options.hache && rd.hache) {
        rdMain += rd.hache;
      }
      if (target.ignoreMoitieRD) rdMain = parseInt(rdMain / 2);
      if (target.ignoreRD) {
        if (target.ignoreRD > rdMain) {
          target.ignoreRD -= rdMain;
          rdMain = 0;
        } else {
          rdMain -= target.ignoreRD;
          target.ignoreRD = 0;
        }
      }
      if (rdMain > 0 && dmgTotal > 0) {
        dmgTotal -= rdMain;
        if (dmgTotal < 0) {
          rdMain += dmgTotal;
          dmgTotal = 0;
        }
        dmgDisplay += " - " + rdMain;
        showTotal = true;
      }
      var rdElems = 0;
      if (attributeAsBool(target, 'protectionContreLesElements')) {
        rdElems =
          getValeurOfEffet(target, 'protectionContreLesElements', 1, 'voieDeLaMagieElementaire') * 2;
      }
      if (rd.elementaire) rdElems += rd.elementaire;
      if (target.ignoreMoitieRD) rdElems = parseInt(rdElems / 2);
      if (rdElems > 0 && dmgTotal > 0 && estElementaire(mainDmgType)) {
        if (dmgTotal > rdElems) {
          dmgDisplay += ' - ' + rdElems;
          dmgTotal -= rdElems;
          rdElems = 0;
        } else {
          dmgDisplay += ' - ' + dmgTotal;
          rdElems -= dmgTotal;
          dmgTotal = 0;
        }
      }
      let additionalType = {
        magique: options.magique,
        tranchant: options.tranchant,
        percant: options.percant,
        contondant: options.contondant,
        sortilege: options.sortilege,
        hache: options.hache,
      };
      let remainingRD = 0;
      if (rdMain < 0) remainingRD = rdMain;
      let resSauf = applyRDSauf(rd.sauf, mainDmgType, dmgTotal, dmgDisplay, additionalType, target, showTotal, remainingRD);
      dmgTotal = resSauf.total;
      dmgDisplay = resSauf.display;
      showTotal = resSauf.showTotal;
      // Damage mitigaters for main damage
      mitigate(target, mainDmgType,
        function() {
          dmgTotal = Math.ceil(dmgTotal / 2);
          if (dmgExtra) dmgDisplay = "(" + dmgDisplay + ")";
          dmgDisplay += " / 2";
          showTotal = true;
        },
        function() {
          if (dmgTotal > 0) {
            dmgDisplay += '-' + dmgTotal;
            dmgTotal = 0;
          }
        }, expliquer, options);
    }
    var dmSuivis = {
      drain: 0
    }; //si il faut noter les DMs d'un type particulier
    if (mainDmgType == 'drain') dmSuivis.drain = dmgTotal;
    charAttribute(target.charId, 'vitaliteSurnaturelle').forEach(function(a) {
      var typeVitalite = a.get('max').split(',');
      typeVitalite.forEach(function(tv) {
        if (tv == mainDmgType) dmSuivis[tv] = dmgTotal;
        else dmSuivis[tv] = 0;
      });
    });
    // Autres sources de d\xE9g\xE2ts
    // On compte d'abord les autres sources, pour la synchronisation
    let count = 0;
    for (var dt in dmgParType) {
      if (immuniseAuType(target, dt, options.attaquant)) {
        if (expliquer && !target['msgImmunite_' + dt]) {
          target.tokName = target.tokName || target.token.get('name');
          expliquer(target.tokName + " ne semble pas affect\xE9 par " + stringOfType(dt));
          target['msgImmunite_' + dt] = true;
        }
        delete dmgParType[dt];
      } else
        count += dmgParType[dt].length;
    }
    let critOther = crit && reglesOptionelles.dommages.val.crit_elementaire.val;
    let dealOneType = function(dmgType) {
      if (dmgType == mainDmgType) {
        count -= dmgParType[dmgType].length;
        if (count === 0) dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis);
        return; //type principal d\xE9j\xE0 g\xE9r\xE9
      }
      showTotal = true;
      let dm = 0;
      let typeDisplay = "";
      let typeCount = dmgParType[dmgType].length;
      dmgParType[dmgType].forEach(function(d) {
        if (d.totalSave && d.totalSave.tempete && options.tempeteDeManaIntense) {
          d.totalSave.seuil += d.totalSave.tempete * options.tempeteDeManaIntense;
        }
        if (d.partialSave && d.partialSave.tempete && options.tempeteDeManaIntense) {
          d.partialSave.seuil += d.partialSave.tempete * options.tempeteDeManaIntense;
        }
        partialSave(d, target, false, d.display, d.total, expliquer, evt,
          function(res) {
            let addTypeDisplay = d.display;
            if (res) {
              dm += res.total;
              if (critOther) {
                dm += res.total;
                if (options.memePasMal) options.memePasMal += res.total;
              }
              addTypeDisplay = res.dmgDisplay;
            } else {
              dm += d.total;
              if (critOther) {
                dm += d.total;
                if (options.memePasMal) options.memePasMal += d.total;
              }
            }
            if (critOther) addTypeDisplay = '(' + addTypeDisplay + ') x2';
            if (typeDisplay === '') typeDisplay = addTypeDisplay;
            else typeDisplay += "+" + addTypeDisplay;
            typeCount--;
            if (typeCount === 0) {
              if (!target.ignoreTouteRD) {
                var rdl = typeRD(rd, dmgType);
                if (dmgType == 'normal') {
                  if (options.tranchant && rd.tranchant) rdl += rd.tranchant;
                  if (options.percant && rd.percant) rdl += rd.percant;
                  if (options.contondant && rd.contondant) rdl += rd.contondant;
                }
                if (target.ignoreMoitieRD) rdl = parseInt(rdl / 2);
                if (target.ignoreRD) {
                  if (target.ignoreRD > rdl) {
                    target.ignoreRD -= rdl;
                    rdl = 0;
                  } else {
                    rdl -= target.ignoreRD;
                    target.ignoreRD = 0;
                  }
                }
                if (rdl > 0 && dm > 0) {
                  dm -= rdl;
                  if (dm < 0) {
                    rdl += dm;
                    dm = 0;
                  }
                  typeDisplay += "-" + rdl;
                }
                if (rdElems > 0 && dm > 0 && estElementaire(dmgType)) {
                  if (dm > rdElems) {
                    typeDisplay += ' - ' + rdElems;
                    dm -= rdElems;
                    rdElems = 0;
                  } else {
                    typeDisplay += ' - ' + dm;
                    rdElems -= dm;
                    dm = 0;
                  }
                }
                let additionalType = {
                  sortilege: options.sortilege,
                  magique: options.magique
                };
                let resSauf = applyRDSauf(rd.sauf, dmgType, dm, typeDisplay, additionalType, target);
                dm = resSauf.total;
                typeDisplay = resSauf.display;
                mitigate(target, dmgType,
                  function() {
                    dm = Math.ceil(dm / 2);
                    if (dmgParType[dmgType].length > 1) typeDisplay = "(" + typeDisplay + ")";
                    typeDisplay += " / 2";
                  },
                  function() {
                    if (dm > 0) {
                      typeDisplay += "-" + dm;
                      dm = 0;
                    }
                  }, expliquer, options);
                dmgTotal += dm;
                dmgDisplay += "+" + typeDisplay;
                if (_.has(dmSuivis, dmgType)) {
                  dmSuivis[dmgType] = dm;
                }
              }
            }
            count--;
            if (count === 0) dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis);
          });
      });
    };
    if (count > 0) {
      for (var dmgType in dmgParType) {
        dealOneType(dmgType);
      }
    } else {
      return dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis);
    }
  }

  //Appel\xE9 quand on met \xE0 0 PV
  function mort(personnage, expliquer, evt) {
    if (predicateAsBool(personnage, 'exsangue') && !attributeAsBool(personnage, 'etatExsangue')) {
      let msg;
      if (expliquer) {
        personnage.tokName = personnage.tokName || personnage.token.get('name');
        expliquer(personnage.tokName + " continue \xE0 agir malgr\xE9 son \xE9tat");
      } else msg = "continue \xE0 agir malgr\xE9 son \xE9tat";
      setTokenAttr(personnage, 'etatExsangue', true, evt, {
        msg: msg
      });
      return;
    }
    if (predicateAsBool(personnage, 'energieDeLaMort')) {
      personnage.tokName = personnage.tokName || personnage.token.get('name');
      let duree = rollDePlus(6, {
        bonus: 5
      });
      sendChat('', '/w GM ' + personnage.tokName + ' r\xE9appara\xEEtra dans ' + duree.roll + ' tours.');
      let effet = 'messageRetarde(r\xE9apparition)';
      setAttrDuree(personnage, effet, duree.val - 1, evt);
      setToken(personnage.token, 'layer', 'gmlayer', evt);
      if (personnage.attaquant) {
        let dm = rollDePlus(6);
        let dmg = {
          type: 'magique',
          display: dm.roll,
          total: dm.val
        };
        let pvMax = parseInt(personnage.token.get('bar1_max'));
        pvMax += dm.val;
        updateCurrentBar(personnage, 1, pvMax, evt, pvMax);
        let explications = [];
        dealDamage(personnage.attaquant, dmg, [], evt, false, {}, explications,
          function(dmgDisplay, dmgFinal, dmgDrain) {
            setTokenAttr(personnage, effet + 'Valeur', personnage.tokName + " r\xE9apparait avec " + dmgFinal + " PV en plus.", evt);
            let attName = personnage.attaquant.tokName || personnage.attaquant.token.get('name');
            let msg = "se transforme en brume noire qui traverse " + attName + " de part en part avant de dispara\xEEtre dans une paroi en poussant un hululement inhumain. le froid de la mort inflige " + dmgDisplay + " DM \xE0 " + attName;
            if (expliquer) {
              expliquer(personnage.tokName + ' ' + msg);
            } else {
              sendPerso(personnage, msg);
            }
          });
      }
      return;
    }
    // Suppression Zombies
    let attrsDegradationZombie = tokenAttribute(personnage, 'degradationZombie');
    if (attrsDegradationZombie.length > 0) {
      finDEffet(attrsDegradationZombie[0], 'degradationZombie', attrsDegradationZombie[0].get("name"), personnage.charId, evt);
      return;
    }
    setState(personnage, 'mort', true, evt);
    let targetPos = {
      x: personnage.token.get('left'),
      y: personnage.token.get('top')
    };
    spawnFxBetweenPoints(targetPos, {
      x: 400,
      y: 400
    }, "splatter-blood");

  }

  function dmgNaturel(options) {
    if (options.nature) return true;
    if (options.artificiel) return false;
    var attaquant = options.attaquant;
    if (attaquant === undefined) return false;
    if (estAnimal(attaquant)) return true;
    if (predicateAsBool(attaquant, 'insecte')) return true;
    var attr = findObjs({
      _type: 'attribute',
      _characterid: attaquant.charId,
    });
    var attrProfile = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'PROFIL';
    });
    if (attrProfile.length > 0) {
      if (attrProfile[0].get('current').trim().toLowerCase() == 'insecte') {
        return true;
      }
    }
    var attrRace = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'RACE';
    });
    if (attrRace.length === 0) return false;
    var charRace = attrRace[0].get('current').trim().toLowerCase();
    switch (charRace) {
      case 'insecte':
      case 'ankheg':
      case 'araign\xE9e':
      case 'araignee':
      case 'gu\xEApe':
      case 'libellule':
      case 'scarab\xE9e':
      case 'scorpion':
      case 'strige':
        return true;
      default:
        return false;
    }
  }

  function testBlessureGrave(target, dmgTotal, expliquer, evt) {
    target.tokName = target.tokName || target.token.get('name');
    if (estPJ(target) && ((dmgTotal == 'mort' && reglesOptionelles.dommages.val.blessures_graves.val) ||
        (reglesOptionelles.dommages.val.degats_importants.val && dmgTotal >
          (ficheAttributeAsInt(target, 'niveau', 1) +
            ficheAttributeAsInt(target, 'constitution', 10))))) {
      var pr = pointsDeRecuperation(target);
      if (pr.current > 0) {
        expliquer("Les d\xE9g\xE2ts sont si importants que " + target.tokName + " perd 1 PR");
        enleverPointDeRecuperation(target, evt);
      } else if (getState(target, 'blesse')) {
        if (getState(target, 'mort')) {
          expliquer("Avec la blessure grave, c'est vraiment la fin, " + target.tokName + " ne se rel\xE8vera plus...");
        } else {
          expliquer("Les d\xE9g\xE2ts sont trop importants, et " + target.tokName + " s'effondre");
          mort(target, expliquer, evt);
        }
      } else {
        setState(target, 'blesse', true, evt);
        expliquer("Les d\xE9g\xE2ts occasionnent une blessure grave !");
      }
    }
  }

  function enlevePVStatueDeBois(perso, pvPerdus, evt) {
    if (pvPerdus <= 0) return;
    let attrs = tokenAttribute(perso, 'statueDeBoisValeur');
    if (attrs.length === 0) return;
    let cur = parseInt(attrs[0].get('current'));
    let attrsB = tokenAttribute(perso, 'statueDeBois');
    if (attrsB.length === 0) {
      error("Attribut pour l'effet status de bois introuvable", cur);
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attrs[0]);
      attrs[0].remove();
    }
    if (isNaN(cur)) {
      finDEffet(attrsB[0], 'statueDeBois', attrsB[0].get('name'), perso.charId, evt);
      return;
    }
    let newCur = cur - pvPerdus;
    if (newCur <= 0) {
      finDEffet(attrsB[0], 'statueDeBois', attrsB[0].get('name'), perso.charId, evt);
      return;
    }
    evt.attributes = evt.attributes || [];
    evt.attributes.push({
      attribute: attrs[0],
      current: cur,
      max: attrs[0].get('max')
    });
    attrs[0].set('current', newCur);
  }

  function finDEffetDeNom(perso, effet, evt, options) { //Supprime l'effet si pr\xE9sent
    let attrs = tokenAttribute(perso, effet);
    if (attrs.length === 0) return;
    attrs = attrs[0];
    options = options || {};
    options.pageId = options.pageId || perso.token.get('pageid');
    finDEffet(attrs, effetTempOfAttribute(attrs), attrs.get('name'), perso.charId, evt, options);
  }

  function mettreAZeroPV(target, evt, expliquer) {
    updateCurrentBar(target, 1, 0, evt);
    if (predicateAsBool(target, 'baroudHonneur')) {
      let msgBarroud = target.tokName + " devrait \xEAtre mort";
      msgBarroud += eForFemale(target) + ", mais ";
      msgBarroud += onGenre(target, 'il', 'elle') + " continue \xE0 se battre !";
      expliquer(msgBarroud);
      setTokenAttr(target, 'baroudHonneurActif', true, evt);
    } else if (predicateAsBool(target, 'increvable') && attributeAsInt(target, 'limiteParCombat__increvable', predicateAsInt(target, 'increvable', 1)) > 0) {
      var msgIncrevable = target.tokName + " devrait \xEAtre mort";
      msgIncrevable += eForFemale(target) + ", mais ";
      msgIncrevable += onGenre(target, 'il', 'elle') + " est increvable !";
      expliquer(msgIncrevable);
      let restants = attributeAsInt(target, 'limiteParCombat__increvable', predicateAsInt(target, 'increvable', 1));
      setTokenAttr(target, 'limiteParCombat__increvable', restants - 1, evt);
      setTokenAttr(target, 'increvableActif', true, evt);
    } else if ((attributeAsBool(target, 'enrage') || predicateAsBool(target, 'durACuire')) &&
      !attributeAsBool(target, 'aAgiAZeroPV')) {
      let msgAgitZ = target.tokName + " devrait \xEAtre mort";
      msgAgitZ += eForFemale(target) + ", mais ";
      msgAgitZ += onGenre(target, 'il', 'elle') + " continue \xE0 se battre !";
      expliquer(msgAgitZ);
      if (!attributeAsBool(target, 'agitAZeroPV'))
        setAttrDuree(target, 'agitAZeroPV', 1, evt);
    } else if (predicateAsBool(target, 'nAbandonneJamais')) {
      if (attributeAsBool(target, 'mortMaisNAbandonnePas')) {
        expliquer(target.tokName + " est dans un \xE9tat lamentable, mais continue \xE0 bouger. Il faudrait une action limit\xE9e pour le r\xE9duire en miettes.");
      } else {
        expliquer(target.tokName + " est pratiquement d\xE9truit, mais continue \xE0 bouger !");
        setTokenAttr(target, 'mortMaisNAbandonnePas', true, evt);
        setState(target, 'ralenti', true, evt);
      }
    } else {
      mort(target, expliquer, evt);
      testBlessureGrave(target, 'mort', expliquer, evt);
    }
  }

  //target prend un coup qui lui fait perdre tous ses PVs
  // Asynchrone
  function prendreUnCoupMortel(target, dmgTotal, pvPerdus, bar1, tempDmg, dmgDisplay, showTotal, dmDrains, displayRes, options, evt, expliquer) {
    pvPerdus += bar1;
    testBlessureGrave(target, dmgTotal, expliquer, evt);
    if (predicateAsBool(target, 'defierLaMort')) {
      let defierLaMort = charAttributeAsInt(target, 'defierLaMort', 10);
      let rollId = 'defierLaMort_' + target.token.id;
      let saveOpts = {
        msgPour: " pour d\xE9fier la mort",
        msgReussite: ", conserve 1 PV",
        rolls: options.rolls,
        chanceRollId: options.chanceRollId
      };
      if (attributeAsBool(target, 'rageDuBerserk')) saveOpts.bonus = 10;
      save({
          carac: 'CON',
          seuil: defierLaMort
        }, target, rollId, expliquer, saveOpts, evt,
        function(reussite, rollText) {
          if (reussite) {
            bar1 = 1;
            pvPerdus--;
            setTokenAttr(target, 'defierLaMort', defierLaMort + 10, evt);
            updateCurrentBar(target, 1, 1, evt);
            enlevePVStatueDeBois(target, pvPerdus, evt);
          } else {
            mettreAZeroPV(target, evt, expliquer);
          }
          postBarUpdateForDealDamage(target, dmgTotal, pvPerdus, bar1, tempDmg, dmgDisplay, showTotal, dmDrains, displayRes, evt, expliquer);
        });
      //On arr\xEAte l\xE0, car tout le reste est fait dans la continuation du save.
      return;
    }
    mettreAZeroPV(target, evt, expliquer);
    postBarUpdateForDealDamage(target, dmgTotal, pvPerdus, bar1, tempDmg, dmgDisplay, showTotal, dmDrains, displayRes, evt, expliquer);
  }

  function dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis) {
    const charId = target.charId;
    let token = target.token;
    // Now do some dmg mitigation rolls, if necessary
    if ((options.distance || options.aoe) &&
      attributeAsBool(target, 'aCouvert')) {
      if (showTotal) dmgDisplay = "(" + dmgDisplay + ")";
      dmgDisplay += " / 2";
      dmgTotal = Math.ceil(dmgTotal / 2);
      dmSuivis = _.map(dmSuivis, function(d) {
        return Math.ceil(d / 2);
      });
      showTotal = true;
    }
    if (options.totalSave && options.totalSave.tempete && options.tempeteDeManaIntense) {
      options.totalSave.seuil += options.totalSave.tempete * options.tempeteDeManaIntense;
    }
    if (options.partialSave && options.partialSave.tempete && options.tempeteDeManaIntense) {
      options.partialSave.seuil += options.partialSave.tempete * options.tempeteDeManaIntense;
    }
    partialSave(options, target, showTotal, dmgDisplay, dmgTotal,
      expliquer, evt,
      function(saveResult) {
        if (saveResult) {
          if (saveResult.total < dmgTotal) {
            dmgTotal = saveResult.total;
            dmSuivis = _.map(dmSuivis, function(d) {
              return Math.ceil(d / 2);
            });
          }
          dmgDisplay = saveResult.dmgDisplay;
          showTotal = saveResult.showTotal;
        }
        let rdTarget = getRDS(target);
        let rd = rdTarget.rdt || 0;
        if (rd > 0 && !options.aoe && options.attaquant && predicateAsBool(options.attaquant, 'ventreMou')) {
          var taille = taillePersonnage(target, 4);
          if (taille > 4) {
            if (target.messages) target.messages.push("Ventre mou => L'attaque ignore la RD d\xFBe \xE0 la taille");
            rd -= 3 * (taille - 4);
            if (taille > 6) rd--;
            if (rd < 0) rd = 0;
          }
        }
        if (predicateAsBool(target, 'hausserLeTon')) {
          if (parseInt(target.token.get('bar1_value')) <= target.token.get('bar1_max') / 2) {
            rd += 5;
          }
        }
        if (target.attaquant && predicateAsBool(target, 'combatKinetique') &&
          !getState(target, 'endormi') && !getState(target, 'assomme') &&
          !getState(target, 'mort') && !getState(target, 'surpris') &&
          !getState(target, 'etourdi')) {
          rd += 3;
        }
        if (attributeAsBool(target, 'statueDeBois')) rd += 10;
        if (attributeAsBool(target, 'mutationSilhouetteMassive')) rd += 3;
        if (crit) {
          var rdCrit = predicateAsInt(target, 'RD_critique', 0); //pour la compatibilit\xE9
          if (ficheAttributeAsBool(target, 'casque_on', false))
            rdCrit += ficheAttributeAsInt(target, 'casque_rd', 0);
          rd += rdCrit;
          if (options.memePasMal) options.memePasMal -= rdCrit;
        }
        if (options.distance) {
          if (rdTarget.distance) rd += rdTarget.distance;
          let piqures = predicateAsInt(target, 'piquresDInsectes', 0);
          if (piqures > 0) {
            if (persoEstPNJ(target) || (ficheAttributeAsBool(target, 'defarmureon', false) && ficheAttributeAsInt(target, 'defarmure', 0) > 5)) {
              rd += piqures;
            }
          }
        }
        if (attributeAsBool(target, 'masqueMortuaire')) rd += 2;
        if (rdTarget.nature > 0 && dmgNaturel(options)) rd += rdTarget.nature;
        if (dmgTotal > rd && rdTarget.sauf[1]) {
          if (dmgTotal > rd + rdTarget.sauf[1]) rd += rdTarget.sauf[1];
          else rd = dmgTotal - 1;
        }
        if (target.defautCuirasse) rd = 0;
        if (options.intercepter) rd += options.intercepter;
        if (target.intercepter) rd += target.intercepter;
        if (target.extraRD) {
          rd += target.extraRD;
          expliquer(target.tokName + " encaisse le coup avec son armure");
        }
        if (target.extraRDBouclier) {
          rd += target.extraRDBouclier;
          expliquer(target.tokName + " d\xE9vie le coup avec son bouclier");
        }
        if (target.ignoreTouteRD) rd = 0;
        else if (target.ignoreMoitieRD) rd = parseInt(rd / 2);
        if (target.ignoreRD) {
          if (target.ignoreRD > rd) {
            target.ignoreRD -= rd;
            rd = 0;
          } else {
            rd -= target.ignoreRD;
            target.ignoreRD = 0;
          }
        }
        //Option Max Rune de Protection
        if (target.utiliseRuneProtectionMax) {
          target.messages.push(target.tokName + " utilise sa Rune de Protection");
          addToAttributeAsInt(target, 'limiteParCombat_runeForgesort_protection', 1, -1, evt);
          rd += target.utiliseRuneProtectionMax;
          if (dmgTotal <= rd) expliquer("La rune de protection absorbe tous les dommages");
          else expliquer("La rune de protection encaisse " + target.utiliseRuneProtectionMax + " dommages");
        }
        //RD PeauDePierre \xE0 prendre en compte en dernier
        if (!target.defautCuirasse && !target.ignoreTouteRD && rd < dmgTotal && attributeAsBool(target, 'peauDePierreMag')) {
          let peauDePierreMagValeur = tokenAttribute(target, 'peauDePierreMagValeur');
          if (peauDePierreMagValeur.length === 0) {
            error("compteur de Peau de Pierre non trouv\xE9", target);
          } else {
            peauDePierreMagValeur = peauDePierreMagValeur[0];
            let rdPeauDePierreMax = parseInt(peauDePierreMagValeur.get('current'));
            let peauDePierreAbsorbe = parseInt(peauDePierreMagValeur.get('max'));
            if (isNaN(rdPeauDePierreMax) || isNaN(peauDePierreAbsorbe) || rdPeauDePierreMax < 1 || peauDePierreAbsorbe < 1) {
              error("compteur de Peau de Pierre mal form\xE9", peauDePierreMagValeur);
              finDEffetDeNom(target, "peauDePierreMag", evt);
            } else {
              let rdPeauDePierreMag = rdPeauDePierreMax;
              if (target.ignoreMoitieRD) rdPeauDePierreMag = parseInt(rdPeauDePierreMag / 2);
              if (rd + rdPeauDePierreMag > dmgTotal) {
                rdPeauDePierreMag = dmgTotal - rd;
              }
              if (rdPeauDePierreMag >= peauDePierreAbsorbe) {
                rdPeauDePierreMag = peauDePierreAbsorbe;
                finDEffetDeNom(target, "peauDePierreMag", evt);
              } else {
                peauDePierreAbsorbe -= rdPeauDePierreMag;
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: peauDePierreMagValeur,
                  current: rdPeauDePierreMax,
                  max: peauDePierreAbsorbe
                });
                peauDePierreMagValeur.set('max', peauDePierreAbsorbe);
              }
              rd += rdPeauDePierreMag;
            }
          }
        }
        if (rd > 0) {
          if (showTotal) dmgDisplay = "(" + dmgDisplay + ") - " + rd;
          else {
            dmgDisplay += " - " + rd;
            showTotal = true;
          }
        }
        dmgTotal -= rd;
        for (var dmSuiviType in dmSuivis) {
          if (rd === 0) break;
          dmSuivis[dmSuiviType] -= rd;
          if (dmSuivis[dmSuiviType] < 0) {
            rd = -dmSuivis[dmSuiviType];
            dmSuivis[dmSuiviType] = 0;
          } else rd = 0;
        }
        if (options.metal && attributeAsBool(target, 'magnetisme')) {
          if (showTotal) dmgDisplay = "(" + dmgDisplay + ") / 2";
          else dmgDisplay += " / 2";
          showTotal = true;
          dmgTotal = Math.ceil(dmgTotal / 2);
          if (options.memePasMal)
            options.memePasMal = Math.ceil(options.memePasMal / 2);
          dmSuivis = _.map(dmSuivis, function(d) {
            return Math.ceil(d / 2);
          });
        }
        if (predicateAsBool(target, 'commandant')) {
          //On cherche si il y a au moins 4 cr\xE9atures sous ses ordres \xE0 moins de 10 m
          let pageId = target.token.get('pageid');
          let tokens =
            findObjs({
              _type: 'graphic',
              _subtype: 'token',
              layer: 'objects',
              _pageid: pageId
            });
          let nbCreatures = 0;
          tokens.forEach(function(tok) {
            if (tok.id === target.token.id) return;
            let ci = tok.get('represents');
            if (ci === '') return;
            if (distanceCombat(tok, target.token, pageId) > 10) return;
            let attrCom = charAttribute(ci, 'capitaine');
            if (attrCom.length === 0) return;
            let capitaine = persoOfIdName(attrCom[0].get('current'), pageId);
            if (!capitaine || capitaine.token.id != target.token.id) return;
            let perso = {
              token: tok,
              charId: ci
            };
            if (isActive(perso)) nbCreatures++;
          });
          if (nbCreatures > 3) {
            if (showTotal) dmgDisplay = "(" + dmgDisplay + ") / 2";
            else dmgDisplay += " / 2";
            showTotal = true;
            dmgTotal = Math.ceil(dmgTotal / 2);
            if (options.memePasMal)
              options.memePasMal = Math.ceil(options.memePasMal / 2);
            dmSuivis = _.map(dmSuivis, function(d) {
              return Math.ceil(d / 2);
            });
          }
        }
        if (dmgTotal < reglesOptionelles.dommages.val.dm_minimum.val) {
          dmgTotal = reglesOptionelles.dommages.val.dm_minimum.val;
          dmgDisplay += "-> " + reglesOptionelles.dommages.val.dm_minimum.val;
        }
        if (options.divise) {
          dmgTotal = Math.ceil(dmgTotal / options.divise);
          if (options.memePasMal)
            options.memePasMal = Math.ceil(options.memePasMal / options.divise);
          dmSuivis = _.map(dmSuivis, function(d) {
            return Math.ceil(d / options.divise);
          });
          dmgDisplay = "(" + dmgDisplay + ")/" + options.divise;
          showTotal = true;
        }
        if (crit && options.memePasMal && options.memePasMal > 0) {
          dmgTotal -= options.memePasMal;
          if (dmgTotal < 0) {
            options.memePasMal += dmgTotal;
            dmgTotal = 0;
          }
          expliquer("M\xEAme pas mal : ignore " + options.memePasMal + " PVs et peut enrager");
          let mpm = attributeAsInt(target, 'memePasMalIgnore', 0);
          setTokenAttr(target, 'memePasMalIgnore', mpm + options.memePasMal, evt);
          setAttrDuree(target, 'memePasMalBonus', 3, evt);
        }
        // calcul de l'effet sur la cible
        let bar1 = parseInt(token.get('bar1_value'));
        let pvmax = parseInt(token.get('bar1_max'));
        if (isNaN(bar1)) {
          error("Pas de points de vie chez la cible", token);
          bar1 = 0;
          pvmax = 0;
        } else if (isNaN(pvmax)) {
          pvmax = bar1;
          token.set('bar1_max', bar1);
        }
        let hasMana = (ficheAttributeAsInt(target, 'PM', 0) > 0);
        let tempDmg = 0;
        const estMook = token.get("bar1_link") === '';
        if (hasMana) {
          if (estMook) tempDmg = attributeAsInt(target, 'DMTEMP', 0);
          else tempDmg = ficheAttributeAsInt(target, 'DMTEMP', 0);
        } else {
          tempDmg = parseInt(token.get("bar2_value"));
          if (isNaN(tempDmg)) {
            if (target.tempDmg) { //then try to set bar2 correctly
              if (estMook) {
                token.set("bar2_max", pvmax);
              } else {
                let tmpHitAttr =
                  findObjs({
                    _type: "attribute",
                    _characterid: charId,
                    name: 'DMTEMP'
                  }, {
                    caseInsensitive: true
                  });
                var dmTemp;
                if (tmpHitAttr.length === 0) {
                  dmTemp =
                    createObj("attribute", {
                      characterid: charId,
                      name: 'DMTEMP',
                      current: 0,
                      max: pvmax
                    });
                } else {
                  dmTemp = tmpHitAttr[0];
                }
                token.set("bar2_max", pvmax);
                token.set("bar2_link", dmTemp.id);
              }
            }
            tempDmg = 0;
          }
        }
        if (!options.aoe && predicateAsBool(target, 'ciblesMultiples')) {
          dmgTotal = 1;
          expliquer("La nu\xE9e est constitu\xE9e de tr\xE8s nombreuses cibles, l'attaque ne lui fait qu'1 DM");
        }
        let pvPerdus = dmgTotal;
        if (target.tempDmg) {
          tempDmg += dmgTotal;
          if (tempDmg > pvmax) {
            pvPerdus -= tempDmg - pvmax;
            tempDmg = pvmax;
          }
          if (hasMana) {
            setTokenAttr(target, 'DMTEMP', tempDmg, evt);
          } else {
            updateCurrentBar(target, 2, tempDmg, evt);
          }
          enlevePVStatueDeBois(target, pvPerdus, evt);
        } else {
          //On enl\xE8ve les points de vie
          let pvTemporaires = attributeAsInt(target, 'PVTemporaires', 0);
          if (bar1 > 0 && bar1 + pvTemporaires <= dmgTotal &&
            predicateAsBool(target, 'instinctDeSurvieHumain')) {
            dmgTotal = Math.floor(dmgTotal / 2);
            dmSuivis = _.map(dmSuivis, function(d) {
              return Math.ceil(d / 2);
            });
            if (dmgTotal < 1) dmgTotal = 1;
            if (showTotal) {
              dmgDisplay = "(" + dmgDisplay + ") / 2";
            } else {
              dmgDisplay += " / 2";
              showTotal = true;
            }
            expliquer("L'instinct de survie aide \xE0 r\xE9duire une attaque fatale");
          }
          pvPerdus = dmgTotal;
          if (pvTemporaires > 0) {
            if (pvTemporaires <= dmgTotal) {
              removeTokenAttr(target, 'PVTemporaires', evt);
              expliquer(target.tokName + " perd tous ses PVs temporaires");
              bar1 = bar1 - dmgTotal + pvTemporaires;
            } else {
              setTokenAttr(target, 'PVTemporaires', pvTemporaires - dmgTotal, evt);
              expliquer(target.tokName + " perd " + dmgTotal + " PVs temporaires");
            }
          } else {
            bar1 = bar1 - dmgTotal;
          }
          if (crit) { //Vuln\xE9rabilit\xE9 aux critiues
            let vulnerableCritique = predicateAsInt(target, 'vulnerableCritique', 0);
            if (vulnerableCritique > 0) {
              if (randomInteger(100) <= vulnerableCritique) {
                expliquer("Le coup critique le fait voler en \xE9clats");
                if (bar1 > 0) {
                  dmgTotal += bar1;
                  pvPerdus += bar1;
                  bar1 = 0;
                }
              } else {
                expliquer("Le coup critique fait vibrer l'adversaire, mais il r\xE9siste.");
              }
            }
          }
          if ((crit || bar1 < pvmax / 2) &&
            predicateAsBool(target, 'peutEnrager') &&
            !attributeAsBool(target, 'enrage')) {
            setTokenAttr(target, 'enrage', true, evt);
            expliquer(target.tokName + " devient enrag\xE9" + eForFemale(target) + ".");
            finDEffetDeNom(target, 'apeureTemp', evt);
            finDEffetDeNom(target, 'peurEtourdi', evt);
            setState(target, 'apeure', false, evt);
          }
          if (bar1 <= 0) {
            let attrFDA = tokenAttribute(target, 'formeDArbre');
            if (attrFDA.length > 0) {
              let effetFDA = finDEffet(attrFDA[0], 'formeDArbre', attrFDA[0].get('name'), charId, evt, {
                pageId: token.get('pageid')
              });
              if (effetFDA && effetFDA.newToken) {
                token = effetFDA.newToken;
                target.token = token;
              }
              let newBar1 = parseInt(token.get('bar1_value'));
              if (isNaN(newBar1) || newBar1 < 0) {
                error("Points de vie de l'ancien token incorrects", newBar1);
              } else {
                bar1 += newBar1;
              }
            }
          }
          //On enregistre les dm suivis
          for (let dmType in dmSuivis) {
            let d = dmSuivis[dmType];
            if (d && dmType != 'drain') {
              let attrDmSuivi = tokenAttribute(target, 'DMSuivis' + dmType);
              if (attrDmSuivi.length > 0) {
                let cd = parseInt(attrDmSuivi[0].get('current'));
                if (cd > 0) d += cd;
                attrDmSuivi[0].set('current', d);
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: attrDmSuivi[0],
                  current: cd
                });
              } else {
                setTokenAttr(target, 'DMSuivis' + dmType, d, evt);
              }
            }
          }
          if (bar1 <= 0) {
            if (predicateAsBool(target, 'sergent') &&
              !attributeAsBool(target, 'attributDeCombat_sergentUtilise')) {
              expliquer(token.get('name') + " \xE9vite l'attaque in-extremis");
              setTokenAttr(target, 'attributDeCombat_sergentUtilise', true, evt);
              pvPerdus = 0;
            } else if (target.attackRoll &&
              predicateAsBool(target, 'increvableHumain') &&
              !attributeAsBool(target, 'increvableHumainUtilise')) {
              setTokenAttr(target, 'increvableHumainUtilise', true, evt);
              let weaponStatsIncrevable = {
                attSkillDiv: 0,
                crit: 20,
                parDefaut: true,
              };
              if (options.sortilege) {
                weaponStatsIncrevable.name = "Attaque magique";
                weaponStatsIncrevable.attSkill = '@{ATKMAG}';
              } else if (options.contact) {
                let enMain = armesEnMain(target);
                if (!enMain || enMain.sortilege || enMain.portee > 0) {
                  weaponStatsIncrevable.name = "Attaque au contact";
                  weaponStatsIncrevable.attSkill = '@{ATKCAC}';
                } else {
                  weaponStatsIncrevable = enMain;
                }
              } else { //attaque \xE0 distance
                weaponStatsIncrevable.name = "Attaque \xE0 distance";
                weaponStatsIncrevable.attSkill = '@{ATKTIR}';
              }
              var optionsIncrevable = {...options
              };
              optionsIncrevable.pasDeDmg = true;
              var critIncrevable = critEnAttaque(target, weaponStatsIncrevable, optionsIncrevable);
              var dice = 20;
              var malusAttaque = 0;
              if (estAffaibli(target)) {
                if (predicateAsBool(target, 'insensibleAffaibli')) {
                  malusAttaque = -2;
                  expliquer(target.tokName + " affaibli, mais insensible => -2 en Attaque");
                } else {
                  dice = 12;
                  expliquer(target.tokName + " affaibli => D12 au lieu de D20 en Attaque");
                }
              } else if (getState(target, 'immobilise')) {
                dice = 12;
                expliquer(target.tokName + " immobilis\xE9 => D12 au lieu de D20 en Attaque");
              } else if (attributeAsBool(target, 'mortMaisNAbandonnePas')) {
                dice = 12;
                expliquer(target.tokName + " mort mais n'abandonne pas => D12 au lieu de D20 en Attaque");
              } else {
                var ebriete = attributeAsInt(target, 'niveauEbriete', 0);
                if (ebriete > 0) {
                  if (options.distance || options.sortilege || ebriete > 1) {
                    dice = 12;
                    if (ebriete > 3) ebriete = 3;
                    expliquer(target.tokName + ' ' + niveauxEbriete[ebriete] + " => D12 au lieu de D20 en Attaque");
                  }
                }
              }
              let toEvaluateAttackIncrevable =
                attackExpression(target, 1, dice, critIncrevable, true, weaponStatsIncrevable);
              sendChat('', toEvaluateAttackIncrevable, function(resAttackIncrevable) {
                let rollsAttack = resAttackIncrevable[0];
                let afterEvaluateAttack = rollsAttack.content.split(' ');
                let attRollNumber = rollNumber(afterEvaluateAttack[0]);
                let attSkillNumber = rollNumber(afterEvaluateAttack[1]);
                let d20rollAttaquant = rollsAttack.inlinerolls[attRollNumber].results.total;
                var attSkill = rollsAttack.inlinerolls[attSkillNumber].results.total;
                let explications = [];
                let attBonus =
                  bonusAttaqueA(target, weaponStatsIncrevable.name, evt, explications, optionsIncrevable);
                attBonus += malusAttaque;
                let pageId = options.pageId || token.get('pageid');
                attBonus +=
                  bonusAttaqueD(target, target.attaquant, 0, pageId, evt, explications, optionsIncrevable);
                let attackRollAttaquant = d20rollAttaquant + attSkill + attBonus;
                let attRollValue = buildinline(rollsAttack.inlinerolls[attRollNumber]);
                attRollValue += (attSkill > 0) ? "+" + attSkill : (attSkill < 0) ? attSkill : "";
                attRollValue += (attBonus > 0) ? "+" + attBonus : (attBonus < 0) ? attBonus : "";
                let msgIncrevable = "Increvable : " + target.tokName + " fait " + attRollValue;
                //TODO: afficher les explications de calcul des bonus d'attaque ?
                if (attackRollAttaquant < target.attackRoll) {
                  expliquer(msgIncrevable + " < " + target.attackRoll + " => \xE9chec ");
                  prendreUnCoupMortel(target, dmgTotal, pvPerdus, bar1, tempDmg, dmgDisplay, showTotal, dmSuivis.drain, displayRes, options, evt, expliquer);
                  return;
                }
                //L'attaque est \xE9vit\xE9e
                expliquer(msgIncrevable + " > " + target.attackRoll + " => l'attaque est \xE9vit\xE9e ! ");

                postBarUpdateForDealDamage(target, dmgTotal, 0, bar1, tempDmg, dmgDisplay, showTotal, dmSuivis.drain, displayRes, evt, expliquer);
              });
              return;
            } else { //la cible prend le coup
              prendreUnCoupMortel(target, dmgTotal, pvPerdus, bar1, tempDmg, dmgDisplay, showTotal, dmSuivis.drain, displayRes, options, evt, expliquer);
              //La suite est fait en continuation car la fonction est asynchrone
              return;
            }
          } else { // bar1>0
            testBlessureGrave(target, dmgTotal, expliquer, evt);
            updateCurrentBar(target, 1, bar1, evt);
            enlevePVStatueDeBois(target, pvPerdus, evt);
          }
        }
        postBarUpdateForDealDamage(target, dmgTotal, pvPerdus, bar1, tempDmg, dmgDisplay, showTotal, dmSuivis.drain, displayRes, evt, expliquer);
      });
    return dmgDisplay;
  }

  function postBarUpdateForDealDamage(target, dmgTotal, pvPerdus, bar1, tempDmg, dmgDisplay, showTotal, dmDrains, displayRes, evt, expliquer) {
    if (bar1 > 0 && tempDmg >= bar1) { //assomm\xE9
      setState(target, 'assomme', true, evt);
    }
    var attrsLienDeSang = tokenAttribute(target, "lienDeSangVers");
    if (attrsLienDeSang.length > 0) {
      var lienDuSangDmg = Math.floor(dmgTotal / 2);
      if (lienDuSangDmg > 0) {
        var r = {
          total: lienDuSangDmg,
          type: 'normal',
          display: lienDuSangDmg
        };
        var personnageLie = persoOfId(attrsLienDeSang[0].get("current"));
        if (personnageLie) {
          expliquer("Le lien de sang inflige " + lienDuSangDmg + " d\xE9g\xE2ts \xE0 " + personnageLie.token.get("name"));
          dealDamage(personnageLie, r, [], evt, false);
        }
      }
    }
    if (showTotal) dmgDisplay += " = " + dmgTotal;
    if (displayRes === undefined) return;
    displayRes(dmgDisplay, pvPerdus, dmDrains);
  }

  function buildinline(inlineroll, dmgType, magique) {
    let InlineColorOverride = "";
    let values = [];
    let critRoll = false;
    let failRoll = false;
    let critCheck = false;
    let failCheck = false;
    let highRoll = false;
    let lowRoll = false;
    let noHighlight = false;

    inlineroll.results.rolls.forEach(function(roll) {
      let result = processRoll(roll, critRoll, failRoll, highRoll, lowRoll, noHighlight);
      if (result.value.toString().indexOf("critsuccess") != -1) critCheck = true;
      if (result.value.toString().indexOf("critfail") != -1) failCheck = true;
      values.push(result.value);
      critRoll = result.critRoll;
      failRoll = result.failRoll;
      highRoll = result.highRoll;
      lowRoll = result.lowRoll;
      noHighlight = result.noHighlight;
    });

    // Overrides the default coloring of the inline rolls...
    let tc = dmgType;
    if (magique && (tc == 'normal' || tc == 'maladie')) tc = 'magique';
    let couleurs = couleurType[tc];
    if (couleurs) {
      InlineColorOverride = ' background-color: ' + couleurs.background + '; color: ' + couleurs.color + ';';
    } else {
      if (critCheck && failCheck) {
        InlineColorOverride = ' background-color: #8FA4D4; color: #061539;';
      } else if (critCheck && !failCheck) {
        InlineColorOverride = ' background-color: #88CC88; color: #004400;';
      } else if (!critCheck && failCheck) {
        InlineColorOverride = ' background-color: #FFAAAA; color: #660000;';
      } else {
        InlineColorOverride = ' background-color: #FFFEA2; color: #000;';
      }
    }
    var expression = inlineroll.expression.replace(/=>|>=/, '&amp;ge;').replace(/>/, '&amp;gt;').replace(/<=|=</, '&amp;le;').replace(/</, '&amp;lt;');
    var rollOut = '<span style="display: inline-block; border-radius: 5px; padding: 0 4px; ' + InlineColorOverride + '" title="' + expression + ' = ' + values.join("");
    rollOut += '" class="a inlinerollresult showtip tipsy-n';
    rollOut += (critCheck && failCheck) ? ' importantroll' : (critCheck ? ' fullcrit' : (failCheck ? ' fullfail' : ''));
    rollOut += '">' + inlineroll.results.total + '</span>';
    return rollOut;
  }

  function processRoll(roll, critRoll, failRoll, highRoll, lowRoll, noHighlight) {
    switch (roll.type) {
      case 'C':
        return {
          value: " " + roll.text + " "
        };
      case 'L':
        if (roll.text.indexOf("HR") != -1) highRoll = parseInt(roll.text.substring(2));
        else highRoll = false;
        if (roll.text.indexOf("LR") != -1) lowRoll = parseInt(roll.text.substring(2));
        else lowRoll = false;
        if (roll.text.indexOf("NH") != -1) {
          // Blocks highlight on an individual roll...
          noHighlight = true;
        }
        // Remove inline tags to reduce clutter...
        roll.text = roll.text.replace(/HR(\d+)/g, "");
        roll.text = roll.text.replace(/LR(\d+)/g, "");
        roll.text = roll.text.replace(/NH/g, "");
        if (roll.text !== "") roll.text = " [" + roll.text + "] ";
        return {
          value: roll.text,
          highRoll: highRoll,
          lowRoll: lowRoll,
          noHighlight: noHighlight
        };
      case 'M':
        roll.expr = roll.expr.toString().replace(/\+/g, " + ");
        return {
          value: roll.expr
        };
      case 'R':
        var rollValues = [];
        roll.results.forEach(function(result) {
          if (result.tableItem !== undefined) {
            rollValues.push(result.tableItem.name);
          } else {
            // Turn off highlighting if true...
            if (noHighlight) {
              critRoll = false;
              failRoll = false;
            } else {
              if (roll.mods) {
                if (roll.mods.customCrit && roll.mods.customCrit.length > 0) {
                  switch (roll.mods.customCrit[0].comp) {
                    case '=':
                    case '==':
                      critRoll = (result.v == roll.mods.customCrit[0].point);
                      break;
                    case '>=':
                    case '=>':
                    case '>':
                      critRoll = (result.v >= roll.mods.customCrit[0].point);
                      break;
                    default:
                      critRoll =
                        (highRoll !== false && result.v >= highRoll ||
                          result.v === roll.sides);
                  }
                }
                if (!critRoll && roll.mods.customFumble && roll.mods.customFumble.length > 0) {
                  switch (roll.mods.customFumble[0].comp) {
                    case '=':
                    case '==':
                      failRoll = (result.v == roll.mods.customFumble[0].point);
                      break;
                    case '<=':
                    case '=<':
                    case '<':
                      failRoll = (result.v <= roll.mods.customFumble[0].point);
                      break;
                    default:
                      failRoll =
                        (lowRoll !== false && result.v <= lowRoll || result.v === 1);
                  }
                }
              } else {
                critRoll =
                  (highRoll !== false && result.v >= highRoll ||
                    result.v === roll.sides);
                failRoll =
                  (!critRoll &&
                    (lowRoll !== false && result.v <= lowRoll || result.v === 1));
              }
            }
            var rv = "<span class='basicdiceroll" + (critRoll ? ' critsuccess' : (failRoll ? ' critfail' : '')) + "'>" + result.v + "</span>";
            rollValues.push(rv);
          }
        });
        var separator = ' + ';
        if (roll.mods && roll.mods.keep) separator = ' , ';
        return {
          value: "(" + rollValues.join(separator) + ")",
          critRoll: critRoll,
          failRoll: failRoll,
          highRoll: highRoll,
          lowRoll: lowRoll,
          noHighlight: noHighlight
        };
      case 'G':
        var grollVal = [];
        roll.rolls.forEach(function(groll) {
          groll.forEach(function(groll2) {
            var result = processRoll(groll2, highRoll, lowRoll, noHighlight);
            grollVal.push(result.value);
            critRoll = critRoll || result.critRoll;
            failRoll = failRoll || result.failRoll;
            highRoll = highRoll || result.highRoll;
            lowRoll = lowRoll || result.lowRoll;
            noHighlight = noHighlight || result.noHighlight;
          });
        });
        return {
          value: "{" + grollVal.join(" ") + "}",
          critRoll: critRoll,
          failRoll: failRoll,
          highRoll: highRoll,
          lowRoll: lowRoll,
          noHighlight: noHighlight
        };
    }
  }

  function getBrightness(hex) {
    hex = hex.replace('#', '');
    var c_r = hexDec(hex.substr(0, 2));
    var c_g = hexDec(hex.substr(2, 2));
    var c_b = hexDec(hex.substr(4, 2));
    return ((c_r * 299) + (c_g * 587) + (c_b * 114)) / 1000;
  }

  function hexDec(hex_string) {
    hex_string = (hex_string + '').replace(/[^a-f0-9]/gi, '');
    return parseInt(hex_string, 16);
  }

  function addOrigin(name, toEvaluate) {
    return toEvaluate.replace(/@{/g, "@{" + name + "|");
  }

  function tokenCenter(tok) {
    return [tok.get('left'), tok.get('top')];
  }

  // Retourne le diam\xE8tre d'un disque inscrit dans un carr\xE9 de surface
  // \xE9quivalente \xE0 celle du token
  function tokenSizeAsCircle(token) {
    var surface = token.get('width') * token.get('height');
    return Math.sqrt(surface);
  }

  // if token is bigger than thresh reduce the distance by that size
  function tokenSize(tok, thresh) {
    var size = (tok.get('width') + tok.get('height')) / 2;
    if (size > thresh) return ((size - thresh) / 2);
    return 0;
  }


  function malusDistance(perso1, tok2, distanceDeBase, portee, pageId, explications, ignoreObstacles) {
    // Extension de distance pour tir parabolique
    let tirParabolique = predicateAsBool(perso1, 'tirParabolique');
    var distance = tirParabolique ? Math.max(0, distanceDeBase - portee) : distanceDeBase;

    if (distance === 0) return 0;
    var tok1 = perso1.token;
    var mPortee = (distance <= portee) ? 0 : (Math.ceil(5 * (distance - portee) / portee));
    if (mPortee > 0) {
      explications.push("Distance > " + ((tirParabolique) ? portee * 2 : portee) + " m => -" + mPortee + " en Attaque");
    }
    if (ignoreObstacles || predicateAsBool(perso1, 'joliCoup'))
      return mPortee;
    // Now determine if any token is between tok1 and tok2
    var allToks =
      findObjs({
        _type: 'graphic',
        _pageid: pageId,
        _subtype: 'token',
        layer: 'objects'
      });
    var mObstacle = 0;
    var pt1 = tokenCenter(tok1);
    var pt2 = tokenCenter(tok2);
    var distance_pix = VecMath.length(VecMath.vec(pt1, pt2));
    var liste_obstacles = [];
    allToks.forEach(function(obj) {
      if (obj.id == tok1.id || obj.id == tok2.id) return;
      var objCharId = obj.get('represents');
      var perso = {
        token: obj,
        charId: objCharId
      };
      if (objCharId !== '' &&
        (getState(perso, 'mort') ||
          getState(perso, 'assomme') || getState(perso, 'endormi') ||
          (attributeAsBool(perso, 'intangible') && attributeAsInt(perso, 'intangibleValeur', 1)) ||
          (attributeAsBool(perso, 'intangibleInvisible') && attributeAsInt(perso, 'intangibleInvisibleValeur', 1))
        )
      )
        return;
      //On regarde si le token est une monture d'un des personnages
      var attrMonte = tokenAttribute(perso, 'estMontePar');
      var estMonture = attrMonte.find(function(a) {
        var cid = a.get('current');
        return cid == tok1.id || cid == tok2.id;
      });
      if (estMonture) return;
      var pt = tokenCenter(obj);
      var obj_dist = VecMath.length(VecMath.vec(pt1, pt));
      if (obj_dist > distance_pix) return;
      obj_dist = VecMath.length(VecMath.vec(pt2, pt));
      if (obj_dist > distance_pix) return;
      var distToTrajectory = VecMath.ptSegDist(pt, pt1, pt2);
      // On mod\xE9lise le token comme un disque
      var rayonObj = tokenSizeAsCircle(obj) / 2;
      if (distToTrajectory > rayonObj) return;
      liste_obstacles.push(obj.get("name"));
      // On calcule un malus proportionnel \xE0 l'arc \xE0 traverser
      // Pour l'instant, malus = 1 si distance = PIX_PER_UNIT
      var longueurArc = 2 * Math.sqrt(rayonObj * rayonObj - distToTrajectory * distToTrajectory);
      var mToken = longueurArc / PIX_PER_UNIT;
      //malus plus important si l'obstacle est au contact de la cible
      if (distanceCombat(tok2, obj, pageId) === 0) mToken *= 5;
      else mToken *= 3;
      mObstacle += mToken;
    });
    // On ajuste aussi en fonction de la taille de la cible
    mObstacle = mObstacle / (tokenSizeAsCircle(tok2) / PIX_PER_UNIT);
    if (mObstacle > 5) mObstacle = 5;
    else mObstacle = Math.round(mObstacle);
    var res = mPortee + mObstacle;
    if (mObstacle > 0) {
      log("Obstacle" + ((liste_obstacles.length > 1) ? "s" : "") + " trouv\xE9 : " + liste_obstacles.join(', '));
      explications.push('Obstacle' + ((liste_obstacles.length > 1) ? 's' : '') + ' sur le trajet => -' + mObstacle + ' en Attaque<br /><span style="font-size: 0.8em; color: #666;">' + liste_obstacles.join(', ') + '</span>');
    }
    return res;
  }

  //Met tous les attributs avec le nom au max
  function resetAttr(attrs, attrName, evt, msg) {
    allAttributesNamed(attrs, attrName).forEach(function(att) {
      var vm = parseInt(att.get("max"));
      if (!isNaN(vm)) {
        var vc = parseInt(att.get("current"));
        if (vc != vm) {
          evt.attributes.push({
            attribute: att,
            current: vc
          });
          att.set("current", vm);
          if (msg) {
            const charId = att.get('characterid');
            whisperChar(charId, msg);
          }
        }
      }
    });
  }

  // Fait foo sur tous les tokens repr\xE9sentant charId, ayant l'effet donn\xE9, et correspondant au nom d'attribut. Pour le cas o\xF9 le token doit \xEAtre li\xE9 au personnage, on ne prend qu'un seul token, sauf si les options indiquent autrement (soit option.tousLesTokens, soit une fonction options.filterAffected)
  // Ne fonctionne correctement que pour les attributs sans _
  function iterTokensOfAttribute(charId, pageId, attrName, attrNameComplet, foo, options) {
    options = options || {};
    var total = 1; //Nombre de tokens affect\xE9s, pour g\xE9rer l'asynchronie si besoin
    if (attrNameComplet == attrName) { //token li\xE9 au character
      var tokens;
      if (pageId) {
        tokens =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            _pageid: pageId,
            represents: charId
          });
      }
      if (tokens === undefined ||
        (tokens.length === 0 && !options.onlyOnPage)) {
        tokens =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            represents: charId
          });
        tokens = tokens.filter(function(tok) {
          if (tok.get('bar1_link') === '') return false;
          var pid = tok.get('pageid');
          var page = getObj('page', pid);
          if (page) {
            return !(page.get('archived'));
          }
          return false;
        });
      }
      if (tokens.length === 0) {
        log("Pas de token pour un personnage");
        log(charId);
        log(attrNameComplet);
        return;
      }
      if (options.tousLesTokens) {
        tokens.forEach(function(tok) {
          foo(tok, tokens.length);
        });
      } else if (options.filterAffected) {
        total = tokens.length;
        tokens.forEach(function(tok) {
          if (options.filterAffected(tok)) foo(tok, total);
        });
      } else foo(tokens[0], 1);
    } else { //token non li\xE9 au character
      var tokenName = attrNameComplet.substring(attrNameComplet.indexOf('_') + 1);
      var tNames;
      if (pageId) {
        tNames =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            _pageid: pageId,
            represents: charId,
            name: tokenName,
            bar1_link: ''
          });
      }
      if (tNames === undefined || (tNames.length === 0 && !options.onlyOnPage)) {
        tNames =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            represents: charId,
            name: tokenName,
            bar1_link: ''
          });
        tNames = tNames.filter(function(tok) {
          var pid = tok.get('pageid');
          var page = getObj('page', pid);
          if (page) {
            return !(page.get('archived'));
          }
          return false;
        });
      }
      total = tNames.length;
      if (total > 1) {
        var character = getObj('character', charId);
        var charName = "d'id " + charId;
        if (character) charName = character.get('name');
        error("Attention, il y a plusieurs tokens nomm\xE9s " + tokenName, total);
        log("  tokens instances du personnage " + charName, total);
      }
      tNames.forEach(function(tok) {
        foo(tok, total);
      });
    }
  }

  var aura_token_on_turn = false;

  function setTokenInitAura(perso) {
    let token = perso.token;
    if (stateCOF.options.affichage.val.init_dynamique.val) {
      threadSync++;
      activateRoundMarker(threadSync, token);
      return;
    }
    if (aura_token_on_turn) {
      // ennemi => rouge
      var aura2_color = '#CC0000';
      if (estAllieJoueur(perso)) {
        // equipe => vert
        aura2_color = '#59E594';
      }
      token.set('aura2_radius', '0.1');
      token.set('aura2_color', aura2_color);
      token.set('showplayers_aura2', true);
    } else {
      var status = '';
      // Cas des tokens personnalis\xE9s
      if (statusForInitEnemy && statusForInitAlly) {
        // ennemi => rouge
        status = statusForInitEnemy;
        if (estAllieJoueur(perso)) {
          // equipe => vert
          status = statusForInitAlly;
        }
      } else status = 'status_flying-flag';
      token.set(status, true);
    }
  }

  //Ne rajoute pas evt \xE0 l'historique
  function setActiveToken(tokenId, evt) {
    let pageId = stateCOF.combat_pageid;
    if (stateCOF.activeTokenId) {
      if (tokenId == stateCOF.activeTokenId) return;
      evt.activeTokenId = stateCOF.activeTokenId;
      let prevToken = getObj('graphic', stateCOF.activeTokenId);
      if (prevToken) {
        affectToken(prevToken, 'statusmarkers', prevToken.get('statusmarkers'), evt);
        affectToken(prevToken, 'aura2_radius', prevToken.get('aura2_radius'), evt);
        affectToken(prevToken, 'aura2_color', prevToken.get('aura2_color'), evt);
        affectToken(prevToken, 'showplayers_aura2', prevToken.get('showplayers_aura2'), evt);
        removeTokenFlagAura(prevToken);
      } else {
        if (pageId) {
          prevToken = findObjs({
            _type: 'graphic',
            _subtype: 'token',
            _pageid: pageId,
            name: stateCOF.activeTokenName
          });
        } else {
          prevToken = findObjs({
            _type: 'graphic',
            _subtype: 'token',
            name: stateCOF.activeTokenName
          });
        }
        prevToken.forEach(function(o) {
          affectToken(o, 'statusmarkers', o.get('statusmarkers'), evt);
          affectToken(o, 'aura2_radius', o.get('aura2_radius'), evt);
          affectToken(o, 'aura2_color', o.get('aura2_color'), evt);
          affectToken(o, 'showplayers_aura2', o.get('showplayers_aura2'), evt);
          removeTokenFlagAura(o);
        });
      }
    }
    if (tokenId) {
      let perso = persoOfId(tokenId, tokenId);
      if (perso) {
        //On remet \xE0 0 la liste des cibles attaqu\xE9es par le personnage
        removeDernieresCiblesAttaquees(perso, evt);
        let token = perso.token;
        // personnage li\xE9 au Token
        affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
        affectToken(token, 'aura2_radius', token.get('aura2_radius'), evt);
        affectToken(token, 'aura2_color', token.get('aura2_color'), evt);
        affectToken(token, 'showplayers_aura2', token.get('showplayers_aura2'), evt);
        setTokenInitAura(perso);
        stateCOF.activeTokenId = tokenId;
        stateCOF.activeTokenName = token.get('name');
        turnAction(perso);
        // Gestion de la confusion
        if (attributeAsBool(perso, "confusion")) {
          //Une chance sur deux de ne pas agir
          if (randomInteger(2) < 2) {
            sendPerso(perso, "est en pleine confusion. Il ne fait rien ce tour");
            removeTokenFlagAura(token);
          } else {
            //Trouver la cr\xE9ature la plus proche
            var closestToken;
            pageId = token.get('pageid');
            var toksOnPage = findObjs({
              _type: 'graphic',
              _subtype: 'token',
              _pageid: pageId,
              layer: 'objects'
            });
            toksOnPage.forEach(function(tok) {
              if (tok.id == tokenId) return;
              var perso = {
                token: tok
              };
              perso.charId = tok.get('represents');
              if (perso.charId === '') return;
              if (getState(perso, 'mort')) return;
              var dist = distanceCombat(token, tok, pageId);
              if (closestToken) {
                if (dist > closestToken.distance) return;
                if (dist < closestToken.distance) {
                  closestToken = {
                    distance: dist,
                    names: [tok.get('name')]
                  };
                  return;
                }
                closestToken.names.push(tok.get('name'));
                return;
              }
              closestToken = {
                distance: dist,
                names: [tok.get('name')]
              };
            });
            if (closestToken) {
              var r = randomInteger(closestToken.names.length) - 1;
              sendPerso(perso,
                "est en pleine confusion. " + onGenre(perso, 'Il', 'Elle') +
                " attaque " + closestToken.names[r] + ".");
            } else {
              sendPerso(perso, "est seul" + onGenre(perso, '', 'e') + " et en plein confusion");
            }
          }
        }
        //On enl\xE8ve aussi les \xE9tats qui ne durent qu'un tour
        var defenseTotale = tokenAttribute(perso, 'defenseTotale');
        if (defenseTotale.length > 0) {
          defenseTotale = defenseTotale[0];
          var tourDefTotale = defenseTotale.get('max');
          if (tourDefTotale < stateCOF.tour) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(defenseTotale);
            defenseTotale.remove();
          }
        }
      } else {
        error("Impossible de trouver le token dont c'est le tour", tokenId);
        stateCOF.activeTokenId = undefined;
      }
    } else stateCOF.activeTokenId = undefined;
  }

  const armeDeJetRegExpr = new RegExp(/^repeating_(armes|pnjatk)_[^_]*_armejetqte$/);

  function recupererArmesDeJet(attrs, evt) {
    attrs.forEach(function(a) {
      const nom = a.get('name');
      if (!armeDeJetRegExpr.test(nom)) return;
      const charId = a.get('characterid');
      let m = parseInt(a.get('max'));
      if (isNaN(m) || m < 0) {
        error("Erreur dans les quantit\xE9s d'arme de jet", a);
        a.remove();
        return;
      }
      let n = parseInt(a.get('current'));
      if (isNaN(n) || n < m) {
        evt.attributes.push({
          attribute: a,
          current: n,
          max: m
        });
        whisperChar(charId, "r\xE9cup\xE8re ses armes de jet");
        a.set('current', m);
      }
    });
  }

  function sortirDuCombat() {
    stateCOF.usureOff = undefined;
    stateCOF.prescience = undefined;
    stateCOF.nextPrescience = undefined;
    if (!stateCOF.combat) {
      log("Pas en combat");
      sendChat("GM", "/w GM Le combat est d\xE9j\xE0 termin\xE9");
      return;
    }
    sendChat("GM", "Le combat est termin\xE9");
    let evt = {
      type: 'fin_combat',
      initiativepage: Campaign().get('initiativepage'),
      turnorder: Campaign().get('turnorder'),
      attributes: [],
      combat: true,
      tour: stateCOF.tour,
      init: stateCOF.init,
      deletedAttributes: [],
      chargeFantastique: stateCOF.chargeFantastique
    };
    stateCOF.combat = false;
    stateCOF.chargeFantastique = undefined;
    stateCOF.armeesDesMorts = undefined;
    setActiveToken(undefined, evt);
    Campaign().set('initiativepage', false);
    let attrs = findObjs({
      _type: 'attribute'
    });
    // Fin des effets qui durent pour le combat
    attrs = removeAllAttributes('attributDeCombat', evt, attrs);
    attrs = removeAllAttributes('enflamme', evt, attrs);
    attrs = removeAllAttributes('protegerUnAllie', evt, attrs);
    attrs = removeAllAttributes('protegePar', evt, attrs);
    attrs = removeAllAttributes('interposer', evt, attrs);
    attrs = removeAllAttributes('defenseTotale', evt, attrs);
    attrs = removeAllAttributes('dureeStrangulation', evt, attrs);
    attrs = removeAllAttributes('defautDansLaCuirasse', evt, attrs);
    attrs = removeAllAttributes('postureDeCombat', evt, attrs);
    attrs = removeAllAttributes('dedouble', evt, attrs);
    attrs = removeAllAttributes('limiteParCombat', evt, attrs);
    attrs = removeAllAttributes('limiteParTour', evt, attrs);
    attrs = removeAllAttributes('armeSecreteBardeUtilisee', evt, attrs);
    attrs = removeAllAttributes('attaqueMalgreMenace', evt, attrs);
    attrs = removeAllAttributes('limiteApplicationManoeuvre', evt, attrs);
    attrs = removeAllAttributes('attaqueParMeute', evt, attrs);
    attrs = removeAllAttributes('dernieresCiblesAttaquees', evt, attrs);
    attrs = removeAllAttributes('testsRatesDuTour', evt, attrs);
    attrs = removeAllAttributes('effetsTemporairesLies', evt, attrs);
    attrs = removeAllAttributes('aAgiAZeroPV', evt, attrs);
    attrs = removeAllAttributes('injonctionMortelle', evt, attrs);
    attrs = removeAllAttributes('cercleDeProtectionActif', evt, attrs);
    attrs = removeAllAttributes('feinte', evt, attrs);
    attrs = removeAllAttributes('lienDeSangVers', evt, attrs);
    attrs = removeAllAttributes('lienDeSangDe', evt, attrs);
    attrs = removeAllAttributes('prescienceUtilisee', evt, attrs);
    attrs = removeAllAttributes('attaqueAOutrance', evt, attrs);
    attrs = removeAllAttributes('increvableHumainUtilise', evt, attrs);
    attrs = removeAllAttributes('resistanceRaillerie', evt, attrs);
    attrs = removeAllAttributes('defierLaMort', evt, attrs);
    attrs = removeAllAttributes('traquenardImpossible', evt, attrs);
    attrs = removeAllAttributes('niveauDesObjetsAnimes', evt, attrs);
    attrs = removeAllAttributes('seulContreTous_leader', evt, attrs);
    attrs = removeAllAttributes('meneurDHommesCible', evt, attrs);
    // Autres attributs
    // On r\xE9cup\xE8re les munitions r\xE9cup\xE9rables
    resetAttr(attrs, 'munition', evt, "r\xE9cup\xE8re ses munitions");
    recupererArmesDeJet(attrs, evt);
    //Utilisation automatique de second souffle, si pas utilis\xE9
    let tokens = findObjs({ // Les tokens sur la page du combat
      _type: 'graphic',
      _subtype: 'token',
      _pageid: stateCOF.combat_pageid,
    });
    let persosDuCombat = []; //peupl\xE9 la premi\xE8re fois qu'on regarde les tokens
    let persoParCharId = {}; //Pour ne garder qu'un jeu de pr\xE9dicat par charId
    tokens.forEach(function(token) {
      let charId = token.get('represents');
      if (charId === '' || charId === undefined) return;
      let perso = {
        token: token,
        charId: charId
      };
      persosDuCombat.push(perso);
      let persoTest = persoParCharId[charId];
      if (persoTest === undefined) {
        persoParCharId[charId] = perso;
        persoTest = perso;
      }
      if (!predicateAsBool(perso, 'secondSouffle')) return;
      if (!isActive(perso)) return;
      if (attributeAsBool(perso, 'secondSouffleUtilise')) return;
      let pvDebut = attributeAsInt(perso, 'PVsDebutCombat', 0);
      if (pvDebut === 0) return; //personnage pas en combat.
      let pv = parseInt(token.get('bar1_value'));
      if (isNaN(pv)) return;
      if (pvDebut <= pv) return;
      let bonus = ficheAttributeAsInt(perso, 'niveau', 1);
      bonus += modCarac(perso, 'constitution');
      let jetSoins = rollDePlus(10, {
        bonus: bonus
      });
      let msg = ' reprend son souffle et r\xE9cup\xE8re ';
      let soins = jetSoins.val;
      if (pv + soins > pvDebut) {
        soins = pvDebut - pv;
        msg += soins + " PV (le jet \xE9tait " + jetSoins.roll + ")";
      } else {
        msg += jetSoins.roll + " PVs";
      }
      sendPerso(perso, msg);
      soigneToken(perso, soins, evt, undefined, undefined, {
        recuperation: true
      });
    });
    attrs = removeAllAttributes('secondSouffleUtilise', evt, attrs);
    attrs = removeAllAttributes('PVsDebutCombat', evt, attrs);
    // On diminue l'\xE9bri\xE9t\xE9 des personnages sous vapeurs \xE9thyliques
    allAttributesNamed(attrs, 'vapeursEthyliques').forEach(function(attr) {
      var veCharId = attr.get('characterid');
      if (veCharId === undefined || veCharId === '') {
        error("Attribut sans personnage associ\xE9", attr);
        return;
      }
      iterTokensOfAttribute(veCharId, stateCOF.combat_pageid,
        'vapeursEthyliques', attr.get('name'),
        function(tok) {
          var perso = {
            charId: veCharId,
            token: tok
          };
          removeTokenAttr(perso, 'niveauEbriete', evt, {
            msg: "d\xE9sao\xFBle"
          });
        });
    });
    attrs = removeAllAttributes('vapeursEthyliques', evt, attrs);
    // Pour frappe du vide, on rengaine l'arme, cela remet aussi l'attribut
    persosDuCombat.forEach(function(perso) {
      let persoTest = persoParCharId[perso.charId];
      if (predicateAsBool(persoTest, 'frappeDuVide')) {
        degainerArme(perso, '', evt);
      }
    });
    // On remet en main l'arme par d\xE9faut si elle est pr\xE9cis\xE9e
    persosDuCombat.forEach(function(perso) {
      if (!isActive(perso)) return;
      let persoTest = persoParCharId[perso.charId];
      let arme = predicateAsBool(persoTest, 'armeParDefaut');
      if (arme === undefined) return;
      if (arme === true) degainerArme(perso, '', evt);
      else degainerArme(perso, arme, evt);
    });
    // On recharge les armes
    let charges = {};
    persosDuCombat.forEach(function(perso) {
      let persoTest = persoParCharId[perso.charId];
      if (charges[persoTest.charId] === undefined) {
        charges[persoTest.charId] = {};
        let pred = getPredicates(perso);
        for (let predicat in pred) {
          if (predicat.startsWith('charge_'))
            charges[persoTest.charId][predicat] = pred[predicat];
        }
      }
      for (let charge in charges[persoTest.charId]) {
        setTokenAttr(perso, charge, charges[persoTest.charId][charge], evt);
      }
    });
    //Effet de ignorerLaDouleur
    let ilds = allAttributesNamed(attrs, 'douleurIgnoree');
    ilds = ilds.concat(allAttributesNamed(attrs, 'memePasMalIgnore'));
    ilds.forEach(function(ild) {
      let douleur = parseInt(ild.get('current'));
      if (isNaN(douleur)) {
        error("La douleur ignor\xE9e n'est pas un nombre", douleur);
        return;
      }
      let charId = ild.get('characterid');
      if (charId === undefined || charId === '') {
        error("Attribut sans personnage", ild);
        return;
      }
      let ildName = ild.get('name');
      if (ildName == 'douleurIgnoree' || ildName == 'memePasMalIgnore') {
        let pvAttr = findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: 'PV'
        }, {
          caseInsensitive: true
        });
        if (pvAttr.length === 0) {
          error("Personnage sans PV ", charId);
          return;
        }
        pvAttr = pvAttr[0];
        let pv = parseInt(pvAttr.get('current'));
        if (isNaN(pv)) {
          error("PV mal form\xE9s ", pvAttr);
          return;
        }
        evt.attributes.push({
          attribute: pvAttr,
          current: pv
        });
        let newPv = pv - douleur;
        if (newPv < 0) newPv = 0;
        pvAttr.set('current', newPv);
        if (pv > 0 && newPv === 0) {
          sendChar(charId, "s'\xE9croule. Il semble sans vie. La douleur qu'il avait ignor\xE9e l'a finalement rattrap\xE9...", true);
        } else {
          let tempDmg = ficheAttributeAsInt(charId, 'DMTEMP', 0);
          if (pv > tempDmg && newPv <= tempDmg) {
            sendChar(charId, "s'\xE9croule, assomm\xE9. La douleur qu'il avait ignor\xE9e l'a finalement rattrap\xE9...", true);
          } else {
            sendChar(charId, "subit le contrecoup de la douleur qu'il avait ignor\xE9e", true);
          }
        }
      } else { // ignorer la douleur d'un token
        let tokName = ildName.substring(ildName.indexOf('_') + 1);
        let tokensIld = findObjs({
          _type: 'graphic',
          _subtype: 'token',
          represents: charId,
          name: tokName
        });
        if (tokensIld.length === 0) {
          error("Pas de token nomm\xE9 " + tokName + " qui aurait ignor\xE9 la douleur", ild);
          return;
        }
        if (tokensIld.length > 1) {
          sendChar(charId, "a plusieurs tokens nomm\xE9s " + tokName + ". Un seul d'entre eux subira l'effet d'ignorer la douleur", true);
        }
        let tokPv = parseInt(tokensIld[0].get('bar1_value'));
        let tokNewPv = tokPv - douleur;
        if (tokNewPv < 0) tokNewPv = 0;
        let perso = {
          charId: charId,
          token: tokensIld[0]
        };
        updateCurrentBar(perso, 1, tokNewPv, evt);
        //TODO: faire mourrir, assommer
      }
    }); // end forEach on all attributes ignorerLaDouleur
    ilds.forEach(function(ild) {
      evt.deletedAttributes.push(ild);
      ild.remove();
    });
    if (ilds.length > 0) {
      attrs = attrs.filter(function(attr) {
        let ind = ilds.findIndex(function(nattr) {
          return nattr.id == attr.id;
        });
        return (ind == -1);
      });
    }
    // fin des effets temporaires (dur\xE9e en tours, ou dur\xE9e = combat)
    attrs.forEach(function(obj) {
      let attrName = obj.get('name');
      let charId = obj.get('characterid');
      if (estEffetTemp(attrName)) {
        finDEffet(obj, effetTempOfAttribute(obj), attrName, charId, evt, {
          pageId: stateCOF.combat_pageid
        });
      } else if (estAttributEffetTemp(attrName)) {
        evt.deletedAttributes.push(obj);
        obj.remove();
      } else if (estEffetCombat(attrName)) {
        let effet = effetCombatOfAttribute(obj);
        if (effet == 'armeDArgent') {
          //Alors on va rengainer l'arme en main si c'est l'arme d'argent
          iterTokensOfAttribute(charId, stateCOF.combat_pageid, effet, attrName, function(token) {
            let perso = {
              token: token,
              charId: charId
            };
            let arme = armesEnMain(perso);
            if (!arme) return;
            let options = arme.options;
            if (options === '') return;
            if (!options.startsWith(' ')) options = ' ' + options;
            options = options.split(' --');
            options.find(function(o) {
              if (o.startsWith('si ')) {
                o = o.split(' ');
                if (o.includes('armeDArgent')) {
                  degainerArme(perso, '', evt);
                  return true;
                }
              }
              return false;
            });
          });
        }
        let mc = messageEffetCombat[effet].fin;
        if (mc && mc !== '') sendChar(charId, mc, true);
        evt.deletedAttributes.push(obj);
        obj.remove();
      } else if (estAttributEffetCombat(attrName)) {
        evt.deletedAttributes.push(obj);
        obj.remove();
      }
    });
    if (stateCOF.tokensTemps) {
      evt.deletedTokensTemps = [];
      stateCOF.tokensTemps.forEach(function(tt) {
        let token = getObj('graphic', tt.tid);
        if (token) {
          let ett = {...tt
          };
          ett.deletedToken = getTokenFields(token);
          evt.deletedTokensTemps.push(ett);
          token.remove();
        }
      });
      delete stateCOF.tokensTemps;
    }
    addEvent(evt);
  }

  function pointsDeRecuperation(perso) {
    // retourne les nombre de PR restant
    var attrPR = tokenAttribute(perso, 'pointsDeRecuperation');
    var prc = 5;
    var prm = 5;
    if (attrPR.length > 0) {
      prc = parseInt(attrPR[0].get('current'));
      prm = parseInt(attrPR[0].get('max'));
      return {
        current: prc,
        max: prm
      };
    }
    attrPR = charAttribute(perso.charId, 'pr', {
      caseInsensitive: true
    });
    if (attrPR.length === 0) {
      return {
        current: 5,
        max: 5
      };
    }
    prm = attrPR[0].get('max');
    if (prm === '') prm = 5;
    else {
      prm = parseInt(prm);
      if (isNaN(prm) || prm < 0) prm = 5;
    }
    prc = attrPR[0].get('current');
    if (prc === '') prc = 5;
    else {
      prc = parseInt(prc);
      if (isNaN(prc)) prc = prm;
      else if (prc < 0) prc = 0;
      else if (prc > prm) prc = prm;
    }
    return {
      current: prc,
      max: prm
    };
  }

  function enleverPointDeRecuperation(perso, evt) {
    evt.attributes = evt.attributes || [];
    var attrPR = charAttribute(perso.charId, 'pr', {
      caseInsensitive: true
    });
    if (attrPR.length === 0) {
      attrPR = createObj("attribute", {
        characterid: perso.charId,
        name: 'pr',
        current: 4,
        max: 5
      });
      evt.attributes.push({
        attribute: attrPR,
      });
      return;
    }
    var prc = attrPR[0].get('current');
    if (prc === '') prc = 5;
    else prc = parseInt(prc);
    if (isNaN(prc) || prc < 1) {
      sendChat("COF", "Plus de point de r\xE9cup\xE9ration \xE0 enlever");
      return;
    }
    evt.attributes.push({
      attribute: attrPR[0],
      current: prc
    });
    attrPR[0].set('current', prc - 1);
  }

  function rajouterPointDeRecuperation(perso, evt) {
    evt.attributes = evt.attributes || [];
    var attrPR = charAttribute(perso.charId, 'pr', {
      caseInsensitive: true
    });
    if (attrPR.length === 0) {
      attrPR = createObj("attribute", {
        characterid: perso.charId,
        name: 'pr',
        current: 5,
        max: 5
      });
      evt.attributes.push({
        attribute: attrPR,
      });
      return;
    }
    var prmax = attrPR[0].get('max');
    if (prmax === '') prmax = 5;
    else {
      prmax = parseInt(prmax);
      if (isNaN(prmax) || prmax < 0) prmax = 5;
    }
    var prc = attrPR[0].get('current');
    if (prc === '') prc = 5;
    else prc = parseInt(prc);
    if (isNaN(prc) || prc >= prmax) {
      return;
    }
    evt.attributes.push({
      attribute: attrPR[0],
      current: prc
    });
    attrPR[0].set('current', prc + 1);
    return true;
  }

  //Asynchrone
  // ne rajoute pas evt \xE0 l'historique
  function soinsEcuyers(ecuyers, manquePV, playerId, evt) {
    ecuyers.forEach(function(ec) {
      var ecuyer = ec.perso;
      var ecuyerDe = ec.ecuyerDe;
      var charChevalier = findObjs({
        _type: 'character',
        name: ecuyerDe
      });
      if (charChevalier.length === 0) {
        error("Pas de chevalier " + ecuyerDe + " pour l'\xE9cuyer " + ecuyer.token.get('name'), ec);
        return;
      }
      if (charChevalier.length > 1) {
        error("Plusieurs personnages nomm\xE9s " + ecuyerDe + ". Attention aux ambiguit\xE9s.");
      }
      charChevalier = charChevalier[0].id;
      var maxASoigner = modCarac(charChevalier, 'charisme') + 1;
      var allies = alliesParPerso[ecuyer.charId] || new Set();
      var alliesASoigner = [];
      var nbCibles = 0;
      var chevalier;
      let monture;
      manquePV.forEach(function(cible) {
        if (cible.charId == charChevalier) {
          chevalier = cible;
          nbCibles++;
          return;
        }
        if (allies.has(cible.charId)) {
          var montureDe = findObjs({
            _type: 'attribute',
            _characterid: cible.charId,
            name: 'montureDe'
          });
          if (montureDe.length > 0 && montureDe[0].get('current') == ecuyerDe) {
            monture = cible;
            nbCibles++;
            return;
          }
          alliesASoigner.push(cible);
        }
      }); //fin de d\xE9termination des cibles
      if (chevalier === undefined && monture === undefined &&
        (maxASoigner < 1 || alliesASoigner.length === 0)) { //Personne \xE0 soigner
        return;
      }
      //TODO: utiliser l'id d'un player qui contr\xF4le le chevalier
      var display = startFramedDisplay(playerId, "Services d'\xE9cuyer", ecuyer);
      var finSoin = function() {
        nbCibles--;
        if (nbCibles === 0) {
          if (display) sendChat("", endFramedDisplay(display));
        }
      };
      var soigneUneCible = function(c) {
        sendChat('', "[[2d6]]", function(res) {
          var soins = res[0].inlinerolls[0].results.total;
          var soinTxt = buildinline(res[0].inlinerolls[0], 'normal', true);
          var printTrue = function(s) {
            var msgSoin = ecuyer.token.get('name') + ' ';
            if (c.id == ecuyer.token.id) {
              msgSoin = 'se soigne de ';
            } else {
              msgSoin = c.token.get('name') + " r\xE9cup\xE8re ";
            }
            if (s < soins)
              msgSoin += s + " PV. (Le r\xE9sultat du jet \xE9tait " + soinTxt + ")";
            else msgSoin += soinTxt + " PV.";
            addLineToFramedDisplay(display, msgSoin);
          };
          soigneToken(c, soins, evt, printTrue);
          finSoin();
        }); //fin du sendChat
      }; // fin de d\xE9finition de soigneCible
      var peutToutSoigner = (alliesASoigner.length <= maxASoigner);
      if (peutToutSoigner) nbCibles += alliesASoigner.length;
      else if (maxASoigner > 0) nbCibles++; //pour ne pas finir avant d'imprimer les boutons
      if (chevalier) soigneUneCible(chevalier);
      if (monture) soigneUneCible(monture);
      if (peutToutSoigner) {
        alliesASoigner.forEach(soigneUneCible);
      } else if (maxASoigner > 0) {
        addLineToFramedDisplay(display, "Peut prendre soin de (max " + maxASoigner + ") :");
        var attr = setTokenAttr(ecuyer, 'SoinsdEcuyer', maxASoigner, evt);
        var action = "!cof-soin " + ecuyer.token.id + " ";
        alliesASoigner.forEach(function(c) {
          var nom = c.token.get('name');
          addLineToFramedDisplay(display, bouton(action + c.token.id + " 2d6", nom, ecuyer, {
            ressource: attr
          }));
        });
        finSoin();
      }
    }); //fin iteration sur les \xE9cuyers
  }

  function parseOptions(msg) {
    let pageId, playerId;
    if (msg.selected && msg.selected.length > 0) {
      let firstSelected = getObj('graphic', msg.selected[0]._id);
      if (firstSelected === undefined) {
        error("Un token s\xE9lectionn\xE9 n'est pas trouv\xE9 en interne", msg.selected);
        return;
      }
      pageId = firstSelected.get('pageid');
    } else {
      playerId = getPlayerIdFromMsg(msg);
      pageId = getPageId(playerId);
    }
    let opts = msg.content.split(' --');
    let cmd = opts.shift().split(' ');
    cmd = cmd.filter(function(c) {
      return c !== '';
    });
    let options = {
      pageId: pageId,
      playerId: playerId,
      cmd: cmd
    };
    opts.forEach(function(arg) {
      cmd = arg.trim().split(' ');
      switch (cmd[0]) {
        case 'attaqueMentale':
        case 'seulementVivant':
        case 'repos':
        case 'secret':
        case 'magique':
        case 'montreActions':
          options[cmd[0]] = true;
          break;
        case 'lanceur':
          if (cmd.length < 2) {
            error("Il faut pr\xE9ciser l'id ou le nom du lanceur", arg);
            return;
          }
          options.lanceur = persoOfId(cmd[1], cmd[1], pageId);
          if (options.lanceur === undefined) {
            error("Argument de --lanceur non valide", cmd);
          }
          return;
        case 'puissant':
          if (cmd.length < 2) {
            options.puissant = "on";
            return;
          }
          switch (cmd[1]) {
            case "oui":
              options.puissant = "on";
              return;
            case "non":
              options.puissant = "off";
              return;
            case "duree":
              options.puissantDuree = true;
              return;
            case 'portee':
              options.puissantPortee = true;
              return;
            default:
              error("Option puissant non reconnue", cmd);
          }
          return;
        case 'mana':
          if (cmd.length < 2) {
            error("Pas assez d'argument pour --mana", cmd);
            return;
          }
          let cout;
          if (cmd.length > 2 && cmd[1] !== '' && cmd[2] !== '') {
            options.lanceur = options.lanceur || persoOfId(cmd[1], cmd[1], pageId);
            if (options.lanceur === undefined) {
              error("Premier argument de --mana non valide", cmd);
              return;
            }
            cout = parseInt(cmd[2]);
          } else {
            cout = parseInt(cmd[1]);
          }
          if (isNaN(cout) || cout < 0) {
            error("Co\xFBt en mana incorrect", cmd);
            return;
          }
          options.mana = options.mana || 0;
          options.mana += cout;
          return;
        case 'tempeteDeMana':
          parseTempeteDeMana(cmd, options);
          return;
        case 'rang':
          if (cmd.length < 2) {
            error("Usage : --rang r", cmd);
            return;
          }
          var rang = parseInt(cmd[1]);
          if (isNaN(rang) || rang < 1) {
            error("Le rang doit \xEAtre un nombre positif");
            return;
          }
          options.rang = rang;
          break;
        case 'limiteParJour':
          if (cmd.length < 2) {
            error("Il manque la limite journali\xE8re", cmd);
            return;
          }
          let limiteParJour = parseInt(cmd[1]);
          if (isNaN(limiteParJour) || limiteParJour < 1) {
            error("La limite journali\xE8re doit \xEAtre un nombre positif", cmd);
            return;
          }
          options.limiteParJour = limiteParJour;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            options.limiteParJourRessource = cmd.join('_');
          }
          return;
        case 'depasseLimite':
          if (cmd.length < 2) {
            error("Il manque le co\xFBt en mana pour depasser la limite", cmd);
            return;
          }
          let depasse = parseInt(cmd[1]);
          if (isNaN(depasse) || depasse < 1) {
            error("Le co\xFBt de d\xE9passement doit \xEAtre un nombre positif", cmd);
            return;
          }
          options.depasseLimite = depasse;
          return;
        case 'limiteSoinsParJour':
          if (cmd.length < 2) {
            error("Il manque la limite de soins journali\xE8re", cmd);
            return;
          }
          var limiteSoinsParJour = parseInt(cmd[1]);
          if (isNaN(limiteSoinsParJour) || limiteSoinsParJour < 1) {
            error("La limite de soins journali\xE8re doit \xEAtre un nombre positif", cmd);
            return;
          }
          options.limiteSoinsParJour = limiteSoinsParJour;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            options.limiteSoinsParJourRessource = cmd.join('_');
          }
          return;
        case 'limiteCibleParJour':
          if (cmd.length < 2) {
            error("Il manque la limite journali\xE8re", cmd);
            return;
          }
          var limiteCibleParJour = parseInt(cmd[1]);
          if (isNaN(limiteCibleParJour) || limiteCibleParJour < 1) {
            error("La limite journali\xE8re doit \xEAtre un nombre positif", cmd);
            return;
          }
          options.limiteCibleParJour = limiteCibleParJour;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            options.limiteCibleParJourRessource = cmd.join('_');
          }
          return;
        case 'limiteParCombat':
          if (cmd.length < 2) {
            options.limiteParCombat = 1;
            return;
          }
          var limiteParCombat = parseInt(cmd[1]);
          if (isNaN(limiteParCombat) || limiteParCombat < 1) {
            error("La limite par combat doit \xEAtre un nombre positif", cmd);
            return;
          }
          options.limiteParCombat = limiteParCombat;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            options.limiteParCombatRessource = cmd.join('_');
          }
          return;
        case "portee":
          if (cmd.length < 2) {
            error("Pas assez d'argument pour --portee n", cmd);
            return;
          }
          var portee;
          if (cmd.length > 2) {
            var tokPortee = persoOfId(cmd[1], cmd[1], pageId);
            if (tokPortee === undefined) {
              error("Premier argument de --portee non valide", cmd);
              return;
            }
            portee = parseInt(cmd[2]);
          } else {
            portee = parseInt(cmd[1]);
          }
          if (isNaN(portee) || portee < 0) {
            error("Port\xE9e incorrecte", cmd);
            return;
          }
          options.portee = portee;
          return;
        case 'saveParTour':
          options.saveParTour = parseSave(cmd);
          return;
        case 'save':
          options.save = parseSave(cmd);
          return;
        case 'dose':
          if (cmd.length < 2) {
            error("Il faut le nom de la dose", cmd);
            return;
          }
          options.dose = cmd[1];
          return;
        case 'decrAttribute':
          if (cmd.length < 2) {
            error("Erreur interne d'une commande g\xE9n\xE9r\xE9e par bouton", opts);
            return;
          }
          let attr = getObj('attribute', cmd[1]);
          if (attr === undefined && options.lanceur) {
            attr = tokenAttribute(options.lanceur, cmd[1]);
            if (attr.length === 0) {
              log("Attribut \xE0 changer perdu");
              log(cmd);
              return;
            }
            attr = attr[0];
          }
          if (attr === undefined) {
            log("Attribut \xE0 changer perdu");
            log(cmd);
            return;
          }
          options.decrAttribute = attr.id;
          return;
        case 'valeur':
          if (cmd.length < 2) {
            error("Il manque la valeur en argument de l'option --valeur", opts);
            return;
          }
          options.valeur = cmd[1];
          if (cmd.length > 2) options.valeurMax = cmd[2];
          return;
        case 'accumuleDuree':
          if (cmd.length < 2) {
            error("Il manque la valeur en argument de l'option --accumuleDuree", opts);
            return;
          }
          var accumuleDuree = parseInt(cmd[1]);
          if (isNaN(accumuleDuree) || accumuleDuree < 1) {
            error("On ne peut accumuler qu'on nombre strictement positif d'effets", opts);
            return;
          }
          options.accumuleDuree = accumuleDuree;
          return;
        case 'optionEffet':
          if (cmd.length < 2) {
            error("Il manque l'option en argument de --optionEffet", cmd);
            return;
          }
          options.optionsEffet = options.optionsEffet || '';
          options.optionsEffet = ' --' + cmd.slice(1).join(' ') + options.optionsEffet;
          return;
        case "nonVivant":
          options.nonVivant = true;
          if (cmd.length > 1) {
            var nonVivantPerso = persoOfId(cmd[1], cmd[1], pageId);
            if (nonVivantPerso) {
              options.nonVivant = predicateAsBool(nonVivantPerso, 'nonVivant');
            }
          }
          return;
        case "fx":
          getFx(cmd, 'fx', options);
          return;
        case "targetFx":
          getFx(cmd, 'targetFx', options);
          break;
        case "classeEffet":
          if (cmd.length < 2) {
            sendChat("COF", "Il manque un argument \xE0 l'option --classeEffet");
            return;
          }
          options.classeEffet = cmd[1];
          return;
        case 'message':
          if (cmd.length < 2) {
            error("Il manque le message apr\xE8s --message", cmd);
            return;
          }
          options.messages = options.messages || [];
          options.messages.push(cmd.slice(1).join(' '));
          return;
        case 'image':
          if (cmd.length < 2) {
            error("Il manque le nom de l'imageapr\xE8s --image", cmd);
            return;
          }
          options.image = cmd[1].replace('&#58;', ':');
          return;
        case 'son':
          if (cmd.length < 2) {
            error("Il manque le nom du son apr\xE8s --son", cmd);
            return;
          }
          options.son = cmd.slice(1).join(' ');
          return;
        case 'feu':
        case 'froid':
        case 'acide':
        case 'electrique':
        case 'sonique':
        case 'poison':
        case 'maladie':
        case 'energie':
          options.type = cmd[0];
          return;
        case 'bonus':
        case 'rayon':
          if (cmd.length >= 2) {
            let value = parseInt(cmd[1]);
            if (!isNaN(value)) {
              options[cmd[0]] = value;
            }
          }
          return;
        case 'etat':
          if (cmd.length < 2) {
            error("Il manque le nom de l'\xE9tat et sa valeur apr\xE8s --etat", cmd);
            return;
          }
          options.etats = options.etats || {};
          if (cmd.length < 3) {
            options.etats[cmd[1]] = true;
            return;
          }
          if (cmd[2] == 'false' || cmd[2] == 'non') options.etats[cmd[1]] = false;
          else if (cmd[2] == 'true' || cmd[2] == 'oui') options.etats[cmd[1]] = true;
          else options.etats[cmd[1]] = cmd[2];
          return;
        case 'degainer':
          if (cmd.length > 1) options.degainer = cmd[1];
          else options.degainer = '';
          return;
        case 'soin':
        case 'dm':
          let t = cmd[0];
          if (options[t]) {
            error(t + " d\xE9j\xE0 d\xE9fini", opts);
            return;
          }
          if (cmd.length < 2) {
            error("Il manque l'expression pour les " + t + "s", opts);
          }
          options[t] = cmd.slice(1).join(' ');
          return;
        case 'malusRepetition':
          let malusRepetition = 1;
          if (cmd.length > 1) {
            malusRepetition = parseInt(cmd[1]);
            if (isNaN(malusRepetition)) malusRepetition = 1;
          }
          options.malusRepetition = malusRepetition;
          return;
        case 'magieEnArmure':
          if (cmd.length > 1) {
            if (cmd[1] == 'mana') {
              options.magieEnArmureMana = true;
            } else {
              let base = parseInt(cmd[1]);
              if (isNaN(base)) {
                error("L'argument de --magieEnArmure doit \xEAtre un nombre ou mana", cmd);
                return;
              }
              options.magieEnArmure = {
                base
              };
            }
          } else {
            options.magieEnArmure = {};
          }
          return;
        default:
          return;
      }
    });
    return options;
  }

  //Si il y a des effets \xE0 dur\xE9e ind\xE9termin\xE9es, les rappeler au MJ, avec un bouton pour facilement y mettre fin si n\xE9cessaire
  function proposerFinEffetsIndetermines() {
    let attrs = findObjs({
      _type: 'attribute'
    });
    attrs = attrs.filter(function(a) {
      let name = a.get('name');
      return name == 'PVTemporaires' || name.startsWith('PVTemporaires_') ||
        estEffetIndetermine(name);
    });
    if (attrs.length === 0) return;
    const display = startFramedDisplay(undefined, "<b>Effets \xE0 dur\xE9e ind\xE9termin\xE9e actifs</b>", undefined, {
      chuchote: 'gm'
    });
    let attrsParPerso = {};
    attrs.forEach(function(a) {
      const charId = a.get('characterid');
      const attrName = a.get('name');
      let ef = {
        nom: attrName
      };
      let attrLie;
      if (attrName == 'PVTemporaires') {
        let pt = parseInt(a.get('current'));
        if (isNaN(pt) || pt < 1) {
          a.remove();
          return;
        }
        attrLie = true;
        ef.pvTemporaires = pt;
      } else if (attrName.startsWith('PVTemporaires_')) {
        let pt = parseInt(a.get('current'));
        if (isNaN(pt) || pt < 1) {
          a.remove();
          return;
        }
        ef.pvTemporaires = pt;
      } else {
        let mes = messageEffetIndetermine[attrName];
        if (mes) {
          ef.actif = mes.actif;
          attrLie = true;
        }
      }
      if (attrLie) {
        if (attrsParPerso[charId] === undefined) {
          let resLinked = {
            effets: [ef]
          };
          let linkedTokens = findObjs({
            _type: 'graphic',
            represents: charId
          });
          linkedTokens = linkedTokens.filter(function(t) {
            return t.get('bar1_link') !== '';
          });
          if (linkedTokens.length === 0) {
            let character = getObj('character', charId);
            if (character === undefined) {
              error("Attribut sans personnage", a);
              a.remove();
              return;
            }
            resLinked.nomPerso = character.get('name');
          } else {
            resLinked.nomPerso = linkedTokens[0].get('name');
            resLinked.tokenId = linkedTokens[0].id;
          }
          attrsParPerso[charId] = resLinked;
          return;
        }
        attrsParPerso[charId].effets.push(ef);
        return;
      } // on a un attribut de token non li\xE9
      let pn = attrName.indexOf('_');
      if (pn < 1) return;
      ef.nom = attrName.substring(0, pn - 1);
      if (!ef.pvTemporaires) {
        let mes = messageEffetIndetermine[ef.nom];
        if (mes === undefined) return;
        ef.actif = mes.actif;
      }
      let nomPerso = attrName.substring(pn + 1);
      if (attrsParPerso[nomPerso] === undefined) {
        let tokens = findObjs({
          _type: 'graphic',
          represents: charId
        });
        tokens = tokens.filter(function(t) {
          return t.get('bar1_link') === '' && t.get('name') == nomPerso;
        });
        if (tokens.length === 0) {
          error("Attribut de mook sans personnage", a);
          a.remove();
          return;
        }
        attrsParPerso[nomPerso] = {
          nomPerso: nomPerso,
          tokenId: tokens[0].id,
          effets: [ef]
        };
        return;
      }
      attrsParPerso[nomPerso].effets.push(ef);
    });
    _.each(attrsParPerso, function(a) {
      let line = '<b>' + a.nomPerso + "</b> : ";
      a.effets.forEach(function(e) {
        if (e.pvTemporaires) {
          line += "PV temporaires " + e.pvTemporaires + ' ';
        } else {
          line += e.actif + ' ';
        }
        if (a.tokenId) {
          if (e.pvTemporaires) {
            line += boutonSimple('!cof-set-attribute PVTemporaires 0 --message Disparition des PVs temporaires --target ' + a.tokenId, 'X');
          } else {
            line += boutonSimple('!cof-effet ' + e.nom + ' false --target ' + a.tokenId, 'X');
          }
        } else line += "supprimer l'attribut " + e.nom;
      });
      addLineToFramedDisplay(display, line);
    });
    sendChat('', endFramedDisplay(display));
  }

  // Remise \xE0 z\xE9ro de toutes les limites journali\xE8res
  // N'ajoute pas evt \xE0 l'historique
  function jour(evt, options) {
    var attrs;
    attrs = removeAllAttributes('pressionMortelle', evt);
    attrs = removeAllAttributes('soinsLegers', evt, attrs);
    attrs = removeAllAttributes('depassesoinsLegers', evt, attrs);
    attrs = removeAllAttributes('soinsModeres', evt, attrs);
    attrs = removeAllAttributes('depassesoinsModeres', evt, attrs);
    attrs = removeAllAttributes('fortifie', evt, attrs);
    attrs = removeAllAttributes('limiteParJour', evt, attrs);
    attrs = removeAllAttributes('depasseLimiteParJour', evt, attrs);
    attrs = removeAllAttributes('tueurFantasmagorique', evt, attrs);
    attrs = removeAllAttributes('resisteInjonction', evt, attrs);
    attrs = removeAllAttributes('testsRatesDuTour', evt, attrs);
    //Les \xE9lixirs
    attrs = removeAllAttributes('elixirsACreer', evt, attrs);
    attrs = proposerRenouveauElixirs(evt, attrs);
    //Les runes
    attrs = proposerRenouveauRunes(evt, attrs);
    //Les plantes m\xE9dicinales
    attrs = removeAllAttributes('dose_Plante m\xE9dicinale', evt, attrs);
    attrs = removeConsommables('Plante m\xE9dicinale', evt, attrs);
    //On pourrait diviser par 2 le nombre de baies
    //var attrsBaie = allAttributesNamed(attrs, 'dose_Baie_magique');
    //Saves journaliers
    var attrsSave = attrs.filter(function(attr) {
      var attrName = attr.get('name');
      var indexSave = attrName.indexOf('SaveParJour');
      if (indexSave <= 0) return false;
      indexSave = attrName.indexOf('SaveParJourType');
      return indexSave <= 0;
    });
    //Les saves sont asynchrones
    var count = attrsSave.length;
    if (count === 0) {
      proposerFinEffetsIndetermines();
      return;
    }
    var finalize = function() {
      count--;
      if (count > 0) return;
      proposerFinEffetsIndetermines();
    };
    attrsSave.forEach(function(attr) {
      var attrName = attr.get('name');
      var carac = attr.get('current');
      if (!isCarac(carac)) {
        error("Save par jour " + attrName + " mal form\xE9", carac);
        finalize();
        return;
      }
      var seuil = parseInt(attr.get('max'));
      if (isNaN(seuil)) {
        error("Save par jour " + attrName + " mal form\xE9", seuil);
        finalize();
        return;
      }
      var charId = attr.get('characterid');
      var indexSave = attrName.indexOf('SaveParJour');
      var effetC = attrName.substring(0, indexSave);
      attrName = effetC + attrName.substr(indexSave + 11);
      var token;
      iterTokensOfAttribute(charId, undefined, effetC, attrName, function(tok) {
        if (token === undefined) token = tok;
      });
      if (token === undefined) {
        log("Pas de token pour le save " + attrName);
        finalize();
        return;
      }
      var pageId = token.get('pageid');
      var perso = {
        token: token,
        charId: charId
      };
      if (getState(perso, 'mort')) {
        finalize();
        return;
      }
      var attrEffet = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attrName
      });
      if (attrEffet === undefined || attrEffet.length === 0) {
        error("Save sans effet associ\xE9 " + attrName, attr);
        findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: attr.get('name').replace('SaveParJour', 'SaveParJourType')
        }).forEach(function(a) {
          a.remove();
        });
        attr.remove();
        finalize();
        return;
      }
      attrEffet = attrEffet[0];
      var expliquer = function(msg) {
        sendPerso(perso, msg);
      };
      var sujet = onGenre(perso, 'il', 'elle');
      let met = messageEffetIndetermine[effetC];
      if (met === undefined) met = {
        fin: "r\xE9siste \xE0 l'effet",
        actf: "reste sous l'emprise de l'effet"
      };
      var saveOpts = {
        msgPour: " pour ne plus \xEAtre sous l'effet " + effetC,
        msgReussite: ", " + sujet + " " + met.fin,
        msgRate: ", " + sujet + " " + met.actif,
        rolls: options.rolls,
        chanceRollId: options.chanceRollId
      };
      var attrType = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attr.get('name').replace('SaveParJour', 'SaveParJourType')
      });
      if (attrType.length > 0) {
        saveOpts.type = attrType[0].get('current');
      }
      var saveId = 'saveParJour_' + effetC + "_" + perso.token.id;
      save({
          carac: carac,
          seuil: seuil
        }, perso, saveId, expliquer, saveOpts, evt,
        function(reussite, texte) { //asynchrone
          if (reussite) {
            finDEffet(attrEffet, effetC, attrName, charId, evt, {
              attrSave: attr,
              pageId: pageId
            });
          }
          count--;
        });
    }); //fin boucle attrSave
  }

  //La caract\xE9ristique sans affaiblissement
  function caracNormale(perso, carac) {
    let res = ficheAttributeAsInt(perso, carac, 10);
    if (!persoEstPNJ(perso)) return res;
    let mod;
    switch (carac) {
      case 'force':
        mod = ficheAttributeAsInt(perso, 'pnj_for', 0);
        break;
      case 'dexterite':
        mod = ficheAttributeAsInt(perso, 'pnj_dex', 0);
        break;
      case 'constitution':
        mod = ficheAttributeAsInt(perso, 'pnj_con', 0);
        break;
      case 'intelligence':
        mod = ficheAttributeAsInt(perso, 'pnj_int', 0);
        break;
      case 'sagesse':
        mod = ficheAttributeAsInt(perso, 'pnj_sag', 0);
        break;
      case 'charisme':
        mod = ficheAttributeAsInt(perso, 'pnj_cha', 0);
        break;
    }
    if (mod == Math.floor((caracNormale - 10) / 2)) {
      return res;
    }
    return mod * 2 + 10;
  }

  function caracCourante(perso, carac) {
    return caracNormale(perso, carac) -
      attributeAsInt(perso, 'affaiblissementde' + carac, 0);
  }

  //N'ajoute pas evt \xE0 l'historique
  function diminueAffaiblissement(perso, carac, valeur, evt, malus) {
    if (valeur < 1) return;
    let nomAttr = 'affaiblissementde' + carac;
    malus = malus || attributeAsInt(perso, nomAttr, 0);
    if (valeur < malus) {
      setTokenAttr(perso, nomAttr, malus - valeur, evt);
    } else {
      valeur = malus;
      removeTokenAttr(perso, nomAttr, evt);
    }
    if (carac == 'constitution') {
      let gainMod = Math.floor((valeur) / 2);
      let constitution;
      if (valeur % 2 == 1) {
        constitution = caracNormale(perso, 'constitution');
        if ((constitution - malus) % 2 == 1) gainMod += 1;
      }
      if (gainMod > 0) {
        //On recalcule les pvmax en fonction de la perte courante
        let bar1 = parseInt(perso.token.get("bar1_value"));
        let pvmax = parseInt(perso.token.get("bar1_max"));
        if (isNaN(bar1) || isNaN(pvmax)) {
          error("Affaiblissement de constitution sur un token sans points de vie", perso);
          return;
        }
        let pvMaxNormaux = attributeAsInt(perso, 'pvMaxNormaux', 0);
        if (pvMaxNormaux < pvmax) {
          error("Les PV max sont inf\xE9rieurs \xE0 la valeur normale", pvMaxNormaux);
          return;
        }
        if (valeur == malus || (valeur == malus - 1 && caracNormale(perso, 'consititution') % 2 == 1)) {
          removeTokenAttr(perso, 'pvMaxNormaux', evt);
          let pvGagnes = pvMaxNormaux - pvmax;
          if (pvGagnes > 0) {
            updateCurrentBar(perso, 1, bar1 + pvGagnes, evt, pvMaxNormaux);
          }
        } else {
          let nouveauMalus = malus - valeur;
          let perteMod = Math.floor(nouveauMalus / 2);
          if (nouveauMalus % 2 == 1) {
            if (constitution === undefined)
              constitution = caracNormale(perso, 'constitution');
            if (constitution % 2 == 0) perteMod++;
          }
          let niveau = ficheAttributeAsInt(perso, 'niveau', 1);
          let pvPerdus = niveau * perteMod;
          let nouveauPVMax = pvMaxNormaux - pvPerdus;
          if (nouveauPVMax > pvmax) {
            bar1 += nouveauPVMax - pvmax;
            pvmax = nouveauPVMax;
            updateCurrentBar(perso, 1, bar1, evt, pvmax);
          }
        }
      } else if (valeur == malus) {
        //Au cas o\xF9, on v\xE9rifie le pv max
        let pvMaxNormaux = attributeAsInt(perso, 'pvMaxNormaux', 0);
        if (pvMaxNormaux > 0) {
          let pvmax = parseInt(perso.token.get("bar1_max"));
          if (pvmax < pvMaxNormaux) {
            let bar1 = parseInt(perso.token.get("bar1_value"));
            updateCurrentBar(perso, 1, bar1 + pvMaxNormaux - pvmax, evt, pvMaxNormaux);
          }
          removeTokenAttr(perso, 'pvMaxNormaux', evt);
        }
      }
    }
  }

  function parseNouveauJour(msg) {
    let options = parseOptions(msg);
    getSelected(msg, function(selection, playerId) {
      options.playerId = playerId;
      if (selection.length === 0) {
        var pageId = getPageId(playerId);
        var tokens =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            layer: 'objects',
            _pageid: pageId
          });
        tokens.forEach(function(tok) {
          if (tok.get('represents') === '') return;
          selection.push({
            _id: tok.id
          });
        });
      }
      var persos = [];
      iterSelected(selection, function(perso) {
        persos.push(perso);
      });
      doNouveauJour(persos, options);
    }, options);
  }

  function doNouveauJour(persos, options) {
    var evt = {
      type: "nouveauJour",
      attributes: [],
      action: {
        persos: persos,
        options: options
      }
    };
    addEvent(evt);
    var fromMsg = 'player|' + options.playerId;
    var player = getObj('player', options.playerId);
    if (player) {
      var speaksAs = player.get('speakingas');
      if (speaksAs !== '') fromMsg = speaksAs;
    }
    sendChat(fromMsg, "Un nouveau jour se l\xE8ve");
    if (stateCOF.combat) sortirDuCombat();
    jour(evt, options);
    if (options.repos) {
      recuperation(persos, true, options.playerId, evt, options);
    }
  }

  function parseRecuperer(msg) {
    if (stateCOF.combat) {
      sendPlayer(msg, "impossible de se reposer en combat");
      return;
    }
    let reposLong = false;
    if (msg.content.includes(' --reposLong')) reposLong = true;
    getSelected(msg, function(selection, playerId) {
      if (selection.length === 0) {
        sendPlayer(msg, "!cof-recuperer sans s\xE9lection de tokens", playerId);
        log("!cof-recuperer requiert des tokens s\xE9lectionn\xE9s");
        return;
      }
      var persos = [];
      iterSelected(selection, function(perso) {
        persos.push(perso);
      });
      doRecuperation(persos, reposLong, playerId);
    });
  }

  function doRecuperation(persos, reposLong, playerId, options) {
    const evt = {
      type: "recuperation",
      attributes: [],
      action: {
        persos: persos,
        reposLong: reposLong,
        playerId: playerId,
        options: options
      }
    };
    addEvent(evt);
    recuperation(persos, reposLong, playerId, evt, options);
  }

  let allCaracs = ['force', 'dexterite', 'constitution', 'intelligence', 'sagesse', 'charisme'];

  //Asynchrone (jets de d\xE9s)
  // ne rajoute pas evt \xE0 l'historique
  function recuperation(persos, reposLong, playerId, evt, options) {
    options = options || {};
    let manquePV = [];
    let ecuyers = [];
    let count = persos.length;
    let finalize = function() {
      count--;
      if (count === 0) {
        if (ecuyers.length > 0 && manquePV.length > 0) {
          soinsEcuyers(ecuyers, manquePV, playerId, evt);
        }
      }
    };
    persos.forEach(function(perso) {
      if (getState(perso, 'mort')) {
        finalize();
        return;
      }
      if (reposLong) {
        let attrEcuyerDe = findObjs({
          _type: 'attribute',
          _characterid: perso.charId,
          name: 'ecuyerDe'
        });
        if (attrEcuyerDe.length > 0) {
          ecuyers.push({
            perso: perso,
            ecuyerDe: attrEcuyerDe[0].get('current')
          });
        }
      }
      let token = perso.token;
      let charId = perso.charId;
      let character = getObj("character", charId);
      if (character === undefined) {
        finalize();
        return;
      }
      let pr = pointsDeRecuperation(perso);
      let bar2 = parseInt(token.get("bar2_value"));
      let manaAttr = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'PM'
      }, {
        caseInsensitive: true
      });
      let hasMana = false;
      let dmTemp = bar2;
      let estMook = token.get('bar1_link') === '';
      if (manaAttr.length > 0) { // R\xE9cup\xE9ration des points de mana
        var manaMax = parseInt(manaAttr[0].get('max'));
        hasMana = !isNaN(manaMax) && manaMax > 0;
        if (hasMana) {
          if (estMook) dmTemp = attributeAsInt(perso, 'DMTEMP', 0);
          else dmTemp = ficheAttributeAsInt(perso, 'DMTEMP', 0);
          if (reposLong && (isNaN(bar2) || bar2 < manaMax)) {
            updateCurrentBar(perso, 2, manaMax, evt);
          }
        }
      }
      if (!isNaN(dmTemp) && dmTemp > 0) { // r\xE9cup\xE9ration de DM temp
        if (reposLong) dmTemp = 0;
        else dmTemp = Math.max(0, dmTemp - 10);
        if (hasMana) {
          setTokenAttr(perso, 'DMTEMP', dmTemp, evt);
        } else {
          updateCurrentBar(perso, 2, dmTemp, evt);
        }
      }
      let bar1 = parseInt(token.get("bar1_value"));
      let pvmax = parseInt(token.get("bar1_max"));
      if (isNaN(bar1) || isNaN(pvmax)) {
        finalize();
        return;
      }
      if (bar1 >= pvmax && !reposLong) {
        //Plus rien \xE0 faire si pas un repos long
        sendPerso(perso, "n'a pas besoin de repos");
        finalize();
        return;
      }
      if (reposLong) {
        //R\xE9cup\xE9ration des affaiblissements de carac si repos long
        allCaracs.forEach(function(carac) {
          let malus = attributeAsInt(perso, 'affaiblissementde' + carac, 0);
          if (malus > 0) {
            diminueAffaiblissement(perso, carac, 1, evt, malus);
            sendPerso(perso, "r\xE9cup\xE8re un point de " + carac);
          }
        });
        if (bar1 >= pvmax && pr.current == pr.max) {
          finalize();
          return;
        }
        if (bar1 < pvmax && predicateAsBool(perso, 'montureMagique')) {
          //La monture magique r\xE9cup\xE8re tous ses PV durant la nuit
          updateCurrentBar(perso, 1, pvmax, evt);
          sendPerso(perso, "r\xE9cup\xE8re tous ses PV");
          finalize();
          return;
        }
      }
      //La r\xE9cup\xE9ration de PV ou de PR
      let dVie = ficheAttributeAsInt(perso, "DV", 0);
      if (dVie < 4) {
        if (bar1 < pvmax) manquePV.push(perso);
        finalize();
        return; //Si pas de d\xE9 de vie, alors pas de PR.
      }
      if (limiteRessources(perso, options, 'repos', 'repos', evt)) {
        if (bar1 < pvmax) manquePV.push(perso);
        finalize();
        return;
      }
      let message;
      if (reposLong && pr.current < pr.max) { // on r\xE9cup\xE8re un PR
        //Sauf si on a une blessure gave
        if (getState(perso, 'blesse')) {
          var testId = 'gu\xE9rir_blessure_' + perso.token.id;
          testCaracteristique(perso, 'CON', 8, testId, options, evt, function(tr) {
            sendPerso(perso, "fait un jet de CON pour gu\xE9rir de sa blessure");
            var m = "/direct " + onGenre(perso, 'Il', 'Elle') + " fait " + tr.texte;
            if (tr.reussite) {
              sendChar(charId, m + "&ge; 8, son \xE9tat s'am\xE9liore nettement." + tr.modifiers, true);
              setState(perso, 'blesse', false, evt);
            } else {
              var msgRate = m + "< 8, son \xE9tat reste pr\xE9occupant." + tr.rerolls + tr.modifiers;
              sendChar(charId, msgRate, true);
            }
            finalize();
          });
          return;
        }
        var affAttr = rajouterPointDeRecuperation(perso, evt);
        if (affAttr === undefined) {
          error("Pas de point de r\xE9cup\xE9rartion \xE0 rajouter et pourtant pas au max", token);
          finalize();
          return;
        }
        message =
          "Au cours de la nuit, les points de r\xE9cup\xE9ration de " + token.get('name') +
          " passent de " + pr.current + " \xE0 " + (pr.current + 1);
        sendChar(charId, message, true);
        if (bar1 < pvmax) manquePV.push(perso);
        finalize();
        return;
      }
      if (!reposLong) {
        if (pr.current === 0) { //pas possible de r\xE9cup\xE9rer
          message = " a besoin d'une nuit compl\xE8te pour r\xE9cup\xE9rer";
          sendPerso(perso, message);
          finalize();
          return;
        } else { //d\xE9pense d'un PR
          enleverPointDeRecuperation(perso, evt);
          pr.current--;
        }
      }
      let conMod = modCarac(perso, 'constitution');
      let niveau = ficheAttributeAsInt(perso, 'niveau', 1);
      let characterName = character.get("name");
      let rollExpr = addOrigin(characterName, "[[1d" + dVie + "]]");
      sendChat("COF", rollExpr, function(res) {
        let rollRecupID = "rollRecup_" + perso.token.id;
        options.rolls = options.rolls || {};
        var roll = options.rolls[rollRecupID] ? options.rolls[rollRecupID] : res[0].inlinerolls[0];
        evt.action = evt.action || {};
        evt.action.rolls = evt.action.rolls || {};
        evt.action.rolls[rollRecupID] = roll;
        var dVieRoll = roll.results.total;
        var bonus = conMod + niveau;
        var total = dVieRoll + bonus;
        if (total < 0) total = 0;
        if (bar1 === 0) {
          if (attributeAsBool(perso, 'etatExsangue')) {
            removeTokenAttr(perso, 'etatExsangue', evt, {
              msg: "retrouve des couleurs"
            });
          }
        }
        bar1 += total;
        if (bar1 < pvmax) manquePV.push(perso);
        else bar1 = pvmax;
        updateCurrentBar(perso, 1, bar1, evt);
        if (reposLong) {
          message = "Au cours de la nuit, ";
        } else {
          message = "Apr\xE8s 5 minutes de minutes de repos, ";
        }
        message +=
          "r\xE9cup\xE8re " + buildinline(roll) + "+" + bonus + " PV. Il lui reste " + pr.current + " points de r\xE9cup\xE9ration";
        sendPerso(perso, message);
        finalize();
      });
    });
  }

  function recharger(msg) {
    var cmd = msg.content.split(" ");
    if (cmd.length < 2) {
      error("La fonction !cof-recharger attend au moins un argument", msg);
      return;
    }
    var attackLabel = cmd[1];
    var evt = {
      type: 'recharger',
      attributes: []
    };
    var grenaille = false;
    if (msg.content.includes(' --grenaille')) grenaille = true;
    var options = {};
    if (msg.content.includes(' --son')) {
      options = parseOptions(msg);
      options = options || {};
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined) {
        sendPlayer(msg, "!cof-recharger sans s\xE9lection de tokens", playerId);
        log("!cof-recharger requiert des tokens s\xE9lectionn\xE9s");
        return;
      }
      iterSelected(selected, function(perso) {
        var weaponName = getAttackName(attackLabel, perso);
        if (weaponName === undefined) {
          error("Arme " + attackLabel + " n'existe pas pour " + perso.tokName, perso);
          return;
        }
        let maxCharge = predicateAsInt(perso, 'charge_' + attackLabel, 0, 1);
        let currentCharge = 0;
        let attrs =
          findObjs({
            _type: 'attribute',
            _characterid: perso.charId,
            name: "charge_" + attackLabel
          });
        if (attrs.length < 1) {
          attrs = createObj('attribute', {
            characterid: perso.charId,
            name: 'charge_' + attackLabel,
            current: 0
          });
        } else {
          attrs = attrs[0];
          currentCharge = parseInt(attrs.get('current'));
          if (isNaN(currentCharge)) {
            error("charge mal form\xE9e", attrs);
            currentCharge = 0;
          }
        }
        let attrGrenaille =
          findObjs({
            _type: 'attribute',
            _characterid: perso.charId,
            name: "chargeGrenaille_" + attackLabel
          });
        let currentChargeGrenaille;
        if (currentCharge < maxCharge) {
          if (grenaille) {
            if (attrGrenaille.length < 1) {
              attrGrenaille = createObj('attribute', {
                characterid: perso.charId,
                name: 'chargeGrenaille_' + attackLabel,
                current: 0
              });
            } else attrGrenaille = attrGrenaille[0];
            currentChargeGrenaille = parseInt(attrGrenaille.get('current'));
            if (isNaN(currentChargeGrenaille)) {
              error("charge de grenaille mal form\xE9e", attrGrenaille);
              return;
            }
            if (currentChargeGrenaille > currentCharge) currentChargeGrenaille = currentCharge;
            evt.attributes.push({
              attribute: attrGrenaille,
              current: currentChargeGrenaille
            });
            attrGrenaille.set('current', currentChargeGrenaille + 1);
          }
          evt.attributes.push({
            attribute: attrs,
            current: currentCharge
          });
          attrs.set('current', currentCharge + 1);
          updateNextInit(perso);
          if (options.son) playSound(options.son);
          if (grenaille)
            sendPerso(perso, "charge " + weaponName + " de grenaille.");
          else
            sendPerso(perso, "recharge " + weaponName);
          return;
        } else {
          if (grenaille) { //On peut vouloir changer des charges normales en grenaille
            if (attrGrenaille.length < 1) {
              attrGrenaille = createObj('attribute', {
                characterid: perso.charId,
                name: 'chargeGrenaille_' + attackLabel,
                current: 0
              });
            } else attrGrenaille = attrGrenaille[0];
            currentChargeGrenaille = parseInt(attrGrenaille.get('current'));
            if (isNaN(currentChargeGrenaille)) {
              error("charge de grenaille mal form\xE9e", attrGrenaille);
              return;
            }
            if (currentChargeGrenaille < currentCharge) {
              evt.attributes.push({
                attribute: attrGrenaille,
                current: currentChargeGrenaille
              });
              attrGrenaille.set('current', currentChargeGrenaille + 1);
              sendPerso(perso, "remplace une charge de " + weaponName + " par de la grenaille.");
              return;
            }
          } else if (attrGrenaille.length > 0) {
            attrGrenaille = attrGrenaille[0];
            currentChargeGrenaille = parseInt(attrGrenaille.get('current'));
            if (isNaN(currentChargeGrenaille)) {
              error("charge de grenaille mal form\xE9e", attrGrenaille);
              return;
            }
            if (currentChargeGrenaille > 0) {
              evt.attributes.push({
                attribute: attrGrenaille,
                current: currentChargeGrenaille
              });
              attrGrenaille.set('current', currentChargeGrenaille - 1);
              sendPerso(perso, "remplace une charge de grenaille  de " + weaponName + " par une charge normale.");
              return;
            }
          }
        }
        if (maxCharge == 1) {
          sendPerso(perso, weaponName + " est d\xE9j\xE0 charg\xE9");
        } else {
          sendPerso(perso, "a d\xE9j\xE0 tous ses " + weaponName + " charg\xE9s");
        }
      });
    });
    addEvent(evt);
  }

  //!cof-bouton-chance [evt.id] [rollId]
  function boutonChance(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-bouton-chance n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    var action = evt.action;
    if (!action) {
      error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
      return;
    }
    var perso = evt.personnage;
    var rollId;
    if (args.length > 2) {
      var roll = action.rolls[args[2]];
      if (roll === undefined) {
        error("Erreur interne du bouton de chance : roll non identifi\xE9", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de chance : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[2];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de chance : l'\xE9venement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var chance = pointsDeChance(perso);
    if (chance <= 0) {
      sendPerso(perso, "n'a plus de point de chance \xE0 d\xE9penser...");
      return;
    }
    var evtChance = {
      type: 'chance',
      rollId: rollId
    };
    chance--;
    undoEvent(evt);
    setFicheAttr(perso, 'pc', chance, evtChance, {
      msg: " a d\xE9pens\xE9 un point de chance. Il lui en reste " + chance
    });
    action.options = action.options || {};
    if (rollId) {
      action.options.chanceRollId = action.options.chanceRollId || {};
      action.options.chanceRollId[rollId] = (action.options.chanceRollId[rollId] + 10) || 10;
    } else {
      action.options.chance = (action.options.chance + 10) || 10;
    }
    if (!redoEvent(evt, action, perso))
      error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
    addEvent(evtChance);
  }

  //!cof-prouesse [evt.id] [rollId]
  function boutonProuesse(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-prouesse n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    var perso = evt.personnage;
    var rollId;
    if (args.length > 2) {
      if (!evt.action) {
        error("Le dernier \xE9v\xE8nement n'est pas une action", args);
        return;
      }
      var roll = evt.action.rolls[args[2]];
      if (roll === undefined) {
        error("Erreur interne du bouton de chance : roll non identifi\xE9", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de prouesse : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[2];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de prouesse : l'\xE9venement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let testProuesse = testLimiteUtilisationsCapa(perso, 'prouesse', 'tour', "ne peut plus utiliser sa prouesse");
    if (testProuesse === undefined) {
      return;
    }
    var action = evt.action;
    if (action) { //alors on peut faire le undo
      var options = evt.action.options || {};
      options.rolls = action.rolls || {};
      undoEvent(evt);
      var d4 = rollDePlus(4);
      var r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      var evtProuesse = {
        type: 'prouesse',
        rollId: rollId,
        action: {
          rolls: {
            "prouesseDmg": d4
          }
        }
      };
      addEvent(evtProuesse);
      let explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtProuesse, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendPerso(perso, "r\xE9alise une prouesse et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendPerso(perso, expl);
          });
        });
      utiliseCapacite(perso, testProuesse, evt);
      if (rollId) {
        options.chanceRollId = options.chanceRollId || {};
        options.chanceRollId[rollId] = (options.chanceRollId[rollId] + 5) || 5;
      } else {
        options.chance = (options.chance + 10) || 10;
      }
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
  }

  //!cof-pacte-sanglant [evt.id] [3|5] [rollId]
  function boutonPacteSanglant(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("La fonction !cof-pacte-sanglant n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    var bonus = parseInt(args[2]);
    if (isNaN(bonus)) {
      error("Il manque un choix de bonus au Pacte sanglant", args);
      return;
    }
    var perso = evt.personnage;
    var rollId;
    if (args.length > 3) {
      if (!evt.action) {
        error("Le dernier \xE9v\xE8nement n'est pas une action", args);
        return;
      }
      var roll = evt.action.rolls[args[3]];
      if (roll === undefined) {
        error("Erreur interne du bouton de pacte sanglant : roll non identifi\xE9", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de pacte sanglant : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[3];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de pacte sanglant : l'\xE9venement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let valPacteSanglant = predicateAsInt(perso, 'pacteSanglant', 0);
    if (valPacteSanglant < bonus) {
      sendPerso(perso, "ne peut pas faire \xE7a !");
      return;
    }
    let action = evt.action;
    if (action) { //alors on peut faire le undo
      let options = action.options || {};
      undoEvent(evt);
      let d4 = (bonus < 5) ? rollDePlus(4) : rollDePlus(4, {
        nbDes: 2
      });
      let r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      let evtPacteSanglant = {
        type: 'pacteSanglant',
        rollId: rollId,
        action: {
          rolls: {
            "pacteSanglantDmg": d4
          }
        }
      };
      addEvent(evtPacteSanglant);
      let explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtPacteSanglant, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendPerso(perso, "r\xE9alise un Pacte sanglant et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendPerso(perso, expl);
          });
        });
      if (rollId) {
        options.chanceRollId = options.chanceRollId || {};
        options.chanceRollId[rollId] = (options.chanceRollId[rollId] + bonus) || bonus;
      } else {
        options.chance = (options.chance + bonus) || bonus;
      }
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
  }

  //!cof-pacte-sanglant [evt.id] [3|5] [targetId]
  function boutonPacteSanglantDef(msg) {
    var args = msg.content.split(' ');
    if (args.length < 4) {
      error("La fonction !cof-pacte-sanglant-def n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    if (!evt.action) {
      error("Le dernier \xE9v\xE8nement n'est pas une action", args);
      return;
    }
    let bonus = parseInt(args[2]);
    if (isNaN(bonus)) {
      error("Il manque un choix de bonus au Pacte sanglant", args);
      return;
    }
    let perso = persoOfId([args[3]]);
    if (perso === undefined) {
      error("Erreur interne du bouton de pacte sanglant (DEF) : pas de cible trouv\xE9e", args);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let valPacteSanglant = predicateAsInt(perso, 'pacteSanglant', 0);
    if (valPacteSanglant < bonus) {
      sendPerso(perso, "ne peut pas faire \xE7a !");
      return;
    }
    let action = evt.action;
    if (action) { //alors on peut faire le undo
      let options = action.options || {};
      undoEvent(evt);
      let d4 = (bonus < 5) ? rollDePlus(4) : rollDePlus(4, {
        nbDes: 2
      });
      let r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      let evtPacteSanglant = {
        type: 'pacteSanglantDEF',
        action: {
          rolls: {
            "pacteSanglantDmg": d4
          }
        }
      };
      addEvent(evtPacteSanglant);
      let explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtPacteSanglant, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendPerso(perso, "r\xE9alise un Pacte sanglant et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendPerso(perso, expl);
          });
        });
      options.pacteSanglantDef = options.pacteSanglantDef || {};
      options.pacteSanglantDef[perso.token.id] = (options.pacteSanglantDef[perso.token.id] + bonus) || bonus;
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
  }

  //!cof-tour-force [evt.id] [rollId]
  function boutonTourDeForce(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-tour-force n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    var perso = evt.personnage;
    var rollId;
    if (args.length > 2) {
      if (!evt.action) {
        error("Le dernier \xE9v\xE8nement n'est pas une action", args);
        return;
      }
      var roll = evt.action.rolls[args[2]];
      if (roll === undefined) {
        error("Erreur interne du bouton de tour de force : roll non identifi\xE9", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de tour de force : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[2];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de tour de force : l'\xE9venement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var attrTourDeForce = predicateAsBool(perso, 'tourDeForce');
    if (!attrTourDeForce) {
      sendPerso(perso, "ne peut pas faire \xE7a !");
      return;
    }
    var action = evt.action;
    if (action) { //alors on peut faire le undo
      var options = action.options || {};
      undoEvent(evt);
      var d4 = rollDePlus(4);
      var r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      var evtTourDeForce = {
        type: 'tourDeForce',
        rollId: rollId,
        action: {
          rolls: {
            "tourDeForceDmg": d4
          }
        }
      };
      addEvent(evtTourDeForce);
      let explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtTourDeForce, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendPerso(perso, "r\xE9alise un Tour de force et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendPerso(perso, expl);
          });
        });
      if (rollId) {
        options.chanceRollId = options.chanceRollId || {};
        options.chanceRollId[rollId] = (options.chanceRollId[rollId] + 10) || 10;
      } else {
        options.chance = (options.chance + 10) || 10;
      }
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
  }

  //Renvoie true si redo possible, false sinon
  function redoEvent(evt, action, perso) {
    let options = action.options || {};
    options.rolls = action.rolls;
    options.choices = action.choices;
    switch (evt.type) {
      case 'Attaque':
        options.redo = true;
        if (action.cibles) {
          action.cibles.forEach(function(target) {
            delete target.partialSaveAuto;
            delete target.dmRate;
          });
        }
        attack(action.playerName, action.playerId, action.attaquant, action.cibles, action.weaponStats, options);
        return true;
      case 'attaqueMagique':
        attaqueMagiqueOpposee(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'armeSecrete':
        doArmeSecrete(action.perso, action.cible, options);
        return true;
      case 'boireAlcool':
        doBoireAlcool(action.playerId, action.persos, options);
        return true;
      case 'dmgDirects':
        dmgDirects(action.playerId, action.playerName, action.cibles, action.dmg, options);
        return true;
      case 'degainer':
        doDegainer(action.persos, action.armeLabel, options);
        return true;
      case 'destructionMortsVivants':
        doDestructionDesMortsVivants(action.lanceur, action.playerName, action.dm, options);
        return true;
      case 'echapperEtreinte':
      case 'echapperEnveloppement':
        doEchapperEnveloppement(action.perso, action.etreinte, action.cube, action.difficulte, options);
        return true;
      case 'effetTemp':
        effetTemporaire(action.playerId, action.cibles, action.effet, action.mEffet, action.duree, options);
        return true;
      case 'enduireDePoison':
        doEnduireDePoison(action.perso, action.armeEnduite, action.savePoison, action.forcePoison, action.attribut,
          action.testINT, action.infosAdditionelles, options);
        return true;
      case 'enveloppement':
      case '\xE9treinte':
        doEnveloppement(action.attaquant, action.cible, action.difficulte, action.type, action.exprDM, options);
        return true;
      case 'injonction':
        injonction(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'injonctionMortelle':
        injonctionMortelle(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'jetPerso':
        jetPerso(perso, action.caracteristique, action.difficulte, action.titre, action.playerId, options);
        return true;
      case 'libererAgrippe':
        doLibererAgrippe(action.perso, action.agrippant, action.attrName, options);
        return true;
      case 'natureNourriciere':
        doNatureNourriciere(action.perso, options);
        return true;
      case 'nextTurn':
        let turnOrder = Campaign().get("turnorder");
        if (turnOrder === '') return false; // nothing in the turn order
        turnOrder = JSON.parse(turnOrder);
        if (turnOrder.length < 1) return false; // Juste le compteur de tour
        var lastTurn = turnOrder.shift();
        turnOrder.push(lastTurn);
        Campaign().set("turnorder", JSON.stringify(turnOrder));
        nextTurn(Campaign(), options);
        return true;
      case 'nouveauJour':
        doNouveauJour(action.persos, options);
        return true;
      case 'peur':
        doPeur(action.cibles, action.difficulte, action.duree, options);
        return true;
      case 'provocation':
        doProvocation(action.voleur, action.cible, options);
        return true;
      case 'rage':
        doRageDuBerserk(action.persos, action.typeRage, options);
        return true;
      case 'recuperation':
        doRecuperation(action.persos, action.reposLong, action.playerId, options);
        return true;
      case 'save_state':
        doSaveState(action.playerId, action.perso, action.etat, action.carac, options, action.opposant, action.seuil);
        return true;
      case 'set_state':
        doSetState(action.cibles, action.etat, action.valeur, options);
        return true;
      case 'sommeil':
        doSommeil(action.lanceur, action.cibles, options, action.ciblesSansSave, action.ciblesAvecSave);
        return true;
      case 'surprise':
        doSurprise(action.cibles, action.testSurprise, action.selected, options);
        return true;
      case 'tourDeForce': //Deprecated
        doTourDeForce(action.perso, action.seuil, options);
        return true;
      case 'tueurFantasmagorique':
        tueurFantasmagorique(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'vapeursEthyliques':
        doVapeursEthyliques(action.playerId, action.persos, options);
        return true;
      case 'ombre_mouvante':
        doOmbreMouvante(action.perso, action.playerId, options);
        return true;
      default:
        return false;
    }
  }

  function echecTotal(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-bouton-echec-total n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    var perso = evt.personnage;
    if (perso === undefined) {
      error("Erreur interne du bouton d'\xE9chec total: l'\xE9venement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var action = evt.action;
    if (!action || evt.type != "Attaque") {
      error("Erreur interne du bouton d'\xE9chec total: l'\xE9v\xE8nement n'est pas une attaque", evt);
      return;
    }
    var evtEchecTotal = {
      type: 'echecTotal'
    };
    addEvent(evtEchecTotal);
    // Attaquer avec les m\xEAmes options, vider redo et preDmg \xE9ventuels
    var options = action.options;
    options.auto = true;
    options.echecTotal = true;
    delete options.redo;
    delete options.preDmg;
    attack(action.playerName, action.playerId, perso, perso.token, action.weaponStats, options);
  }

  function persoUtiliseDeExpertDuCombat(perso, evt) {
    let rangExpertDuCombat = predicateAsInt(perso, 'expertDuCombat', 0);
    if (rangExpertDuCombat < 1) {
      sendPerso(perso, "n'est pas un expert du combat");
      return false;
    }
    let limiteParTour;
    if (rangExpertDuCombat > 4) limiteParTour = 3;
    else if (rangExpertDuCombat > 2) limiteParTour = 2;
    else limiteParTour = 1;
    if (limiteRessources(perso, {
        limiteParCombat: rangExpertDuCombat * 2,
        limiteParTour: limiteParTour
      }, "expertDuCombat", "a atteint sa limite de d\xE9 d'expert du combat", evt)) {
      addEvent(evt);
      return false;
    }
    sendPerso(perso, "utilise un d\xE9 d'expert du combat");
    return true;
  }

  //!cof-expert-combat
  //!cof-expert-combat-touche
  //!cof-expert-combat-dm
  function expertDuCombat(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser les d\xE9s d'expert du combat qu'en combat");
      return;
    }
    var cmd = msg.content.split(' ');
    var evtARefaire;
    var evt = {
      type: "D\xE9 d'expert du combat (touche)",
      attributes: []
    };
    if (cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[1]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
      var perso = evtARefaire.personnage;
      var action = evtARefaire.action;
      if (action === undefined) {
        error("Impossible de relancer l'action", evtARefaire);
        return;
      }
      if (perso === undefined) {
        error("Erreur interne du bouton expert de combat : l'\xE9venement n'a pas de personnage", evtARefaire);
        return;
      }
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "pas le droit d'utiliser ce bouton");
        return;
      }
      if (!persoUtiliseDeExpertDuCombat(perso, evt)) return;
      undoEvent(evtARefaire);
      addEvent(evt);
      action.options = action.options || {};
      if (cmd[0].includes("-touche"))
        action.options.expertDuCombatTouche = action.options.expertDuCombatTouche + 1 || 1;
      else if (cmd[0].includes("-dm"))
        action.options.expertDuCombatDM = action.options.expertDuCombatDM + 1 || 1;
      if (!redoEvent(evtARefaire, action, perso))
        error("Type d'\xE9v\xE8nement pas support\xE9 par le bouton Rune d'Energie", evt);
    } else { //Juste pour v\xE9rifier l'attribut et le diminuer
      getSelected(msg, function(selection) {
        if (selection.length === 0) {
          sendPlayer(msg, 'Pas de token s\xE9lectionn\xE9 pour !cof-bouton-expert-combat-touche');
          return;
        }
        iterSelected(selection, function(perso) {
          persoUtiliseDeExpertDuCombat(perso, evt);
        }); //fin iterSelected
        addEvent(evt);
      }); //fin getSelected
    }
  }

  //!cof-expert-combat-def [evt.id] [targetId]
  function expertDuCombatDEF(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("La fonction !cof-expert-combat-def n'a pas assez d'arguments", args);
      return;
    }
    var evtARefaire = findEvent(args[1]);
    if (evtARefaire === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    var action = evtARefaire.action;
    if (action === undefined) {
      error("Le dernier \xE9v\xE8nement n'est pas une action", args);
      return;
    }
    var perso = persoOfId([args[2]]);
    if (perso === undefined) {
      error("Erreur interne du bouton d'expert du combat (DEF) : pas de cible trouv\xE9e", args);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var evt = {
      type: 'expertDuCombatDEF',
    };
    if (!persoUtiliseDeExpertDuCombat(perso, evt)) return;
    undoEvent(evtARefaire);
    addEvent(evt);
    action.options = action.options || {};
    action.options.expertDuCombatDEF = action.options.expertDuCombatDEF || {};
    action.options.expertDuCombatDEF[perso.token.id] = rollDePlus(6);
    removePreDmg(action.options, perso, 'expertDuCombatDEF');
    redoEvent(evtARefaire, action);
  }

  function persoUtiliseRuneEnergie(perso, evt) {
    var attr = tokenAttribute(perso, 'runeForgesort_\xE9nergie');
    if (attr.length < 1 || attr[0].get('current') < 1) {
      sendPerso(perso, "n'a pas de rune d'\xE9nergie");
      return false;
    }
    if (limiteRessources(perso, {
        limiteParCombat: 1
      }, "runeForgesort_\xE9nergie", "a d\xE9j\xE0 utilis\xE9 sa rune d'\xE9nergie durant ce combat", evt)) {
      addEvent(evt);
      return false;
    }
    sendPerso(perso, "utilise sa rune d'\xE9nergie pour relancer un d20 sur un test d'attaque, de FOR, DEX ou CON");
    return true;
  }

  //!cof-bouton-rune-energie
  function runeEnergie(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser les runes d'\xE9nergie qu'en combat");
      return;
    }
    var cmd = msg.content.split(' ');
    var evtARefaire;
    var evt = {
      type: "Rune d'\xE9nergie",
      attributes: []
    };
    if (cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[1]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
      var perso = evtARefaire.personnage;
      var action = evtARefaire.action;
      if (action === undefined) {
        error("Impossible de relancer l'action", evtARefaire);
        return;
      }
      var rollId;
      if (cmd.length > 2) {
        var roll = action.rolls[cmd[2]];
        if (roll === undefined) {
          error("Erreur interne du bouton de chance : roll non identifi\xE9", cmd);
          return;
        }
        if (roll.token === undefined) {
          error("Erreur interne du bouton de chance : roll sans token", cmd);
          return;
        }
        perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
        rollId = cmd[2];
        evt.rollId = rollId;
      }
      if (perso === undefined) {
        error("Erreur interne du bouton de rune d'\xE9nergie : l'\xE9venement n'a pas de personnage", evtARefaire);
        return;
      }
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "pas le droit d'utiliser ce bouton");
        return;
      }
      var carac = action.caracteristque;
      if (carac == 'SAG' || carac == 'INT' || carac == 'CHA') {
        sendPerso(perso, "ne peut pas utiliser la rune d'\xE9nergie pour un test de " + carac);
        return;
      }
      if (!persoUtiliseRuneEnergie(perso, evt)) return;
      undoEvent(evtARefaire);
      addEvent(evt);
      if (rollId) delete action.rolls[rollId];
      else if (action.rolls && action.rolls.attack) delete action.rolls.attack;
      if (!redoEvent(evtARefaire, action, perso))
        error("Type d'\xE9v\xE8nement pas support\xE9 par le bouton Rune d'Energie", evt);
    } else { //Juste pour v\xE9rifier l'attribut et le diminuer
      getSelected(msg, function(selection) {
        if (selection.length === 0) {
          sendPlayer(msg, 'Pas de token s\xE9lectionn\xE9 pour !cof-rune-energie');
          return;
        }
        iterSelected(selection, function(perso) {
          persoUtiliseRuneEnergie(perso, evt);
        }); //fin iterSelected
        addEvent(evt);
      }); //fin getSelected
    }
  }

  function persoUtiliseRunePuissance(perso, labelArme, evt, permanent) {
    var attrName = permanent ? 'runeDePuissance' + labelArme : "runeForgesort_puissance(" + labelArme + ")";
    var arme = getAttackName(labelArme, perso);
    if (arme === undefined) {
      error(perso.tokNname + " n'a pas d'arme associ\xE9e au label " + labelArme, perso);
      return false;
    }
    if (!permanent && tokenAttribute(perso, attrName).length === 0) {
      sendPerso(perso, "n'a pas de rune de puissance sur " + arme);
      return false;
    }
    if (limiteRessources(perso, {
        limiteParCombat: 1
      }, attrName, "a d\xE9j\xE0 utilis\xE9 sa rune de puissance durant ce combat", evt)) {
      addEvent(evt);
      return false;
    }
    sendPerso(perso, "utilise sa rune de puissance pour obtenir les DM maximum de son arme");
    return true;
  }

  //!cof-rune-puissance label
  //!cof-bouton-rune-puissance label evt.id [permanent]
  function runePuissance(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser les runes de puissance qu'en combat");
      return;
    }
    let cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il faut sp\xE9cifier le label de l'arme sur laquelle la rune de puissance est inscrite", cmd);
      return;
    }
    let labelArme = cmd[1];
    let evtARefaire;
    let evt = {
      type: "Rune de puissance",
      attributes: []
    };
    if (cmd.length > 2) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[2]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
      let perso = evtARefaire.personnage;
      if (perso === undefined) {
        error("Erreur interne du bouton de rune de puissance : l'\xE9venement n'a pas de personnage", evtARefaire);
        return;
      }
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "pas le droit d'utiliser ce bouton");
        return;
      }
      let action = evtARefaire.action;
      if (action === undefined) {
        error("Impossible de relancer l'action", evtARefaire);
        return;
      }
      let permanent = (cmd.length > 3 && cmd[3] == 'permanent');
      if (!persoUtiliseRunePuissance(perso, labelArme, evt, permanent)) return;
      let options = action.options || {};
      options.redo = true;
      options.maxDmg = true;
      options.runeDePuissance = true;
      options.rolls = action.rolls;
      action.cibles.forEach(function(target) {
        delete target.rollsDmg;
      });
      delete options.preDmg.runeDePuissance;
      if (_.isEmpty(options.preDmg)) delete options.preDmg;
      addEvent(evt);
      switch (evtARefaire.type) {
        case 'Attaque':
          undoEvent(evtARefaire);
          attack(action.playerName, action.playerId, perso, action.cibles, action.weaponStats, options);
          return;
        default:
          return;
      }
    } else { //Juste pour v\xE9rifier l'attribut et le diminuer
      getSelected(msg, function(selection, playerId) {
        if (selection.length === 0) {
          sendPlayer(msg, 'Pas de token s\xE9lectionn\xE9 pour !cof-rune-puissance', playerId);
          return;
        }
        iterSelected(selection, function(perso) {
          persoUtiliseRunePuissance(perso, labelArme, evt);
        }); //fin iterSelected
        addEvent(evt);
      }); //fin getSelected
    }
  }

  //!cof-bouton-pousser-kiai evt.id
  function kiai(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut pousser un kiai qu'en combat");
      return;
    }
    var cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il manque l'id de l'attaque sur laquelle pousser le kiai", cmd);
      return;
    }
    var evtARefaire = findEvent(cmd[1]);
    if (evtARefaire === undefined) {
      error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
      return;
    }
    var perso = evtARefaire.personnage;
    if (perso === undefined) {
      error("Erreur interne du bouton de kiai : l'\xE9venement n'a pas de personnage", evtARefaire);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var action = evtARefaire.action;
    if (action === undefined) {
      error("Impossible de relancer l'action", evtARefaire);
      return;
    }
    let testKiai = testLimiteUtilisationsCapa(perso, 'kiai', 'combat', "ne peut plus pousser de kiai pendant ce combat", "ne sait pas pousser de kiai");
    if (testKiai === undefined) {
      return;
    }
    var evt = {
      type: "Kiai",
    };
    utiliseCapacite(perso, testKiai, evt);
    if (testKiai.utilisations > 1) {
      setAttrDuree(perso, 'rechargeDuKiai', randomInteger(6), evt);
    }
    var options = action.options || {};
    options.redo = true;
    options.maxDmg = true;
    options.rolls = action.rolls;
    action.cibles.forEach(function(target) {
      delete target.rollsDmg;
    });
    addEvent(evt);
    switch (evtARefaire.type) {
      case 'Attaque':
        undoEvent(evtARefaire);
        attack(action.playerName, action.playerId, perso, action.cibles, action.weaponStats, options);
        return;
      default:
        return;
    }
  }

  //Devrait \xEAtre appel\xE9 seulement depuis un bouton
  //!cof-esquive-fatale evtid target_id
  function doEsquiveFatale(msg) {
    var cmd = msg.content.split(' ');
    var evtARefaire;
    var evt = {
      type: "Esquive fatale",
      attributes: []
    };
    if (cmd.length < 3) {
      error("Il manque des arguments \xE0 !cof-esquive-fatale", cmd);
      return;
    }
    evtARefaire = findEvent(cmd[1]);
    if (evtARefaire === undefined) {
      error("L'attaque est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
      return;
    }
    var action = evtARefaire.action;
    if (action === undefined) {
      error("Impossible d'esquiver l'attaque", evtARefaire);
      return;
    }
    var perso = action.cibles[0];
    if (perso === undefined) {
      error("Erreur interne du bouton de 'esquive fatale : l'\xE9venement n'a pas de personnage", evtARefaire);
      return;
    }
    var adversaire = persoOfId(cmd[2]);
    if (adversaire === undefined) {
      sendPlayer(msg, "Il faut cibler un token valide");
      return;
    }
    var attaquant = action.attaquant;
    if (attaquant.token.id == adversaire.token.id) {
      sendPlayer(msg, "Il faut cibler un autre adversaire que l'attaquant");
      return;
    }
    if (distanceCombat(perso.token, adversaire.token) > 0) {
      sendPerso(perso, "doit choisir un adversaire au contact pour l'esquive fatale");
      return;
    }
    var ennemisAuContact = perso.ennemisAuContact;
    if (ennemisAuContact === undefined) {
      error("Ennemis au contact non d\xE9finis", perso);
    } else {
      var i = ennemisAuContact.find(function(tok) {
        return (tok.id == adversaire.token.id);
      });
      if (i === undefined) {
        sendPlayer(msg, "Il faut cibler un adversaire au contact pour l'esquive fatale");
        return;
      }
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let testEsquiveFatale = testLimiteUtilisationsCapa(perso, 'esquiveFatale', 'combat', "a d\xE9j\xE0 fait une esquive fatale durant ce combat", "ne sait pas faire d'esquive fatale");
    if (testEsquiveFatale === undefined) {
      return;
    }
    adversaire.tokName = adversaire.token.get('name');
    utiliseCapacite(perso, testEsquiveFatale, evt);
    //On va refaire compl\xE8tement l'attaque
    undoEvent(evtARefaire);
    addEvent(evt);
    adversaire.msgEsquiveFatale = perso.tokName + " esquive l'attaque qui touche " + adversaire.tokName;
    action.cibles = action.cibles.filter(cible => cible.token.id !== perso.token.id);
    action.cibles.push(adversaire);
    removePreDmg(action.options, perso);
    redoEvent(evtARefaire, action);
  }

  //Soit juste !cof-intercepter (en s\xE9lectionnant le chevalier)
  //Soit depuis un bouton !cof-intercepter evtid cibleid
  function intercepter(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    let fromEvtId;
    if (cmd.length > 1) {
      fromEvtId = cmd[1]; //Appel depuis le bouton
      if (cmd.length < 3) {
        error("Bouton d'interception mal form\xE9", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(chevalier) {
        let character = getObj('character', chevalier.charId);
        if (character === undefined) {
          error("L'argument de !cof-intercepter n'est pas une id de token valide (personnage non d\xE9fini)", msg.content);
          return;
        }
        let test = testLimiteUtilisationsCapa(chevalier, 'intercepter', 'tour', "a d\xE9j\xE0 intercept\xE9 une attaque ce tour", "ne sait pas utiliser intercepter les attaques");
        if (test === undefined) {
          return;
        }
        let voieMeneur = predicateAsInt(chevalier, 'voieDuMeneurDHomme', 2);
        let attaque;
        let originalTarget;
        let evtARefaire;
        if (fromEvtId) { //On a utilis\xE9 un bouton
          if (!peutController(msg, chevalier)) {
            sendPlayer(msg, "pas le droit d'utiliser ce bouton");
            return;
          }
          evtARefaire = findEvent(fromEvtId);
          if (evtARefaire !== undefined) {
            attaque = evtARefaire.action;
          }
          if (attaque === undefined) {
            sendPlayer(msg, "Plus possible d'utiliser ce bouton");
            return;
          }
          attaque.cibles = attaque.cibles.filter(function(c) {
            if (originalTarget) return true;
            if (c.token.id != cmd[2]) return true;
            originalTarget = c;
            return false;
          });
          if (originalTarget === undefined) {
            if (attaque.cibles.length === 1) {
              originalTarget = attaque.cibles[0];
              attaque.cibles = [];
            } else {
              error("Impossible de retrouver la cible de l'attaque", attaque);
              return;
            }
          }
        } else {
          evtARefaire = lastEvent();
          if (evtARefaire !== undefined) {
            attaque = evtARefaire.action;
          }
          if (attaque === undefined) {
            sendPlayer(msg, "La derni\xE8re action trouv\xE9e n'est pas une attaque, impossible d'intercepter");
            return;
          }
          if (attaque.cibles.length === 0) {
            sendPlayer(msg, "la derni\xE8re attaque n'a touch\xE9 aucune cible, impossible d'intercepter");
            return;
          }
          if (attaque.cibles.length > 1) {
            sendPlayer(msg, "la derni\xE8re attaque a touch\xE9 plus d'une cible, impossible d'intercepter");
            return;
          }
          originalTarget = attaque.cibles[0];
          attaque.cibles = [];
          if (distanceCombat(chevalier.token, originalTarget.token) > 0) {
            sendPerso(chevalier, " est trop loin de " + originalTarget.token.get('name') + " pour intercepter l'attaque");
            return;
          }
        }
        let evt = {
          type: 'interception'
        };
        utiliseCapacite(chevalier, test, evt);
        attaque.cibles.push(chevalier);
        chevalier.rollDmg = chevalier.rollDmg;
        chevalier.tokName = chevalier.token.get('name');
        chevalier.intercepter = voieMeneur;
        let optionsRedo = attaque.options;
        optionsRedo.rolls = attaque.rolls;
        undoEvent(evtARefaire);
        addEvent(evt);
        removePreDmg(attaque.options, originalTarget);
        redoEvent(evtARefaire, attaque);
      });
    });
  }

  //simplement prendre les DM \xE0 la place d'un autre
  function interposer(msg) {
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(cible) {
        var charId = cible.charId;
        var character = getObj('character', charId);
        if (character === undefined) {
          error("L'argument de !cof-interposer n'est pas une id de token valide (personnage non d\xE9fini)", msg.content);
          return;
        }
        cible.tokName = cible.token.get('name');
        cible.name = character.get('name');
        if (attributeAsBool(cible, 'interposer')) {
          sendPerso(cible, " a d\xE9j\xE0 intercept\xE9 une attaque ce tour");
          return;
        }
        var attaque;
        var lastAct = lastEvent();
        if (lastAct !== undefined) {
          attaque = lastAct.action;
        }
        if (attaque === undefined) {
          sendPlayer(msg, "la derni\xE8re action trouv\xE9e n'est pas une attaque, impossible d'intercepter");
          return;
        }
        if (attaque.cibles.length === 0) {
          sendPlayer(msg, "la derni\xE8re attaque n'a touch\xE9 aucune cible, impossible de s'interposer");
          return;
        }
        if (attaque.cibles.length > 1) {
          sendPlayer(msg, "la derni\xE8re attaque a touch\xE9 plus d'une cible, impossible de s'interposer en utilisant le script");
          return;
        }
        var target = attaque.cibles[0];
        var targetName = target.tokName;
        if (targetName === undefined) {
          error("Le token de la derni\xE8re attaque est ind\xE9fini", attaque);
          return;
        }
        if (distanceCombat(cible.token, target.token) > 0) {
          sendPerso(cible, " est trop loin de " + targetName + " pour s'interposer");
          return;
        }
        var evt = {
          type: 'interposer'
        };
        setTokenAttr(cible, 'interposer', true, evt, {
          msg: "se met devant " + targetName + " pour intercepter l'attaque !"
        });
        var pvApres = target.token.get('bar1_value');
        // On annule l'ancienne action
        undoEvent();
        // On calcule ensuite les pv perdus, et on les applique au d\xE9fenseur
        var pvPerdus = target.token.get('bar1_value') - pvApres;
        // Puis on refait en changeant la cible
        var options = attaque.options;
        options.interposer = pvPerdus;
        options.rolls = attaque.rolls;
        options.evt = evt;
        options.redo = true;
        cible.rollsDmg = target.rollsDmg;
        attack(attaque.playerName, attaque.playerId, attaque.attaquant, [cible], attaque.weaponStats, options);
      });
    });
  }

  function exemplaire(msg) {
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(cible) {
        if (attributeAsBool(cible, 'exemplaire')) {
          sendPerso(cible, " a d\xE9j\xE0 montr\xE9 l'exemple \xE0 ce tour");
          return;
        }
        var attaque;
        var lastAct = lastEvent();
        if (lastAct !== undefined) {
          if (lastAct.type == 'Attaque' && lastAct.succes === false) {
            attaque = lastAct.action;
          }
        }
        if (attaque === undefined) {
          sendPlayer(msg, "la derni\xE8re action trouv\xE9e n'est pas une attaque rat\xE9e, impossible de montrer l'exemple",
            playerId);
          return;
        }
        var attackerName = attaque.attaquant.token.get('name');
        if (attackerName === undefined) {
          error("Le token de la derni\xE8re attaque est ind\xE9fini", attaque);
          return;
        }
        var evt = {
          type: "Montrer l'exemple"
        };
        setTokenAttr(cible, 'exemplaire', true, evt, {
          msg: "montre l'exemple \xE0 " + attackerName
        });
        // On annule l'ancienne action
        undoEvent();
        // Puis on refait
        var options = attaque.options;
        options.evt = evt;
        options.redo = true;
        attack(attaque.playerName, attaque.playerId, attaque.attaquant, attaque.cibles, attaque.weaponStats, options);
      });
    });
  }

  function interventionDivine(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser intervention divine qu'en combat");
      return;
    }
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 2 || (cmd[1] != "rate" && cmd[1] != "touche")) {
      error("Il manque l'option rate ou touche \xE0 Intervention Divine", msg);
      return;
    }
    getSelected(msg, function(selected) {
      iterSelected(selected, function(pretre) {
        let testIntervention = testLimiteUtilisationsCapa(pretre, 'interventionDivine', 'combat', "a d\xE9j\xE0 fait une intervention divine ce combat", "ne sait pas faire d'intervention divine");
        if (testIntervention === undefined) {
          return;
        }
        var evtARefaire = lastEvent();
        var perso = evtARefaire.personnage;
        if (perso === undefined) {
          error("Erreur interne : intervention divine sans personnage", evtARefaire);
          return;
        }
        var action = evtARefaire.action;
        if (action === undefined) {
          error("Impossible de relancer l'action", evtARefaire);
          return;
        }
        var optionsRedo = action.options || {};
        optionsRedo.redo = true;
        var evt = {
          type: "Intervention divine",
          attributes: []
        };
        if (limiteRessources(pretre, options, 'intervention divine', ' faire une intervention divine', evt)) return;
        utiliseCapacite(pretre, testIntervention, evt);
        addEvent(evt);
        if (evtARefaire.type != 'Attaque') {
          //TODO : Implementer triche sur jetPerso() et echapperEnveloppement()
          error("Intervention Divine ne supporte que les attaques", evtARefaire);
          return;
        }
        undoEvent(evtARefaire);
        if (action.cibles) {
          action.cibles.forEach(function(target) {
            delete target.partialSaveAuto;
            delete target.dmRate;
          });
        }
        optionsRedo.interventionDivine = cmd[1];
        attack(action.playerName, action.playerId, action.attaquant, action.cibles, action.weaponStats, optionsRedo);
        return;
      });
    });
  }

  //!cof-petit-veinard (avec un token s\xE9lectionn\xE9)
  //!cof-bouton-petit-veinard evtid
  //sans argument, diminue juste l'attribut, sinon relance l'\xE9v\xE9nement
  function petitVeinard(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser petit veinard qu'en combat");
      return;
    }
    var msgOptions = parseOptions(msg);
    if (msgOptions === undefined) return;
    var cmd = msgOptions.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    var evtARefaire;
    var evt = {
      type: "Petit veinard",
      attributes: []
    };
    if (cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[1]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
      var perso = evtARefaire.personnage;
      var rollId;
      if (cmd.length > 2) {
        if (!evtARefaire.action) {
          error("Le dernier \xE9v\xE8nement n'est pas une action", msg.content);
          return;
        }
        var roll = evtARefaire.action.rolls[cmd[2]];
        if (roll === undefined) {
          error("Erreur interne du bouton de chance : roll non identifi\xE9", msg.content);
          return;
        }
        if (roll.token === undefined) {
          error("Erreur interne du bouton de chance : roll sans token", msg.content);
          return;
        }
        perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
        rollId = cmd[2];
      }
      if (perso === undefined) {
        error("Erreur interne du bouton petit veinard : l'\xE9venement n'a pas de personnage", evtARefaire);
        return;
      }
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "pas le droit d'utiliser ce bouton");
        return;
      }
      var action = evtARefaire.action;
      if (action === undefined) {
        error("Impossible de relancer l'action", evtARefaire);
        return;
      }
      let testPetitVeinard = testLimiteUtilisationsCapa(perso, 'petitVeinard', 'combat', "a d\xE9j\xE0 tent\xE9 sa chance pour ce combat", "n'est pas un petit veinard");
      if (testPetitVeinard === undefined) {
        return;
      }
      utiliseCapacite(perso, testPetitVeinard, evt);
      undoEvent(evtARefaire);
      addEvent(evt);
      if (rollId) delete action.rolls[rollId];
      else if (action.rolls && action.rolls.attack) delete action.rolls.attack;
      if (!redoEvent(evtARefaire, action, perso))
        error("Type d'\xE9v\xE8nement pas support\xE9 par le bouton Petit Veinard", evt);
    } else { //Juste pour v\xE9rifier l'attribut et le diminuer
      getSelected(msg, function(selection, playerId) {
        if (selection.length === 0) {
          sendPlayer(msg, 'Pas de token s\xE9lectionn\xE9 pour !cof-petit-veinard', playerId);
          return;
        }
        iterSelected(selection, function(perso) {
          let testPetitVeinard = testLimiteUtilisationsCapa(perso, 'petitVeinard', 'combat', "a d\xE9j\xE0 tent\xE9 sa chance pour ce combat", "n'est pas un petit veinard");
          if (testPetitVeinard === undefined) {
            return;
          }
          sendPerso(perso, "peut relancer un d\xE9");
          utiliseCapacite(perso, testPetitVeinard, evt);
        }); //fin iterSelected
        addEvent(evt);
      }); //fin getSelected
    }
  }

  function parseSurprise(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    var testSurprise;
    if (cmd.length > 1) {
      testSurprise = parseInt(cmd[1]);
      if (isNaN(testSurprise)) testSurprise = undefined;
    }
    var cibles = [];
    var ciblesSelectionnees;
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "!cof-surprise sans s\xE9lection de token", playerId);
        log("!cof-surprise requiert de s\xE9lectionner des tokens");
        return;
      }
      ciblesSelectionnees = selected;
      iterSelected(selected, function(perso) {
        if (!isActive(perso)) {
          return;
        }
        cibles.push(perso);
      });
    });
    if (cibles.length > 0) {
      doSurprise(cibles, testSurprise, ciblesSelectionnees, options);
    } else {
      error("Pas de cible valable s\xE9lectionn\xE9e pour la surprise", msg.content);
    }
  }

  function doSurprise(cibles, testSurprise, selected, options) {
    var evt = {
      type: 'surprise',
      action: {
        cibles: cibles,
        testSurprise: testSurprise,
        selected: selected,
        options: options
      }
    };
    addEvent(evt);
    initiative(selected, evt);
    let bonusAttrs = [];
    let bonusPreds = [];
    if (!options.nonVivant) bonusPreds.push('radarMental');
    let display;
    if (testSurprise === undefined) {
      display = startFramedDisplay(options.playerId, "<b>Surprise !</b>");
    } else {
      display = startFramedDisplay(options.playerId, "Test de surprise difficult\xE9 " + testSurprise);
    }
    let tokensToProcess = cibles.length;
    let sendEvent = function() {
      if (tokensToProcess == 1) {
        sendChat("", endFramedDisplay(display));
      }
      tokensToProcess--;
    };
    cibles.forEach(function(perso) {
      const name = perso.token.get('name');
      if (predicateAsBool(perso, 'immunite_surpris')) {
        addLineToFramedDisplay(display, name + " n'est pas surpris" + eForFemale(perso));
        sendEvent();
        return;
      }
      let bonusSurprise = 0;
      let bonusMessages = [];
      if (compagnonPresent(perso, 'surveillance')) {
        bonusSurprise += 5;
        setTokenAttr(perso, 'bonusInitEmbuscade', 5, evt);
        bonusMessages.push(name + " garde un temps d'avance gr\xE2ce \xE0 son compagnon animal : +5");
        initPerso(perso, evt, true);
      }
      if (attributeAsBool(perso, 'sixiemeSens')) {
        bonusSurprise += 5;
        bonusMessages.push(name + " a un sixi\xE8me sens : +5");
      }
      if (testSurprise !== undefined) {
        var testId = 'surprise_' + perso.token.id;
        var optionsTest = {...options
        };
        optionsTest.bonus = bonusSurprise;
        optionsTest.bonusAttrs = bonusAttrs;
        optionsTest.bonusPreds = bonusPreds;
        optionsTest.competence = 'vigilance';
        testCaracteristique(perso, 'SAG', testSurprise, testId, optionsTest, evt,
          function(tr, explications) {
            var result;
            if (tr.reussite) result = "r\xE9ussi." + tr.modifiers;
            else {
              result = "rat\xE9, " + name + " est surpris";
              result += eForFemale(perso);
              result += tr.rerolls + tr.modifiers;
              setState(perso, 'surpris', true, evt);
            }
            var message = name + " fait " + tr.texte + " : " + result;
            addLineToFramedDisplay(display, message);
            explications.forEach(function(m) {
              addLineToFramedDisplay(display, m, 80);
            });
            bonusMessages.forEach(function(m) {
              addLineToFramedDisplay(display, m, 80);
            });
            sendEvent();
          });
      } else { //no test
        setState(perso, 'surpris', true, evt);
        addLineToFramedDisplay(display, name + " est surpris." + eForFemale(perso));
        sendEvent();
      }
    });
  }

  function interchangeable(attackingToken, target, pageId) { //d\xE9termine si il y a assez de tokens
    let token = target.token;
    let res = {
      result: false,
      targets: []
    };
    if (!isActive(target)) return res;
    let limite = predicateAsInt(target, 'interchangeable', 0);
    if (limite < 1) return res;
    let tokens = findObjs({
      _type: 'graphic',
      _subtype: 'token',
      represents: target.charId,
      _pageid: pageId
    });
    tokens = tokens.filter(function(tok) {
      return isActive({
        token: tok
      });
    });
    res.result = (tokens.length > limite);
    // Now select the tokens which could be valid targets
    var p = distanceCombat(attackingToken, token);
    if (p === 0) { //cible au contact, on garde toutes celles au contact
      res.targets = tokens.filter(function(tok) {
        var d = distanceCombat(attackingToken, tok);
        return (d === 0);
      });
    } else { // cible \xE0 distance, on garde celles au contact de la cible
      res.targets = tokens.filter(function(tok) {
        var d = distanceCombat(token, tok);
        return (d === 0);
      });
    }
    return res;
  }

  var alliesParPerso = {};
  var listeCompetences = {
    FOR: {
      list: [],
      elts: new Set()
    },
    DEX: {
      list: [],
      elts: new Set()
    },
    CON: {
      list: [],
      elts: new Set()
    },
    SAG: {
      list: [],
      elts: new Set()
    },
    INT: {
      list: [],
      elts: new Set()
    },
    CHA: {
      list: [],
      elts: new Set()
    },
    nombre: 0
  };
  // Appel\xE9 uniquement apr\xE8s le "ready" et lorsqu'on modifie un handout (fonctionne apr\xE8s l'ajout et la destruction d'un handout)
  // Du coup, alliesParPerso est toujours \xE0 jour
  function changeHandout(hand, prev) {
    if (prev && prev.name && prev.name.startsWith("Equipe ")) {
      var handouts = findObjs({
        _type: 'handout'
      });
      alliesParPerso = {};
      handouts.forEach(parseHandout);
    } else if (hand) {
      parseHandout(hand);
    }
  }

  //pour ce d\xE9barasser des balises html
  // et avoir un tableau de lignes
  function linesOfNote(note) {
    note = note.trim();
    if (note.startsWith('<p>')) note = note.substring(3);
    note = note.trim().replace(/<span[^>]*>|<\/span>/g, '');
    note = note.replace(/<p>/g, '<br>');
    note = note.replace(/<\/p>/g, '');
    return note.trim().split('<br>');
  }

  function charactersInHandout(note, nomEquipe) {
    var names = linesOfNote(note);
    var persos = new Set();
    names.forEach(function(name) {
      name = name.replace(/<(?:.|\s)*?>/g, ''); //Pour enlever les <h2>, etc
      name = name.trim();
      if (name.length === 0) return;
      var characters = findObjs({
        _type: 'character',
      });
      characters = characters.filter(function(c) {
        return c.get('name').trim() == name;
      });
      if (characters.length === 0) {
        log(name + " dans l'\xE9quipe " + nomEquipe + " est inconnu");
        return;
      }
      if (characters.length > 1) {
        var nonArch = characters.filter(function(c) {
          return !(c.get('archived'));
        });
        if (nonArch.length > 0) characters = nonArch;
        if (characters.length > 1) {
          log(name + " dans l'\xE9quipe " + nomEquipe + " est en double");
        }
      }
      characters.forEach(function(character) {
        persos.add(character.id);
      });
    });
    return persos;
  }

  function parseHandout(hand) {
    var handName = hand.get('name').trim();
    if (handName.startsWith("Equipe ")) {
      hand.get('notes', function(note) { // asynchronous
        var persos = charactersInHandout(note, handName);
        persos.forEach(function(charId) {
          var ancien = alliesParPerso[charId];
          if (ancien === undefined) {
            ancien = new Set();
            alliesParPerso[charId] = ancien;
          }
          persos.forEach(function(aci) {
            if (aci == charId) return;
            ancien.add(aci);
          });
        });
      }); //end hand.get('notes')
    } else if (handName == 'Comp\xE9tences' || handName == 'Competences') {
      listeCompetences = {
        FOR: {
          list: [],
          elts: new Set()
        },
        DEX: {
          list: [],
          elts: new Set()
        },
        CON: {
          list: [],
          elts: new Set()
        },
        SAG: {
          list: [],
          elts: new Set()
        },
        INT: {
          list: [],
          elts: new Set()
        },
        CHA: {
          list: [],
          elts: new Set()
        },
        nombre: 0
      };
      hand.get('notes', function(note) { // asynchronous
        var carac; //La carac dont on sp\xE9cifie les comp\xE9tences actuellement
        var lignes = linesOfNote(note);
        lignes.forEach(function(ligne) {
          ligne = ligne.trim();
          var header = ligne.split(':');
          if (header.length > 1) {
            var c = header.shift().trim().toUpperCase();
            if (!isCarac(c)) return;
            carac = c;
            ligne = header.join(':').trim();
          }
          if (ligne.length === 0) return;
          if (carac === undefined) {
            error("Comp\xE9tences sans caract\xE9ristique associ\xE9e", note);
            return;
          }
          var comps = ligne.split(/, |\/| /);
          comps.forEach(function(comp) {
            if (comp.length === 0) return;
            comp = comp.replace(/_/g, ' ');
            listeCompetences[carac].list.push(comp);
            listeCompetences.nombre++;
            listeCompetences[carac].elts.add(comp.toLowerCase());
          });
        });
      }); //end hand.get(notes)
    }
  }

  function estControlleParJoueur(charId) {
    var character = getObj('character', charId);
    if (character === undefined) return false;
    return character.get('controlledby').length > 0;
  }

  //Pour savoir si un personnage est un personnage joueur
  // -> fiche de PJ + d\xE9 de vie + token li\xE9 + controll\xE9 par au moins un joueur.
  function estPJ(perso) {
    if (persoEstPNJ(perso)) return false;
    var dv = ficheAttributeAsInt(perso, 'DV', 0);
    if (dv === 0) return false;
    if (perso.token.get('bar1_link') === '') return false;
    return estControlleParJoueur(perso.charId);
  }

  function estAllieJoueur(perso) {
    if (estControlleParJoueur(perso.charId)) return true;
    var allies = alliesParPerso[perso.charId];
    if (allies === undefined) return false;
    var res = false;
    allies.forEach(function(p) {
      res = res || estControlleParJoueur(p);
    });
    return res;
  }

  function estArme(attaque) {
    let t = fieldAsString(attaque, 'armetypeattaque', 'Naturel');
    if (t.startsWith('Arme')) {
      return t != 'Arme de jet';
    }
    return false;
  }

  //options peut contenir:
  // - ligneOptions : une cha\xEEne de caract\xE8res \xE0 ajouter aux attaques
  // - target : l'id de la cible des attaques
  // - nePasAfficherArmes : quand on affiche plus tard l'arme en main
  function listeAttaquesVisibles(perso, options) {
    options = options || {};
    let ligneOptions = options.ligneOptions || '';
    let target = options.target || '@{target|token_id}';
    let ligne = '';
    //Cherche toutes les attaques \xE0 afficher
    let attaques = listAllAttacks(perso);
    let attaquesTriees = [];
    let attaquesNonTriees = {};
    for (let attLabel in attaques) {
      let att = attaques[attLabel];
      if (fieldAsInt(att, 'armeactionvisible', 1) === 0) continue;
      if (options.nePasAfficherArmes && estArme(att)) continue;
      //V\xE9rification que des options n'emp\xEAchent pas l'utilisation de l'attaque
      let attackOptions = ' ' + fieldAsString(att, 'armeoptions', '');
      if (actionImpossible(perso, attackOptions.split(' --'), attLabel)) continue;
      //On regarde aussi si c'est une arme de jet
      if (att.armetypeattaque == 'Arme de jet' && fieldAsInt(att, 'armejetqte', 1) === 0) continue;
      let command = "!cof-attack @{selected|token_id} " + target + " " + attLabel + " " + ligneOptions;
      let index = +attLabel;
      if (isNaN(index) || parseInt(index) != index || index < 0)
        attaquesNonTriees[attLabel] = bouton(command, att.armenom, perso);
      else
        attaquesTriees[attLabel] = bouton(command, att.armenom, perso);
    }
    attaquesTriees.forEach(function(b) {
      if (b === undefined) return;
      ligne += b + '<br />';
    });
    for (let label in attaquesNonTriees) {
      ligne += attaquesNonTriees[label] + '<br />';
    }
    //On ajoute aussi les lancers de feu gr\xE9geois, si il y en a
    let attrFeuxGregeois = tokenAttribute(perso, 'elixir_feu_gr\xE9geois');
    if (attrFeuxGregeois.length > 0) {
      attrFeuxGregeois = attrFeuxGregeois[0];
      let feuxGregeois = parseInt(attrFeuxGregeois.get('current'));
      if (feuxGregeois > 0) {
        let command = attrFeuxGregeois.get('max').trim();
        ligne += bouton(command, 'Feu gr\xE9geois', perso, {
          ressource: attrFeuxGregeois
        });
        ligne += " (reste " + feuxGregeois + ")";
      }
    }
    return ligne;
  }

  function argsAttaqueAMainsNues(perso) {
    let bonusAtk = computeArmeAtk(perso, '@{ATKCAC}');
    return "Mains nues --toucher " + bonusAtk + " --dm 1d4 + [[@{selected|FOR}]] --tempDmg";
  }

  function listeDesArmes(perso) {
    const listeAttaques = listAllAttacks(perso);
    let attaqueNaturelleNonVisible;
    let armes = {};
    let armeVisible = 0;
    let possedeAttaqueNaturelle;
    for (let label in listeAttaques) {
      const arme = listeAttaques[label];
      const t = fieldAsString(arme, 'armetypeattaque', 'Naturel');
      if (fieldAsInt(arme, 'armeactionvisible', 1) === 1) {
        let options = ' ' + fieldAsString(arme, 'armeoptions', '');
        if (actionImpossible(perso, options.split(' --'), label)) continue;
        switch (t) {
          case 'Naturel':
            possedeAttaqueNaturelle = true;
            break;
          case 'Arme 1 main':
          case 'Arme 2 mains':
          case 'Arme gauche':
            armes[label] = arme;
            armeVisible = true;
            break;
        }
      } else if (!attaqueNaturelleNonVisible && t == 'Naturel') {
        attaqueNaturelleNonVisible = arme;
      }
    }
    return {
      listeAttaques,
      armes,
      armeVisible,
      possedeAttaqueNaturelle,
      attaqueNaturelleNonVisible
    };
  }
  //retourne soit une ability, soit un nombre entre 1 et 4, soit undefined si
  // la liste n'existe pas
  function findListeActions(perso, listActions, abilities) {
    if (listActions == ficheAttribute(perso, 'nomlisteaction1', 'Liste 1')) return 1;
    if (listActions == ficheAttribute(perso, 'nomlisteaction2', 'Liste 2')) return 2;
    if (listActions == ficheAttribute(perso, 'nomlisteaction3', 'Liste 3')) return 3;
    if (listActions == ficheAttribute(perso, 'nomlisteaction4', 'Liste 4')) return 4;
    var fullListActions = '#' + listActions + '#';
    var res = abilities.find(function(a) {
      return a.get('name') == fullListActions;
    });
    return res;
  }

  //Si listActions est fourni, \xE7a peut faire r\xE9f\xE9rence \xE0 une ability
  //dont le nom commence et termine par #, contenant une liste d'actions
  //\xE0 afficher
  //sinon, fait r\xE9f\xE9rence \xE0 une des listes d'action de la fiche
  function turnAction(perso, playerId, listActions) {
    var pageId = perso.token.get('pageid');
    // Toutes les Abilities du personnage li\xE9 au Token
    var abilities = findObjs({
      _type: 'ability',
      _characterid: perso.charId,
    });
    var title = 'Actions possibles :';
    if (stateCOF.chargeFantastique) title = "Charge fantastique: action d'attaque";
    var opt_display = {
      chuchote: true
    };
    var actionsDuTour;
    var actionsParDefaut;
    if (listActions) {
      title = listActions;
      actionsDuTour = findListeActions(perso, listActions, abilities);
      if (actionsDuTour === undefined) {
        return;
      }
    } else {
      afficherOptionsAttaque(perso, opt_display);
      actionsDuTour = 0;
      actionsParDefaut = true;
    }
    var formeDarbre = false;
    if (actionsDuTour === 0) {
      if (!isActive(perso)) {
        if (!getState(perso, 'surpris') || !compagnonPresent(perso, 'surveillance')) {
          sendPerso(perso, "ne peut pas agir \xE0 ce tour");
          return true;
        }
      }
      formeDarbre = attributeAsBool(perso, 'formeDArbre');
      if (formeDarbre) {
        actionsDuTour = findListeActions(perso, "Forme d'arbre", abilities);
        if (actionsDuTour === undefined) actionsDuTour = findListeActions(perso, 'FormeArbre', abilities);
        if (actionsDuTour) {
          actionsParDefaut = true;
        } else {
          actionsDuTour = 0;
          formeDarbre = false;
        }
      }
    }
    //actionDuTour peut \xEAtre undefined, pour la liste par d\xE9faut
    let actionsAAfficher;
    let ligne = '';
    let command = '';
    if (actionsParDefaut && !stateCOF.chargeFantastique && attributeAsBool(perso, 'hate')) {
      ligne += "Effet de h\xE2te : une action d'attaque ou de mouvement en plus <br />";
    }
    if (actionsParDefaut && !stateCOF.chargeFantastique && attributeAsBool(perso, 'reactionViolente')) {
      ligne += "Crise de folie : doit attaquer la personne qui l'a provoqu\xE9 et ceux qui l'en emp\xEAchent.<br />";
      ligne += boutonSimple('!cof-fin-reaction-violente ' + perso.token.id, "Prendre sur soi");
    }
    //Les d\xE9g\xE2ts aux personnages envelopp\xE9s par perso
    var attrs_enveloppe = tokenAttribute(perso, 'enveloppe');
    attrs_enveloppe.forEach(function(a) {
      var cible = persoOfIdName(a.get('current'), pageId);
      if (cible === undefined) {
        error("Attribut d'enveloppe mal form\xE9 ou obsol\xE8te", a.get('current'));
        return;
      }
      var enveloppeDM = a.get('max');
      if (enveloppeDM.startsWith('ability ')) {
        enveloppeDM = enveloppeDM.substring(8);
        var abEnveloppe = abilities.find(function(abilitie) {
          return (abilitie.get('name') === enveloppeDM);
        });
        if (abEnveloppe) {
          command = abEnveloppe.get('action').trim();
          command = replaceAction(command, perso);
          command = command.replace(new RegExp(escapeRegExp('@{target|token_id}'), 'g'), cible.token.id);
          ligne += bouton(command, "Infliger DMS \xE0 " + cible.tokName, perso) + '<br />';
        }
      } else if (enveloppeDM.startsWith('label ')) {
        actionsAAfficher = true;
        command = '!cof-attack ' + perso.token.id + ' ' + cible.token.id + ' ' + enveloppeDM.substring(6) + ' --auto --acide --effet paralyseTemp [[2d6]] --save CON 15';
        ligne += bouton(command, "Infliger DMs \xE0 " + cible.tokName, perso) + '<br />';
      } else if (enveloppeDM.startsWith('etreinte ')) {
        actionsAAfficher = true;
        enveloppeDM = enveloppeDM.substring(9);
        command = '!cof-attack ' + perso.token.id + ' ' + cible.token.id + ' --dm ' + enveloppeDM + ' --auto --nom \xE9treinte ';
        ligne += bouton(command, "Infliger DMs \xE0 " + cible.tokName, perso) + '<br />';
      } //else pas reconnu
    });
    var gobePar;
    var attrGobePar = tokenAttribute(perso, 'estGobePar');
    if (attrGobePar.length > 0) {
      gobePar = persoOfIdName(attrGobePar[0].get('current', pageId));
      command = '!cof-jet FOR 15 --target ' + perso.token.id;
      ligne += boutonSimple(command, "Jet de force") + "pour pouvoir attaquer avec une dague <br />";
      toFront(gobePar.token);
    }
    if (!gobePar && attributeAsBool(perso, 'enveloppePar')) {
      actionsAAfficher = true;
      command = '!cof-echapper-enveloppement --target ' + perso.token.id;
      ligne += boutonSimple(command, 'Se lib\xE9rer') + '<br />';
    } else if (getState(perso, 'enseveli')) {
      actionsAAfficher = true;
      ligne += boutonSaveState(perso, 'enseveli') + '<br />';
    } else if (!gobePar && attributeAsBool(perso, 'etreinteScorpionPar')) {
      actionsAAfficher = true;
      command = '!cof-liberer-agrippe ' + perso.token.id;
      ligne += boutonSimple(command, 'Se lib\xE9rer') + "de l'\xE9treinte du scorpion <br />";
    } else {
      if (stateCOF.armeesDesMorts && !gobePar) {
        var combattreArmee = false;
        stateCOF.armeesDesMorts.forEach(function(armee) {
          var persoArmee = persoOfId(armee);
          var boost = 0;
          if (charAttributeAsBool(persoArmee, "armeeDesMortsPuissant")) boost = 1;
          else boost = charAttributeAsInt(persoArmee, "armeeDesMortsTempeteDeManaIntense", 0);
          var rayon = Math.floor(20 * Math.sqrt(1 + boost));
          if (persoArmee && distanceCombat(perso.token, persoArmee.token, pageId) <= rayon &&
            (!alliesParPerso[persoArmee.charId] || !alliesParPerso[persoArmee.charId].has(perso.charId))) {
            actionsAAfficher = true;
            combattreArmee = true;
          }
        });
        if (combattreArmee) {
          command = '!cof-defense-armee-des-morts ' + perso.token.id;
          ligne += bouton(command, 'Combattre les Morts-Vivants', perso) + '<br />';
        }
      }
      if (!gobePar && (attributeAsBool(perso, 'estAgrippePar') || attributeAsBool(perso, 'estDevorePar'))) {
        actionsAAfficher = true;
        command = '!cof-liberer-agrippe ' + perso.token.id;
        ligne += bouton(command, 'Se lib\xE9rer', perso) + '(action de mvt)<br />';
      }
      if (!gobePar && attributeAsBool(perso, 'etreinteImmolePar')) {
        actionsAAfficher = true;
        command = '!cof-liberer-agrippe ' + perso.token.id;
        ligne += bouton(command, 'Se lib\xE9rer', perso) + ' (action limit\xE9e)<br />';
      }
      if (formeDarbre) {
        actionsAAfficher = true;
        command = '!cof-attack @{selected|token_id} ';
        if (gobePar) command += gobePar.token.id;
        else command += '@{target|token_id}';
        command += ' ["Branches",["@{selected|niveau}",0],20,[1,6,3,0],0]';
        ligne += bouton(command, 'Attaque', perso) + '<br />';
      }
      //On cherche si il y a une arm\xE9e conjur\xE9e \xE0 attaquer
      let attrs_armee =
        findObjs({
          _type: "attribute",
          name: 'armeeConjuree',
        });
      if (attrs_armee.length > 0) {
        let allTokens =
          findObjs({
            _type: "graphic",
            _pageid: pageId,
            _subtype: "token",
            layer: "objects"
          });
        let scale = computeScale(pageId);
        let px = perso.token.get('left');
        let py = perso.token.get('top');
        let pxp = px + 10 * PIX_PER_UNIT / scale;
        let pxm = px - 10 * PIX_PER_UNIT / scale;
        let pyp = py + 10 * PIX_PER_UNIT / scale;
        let pym = py - 10 * PIX_PER_UNIT / scale;
        var ps = tokenSize(perso.token, 0);
        pxp += ps;
        pxm -= ps;
        pyp += ps;
        pym -= ps;
        attrs_armee.forEach(function(aa) {
          var aacid = aa.get('characterid');
          if (aacid == perso.charId) return;
          var invocId = aa.get('current');
          if (invocId == perso.charId) return;
          var allies = alliesParPerso[invocId] || new Set();
          if (allies.has(perso.charId)) return;
          allTokens.forEach(function(t) {
            if (t.get('represents') == aacid) {
              //teste si dans un carr\xE9 de 20 m de cot\xE9 autour de l'arm\xE9e.
              var tx = t.get('left');
              var ty = t.get('top');
              if (tx < pxp && tx > pxm && ty < pyp && ty > pym) {
                command = '!cof-attack ' + perso.token.id + ' ' + t.id + ' ["AttaqueArm\xE9e",[0,0],20,[0,6,' + (ficheAttributeAsInt(perso, 'niveau', 1) + 1) + ',0],20] --auto --attaqueArmeeConjuree';
                ligne += bouton(command, "Attaque de l'arm\xE9e", perso) + '<br />';
              }
            }
          });
        });
      }
      //Les soins pour les \xE9l\xE9mentaires
      if (predicateAsBool(perso, 'corpsElementaire')) {
        command = '!cof-soin 5';
        ligne += bouton(command, "R\xE9g\xE9n\xE9ration", perso) + " si source \xE9l\xE9mentaire proche<br />";
      }
      //Les attaques de la fiche \xE0 afficher dans la liste d'actions
      const montrerAttaques = ficheAttributeAsInt(perso, 'montrerattaques', 1);
      const afficherAttaquesFiche =
        actionsParDefaut ||
        (actionsDuTour === 0 && montrerAttaques);
      const montrerArmeEnMain = (actionsDuTour === 0 && ficheAttributeAsInt(perso, 'montrerarmeenmain', 1));
      if (afficherAttaquesFiche) {
        let attackOptions = {};
        if (gobePar) attackOptions.target = gobePar.token.id;
        if (montrerArmeEnMain) attackOptions.nePasAfficherArmes = true;
        ligne += listeAttaquesVisibles(perso, attackOptions);
      }
      //L'arme en main et d\xE9gainer, si besoin
      if (montrerArmeEnMain) {
        let {
          listeAttaques,
          armes,
          armeVisible,
          possedeAttaqueNaturelle,
          attaqueNaturelleNonVisible
        } = listeDesArmes(perso);
        let labelArmePrincipale;
        let labelArmeGauche;
        let ligneArmePrincipale;
        let ligneArmeGauche;
        let labelArme = tokenAttribute(perso, 'armeEnMain');
        if (labelArme.length > 0) {
          labelArme = labelArme[0];
          labelArmePrincipale = labelArme.get('current');
          labelArmeGauche = labelArme.get('max');
        }
        let command = '!cof-attack ' + perso.token.id + ' @{target|token_id} ';
        if (labelArmePrincipale && listeAttaques[labelArmePrincipale]) {
          ligneArmePrincipale = bouton(command + labelArmePrincipale, listeAttaques[labelArmePrincipale].armenom, perso);
        } else if (!possedeAttaqueNaturelle) {
          if (attaqueNaturelleNonVisible) {
            ligneArmePrincipale =
              bouton(command + attaqueNaturelleNonVisible.armelabel, attaqueNaturelleNonVisible.armenom, perso);
          } else {
            ligneArmePrincipale = bouton(command + argsAttaqueAMainsNues(perso), 'Mains nues', perso);
          }
        }
        if (labelArmeGauche && listeAttaques[labelArmeGauche]) {
          ligneArmeGauche = bouton("!cof-attack @{selected|token_id} @{target|token_id} " + labelArmeGauche, listeAttaques[labelArmeGauche].armenom, perso);
        }
        //Maintenant on propose de d\xE9gainer
        if (armeVisible) {
          let degainer = "!cof-degainer ?{Arme?|";
          let armeADegainer;
          for (var l in armes) {
            if (l != labelArmePrincipale && l != labelArmeGauche) {
              degainer += armes[l].armenom + "," + l + "|";
              if (armeADegainer) armeADegainer.unique = undefined;
              else armeADegainer = {
                unique: true,
                nom: armes[l].armenom,
                label: l
              };
            }
          }
          // Pictos : https://wiki.roll20.net/CSS_Wizardry#Pictos
          if (armeADegainer) {
            if (labelArmePrincipale || labelArmeGauche) {
              degainer += "Rengainer son arme,&amp;#32;}";
            } else if (armeADegainer.unique) {
              //Dans ce cas, pas de choix, juste une arme \xE0 d\xE9gainer
              degainer = '!cof-degainer ' + armeADegainer.label;
            } else {
              degainer = degainer.substr(0, degainer.length - 1) + '}';
            }
            degainer += ' --montreActions';
            if (ligneArmePrincipale)
              ligneArmePrincipale += bouton(degainer, '<span style="font-family:Pictos">;</span>', perso);
            else
              ligneArmePrincipale = bouton(degainer, 'D\xE9gainer', perso);
            if (armeADegainer.unique && !labelArmePrincipale && !labelArmeGauche)
              ligneArmePrincipale += armeADegainer.nom;
          } else {
            ligneArmePrincipale += bouton('!cof-degainer --montreActions', '<span style="font-family:Pictos">}</span>', perso);
          }
        }
        if (ligneArmePrincipale) ligne += ligneArmePrincipale + '<br />';
        if (ligneArmeGauche) ligne += ligneArmeGauche + '<br />';
      }
      //L'action de traverser pour un cyclone
      if (attributeAsBool(perso, 'cyclone')) {
        var labelCyclone = getValeurOfEffet(perso, 'cyclone', 1);
        var diffRenverse = 10 + modCarac(perso, 'force');
        var commandTraverser = "!cof-attack @{selected|token_id} @{target|token_id} " + labelCyclone + " --auto --ifSaveFails DEXFOR " + diffRenverse + " --etat renverse --else --diviseDmg 2 --endif";
        ligne += bouton(commandTraverser, 'Traverser', perso) + '<br />';
      }
      //Affichage du second souffle
      if (actionsParDefaut && predicateAsBool(perso, 'secondSouffle') &&
        !attributeAsBool(perso, 'secondSouffleUtilise')) {
        var pvDebut = attributeAsInt(perso, 'PVsDebutCombat', 0);
        var pv = parseInt(perso.token.get('bar1_value'));
        if (!isNaN(pv) && pv < pvDebut) {
          command = "!cof-soin @{selected|token_id} secondSouffle";
          ligne += bouton(command, 'Second souffle', perso) + '<br/>';
        }
      }
      //Changement de phase pour intangibilit\xE9 avec changement de phase
      if (attributeAsBool(perso, 'intangiblePuissant')) {
        if (attributeAsInt(perso, 'intangibleValeur', 1)) {
          command = "!cof-set-attribute intangibleValeur 0 --target " + perso.token.id + " --message redevient tangible";
          ligne += boutonSimple(command, "Redevenir tangible") + '<br/>';
        } else {
          command = "!cof-set-attribute intangibleValeur 1 --target " + perso.token.id + " --message devient l\xE9g\xE8rement translucide";
          ligne += boutonSimple(command, "Redevenir intangible") + '<br/>';
        }
      }
      if (attributeAsBool(perso, 'intangibleInvisiblePuissant')) {
        if (attributeAsInt(perso, 'intangibleInvisibleValeur', 1)) {
          command = "!cof-set-attribute intangibleInvisibleValeur 0 --etat invisible false --target " + perso.token.id + " --message r\xE9appara\xEEt";
          ligne += boutonSimple(command, "Redevenir tangible") + '<br/>';
        } else {
          command = "!cof-set-attribute intangibleInvisibleValeur 1 --etat invisible true --target " + perso.token.id + " --message dispara\xEEt";
          ligne += boutonSimple(command, "Redevenir intangible") + '<br/>';
        }
      }
      //La liste d'action proprement dite
      actionsAAfficher = treatActions(perso, actionsDuTour, abilities, function(command, text, macros, options) {
        if (command == 'liste des attaques') {
          let attackOptions = {
            ligneOptions: options
          };
          if (gobePar) attackOptions.target = gobePar.token.id;
          ligne += listeAttaquesVisibles(perso, attackOptions);
        } else {
          options = options || {};
          var b = bouton(command, text, perso, options);
          if (options.actionImpossible) ligne += text + '<br />';
          else ligne += b + '<br />';
        }
      });
      if (actionsParDefaut) {
        actionsAAfficher = true;
        command = "!cof-attendre ?{Nouvelle initiative}";
        ligne += bouton(command, 'Attendre', perso) + '<br />';
        if (!gobePar && !charAttributeAsBool(perso, 'armeeConjuree')) {
          command = "!cof-action-defensive ?{Action d\xE9fensive|simple|totale}";
          ligne += bouton(command, 'Se d\xE9fendre', perso) + '<br />';
          var manoeuvreDuelliste = predicateAsBool(perso, 'manoeuvreDuelliste');
          if (manoeuvreDuelliste) {
            command = "!cof-manoeuvre @{selected|token_id} @{target|token_id} ?{Manoeuvre?|bloquer|desarmer|renverser|tenirADistance|repousser}";
            ligne += bouton(command, 'Manoeuvres de duelliste', perso) + '<br />';
          }
          if (stateCOF.options.affichage.val.manoeuvres.val) {
            if (manoeuvreDuelliste) {
              command = "!cof-manoeuvre @{selected|token_id} @{target|token_id} ?{Manoeuvre?|aveugler|faireDiversion|menacer}";
              ligne += bouton(command, 'Autres manoeuvres', perso) + '<br />';
            } else {
              command = "!cof-manoeuvre @{selected|token_id} @{target|token_id} ?{Manoeuvre?|aveugler|bloquer|desarmer|faireDiversion|menacer|renverser|tenirADistance|repousser}";
              ligne += bouton(command, 'Manoeuvres', perso) + '<br />';
            }
          }
        }
      }
      for (var etat in cof_states) {
        var saveEtat = boutonSaveState(perso, etat);
        if (saveEtat) {
          ligne += saveEtat + '<br />';
          actionsAAfficher = true;
        }
      }
    }
    if (actionsAAfficher) {
      // on envoie la liste aux joueurs qui g\xE8rent le personnage dont le token est li\xE9
      let lastPlayerid;
      // on r\xE9cup\xE8re les players_ids qui controllent le Token
      let playerIds;
      if (playerId) playerIds = [playerId];
      else playerIds = getPlayerIds(perso);
      playerIds.forEach(function(playerid) {
        lastPlayerid = playerid;
        let display = startFramedDisplay(playerid, title, perso, opt_display);
        addLineToFramedDisplay(display, ligne);
        sendChat('', endFramedDisplay(display));
      });
      // En prime, on l'envoie au MJ, si besoin
      let envoieAuMJ = playerIds.length === 0;
      if (!envoieAuMJ && stateCOF.options.affichage.val.MJ_voit_actions.val) {
        envoieAuMJ = playerIds.every(function(pid) {
          return !playerIsGM(pid);
        });
      }
      if (envoieAuMJ) {
        opt_display.chuchote = 'gm';
        var display = startFramedDisplay(lastPlayerid, title, perso, opt_display);
        addLineToFramedDisplay(display, ligne);
        sendChat('', endFramedDisplay(display));
      }
    }
    return actionsAAfficher;
  }

  function apiTurnAction(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) return;
    let liste;
    if (cmd.length > 1) {
      liste = cmd.slice(1).join(' ');
    }
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        let actions = turnAction(perso, playerId, liste);
        if (!actions) {
          let l = liste || '';
          sendPerso(perso, "n'a pas de liste d'actions " + l + " d\xE9finie");
        }
      });
    });
  }

  function removeDernieresCiblesAttaquees(perso, evt) {
    let attrDernieresCibles = tokenAttribute(perso, 'dernieresCiblesAttaquees');
    if (attrDernieresCibles.length > 0) {
      attrDernieresCibles = attrDernieresCibles[0];
      if (predicateAsBool(perso, 'attaqueEnMeute')) {
        let dernieresCibles = attrDernieresCibles.get('current');
        let cibles = new Set(dernieresCibles.split(' '));
        cibles.forEach(function(ci) {
          let cible = persoOfId(ci);
          if (cible === undefined) return;
          let attrCibleMeute = tokenAttribute(cible, 'attaqueParMeute');
          if (attrCibleMeute.length > 0) {
            attrCibleMeute = attrCibleMeute[0];
            let cibleMeute = attrCibleMeute.get('current');
            let ensembleCibleMeute = new Set(cibleMeute.split(' '));
            if (ensembleCibleMeute.has(perso.token.id)) {
              ensembleCibleMeute.delete(perso.token.id);
              if (ensembleCibleMeute.size > 0) {
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: attrCibleMeute,
                  current: cibleMeute,
                });
                cibleMeute = '';
                ensembleCibleMeute.forEach(function(ai) {
                  if (cibleMeute === '') cibleMeute = ai;
                  else cibleMeute += ' ' + ai;
                });
                attrCibleMeute.set('current', cibleMeute);
              } else {
                evt.deletedAttributes = evt.deletedAttributes || [];
                evt.deletedAttributes.push(attrCibleMeute);
                attrCibleMeute.remove();
              }
            }
          }
        });
      }
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attrDernieresCibles);
      attrDernieresCibles.remove();
    }
  }

  function getTurnOrder(evt) {
    var turnOrder = Campaign().get('turnorder');
    evt.turnorder = evt.turnorder || turnOrder;
    if (turnOrder === "") {
      turnOrder = [{
        id: "-1",
        pr: 1,
        custom: "Tour",
        formula: "+1"
      }];
      evt.tour = stateCOF.tour;
      stateCOF.tour = 1;
    } else {
      turnOrder = JSON.parse(turnOrder);
    }
    var indexTour = turnOrder.findIndex(function(elt) {
      return (elt.id == "-1" && elt.custom == "Tour");
    });
    if (indexTour == -1) {
      indexTour = turnOrder.length;
      turnOrder.push({
        id: "-1",
        pr: 1,
        custom: "Tour",
        formula: "+1"
      });
      evt.tour = stateCOF.tour;
      stateCOF.tour = 1;
    }
    var res = {
      tour: turnOrder[indexTour],
      pasAgi: turnOrder.slice(0, indexTour),
      dejaAgi: turnOrder.slice(indexTour + 1, turnOrder.length)
    };
    return res;
  }

  //ne rajoute pas evt \xE0 l'historique
  function setTurnOrder(to, evt) {
    if (to.pasAgi.length > 0) {
      to.pasAgi.sort(function(a, b) {
        if (a.id == "-1") return 1;
        if (b.id == "-1") return -1;
        if (a.pr < b.pr) return 1;
        if (b.pr < a.pr) return -1;
        // Priorit\xE9 aux joueurs
        // Premier crit\xE8re : la barre de PV des joueurs est li\xE9e
        var tokenA = getObj('graphic', a.id);
        if (tokenA === undefined) return 1;
        var tokenB = getObj('graphic', b.id);
        if (tokenB === undefined) return -1;
        if (tokenA.get('bar1_link') === '') {
          if (tokenB.get('bar1_link') === '') return 0;
          return 1;
        }
        if (tokenB.get('bar1_link') === '') return -1;
        // Deuxi\xE8me crit\xE8re : les joueurs ont un DV
        var charIdA = tokenA.get('represents');
        if (charIdA === '') return 1;
        var charIdB = tokenB.get('represents');
        if (charIdB === '') return -1;
        var persoA = {
          token: tokenA,
          charId: charIdA
        };
        var persoB = {
          token: tokenB,
          charId: charIdB
        };
        var dvA = ficheAttributeAsInt(persoA, "DV", 0);
        var dvB = ficheAttributeAsInt(persoB, "DV", 0);
        if (dvA === 0) {
          if (dvB === 0) return 0;
          return 1;
        }
        if (dvB === 0) return -1;
        //Entre joueurs, priorit\xE9 \xE0 la plus grosse sagesse
        var sagA = ficheAttributeAsInt(persoA, 'sagesse', 10);
        var sagB = ficheAttributeAsInt(persoB, 'sagesse', 10);
        if (sagA < sagB) return 1;
        if (sagA > sagB) return -1;
        return 0;
      });
      setActiveToken(to.pasAgi[0].id, evt);
    }
    to.pasAgi.push(to.tour);
    var turnOrder = to.pasAgi.concat(to.dejaAgi);
    Campaign().set('turnorder', JSON.stringify(turnOrder));
  }

  function attendreInit(msg) {
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("La fonction !cof-attendre : rien \xE0 faire, pas de token selectionn\xE9", msg);
        return;
      }
      var cmd = msg.content.split(' ');
      if (cmd.length < 2) {
        error("Attendre jusqu'\xE0 quelle initiative ?", cmd);
        return;
      }
      var newInit = parseInt(cmd[1]);
      if (isNaN(newInit) || newInit < 1) {
        error("On ne peut attendre que jusqu'\xE0 une initiative de 1", cmd);
        newInit = 1;
      }
      var evt = {
        type: "attente"
      };
      var to = getTurnOrder(evt);
      iterSelected(selected, function(perso) {
        var token = perso.token;
        if (!isActive(perso)) return;
        var tokenPos =
          to.pasAgi.findIndex(function(elt) {
            return (elt.id == token.id);
          });
        if (tokenPos == -1) { // token ne peut plus agir
          sendPerso(perso, " a d\xE9j\xE0 agit ce tour");
          return;
        }
        if (newInit < to.pasAgi[tokenPos].pr) {
          to.pasAgi[tokenPos].pr = newInit;
          sendPerso(perso, " attend un peu avant d'agir...");
          updateNextInit(perso);
        } else {
          sendPerso(perso, " a d\xE9j\xE0 une initiative inf\xE9rieure \xE0 " + newInit);
        }
      });
      setTurnOrder(to, evt);
      addEvent(evt);
    });
  }

  // Affiche des informations sur le personnage s\xE9lectionn\xE9
  function statut(msg) {
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Dans !cof-statut : rien \xE0 faire, pas de token selectionn\xE9", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        const token = perso.token;
        const charId = perso.charId;
        const name = token.get('name');
        let lie = true;
        if (token.get('bar1_link') === '') lie = false;
        const display = startFramedDisplay(playerId, "\xC9tat de " + name, perso, {
          chuchote: true
        });
        const estPNJ = persoEstPNJ(perso);
        let line;
        let hasMana = false;
        let manaAttr = [];
        if (!estPNJ)
          manaAttr = findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: 'PM'
          }, {
            caseInsensitive: true
          });
        if (manaAttr.length > 0) {
          let manaMax = parseInt(manaAttr[0].get('max'));
          hasMana = !isNaN(manaMax) && manaMax > 0;
        }
        let dmTemp = parseInt(token.get('bar2_value'));
        if (hasMana) { //ne peut pas \xEAtre un PNJ
          if (lie) {
            dmTemp = ficheAttributeAsInt(perso, 'DMTEMP', 0);
          } else {
            dmTemp = attributeAsInt(perso, 'DMTEMP', 0);
          }
        } else if (lie) {
          var nameAttrDMTEMP = 'DMTEMP';
          var versionFiche = parseFloat(ficheAttribute(perso, 'version', 0));
          if (isNaN(versionFiche)) versionFiche = 0;
          if (estPNJ && versionFiche < 3.7) nameAttrDMTEMP = 'pnj_dmtemp';
          dmTemp = ficheAttributeAsInt(perso, nameAttrDMTEMP, 0);
        }
        if (!isNaN(dmTemp) && dmTemp > 0) {
          line = "Dommages temporaires : " + dmTemp;
          addLineToFramedDisplay(display, line);
        }
        var douleurIgnoree = attributeAsInt(perso, 'douleurIgnoree', 0);
        if (douleurIgnoree > 0) {
          line = "a ignor\xE9 " + douleurIgnoree + " pv dans ce combat.";
          addLineToFramedDisplay(display, line);
        }
        var aDV = ficheAttributeAsInt(perso, 'DV', 0);
        if (aDV > 0) { // correspond aux PJs
          var pr = pointsDeRecuperation(perso);
          line =
            "Points de r\xE9cup\xE9ration : " + pr.current + " / " + pr.max;
          addLineToFramedDisplay(display, line);
          if (ficheAttributeAsInt(perso, 'option_pc', 1)) {
            var pc = 3;
            var pc_max = 3;
            var attr_pc = charAttribute(perso.charId, 'pc', {
              caseInsensitive: true
            });
            if (attr_pc !== undefined && attr_pc.length > 0) {
              pc = parseInt(attr_pc[0].get('current'));
              if (isNaN(pc)) pc = 0;
              pc_max = parseInt(attr_pc[0].get('max'));
              if (isNaN(pc_max)) pc_max = 3;
            }
            line = "Points de chance : " + pc + " / " + pc_max;
            addLineToFramedDisplay(display, line);
          }
          if (predicateAsBool(perso, 'pacifisme')) {
            if (attributeAsBool(perso, 'attributDeCombat_pacifismeAnnule')) {
              addLineToFramedDisplay(display, "Pacifisme non actif");
            } else {
              addLineToFramedDisplay(display, "Pacifisme actif");
            }
          }
        }
        var attrsChar = findObjs({
          _type: 'attribute',
          _characterid: charId
        });
        var attaques = listAllAttacks(perso);
        var armeEnMain =
          attrsChar.find(function(a) {
            return a.get('name') == 'armeEnMain';
          });
        var armeEnMainGauche;
        if (armeEnMain) {
          armeEnMainGauche = armeEnMain.get('max');
          armeEnMain = armeEnMain.get('current');
        }
        _.forEach(attaques, function(att, armeLabel) {
          let nomArme = att.armenom;
          let chargeMax = predicateAsInt(perso, 'charge_' + armeLabel, 0);
          if (chargeMax) {
            let charge = attributeAsInt(perso, 'charge_' + armeLabel, 0);
            if (charge === 0) {
              line = nomArme + " n'est pas charg\xE9";
            } else {
              let grenaille = attrsChar.find(function(a) {
                return (a.get('name') == 'chargeGrenaille_' + armeLabel);
              });
              if (grenaille) {
                grenaille = parseInt(grenaille.get('current'));
                if (isNaN(grenaille) || grenaille < 0) grenaille = 0;
              } else grenaille = 0;
              if (charge == 1) {
                line = nomArme + " est charg\xE9";
                if (grenaille) line += " de grenaille";
              } else if (charge > 1) {
                line = nomArme + " contient encore " + charge + " charges";
                if (grenaille == charge) line += " de grenaille";
                else if (grenaille)
                  line += ", dont " + grenaille + " de grenaille";
              }
            }
            if (armeEnMain == armeLabel) line += " et en main";
            else if (armeEnMainGauche == armeLabel) line += " et en main gauche";
            else line += ", pas en main";
            addLineToFramedDisplay(display, line);
          } else if (armeEnMain == armeLabel) {
            addLineToFramedDisplay(display, "tient " + nomArme + " en main.");
          } else if (armeEnMainGauche == armeLabel) {
            addLineToFramedDisplay(display, "tient " + nomArme + " en main gauche.");
          } else if (att.armetypeattaque == "Arme de jet") {
            let n = fieldAsInt(att, 'armejetqte', 1);
            addLineToFramedDisplay(display, nomArme + " : " + n);
          }
          if (attributeAsBool(perso, 'poisonRapide_' + armeLabel)) {
            addLineToFramedDisplay(display, nomArme + " est enduit de poison.");
          }
        });
        if (attributeAsInt(perso, 'enflamme', 0))
          addLineToFramedDisplay(display, "en flammes");
        var attrEnveloppe = tokenAttribute(perso, 'enveloppePar');
        if (attrEnveloppe.length > 0) {
          var cube = persoOfIdName(attrEnveloppe[0].get('current'));
          if (cube) {
            var actE = "est envelopp\xE9 dans ";
            if ((attrEnveloppe[0].get('max') + '').startsWith('etreinte')) actE = "est prisonnier de l'\xE9treinte de ";
            addLineToFramedDisplay(display, actE + cube.tokName);
          }
        }
        let pageId = perso.token.get('pageid');
        let defense = defenseOfPerso(undefined, perso, pageId, undefined, {
          test: true
        });

        let defenseMontree;
        let bufDef = attributeAsInt(perso, 'bufDEF', 0);
        if (bufDef > 0) {
          addLineToFramedDisplay(display, "D\xE9fense temporairement modifi\xE9e de " + bufDef + " (DEF " + defense + ")");
          defenseMontree = true;
        }
        for (let etat in cof_states) {
          if (getState(perso, etat)) {
            let markerName = cof_states[etat].substring(7).split("::")[0];
            let marker = markerCatalog[markerName];
            let etext = stringOfEtat(etat, perso);
            if (marker) {
              etext = "<img src=" + marker.url + "></img> " + etext;
            }
            let saveEtat = boutonSaveState(perso, etat);
            if (saveEtat) etext += ", " + saveEtat;
            addLineToFramedDisplay(display, etext);
          }
        }
        if (ficheAttributeAsInt(perso, 'defarmureon', 0) === 0) {
          let possedeArmure = ficheAttributeAsInt(perso, 'defarmure', 0) > 0;
          if (possedeArmure) addLineToFramedDisplay(display, "Ne porte pas son armure");
          if (predicateAsInt(perso, 'vetementsSacres', 0) > 0) {
            if (possedeArmure) addLineToFramedDisplay(display, "  mais b\xE9n\xE9ficie de ses v\xEAtements sacr\xE9s (DEF " + defense + ")");
            else addLineToFramedDisplay(display, "porte des v\xEAtements sacr\xE9s (DEF " + defense + ")");
            defenseMontree = true;
          }
          if (predicateAsInt(perso, 'armureDeVent', 0) > 0) {
            if (possedeArmure) addLineToFramedDisplay(display, "  mais b\xE9n\xE9ficie de son armure de vent (DEF " + defense + ")");
            else addLineToFramedDisplay(display, "b\xE9n\xE9ficie de son armure de vent (DEF " + defense + ")");
            defenseMontree = true;
          }
        }
        if (ficheAttributeAsInt(perso, 'defbouclieron', 0) === 0 &&
          ficheAttributeAsInt(perso, 'defbouclier', 0))
          addLineToFramedDisplay(display, "Ne porte pas son bouclier");
        if (attributeAsBool(perso, 'etatExsangue')) {
          addLineToFramedDisplay(display, "est exsangue");
        }
        if (attributeAsBool(perso, 'malediction')) {
          addLineToFramedDisplay(display, "est maudit...");
        }
        const allAttrs = findObjs({
          _type: 'attribute',
          _characterid: charId
        });
        allAttrs.forEach(function(attr) {
          const attrName = attr.get('name');
          if (!lie && !attrName.endsWith('_' + name)) return;
          if (estEffetTemp(attrName)) {
            let effet = effetTempOfAttribute(attr);
            let mt = messageEffetTemp[effet];
            if (lie) {
              if (mt.generic) {
                if (attrName.indexOf(')_') > 0) return;
              } else if (effet != attrName) return;
            }
            let explEffetMsg = mt.actif;
            if (stateCOF.options.affichage.val.duree_effets.val || playerIsGM(playerId)) {
              let effetVal = attr.get('current');
              if (parseInt(effetVal)) {
                explEffetMsg += " (" + effetVal + " tours)";
              } else {
                explEffetMsg += " (tour final)";
              }
            }
            addLineToFramedDisplay(display, explEffetMsg);
          } else if (estEffetCombat(attrName)) {
            var effetC = effetCombatOfAttribute(attr);
            if (lie && effetC != attrName) return;
            addLineToFramedDisplay(display, messageEffetCombat[effetC].actif);
          } else if (estEffetIndetermine(attrName)) {
            var effetI = effetIndetermineOfAttribute(attr);
            if (lie && effetI != attrName) return;
            addLineToFramedDisplay(display, messageEffetIndetermine[effetI].actif);
          }
        });
        allAttributesNamed(attrsChar, 'munition').forEach(function(attr) {
          var attrName = attr.get('name');
          var underscore = attrName.indexOf('_');
          if (underscore < 0 || underscore == attrName.length - 1) return;
          var munitionNom = attrName.substring(underscore + 1).replace(/_/g, ' ');
          addLineToFramedDisplay(display, munitionNom + " : " + attr.get('current') + " / " + attr.get('max'));
        });
        var attrPosture = tokenAttribute(perso, 'postureDeCombat');
        if (attrPosture.length > 0) {
          attrPosture = attrPosture[0];
          var posture = attrPosture.get('max');
          var postureMsg = "a une posture ";
          switch (posture.substr(-3, 3)) {
            case 'DEF':
              postureMsg += "d\xE9fensive";
              break;
            case 'ATT':
              postureMsg += "offensive";
              break;
            case '_DM':
              postureMsg += "puissante";
              break;
            default:
          }
          postureMsg += " mais ";
          switch (posture.substr(0, 3)) {
            case 'DEF':
              postureMsg += "risqu\xE9e";
              break;
            case 'ATT':
              postureMsg += "moins pr\xE9cise";
              break;
            case 'DM_':
              postureMsg += "moins puissante";
              break;
            default:
          }
          addLineToFramedDisplay(display, postureMsg);
        }
        var attrattaqueAOutrance = tokenAttribute(perso, 'attaqueAOutrance');
        if (attrattaqueAOutrance.length > 0) {
          attrattaqueAOutrance = attrattaqueAOutrance[0];
          var attaqueAOutrance = attrattaqueAOutrance.get('current');
          var attaqueAOutranceMsg = "attaque \xE0 outrance ";
          switch (attaqueAOutrance) {
            case 2:
              attaqueAOutranceMsg += "(-2 DEF, +1D6 DM)";
              break;
            case 5:
              attaqueAOutranceMsg += "(-5 DEF, +2D6 DM)";
              break;
            default:
          }
          addLineToFramedDisplay(display, attaqueAOutranceMsg);
        }
        let rangSoin = predicateAsInt(perso, 'voieDesSoins', 0);
        if (rangSoin > 0) {
          var msgSoins;
          var soinsRestants;
          var soins = "";
          let soinsLegers = attributeAsInt(perso, 'soinsLegers', 0);
          if (soinsLegers < rangSoin) {
            soinsRestants = rangSoin - soinsLegers;
            if (soinsRestants > 1) soins = 's';
            msgSoins = "peut encore faire " + soinsRestants + " soin" + soins + " l\xE9ger" + soins;
            addLineToFramedDisplay(display, msgSoins);
          } else {
            addLineToFramedDisplay(display, "ne peut plus faire de soin l\xE9ger aujourd'hui");
          }
          if (rangSoin > 1) {
            var soinsModeres = attributeAsInt(perso, 'soinsModeres', 0);
            if (soinsModeres < rangSoin) {
              soinsRestants = rangSoin - soinsModeres;
              if (soinsRestants > 1) soins = 's';
              else soins = '';
              msgSoins = "peut encore faire " + soinsRestants + " soin" + soins + " mod\xE9r\xE9" + soins;
              addLineToFramedDisplay(display, msgSoins);
            } else {
              addLineToFramedDisplay(display, "ne peut plus faire de soin mod\xE9r\xE9 aujourd'hui");
            }
          }
          if (rangSoin > 3) {
            var soinsGuerison = attributeAsInt(perso, 'limiteParJour_gu\xE9rison', 1);
            if (soinsGuerison) {
              addLineToFramedDisplay(display, "peut encore faire " + soinsGuerison + "gu\xE9rison" + (soinsGuerison > 1 ? 's' : '') + " aujourd'hui");
            } else {
              addLineToFramedDisplay(display, "ne peut plus faire de gu\xE9rison aujourd'hui");
            }
          }
        }
        let ebriete = attributeAsInt(perso, 'niveauEbriete', 0);
        if (ebriete > 0 && ebriete < niveauxEbriete.length) {
          addLineToFramedDisplay(display, "est " + niveauxEbriete[ebriete]);
        }
        let bonusCouvert = attributeAsInt(perso, 'bonusCouvert');
        if (bonusCouvert) {
          addLineToFramedDisplay(display, "est \xE0 couvert (+" + bonusCouvert + " DEF)");
        }
        if (!defenseMontree) {
          let defenseAffichee = 10;
          if (estPNJ) {
            defenseAffichee = ficheAttributeAsInt(perso, 'pnj_def', 10);
          } else {
            defenseAffichee += ficheAttributeAsInt(perso, 'defarmure', 0) * ficheAttributeAsInt(perso, 'defarmureon', 0);
            defenseAffichee += ficheAttributeAsInt(perso, 'defbouclier', 0) * ficheAttributeAsInt(perso, 'defbouclieron', 0);
            defenseAffichee += ficheAttributeAsInt(perso, 'DEFDIV', 0);
            defenseAffichee += modCarac(perso, 'dexterite');
          }
          if (defense != defenseAffichee)
            addLineToFramedDisplay(display, "D\xE9fense actuelle : " + defense);
        }
        let predicatExpertDuCombat = predicateAsInt(perso, "expertDuCombat", 0);
        if (stateCOF.combat && predicatExpertDuCombat > 0) {
          let nbDesExpertDuCombat_combat_max = predicatExpertDuCombat * 2;
          let nbDesExpertDuCombat_combat = attributeAsInt(perso, "limiteParCombat_expertDuCombat", predicatExpertDuCombat * 2);
          let nbDesExpertDuCombat_tour_max;
          if (predicatExpertDuCombat > 4) nbDesExpertDuCombat_tour_max = 3;
          else if (predicatExpertDuCombat > 2) nbDesExpertDuCombat_tour_max = 2;
          else nbDesExpertDuCombat_tour_max = 1;
          let nbDesExpertDuCombat_tour = Math.min(nbDesExpertDuCombat_combat,
            attributeAsInt(perso, "limiteParTour_expertDuCombat", nbDesExpertDuCombat_tour_max));
          addLineToFramedDisplay(display, "D\xE9s d'expertise du combat : <br>" +
            "Tour : " + nbDesExpertDuCombat_tour + "/" + nbDesExpertDuCombat_tour_max + "<br>" +
            "Combat : " + nbDesExpertDuCombat_combat + "/" + nbDesExpertDuCombat_combat_max + "<br>");
        }
        //Affaiblissements de caract\xE9ristiques
        allCaracs.forEach(function(carac) {
          let malus = attributeAsInt(perso, 'affaiblissementde' + carac, 0);
          if (malus > 0) {
            let normal = caracNormale(perso, carac);
            let ligne = carac + " : " + (normal - malus) + " / " + normal;
            addLineToFramedDisplay(display, ligne);
          }
        });
        let autresAttributs = charAttribute(charId, 'attributsDeStatut');
        autresAttributs.forEach(function(attr) {
          let listeAttrs = attr.get('current').split(',');
          listeAttrs.forEach(function(a) {
            a = a.trim();
            if (a === '') return;
            let aDisplay = tokenAttribute(perso, a);
            aDisplay.forEach(function(ad) {
              let line = a + " : " + ad.get('current');
              let admax = ad.get('max');
              if (admax) line += " / " + admax;
              addLineToFramedDisplay(display, line);
            });
          });
        });
        sendChat("", endFramedDisplay(display));
      }); //fin du iterSelected
    });
  }

  //retourne l'id du suivant si le token actuel \xE9tait en t\xEAte de liste
  function removeFromTurnTracker(perso, evt) {
    removeDernieresCiblesAttaquees(perso, evt);
    let tokenId = perso.token.id;
    let turnOrder = Campaign().get('turnorder');
    if (turnOrder === '' || !stateCOF.combat) {
      return;
    }
    evt.turnorder = evt.turnorder || turnOrder;
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length === 0) return;
    let res;
    if (turnOrder[0].id == tokenId) {
      if (turnOrder.length > 1) {
        res = {
          nextId: turnOrder[1].id
        };
        turnOrder.shift();
        if (turnOrder[0].id == "-1" && turnOrder[0].custom == "Tour") {
          //Il faut aussi augmenter la valeur du tour
          let tour = parseInt(turnOrder[0].pr);
          if (isNaN(tour)) {
            error("Tour invalide", turnOrder);
            return;
          }
          turnOrder[0].pr = tour + 1;
        }
        let cmp = Campaign();
        cmp.set('turnorder', JSON.stringify(turnOrder));
        nextTurn(cmp, undefined, evt);
        return res;
      } else {
        res = {
          nextId: false
        };
        turnOrder = [];
      }
    } else {
      turnOrder = turnOrder.filter(
        function(elt) {
          return (elt.id != tokenId);
        });
    }
    Campaign().set('turnorder', JSON.stringify(turnOrder));
    return res;
  }

  function replaceInTurnTracker(tidOld, tidNew, evt) {
    var turnOrder = Campaign().get('turnorder');
    if (turnOrder === "" || !stateCOF.combat) {
      return;
    }
    evt.turnorder = evt.turnorder || turnOrder;
    turnOrder = JSON.parse(turnOrder);
    turnOrder.forEach(function(elt) {
      if (elt.id == tidOld) elt.id = tidNew;
    });
    Campaign().set('turnorder', JSON.stringify(turnOrder));
    if (tidOld == stateCOF.activeTokenId)
      stateCOF.activeTokenId = tidNew;
  }

  function armureMagique(msg) {
    msg.content += " armureMagique";
    effetCombat(msg);
  }

  function bufDef(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("La fonction !cof-buf-def attend un argument", cmd);
      return;
    }
    var buf = parseInt(cmd[1]);
    if (isNaN(buf)) {
      error("Argument de !cof-bu-def invalide", cmd);
      return;
    }
    if (buf === 0) return;
    var message = "";
    if (buf > 0) message = "voit sa d\xE9fense augmenter";
    else message = "voit sa d\xE9fense baisser";
    var evt = {
      type: 'other'
    };
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour !cof--buf-def", playerId);
      }
      iterSelected(selected, function(perso) {
        setTokenAttr(perso, 'bufDEF', buf, evt, {
          msg: message
        });
        setToken(perso.token, 'status_blue', buf, evt);
      });
      if (evt.attributes.length === 0) {
        error("Pas de cible valide s\xE9lectionn\xE9e pour !cod-buf-def", msg);
        return;
      }
      addEvent(evt);
    });
  }

  function removeBufDef(msg) {
    var evt = {
      type: 'other'
    };
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour !cof-remove-buf-def", playerId);
      }
      iterSelected(selected, function(perso) {
        removeTokenAttr(perso, 'bufDEF', evt, {
          msg: "retrouve sa d\xE9fense normale"
        });
        setToken(perso.token, 'status_blue', false, evt);
      });
      addEvent(evt);
    });
  }

  function deTest(personnage, carac) {
    var dice = 20;
    if ((estAffaibli(personnage) && !predicateAsBool(personnage, 'insensibleAffaibli')) ||
      getState(personnage, 'immobilise') ||
      attributeAsBool(personnage, 'mortMaisNAbandonnePas'))
      dice = 12;
    else {
      var ebriete = attributeAsInt(personnage, 'niveauEbriete', 0);
      if (ebriete > 2) dice = 12;
      else if (ebriete > 1 && carac != 'CON') dice = 12;
    }
    return dice;
  }

  function parseDmgOptions(text, options) {
    let optArgs = text.split(' --');
    optArgs.forEach(function(opt) {
      opt = opt.trim().split(' ');
      opt = opt.filter(function(c) {
        return c !== '';
      });
      switch (opt[0]) {
        case 'psave':
          let psaveopt = options;
          if (options.additionalDmg && opt.length > 3 && opt[3] == 'local') {
            let psavel = options.additionalDmg.length;
            if (psavel > 0) {
              psaveopt = options.additionalDmg[psavel - 1];
            }
          }
          let psaveParams = parseSave(opt);
          if (psaveParams) {
            psaveopt.partialSave = psaveParams;
          }
          return;
        case 'asphyxie':
        case 'affute':
        case "metal":
        case 'magique':
        case 'artificiel':
        case 'tranchant':
        case 'percant':
        case 'contondant':
        case 'tempDmg':
        case 'mortsVivants':
        case 'ignoreMoitieRD':
        case 'maxDmg':
        case 'sortilege':
          options[opt[0]] = true;
          return;
        case 'feu':
        case 'froid':
        case 'acide':
        case 'electrique':
        case 'sonique':
        case 'poison':
        case 'maladie':
        case 'argent':
        case 'energie':
          if (options.additionalDmg) {
            var l = options.additionalDmg.length;
            if (l > 0) {
              options.additionalDmg[l - 1].type = opt[0];
            } else {
              options.type = opt[0];
            }
          } else options.type = opt[0];
          return;
        case 'nature':
        case 'naturel':
          options.nature = true;
          return;
        case 'vampirise':
          var vampirise = 100;
          if (opt.length > 1) {
            vampirise = parseInt(opt[1]);
            if (isNaN(vampirise)) {
              error("Il faut un pourcentage entier comme argument \xE0 --vampirise", opt);
              vampirise = 100;
            }
          }
          options.vampirise = vampirise;
          return;
        case "ignoreRD":
          if (opt.length < 2) {
            options.ignoreTouteRD = true;
            return;
          }
          options.ignoreRD = parseInt(opt[1]);
          if (isNaN(options.ignoreRD) || options.ignoreRD < 1) {
            log("Pas un nombre positif apr\xE8s --ignoreRD, interpr\xE9t\xE9 comme ignore toute la RD");
            options.ignoreRD = undefined;
            options.ignoreTouteRD = true;
          }
          return;
        case 'attaquant':
          if (opt.length < 2) {
            error("Manque l'id de l'attaquant, option ignor\xE9e", optArgs);
            return;
          }
          var attaquant = persoOfId(opt[1]);
          if (attaquant) {
            options.attaquant = attaquant;
            return;
          }
          error("Attaquant non trouv\xE9", opt);
          return;
        case 'titre':
          if (opt.length < 2) {
            error("Il manque le message apr\xE8s --message", text);
            return;
          }
          options.titre = opt.slice(1).join(' ');
          return;
      }
    });
  }

  // Ne pas remplacer les inline rolls, il faut les afficher correctement
  function parseDmgDirects(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("cof-dmg prend les d\xE9gats en argument, avant les options",
        msg.content);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "pas de cible trouv\xE9e, action annul\xE9e", playerId);
        return;
      }
      options.aoe = true;
      parseDmgOptions(msg.content, options);
      let cibles = [];
      iterSelected(selected, function(perso) {
        cibles.push(perso);
      });
      if (options.return) return;
      //L'expression \xE0 lancer est tout ce qui est entre le premier blanc et le premier --
      let debutDmgRollExpr = msg.content.indexOf(' ') + 1;
      let dmgRollExpr = msg.content.substring(debutDmgRollExpr);
      let finDmgRollExpr = msg.content.indexOf(' --');
      if (finDmgRollExpr > debutDmgRollExpr)
        dmgRollExpr = msg.content.substring(debutDmgRollExpr, finDmgRollExpr);
      else dmgRollExpr = msg.content.substring(debutDmgRollExpr);
      dmgRollExpr = dmgRollExpr.trim();
      let dmgType = options.type || 'normal';
      let dmg = {
        type: dmgType,
        value: dmgRollExpr
      };
      if (options.maxDmg) {
        dmgRollExpr = dmgRollExpr.replace(/d([1-9])/g, "*$1");
      }
      let playerName = msg.who;
      if (playerIsGM(playerId)) playerName = 'GM';
      dmgDirects(playerId, playerName, cibles, dmg, options);
    }, options); //fin du getSelected
  }

  function copyDmgOptionsToTarget(target, options) {
    target.ignoreRD = options.ignoreRD;
    target.ignoreTouteRD = options.ignoreTouteRD;
    target.ignoreMoitieRD = options.ignoreMoitieRD;
    target.tempDmg = options.tempDmg;
    target.attaquant = options.lanceur;
  }


  function dmgDirects(playerId, playerName, cibles, dmg, options) {
    let evt;
    if (options.evt) {
      evt = options.evt;
    } else {
      evt = {
        type: 'dmgDirects'
      };
      addEvent(evt);
    }
    evt.action = {
      titre: "D\xE9g\xE2ts",
      playerId: playerId,
      playerName: playerName,
      cibles: cibles,
      dmg: dmg,
      options: options
    };
    if (options.lanceur && limiteRessources(options.lanceur, options, 'dmg', 'dmg', evt)) return;
    let action = "<b>D\xE9g\xE2ts.</b> ";
    if (options.titre) action += options.titre + "<br/>";
    if (options.partialSave) {
      action +=
        " Jet de " + options.partialSave.carac + " difficult\xE9 " + options.partialSave.seuil +
        " pour r\xE9duire les d\xE9g\xE2ts";
    }
    let display = startFramedDisplay(playerId, action);
    let tokensToProcess = cibles.length;
    let someDmgDone;
    let finalDisplay = function() {
      if (tokensToProcess == 1) {
        if (someDmgDone) {
          sendChat('', endFramedDisplay(display));
        } else {
          sendPlayer(playerName, "Aucune cible valide n'a \xE9t\xE9 s\xE9lection\xE9e");
        }
      }
      tokensToProcess--;
    };
    try {
      sendChat('', '[[' + dmg.value + ']]', function(resDmg) {
        dmg.roll = dmg.roll || resDmg[0];
        let afterEvaluateDmg = dmg.roll.content.split(' ');
        let dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
        dmg.total = dmg.roll.inlinerolls[dmgRollNumber].results.total;
        dmg.display = buildinline(dmg.roll.inlinerolls[dmgRollNumber], dmg.type, options.magique);
        cibles.forEach(function(perso) {
          if (getState(perso, 'mort')) { //pas de d\xE9g\xE2ts aux morts
            finalDisplay();
            return;
          }
          if (options.mortsVivants && !(estMortVivant(perso))) {
            sendPlayer(playerName, perso.token.get('name') + " n'est pas un mort-vivant");
            finalDisplay();
            return;
          }
          let name = perso.token.get('name');
          let explications = [];
          copyDmgOptionsToTarget(perso, options);
          dealDamage(perso, dmg, [], evt, false, options, explications, function(dmgDisplay, dmgFinal) {
            someDmgDone = true;
            addLineToFramedDisplay(display,
              name + " re\xE7oit " + dmgDisplay + " DM");
            explications.forEach(function(e) {
              addLineToFramedDisplay(display, e, 80, false);
            });
            finalDisplay();
          });
        }); //fin forEach
      }); //fin du jet de d\xE9s
    } catch (rollError) {
      error("Jet " + dmg.value + " mal form\xE9", dmg);
    }
  }

  function estElementaire(t) {
    if (t === undefined) return false;
    return (t == "feu" || t == "froid" || t == "acide" || t == "electrique");
  }

  function parseSetState(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-set-state", msg.content);
      return;
    }
    let etat = cmd[1];
    let valeur = cmd[2];
    if (valeur == 'false' || valeur == '0' || valeur == 'non' || valeur == 'no') valeur = false;
    if (valeur == 'true' || valeur == 'oui' || valeur == 'yes') valeur = true;
    if (!_.has(cof_states, etat)) {
      error("Le premier argument de !cof-set-state n'est pas un \xE9tat valide", cmd);
      return;
    }
    if (isCarac(cmd[2])) {
      if (cmd.length < 4) {
        error("Il manque la difficult\xE9 du jet de sauvegarde.", cmd);
        return;
      }
      valeur = true;
      options.saveParTour = {
        carac: cmd[2]
      };
      let opposition = persoOfId(cmd[3]);
      if (opposition) {
        options.saveParTour.difficulte = cmd[3] + ' ' + opposition.token.get('name');
      } else {
        options.saveParTour.difficulte = parseInt(cmd[3]);
        if (isNaN(options.saveParTour.difficulte)) {
          error("Difficult\xE9 du jet de sauvegarde incorrecte", cmd);
          return;
        }
      }
    }
    let cibles = [];
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        error("Pas de cible pour le changement d'\xE9tat", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        if (options.seulementVivant && estNonVivant(perso)) {
          sendPlayer(msg, "cet effet n'affecte que les cr\xE9atures vivantes", playerId);
          return;
        }
        switch (etat) {
          case 'apeure':
          case 'endormi':
            if (predicateAsBool(perso, 'liberteDAction')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            break;
          case 'paralyse':
            if (predicateAsBool(perso, 'liberteDAction')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            if ((options.magique || options.mana != undefined) &&
              predicateAsBool(perso, 'actionLibre')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            break;
          case 'immobilise':
          case 'ralenti':
            if (predicateAsBool(perso, 'liberteDAction')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            if ((options.magique || options.mana != undefined) &&
              predicateAsBool(perso, 'actionLibre')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            if (predicateAsInt(perso, 'voieDeLArchange', 1) > 1 && attributeAsBool(perso, 'formeDAnge')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            break;
          default:
        }
        cibles.push(perso);
      });
    });
    doSetState(cibles, etat, valeur, options);
  }

  function doSetState(cibles, etat, valeur, options) {
    var evt = {
      type: "set_state",
      action: {
        titre: "Interface Set State",
        cibles: cibles,
        etat: etat,
        valeur: valeur,
        options: options
      }
    };
    addEvent(evt);
    var lanceur = options.lanceur;
    if (lanceur === undefined && cibles.length == 1) lanceur = persoOfId(cibles[0].token.id);
    if (limiteRessources(lanceur, options, etat, etat, evt)) return;
    if (options.messages) {
      options.messages.forEach(function(m) {
        if (lanceur) sendPerso(lanceur, m, options.secret);
        else sendChat('', m);
      });
    }
    cibles.forEach(function(perso) {
      function setEffect() {
        setState(perso, etat, valeur, evt);
        if (options.saveParTour) {
          setTokenAttr(perso, etat + 'Save', options.saveParTour.carac, evt, {
            maxVal: options.saveParTour.difficulte
          });
        }
      }
      if (options.save) {
        var saveOpts = {
          msgPour: " pour r\xE9sister \xE0 l'effet " + stringOfEtat(etat),
          msgRate: ", rat\xE9.",
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: options.type
        };
        var expliquer = function(s) {
          sendPerso(perso, s);
        };
        var saveId = 'effet_' + etat + '_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt, function(reussite, rollText) {
          if (!reussite) {
            setEffect();
          }
        });
      } else {
        setEffect();
      }
    });
  }

  function textOfSaveState(etat, perso) {
    switch (etat) {
      case 'immobilise':
        return "se lib\xE9rer";
      case 'aveugle':
        return "retrouver la vue";
      case 'etourdi':
        return "reprendre ses esprits";
      case 'assomme':
        return "reprendre conscience";
      case 'renverse':
        return "se relever";
      case 'endormi':
        return "se r\xE9veiller";
      case 'apeure':
        return "retrouver du courage";
      case 'enseveli':
        return "sortir de terre";
      default:
        return "ne plus \xEAtre " + stringOfEtat(etat, perso);
    }
  }

  function parseSaveState(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 4 || !_.has(cof_states, cmd[1])) {
      error("Param\xE8tres de !cof-save-state incorrects", cmd);
      return;
    }
    var etat = cmd[1];
    var carac = cmd[2];
    var carac2;
    if (!isCarac(carac)) {
      if (carac.length == 6) {
        carac2 = carac.substring(3, 6);
        carac = carac.substring(0, 3);
        if (!isCarac(carac) || !isCarac(carac)) {
          error("Param\xE8tres de !cof-save-state incorrects", cmd);
          return;
        }
      } else {
        error("Param\xE8tres de !cof-save-state incorrects", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Pas de token s\xE9lectionn\xE9", msg.content);
        return;
      }
      var pageId = options.pageId;
      if (pageId === undefined) {
        iterSelected(selected, function(perso) {
          if (pageId) return;
          pageId = perso.token.get('pageid');
        });
      }
      var opposant = persoOfId(cmd[3], cmd[4], pageId);
      if (opposant) {
        iterSelected(selected, function(perso) {
          if (!getState(perso, etat)) {
            sendPerso(perso, "n'est pas " + stringOfEtat(etat, perso));
            return;
          }
          doSaveState(playerId, perso, etat, carac, options, opposant);
        });
      } else {
        var seuil = parseInt(cmd[3]);
        if (isNaN(seuil)) {
          error("La difficult\xE9 n'est pas un nombre", cmd);
          return;
        }
        iterSelected(selected, function(perso) {
          if (!getState(perso, etat)) {
            sendPerso(perso, "n'est pas " + stringOfEtat(etat, perso));
            return;
          }
          if (carac2) carac = meilleureCarac(carac, carac2, perso, seuil);
          doSaveState(playerId, perso, etat, carac, options, undefined, seuil);
        });
      }
    });
  }

  function doSaveState(playerId, perso, etat, carac, options, opposant, seuil) {
    var evt = {
      type: "save_state",
      action: {
        titre: "Interface Save State",
        perso: perso,
        etat: etat,
        carac: carac,
        options: options,
        opposant: opposant,
        seuil: seuil,
        playerId: playerId
      }
    };
    addEvent(evt);
    var titre = "Jet de " + carac + " pour " + textOfSaveState(etat, perso);
    if (opposant) {
      var display = startFramedDisplay(playerId, titre, perso, {
        perso2: opposant
      });
      var explications = [];
      var rollId = 'saveState_' + perso.token.id;
      testOppose(rollId, perso, carac, options, opposant, carac,
        options, explications, evt,
        function(resultat, crit, rt1, rt2) {
          if (resultat == 2) {
            explications.push(perso.token.get('name') + " est toujours " + stringOfEtat(etat, perso));
          } else {
            setState(perso, etat, false, evt);
            explications.push(perso.token.get('name') + " n'est plus " + stringOfEtat(etat, perso));
          }
          explications.forEach(function(e) {
            addLineToFramedDisplay(display, e);
          });
          sendChat("", endFramedDisplay(display));
        });
    } else {
      var testId = 'saveState_' + carac + seuil;
      testCaracteristique(perso, carac, seuil, testId, options, evt, function(res) {
        sendPerso(perso, titre);
        if (res.reussite) {
          setState(perso, etat, false, evt);
          sendPerso(perso, res.texte + " &ge; " + seuil + ", " + perso.token.get('name') + " n'est plus " + stringOfEtat(etat, perso) + res.modifiers);
        } else {
          sendPerso(perso, res.texte + " &lt; " + seuil + ", " + perso.token.get('name') + " est toujours " + stringOfEtat(etat, perso) + res.rerolls + res.modifiers);
        }
      });
    }
  }

  //Renvoie false si le personnage n'a pas d'attribut etatSave
  function boutonSaveState(perso, etat) {
    var attr = tokenAttribute(perso, etat + 'Save');
    if (attr.length === 0) return false;
    attr = attr[0];
    var carac = attr.get('current');
    var action = "!cof-save-state " + etat + ' ' + carac + ' ' + attr.get('max');
    if (etat == 'enseveli') action += " --bonus ?{Bonus au jet}";
    var b = bouton(action, "Jet", perso);
    return b + " pour " + textOfSaveState(etat, perso);
  }

  function updateInit(token, evt) {
    if (stateCOF.combat &&
      token.get('pageid') == stateCOF.combat_pageid)
      initiative([{
        _id: token.id
      }], evt, true);
  }

  function updateNextInit(perso) {
    updateNextInitSet.add(perso.token.id);
  }

  function parseDegainer(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("commande non form\xE9e", msg.content);
      return;
    }
    let armeLabel = '';
    if (cmd.length > 1) armeLabel = cmd[1];
    if (cmd.length > 2 && cmd[2] == 'gauche') options.gauche = true;
    let personnages = [];
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("Qui doit d\xE9gainer ?", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        personnages.push(perso);
      });
    });
    doDegainer(personnages, armeLabel, options);
  }

  function doDegainer(persos, labelArme, options) {
    const evt = {
      type: "degainer",
      attributes: [],
      action: {
        persos: persos,
        armeLabel: labelArme,
        options: options
      }
    };
    addEvent(evt);
    if (options.son) playSound(options.son);
    persos.forEach(function(perso) {
      function afterSave() {
        let nomArme = degainerArme(perso, labelArme, evt, options);
        if (nomArme) sendPerso(perso, "a d\xE9j\xE0 " + nomArme + " en main");
        else if (options.montreActions && persos.length === 1)
          turnAction(perso);
      }
      if (options.save) {
        let saveOpts = {
          msgPour: " pour garder son arme en main",
          msgRate: ", rat\xE9.",
          rolls: options.rolls,
          chanceRollId: options.chanceRollId
        };
        let expliquer = function(s) {
          sendPerso(perso, s);
        };
        var saveId = 'garderArme_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt, function(reussite, rollText) {
          if (!reussite) {
            afterSave();
          }
        });
      } else {
        afterSave();
      }
    });
  }

  function echangeInit(msg) {
    var args = msg.content.split(" ");
    if (args.length < 4) {
      error("Pas assez d'arguments pour !cof-echange-init: " + msg.content, args);
      return;
    }
    var perso1 = persoOfId(args[1], args[1]);
    if (perso1 === undefined) {
      error("le premier argument n'est pas un token valide", args[1]);
      return;
    }
    var perso2 = persoOfId(args[2], args[2]);
    if (perso2 === undefined) {
      error("le second argument n'est pas un token valide", args[2]);
      return;
    }
    var attackBonus = parseInt(args[3]);
    if (isNaN(attackBonus) || attackBonus < 1 || attackBonus > 2) {
      error("Le troisi\xE8me argument n'est pas un nombre", args[3]);
      return;
    }
    var evt = {
      type: "echange_init"
    };
    var to = getTurnOrder(evt);
    var tourTok1 = to.pasAgi.findIndex(function(t) {
      return (t.id == perso1.token.id);
    });
    var tourTok2 = to.pasAgi.findIndex(function(t) {
      return (t.id == perso2.token.id);
    });
    if (tourTok1 < 0) {
      sendPerso(perso1, "a d\xE9j\xE0 agit, pas moyen d'\xE9changer son initiative");
      return;
    }
    if (tourTok2 < 0) {
      sendPerso(perso2, "a d\xE9j\xE0 agit, pas moyen d'\xE9changer son initiative");
      return;
    }
    var pr1 = to.pasAgi[tourTok1].pr;
    var pr2 = to.pasAgi[tourTok2].pr;
    if (pr1 == pr2) {
      sendPerso(perso1, "a la m\xEAme initiative que " + perso2.token.get('name'));
      return;
    }
    if (pr1 > pr2) {
      setTokenAttr(perso1, 'actionConcertee', attackBonus, evt, {
        msg: "gagne un bonus de " + attackBonus + " \xE0 ses attaques et en DEF pour ce tour"
      });
      setActiveToken(perso2.token.id, evt);
    } else {
      setActiveToken(perso1.token.id, evt);
    }
    to.pasAgi[tourTok1].pr = pr2;
    to.pasAgi[tourTok2].pr = pr1;
    var t1 = to.pasAgi[tourTok1];
    to.pasAgi[tourTok1] = to.pasAgi[tourTok2];
    to.pasAgi[tourTok2] = t1;
    updateNextInit(perso1);
    updateNextInit(perso2);
    to.pasAgi.push(to.tour);
    var turnOrder = to.pasAgi.concat(to.dejaAgi);
    Campaign().set('turnorder', JSON.stringify(turnOrder));
    addEvent(evt);
  }

  function aCouvert(msg) {
    var args = msg.content.split(" ");
    if (args.length < 2) {
      error("Pas assez d'arguments pour !cof-a-couvert: " + msg.content, args);
      return;
    }
    var perso1 = persoOfId(args[1], args[1]);
    if (perso1 === undefined) {
      error("Le premier argument n'est pas un token valide", args[1]);
      return;
    }
    var evt = {
      type: "aCouvert"
    };
    var init = getInit();
    var secret = args.some(function(arg) {
      return arg == '--secret';
    });
    setTokenAttr(perso1, 'aCouvert', 1, evt, {
      msg: "reste \xE0 couvert",
      maxVal: init,
      secret: secret
    });
    if (args.length > 2) {
      var perso2 = persoOfId(args[2], args[2]);
      if (perso2 === undefined) {
        error("Le second argument n'est pas un token valide", args[2]);
        addEvent(evt);
        return;
      }
      if (perso2.token.id == perso1.token.id) {
        if (secret) {
          whisperChar(perso1.charId, "s'est cibl\xE9 lui-m\xEAme, il est donc le seul \xE0 couvert");
        } else {
          sendPerso(perso1, "s'est cibl\xE9 lui-m\xEAme, il est donc le seul \xE0 couvert");
        }
        addEvent(evt);
        return;
      }
      var d = distanceCombat(perso1.token, perso2.token);
      if (d > 0) {
        if (secret) {
          whisperChar(perso2.charId, "est trop \xE9loign\xE9 de " + perso1.token.get('name') + " pour rester \xE0 couvert avec lui");
        } else {
          sendPerso(perso2, "est trop \xE9loign\xE9 de " + perso1.token.get('name') + " pour rester \xE0 couvert avec lui");
        }
      } else {
        setTokenAttr(perso2, 'aCouvert', 1, evt, {
          msg: "suit " + perso1.token.get('name') + " et reste \xE0 couvert",
          maxVal: init,
          secret: secret
        });
      }
    }
    addEvent(evt);
  }

  function getInit() {
    return stateCOF.init;
  }

  function parseEffetTemporaire(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-effet-temp", msg.content);
      return;
    }
    let effet = cmd[1];
    let lanceur = options.lanceur;
    let charId;
    if (lanceur) charId = lanceur.charId;
    if (cof_states[effet]) { //remplacer par sa version effet temporaire
      effet += 'Temp';
    }
    if (effet == 'forgeron' || effet == 'armeEnflammee') {
      //Compl\xE9ter description de l'effet
      if (!lanceur) {
        error("Pas de lanceur pour forgeron ou armeEnflammee", msg.content);
        return;
      }
      let armeActuelle = tokenAttribute(lanceur, 'armeEnMain');
      if (armeActuelle.length === 0) {
        whisperChar(charId, "Pas d'arme en main, impossible de savoir quoi enflammer.");
        return;
      }
      let labelArme = armeActuelle[0].get('current');
      effet = effet + '(' + labelArme + ')';
    } else if (!estEffetTemp(effet)) {
      error(effet + " n'est pas un effet temporaire r\xE9pertori\xE9", msg.content);
      return;
    }
    if (!options.type && options.valeurMax && effet.startsWith('dotGen(')) {
      options.type = options.valeurMax;
    }
    let pp = effet.indexOf('(');
    let mEffet = (pp > 0) ? messageEffetTemp[effet.substring(effet, pp)] : messageEffetTemp[effet];
    if (mEffet === undefined) {
      error("Impossible de trouver l'effet " + effet, cmd);
      return;
    }
    let duree = parseInt(cmd[2]);
    if (isNaN(duree) || duree < 1) duree = 0; //On veut terminer l'effet
    if (options.puissantDuree || options.tempeteDeManaDuree) duree = duree * 2;
    getSelected(msg, function(selected, playerId, aoe) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lection\xE9e pour l'effet", playerId);
        return;
      }
      options.aoe = aoe;
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine de l'effet", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) {
            options.lanceur = lanceur;
            charId = lanceur.charId;
          }
        }
      }
      if (lanceur && options.tempeteDeMana) {
        if (duree > 0 && options.tempeteDeMana.cout === 0) {
          //On demande de pr\xE9ciser les options
          let optMana = {
            mana: options.mana,
            dm: mEffet.dm,
            soins: mEffet.soins,
            portee: options.portee,
            duree: true,
            rang: options.rang,
            altruiste: options.altruiste
          };
          setTempeteDeMana(playerId, lanceur, msg.content, optMana);
          return;
        } else {
          if (options.rang && options.tempeteDeMana.cout > options.rang) {
            sendPlayer(msg, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
          }
          if (selected.length == 1 && options.tempeteDeMana.altruiste) {
            selected[0]._id = options.tempeteDeMana.altruiste.token.id;
            if (options.portee === undefined) options.portee = 0;
          }
        }
      }
      let cibles = [];
      iterSelected(selected, function(perso) {
        if (options.portee !== undefined) {
          if (options.puissantPortee || options.tempeteDeManaPortee) options.portee = options.portee * 2;
          var dist = distanceCombat(lanceur.token, perso.token);
          if (dist > options.portee) {
            sendPerso(perso, " est trop loin de " + perso.token.get('name'));
            return;
          }
        }
        if ((mEffet.seulementVivant || options.seulementVivant) &&
          estNonVivant(perso)) {
          sendPlayer(msg, "cet effet n'affecte que les cr\xE9atures vivantes", playerId);
          return;
        }
        if (predicateAsBool(perso, 'liberteDAction') &&
          (effet == 'confusion ' ||
            effet == 'charme ' ||
            effet == 'prisonVegetale' ||
            effet == 'toiles' ||
            effet == 'foretVivanteEnnemie' ||
            ((options.magique || options.mana != undefined) &&
              (effet == 'apeureTemp' ||
                effet == 'endormiTemp' ||
                effet == 'etourdiTemp' ||
                effet == 'immobiliseTemp' ||
                effet == 'paralyseTemp' ||
                effet == 'paralyseGoule' ||
                effet == 'ralentiTemp'))
          )) {
          sendPerso(perso, "reste libre de ses mouvements !");
          return;
        }
        if ((options.magique || options.mana != undefined) &&
          ((predicateAsBool(perso, 'actionLibre') &&
              (effet == 'immobiliseTemp' ||
                effet == 'paralyseTemp' ||
                effet == 'paralyseGoule' ||
                effet == 'ralentiTemp' ||
                effet == 'toiles')) ||
            (mEffet.entrave && effet != 'paralyseTemp' && effet != 'paralyseGoule' && predicateAsInt(perso, 'voieDeLArchange', 1) > 1 && attributeAsBool(perso, 'formeDAnge'))
          )) {
          sendPerso(perso, "reste libre de ses mouvements !");
          return;
        }
        cibles.push(perso);
      });
      if (cibles.length == 0) {
        return;
      }
      effetTemporaire(playerId, cibles, effet, mEffet, duree, options);
    }, options);
  }

  function activerEffetTemporaire(playerId, lanceur, cibles, effet, mEffet, duree, options, evt, whisper, explications, display) {
    let ef = {
      effet: effet,
      duree: duree,
      acumuleDuree: options.accumuleDuree,
      typeDmg: options.type,
      message: mEffet,
      valeur: options.valeur,
      valeurMax: options.valeurMax,
      saveParTour: options.saveParTour,
      whisper: whisper,
      attaquant: options.lanceur,
      options: options.optionsEffet
    };
    if (display) ef.whisper = undefined;
    let entreEnCombat = false;
    let nbCibles = cibles.length;
    let finalize = function() {
      nbCibles--;
      if (nbCibles === 0) { //affichage
        if (display) {
          cibles.forEach(function(cible) {
            if (cible.messages.length > 0) {
              if (cibles.length > 1 || !lanceur || cible.token.id != lanceur.token.id)
                addLineToFramedDisplay(display, "<b>" + cible.token.get('name') + "</b> :");
              cible.messages.forEach(function(expl) {
                addLineToFramedDisplay(display, expl, 80);
              });
            }
          });
          explications.forEach(function(e) {
            addLineToFramedDisplay(display, e);
          });
          sendChat('', endFramedDisplay(display));
        } else {
          explications.forEach(function(e) {
            sendChat('', e);
          });
        }
      }
    };
    let setOneEffect = function(perso, d) {
      let expliquer = function(m) {
        if (display) {
          perso.messages.push(m);
        } else sendPerso(perso, m, options.secret);
      };
      if (options.limiteCibleParJour) {
        let ressource = effet;
        if (options.limiteCibleParJourRessource)
          ressource = options.limiteCibleParJourRessource;
        ressource = "limiteParJour_" + ressource;
        let utilisations = attributeAsInt(perso, ressource, options.limiteCibleParJour);
        if (utilisations === 0) {
          expliquer("ne peut plus b\xE9n\xE9ficier de " + effet + " aujourd'hui");
          return;
        }
        setTokenAttr(perso, ressource, utilisations - 1, evt);
      }
      if (!entreEnCombat) {
        entreEnCombat = true;
        if (mEffet.dm || mEffet.prejudiciable) {
          entrerEnCombat(lanceur, cibles, explications, evt);
        } else { //On met juste dans la liste d'initiative
          let ini = [...cibles];
          if (lanceur) ini.push(lanceur);
          entrerEnCombat(undefined, ini, explications, evt);
        }
        if (options.aoe && options.pageId && effet == 'prisonVegetale' && options.aoe.type == 'disque') {
          if (lanceur) {}
          let diametre = options.aoe.rayon * 2 * PIX_PER_UNIT / computeScale(options.pageId);
          let t = createObj('graphic', {
            _pageid: options.pageId,
            imgsrc: stateCOF.options.images.val.prison_vegetale.val,
            represents: '',
            left: options.aoe.centre.get('left'),
            top: options.aoe.centre.get('top'),
            width: diametre,
            height: diametre,
            layer: 'map',
            isDrawing: true,
            name: 'Prison v\xE9g\xE9tale'
          });
          if (t) {
            toFront(t);
            evt.tokens = evt.tokens || [];
            evt.tokens.push(t);
            stateCOF.tokensTemps = stateCOF.tokensTemps || [];
            stateCOF.tokensTemps.push({
              tid: t.id,
              duree,
              init: getInit()
            });
          }
        }
      }
      if (display) perso.tokName = perso.tokName || perso.token.get('name');
      setEffetTemporaire(perso, ef, d, evt, options);
      if (effet.startsWith('forgeron(')) {
        //Il faut d\xE9gainer l'arme si elle n'est pas en main, et ajouter une lumi\xE8re
        let labelArmeForgeron = effet.substring(9, effet.indexOf(')'));
        degainerArme(perso, labelArmeForgeron, evt);
        let feu = getValeurOfEffet(perso, effet, 1, 'voieDuMetal');
        ajouteUneLumiere(perso, effet, feu * 3, feu, evt);
      } else if (effet.startsWith('armeEnflammee(')) {
        let labelArmeEnflammee = effet.substring(14, effet.indexOf(')'));
        degainerArme(perso, labelArmeEnflammee, evt);
        ajouteUneLumiere(perso, effet, 9, 3, evt);
      }
      if (effet == 'cercleDeProtection') {
        let protecteur = options.lanceur || perso;
        if (!attributeAsBool(protecteur, 'cercleDeProtectionActif')) {
          setTokenAttr(protecteur, 'cercleDeProtectionActif', 1, evt, {
            maxVal: 1
          });
        }
      }
      if (effet == 'armeeDesMorts') {
        stateCOF.armeesDesMorts = stateCOF.armeesDesMorts || [];
        stateCOF.armeesDesMorts.push(perso.token.id);
      }
      if (options.puissant) {
        let puissant = (options.puissant != 'off');
        setTokenAttr(perso, effet + 'Puissant', puissant, evt);
      }
      if (lanceur && options.fx) {
        let p1e = {
          x: lanceur.token.get('left'),
          y: lanceur.token.get('top'),
        };
        let p2e = {
          x: perso.token.get('left'),
          y: perso.token.get('top'),
        };
        spawnFxBetweenPoints(p1e, p2e, options.fx, options.pageId);
      }
      if (options.son) playSound(options.son);
      if (options.targetFx) {
        spawnFx(perso.token.get('left'), perso.token.get('top'), options.targetFx, options.pageId);
      }
      finalize();
    };
    cibles.forEach(function(perso) {
      if (display) perso.messages = [];
      let expliquer = function(s) {
        if (display) perso.messages.push(s);
        else sendPerso(perso, s);
      };
      if (options.type && immuniseAuType(perso, options.type, lanceur)) {
        expliquer("ne semble pas affect\xE9 par " + stringOfType(options.type));
        finalize();
        return;
      }
      if (options.save) {
        let saveOpts = {
          msgPour: " pour r\xE9sister \xE0 l'effet " + effet,
          msgRate: ", rat\xE9.",
          attaquant: lanceur,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: options.type
        };
        options.save.entrave = mEffet.entrave;
        let d = duree;
        let saveId = 'effet_' + effet + "_" + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt,
          function(reussite, rollText) {
            if (reussite && options.save.demiDuree) {
              reussite = false;
              d = Math.ceil(d / 2);
            }
            if (reussite) finalize();
            else setOneEffect(perso, d);
          });
      } else {
        setOneEffect(perso, duree);
      }
    });
  }

  function porteArmure(perso) {
    return ficheAttributeAsBool(perso, 'defarmureon', false) ||
      ficheAttributeAsBool(perso, 'defbouclieron', false);
  }

  function effetTemporaire(playerId, cibles, effet, mEffet, duree, options) {
    const evt = {
      type: 'effetTemp',
      action: {
        titre: "Effet Temporaire",
        playerId: playerId,
        cibles: cibles,
        effet: effet,
        mEffet: mEffet,
        duree: duree,
        options: options
      }
    };
    let lanceur = options.lanceur;
    let explications = options.messages || [];
    let whisper = '';
    if (options.secret && playerId) {
      let player = getObj('player', playerId);
      if (player !== undefined) {
        whisper = '/w "' + player.get('displayname') + '" ';
      }
    }
    addEvent(evt);
    if (limiteRessources(lanceur, options, effet, effet, evt)) return;
    if (duree > 0) {
      if (options.magieEnArmure && lanceur && porteArmure(lanceur)) {
        lanceur.tokName = lanceur.tokName || lanceur.token.get('name');
        let display = startFramedDisplay(playerId, "Sort en armure", lanceur, options);
        let difficulte = 10;
        if (options.magieEnArmure.base) difficulte = options.magieEnArmure.base;
        else if (options.rang) difficulte = 10 + options.rang;
        else difficulte = 11;
        difficulte += malusArmure(lanceur);
        let testId = 'magieEnArmure_' + lanceur.token.id;
        testCaracteristique(lanceur, 'INT', difficulte, testId, options, evt,
          function(tr) {
            let line = "Jet d'INT : " + tr.texte;
            if (tr.reussite) {
              line += '&ge; ' + difficulte;
              addLineToFramedDisplay(display, line);
              activerEffetTemporaire(playerId, lanceur, cibles, effet, mEffet, duree, options, evt, whisper, explications, display);
            } else {
              line += '&lt; ' + difficulte + ", le sort est rat\xE9";
              addLineToFramedDisplay(display, line);
              sendChat('', endFramedDisplay(display));
            }
          });
      } else {
        activerEffetTemporaire(playerId, lanceur, cibles, effet, mEffet, duree, options, evt, whisper, explications);
      }
    } else { //On met fin \xE0 l'effet
      explications.forEach(function(e) {
        sendChat('', e);
      });
      let opt = {
        pageId: options.pageId
      };
      cibles.forEach(function(perso) {
        let attr = tokenAttribute(perso, effet);
        if (attr.length === 0) {
          log(perso.token.get('name') + " n'a pas d'attribut " + effet);
          return;
        }
        finDEffet(attr[0], effetTempOfAttribute(attr[0]), attr[0].get('name'), perso.charId, evt, opt);
      });
    }
    if (options.montreActions && cibles.length === 1)
      turnAction(cibles[0], playerId);
  }

  function effetCombat(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-effet-combat", msg.content);
      return;
    }
    var effet = cmd[1];
    if (!estEffetCombat(effet)) {
      error(effet + " n'est pas un effet de combat r\xE9pertori\xE9", msg.content);
      return;
    }
    var evt = {
      type: 'Effet ' + effet
    };
    var lanceur = options.lanceur;
    var charId;
    if (lanceur) charId = lanceur.charId;
    getSelected(msg, function(selected, playerId) {
      var whisper = '';
      if (options.secret) {
        let player;
        if (playerId) player = getObj('player', playerId);
        if (player !== undefined) {
          whisper = '/w "' + player.get('displayname') + '" ';
        }
      }
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lection\xE9e pour l'effet", playerId);
        return;
      }
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine de l'effet", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) charId = lanceur.charId;
        }
      }
      if (lanceur && options.tempeteDeMana) {
        if (options.tempeteDeMana.cout === 0) {
          //On demande de pr\xE9ciser les options
          var optMana = {
            mana: options.mana,
            dm: messageEffetCombat[effet].dm,
            soins: messageEffetCombat[effet].soins,
            portee: options.portee,
            altruiste: options.altruiste,
            rang: options.rang
          };
          setTempeteDeMana(playerId, lanceur, msg.content, optMana);
          return;
        } else {
          if (options.rang && options.tempeteDeMana.cout > options.rang) {
            sendPerso(lanceur, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort", options.secret);
          }
          if (selected.length == 1 && options.tempeteDeMana.altruiste) {
            selected[0]._id = options.tempeteDeMana.altruiste.token.id;
            if (options.portee === undefined) options.portee = 0;
          }
        }
      }
      if (options.portee !== undefined) {
        if (options.puissantPortee || options.tempeteDeManaPortee) options.portee = options.portee * 2;
        selected = selected.filter(function(sel) {
          var token = getObj('graphic', sel._id);
          var dist = distanceCombat(lanceur.token, token);
          if (dist > options.portee) {
            whisperChar(charId, " est trop loin de " + token.get('name'));
            return false;
          }
          return true;
        });
      }
      if (selected.length === 0) return;
      if (limiteRessources(lanceur, options, effet, effet, evt)) {
        addEvent(evt);
        return;
      }
      initiative(selected, evt);
      var mEffet = messageEffetCombat[effet];
      var actMsg = mEffet.activation;
      var img = options.image;
      if (img !== "" && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
        var newLineimg = '<span style="padding: 4px 0;" >  ';
        newLineimg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
        newLineimg += '</span>';
        actMsg += newLineimg;
      }
      iterSelected(selected, function(perso) {
        if (effet == 'blessureQuiSaigne' && predicateAsBool(perso, 'immuniteSaignement')) {
          sendPerso(perso, "ne saigne pas");
          return;
        }
        var effetAttr = setTokenAttr(perso, effet, true, evt, {
          msg: whisper + actMsg
        });
        if (options.lanceur && options.mana !== undefined && mEffet.prejudiciable) {
          addEffetTemporaireLie(options.lanceur, effetAttr, evt);
        }
        if (options.puissant) {
          let puissant = (options.puissant != 'off');
          setTokenAttr(perso, effet + 'Puissant', puissant, evt);
        }
        if (options.valeur !== undefined) {
          setTokenAttr(perso, effet + 'Valeur', options.valeur, evt, {
            maxVal: options.valeurMax
          });
        }
        if (options.optionsEffet !== undefined) {
          setTokenAttr(perso, effet + 'Options', options.optionsEffet, evt);
        }
        if (options.saveParTour) {
          setTokenAttr(perso, effet + 'SaveParTour', options.saveParTour.carac, evt, {
            maxVal: options.saveParTour.seuil
          });
        }
        if (options.tempeteDeManaIntense !== undefined) {
          setTokenAttr(perso, effet + "TempeteDeManaIntense", options.tempeteDeManaIntense, evt);
        }
      });
      addEvent(evt);
      if (lanceur && options.fx) {
        iterSelected(selected, function(target) {
          var p1e = {
            x: lanceur.token.get('left'),
            y: lanceur.token.get('top'),
          };
          var p2e = {
            x: target.token.get('left'),
            y: target.token.get('top'),
          };
          spawnFxBetweenPoints(p1e, p2e, options.fx, options.pageId);
        });
      }
      if (options.son) playSound(options.son);
      if (options.targetFx) {
        iterSelected(selected, function(target) {
          spawnFx(target.token.get('left'), target.token.get('top'), options.targetFx, options.pageId);
        });
      }
      if (options.degainer !== undefined) {
        if (lanceur) {
          degainerArme(lanceur, options.degainer, evt);
        } else if (selected.length === 1) {
          iterSelected(selected, function(target) {
            degainerArme(target, options.degainer, evt);
          });
        }
      }
      if (options.montreActions) {
        if (lanceur) {
          turnAction(lanceur, playerId);
        } else if (selected.length === 1) {
          iterSelected(selected, function(target) {
            turnAction(target, playerId);
          });
        }
      }
    });
  }

  function effetIndetermine(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-effet", msg.content);
      return;
    }
    var effet = cmd[1];
    if (!estEffetIndetermine(effet)) {
      error(effet + " n'est pas un effet r\xE9pertori\xE9", msg.content);
      return;
    }
    let activer;
    let valeur;
    switch (cmd[2]) {
      case 'oui':
      case 'Oui':
      case 'true':
      case 'd\xE9but':
      case 'debut':
        activer = true;
        break;
      case 'non':
      case 'Non':
      case 'false':
      case 'fin':
        activer = false;
        break;
      default:
        valeur = parseInt(cmd[2]);
        if (isNaN(valeur)) {
          error("Option de !cof-effet inconnue", cmd);
          return;
        }
        activer = valeur !== 0;
    }
    const evt = {
      type: 'Effet ' + effet
    };
    var lanceur = options.lanceur;
    var charId;
    if (lanceur) charId = lanceur.charId;
    getSelected(msg, function(selected, playerId) {
      var whisper = '';
      if (options.secret) {
        var player;
        if (playerId) player = getObj('player', playerId);
        if (player !== undefined) {
          whisper = '/w "' + player.get('displayname') + '" ';
        }
      }
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lection\xE9e pour l'effet", playerId);
        return;
      }
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine de l'effet", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) charId = lanceur.charId;
        }
      }
      if (options.portee !== undefined) {
        selected = selected.filter(function(sel) {
          var token = getObj('graphic', sel._id);
          var dist = distanceCombat(lanceur.token, token);
          if (dist > options.portee) {
            whisperChar(charId, " est trop loin de " + token.get('name'));
            return false;
          }
          return true;
        });
      }
      if (selected.length === 0) return;
      if (activer) {
        if (limiteRessources(lanceur, options, effet, effet, evt)) {
          addEvent(evt);
          return;
        }
        if (options.classeEffet) {
          selected = selected.filter(function(sel) {
            var perso = persoOfId(sel._id);
            if (perso === undefined) return false;
            if (attributeAsBool(perso, options.classeEffet)) {
              var attrDeClasse = attributesOfClass(perso, options.classeEffet);
              var mpc = "Non cumulable avec";
              attrDeClasse.forEach(function(attrClasseEffet) {
                var attr = attrClasseEffet.baseAttribute;
                var attrName = attr.get('name');
                if (estEffetIndetermine(attrName))
                  mpc += ' ' + messageEffetIndetermine[effetIndetermineOfAttribute(attr)].actif;
                else mpc += ' ' + attrName;
              });
              sendPerso(perso, mpc, options.secret);
              return false;
            }
            setTokenAttr(perso, options.classeEffet, true, evt);
            setTokenAttr(perso, effet + 'ClasseEffet', options.classeEffet, evt);
            return true;
          });
        }
        let msgEffet = whisper + messageEffetIndetermine[effet].activation;
        let val = (valeur === undefined) ? true : valeur;
        iterSelected(selected, function(perso) {
          if (valeur !== undefined && (cmd[2].startsWith('+') || valeur < 0)) {
            addToAttributeAsInt(perso, effet, 0, valeur, evt);
            sendPerso(perso, effet + " varie de " + valeur, options.secret);
          } else {

            setTokenAttr(
              perso, effet, val, evt, {
                msg: msgEffet
              });
            switch (effet) {
              case 'foretVivanteEnnemie':
                if (stateCOF.combat) updateNextInit(perso);
                break;
              case 'sangDeLArbreCoeur':
                guerisonPerso(perso, evt);
                break;
            }
          }
          if (options.puissant) {
            let puissant = (options.puissant != 'off');
            setTokenAttr(perso, effet + 'Puissant', puissant, evt);
          }
          if (options.valeur !== undefined) {
            setTokenAttr(perso, effet + 'Valeur', options.valeur, evt, {
              maxVal: options.valeurMax
            });
          }
          if (options.tempeteDeManaIntense !== undefined) {
            setTokenAttr(perso, effet + 'TempeteDeManaIntense', options.tempeteDeManaIntense, evt);
          }
        });
      } else {
        iterSelected(selected, function(perso) {
          //On commence par enlever les attributs de classe d'effet, si besoin
          var ace = tokenAttribute(perso, effet + 'ClasseEffet');
          if (ace.length > 0) {
            var ce = ace[0].get('current');
            removeTokenAttr(perso, ce, evt);
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(ace[0]);
            ace[0].remove();
          }
          removeTokenAttr(perso, effet, evt, {
            msg: messageEffetIndetermine[effet].fin
          });
          removeTokenAttr(perso, effet + 'Puissant', evt);
          removeTokenAttr(perso, effet + 'Valeur', evt);
          removeTokenAttr(perso, effet + 'TempeteDeManaIntense', evt);
          removeTokenAttr(perso, effet + 'Options', evt);
          if (effet == 'foretVivanteEnnemie' && stateCOF.combat) {
            updateNextInit(perso);
          }
        });
      }
      addEvent(evt);
    });
  }

  function finClasseDEffet(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il manque l'argument de !cof-fin-classe-effet", cmd);
      return;
    }
    var classeEffet = cmd[1];
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("Pas de cible s\xE9lectionn\xE9e pour la fin d'une classe d'effets", msg);
        return;
      }
      var evt = {
        type: "Fin des effets de classe " + classeEffet,
        deletedAttributes: []
      };
      iterSelected(selected, function(perso) {
        if (attributeAsBool(perso, classeEffet)) {
          var attrDeClasse = attributesOfClass(perso, classeEffet);
          attrDeClasse.forEach(function(adc) {
            var attrName = adc.baseAttribute.get('name');
            if (estEffetIndetermine(attrName))
              sendPerso(perso, messageEffetIndetermine[effetIndetermineOfAttribute(adc.baseAttribute)].fin);
            evt.deletedAttributes.push(adc.baseAttribute);
            adc.baseAttribute.remove();
            evt.deletedAttributes.push(adc.classAttribute);
            adc.classAttribute.remove();
          });
          removeTokenAttr(perso, classeEffet, evt);
        }
      });
      addEvent(evt);
    }); //fin de getSelected
  }

  function peurOneToken(target, difficulte, duree, options, messages, evt, callback) {
    const targetName = target.token.get('name');
    if (predicateAsBool(target, 'sansPeur') ||
      predicateAsBool(target, 'immunite_peur') ||
      predicateAsBool(target, 'proprioception') ||
      predicateAsBool(target, 'sansEsprit') ||
      attributeAsBool(target, 'enrage') ||
      predicateAsBool(target, 'liberteDAction')) {
      messages.push(targetName + " est insensible \xE0 la peur !");
      callback();
      return;
    }
    var carac = 'SAG'; //carac pour r\xE9sister
    if (options.resisteAvecForce)
      carac = meilleureCarac('SAG', 'FOR', target, difficulte);
    //chercher si un partenaire a sansPeur pour appliquer le bonus
    var allieSansPeur = 0;
    var allies = alliesParPerso[target.charId];
    if (allies) {
      var pageId = options.pageId || target.token.get('pageid');
      var allTokens;
      allies.forEach(function(cid) {
        if (charPredicateAsBool(cid, 'sansPeur')) {
          //On cherche si l'alli\xE9 est pr\xE9sent sur la m\xEAme page
          allTokens = allTokens ||
            findObjs({
              _type: "graphic",
              _pageid: pageId,
              _subtype: "token",
              layer: "objects"
            });
          var alliePresent = allTokens.find(function(tok) {
            return tok.get('represents') == cid;
          });
          if (alliePresent)
            allieSansPeur = Math.max(allieSansPeur, 2 + modCarac(cid, 'charisme'));
        }
      });
    }
    var optionsPeur = {...options
    };
    optionsPeur.bonus = allieSansPeur;
    let testId = 'peurOne_' + target.token.id;
    testCaracteristique(target, carac, difficulte, testId, optionsPeur, evt,
      function(tr) {
        let line = "Jet de r\xE9sistance de " + targetName + " :" + tr.texte;
        let sujet = onGenre(target, 'il', 'elle');
        if (tr.reussite) {
          line += "&gt;=" + difficulte + ",  " + sujet + " r\xE9siste \xE0 la peur." + tr.modifiers;
        } else {
          line += "&lt;" + difficulte + ", " + sujet + ' ';
          let effet = 'apeureTemp';
          let etat = 'apeure';
          if (options.etourdi) {
            line += "s'enfuit ou reste recroquevill\xE9" + eForFemale(target) + " sur place";
            effet = 'peurEtourdi';
          } else if (options.ralenti) {
            line += "est ralenti" + eForFemale(target);
            effet = 'ralentiTemp';
            etat = 'ralenti';
          } else {
            line += "s'enfuit.";
          }
          line += tr.rerolls + tr.modifiers;
          setState(target, etat, true, evt);
          setAttrDuree(target, effet, duree, evt);
        }
        messages.push(line);
        callback();
      }); //fin testCaracteristique (asynchrone)
  }

  function parsePeur(msg) {
    var optArgs = msg.content.split(' --');
    var cmd = optArgs[0].split(' ');
    if (cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-peur", msg.content);
      return;
    }
    var playerId = getPlayerIdFromMsg(msg);
    var pageId = getPageId(playerId);
    var difficulte = parseInt(cmd[1]);
    if (isNaN(difficulte)) {
      error("Le premier argument de !cof-peur, la difficult\xE9 du test de r\xE9sistance, n'est pas un nombre", cmd);
      return;
    }
    var duree = parseInt(cmd[2]);
    if (isNaN(duree) || duree < 0) {
      error("Le second argument de !cof-peur, la dur\xE9e, n'est pas un nombre positif", cmd);
      return;
    }
    var options = {};
    options.playerId = playerId;
    options.pageId = pageId;
    optArgs.shift();
    optArgs.forEach(function(opt) {
      var optCmd = opt.split(' ');
      switch (optCmd[0]) {
        case "attaqueMagique":
          error("TODO", opt);
          return;
        case "resisteAvecForce":
        case "etourdi":
        case "ralenti":
        case "effroi":
          options[optCmd[0]] = true;
          return;
        case "portee":
          if (optCmd.length < 2) {
            error("Il manque l'argument de port\xE9e", optArgs);
            return;
          }
          options.portee = parseInt(optCmd[1]);
          if (isNaN(options.portee) || options.portee < 0) {
            error("La port\xE9e n'est pas un nombre positif", optCmd);
            delete options.portee;
          }
          return;
        case 'lanceur':
          if (optCmd.length < 2) {
            error("Il manque l'argument de lanceur", optArgs);
            return;
          }
          options.lanceur = persoOfId(optCmd[1], optCmd[1]);
          if (options.lanceur) pageId = options.lanceur.token.get('pageid');
          return;
        default:
          return;
      }
    });
    var cibles = [];
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("Pas de cible s\xE9lectionn\xE9e pour la peur", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        if (options.portee !== undefined && options.lanceur) {
          var distance = distanceCombat(options.lanceur.token, perso.token, pageId);
          if (distance > options.portee) {
            return;
          }
        }
        cibles.push(perso);
      });
    });
    if (cibles.length > 0) {
      doPeur(cibles, difficulte, duree, options);
    } else {
      error("Aucune cible valable \xE0 port\xE9e de l'effet de Peur", msg);
    }
  }

  function doPeur(cibles, difficulte, duree, options) {
    var evt = {
      type: 'peur',
      action: {
        cibles: cibles,
        difficulte: difficulte,
        duree: duree,
        options: options
      }
    };
    addEvent(evt);
    var action = "Effet de peur";
    if (options.lanceur) {
      action = "<b>" + options.lanceur.token.get('name') + "</b> ";
      if (options.effroi)
        action += "est vraiment effrayant" + eForFemale(options.lanceur);
      else action = "<b>Capacit\xE9</b> : Sort de peur";
    }
    let messages = [];
    entrerEnCombat(options.lanceur, cibles, messages, evt);
    var display = startFramedDisplay(options.playerId, action, options.lanceur);
    var counter = cibles.length;
    var finalDisplay = function() {
      if (counter == 1) {
        messages.forEach(function(message) {
          addLineToFramedDisplay(display, message);
        });
        sendChat("", endFramedDisplay(display));
      }
      counter--;
    };
    cibles.forEach(function(perso) {
      peurOneToken(perso, difficulte, duree, options, messages, evt, finalDisplay);
    });
  }

  function parseAttaqueMagique(msg, type) {
    var options = parseOptions(msg);
    if (options === undefined || options.cmd === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 3) {
      error("Il faut au moins 2 arguments \xE0 !cof-attaque-magique", cmd);
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    var cible = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined || cible === undefined) {
      error("Arguments de !cof-attaque-magique", cmd);
      return;
    }
    if (options.portee) {
      var distance = distanceCombat(attaquant.token, cible.token, options.pageId);
      if (distance > options.portee) {
        sendPerso(attaquant, "est trop loin de " + cible.token.get('name') +
          " pour l'attaque magique");
        return;
      }
    }
    type = type || '';
    switch (type) {
      case 'tueurFantasmagorique':
        tueurFantasmagorique(getPlayerIdFromMsg(msg), attaquant, cible, options);
        break;
      case 'injonction':
        injonction(getPlayerIdFromMsg(msg), attaquant, cible, options);
        break;
      default:
        attaqueMagiqueOpposee(getPlayerIdFromMsg(msg), attaquant, cible, options);
        break;
    }
  }

  // callback est seulement appel\xE9 si on fait le test
  // evt est facultatif ; si absent, en cr\xE9e un nouveau g\xE9n\xE9rique et l'ajoute \xE0 l'historique
  function attaqueMagiqueOpposee(playerId, attaquant, cible, options, callback, evt) {
    if (options.attaqueMentale) {
      if (predicateAsBool(cible, 'sansEsprit')) {
        sendPerso(attaquant, " est sans esprit, " + onGenre(cible, 'il', 'elle') +
          " est immunis\xE9" + onGenre(cible, '', 'e') + " aux attaques mentales.");
        return;
      } else if (predicateAsBool(cible, 'liberteDAction')) {
        sendPerso(cible, "reste libre de ses actions !");
        return;
      }
    }
    let explications = options.messages || [];
    if (!evt) {
      evt = {
        type: 'attaqueMagique',
        action: {
          titre: "Attaque magique",
          attaquant: attaquant,
          cible: cible,
          options: options
        }
      };
      addEvent(evt);
    } else if (!evt.action) {
      evt.action = {
        titre: "Attaque magique",
        attaquant: attaquant,
        cible: cible,
        options: options
      };
    }
    entrerEnCombat(attaquant, [cible], explications, evt);
    if (limiteRessources(attaquant, options, 'attaqueMagique', "l'attaque magique", evt)) {
      return;
    }
    let bonus1 = bonusDAttaque(attaquant, explications, evt);
    if (bonus1 === 0) bonus1 = "";
    else if (bonus1 > 0) bonus1 = " +" + bonus1;
    let attk1 = addOrigin(attaquant.token.get("name"), "[[" + computeArmeAtk(attaquant, '@{ATKMAG}') +
      bonus1 + "]]");
    let bonus2 = bonusDAttaque(cible, explications, evt);
    if (bonus2 === 0) bonus2 = "";
    else if (bonus2 > 0) bonus2 = " +" + bonus2;
    let attk2 = addOrigin(cible.token.get("name"), "[[" + computeArmeAtk(cible, '@{ATKMAG}') +
      bonus1 + "]]");
    let de1 = computeDice(attaquant);
    let de2 = computeDice(cible);
    let toEvaluate = "[[" + de1 + "]] [[" + de2 + "]] " + attk1 + " " + attk2;
    sendChat("", toEvaluate, function(res) {
      let rolls = res[0];
      options.rolls = options.rolls || {};
      // Determine which roll number correspond to which expression
      let afterEvaluate = rolls.content.split(" ");
      let att1RollNumber = rollNumber(afterEvaluate[0]);
      let att2RollNumber = rollNumber(afterEvaluate[1]);
      let attk1SkillNumber = rollNumber(afterEvaluate[2]);
      let attk2SkillNumber = rollNumber(afterEvaluate[3]);
      let roll1 = (options.rolls && options.rolls.roll1) ? options.rolls.roll1 : rolls.inlinerolls[att1RollNumber];
      let atk1 = (options.rolls && options.rolls.atk1) ? options.rolls.atk1 : rolls.inlinerolls[attk1SkillNumber];
      let roll2 = (options.rolls && options.rolls.roll2) ? options.rolls.roll2 : rolls.inlinerolls[att2RollNumber];
      let atk2 = (options.rolls && options.rolls.atk2) ? options.rolls.atk2 : rolls.inlinerolls[attk2SkillNumber];
      roll1.token = attaquant.token;
      atk1.token = attaquant.token;
      roll2.token = cible.token;
      atk2.token = cible.token;
      evt.action.rolls = evt.action.rolls || {};
      evt.action.rolls.roll1 = roll1;
      evt.action.rolls.atk1 = atk1;
      evt.action.rolls.roll2 = roll2;
      evt.action.rolls.atk2 = atk2;
      var d20roll1 = roll1.results.total;
      var att1Skill = atk1.results.total;
      if (estAffaibli(attaquant) && predicateAsBool(attaquant, 'insensibleAffaibli')) att1Skill -= 2;
      var attackRoll1 = d20roll1 + att1Skill;
      if (options.chanceRollId && options.chanceRollId.roll1)
        attackRoll1 += options.chanceRollId.roll1;
      var d20roll2 = roll2.results.total;
      var att2Skill = atk2.results.total;
      if (estAffaibli(cible) && predicateAsBool(cible, 'insensibleAffaibli')) att2Skill -= 2;
      var attackRoll2 = d20roll2 + att2Skill;
      if (options.chanceRollId && options.chanceRollId.roll2)
        attackRoll2 += options.chanceRollId.roll2;
      var action = "Attaque magique oppos\xE9e";
      var reussi;
      if (d20roll1 == 1) {
        if (d20roll2 == 1) reussi = (attackRoll1 >= attackRoll2);
        else reussi = false;
      } else if (d20roll2 == 1) reussi = true;
      else if (d20roll1 == 20) {
        if (d20roll2 == 20) reussi = (attackRoll1 >= attackRoll2);
        else reussi = true;
      } else reussi = (attackRoll1 >= attackRoll2);
      var display = startFramedDisplay(playerId, action, attaquant, {
        perso2: cible
      });
      var line = attaquant.token.get('name') + " fait " + buildinline(roll1);
      if (att1Skill > 0) line += "+" + att1Skill;
      else if (att1Skill < 0) line += att1Skill;
      if (options.chanceRollId && options.chanceRollId.roll1)
        line += "+" + options.chanceRollId.roll1;
      line += " = " + attackRoll1;
      if (!reussi) {
        var pcAttaquant = pointsDeChance(attaquant);
        if (pcAttaquant > 0)
          line += "<br/>" + boutonSimple("!cof-bouton-chance " + evt.id + " roll1", "Chance") +
          " (reste " + pcAttaquant + " PC)";
        if (predicateAsInt(attaquant, 'pacteSanglant', 0) >= 3) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 roll1", "Pacte sanglant (+3)");
        }
        if (predicateAsInt(attaquant, 'pacteSanglant', 0) >= 5) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 roll1", "Pacte sanglant (+5)");
        }
      }
      addLineToFramedDisplay(display, line);
      line = cible.token.get('name') + " fait " + buildinline(roll2);
      if (att2Skill > 0) line += "+" + att2Skill;
      else if (att2Skill < 0) line += att2Skill;
      if (options.chanceRollId && options.chanceRollId.roll2)
        line += "+" + options.chanceRollId.roll2;
      line += " = " + attackRoll2;
      if (reussi) {
        var pcCible = pointsDeChance(cible);
        if (pcCible > 0)
          line += "<br/>" + boutonSimple("!cof-bouton-chance " + evt.id + " roll2", "Chance") +
          " (reste " + pcCible + " PC)";
        if (predicateAsInt(cible, 'pacteSanglant', 0) >= 3) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 roll2", "Pacte sanglant (+3)");
        }
        if (predicateAsInt(cible, 'pacteSanglant', 0) >= 5) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 roll2", "Pacte sanglant (+5)");
        }
      }
      addLineToFramedDisplay(display, line);
      if (reussi) {
        diminueMalediction(cible, evt);
        addLineToFramedDisplay(display, "<b>Attaque r\xE9ussie !</b>");
      } else {
        diminueMalediction(attaquant, evt);
        addLineToFramedDisplay(display, "<b>L'attaque \xE9choue.</b>");
      }
      explications.forEach(explication => addLineToFramedDisplay(display, explication, 80));
      if (callback) callback(display, reussi);
      else {
        sendChat("", endFramedDisplay(display));
      }
    });
  }

  function injonction(playerId, attaquant, cible, options) {
    options.attaqueMentale = true;
    const evt = {
      type: 'injonction',
      action: {
        titre: "Injonction",
        attaquant: attaquant,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    attaqueMagiqueOpposee(playerId, attaquant, cible, options,
      function(display, reussi) {
        if (reussi) {
          if (attributeAsBool(cible, 'resisteInjonction')) {
            addLineToFramedDisplay(display, cible.token.get('name') + " a d\xE9j\xE0 r\xE9sist\xE9 \xE0 une injonction aujourd'hui, c'est sans effet");
          } else if (predicateAsBool(cible, 'liberteDAction')) {
            addLineToFramedDisplay(display, cible.token.get('name') + " reste libre de ses actions !");
          } else {
            addLineToFramedDisplay(display, cible.token.get('name') + " ob\xE9it \xE0 l'injonction");
          }
          sendChat("", endFramedDisplay(display));
        } else {
          setTokenAttr(cible, 'resisteInjonction', true, evt);
          addLineToFramedDisplay(display, cible.token.get('name') + " n'ob\xE9it pas \xE0 l'injonction");
          sendChat("", endFramedDisplay(display));
        }
      }, evt);
  }

  function tueurFantasmagorique(playerId, attaquant, cible, options) {
    var evt = {
      type: 'tueurFantasmagorique',
      action: {
        titre: "Tueur Fantasmagorique",
        attaquant: attaquant,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    attaqueMagiqueOpposee(playerId, attaquant, cible, options,
      function(display, reussi) {
        if (reussi) {
          if (estNonVivant(cible)) {
            addLineToFramedDisplay(display, cible.token.get('name') + " n'est pas une cr\xE9ature vivante, il ne peut croire \xE0 sa mort");
            sendChat("", endFramedDisplay(display));
            return;
          }
          if (attributeAsBool(cible, 'tueurFantasmagorique')) {
            addLineToFramedDisplay(display, cible.token.get('name') + " a d\xE9j\xE0 \xE9t\xE9 victime d'un tueur fantasmagorique aujourd'hui, c'est sans effet");
            sendChat("", endFramedDisplay(display));
            return;
          }
          setTokenAttr(cible, 'tueurFantasmagorique', true, evt);
          var s = {
            carac: 'SAG',
            seuil: 10 + modCarac(attaquant, 'charisme')
          };
          var niveauAttaquant = ficheAttributeAsInt(attaquant, 'niveau', 1);
          var niveauCible = ficheAttributeAsInt(cible, 'niveau', 1);
          if (niveauCible > niveauAttaquant)
            s.seuil -= (niveauCible - niveauAttaquant) * 5;
          else if (niveauCible < niveauAttaquant)
            s.seuil += (niveauAttaquant - niveauCible);
          var expliquer = function(message) {
            addLineToFramedDisplay(display, message, 80);
          };
          var saveOpts = {
            msgPour: " pour r\xE9sister au tueur fantasmagorique",
            attaquant: attaquant,
            rolls: options.rolls,
            chanceRollId: options.chanceRollId,
            type: 'magique'
          };
          var saveId = 'tueurFantasmagorique_' + cible.token.id;
          save(s, cible, saveId, expliquer, saveOpts, evt,
            function(reussiteSave, texte) {
              if (reussiteSave) {
                addLineToFramedDisplay(display, cible.token.get('name') + " perd l'\xE9quilibre et tombe par terre");
                setState(cible, 'renverse', true, evt);
              } else { //save rat\xE9
                addLineToFramedDisplay(display, cible.token.get('name') + " succombe \xE0 ses pires terreurs");
                updateCurrentBar(cible, 1, 0, evt);
                setState(cible, 'mort', true, evt);
              }
              sendChat("", endFramedDisplay(display));
            });
        } else {
          setTokenAttr(cible, 'tueurFantasmagorique', true, evt);
          sendChat("", endFramedDisplay(display));
        }
      }, evt);
  }

  function parseInjonctionMortelle(msg) {
    var options = parseOptions(msg);
    if (options === undefined || options.cmd === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 3) {
      error("Il faut au moins 2 arguments \xE0 !cof-injonction-mortelle", cmd);
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    var cible = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined || cible === undefined) {
      error("Arguments de !cof-injonction-mortelle", cmd);
      return;
    }
    var distance = distanceCombat(attaquant.token, cible.token, options.pageId);
    if (distance > 30) {
      sendPerso(attaquant, "est trop loin de " + cible.token.get('name') +
        " pour l'injonction mortelle");
      return;
    }
    injonctionMortelle(getPlayerIdFromMsg(msg), attaquant, cible, options);
  }

  function injonctionMortelle(playerId, attaquant, cible, options) {
    var evt = {
      type: 'injonctionMortelle',
      action: {
        titre: "Injonction Mortelle",
        playerId: playerId,
        attaquant: attaquant,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    var explications = options.messages || [];
    entrerEnCombat(attaquant, [cible], explications, evt);
    var display = startFramedDisplay(playerId, evt.action.titre, attaquant, {
      perso2: cible
    });
    explications.forEach(msg => addLineToFramedDisplay(display, msg, 80));
    if (attributeAsBool(cible, 'injonctionMortelle')) {
      addLineToFramedDisplay(display, cible.token.get('name') + " a d\xE9j\xE0 \xE9t\xE9 victime d'une injonction mortelle ce combat, c'est sans effet");
      sendChat("", endFramedDisplay(display));
      return;
    }
    if (predicateAsBool(cible, 'liberteDAction')) {
      addLineToFramedDisplay(display, cible.token.get('name') + " reste libre de ses actions !");
      sendChat("", endFramedDisplay(display));
      return;
    }
    setTokenAttr(cible, 'injonctionMortelle', true, evt);
    var saveOpts = {
      msgPour: " pour r\xE9sister \xE0 l'injonction mortelle",
      msgRate: ", rat\xE9.",
      attaquant: attaquant,
      rolls: options.rolls,
      chanceRollId: options.chanceRollId,
      necromancie: true
    };
    var saveId = 'injonctionMortelle_' + cible.token.id;
    var expliquer = function(message) {
      addLineToFramedDisplay(display, message, 80);
    };
    save({
        carac: 'CON',
        seuil: 15,
        type: 'magique'
      }, cible, saveId, expliquer, saveOpts, evt,
      function(reussite, rollText) {
        if (reussite) {
          let nc = ficheAttributeAsInt(attaquant, "niveau", 0);
          let dmg = {
            type: 'normal',
            value: '2d6+' + nc
          };
          sendChat('', '[[' + dmg.value + ']]', function(resDmg) {
            dmg.roll = dmg.roll || resDmg[0];
            var afterEvaluateDmg = dmg.roll.content.split(' ');
            var dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
            dmg.total = dmg.roll.inlinerolls[dmgRollNumber].results.total;
            dmg.display = buildinline(dmg.roll.inlinerolls[dmgRollNumber], dmg.type, options.magique);
            var name = cible.token.get('name');
            let explicationsDmg = [];
            cible.attaquant = attaquant;
            dealDamage(cible, dmg, [], evt, false, options, explicationsDmg, function(dmgDisplay, dmgFinal) {
              addLineToFramedDisplay(display,
                name + " re\xE7oit " + dmgDisplay + " DM");
              explicationsDmg.forEach(function(e) {
                addLineToFramedDisplay(display, e, 80, false);
              });
              sendChat("", endFramedDisplay(display));
            });
          });
        } else {
          addLineToFramedDisplay(display, cible.token.get('name') + " meurt sous l'injonction mortelle !", 80);
          updateCurrentBar(cible, 1, 0, evt);
          setState(cible, 'mort', true, evt);
          sendChat("", endFramedDisplay(display));
        }
      });
  }

  function parseSommeil(msg) { //sort de sommeil
    var options = parseOptions(msg);
    if (options === undefined) return;
    var args = options.cmd;
    if (args.length < 2) {
      error("La fonction !cof-sommeil a besoin du nom ou de l'id du lanceur de sort", args);
      return;
    }
    var lanceur = persoOfId(args[1], args[1]);
    if (lanceur === undefined) {
      error("Aucun personnage nomm\xE9 " + args[1], args);
      return;
    }
    var casterCharId = lanceur.charId;
    var casterChar = getObj('character', casterCharId);
    if (casterChar === undefined) {
      error("Fiche de personnage manquante");
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lectionn\xE9e pour le sort de sommeil", playerId);
        return;
      }
      var cibles = [];
      iterSelected(selected, function(perso) {
        cibles.push(perso);
      });
      doSommeil(lanceur, cibles, options);
    }, {
      lanceur: lanceur
    });
  }

  function doSommeil(lanceur, cibles, options, ciblesSansSave, ciblesAvecSave) {
    var evt = {
      type: 'sommeil',
      action: {
        lanceur: lanceur,
        cibles: cibles,
        ciblesSansSave: ciblesSansSave,
        ciblesAvecSave: ciblesAvecSave,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'sommeil', "lancer un sort de sommeil", evt)) return;
    let casterCharName = lanceur.token.get("name");
    let cha = modCarac(lanceur, 'charisme');
    let attMagText =
      addOrigin(casterCharName, '[[' + computeArmeAtk(lanceur, '@{ATKMAG}') + ']]');
    sendChat("", "[[1d6]] [[" + attMagText + "]]", function(res) {
      evt.action.rolls = options.rolls || {};
      let rollD6Id = 'sommeilD6';
      let rolls = res[0];
      let afterEvaluate = rolls.content.split(" ");
      let d6RollNumber = rollNumber(afterEvaluate[0]);
      let attMagRollNumber = rollNumber(afterEvaluate[1]);
      let rollD6 = evt.action.rolls[rollD6Id] || rolls.inlinerolls[d6RollNumber];
      evt.action.rolls[rollD6Id] = rollD6;
      let nbTargetsMax = rollD6.results.total + cha;
      let action = "<b>Capacit\xE9</b> : Sort de sommeil (max " + nbTargetsMax + " cibles)";
      let display = startFramedDisplay(options.playerId, action, lanceur);
      let attMag = rolls.inlinerolls[attMagRollNumber].results.total;
      let targetsWithSave = [];
      let targetsWithoutSave = [];
      cibles.forEach(function(perso) {
        perso.tokName = perso.token.get('name');
        if (estNonVivant(perso) || predicateAsBool(perso, 'immunite_endormi')) { //le sort de sommeil n'affecte que les cr\xE9atures vivantes
          addLineToFramedDisplay(display, perso.tokName + " n'est pas affect\xE9 par le sommeil");
          return;
        }
        if (predicateAsBool(perso, "liberteDAction")) {
          addLineToFramedDisplay(display, perso.tokName + " reste libre de ses mouvements !");
          return;
        }
        var pv = perso.token.get('bar1_max');
        if (pv > 2 * attMag) {
          var line = perso.tokName + " a trop de PV pour \xEAtre affect\xE9 par le sort";
          addLineToFramedDisplay(display, line);
        } else if (pv > attMag) {
          targetsWithSave.push(perso);
        } else {
          targetsWithoutSave.push(perso);
        }
      });
      var ciblesSansSave;
      if (evt.action.ciblesSansSave) {
        ciblesSansSave = evt.action.ciblesSansSave;
        nbTargetsMax -= ciblesSansSave.length;
      } else {
        ciblesSansSave = [];
        var i, r;
        if (targetsWithoutSave.length > nbTargetsMax) {
          i = 0; //position to decide
          while (nbTargetsMax > 0) {
            r = randomInteger(nbTargetsMax) + i;
            ciblesSansSave.push(targetsWithoutSave[r]);
            targetsWithoutSave[r] = targetsWithoutSave[i];
            i++;
            nbTargetsMax--;
          }
        } else {
          ciblesSansSave = targetsWithoutSave;
          nbTargetsMax -= ciblesSansSave.length;
        }
      }
      evt.action.ciblesSansSave = ciblesSansSave;
      ciblesSansSave.forEach(function(t) {
        setState(t, 'endormi', true, evt);
        addLineToFramedDisplay(display, t.tokName + " s'endort");
      });
      if (nbTargetsMax > 0 && targetsWithSave.length > 0) {
        var ciblesAvecSave;
        if (evt.action.ciblesAvecSave) {
          ciblesAvecSave = evt.action.ciblesAvecSave;
          nbTargetsMax -= ciblesAvecSave.length;
        } else {
          ciblesAvecSave = [];
          if (targetsWithSave.length > nbTargetsMax) {
            var j = 0;
            while (nbTargetsMax > 0) {
              var ra = randomInteger(nbTargetsMax) + j;
              ciblesAvecSave.push(targetsWithSave[ra]);
              targetsWithSave[ra] = targetsWithSave[j];
              j++;
              nbTargetsMax--;
            }
          } else {
            ciblesAvecSave = targetsWithSave;
            nbTargetsMax -= ciblesAvecSave.length;
          }
        }
        var seuil = 10 + cha;
        var tokensToProcess = ciblesAvecSave.length;
        var finalize = function() {
          if (tokensToProcess == 1) {
            sendChat("", endFramedDisplay(display));
          }
          tokensToProcess--;
        };
        evt.action.ciblesAvecSave = ciblesAvecSave;
        ciblesAvecSave.forEach(function(perso) {
          var testId = 'resisteSommeil_' + perso.token.id;
          testCaracteristique(perso, 'SAG', seuil, testId, options, evt,
            function(tr) {
              var line = "Jet de r\xE9sistance de " + perso.tokName + ": " + tr.texte;
              var sujet = onGenre(perso, 'il', 'elle');
              if (tr.reussite) {
                line += "&gt;=" + seuil + ",  " + sujet + " ne s'endort pas." + tr.modifiers;
              } else {
                setState(perso, 'endormi', true, evt);
                line += "&lt;" + seuil + ", " + sujet + " s'endort" + tr.rerolls + tr.modifiers;
              }
              addLineToFramedDisplay(display, line);
              finalize();
            });
        });
      } else { // all targets are without save
        sendChat("", endFramedDisplay(display));
      }
    });
  }

  //!cof-attaque-magique-contre-pv {selected|token_id} {target|token_id}
  function attaqueMagiqueContrePV(msg) {
    var options = parseOptions(msg);
    if (options === undefined || options.cmd === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 3) {
      error("Il faut au moins 2 arguments \xE0 !cof-attaque-magique-contre-pv", cmd);
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    var cible = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined || cible === undefined) {
      error("Arguments de !cof-attaque-magique-contre-pv incorrects", cmd);
      return;
    }
    if (options.portee !== undefined) {
      var distance = distanceCombat(attaquant.token, cible.token, options.pageId);
      if (distance > options.portee) {
        sendPerso(attaquant, "est trop loin de " + cible.token.get('name') +
          " pour l'attaque magique");
        return;
      }
    }
    var pvMax = parseInt(cible.token.get('bar1_max'));
    if (isNaN(pvMax)) {
      error("Token avec des PV max qui ne sont pas un nombre", cible.token);
      return;
    }
    var evt = {
      type: 'Attaque magique',
    };
    addEvent(evt);
    if (limiteRessources(attaquant, options, 'attaque magique', "l'attaque magique", evt)) return;
    var attaquantChar = getObj('character', attaquant.charId);
    if (attaquantChar === undefined) {
      error("Fiche de l'attaquant introuvable");
      return;
    }
    attaquant.tokName = attaquant.token.get('name');
    attaquant.name = attaquantChar.get('name');
    var playerId = options.playerId || getPlayerIdFromMsg(msg);
    var explications = [];
    var bonusA = bonusDAttaque(attaquant, explications, evt);
    if (bonusA === 0) bonusA = "";
    else if (bonusA > 0) bonusA = " +" + bonusA;
    var attMagText = addOrigin(attaquant.name, "[[" + computeArmeAtk(attaquant, '@{ATKMAG}') + bonusA + "]]");
    var de = computeDice(attaquant);
    var action = "<b>Attaque magique</b> (contre pv max)";
    var display = startFramedDisplay(playerId, action, attaquant, {
      perso2: cible
    });
    sendChat("", "[[" + de + "]] " + attMagText, function(res) {
      var rolls = res[0];
      var afterEvaluate = rolls.content.split(" ");
      var attRollNumber = rollNumber(afterEvaluate[0]);
      var attSkillNumber = rollNumber(afterEvaluate[1]);
      var d20roll = rolls.inlinerolls[attRollNumber].results.total;
      var attSkill = rolls.inlinerolls[attSkillNumber].results.total;
      if (estAffaibli(attaquant) && predicateAsBool(attaquant, 'insensibleAffaibli')) attSkill -= 2;
      var attackRoll = d20roll + attSkill;
      var line =
        attaquant.tokName + " fait " +
        buildinline(rolls.inlinerolls[attRollNumber]);
      if (attSkill > 0) line += "+" + attSkill + " = " + attackRoll;
      else if (attSkill < 0) line += attSkill + " = " + attackRoll;
      addLineToFramedDisplay(display, line);
      var reussi;
      if (d20roll == 1) reussi = false;
      else if (d20roll == 20) reussi = true;
      else reussi = (attackRoll >= pvMax);
      if (reussi) {
        addLineToFramedDisplay(display, "<b>Attaque r\xE9ussie !</b>");
      } else {
        diminueMalediction(attaquant, evt);
        addLineToFramedDisplay(display, "<b>L'attaque \xE9choue.</b>");
      }
      sendChat("", endFramedDisplay(display));
    }); //Fin du jet de d\xE9s pour l'attaque
  }

  function transeGuerison(msg) {
    if (stateCOF.combat) {
      sendPlayer(msg, "Pas possible de m\xE9diter en combat");
      return;
    }
    var options = parseOptions(msg);
    if (options === undefined) return;
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lectionn\xE9e pour la transe de gu\xE9rison", playerId);
        return;
      }
      var evt = {
        type: "Transe de gu\xE9rison",
      };
      iterSelected(selected, function(perso) {
        var token = perso.token;
        if (attributeAsBool(perso, 'transeDeGu\xE9rison')) {
          sendPerso(perso, "a d\xE9j\xE0 m\xE9dit\xE9 depuis le dernier combat");
          return;
        }
        var bar1 = parseInt(token.get("bar1_value"));
        var pvmax = parseInt(token.get("bar1_max"));
        if (isNaN(bar1) || isNaN(pvmax)) return;
        if (bar1 >= pvmax) {
          sendPerso(perso, "n'a pas besoin de m\xE9diter");
          return;
        }
        var sagMod = modCarac(perso, 'sagesse');
        var niveau = ficheAttributeAsInt(perso, 'niveau', 1);
        var soin = niveau + sagMod;
        if (soin < 0) soin = 0;
        if (bar1 === 0) {
          if (attributeAsBool(perso, 'etatExsangue')) {
            removeTokenAttr(perso, 'etatExsangue', evt, {
              msg: "retrouve des couleurs"
            });
          }
        }
        bar1 += soin;
        if (bar1 > pvmax) {
          soin -= (bar1 - pvmax);
          bar1 = pvmax;
        }
        updateCurrentBar(perso, 1, bar1, evt);
        setTokenAttr(perso, 'transeDeGu\xE9rison', true, evt);
        sendPerso(perso, "entre en m\xE9ditation pendant 10 minutes et r\xE9cup\xE8re " + soin + " points de vie.");
      });
      addEvent(evt);
    });
  }

  function raceIs(perso, race) {
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    return (perso.race == race.toLowerCase());
  }

  function estFee(perso) {
    if (predicateAsBool(perso, 'f\xE9e')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'licorne':
      case 'fee':
      case 'f\xE9e':
      case 'pixie':
      case 'lutin':
        return true;
      default:
        return false;
    }
  }

  function estDemon(perso) {
    if (predicateAsBool(perso, 'd\xE9mon')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'd\xE9mon':
      case 'demon':
      case 'balor':
      case 'marilith':
      case 'quasit':
      case 'succube':
        return true;
      default:
        return false;
    }
  }

  function estMortVivant(perso) {
    if (predicateAsBool(perso, 'mortVivant')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'squelette':
      case 'zombie':
      case 'mort-vivant':
      case 'mort vivant':
      case 'momie':
      case 'goule':
      case 'vampire':
        return true;
      default:
        return false;
    }
  }

  function estGeant(perso) {
    if (predicateAsBool(perso, 'g\xE9ant')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'g\xE9ant':
      case 'geant':
      case 'ogre':
      case 'troll':
      case 'ettin':
      case 'cyclope':
      case 'yai':
        return true;
      default:
        return false;
    }
  }

  function estGobelin(perso) {
    if (predicateAsBool(perso, 'gobelin')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'gobelin':
      case 'gobelours':
      case 'hobgobelin':
      case 'wikkawak':
        return true;
      default:
        return false;
    }
  }

  function estNonVivant(perso) {
    return (predicateAsBool(perso, 'nonVivant') ||
      attributeAsBool(perso, 'masqueMortuaire') || estMortVivant(perso));
  }

  function estElfeNoir(perso) {
    if (predicateAsBool(perso, 'elfeNoir')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    if (perso.race.includes('elf') && perso.race.includes('noir')) return true;
    switch (perso.race) {
      case 'drider':
      case 'drow':
        return true;
      default:
        return false;
    }
  }

  function estElfe(perso) {
    if (predicateAsBool(perso, 'elfe')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    if (perso.race.includes('elfe')) return true;
    return false;
  }

  //Vrai pour les insectes et araign\xE9es
  function estInsecte(perso) {
    if (predicateAsBool(perso, 'insecte')) return true;
    if (perso.profil === undefined) {
      perso.profil = ficheAttribute(perso, 'profil', '');
      perso.profil = perso.profil.toLowerCase();
    }
    if (perso.profil == 'insecte') return true;
    if (perso.profil == 'araign\xE9e') return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    if (perso.race.includes('elf') && perso.race.includes('noir')) return true;
    switch (perso.race) {
      case 'ankheg':
      case 'araign\xE9e':
      case 'araignee':
      case 'insecte':
        return true;
      default:
        return false;
    }
  }

  function estHumanoide(perso) {
    if (predicateAsBool(perso, 'humanoide')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'humain':
      case 'nain':
      case 'elfe':
      case 'elfe des bois':
      case 'elfe noir':
      case 'drow':
      case 'halfelin':
      case 'g\xE9ant':
      case 'geant':
      case 'ange':
      case 'barghest':
      case 'd\xE9mon':
      case 'doppleganger':
      case 'dryade':
      case 'gnoll':
      case 'gobelin':
      case 'gobelours':
      case 'hobegobelin':
      case 'homme-l\xE9zard':
      case 'kobold':
      case 'nymphe':
      case 'ogre':
      case 'orque':
      case 'pixie':
      case 'troll':
        return true;
      default:
        return false;
    }
  }

  function estQuadrupede(perso) {
    if (predicateAsBool(perso, 'quadrupede')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'ankheg':
      case 'araign\xE9e':
      case 'araignee':
      case 'basilic':
      case 'b\xE9hir':
      case 'behir':
      case 'bulette':
      case 'bison':
      case 'centaure':
      case 'cheval':
      case 'chien':
      case 'chim\xE8re':
      case 'chimere':
      case 'cockatrice':
      case 'crocodile':
      case 'dragon':
      case 'drider':
      case 'el\xE9phant':
      case 'elephant':
      case '\xE9l\xE9phant':
      case 'mammouth':
      case 'griffon':
      case 'hipogriffe':
      case 'hippogriffe':
      case 'hydre':
      case 'licorne':
      case 'lion':
      case 'loup':
      case 'worg':
      case 'manticore':
      case 'ours':
      case 'panthere':
      case 'panth\xE8re':
      case 'pegase':
      case 'p\xE9gase':
      case 'pieuvre':
      case 'rat':
      case 'rhinoceros':
      case 'rhinoc\xE9ros':
      case 'sanglier':
      case 'taureau':
      case 'tigre':
        return true;
      default:
        return false;
    }
  }

  function estAnimal(perso) {
    if (predicateAsBool(perso, 'animal')) return true;
    var attr = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    var attrProfile = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'PROFIL';
    });
    if (attrProfile.length > 0) {
      if (attrProfile[0].get('current').trim().toLowerCase() == 'animal')
        return true;
    }
    var attrRace = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'RACE';
    });
    if (attrRace.length === 0) return false;
    var charRace = attrRace[0].get('current').trim().toLowerCase();
    switch (charRace) {
      case 'animal':
      case 'aigle':
      case 'araignee':
      case 'araign\xE9e':
      case 'basilic':
      case 'bulette':
      case 'bison':
      case 'calmar':
      case 'chauve-souris':
      case 'cheval':
      case 'chien':
      case 'crocodile':
      case 'dinosaure':
      case '\xE9l\xE9phant':
      case 'el\xE9phant':
      case 'elephant':
      case 'gorille':
      case 'griffon':
      case 'hipogriffe':
      case 'hydre':
      case 'insecte':
      case 'lion':
      case 'loup':
      case 'mammouth':
      case 'manticore':
      case 'ours':
      case 'ours-hibou':
      case 'panth\xE8re':
      case 'pegase':
      case 'p\xE9gase':
      case 'pieuvre':
      case 'rhinoc\xE9ros':
      case 'roc':
      case 'sanglier':
      case 'serpent':
      case 'rat':
      case 'taureau':
      case 'tigre':
      case 'wiverne':
        return true;
      default:
        return false;
    }
  }

  function estMauvais(perso) {
    if (predicateAsBool(perso, 'mauvais')) return true;
    if (estDemon(perso)) return true; //remplit perso.race
    switch (perso.race) {
      case 'squelette':
      case 'zombie':
      case '\xE9l\xE9mentaire':
      case 'momie':
        return true;
      default:
        return false;
    }
  }

  //Retourne un encodage des tailes :
  // 1 : minuscule
  // 2 : tr\xE8s petit
  // 3 : petit
  // 4 : moyen
  // 5 : grand
  // 6 : \xE9norme
  // 7 : colossal
  function taillePersonnage(perso, def) {
    if (perso.taille) return perso.taille;
    switch (ficheAttribute(perso, 'taille', '').trim().toLowerCase()) {
      case "minuscule":
        perso.taille = 1;
        return 1;
      case "tr\xE8s petit":
      case "tr\xE8s petite":
      case "tres petit":
        perso.taille = 2;
        return 2;
      case "petit":
      case "petite":
        perso.taille = 3;
        return 3;
      case "moyen":
      case "moyenne":
      case "normal":
      case "normale":
        perso.taille = 4;
        return 4;
      case "grand":
      case "grande":
        perso.taille = 5;
        return 5;
      case "\xE9norme":
      case "enorme":
        perso.taille = 6;
        return 6;
      case "colossal":
      case "colossale":
        perso.taille = 7;
        return 7;
      default: //On passe \xE0 la m\xE9thode suivante
    }
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.trim().toLowerCase();
    }
    switch (perso.race) {
      case 'lutin':
      case 'fee':
        perso.taille = 2;
        return 2;
      case 'halfelin':
      case 'gobelin':
      case 'kobold':
        perso.taille = 3;
        return 3;
      case 'humain':
      case 'elfe':
      case 'nain':
      case 'demi-elfe':
      case 'demi-orque':
      case 'orque':
      case 'gnome':
      case '\xE2me-forg\xE9e':
        perso.taille = 4;
        return 4;
      case 'centaure':
      case 'demi-ogre':
      case 'ogre':
      case 'minotaure':
        perso.taille = 5;
        return 5;
    }
    perso.taille = def;
    return def;
  }

  function estAussiGrandQue(perso1, perso2) {
    let t1 = taillePersonnage(perso1);
    let t2 = taillePersonnage(perso2);
    if (t1 === undefined || t2 === undefined) return true;
    return t1 >= t2;
  }

  //!cof-soin
  function soigner(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd.length < 2) {
      error("Il faut au moins un argument \xE0 !cof-soin", cmd);
      return;
    }
    let soigneur = options.lanceur;
    let pageId = options.pageId;
    let cible;
    let argSoin;
    if (cmd.length > 4) {
      error("Trop d'arguments \xE0 !cof-soin", cmd);
    }
    if (cmd.length > 2) { //cof-soin lanceur [cible] montant
      if (soigneur === undefined) {
        soigneur = persoOfId(cmd[1], cmd[1]);
        if (soigneur === undefined) {
          error("Le premier argument n'est pas un token valide", cmd[1]);
          return;
        }
        pageId = soigneur.token.get('pageid');
      }
      if (cmd.length > 3) { // on a la cible en argument
        cible = persoOfId(cmd[2], cmd[2], pageId);
        if (cible === undefined) {
          error("Le deuxi\xE8me argument n'est pas un token valide: " + msg.content, cmd[2]);
          return;
        }
        argSoin = cmd[3];
      } else {
        argSoin = cmd[2];
      }
    } else { //on a juste le montant des soins
      argSoin = cmd[1];
    }
    if (soigneur === undefined && (options.mana || (options.portee !== undefined) || options.limiteParJour || options.limiteParCombat || options.dose || options.limiteSoinsParJour)) {
      error("Il faut pr\xE9ciser un soigneur pour ces options d'effet", options);
      return;
    }
    let charId;
    let niveau = 1;
    let rangSoin = 0;
    let soins;
    if (soigneur) {
      charId = soigneur.charId;
      niveau = ficheAttributeAsInt(soigneur, 'niveau', 1);
      rangSoin = predicateAsInt(soigneur, 'voieDesSoins', 0);
    }
    let effet = "soins";
    let nbDes = 1;
    if (options.tempeteDeManaIntense) nbDes += options.tempeteDeManaIntense;
    switch (argSoin) {
      case 'leger':
        effet += ' l\xE9gers';
        if (options.dose === undefined && options.limiteParJour === undefined)
          options.limiteAttribut = {
            nom: 'soinsLegers',
            message: "ne peut plus lancer de sort de soins l\xE9gers aujourd'hui",
            limite: rangSoin
          };
        let bonusLeger = niveau + predicateAsInt(soigneur, 'voieDuGuerisseur', 0);
        soins = "[[" + nbDes + (options.puissant ? "d10" : "d8");
        if (attributeAsBool(soigneur, 'formeDAnge') && predicateAsInt(soigneur, 'voieDeLArchange', 1) > 1) {
          soins += 'ro1';
        }
        soins += " +" + bonusLeger + "]]";
        if (options.portee === undefined) options.portee = 0;
        break;
      case 'modere':
        effet += ' mod\xE9r\xE9s';
        if (options.dose === undefined && options.limiteParJour === undefined)
          options.limiteAttribut = {
            nom: 'soinsModeres',
            message: "ne peut plus lancer de sort de soins mod\xE9r\xE9ss aujourd'hui",
            limite: rangSoin
          };
        if (options.portee === undefined) options.portee = 0;
        let bonusModere = niveau + predicateAsInt(soigneur, 'voieDuGuerisseur', 0);
        soins = "[[" + (nbDes + 1) + (options.puissant ? "d10" : "d8");
        if (attributeAsBool(soigneur, 'formeDAnge') && predicateAsInt(soigneur, 'voieDeLArchange', 1) > 1) {
          soins += 'ro1';
        }
        soins += " +" + bonusModere + "]]";
        break;
      case 'groupe':
        if (!stateCOF.combat) {
          whisperChar(charId, " ne peut pas lancer de soin de groupe en dehors des combats");
          return;
        }
        effet += ' de groupe';
        if (options.dose === undefined && options.limiteParJour === undefined)
          options.limiteAttribut = {
            nom: 'attributDeCombat_soinsDeGroupe',
            message: " a d\xE9j\xE0 fait un soin de groupe durant ce combat",
            limite: 1
          };
        if (options.puissant) soins = "[[1d10";
        else soins = "[[" + nbDes + "d8";
        if (attributeAsBool(soigneur, 'formeDAnge') && predicateAsInt(soigneur, 'voieDeLArchange', 1) > 1) {
          soins += 'ro1';
        }
        let bonusGroupe = niveau + predicateAsInt(soigneur, 'voieDuGuerisseur', 0);
        soins += " + " + bonusGroupe + "]]";
        msg.content += " --alliesEnVue --self";
        if (options.mana === undefined && estPJ(soigneur)) {
          if (ficheAttributeAsBool(soigneur, 'option_pm', true))
            options.mana = 1;
        }
        break;
      case 'secondSouffle':
        if (!stateCOF.combat) {
          whisperChar(charId, " ne peut pas utiliser la capacit\xE9 second souffle en dehors des combats");
          return;
        }
        effet = "second souffle";
        if (options.dose === undefined && options.limiteParJour === undefined)
          options.limiteAttribut = {
            nom: 'secondSouffleUtilise',
            message: " a d\xE9j\xE0 repris son souffle durant ce combat",
            limite: 1
          };
        soins = "[[1d10+" + niveau + "+" + modCarac(soigneur, 'constitution') +
          "]]";
        cible = soigneur;
        options.recuperation = true;
        if (predicateAsBool(soigneur, 'secondSouffle')) {
          //On limite les soins \xE0 ce qui a \xE9t\xE9 perdu dans ce combat
          const pvDebut = attributeAsInt(soigneur, 'PVsDebutCombat', 0);
          let pv = parseInt(soigneur.token.get('bar1_value'));
          if (isNaN(pv)) return;
          if (pvDebut <= pv) {
            whisperChar(charId, "Aucun PV perdu pendant ce combat, second souffle sans effet");
            return;
          }
          options.limiteSoins = pvDebut - pv;
        }
        break;
      default:
        if (options.tempeteDeManaIntense) {
          let firstDicePart = argSoin.match(/[1-9][0-9]*d\d+/i);
          if (firstDicePart && firstDicePart.length > 0) {
            let fdp = firstDicePart[0];
            nbDes = parseInt(fdp) + options.tempeteDeManaIntense;
            argSoin =
              argSoin.replace(fdp, nbDes + fdp.substring(fdp.search(/d/i)));
          } else {
            argSoin = '(' + argSoin + ')*' + (1 + options.tempeteDeManaIntense);
          }
        }
        if (soigneur && attributeAsBool(soigneur, 'formeDAnge') && predicateAsInt(soigneur, 'voieDeLArchange', 1) > 1) {
          argSoin = argSoin.replace(/([1-9][0-9]*d\d+)/gi, function(all, d) {
            return d + 'ro1';
          });
        }
        soins = "[[" + argSoin + "]]";
    }
    let ressourceLimiteSoinsParJour;
    if (soigneur && options.limiteSoinsParJour) {
      ressourceLimiteSoinsParJour = effet;
      if (options.limiteSoinsParJourRessource)
        ressourceLimiteSoinsParJour = options.limiteSoinsParJourRessource;
      ressourceLimiteSoinsParJour = "limiteParJour_Soins" + ressourceLimiteSoinsParJour;
      var soinsRestantsDuJour = attributeAsInt(soigneur, ressourceLimiteSoinsParJour, options.limiteSoinsParJour);
      if (soinsRestantsDuJour < 1) {
        whisperChar(charId, "Plus possible de faire ces soins aujourd'hui");
        return;
      }
      if (options.limiteSoins === undefined || options.limiteSoins > soinsRestantsDuJour) {
        options.limiteSoins = soinsRestantsDuJour;
      }
    }
    const playerId = getPlayerIdFromMsg(msg);
    if (options.tempeteDeMana && soigneur) {
      if (options.tempeteDeMana.cout === 0) {
        //On demande de pr\xE9ciser les options
        var optMana = {
          mana: options.mana,
          rang: options.rang,
          portee: options.portee,
          altruiste: options.altruiste,
          soins: true
        };
        setTempeteDeMana(playerId, soigneur, msg.content, optMana);
        return;
      } else {
        if (options.rang && options.tempeteDeMana.cout > options.rang) {
          sendPerso(soigneur, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
        }
      }
    }
    try {
      sendChat('', soins, function(res) {
        soins = res[0].inlinerolls[0].results.total;
        let soinTxt = buildinline(res[0].inlinerolls[0], 'normal', true);
        if (soins <= 0) {
          sendChar(charId, "ne r\xE9ussit pas \xE0 soigner (total de soins " + soinTxt + ")", true);
          return;
        }
        let limiteSoinsAtteinte;
        if (options.limiteSoins && soins > options.limiteSoins) {
          soins = options.limiteSoins;
          limiteSoinsAtteinte = true;
        }
        var evt = {
          type: effet
        };
        var ressourceLimiteCibleParJour;
        if (options.limiteCibleParJour) {
          ressourceLimiteCibleParJour = effet;
          if (options.limiteCibleParJourRessource)
            ressourceLimiteCibleParJour = options.limiteCibleParJourRessource;
          ressourceLimiteCibleParJour = "limiteParJour_" + ressourceLimiteCibleParJour;
        }
        var limiteATester = true;
        var soinImpossible = false;
        var nbCibles;
        var display;
        var pvsPartages = new Set();
        let iterCibles = function(callback) {
          if (cible) {
            nbCibles = 1;
            callback(cible);
          } else {
            getSelected(msg, function(selected) {
              nbCibles = selected.length;
              if (nbCibles > 1) {
                display = startFramedDisplay(playerId, effet, soigneur);
              } else if (nbCibles === 0) {
                sendChar(charId, "personne \xE0 soigner", true);
                return;
              }
              iterSelected(selected, callback);
            }, {
              lanceur: soigneur
            });
          }
        };
        let finSoin = function() {
          if (nbCibles == 1) {
            if (options.messages) {
              options.messages.forEach(function(message) {
                if (display) addLineToFramedDisplay(display, message);
                else sendChar(charId, message, true);
              });
            }
            if (display) sendChat("", endFramedDisplay(display));
            if (ressourceLimiteSoinsParJour) {
              whisperChar(charId, "peut encore soigner de " + attributeAsInt(soigneur, ressourceLimiteSoinsParJour, options.limiteSoinsParJour) + " PV aujourd'hui.");
            }
            addEvent(evt);
          }
          nbCibles--;
        };
        iterCibles(function(cible) {
          if (cible.name === undefined) {
            let cibleChar = getObj('character', cible.charId);
            if (cibleChar === undefined) {
              finSoin();
              return;
            }
            cible.name = cibleChar.get('name');
          }
          if (pvsPartages.has(cible.name)) {
            finSoin();
            return;
          }
          let ciblePartagee = charAttribute(cible.charId, 'PVPartagesAvec');
          ciblePartagee.forEach(function(attr) {
            pvsPartages.add(attr.get('current'));
          });
          if (ressourceLimiteCibleParJour) {
            var utilisations =
              attributeAsInt(cible, ressourceLimiteCibleParJour, options.limiteCibleParJour);
            if (utilisations === 0) {
              sendPerso(cible, "ne peut plus b\xE9n\xE9ficier de " + effet + " aujourd'hui");
              finSoin();
              return;
            }
            setTokenAttr(cible, ressourceLimiteCibleParJour, utilisations - 1, evt);
          }
          if (soinImpossible) {
            finSoin();
            return;
          }
          var token2 = cible.token;
          var nomCible = token2.get('name');
          var sujet = onGenre(cible, 'il', 'elle');
          var Sujet = onGenre(cible, 'Il', 'Elle');
          if (options.portee !== undefined) {
            if (options.puissantPortee || options.tempeteDeManaPortee) options.portee = options.portee * 2;
            var distance = distanceCombat(soigneur.token, token2, pageId);
            if (distance > options.portee) {
              if (display)
                addLineToFramedDisplay(display, "<b>" + nomCible + "</b> : trop loin pour le soin.");
              else
                sendChar(charId,
                  "est trop loin de " + nomCible + " pour le soigner.", true);
              return;
            }
          }
          if (limiteATester) {
            limiteATester = false;
            if (limiteRessources(soigneur, options, effet, effet, evt)) {
              soinImpossible = true;
              display = undefined;
              finSoin();
              return;
            } else if (display) {
              addLineToFramedDisplay(display, "R\xE9sultat des d\xE9s : " + soinTxt);
            }
          }
          let callMax = function() {
            if (display) {
              addLineToFramedDisplay(display, "<b>" + nomCible + "</b> : pas besoin de soins.");
            } else {
              var maxMsg = "n'a pas besoin de ";
              if (options.recuperation) {
                maxMsg = "se reposer";
                charId = soigneur.charId;
              } else if (!soigneur || token2.id == soigneur.token.id) {
                maxMsg += "se soigner";
                charId = cible.charId;
              } else {
                maxMsg += "soigner " + nomCible;
              }
              sendChar(charId, maxMsg + ". " + Sujet + " est d\xE9j\xE0 au maximum de PV", true);
            }
          };
          var img = options.image;
          var extraImg = '';
          if (img !== "" && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
            extraImg = '<span style="padding: 4px 0;" >  ';
            extraImg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
            extraImg += '</span>';
          }
          var printTrue = function(s) {
            if (ressourceLimiteSoinsParJour) {
              addToAttributeAsInt(soigneur, ressourceLimiteSoinsParJour, options.limiteSoinsParJour, -s, evt);
            }
            if (display) {
              addLineToFramedDisplay(display,
                "<b>" + nomCible + "</b> : + " + s + " PV" + extraImg);
            } else {
              let msgSoin;
              if (!soigneur || token2.id == soigneur.token.id) {
                msgSoin = 'se soigne';
                charId = cible.charId;
              } else {
                msgSoin = 'soigne ' + nomCible;
              }
              msgSoin += " de ";
              if (options.recuperation) msgSoin = "r\xE9cup\xE8re ";
              if (limiteSoinsAtteinte || s < soins)
                msgSoin += s + " PV. (Le r\xE9sultat du jet \xE9tait " + soinTxt + ")";
              else msgSoin += soinTxt + " PV.";
              msgSoin += extraImg;
              sendChar(charId, msgSoin, true);
            }
          };
          var pvSoigneur;
          let callTrueFinal = printTrue;
          if (msg.content.includes(' --transfer')) { //paie avec ses PV
            if (soigneur === undefined) {
              error("Il faut pr\xE9ciser qui est le soigneur pour utiliser l'option --transfer", msg.content);
              soinImpossible = true;
              return;
            }
            pvSoigneur = parseInt(soigneur.token.get("bar1_value"));
            if (isNaN(pvSoigneur) || pvSoigneur <= 0) {
              if (display)
                addLineToFramedDisplay(display, "<b>" + nomCible + "</b> : plus assez de PV pour le soigner");
              else
                sendPerso(soigneur,
                  "ne peut pas soigner " + nomCible + ", " + sujet + " n'a plus de PV");
              soinImpossible = true;
              finSoin();
              return;
            }
            if (pvSoigneur < soins) {
              soins = pvSoigneur;
            }
            callTrueFinal = function(s) {
              updateCurrentBar(soigneur, 1, pvSoigneur - s, evt);
              if (pvSoigneur == s) mort(soigneur, undefined, evt);
              printTrue(s);
            };
          }
          if (options.fx) {
            var p1e = {
              x: soigneur.token.get('left'),
              y: soigneur.token.get('top'),
            };
            var p2e = {
              x: cible.token.get('left'),
              y: cible.token.get('top'),
            };
            spawnFxBetweenPoints(p1e, p2e, options.fx, pageId);
          }
          if (options.son) playSound(options.son);
          if (options.targetFx) {
            spawnFx(cible.token.get('left'), cible.token.get('top'), options.targetFx, pageId);
          }
          soigneToken(cible, soins, evt, callTrueFinal, callMax, options);
          finSoin();
        }); //fin de iterCibles
      }); //fin du sendChat du jet de d\xE9s
    } catch (e) {
      if (soins) {
        log(msg.content);
        log("L'expression des soins \xE9tait " + soins + ", et il y a eu une erreur durant son \xE9valuation");
        if (argSoin) {
          error("L'expression des soins (" + argSoin + ") n'est pas bien form\xE9e", msg.content);
        } else {
          error("Erreur pendant l'\xE9valuation de l'expression des soins. Plus d'informations dans le log", msg);
        }
      } else {
        error("Erreur pendant les soins ", msg.content);
        throw e;
      }
    }
  }

  function removeConsommables(nom, evt, attrs) {
    var prefixes = new Set();
    var empty = true;
    attrs = attrs.filter(function(a) {
      var attrName = a.get('name');
      var m = consommableNomRegExp.exec(attrName);
      if (!m) return true;
      if (a.get('current').trim() == nom) {
        prefixes.add(m[1]);
        a.remove();
        empty = false;
        return false;
      }
      return true;
    });
    if (empty) return attrs;
    var regExp = '^(';
    var notFirst = false;
    prefixes.forEach(function(pref) {
      if (notFirst) regExp += '|';
      regExp += pref;
    });
    regExp += ').*?$';
    regExp = new RegExp(regExp);
    attrs = attrs.filter(function(a) {
      if (regExp.test(a.get('name'))) {
        a.remove();
        return false;
      }
      return true;
    });
    return attrs;
  }

  function ajouterConsommable(perso, nom, nb, action, evt) {
    if (perso.token.get('bar1_link') === '') { //Perso non li\xE9, on utilise un attribut
      var attrName = 'dose_' + nom;
      var attr = tokenAttribute(perso, attrName);
      if (attr.length > 0) {
        attr = attr[0];
        var bd = parseInt(attr.get('current'));
        if (!isNaN(bd) && bd > 0) nb += bd;
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attr,
          current: bd,
          max: attr.get('max')
        });
        attr.set({
          current: nb,
          max: action
        });
      } else {
        setTokenAttr(perso, attrName, nb, evt, {
          maxVal: action
        });
      }
    } else { //On va mettre les consommables dans l'\xE9quipement
      var attributes = findObjs({
        _type: 'attribute',
        _characterid: perso.charId
      });
      var found = attributes.find(function(attr) {
        var attrName = attr.get('name');
        var m = consommableNomRegExp.exec(attrName);
        if (!m) return false;
        if (attr.get('current').trim() != nom) return false;
        var consoPrefix = m[1];
        var attrEffet = charAttribute(perso.charId, consoPrefix + 'equip_effet');
        if (attrEffet.length === 0) {
          attrEffet = createObj('attribute', {
            characterid: perso.charId,
            name: consoPrefix + 'equip_effet',
            current: action
          });
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attrEffet,
          });
        } else if (attrEffet[0].get('current').trim() != action) {
          return false;
        }
        var attrQte = charAttribute(perso.charId, consoPrefix + 'equip_qte');
        if (attrQte.length === 0) {
          attrQte = createObj('attribute', {
            characterid: perso.charId,
            name: consoPrefix + 'equip_qte',
            current: nb + 1,
          });
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attrQte,
          });
          return true;
        }
        attrQte = attrQte[0];
        var quantite = parseInt(attrQte.get('current'));
        if (isNaN(quantite) || quantite < 1) quantite = 0;
        attrQte.set('current', quantite + nb);
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attrQte,
          current: quantite
        });
        return true;
      });
      // si le consommable n'a pas \xE9t\xE9 trouv\xE9, on le cr\xE9e avec une valeur de nb
      if (!found) {
        var pref = 'repeating_equipement_' + generateRowID() + '_';
        var attre = createObj("attribute", {
          name: pref + 'equip_nom',
          current: nom,
          characterid: perso.charId
        });
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attre,
        });
        attre = createObj('attribute', {
          name: pref + 'equip_effet',
          current: action,
          characterid: perso.charId
        });
        evt.attributes.push({
          attribute: attre,
        });
        if (nb > 1) {
          var attrQte = createObj('attribute', {
            characterid: perso.charId,
            name: pref + 'equip_qte',
            current: nb,
          });
          evt.attributes.push({
            attribute: attrQte,
          });
        }
      }
    }
  }

  function parseNatureNourriciere(msg) {
    var options = parseOptions(msg);
    getSelected(msg, function(selected) {
      iterSelected(selected, function(lanceur) {
        var voieDeLaSurvie = predicateAsInt(lanceur, 'voieDeLaSurvie', 0);
        if (voieDeLaSurvie < 1) {
          sendPerso(lanceur, " ne conna\xEEt pas la Voie de la Survie ?");
        }
        doNatureNourriciere(lanceur, options);
      });
    });
  }

  function doNatureNourriciere(perso, options) {
    var evt = {
      type: "natureNourriciere",
      action: {
        perso: perso,
        options: options,
        rolls: {}
      }
    };
    addEvent(evt);
    var voieDeLaSurvie = predicateAsInt(perso, 'voieDeLaSurvie', 0);
    var trouveBaies = predicateAsBool(perso, 'natureNourriciereBaies');
    if (options.rolls && options.rolls.duree) {
      evt.action.rolls.duree = options.rolls.duree;
    } else {
      evt.action.rolls.duree = rollDePlus(6);
    }
    var output = "cherche des herbes. ";
    if (trouveBaies) output = "cherche des baies. ";
    output += "Apr\xE8s " + evt.action.rolls.duree.roll + " heure";
    if (evt.action.rolls.duree.val > 1) output += "s";
    output += ", " + onGenre(perso, "il", "elle");
    var testId = 'natureNourriciere';
    testCaracteristique(perso, 'SAG', 10, testId, options, evt,
      function(tr) {
        var post = "";
        if ((tr.reussite && !trouveBaies) || (trouveBaies && !tr.reussite && tr.valeur > 7)) {
          if (voieDeLaSurvie > 0) {
            output += " revient avec " + voieDeLaSurvie + " plantes m\xE9dicinales." + tr.modifiers;
            var actionHerbes = "!cof-soin @{selected|token_id} @{selected|token_id} 1d6";
            ajouterConsommable(perso, 'Plante m\xE9dicinale', voieDeLaSurvie, actionHerbes, evt);
          } else {
            output += " revient avec de quoi soigner les bless\xE9s." + tr.modifiers;
          }
        } else if (tr.reussite && trouveBaies) {
          var niveau = ficheAttributeAsInt(perso, 'niveau', 1);
          var actionBaies = "!cof-consommer-baie " + niveau + " --limiteParJour 1 baieMagique";
          var nbBaies = voieDeLaSurvie + Math.floor((tr.valeur - 10) / 2);
          if (nbBaies === 0) nbBaies = 1;
          output += " revient avec " + nbBaies + " baies magiques." + tr.modifiers;
          ajouterConsommable(perso, 'Baie magique', nbBaies, actionBaies, evt);
        } else {
          output += " revient bredouille." + tr.rerolls + tr.modifiers;
        }
        output += "(test de SAG:" + tr.texte + ")";
        output += post;
        sendPerso(perso, output);
      });
  }

  function ignorerLaDouleur(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    var evtARefaire = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[1]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
    }
    getSelected(msg, function(selected) {
      iterSelected(selected, function(chevalier) {
        var token = chevalier.token;
        if (attributeAsInt(chevalier, 'douleurIgnoree', 0) > 0) {
          sendPerso(chevalier, "a d\xE9j\xE0 ignor\xE9 la doubleur une fois pendant ce combat");
          return;
        }
        if (evtARefaire === undefined || evtARefaire.type === undefined || !evtARefaire.type.startsWith('Attaque')) {
          sendPerso(chevalier, "s'y prend trop tard pour ignorer la douleur : la derni\xE8re action n'\xE9tait pas une attaque");
          return;
        }
        var aIgnore;
        var evt = {
          type: 'ignorer la douleur'
        };
        var PVid = token.get('bar1_link');
        if (PVid === '') { //token non li\xE9, effets seulement sur le token.
          if (evtARefaire.affecte) {
            var affecte = evtARefaire.affectes[token.id];
            if (affecte && affecte.prev) {
              var lastBar1 = affecte.prev.bar1_value;
              var bar1 = parseInt(token.get('bar1_value'));
              if (isNaN(lastBar1) || isNaN(bar1) || lastBar1 <= bar1) {
                //On regarde la barre 2, peut-\xEAtre qu'il s'agit de DM temporaires
                var lastBar2 = affecte.prev.bar2_value;
                var bar2 = parseInt(token.get('bar2_value'));
                if (isNaN(lastBar2) || isNaN(bar2) || bar2 <= lastBar2) {
                  sendPerso(chevalier, "ne peut ignorer la douleur : il semble que la derni\xE8re attaque ne lui ait pas enlev\xE9 de PV");
                  return;
                }
                updateCurrentBar(chevalier, 2, lastBar2, evt);
                setTokenAttr(chevalier, 'douleurIgnoree', bar2 - lastBar2, evt);
                aIgnore = true;
              } else {
                updateCurrentBar(chevalier, 1, lastBar1, evt);
                setTokenAttr(chevalier, 'douleurIgnoree', lastBar1 - bar1, evt);
                aIgnore = true;
              }
            }
          }
        } else { // token li\xE9, il faut regarder l'attribut
          var attrPV = evtARefaire.attributes.find(function(attr) {
            return (attr.attribute.id == PVid);
          });
          if (attrPV) {
            var lastPV = attrPV.current;
            var newPV = attrPV.attribute.get('current');
            if (isNaN(lastPV) || isNaN(newPV) || lastPV <= newPV) {
              sendPerso(chevalier, "ne peut ignorer la douleur : il semble que la derni\xE8re attaque ne lui ait pas enlev\xE9 de PV");
              return;
            }
            updateCurrentBar(chevalier, 1, lastPV, evt);
            setTokenAttr(chevalier, 'douleurIgnoree', lastPV - newPV, evt);
            aIgnore = true;
          } else { //peut-\xEAtre qu'il s'agit de DM temporaires
            PVid = token.get('bar2_link');
            attrPV = evtARefaire.attributes.find(function(attr) {
              return (attr.attribute.id == PVid);
            });
            if (attrPV) {
              var lastDmTemp = attrPV.current;
              var newDmTemp = attrPV.attribute.get('current');
              if (isNaN(lastDmTemp) || isNaN(newDmTemp) || newDmTemp <= lastDmTemp) {
                sendPerso(chevalier, "ne peut ignorer la douleur : il semble que la derni\xE8re attaque ne lui ait pas augment\xE9 les DM temporaires");
                return;
              }
              updateCurrentBar(chevalier, 2, lastDmTemp, evt);
              setTokenAttr(chevalier, 'douleurIgnoree', newDmTemp - lastDmTemp, evt);
              aIgnore = true;
            }
          }
        }
        if (aIgnore) {
          sendPerso(chevalier, " ignore la douleur de la derni\xE8re attaque");
          addEvent(evt);
        } else {
          sendPerso(chevalier, "ne peut ignorer la douleur : il semble que la derni\xE8re attaque ne l'ait pas affect\xE9");
        }
      });
    });
  }

  function fortifiant(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("La fonction !cof-fortifiant attend en argument le rang dans la Voie des \xE9lixirs du cr\xE9ateur", cmd);
      return;
    }
    var rang = parseInt(cmd[1]);
    if (isNaN(rang) || rang < 1) {
      error("Rang du fortifiant incorrect", cmd);
      return;
    }
    var evt = {
      type: 'fortifiant',
      attributes: []
    };
    addEvent(evt);
    getSelected(msg, function(selection) {
      iterSelected(selection, function(beneficiaire) {
        if (limiteRessources(beneficiaire, options, 'elixir_fortifiant', "boire un fortifiant", evt)) return;
        var soins = rollDePlus(4, {
          bonus: rang
        });
        sendPerso(beneficiaire, " boit un fortifiant");
        soigneToken(beneficiaire, soins.val, evt, function(soinsEffectifs) {
          var msgSoins = "et est soign\xE9 de ";
          if (soinsEffectifs == soins.val) msgSoins += soins.roll + " PV";
          else msgSoins += soinsEffectifs + " PV (le jet \xE9tait " + soins.roll + ")";
          sendPerso(beneficiaire, msgSoins);
        });
        // Finalement on met l'effet fortifie
        setTokenAttr(beneficiaire, 'fortifie', rang + 1, evt);
      });
    });
  }

  function lancerSort(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    if (options.messages === undefined) options.messages = [];
    if (cmd.length > 1) options.messages.unshift(cmd.slice(1).join(' '));
    if (options.messages.length < 1) {
      options.messages.push("lance un sort");
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        if (options.lanceur) {
          selected = [{
            _id: options.lanceur.token.id
          }];
        } else {
          error("Pas de token s\xE9lection\xE9e pour !cof-lancer-sort", cmd);
          return;
        }
      }
      var evt = {
        type: "lancement de sort"
      };
      addEvent(evt);
      if (options.lanceur) {
        var lanceur = options.lanceur;
        if (options.tempeteDeMana) {
          if (options.tempeteDeMana.cout === 0) {
            //On demande de pr\xE9ciser les options
            var optMana = {
              mana: options.mana,
              dm: false,
              soins: false,
              duree: true,
              portee: true,
              rang: options.rang,
            };
            setTempeteDeMana(playerId, lanceur, msg.content, optMana);
            return;
          } else {
            if (options.rang && options.tempeteDeMana.cout > options.rang) {
              sendPerso(lanceur, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
            }
          }
        }
        if (limiteRessources(lanceur, options, undefined, "lancer un sort", evt)) return;
      }
      if (options.son) playSound(options.son);
      iterSelected(selected, function(cible) {
        if (!options.lanceur) {
          if (options.tempeteDeMana) {
            if (options.tempeteDeMana.cout === 0) {
              //On demande de pr\xE9ciser les options
              var optMana = {
                mana: options.mana,
                dm: false,
                soins: false,
                duree: true,
                portee: true,
                rang: options.rang,
              };
              setTempeteDeMana(playerId, cible, msg.content, optMana);
              return;
            } else {
              if (options.rang && options.tempeteDeMana.cout > options.rang) {
                sendPerso(cible, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
              }
            }
          }
          if (limiteRessources(cible, options, undefined, "lancer un sort", evt)) return;
        }
        options.messages.forEach(function(m) {
          sendPerso(cible, m, options.secret);
        });
      });
    });
  }

  function emulerAs(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il manque le nom du personnage pour !cof-as", msg.content);
      return;
    }
    cmd.shift();
    var nomPerso = cmd.shift();
    if (nomPerso.charAt(0) == '"') {
      nomPerso = nomPerso.substring(1);
      var inComma = cmd.length;
      while (inComma) {
        nomPerso += ' ' + cmd.shift();
        inComma--;
        if (nomPerso.endsWith('"')) {
          nomPerso = nomPerso.substr(0, nomPerso.length - 1);
          inComma = 0;
        }
      }
    }
    sendChat(nomPerso, cmd.join(' '));
  }


  function murDeForce(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) return;
    let sphere = true;
    let imageSphere = stateCOF.options.images.val.image_mur_de_force.val;
    if (cmd.length > 1) {
      if (cmd[1] == 'mur') sphere = false;
      else if (cmd[1] == 'noImage') imageSphere = undefined;
      else imageSphere = cmd[1].replace('&#58;', ':');
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Aucun personnage s\xE9lectionn\xE9 pour lancer le mur de force", playerId);
        return;
      }
      var evt = {
        type: "Mur de force"
      };
      addEvent(evt);
      initiative(selected, evt);
      iterSelected(selected, function(lanceur) {
        if (options.tempeteDeMana) {
          if (options.tempeteDeMana.cout === 0) {
            //On demande de pr\xE9ciser les options
            var optMana = {
              mana: options.mana,
              dm: false,
              soins: false,
              duree: true,
              portee: true,
              rang: options.rang,
            };
            setTempeteDeMana(playerId, lanceur, msg.content, optMana);
            return;
          } else {
            if (options.rang && options.tempeteDeMana.cout > options.rang) {
              sendPerso(lanceur, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
            }
          }
        }
        var charId = lanceur.charId;
        var token = lanceur.token;
        var pageId = token.get('pageid');
        if (limiteRessources(lanceur, options, 'murDeForce', 'lancer un mur de force', evt)) return;
        if (options.son) playSound(options.son);
        whisperChar(charId, "lance un sort de mur de force");
        if (sphere) {
          var scale = computeScale(pageId);
          var diametre = PIX_PER_UNIT * (6 / scale);
          if (options.puissantPortee || options.tempeteDeManaPortee) diametre += diametre;
          if (options.tempeteDeManaIntense)
            diametre *= (1 + options.tempeteDeManaIntense);
          let imageFields = {
            _pageid: pageId,
            imgsrc: imageSphere,
            represents: '',
            left: token.get('left'),
            top: token.get('top'),
            width: diametre,
            height: diametre,
            layer: 'map',
            name: "Mur de force",
            isdrawing: true,
          };
          var newImage = createObj('graphic', imageFields);
          if (newImage) {
            evt.tokens = [newImage];
            toFront(newImage);
            setTokenAttr(lanceur, 'murDeForceId', newImage.id, evt);
            var duree = 5 + modCarac(lanceur, 'charisme');
            if (options.puissantDuree || options.tempeteDeManaDuree) duree += duree;
            setAttrDuree(lanceur, 'murDeForce', duree, evt);
          } else {
            error("Impossible de cr\xE9er l'image " + options.image, imageFields);
          }
        } else {
          sendPlayerAndGM(msg, playerId, "placer l'image du mur sur la carte");
        }
      });
    });
  }

  function tokensEnCombat() {
    var cmp = Campaign();
    var turnOrder = cmp.get('turnorder');
    if (turnOrder === '') return []; // nothing in the turn order
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length === 0) return [];
    var tokens = [];
    turnOrder.forEach(function(a) {
      if (a.id == -1) return;
      tokens.push({
        _id: a.id
      });
    });
    return tokens;
  }

  function devientCapitaine(msg) {
    var cmd = msg.content.split(' ');
    cmd = cmd.filter(function(c) {
      return c !== '';
    });
    if (cmd.length < 2) {
      error("La fonction !cof-capitaine attend en argument l'id du capitaine", cmd);
      return;
    }
    var remove;
    var capitaine;
    var nomCapitaine;
    var bonus = 2;
    var titre = 'capitaine';
    if (cmd[1] == '--aucun') {
      remove = true;
    } else {
      capitaine = persoOfId(cmd[1], cmd[1]);
      if (capitaine === undefined) {
        error("Le premier argument de !cof-lancer-sort doit \xEAtre un token", cmd[1]);
        return;
      }
      nomCapitaine = capitaine.token.get('name');
      if (cmd.length > 2 && !cmd[2].startsWith('--')) {
        bonus = parseInt(cmd[2]);
        if (isNaN(bonus) || bonus < 0) {
          error("Le bonus de capitaine (second argument) doit \xEAtre un nombre positif", cmd);
          return;
        }
        if (bonus === 0) remove = true;
        if (bonus > 2) titre = 'commandant';
      }
    }
    var evt = {
      type: 'Capitaine'
    };
    getSelected(msg, function(selected) {
      if (selected.length === 0) {
        error("Pas de token s\xE9lectionn\xE9 pour !cof-capitaine");
        return;
      }
      iterSelected(selected, function(perso) {
        var token = perso.token;
        if (remove) {
          removeCharAttr(perso.charId, 'capitaine', evt);
          removeCharAttr(perso.charId, 'capitaineActif', evt);
          sendChat('COF', "/w GM " + token.get('name') + " n'a plus de capitaine");
        } else {
          if (token.id == capitaine.token.id) return;
          setTokenAttr(perso, 'capitaine', capitaine.token.id + ' ' + nomCapitaine, evt, {
            maxVal: bonus,
            charAttr: true
          });
          sendChat('COF', "/w GM " + nomCapitaine + " est le " + titre + " de " + token.get('name'));
        }
      });
      addEvent(evt);
    });
  }


  function distribuerBaies(msg) {
    if (msg.selected === undefined || msg.selected.length != 1) {
      error("Pour utiliser !cof-distribuer-baies, il faut s\xE9lectionner un token", msg);
      return;
    }
    var druide = persoOfId(msg.selected[0]._id);
    if (druide === undefined) {
      error("Erreur de s\xE9lection dans !cof-distribuer-baies", msg.selected);
      return;
    }
    var niveau = ficheAttributeAsInt(druide, 'niveau', 1);
    var evt = {
      type: "Distribution de baies magiques"
    };
    var action = "Distribue des baies";
    var mangerBaie = "!cof-consommer-baie " + niveau + " --limiteParJour 1 baieMagique";
    getSelected(msg, function(selected, playerId) {
      var display = startFramedDisplay(playerId, action, druide);
      iterSelected(selected, function(perso) {
        var nom = perso.token.get('name');
        ajouterConsommable(perso, 'Baie magique', 1, mangerBaie, evt);
        var line = nom + " re\xE7oit une baie";
        if (perso.token.id == druide.token.id)
          line = nom + " en garde une pour " + onGenre(druide, "lui", "elle");
        addLineToFramedDisplay(display, line);
      });
      addEvent(evt);
      sendChat("", endFramedDisplay(display));
    }, {
      lanceur: druide
    }); //fin du getSelected
  }

  //!cof-consommer-baie niveau
  function consommerBaie(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 2) {
      error("Il faut un argument \xE0 !cof-consommer-baie", cmd);
      return;
    }
    var baie = parseInt(cmd[1]);
    if (isNaN(baie) || baie < 0) {
      error("L'argument de !cof-consommer-baie doit \xEAtre un nombre positif", cmd);
      return;
    }
    getSelected(msg, function(selection, playerId) {
      if (selection === undefined) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour !cof-consommer-baie", playerId);
        return;
      }
      var evt = {
        type: "consommer une baie"
      };
      addEvent(evt);
      iterSelected(msg.selected, function(perso) {
        if (limiteRessources(perso, options, 'baieMagique', "a d\xE9j\xE0 mang\xE9 une baie aujourd'hui. Pas d'effet.", evt)) return;
        var soins = rollDePlus(6, {
          bonus: baie
        });
        soigneToken(perso, soins.val, evt, function(soinsEffectifs) {
            var msgSoins = "mange une baie magique. Il est rassasi\xE9 et r\xE9cup\xE8re ";
            if (soinsEffectifs == soins.val) msgSoins += soins.roll + " points de vie";
            else msgSoins += soinsEffectifs + " PV (le jet \xE9tait " + soins.roll + ")";
            sendPerso(perso, msgSoins);
          },
          function() {
            sendPerso(perso, "mange une baie magique. " + onGenre(perso, "Il", "Elle") + " se sent rassasi\xE9" + onGenre(perso, '', 'e') + '.');
          });
      });
    }); //fin de getSelected
  }

  function replaceInline(msg) {
    if (msg.inlinerolls) {
      msg.content = _.chain(msg.inlinerolls)
        .reduce(function(m, v, k) {
          m['$[[' + k + ']]'] = v.results.total || 0;
          return m;
        }, {})
        .reduce(function(m, v, k) {
          return m.replace(k, v);
        }, msg.content)
        .value();
    }
  }

  /* Quand on prot\xE8ge un alli\xE9, on stocke l'id et le nom du token dans un attribut 'protegerUnAllie' (champs current et max), et pour ce token, on met un
   * attribut 'protegePar_nom' o\xF9 nom est le nom du token protecteur, et qui contient l'id et le nom du token protecteur
   * Ces attributs disparaissent \xE0 la fin des combats */
  function protegerUnAllie(msg) {
    var args = msg.content.split(" ");
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-proteger-un-allie: " + msg.content, args);
      return;
    }
    var protecteur = persoOfId(args[1], args[1]);
    if (protecteur === undefined) {
      error("Le premier argument n'est pas un token valide", args[1]);
      return;
    }
    var tokenProtecteur = protecteur.token;
    var nameProtecteur = tokenProtecteur.get('name');
    var pageId = tokenProtecteur.get('pageid');
    var target = persoOfId(args[2], args[2], pageId);
    if (target === undefined) {
      error("Le deuxi\xE8me argument n'est pas un token valide: " + msg.content, args[2]);
      return;
    }
    var tokenTarget = target.token;
    if (tokenTarget.id == tokenProtecteur.id) {
      sendPerso(protecteur, "ne peut pas se prot\xE9ger lui-m\xEAme");
      return;
    }
    var nameTarget = tokenTarget.get('name');
    var evt = {
      type: "Prot\xE9ger un alli\xE9"
    };
    var attrsProtecteur = tokenAttribute(protecteur, 'protegerUnAllie');
    var protegePar = 'protegePar_' + nameProtecteur;
    if (attrsProtecteur.length > 0) { //On prot\xE8ge d\xE9j\xE0 quelqu'un
      var previousTarget =
        persoOfId(attrsProtecteur[0].get('current'),
          attrsProtecteur[0].get('max'), pageId);
      if (previousTarget) {
        if (previousTarget.token.id == tokenTarget.id) {
          sendPerso(protecteur, "prot\xE8ge d\xE9j\xE0 " + nameTarget);
          return;
        }
        removeTokenAttr(previousTarget, protegePar, evt, {
          msg: "n'est plus prot\xE9g\xE9 par " + nameProtecteur
        });
      }
    }
    setTokenAttr(protecteur, 'protegerUnAllie',
      tokenTarget.id, evt, {
        msg: "prot\xE8ge " + nameTarget,
        nameTarget
      });
    setTokenAttr(target, protegePar, tokenProtecteur.id, evt, {
      maxVal: nameProtecteur
    });
    addEvent(evt);
  }

  function actionDefensive(msg) {
    var cmd = msg.content.split(' ');
    var def = 2; //pour une d\xE9fense simple
    var defMsg = "pr\xE9f\xE8re se d\xE9fendre pendant ce tour";
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'totale':
          def = 4;
          defMsg = "se consacre enti\xE8rement \xE0 sa d\xE9fense pendant ce tour";
          break;
        case 'simple':
          def = 2;
          break;
        default:
          error("Argument de !cof-action-defensive non reconnu", cmd);
      }
    }
    var evt = {
      type: "action d\xE9fensive"
    };
    getSelected(msg, function(selected) {
      initiative(selected, evt);
      iterSelected(selected, function(perso) {
        setTokenAttr(perso, 'defenseTotale', def, evt, {
          msg: defMsg,
          maxVal: stateCOF.tour
        });
      });
      addEvent(evt);
    });
  }

  function strangulation(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-strangulation: " + msg.content, args);
      return;
    }
    var necromancien = persoOfId(args[1], args[1]);
    if (necromancien === undefined) {
      error("Le premier argument n'est pas un token", args[1]);
      return;
    }
    var pageId = necromancien.token.get('pageid');
    var target = persoOfId(args[2], args[2], pageId);
    if (target === undefined) {
      error("Le deuxi\xE8me argument n'est pas un token valide: " + msg.content, args[2]);
      return;
    }
    var name2 = target.token.get('name');
    if (!attributeAsBool(target, 'strangulation')) {
      sendPerso(necromancien, "ne peut pas maintenir la strangulation. Il faut (re)lancer le sort");
      return;
    }
    var evt = {
      type: "Strangulation"
    };
    var dureeStrang = tokenAttribute(target, 'dureeStrangulation');
    var nouvelleDuree = 1;
    if (dureeStrang.length > 0) {
      nouvelleDuree = parseInt(dureeStrang[0].get('current'));
      if (isNaN(nouvelleDuree)) {
        log("Dur\xE9e de strangulation n'est pas un nombre");
        log(dureeStrang);
        nouvelleDuree = 1;
      } else nouvelleDuree++;
    }
    setTokenAttr(target, 'dureeStrangulation', nouvelleDuree, evt, {
      maxVal: true
    });
    let deStrang = 6;
    if (msg.content.includes(' --puissant')) deStrang = 8;
    let dmgExpr = "[[1d" + deStrang + " ";
    let modInt = modCarac(necromancien, 'intelligence');
    if (modInt > 0) dmgExpr += "+" + modInt;
    else if (modInt < 0) dmgExpr += modInt;
    dmgExpr += "]]";
    sendChat('', dmgExpr, function(res) {
      var dmg = {
        type: 'magique',
        total: res[0].inlinerolls[0].results.total,
        display: buildinline(res[0].inlinerolls[0], 'normal', true),
      };
      dealDamage(target, dmg, [], evt, false, {
          attaquant: necromancien
        }, undefined,
        function(dmgDisplay, dmg) {
          sendPerso(necromancien, "maintient sa strangulation sur " + name2 + ". Dommages : " + dmgDisplay);
          addEvent(evt);
        });
    });
  }


  function ombreMortelle(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 4) {
      error("Pas assez d'arguments pour " + cmd[0], cmd);
      return;
    }
    var lanceur = persoOfId(cmd[1], cmd[1]);
    if (lanceur === undefined) {
      error("Le premier argument n'est pas un token valide", cmd[1]);
      return;
    }
    var pageId = options.pageId || lanceur.token.get('pageid');
    var cible = persoOfId(cmd[2], cmd[2], pageId);
    if (cible === undefined) {
      error("La cible n'est pas un token valide", cmd[2]);
      return;
    }
    cible.tokName = cible.token.get('name');
    var duree = parseInt(cmd[3]);
    if (isNaN(duree) || duree <= 0) {
      error("La dur\xE9e doit \xEAtre un nombre positif", cmd);
      return;
    }
    var image = options.image || stateCOF.options.images.val.image_ombre.val;
    if (options.portee !== undefined) {
      var distance = distanceCombat(lanceur.token, cible.token, pageId);
      if (distance > options.portee) {
        sendPerso(lanceur, "est trop loind de " + cible.tokName +
          " pour animer son ombre");
        return;
      }
    }
    var evt = {
      type: "Ombre mortelle"
    };
    var msgRes = "invoquer une ombre mortelle";
    if (limiteRessources(lanceur, options, "Ombre_mortelle", msgRes, evt)) return;
    copieToken(cible, image, stateCOF.options.images.val.image_ombre.val, "Ombre de " + cible.tokName, 'ombreMortelle', duree, pageId, evt);
    var msgOmbre = "anime l'ombre de " + cible.tokName + ". Celle-ci commence \xE0 attaquer " + cible.tokName + "&nbsp;!";
    if (options.secret) whisperChar(lanceur.charId, msgOmbre);
    else sendPerso(lanceur, msgOmbre);
    addEvent(evt);
  }

  function copieToken(cible, image1, image2, nom, effet, duree, pageId, evt) {
    var pv = parseInt(cible.token.get('bar1_value'));
    if (isNaN(pv)) {
      error("Token avec des PV qui ne sont pas un nombre", cible.token);
      return;
    }
    if (pv > 1) pv = Math.floor(pv / 2);
    var pvMax = parseInt(cible.token.get('bar1_max'));
    if (isNaN(pvMax)) {
      error("Token avec des PV max qui ne sont pas un nombre", cible.token);
      return;
    }
    if (pvMax > 1) pvMax = Math.floor(pvMax / 2);
    let tokenFields = {
      _pageid: pageId,
      imgsrc: image1,
      represents: cible.charId,
      left: cible.token.get('left') + 60,
      top: cible.token.get('top'),
      width: cible.token.get('width'),
      height: cible.token.get('height'),
      rotation: cible.token.get('rotation'),
      layer: 'objects',
      name: nom,
      bar1_value: pv,
      bar1_max: pvMax,
      bar2_value: cible.token.get('bar2_value'),
      bar2_max: cible.token.get('bar2_max'),
      bar3_value: cible.token.get('bar3_value'),
      bar3_max: cible.token.get('bar3_max'),
      showname: true,
      showplayers_name: true,
      showplayers_bar1: cible.token.get('showplayers_bar1'),
    };
    var newToken;
    if (image1) newToken = createObj('graphic', tokenFields);
    if (newToken === undefined) {
      tokenFields.imgsrc = cible.token.get('imgsrc').replace('/max.png', '/thumb.png').replace('/med.png', '/thumb.png');
      newToken = createObj('graphic', tokenFields);
      if (newToken === undefined) {
        log(tokenFields.imgsrc);
        if (image2 && image2 != image1) {
          tokenFields.imgsrc = image2;
          newToken = createObj('graphic', tokenFields);
        }
        if (newToken === undefined) {
          error("L'image du token s\xE9lectionn\xE9 n'a pas \xE9t\xE9 upload\xE9, et l'image par d\xE9faut n'est pas correcte. Impossible de cr\xE9er un token.", tokenFields);
          return;
        }
      }
    }
    evt.tokens = evt.tokens || [];
    evt.tokens.push(newToken);
    var perso = {
      token: newToken,
      charId: cible.charId
    };
    setAttrDuree(perso, effet, duree, evt);
    initPerso(perso, evt);
  }

  //retourne true si le joueur est effectivement d\xE9plac\xE9
  function movePlayerToPage(pid, oldPageId, newPageId) {
    if (getObj('player', pid) === undefined) return;
    var c = Campaign();
    var playerPages = c.get('playerspecificpages');
    var playersMainPage = c.get('playerpageid');
    if (!playerPages) playerPages = {};
    if ((playerPages[pid] && playerPages[pid] == oldPageId)) {
      if (playersMainPage == newPageId) {
        c.set('playerspecificpages', false);
        if (_.size(playerPages) > 1) {
          delete playerPages[pid];
          c.set('playerspecificpages', playerPages);
        }
      } else {
        playerPages[pid] = newPageId;
        c.set('playerspecificpages', false);
        c.set('playerspecificpages', playerPages);
      }
    } else if ((!playerPages[pid] && playersMainPage == oldPageId)) {
      playerPages[pid] = newPageId;
      var allPlayers = findObjs({
        _type: 'player'
      });
      var allOnNewPage = allPlayers.every(function(p) {
        if (playerIsGM(p.id)) return true;
        return playerPages[p.id] == newPageId;
      });
      c.set('playerspecificpages', false);
      if (allOnNewPage) {
        Campaign().set('playerpageid', newPageId);
      } else {
        c.set('playerspecificpages', playerPages);
      }
    }
  }

  function findEsc(escaliers, escName, i) {
    var fullEscName = escName + labelsEscalier[i];
    var sortieEscalier = escaliers.find(function(esc) {
      return esc.get('name') == fullEscName;
    });
    if (sortieEscalier === undefined && i > 0) return findEsc(escName, i - 1);
    return sortieEscalier;
  }

  //Attention : ne tient pas compte de la rotation !
  function intersection(pos1, size1, pos2, size2) {
    if (pos1 == pos2) return true;
    if (pos1 < pos2) return ((pos1 + size1 / 2) >= pos2 - size2 / 2);
    return ((pos2 + size2 / 2) >= pos1 - size1 / 2);
  }

  var labelsEscalier = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"];

  function escalier(msg) {
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de s\xE9lection de token pour !cof-escalier", playerId);
        log("!cof-escalier requiert de s\xE9lectionner des tokens");
        return;
      }
      var pageId = getObj('graphic', selected[0]._id).get('pageid');
      var escaliers = findObjs({
        _type: 'graphic',
        _pageid: pageId,
        layer: 'gmlayer'
      });
      if (escaliers.length === 0) {
        sendPlayer(msg, "Pas de token dans le layer GM", playerId);
        return;
      }
      var tmaps; //Les passages entre les maps.
      var versLeHaut = true;
      var loop = true;
      if (msg.content) {
        if (msg.content.includes(' bas')) {
          versLeHaut = false;
          loop = false;
        } else if (msg.content.includes(' haut')) {
          versLeHaut = true;
          loop = false;
        }
      }
      iterSelected(selected, function(perso) {
        var token = perso.token;
        var posX = token.get('left');
        var sizeX = token.get('width');
        var posY = token.get('top');
        var sizeY = token.get('height');
        var sortieEscalier;
        escaliers.forEach(function(esc) {
          if (sortieEscalier) return;
          if (intersection(posX, sizeX, esc.get('left'), esc.get('width')) &&
            intersection(posY, sizeY, esc.get('top'), esc.get('height'))) {
            var escName = esc.get('name');
            var l = escName.length;
            if (l > 1) {
              var label = escName.substr(l - 1, 1);
              escName = escName.substr(0, l - 1);
              var i = labelsEscalier.indexOf(label);
              if (versLeHaut) {
                if (i == 11) {
                  if (loop) escName += labelsEscalier[0];
                } else escName += labelsEscalier[i + 1];
              } else {
                if (i === 0) {
                  if (loop) escName += labelsEscalier[11];
                } else escName += labelsEscalier[i - 1];
              }
              var escs = escaliers;
              if (escName.startsWith('tmap_')) {
                if (!tmaps) {
                  tmaps = findObjs({
                    _type: 'graphic',
                    layer: 'gmlayer'
                  });
                  tmaps = tmaps.filter(function(e) {
                    return e.get('name').startsWith('tmap_');
                  });
                }
                escs = tmaps;
              }
              sortieEscalier = escs.find(function(esc2) {
                return esc2.get('name') == escName;
              });
              if (sortieEscalier === undefined && loop) {
                if (i > 0) { //sortie par le plus petit
                  escName = escName.substr(0, l - 1) + 'A';
                  sortieEscalier = escs.find(function(esc2) {
                    return esc2.get('name') == escName;
                  });
                } else {
                  sortieEscalier = findEsc(escs, escName.substr(0, l - 1), 10);
                }
              }
            }
          }
        });
        if (sortieEscalier) {
          var left = sortieEscalier.get('left');
          var top = sortieEscalier.get('top');
          var newPageId = sortieEscalier.get('pageid');
          //D\xE9placement du token
          if (newPageId == pageId) {
            token.set('left', left);
            token.set('top', top);
          } else {
            //On change de carte, il faut donc copier le token
            var tokenObj = JSON.parse(JSON.stringify(token));
            tokenObj._pageid = newPageId;
            //On met la taille du token \xE0 jour en fonction des \xE9chelles des cartes.
            var ratio = computeScale(pageId) / computeScale(newPageId);
            if (ratio < 0.9 || ratio > 1.1) {
              if (ratio < 0.25) ratio = 0.25;
              else if (ratio > 4) ratio = 4;
              tokenObj.width *= ratio;
              tokenObj.height *= ratio;
            }
            tokenObj.imgsrc = tokenObj.imgsrc.replace('/med.png', '/thumb.png');
            tokenObj.imgsrc = tokenObj.imgsrc.replace('/max.png', '/thumb.png');
            tokenObj.left = left;
            tokenObj.top = top;
            var newToken = createObj('graphic', tokenObj);
            if (newToken === undefined) {
              error("Impossible de copier le token, et donc de faire le changement de carte", tokenObj);
              return;
            }
          }
          //On d\xE9place ensuite le joueur.
          var character = getObj('character', perso.charId);
          if (character === undefined) return;
          var charControlledby = character.get('controlledby');
          if (charControlledby === '') {
            //Seul le MJ contr\xF4le le personnage
            var players = findObjs({
              _type: 'player',
              online: true
            });
            var gm = players.find(function(p) {
              return playerIsGM(p.id);
            });
            if (gm) {
              if (newPageId != pageId) movePlayerToPage(gm.id, pageId, newPageId);
              sendPing(left, top, newPageId, gm.id, true, gm.id);
            }
          } else {
            charControlledby.split(",").forEach(function(pid) {
              if (newPageId != pageId) movePlayerToPage(pid, pageId, newPageId);
              sendPing(left, top, newPageId, pid, true, pid);
            });
          }
          //Enfin, on efface le token de d\xE9part si on a chang\xE9 de page
          if (newPageId != pageId) token.remove();
          return;
        }
        var err = token.get('name') + " n'est pas sur un escalier";
        if (!loop) {
          if (versLeHaut) err += " qui monte";
          else err += " qui descend";
        }
        sendPlayer(msg, err, playerId);
      });
    }); //fin getSelected
  }

  function defautDansLaCuirasse(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-defaut-dans-la-cuirasse", args);
      return;
    }
    var tireur = persoOfId(args[1], args[1]);
    if (tireur === undefined) {
      error("Le premier argument n'est pas un token valide", args[1]);
      return;
    }
    var pageId = tireur.token.get('pageid');
    var cible = persoOfId(args[2], args[2], pageId);
    if (cible === undefined) {
      error("La cible n'est pas un token valide", args[2]);
      return;
    }
    var evt = {
      type: "D\xE9faut dans la cuirasse"
    };
    setTokenAttr(cible, 'defautDansLaCuirasse_' + tireur.token.get('name'), 2, evt);
    sendPerso(tireur, "passe le tour \xE0 analyser les points faibles de " + cible.token.get('name'));
    addEvent(evt);
  }

  function postureDeCombat(msg) {
    var args = msg.content.split(' ');
    if (args.length < 4) {
      error("Pas assez d'arguments pour !cof-posture-de-combat", args);
      return;
    }
    var bonus = parseInt(args[1]);
    var attrDebuf = args[2];
    if (attrDebuf != 'DEF' && attrDebuf != 'ATT' && attrDebuf != 'DM') {
      error("L'attribut \xE0 d\xE9buffer pour la posture de combat est incorrect", args);
      return;
    }
    var attrBuf = args[3];
    if (attrBuf != 'DEF' && attrBuf != 'ATT' && attrBuf != 'DM') {
      error("L'attribut \xE0 augmenter pour la posture de combat est incorrect", args);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(guerrier) {
        if (isNaN(bonus) || bonus < 1) {
          sendPlayer(msg, "choisir un bonus positif (pas " + args[1] + ") pour sa posture de combat", playerId);
          return;
        }
        var rang = predicateAsInt(guerrier, "voieDuSoldat", 0);
        if (rang > 0 && rang < bonus) {
          sendPerso(guerrier, "ne peut choisir qu'un bonus inf\xE9rieur \xE0 " + rang + " pour sa posture de combat");
          return;
        }
        var evt = {
          type: "Posture de combat"
        };
        if (attrBuf == attrDebuf) {
          sendPerso(guerrier, "prend une posture de combat neutre");
          removeTokenAttr(guerrier, 'postureDeCombat', evt);
          addEvent(evt);
          return;
        }
        msg = "prend une posture ";
        switch (attrBuf) {
          case 'DEF':
            msg += "d\xE9fensive";
            break;
          case 'ATT':
            msg += "offensive";
            break;
          case 'DM':
            msg += "puissante";
            break;
          default:
        }
        msg += " mais ";
        switch (attrDebuf) {
          case 'DEF':
            msg += "risqu\xE9e";
            break;
          case 'ATT':
            msg += "moins pr\xE9cise";
            break;
          case 'DM':
            msg += "moins puissante";
            break;
          default:
        }
        setTokenAttr(guerrier, 'postureDeCombat', bonus, evt, {
          msg: msg,
          maxVal: attrDebuf + "_" + attrBuf
        });
        addEvent(evt);
      });
    });
  }

  function attaqueAOutrance(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("Pas assez d'arguments pour !cof-attaque-a-outrance", args);
      return;
    }
    var bonus = parseInt(args[1]);
    if (bonus != 0 && bonus != 2 && bonus != 5) {
      error("Le malus de DEF ne peut \xEAtre que 0, 2 ou 5", args);
      return;
    }
    getSelected(msg, function(selected) {
      iterSelected(selected, function(guerrier) {
        var evt = {
          type: "Attaque \xE0 outrance"
        };
        if (bonus === 0) {
          sendPerso(guerrier, "n'attaque plus \xE0 outrance");
          removeTokenAttr(guerrier, 'attaqueAOutrance', evt);
          addEvent(evt);
          return;
        }
        msg = "attaque \xE0 outrance ";
        switch (bonus) {
          case 2:
            msg += "(-2 DEF, +1D6 DM)";
            break;
          case 5:
            msg += "(-5 DEF, +2D6 DM)";
            break;
          default:
        }
        setTokenAttr(guerrier, 'attaqueAOutrance', bonus, evt, {
          msg: msg,
        });
        addEvent(evt);
      });
    });
  }

  function parseTourDeForce(msg) { // Deprecated
    var options = parseOptions(msg);
    var cmd = options.cmd;
    if (cmd < 2) {
      error("Il manque un argument \xE0 !cof-tour-de-force", cmd);
      return;
    }
    var seuil = parseInt(cmd[1]);
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(barbare) {
        if (isNaN(seuil)) {
          sendPlayer(msg, "le seuil de difficult\xE9 du tour de force doit \xEAtre un nombre", playerId);
          return;
        }
        doTourDeForce(barbare, seuil, options);
      });
    });
  }

  function doTourDeForce(perso, seuil, options) { // Deprecated
    let evt = {
      type: "tourDeForce",
      action: {
        perso: perso,
        seuil: seuil,
        options: options
      }
    };
    addEvent(evt);
    let action = "<b>Capacit\xE9</b> : Tour de force";
    let display = startFramedDisplay(options.playerId, action, perso);
    let testId = 'tourDeForce';
    options.bonus = 10;
    testCaracteristique(perso, 'FOR', seuil, testId, options, evt,
      function(tr) {
        addLineToFramedDisplay(display, " Jet de force difficult\xE9 " + seuil);
        let smsg = perso.token.get('name') + " fait " + tr.texte;
        if (tr.reussite) {
          smsg += " => r\xE9ussite";
        } else {
          smsg += " => \xE9chec" + tr.rerolls;
        }
        addLineToFramedDisplay(display, smsg);
        let d4 = options.rolls.tourDeForceDmg || rollDePlus(4);
        evt.action.rolls.tourDeForceDmg = d4;
        let r = {
          total: d4.val,
          type: 'normal',
          display: d4.roll
        };
        let explications = [];
        perso.ignoreTouteRD = true;
        dealDamage(perso, r, [], evt, false, {}, explications,
          function(dmgDisplay, dmg) {
            let dmgMsg = "mais cela lui co\xFBte " + dmgDisplay + " PV";
            addLineToFramedDisplay(display, dmgMsg);
            explications.forEach(function(expl) {
              addLineToFramedDisplay(display, expl, 80);
            });
            sendChat('', endFramedDisplay(display));
          });
      });
  }

  function removePreDmg(options, perso, champ, newVal) {
    if (options.preDmg) {
      if (options.preDmg[perso.token.id]) {
        if (champ && options.preDmg[perso.token.id][champ]) {
          if (newVal) options.preDmg[perso.token.id][champ] = newVal;
          else delete options.preDmg[perso.token.id][champ];
        }
        if (champ === undefined || _.isEmpty(options.preDmg[perso.token.id]))
          delete options.preDmg[perso.token.id];
      }
      if (_.isEmpty(options.preDmg)) delete options.preDmg;
    }
  }

  //!cof-encaisser-un-coup, avec la personne qui encaisse s\xE9lectionn\xE9e
  function doEncaisserUnCoup(msg) {
    var optionsEncaisser = parseOptions(msg);
    if (optionsEncaisser === undefined) return;
    var cmd = optionsEncaisser.cmd;
    var evt = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evt = findEvent(cmd[1]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Personne n'est s\xE9lectionn\xE9 pour encaisser un coup", msg);
        return;
      }
      if (evt === undefined) {
        sendChat('', "Historique d'actions vide, pas d'action trouv\xE9e pour encaisser un coup");
        return;
      }
      if (evt.type != 'Attaque' || evt.succes === false) {
        sendChat('', "la derni\xE8re action n'est pas une attaque r\xE9ussie, trop tard pour encaisser le coup d'une action pr\xE9c\xE9dente");
        return;
      }
      var action = evt.action;
      if (action.options.distance) {
        sendChat('', "Impossible d'encaisser le dernier coup, ce n'\xE9tait pas une attaque au contact");
        return;
      }
      var toProceed;
      iterSelected(selected, function(chevalier) {
        if (!attributeAsBool(chevalier, 'encaisserUnCoup')) {
          sendPerso(chevalier, "n'est pas plac\xE9 pour encaisser un coup");
          return;
        }
        if (!peutController(msg, chevalier)) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton", playerId);
          return;
        }
        var cible = action.cibles.find(function(target) {
          return (target.token.id === chevalier.token.id);
        });
        if (cible === undefined) {
          sendPerso(chevalier, "n'est pas la cible de la derni\xE8re attaque");
          return;
        }
        action.choices = action.choices || {};
        action.choices[chevalier.token.id] = action.choices[chevalier.token.id] || {};
        action.choices[chevalier.token.id].encaisserUnCoup = true;
        toProceed = true;
      }); //fin iterSelected
      if (toProceed) {
        var options = action.currentOptions || {};
        options.rolls = action.rolls;
        options.choices = action.choices;
        resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, options, evt, action.explications, action.pageId, action.cibles);
      }
    }); //fin getSelected
  }

  function appliquerEncaisserUnCoup(cible, options, evt) {
    removeTokenAttr(cible, 'encaisserUnCoup', evt);
    cible.extraRD =
      ficheAttributeAsInt(cible, 'defarmure', 0) *
      ficheAttributeAsInt(cible, 'defarmureon', 0) +
      ficheAttributeAsInt(cible, 'defbouclier', 0) *
      ficheAttributeAsInt(cible, 'defbouclieron', 0);
    removePreDmg(options, cible, "encaisserUnCoup");
  }

  //!cof-devier-les-coups, avec la personne qui encaisse s\xE9lectionn\xE9e
  function doDevierLesCoups(msg) {
    var optionsDevier = parseOptions(msg);
    if (optionsDevier === undefined) return;
    var cmd = optionsDevier.cmd;
    var evt = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evt = findEvent(cmd[1]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Personne n'est s\xE9lectionn\xE9 pour d\xE9vier les coups", msg);
        return;
      }
      if (evt === undefined) {
        sendChat('', "Historique d'actions vide, pas d'action trouv\xE9e pour d\xE9vier les coups");
        return;
      }
      if (evt.type != 'Attaque' || evt.succes === false) {
        sendChat('', "la derni\xE8re action n'est pas une attaque r\xE9ussie, trop tard pour d\xE9vier les coups d'une action pr\xE9c\xE9dente");
        return;
      }
      var action = evt.action;
      if (action.options.distance) {
        sendChat('', "Impossible d'encaisser le dernier coup, ce n'\xE9tait pas une attaque au contact");
        return;
      }
      var toProceed;
      iterSelected(selected, function(perso) {

        let testDevierCoups = testLimiteUtilisationsCapa(perso, 'devierLesCoups', 'tour', "ne peut plus d\xE9vier les coups \xE0 ce tour-ci");
        if (testDevierCoups === undefined) return;
        if (!peutController(msg, perso)) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton", playerId);
          return;
        }
        let cible = action.cibles.find(function(target) {
          return (target.token.id === perso.token.id);
        });
        if (cible === undefined) {
          sendPerso(perso, "n'est pas la cible de la derni\xE8re attaque");
          return;
        }
        action.choices = action.choices || {};
        action.choices[perso.token.id] = action.choices[perso.token.id] || {};
        action.choices[perso.token.id].devierLesCoups = testDevierCoups;
        toProceed = true;
      }); //fin iterSelected
      if (toProceed) {
        var options = action.currentOptions || {};
        options.rolls = action.rolls;
        options.choices = action.choices;
        resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, options, evt, action.explications, action.pageId, action.cibles);
      }
    }); //fin getSelected
  }

  function appliquerDevierLesCoups(cible, test, options, evt) {
    utiliseCapacite(cible, test, evt);
    cible.extraRDBouclier =
      ficheAttributeAsInt(cible, 'defbouclier', 0) *
      ficheAttributeAsInt(cible, 'defbouclieron', 0);
    removePreDmg(options, cible, 'devierLesCoups');
  }

  //!cof-parade-projectiles
  function doParadeProjectiles(msg) {
    var optionsParade = parseOptions(msg);
    if (optionsParade === undefined) return;
    var cmd = optionsParade.cmd;
    var evt = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evt = findEvent(cmd[1]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Personne n'est s\xE9lectionn\xE9 pour parer le projectile", msg);
        return;
      }
      if (evt === undefined) {
        sendChat('', "Historique d'actions vide, pas d'action trouv\xE9e pour parer le projectile");
        return;
      }
      if (evt.type != 'Attaque' || evt.succes === false) {
        sendChat('', "la derni\xE8re action n'est pas une attaque r\xE9ussie, trop tard pour parer le projectile d'une action pr\xE9c\xE9dente");
        return;
      }
      var action = evt.action;
      if (!action.options.distance) {
        sendChat('', "Impossible de parer le projectile, ce n'\xE9tait pas une attaque \xE0 distance");
        return;
      }
      if (action.options.poudre) {
        sendChat('', "Impossible de parer le projectile, il s'agit d'une arme \xE0 poudre");
        return;
      }
      if (action.cibles.length > 1) {
        sendChat('', "Impossible de parer un projectile qui touche plusieurs cibles");
        return;
      }
      let toProceed;
      iterSelected(selected, function(moine) {
        let testParadeProjectiles = testLimiteUtilisationsCapa(moine, 'paradeDeProjectiles', 'tour', "ne peut plus parer de projectiles");
        if (testParadeProjectiles === undefined) {
          return;
        }
        if (!peutController(msg, moine)) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton", playerId);
          return;
        }
        let cible = action.cibles.find(function(target) {
          return (target.token.id === moine.token.id);
        });
        if (cible === undefined) {
          sendPerso(moine, "n'est pas la cible de la derni\xE8re attaque");
          return;
        }
        action.choices = action.choices || {};
        action.choices[moine.token.id] = action.choices[moine.token.id] || {};
        action.choices[moine.token.id].paradeDeProjectiles = testParadeProjectiles;
        toProceed = true;
      }); //fin iterSelected
      if (toProceed) {
        var options = action.currentOptions || {};
        options.rolls = action.rolls;
        options.choices = action.choices;
        resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, options, evt, action.explications, action.pageId, action.cibles);
      }
    }); //fin getSelected
  }

  function appliquerParadeProjectiles(cible, test, options, evt) {
    utiliseCapacite(cible, test, evt);
    options.preDmgAnnule = true;
    removePreDmg(options, cible);
  }

  // asynchrone : on fait les jets du personnage en opposition
  // options :
  // predicat : on utilise un pr\xE9dicat et non un attribut. Peut \xEAtre 'tour' ou 'cmbat'
  // protecteur: c'est un protecteur qui prot\xE8ge la cible (pas compatible avec predicate
  function evitementGenerique(msg, verbe, attributeName, actionName, tente, msgDejaFait, carac, typeAttaque, msgReussite, opt) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 1) {
      error("Impossible de trouve la commande !", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Pas assez d'arguments pour " + cmd[0], cmd);
      return;
    }
    var evt;
    var chance;
    if (cmd.length > 2) { //On relance pour un \xE9v\xE9nement particulier
      evt = findEvent(cmd[2]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
      chance = cmd.length > 3 && cmd[3] == 'chance';
    } else {
      evt = lastEvent();
    }
    if (evt === undefined) {
      sendChat('', "Historique d'actions vide, pas d'action trouv\xE9e pour esquiver");
      return;
    }
    if (evt.type != 'Attaque') {
      sendChat('', "la derni\xE8re action n'est pas une attaque r\xE9ussie, trop tard pour " + verbe + " l'attaque pr\xE9c\xE9dente");
      return;
    }
    var perso = persoOfId(cmd[1]);
    if (perso === undefined) {
      error("Le premier argument de " + cmd[0] + " n'est pas un token de personnage", cmd);
      return;
    }
    var action = evt.action;
    var optionsAttaque = action.currentOptions;
    var pageId = action.pageId;
    var cible = action.cibles.find(function(target) {
      return (target.token.id === perso.token.id);
    });
    if (cible === undefined) {
      sendPerso(perso, "n'est pas la cible de la derni\xE8re attaque");
      return;
    }
    let attributAVerifier = attributeName;
    let persoAttribut = perso;
    if (opt.protecteur) { // c'est un personnage tiers qui prot\xE8ge la cible
      var protecteurAttrs = tokenAttribute(perso, attributeName + 'Valeur');
      if (protecteurAttrs.length < 1) {
        error("Erreur interne dans le bouton de protection, protecteur introuvable", cmd);
        return;
      }
      persoAttribut = persoOfId(protecteurAttrs[0].get("current"));
      attributAVerifier = attributeName + "Actif";
      if (persoAttribut === undefined) {
        error("Erreur interne dans le bouton de protection, protecteur introuvable", cmd);
        return;
      }
      opt.protecteur = persoAttribut;
    }
    if (!peutController(msg, persoAttribut)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    if (opt && opt.condition && !opt.condition(perso)) {
      resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, optionsAttaque, evt, action.explications, pageId, action.cibles);
    }
    var jetAdversaire = cible.attackRoll;
    if (jetAdversaire === undefined) {
      error("Impossible de trouver le jet de l'attaquant", cible);
      return;
    }
    let attribut;
    let testPredicat;
    if (opt && opt.predicat) {
      testPredicat = testLimiteUtilisationsCapa(perso, attributeName, opt.predicat, msgDejaFait, "ne sait pas faire " + actionName);
      if (testPredicat === undefined) return;
      testPredicat.perso = perso;
    } else {
      attribut = tokenAttribute(persoAttribut, attributAVerifier);
      if (attribut.length === 0) {
        sendPerso(persoAttribut, "ne sait pas faire " + actionName);
        return;
      }
      attribut = attribut[0];
      if (opt && opt.attrAsBool) {
        if (!attribut.get('current')) {
          sendPerso(persoAttribut, msgDejaFait);
          return;
        }
      } else {
        let curAttribut = parseInt(attribut.get('current'));
        if (isNaN(curAttribut)) {
          error("Resource pour " + actionName + " mal form\xE9e", attribut);
          return;
        }
        if (curAttribut < 1) {
          sendPerso(persoAttribut, msgDejaFait);
          return;
        }
      }
    }
    optionsAttaque.choices = action.choices || {};
    optionsAttaque.choices[perso.token.id] = optionsAttaque.choices[perso.token.id] || {};
    optionsAttaque.choices[perso.token.id].evitementGenerique =
      optionsAttaque.choices[perso.token.id].evitementGenerique || [];
    optionsAttaque.choices[perso.token.id].evitementGenerique.push({
      jetAdversaire,
      attribut,
      testPredicat,
      opt,
      attributeName,
      actionName,
      tente,
      carac,
      typeAttaque,
      msgReussite
    });
    optionsAttaque.rolls = action.rolls;
    resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, optionsAttaque, evt, action.explications, action.pageId, action.cibles);
  }

  function appliquerEvitementGenerique(cible, evitementGen, pageId, options, evt, callback) {
    let action = evt.action;
    let lanceur = cible;
    let {
      jetAdversaire,
      attribut,
      testPredicat,
      opt,
      attributeName,
      actionName,
      tente,
      carac,
      typeAttaque,
      msgReussite
    } = evitementGen;
    if (opt && opt.protecteur) {
      lanceur = opt.protecteur;
    }
    if (attribut) {
      if (opt && opt.attrAsBool) {
        evt.deletedAttributes = evt.deletedAttributes || [];
        evt.deletedAttributes.push(attribut);
      } else {
        let curAttribut = parseInt(attribut.get('current'));
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attribut,
          current: curAttribut
        });
        attribut.set('current', curAttribut - 1);
      }
    } else if (testPredicat) {
      utiliseCapacite(testPredicat.perso, testPredicat, evt);
    } else { //ni attribut ni pr\xE9dicat
      error("On n'a ni attribut ni pr\xE9dicat pour un \xE9vitement g\xE9n\xE9rique", evitementGen);
      return;
    }
    let attackRollExpr = "[[" + computeDice(lanceur) + "cs20cf1]]";
    sendChat('', attackRollExpr, function(res) {
      let testId = attributeName + "_" + lanceur.token.id;
      options.rolls = options.rolls || {};
      var attackRoll = options.rolls[testId] || res[0].inlinerolls[0];
      attackRoll.token = lanceur.token;
      evt.action.rolls = evt.action.rolls || {};
      evt.action.rolls[testId] = attackRoll;
      var d20roll = attackRoll.results.total;
      var msg = buildinline(attackRoll);
      var attBonus = ficheAttributeAsInt(lanceur, 'niveau', 1);
      if (estAffaibli(lanceur) && predicateAsBool(lanceur, 'insensibleAffaibli')) attBonus -= 2;
      switch (typeAttaque) {
        case 'distance':
          attBonus += ficheAttributeAsInt(lanceur, 'ATKTIR_DIV', 0);
          if (stateCOF.setting_arran ||
            (stateCOF.setting_mixte && ficheAttribute(lanceur, 'option_setting', 'generique') == 'arran')) {
            attBonus += ficheAttributeAsInt(lanceur, 'mod_atktir', 0);
          }
          attBonus += modCarac(lanceur, carac);
          break;
        case 'magique':
          attBonus += ficheAttributeAsInt(lanceur, 'ATKMAG_DIV', 0);
          if (stateCOF.setting_arran ||
            (stateCOF.setting_mixte && ficheAttribute(lanceur, 'option_setting', 'generique') == 'arran')) {
            attBonus += ficheAttributeAsInt(lanceur, 'mod_atkmag', 0);
            attBonus += modCarac(lanceur, 'intelligence');
          } else {
            attBonus += modCarac(lanceur, carac);
          }
          break;
        case 'contact':
          attBonus += ficheAttributeAsInt(lanceur, 'ATKCAC_DIV', 0);
          attBonus += modCarac(lanceur, carac);
          break;
        default:
      }
      if (opt && opt.arme && lanceur.arme) {
        actionName = lanceur.arme.nom;
        if (lanceur.arme.attSkillDiv) attBonus += lanceur.arme.attSkillDiv;
      }
      if (opt && opt.armeGauche && lanceur.armeGauche) {
        actionName = lanceur.armeGauche.nom;
        if (lanceur.armeGauche.attSkillDiv) attBonus += lanceur.armeGauche.attSkillDiv;
      }
      var totalEvitement = d20roll + attBonus;
      if (attBonus > 0) msg += "+" + attBonus;
      else if (attBonus < 0) msg += attBonus;
      if (options.chanceRollId && options.chanceRollId[testId]) {
        totalEvitement += options.chanceRollId[testId];
        msg += "+" + options.chanceRollId[testId];
      }
      var optionsEvitement = {
        displayName: true,
        pasDeDmg: true
      };
      var attEvBonus = bonusAttaqueA(cible, actionName, evt, cible.messages, optionsEvitement);
      var bad = bonusAttaqueD(lanceur, action.attaquant, 0, pageId, evt, cible.messages, optionsEvitement);
      attEvBonus += bad;
      if (opt && opt.bonusAttaque) attEvBonus += opt.bonusAttaque;
      if (attEvBonus > 0) msg += "+" + attEvBonus;
      else if (attEvBonus < 0) msg += attEvBonus;
      msg = lanceur.tokName + " tente " + tente + ". " +
        onGenre(lanceur, "Il", "elle") + " fait " + msg;
      var generalMsg = '';
      if (totalEvitement < jetAdversaire) {
        msg += " => Rat\xE9";
        var pc = pointsDeChance(lanceur);
        if (attackRoll.results.total != 1 && pc > 0) {
          generalMsg += '<br/>' +
            boutonSimple("!cof-bouton-chance " + evt.id + " " + testId, "Chance") +
            " (reste " + pc + " PC)";
        }
        if (stateCOF.combat && attributeAsBool(lanceur, 'runeForgesort_\xE9nergie') &&
          attributeAsInt(lanceur, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0 &&
          (carac == 'force' || carac == 'constitution' || carac == 'dexterite')) {
          generalMsg += '<br/>' + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + testId, "Rune d'\xE9nergie");
        }
        if (stateCOF.combat && capaciteDisponible(lanceur, 'petitVeinard', 'combat')) {
          generalMsg += '<br/>' + boutonSimple("!cof-bouton-petit-veinard " + evt.id + " " + testId, "Petit veinard");
        }
        if (generalMsg === '') { //Ne retirer l'option que si aucun reroll possible
          removePreDmg(options, cible, attributeName);
        } else { //Sinon cacher le bouton mais laisser l'option reroll
          removePreDmg(options, cible, attributeName, 'reroll');
        }
      } else { //\xC9vitement r\xE9ussi
        if (opt && cible.critique && (opt.critiqueDevientNormal || (opt.critiqueAnnuleCritique && d20roll != 20))) {
          cible.critique = false;
          msg += " => R\xE9ussi, l'attaque fait des d\xE9g\xE2ts normaux";
          removePreDmg(options, cible, attributeName);
        } else {
          cible.touche = false;
          if (opt.annule) {
            delete options.preDmg;
            options.preDmgAnnule = true;
            generalMsg += " => R\xE9ussi, " + msgReussite;
          } else {
            action.ciblesTouchees = action.ciblesTouchees.filter(function(c) {
              return c.token.id != cible.token.id;
            });
            removePreDmg(options, cible);
            msg += " => R\xE9ussi, " + msgReussite;
          }
        }
      }
      callback(msg, generalMsg);
    });
  }

  //!cof-absorber-coup-au-bouclier id [evtid] [chance]
  function absorberCoupAuBouclier(msg) {
    var condition = function(guerrier) {
      if (ficheAttributeAsInt(guerrier, 'defbouclieron', 0) != 1) {
        sendPerso(guerrier, "ne porte pas son bouclier, il ne peut pas aborber de coup");
        return false;
      }
      return true;
    };
    evitementGenerique(msg, "absorber un coup au bouclier", 'absorberUnCoup',
      "d'absorption de coup au bouclier", "d'absorber un coup au bouclier",
      " a d\xE9j\xE0 essay\xE9 d'absorber un coup au bouclier ce tour", 'force', 'contact', "le coup est absorb\xE9 !", {
        attrAsBool: true,
        condition: condition
      });
  }

  //!cof-absorber-sort-au-bouclier id [evtid] [chance]
  function absorberSortAuBouclier(msg) {
    var condition = function(guerrier) {
      if (ficheAttributeAsInt(guerrier, 'defbouclieron', 0) != 1) {
        sendPerso(guerrier, "ne porte pas son bouclier, il ne peut pas aborber un sort");
        return false;
      }
      return true;
    };
    evitementGenerique(msg, "absorber un sort au bouclier", 'absorberUnSort',
      "d'absorption de sort au bouclier", "d'absorber un sort au bouclier",
      " a d\xE9j\xE0 essay\xE9 d'absorber un sort au bouclier ce tour", 'sagesse', 'magique', "le sort est absorb\xE9 !", {
        attrAsBool: true,
        condition: condition
      });
  }

  // asynchrone : on fait les jets du barbare en opposition
  //!cof-resister-a-la-magie id [evtid] [chance]
  function resisterALaMagie(msg) {
    evitementGenerique(msg, 'r\xE9sister \xE0 la magie', 'resistanceALaMagieBarbare',
      'r\xE9sistance \xE0 la magie', "de r\xE9sister \xE0 la magie",
      " a d\xE9j\xE0 essay\xE9 de r\xE9sister \xE0 la magie ce tour",
      'sagesse', 'magique', "il r\xE9siste \xE0 la magie !", {
        predicat: 'tour'
      });
  }

  // asynchrone : on fait les jets du magicien protecteur en opposition
  //!cof-cercle-protection id [evtid] [chance]
  function cercleDeProtection(msg) {
    evitementGenerique(msg, 'activer le cercle de protection', 'cercleDeProtection',
      'activation du cercle de protection', "de bloquer le sort avec le Cercle de Protection",
      " a d\xE9j\xE0 active le Cercle de Protection ce tour",
      'intelligence', 'magique', "le sort est annul\xE9 !", {
        protecteur: true,
        annule: true
      });
  }

  // asynchrone : on fait les jets du barde en opposition
  //!cof-esquive-acrobatique id [evtid] [chance]
  function doEsquiveAcrobatique(msg) {
    evitementGenerique(msg, 'esquiver', 'esquiveAcrobatique',
      'esquive acrobatique', "une esquive acrobatique", " a d\xE9j\xE0 fait une esquive acrobatique ce tour", 'dexterite', 'distance', "l'attaque est esquiv\xE9e !", {
        critiqueDevientNormal: true,
        predicat: 'tour'
      });
  }

  function doEsquiveMagistrale(msg) {
    evitementGenerique(msg, 'esquiver', 'paradeMagistrale',
      'esquive acrobatique', "une esquive acrobatique", " a d\xE9j\xE0 fait une parade magistrale ce tour", 'dexterite', 'distance', "l'attaque est esquiv\xE9e !", {
        bonusAttaque: -5,
        critiqueDevientNormal: true,
        predicat: 'tour'
      });
  }

  function doParadeMagistrale(msg) {
    evitementGenerique(msg, 'parer', 'paradeMagistrale',
      'parade magistrale', "une parade magistrale", " a d\xE9j\xE0 fait une parade magistrale ce tour", 'dexterite', 'distance', "l'attaque est par\xE9e !", {
        arme: true,
        critiqueDevientNormal: true,
        predicat: 'tour'
      });
  }

  //!cof-parade-au-bouclier
  function doParadeAuBouclier(msg) {
    evitementGenerique(msg, 'parer', 'paradeAuBouclier',
      'parade au bouclier', "une parade au bouclier", " a d\xE9j\xE0 fait une parade au bouclier ce tour", 'force', 'contact', "l'attaque est par\xE9e !", {
        armeGauche: true,
        critiqueAnnuleCritique: true,
        predicat: 'tour'
      });
  }

  //!cof-chair-a-canon id1 id2 [evt_id]
  // id1 est l'id du pnj r\xE9current
  // id2 est l'id du token qui se met devant l'attaque
  function doChairACanon(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("pas assez d'argumennts pour !cof-chair-a-canon", cmd);
      return;
    }
    let evtARefaire;
    if (cmd.length > 3) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[3]);
    } else {
      evtARefaire = lastEvent();
    }
    if (evtARefaire === undefined) {
      error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
      return;
    }
    let pnjRec = persoOfId(cmd[1]);
    if (pnjRec === undefined) {
      error("Le premier argument de !cof-chair-a-canon n'est pas un token de personnage", cmd);
      return;
    }
    if (!peutController(msg, pnjRec)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let testChairACanon = testLimiteUtilisationsCapa(pnjRec, 'chairACanon', 'tour', "a d\xE9j\xE0 utilis\xE9 un sous-fifre ce tour", "ne sait pas utiliser ses sous-fifres pour se d\xE9fendre");
    if (testChairACanon === undefined) {
      return;
    }
    let sousFifre = persoOfId(cmd[2]);
    if (sousFifre === undefined) {
      error("Le second argument de !cof-chair-a-canon n'est pas un token de personnage", cmd);
      return;
    }
    if (evtARefaire === undefined) {
      sendChat('', "Historique d'actions vide, pas d'action trouv\xE9e pour la chair \xE0 canon");
      return;
    }
    if (evtARefaire.type != 'Attaque') {
      sendChat('', "la derni\xE8re action n'est pas une attaque");
      return;
    }
    let attaque = evtARefaire.action;
    if (attaque === undefined) {
      error("Attaque sans action", evtARefaire);
      return;
    }
    let originalTarget;
    attaque.cibles = attaque.cibles.filter(function(c) {
      if (originalTarget) return true;
      if (c.token.id != cmd[1]) return true;
      originalTarget = c;
      return false;
    });
    if (originalTarget === undefined) {
      error("Impossible de trouver " + pnjRec.token.get('name') + " parmi les cibles de l'attaque", attaque);
      return;
    }
    sousFifre.rollDmg = originalTarget.rollDmg;
    sousFifre.tokName = sousFifre.token.get('name');
    sousFifre.chairACanon = true;
    attaque.cibles.push(sousFifre);
    let optionsRedo = attaque.options;
    optionsRedo.rolls = attaque.rolls;
    let evt = {
      type: "chair \xE0 canon"
    };
    utiliseCapacite(pnjRec, testChairACanon, evt);
    undoEvent(evtARefaire);
    addEvent(evt);
    removePreDmg(attaque.options, originalTarget);
    redoEvent(evtARefaire, attaque);
  }

  // modifie res et le retourne (au cas o\xF9 il ne serait pas donn\xE9)
  function listRollResults(roll, res) {
    res = res || [];
    switch (roll.type) {
      case 'V': //top-level des rolls
        if (roll.rolls === undefined) break;
        roll.rolls.forEach(function(r) {
          listRollResults(r, res);
        });
        return res;
      case 'R': //jet simple
        if (roll.results === undefined) break;
        roll.results.forEach(function(r) {
          if (r.v) res.push(r.v);
          else if (r.d) res.push(r.d);
          else log("Type de r\xE9sultat de d\xE9 inconnu " + r);
        });
        return res;
      case 'M':
      case 'L':
        return res;
      case 'G':
        if (roll.rolls === undefined) break;
        roll.rolls.forEach(function(ra) {
          ra.forEach(function(r) {
            listRollResults(r, res);
          });
        });
        return res;
      default:
        log("tag inconnu");
    }
    error("Structure de roll inconnue", roll);
    return res;
  }

  //category est un tableau de string, le premier \xE9l\xE9ment \xE9tant la cat\xE9gorie
  //principale, le suivant la sous-cat\xE9gorie, etc
  //value peut \xEAtre un nombre, un tableau de nombres, ou un inline roll
  function addStatistics(playerId, category, value) {
    if (stateCOF.statistiques === undefined) return;
    var stat = stateCOF.statistiques;
    if (playerId) {
      var player = getObj('player', playerId);
      if (player) {
        //On utilise l'id roll20 qui semble persistante
        var pid = player.get('d20userid');
        stat[pid] = stat[pid] || {};
        stat = stat[pid];
      }
    }
    if (category) {
      category.forEach(function(cat) {
        stat[cat] = stat[cat] || {};
        stat = stat[cat];
      });
    }
    if (!Array.isArray(value)) {
      if (value.results) value = listRollResults(value.results);
      else value = [value];
    }
    value.forEach(function(v) {
      if (isNaN(v)) {
        error("statistique sur une valeur qui n'est pas un nombre", value);
        return;
      }
      if (typeof v != 'number') v = parseInt(v);
      if (stat.total) stat.total += v;
      else stat.total = v;
      if (stat.nombre) stat.nombre++;
      else stat.nombre = 1;
    });
  }

  function displayStatCategory(stats, indent, categoryName, accum) {
    var res = {
      nombre: 0,
      total: 0,
    };
    if (stats.nombre) { //on peut afficher des r\xE9sultats
      res.nombre = stats.nombre;
      res.total = stats.total;
    }
    var nindent = indent + "&nbsp;&nbsp;";
    var nAccum = [];
    for (var category in stats) {
      if (category == 'total' || category == 'nombre') break;
      var catRes = displayStatCategory(stats[category], nindent, category, nAccum);
      res.nombre += catRes.nombre;
      res.total += catRes.total;
    }
    var msg = "aucun jet cellect\xE9";
    if (res.nombre > 0) {
      var moyenne = res.total / res.nombre;
      msg = res.nombre + " jet" + ((res.nombre > 1) ? "s" : "") + ", moyenne " + moyenne;
    }
    if (nAccum.length > 0) msg = indent + categoryName + " (" + msg + ") :";
    else msg = indent + categoryName + " : " + msg;
    accum.push(msg);
    nAccum.forEach(function(m) {
      accum.push(m);
    });
    return res;
  }

  function displayStatistics(msg) {
    var stats = stateCOF.statistiques;
    var display = startFramedDisplay(getPlayerIdFromMsg(msg), "Statistiques");
    if (stats === undefined) {
      stats = stateCOF.statistiquesEnPause;
      if (stats)
        addLineToFramedDisplay(display, "Statistiques en pause");
      else {
        addLineToFramedDisplay(display, "Aucune statistique collect\xE9e");
        sendChat("COF", endFramedDisplay(display));
        return;
      }
    }
    var tot = {
      total: 0,
      nombre: 0
    };
    var players = findObjs({
      type: 'player'
    });
    var findPlayer = function(pid) {
      return players.find(function(p) {
        return (p.get('d20userid') == pid);
      });
    };
    var addMessages = function(mv) {
      mv.forEach(function(m) {
        addLineToFramedDisplay(display, m);
      });
    };
    for (var category in stats) {
      //first, check if the category is a player id
      var pl = findPlayer(category);
      var catName = category;
      if (pl) catName = pl.get('displayname');
      var accum = [];
      var catRes = displayStatCategory(stats[category], "", catName, accum);
      addMessages(accum);
      tot.total += catRes.total;
      tot.nombre += catRes.nombre;
    }
    addLineToFramedDisplay(display, tot.nombre + " jets au total, dont la somme fait " + tot.total);
    sendChat("COF", endFramedDisplay(display));
  }

  function parseDestructionDesMortsVivants(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    let args = options.cmd;
    if (args === undefined || args.length < 2) {
      error("Il faut au moins un argument \xE0 !cof-destruction-des-morts-vivants", args);
      return;
    }
    args.shift();
    let dm = args.join(' ');
    dm = dm.replace(/%/g, '&#37;');
    dm = dm.replace(/\)/g, '&#41;');
    dm = dm.replace(/\?/g, '&#63;');
    dm = dm.replace(/@/g, '&#64;');
    dm = dm.replace(/\[/g, '&#91;');
    dm = dm.replace(/\]/g, '&#93;');
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Il faut s\xE9lectionner le lanceur de la destruction des morts-vivants", playerId);
        return;
      }
      if (selected.length > 1) {
        sendPlayer(msg, "Ne s\xE9lectionner qu'un token \xE0 la fois pour lancer la destruction des mort-vivants.", playerId);
        return;
      }
      let playerName = msg.who;
      if (playerIsGM(playerId)) playerName = 'GM';
      iterSelected(selected, function(lanceur) {
        if (options.tempeteDeMana) {
          if (options.tempeteDeMana.cout === 0) {
            //On demande de pr\xE9ciser les options
            var optMana = {
              mana: options.mana,
              dm: true,
              soins: false,
              duree: false,
              rang: options.rang,
            };
            setTempeteDeMana(playerId, lanceur, msg.content, optMana);
            return;
          } else {
            if (options.rang && options.tempeteDeMana.cout > options.rang) {
              sendPlayerAndGM(msg, playerId, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
            }
          }
        }
        if (options.tempeteDeManaIntense) {
          let findNbDes = dm.match(/^([0-9]+)d/);
          if (findNbDes && findNbDes.length > 1) {
            let nbDes = parseInt(findNbDes[1]);
            dm = dm.replace(findNbDes[0], (nbDes + options.tempeteDeManaIntense) + 'd');
          } else {
            log("Pas r\xE9ussi \xE0 trouver le nombre de d\xE9s dans " + dm);
          }
        } else if (options.puissant) {
          let findValDes = dm.match(/^([0-9]+d)([0-9]+)/);
          if (findValDes && findValDes.length > 2) {
            let valDes = parseInt(findValDes[2]) + 2;
            dm = dm.replace(findValDes[0], findValDes[1] + valDes);
          } else {
            log("Pas r\xE9ussi \xE0 trouver le nombre de faces des d\xE9s dans " + dm);
          }
        }
        doDestructionDesMortsVivants(lanceur, playerName, dm, options);
      });
    });
  }

  function doDestructionDesMortsVivants(lanceur, playerName, dm, options) {
    let playerId = options.playerId;
    var evt = {
      type: "destructionMortsVivants",
      action: {
        lanceur: lanceur,
        playerName: playerName,
        playerId: playerId,
        dm: dm,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'destructionDesMortsVivants', "lancer une destruction des mort-vivants", evt)) return;
    let display = startFramedDisplay(playerId,
      "<b>Sort :<b> destruction des morts-vivants", lanceur);
    let testId = 'destructionDesMortsVivants_' + lanceur.token.id;
    let difficulte = 13;
    let malusRepetition;
    if (options.malusRepetition) {
      malusRepetition = attributeAsInt(lanceur, 'limiteParCombat_malusDestructionDesMortsVivants', 0);
      difficulte += malusRepetition;
      malusRepetition += options.malusRepetition;
    }
    testCaracteristique(lanceur, 'SAG', difficulte, testId, options, evt,
      function(testRes) {
        var msgJet = "Jet de SAG : " + testRes.texte;
        if (testRes.reussite) {
          addLineToFramedDisplay(display, msgJet + " &ge; " + difficulte + testRes.modifiers);
          if (malusRepetition)
            setTokenAttr(lanceur, 'limiteParCombat_malusDestructionDesMortsVivants', malusRepetition, evt);
          let cibles = [];
          let page = getObj("page", options.pageId);
          let murs = getWalls(page, options.pageId);
          let pt;
          if (murs) {
            pt = {
              x: lanceur.token.get('left'),
              y: lanceur.token.get('top')
            };
          }
          let tokensEnVue = findObjs({
            _type: 'graphic',
            _pageid: options.pageId,
            _subtype: 'token',
            layer: 'objects'
          });
          tokensEnVue.forEach(function(obj) {
            if (obj.id == lanceur.token.id) return;
            var objCharId = obj.get('represents');
            if (objCharId === '') return;
            if (obj.get('bar1_max') == 0) return; // jshint ignore:line
            var objChar = getObj('character', objCharId);
            if (objChar === undefined) return;
            if (murs) {
              if (obstaclePresent(obj.get('left'), obj.get('top'), pt, murs)) return;
            }
            var cible = {
              charId: objCharId,
              token: obj
            };
            if (!estMortVivant(cible)) return;
            if (getState(cible, 'mort')) return;
            cibles.push(cible);
          });
          let nbCibles = cibles.length;
          if (nbCibles === 0) {
            addLineToFramedDisplay(display, "Aucun mort-vivant en vue");
            sendChat("", endFramedDisplay(display));
            return;
          }
          let expl = [];
          entrerEnCombat(lanceur, cibles, expl, evt);
          expl.forEach(function(e) {
            addLineToFramedDisplay(display, e, 80, false);
          });
          let optionsDM = {
            sortilege: true,
            lanceur: lanceur,
            aoe: true,
            evt: evt
          };
          dm = dm.trim();
          evt.action.cibles = cibles;
          let finalDisplay = function() {
            nbCibles--;
            if (nbCibles < 1) {
              sendChat('', endFramedDisplay(display));
            }
          };
          cibles.forEach(function(perso) {
            let name = perso.token.get('name');
            let explications = [];
            perso.attaquant = lanceur;
            try {
              sendChat('', '[[' + dm + ']]', function(resDmg) {
                let dmg = {
                  type: 'magique',
                  value: dm,
                  roll: resDmg[0]
                };
                let afterEvaluateDmg = dmg.roll.content.split(' ');
                let dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
                dmg.total = dmg.roll.inlinerolls[dmgRollNumber].results.total;
                dmg.display = buildinline(dmg.roll.inlinerolls[dmgRollNumber], dmg.type, optionsDM.magique);
                dealDamage(perso, dmg, [], evt, false, optionsDM, explications, function(dmgDisplay, dmgFinal) {
                  addLineToFramedDisplay(display,
                    name + " re\xE7oit " + dmgDisplay + " DM");
                  explications.forEach(function(e) {
                    addLineToFramedDisplay(display, e, 80, false);
                  });
                  finalDisplay();
                });
              }); //fin du jet de d\xE9s
            } catch (rollError) {
              error("Jet " + dm + " mal form\xE9", dm);
            }
          }); //fin forEach

        } else {
          addLineToFramedDisplay(display, msgJet + " < " + difficulte);
          var msgRate = lanceur.token.get('name') + " ne r\xE9ussit pas \xE0 invoquer son dieu." + testRes.rerolls + testRes.modifiers;
          addLineToFramedDisplay(display, msgRate);
          sendChat('', endFramedDisplay(display));
        }
      });
  }

  //!cof-enduire-poison label type dm save
  //si label = munition_nom, alors on enduit des munitions et non une arme.
  function parseEnduireDePoison(msg) {
    const options = parseOptions(msg);
    let optArgs = msg.content.split(' --');
    let cmd = options.cmd;
    optArgs.shift();
    if (cmd.length < 5) {
      error("Usage : !cof-enduire-poison L type force save", cmd);
      return;
    }
    let labelArme = cmd[1];
    let typePoison = cmd[2];
    if (typePoison != 'rapide') {
      error("Le seul type de poison g\xE9r\xE9 est rapide, pas " + typePoison, cmd);
    }
    let attribut = 'poisonRapide_' + labelArme;
    let nomMunition;
    let estMunition = labelArme.startsWith('munition_');
    if (estMunition) nomMunition = labelArme.substring(9);
    let forcePoison = cmd[3];
    let savePoison = parseInt(cmd[4]);
    if (isNaN(savePoison)) {
      error("Le dernier argument non optionnel doit \xEAtre la difficult\xE9 du test de CON", cmd);
      return;
    }
    let testINT = 14;
    optArgs.forEach(function(arg) {
      cmd = arg.split(' ');
      switch (cmd[0]) {
        case 'testINT':
          if (cmd.length < 2) {
            error("Il faut un argument \xE0 --testINT", cmd);
            return;
          }
          testINT = parseInt(cmd[1]);
          if (isNaN(testINT)) {
            error("Argument de --testINT invalide", cmd);
            testINT = 14;
          }
          return;
      }
    }); //fin du traitement des options
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        let armeEnduite;
        let attr = tokenAttribute(perso, attribut);
        let infosAdditionelles = savePoison;
        let arme;
        if (!estMunition) {
          arme = getWeaponStats(perso, labelArme);
          if (arme === undefined) {
            error("Pas d'arme de label " + labelArme, cmd);
            return;
          }
          if (arme.sortilege) {
            sendPerso(perso, "imossible d'enduire un sortil\xE8ge de poison", true);
            return;
          }
          if (arme.typeDegats == 'contondant') {
            sendPerso(perso, arme.name + " fait des d\xE9g\xE2ts contondants. Est-il vraiment possible de l'empoisonner ?", true);
          }
          if (arme.armeDeJet) estMunition = true;
        }
        if (estMunition) {
          let munitionsCourantes;
          let maxMunitions;
          let attrQte;
          if (arme) {
            armeEnduite = arme.name;
            attrQte = findObjs({
              _type: 'attribute',
              _characterid: perso.charId,
              name: arme.prefixe + 'armejetqte'
            }, {
              caseInsensitive: true
            });
            if (attrQte.length === 0) {
              munitionsCourantes = 1;
              maxMunitions = 1;
            } else {
              attrQte = attrQte[0];
            }
          } else {
            armeEnduite = nomMunition.replace(/_/g, ' ');
            attrQte = tokenAttribute(perso, labelArme);
            if (attrQte.length === 0) {
              sendPerso(perso, "n'a pas de munition nomm\xE9e " + nomMunition);
              return;
            }
            attrQte = attrQte[0];
          }
          if (munitionsCourantes === undefined) {
            munitionsCourantes = parseInt(attrQte.get('current'));
            maxMunitions = parseInt(attrQte.get('max'));
            if (isNaN(munitionsCourantes) || isNaN(maxMunitions)) {
              error("Attribut de munitions mal form\xE9", attrQte);
              return;
            }
          }
          if (munitionsCourantes === 0) {
            sendPlayer(msg, "Plus de munition " + nomMunition, playerId);
            return;
          }
          let dejaEnduits = 0;
          if (attr.length > 0) {
            let infos = attr[0].get('max');
            let indexInfos = infos.indexOf(' ');
            if (indexInfos < 1) {
              error("Attribut de poison rapide de munition mal form\xE9 (il faudrait la difficult\xE9 du save + le nombre de munitions empoisonn\xE9es)", infos);
              return;
            }
            let oldSave = parseInt(infos.substring(0, indexInfos));
            dejaEnduits = parseInt(infos.substring(indexInfos + 1));
            if (isNaN(dejaEnduits)) dejaEnduits = 0;
            if (dejaEnduits > 0 && (attr[0].get('current') != forcePoison || oldSave != savePoison)) {
              sendPlayer(msg, "Il y a d\xE9j\xE0 du poison de force " + attr[0].get('current') + "et de save " + oldSave + " sur les munitions " + armeEnduite + ". Le script ne sait pas g\xE9rer diff\xE9rents poisons sur les m\xEAmes munitions.", playerId);
              return;
            }
          }
          infosAdditionelles = savePoison + ' ' + (dejaEnduits + 1);
          if (dejaEnduits >= maxMunitions) {
            sendPlayer(msg, "Toutes les munitions " + armeEnduite + " sont d\xE9j\xE0 enduites de poison", playerId);
            return;
          }
        } else {
          armeEnduite = getAttackName(labelArme, perso);
          if (armeEnduite === undefined) {
            error(perso.tokNname + " n'a pas d'arme associ\xE9e au label " + labelArme, cmd);
            return;
          }
          if (attributeAsBool(perso, attribut)) {
            sendPlayer(msg, armeEnduite + " est d\xE9j\xE0 enduit de poison.", playerId);
            return;
          }
        }
        doEnduireDePoison(perso, armeEnduite, savePoison, forcePoison, attribut, testINT, infosAdditionelles, options);
      });
    });
  }

  function doEnduireDePoison(perso, armeEnduite, savePoison, forcePoison, attribut, testINT, infosAdditionelles, options) {
    var evt = {
      type: 'enduireDePoison',
      action: {
        perso: perso,
        armeEnduite: armeEnduite,
        savePoison: savePoison,
        forcePoison: forcePoison,
        attribut: attribut,
        testINT: testINT,
        infosAdditionelles: infosAdditionelles,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(perso, options, 'enduirePoison', 'enduire de poison', evt)) return;
    perso.tokName = perso.token.get('name');
    var display = startFramedDisplay(options.playerId, "Essaie d'enduire " + armeEnduite + " de poison", perso);
    //Test d'INT pour savoir si l'action r\xE9ussit.
    var testId = 'enduireDePoison';
    testCaracteristique(perso, 'INT', testINT, testId, options, evt,
      function(tr) {
        var jet = "Jet d'INT : " + tr.texte;
        if (tr.echecCritique) { //\xE9chec critique
          jet += " \xC9chec critique !" + tr.rerolls + tr.modifiers;
          addLineToFramedDisplay(display, jet);
          addLineToFramedDisplay(display, perso.tokName + " s'empoisonne.");
          sendChat('', "[[" + forcePoison + "]]", function(res) {
            var dmgRoll;
            if (options.rolls && options.rolls.enduireSelfDmg) {
              dmgRoll = options.rolls.enduireSelfDmg;
            } else {
              dmgRoll = res[0].inlinerolls[0];
            }
            evt.action.rolls.enduireSelfDmg = dmgRoll;
            let r = {
              total: dmgRoll.results.total,
              type: 'poison',
              display: buildinline(dmgRoll, 'poison')
            };
            options.partialSave = {
              carac: 'CON',
              seuil: savePoison
            };
            let explications = [];
            dealDamage(perso, r, [], evt, false, options, explications,
              function(dmgDisplay, dmg) {
                explications.forEach(function(e) {
                  addLineToFramedDisplay(display, e);
                });
                addLineToFramedDisplay(display, perso.tokName + " subit " + dmgDisplay + " DM");
                sendChat('', endFramedDisplay(display));
              }); //fin de dmg dus \xE0 l'\xE9chec critique
          }); //fin du jet de dmg
        } else if (tr.reussite) {
          jet += " &ge; " + testINT + tr.modifiers;
          addLineToFramedDisplay(display, jet);
          setTokenAttr(perso, attribut, forcePoison, evt, {
            maxVal: infosAdditionelles
          });
          addLineToFramedDisplay(display, armeEnduite + " est maintenant enduit de poison");
          sendChat("", endFramedDisplay(display));
        } else { //echec normal au jet d'INT
          jet += " < " + testINT + " : \xE9chec" + tr.rerolls + tr.modifiers;
          addLineToFramedDisplay(display, jet);
          sendChat("", endFramedDisplay(display));
        }
      }); //fin du test de carac
  }

  var consommableNomRegExp = new RegExp(/^(repeating_equipement_.*_)equip_nom/);
  var consommableQuantiteRegExp = new RegExp(/^(repeating_equipement_.*_)equip_qte/);
  var consommableEffetRegExp = new RegExp(/^(repeating_equipement_.*_)equip_effet/);

  function listeConsommables(msg) {
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        if (perso.token.get('bar1_link') === '') {
          error("La liste de consommables n'est pas au point pour les tokens non li\xE9s", perso);
          return;
        }
        var display = startFramedDisplay(playerId, 'Liste de vos consommables :', perso, {
          chuchote: true
        });
        var attributes = findObjs({
          _type: 'attribute',
          _characterid: perso.charId
        });
        var consommables = {}; //map id -> nom, quantite, effet, attr
        attributes.forEach(function(attr) {
          var attrName = attr.get('name').trim();
          var m = consommableNomRegExp.exec(attrName);
          var consoPrefix;
          if (m) {
            consoPrefix = m[1];
            consommables[consoPrefix] = consommables[consoPrefix] || {};
            consommables[consoPrefix].nom = attr.get('current');
            return;
          }
          m = consommableQuantiteRegExp.exec(attrName);
          if (m) {
            consoPrefix = m[1];
            consommables[consoPrefix] = consommables[consoPrefix] || {};
            consommables[consoPrefix].quantite = parseInt(attr.get('current'));
            consommables[consoPrefix].attr = attr;
            return;
          }
          m = consommableEffetRegExp.exec(attrName);
          if (m) {
            consoPrefix = m[1];
            consommables[consoPrefix] = consommables[consoPrefix] || {};
            consommables[consoPrefix].effet = attr.get('current');
            return;
          }
          //Consommables dans des attributs utilisateurs
          if (!(attrName.startsWith('dose_') || attrName.startsWith('consommable_') || attrName.startsWith('elixir_'))) return;
          var consName;
          if (attrName.startsWith("elixir_")) {
            var typeElixir = listeElixirs(5).find(function(i) {
              return "elixir_" + i.attrName == attrName;
            });
            if (typeElixir !== undefined) {
              consName = typeElixir.nom;
            }
          }
          if (consName === undefined) {
            consName = attrName.substring(attrName.indexOf('_') + 1);
            consName = consName.replace(/_/g, ' ');
          }
          var quantite = parseInt(attr.get('current'));
          if (isNaN(quantite) || quantite === 0) return;
          var action = attr.get('max').trim();
          while (consommables[attrName]) {
            attrName += randomInteger(1000);
          }
          consommables[attrName] = {
            nom: consName,
            quantite: quantite,
            effet: action,
            attr: attr,
          };
        }); //fin de la boucle sur les attributs
        var aConsommable;
        _.each(consommables, function(c, prefix) {
          if (c.effet === undefined || c.effet === '' || c.nom === undefined || c.nom === '') return;
          //La quantit\xE9 est de 1 par d\xE9faut sur la fiche
          if (c.quantite === undefined) {
            c.quantite = 1;
            c.attr = createObj('attribute', {
              _characterid: perso.charId,
              name: prefix + 'equip_qte',
              current: 1
            });
          } else if (isNaN(c.quantite) || c.quantite < 1) {
            return;
          }
          aConsommable = true;
          var ligne = c.quantite + ' ';
          ligne += bouton(c.effet, c.nom, perso, {
            ressource: c.attr
          });
          // Pictos : https://wiki.roll20.net/CSS_Wizardry#Pictos
          var overlay = ' title="Cliquez pour \xE9changer"';
          ligne += boutonSimple('!cof-echange-consommable ' + perso.token.id + ' @{target|token_id} ' + c.attr.id, '<span style="font-family:Pictos">r</span>', overlay);
          addLineToFramedDisplay(display, ligne);
        }); //fin de la boucle sur les onsommables
        if (aConsommable)
          addLineToFramedDisplay(display, '<em>Cliquez sur le consommable pour l\'utiliser ou sur <tt><span style="font-family:Pictos">r</span></tt> pour l\'\xE9changer avec un autre personnage.</em>');
        else
          addLineToFramedDisplay(display, "<code>Vous n'avez aucun consommable</code>");
        sendChat('', endFramedDisplay(display));
      });
    }); //fin du getSelected
  }

  // !cof-utilise-consommable tok_id attr_id [msg]
  // utilisation d'un consommable sans action en jeu
  function utiliseConsommable(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Erreur interne d'utilisation de consommables", cmd);
      return;
    }
    cmd.shift();
    var perso = persoOfId(cmd[0]);
    if (perso === undefined) {
      log("Propri\xE9taire perdu");
      sendChat('COF', "Plus possible d'utiliser cette action. R\xE9afficher les consommables.");
      return;
    }
    perso.tokName = perso.token.get('name');
    // V\xE9rifie les droits d'utiliser le consommable
    if (msg.selected && msg.selected.length == 1) {
      var utilisateur = persoOfId(msg.selected[0]._id);
      if (utilisateur === undefined) {
        sendChat('COF', "Le token s\xE9lectionn\xE9 n'est pas valide");
        return;
      }
      var d = distanceCombat(perso.token, utilisateur.token);
      if (d > 0) {
        sendPerso(utilisateur, "est trop loin de " + perso.tokName + " pour utiliser ses objets");
        return;
      }
      perso = utilisateur;
    } else {
      //On regarde si le joueur contr\xF4le le token
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "Pas les droits pour \xE7a");
        return;
      }
    }
    //on r\xE9cup\xE8re l'attribut \xE0 utiliser
    cmd.shift();
    var attr = getObj('attribute', cmd[0]);
    if (attr === undefined) {
      log("Attribut a chang\xE9/perdu");
      log(msg.content);
      sendChat('COF', "Plus possible d'utiliser cette action. Veuillez r\xE9afficher les consommables.");
      return;
    }
    //Nom du consommable (pour affichage)
    var consName;
    var quantite = parseInt(attr.get('current'));
    var evt = {
      type: "Utilisation de consommable",
      attributes: [{
        attribute: attr,
        current: quantite,
      }]
    };
    var attrName = attr.get('name').trim();
    //On regarde si c'est un consommable sur la fiche
    var m = consommableQuantiteRegExp.exec(attrName);
    if (m) {
      var consoPrefix = m[1];
      var attrConsName = charAttribute(perso.charId, consoPrefix + 'equip_nom');
      if (attrConsName.length === 0) {
        error("Impossible de trouver le nom du consommable", attr);
        return;
      }
      consName = attrConsName[0].get('current').trim();
    } else {
      consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ').trim();
    }
    if (isNaN(quantite) || quantite < 1) {
      attr.set('current', 0);
      whisperChar(perso.charId + "Vous ne disposez plus de " + consName);
      return;
    }
    if (cmd.length > 1) {
      cmd.shift();
      sendPerso(perso, cmd.join(' '));
    }
    attr.set('current', quantite - 1);
    addEvent(evt);
  }

  //!cof-echange-consommable tid1 tid2 attrid
  function echangeConsommable(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 4) {
      error("Erreur interne de consommables", cmd);
      return;
    }
    if (cmd[1] == cmd[2]) {
      sendChat('COF', "\xC9change avec soi-m\xEAme, sans effet");
      return;
    }
    //perso1 = token avec qui va \xE9changer le consommable
    var perso1 = persoOfId(cmd[1]);
    if (perso1 === undefined) {
      log("Propri\xE9taire perdu");
      sendChat('COF', "Plus possible d'utiliser cette action. R\xE9afficher les consommables.");
      return;
    }
    perso1.tokName = perso1.token.get('name');
    //perso2 = token avec lequel on va faire l'\xE9change
    var perso2 = persoOfId(cmd[2]);
    if (perso2 === undefined) {
      log("Destinataire perdu");
      sendChat('COF', "Erreur concernant le destinataire. Veuillez r\xE9essayer.");
      return;
    }
    perso2.tokName = perso2.token.get('name');
    //On regarde si le joueur contr\xF4le le token
    if (!peutController(msg, perso1)) {
      sendPlayer(msg, "Pas les droits pour \xE7a");
      return;
    }
    //on r\xE9cup\xE8re l'attribut \xE0 \xE9changer de perso1
    var attr1 = getObj('attribute', cmd[3]);
    if (attr1 === undefined) {
      log("Attribut a chang\xE9/perdu");
      log(cmd);
      sendChat('COF', "Plus possible d'utiliser cette action. Veuillez r\xE9afficher les consommables.");
      return;
    }
    var consName;
    var quantite1 = parseInt(attr1.get('current'));
    var evt = {
      type: "\xC9change de consommable",
      attributes: [{
        attribute: attr1,
        current: quantite1,
      }]
    };
    var effet;
    var attrName = attr1.get('name').trim();
    //On regarde si c'est un consommable sur la fiche
    var m1 = consommableQuantiteRegExp.exec(attrName);
    if (m1) {
      var consoPrefix = m1[1];
      var attrConsName = charAttribute(perso1.charId, consoPrefix + 'equip_nom');
      var attrEffet = charAttribute(perso1.charId, consoPrefix + 'equip_effet');
      if (attrConsName.length === 0 || attrEffet.length === 0) {
        error("Impossible de trouver le nom ou l'effet du consommable", attr1);
        return;
      }
      consName = attrConsName[0].get('current').trim();
      effet = attrEffet[0].get('current').trim();
    } else {
      consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ').trim();
      effet = attr1.get('max').trim();
    }
    if (isNaN(quantite1) || quantite1 < 1) {
      attr1.set('current', 0);
      whisperChar(perso1.charId, "Vous ne disposez plus de " + consName);
      return;
    }
    // on baisse la valeur de 1 du consommable qu'on s'appr\xEAte \xE0 \xE9changer
    quantite1--;
    attr1.set('current', quantite1);
    // ajout du consommable dans perso2 :
    var attributes = findObjs({
      _type: 'attribute',
      _characterid: perso2.charId
    });
    var quantite2 = 0;
    // on recherche si le consommable existe chez perso2
    var found = attributes.find(function(attr2) {
      var attrName2 = attr2.get('name');
      var m2 = consommableNomRegExp.exec(attrName2);
      if (m2) {
        if (consName != attr2.get('current').trim()) return false;
        var consoPrefix2 = m2[1];
        var attrEffet2 = charAttribute(perso2.charId, consoPrefix2 + 'equip_effet');
        if (attrEffet2.length === 0) {
          attrEffet2 = createObj('attribute', {
            characterid: perso2.charId,
            name: consoPrefix2 + 'equip_effet',
            current: effet
          });
          evt.attributes.push({
            attribute: attrEffet2,
          });
        } else if (attrEffet2[0].get('current').trim() != effet) {
          error("\xC9change dangereux : pas le m\xEAme effet pour le consommable selon le personnage \n" +
            "Effet chez " + perso1.tokName + " : " + effet + "\n" +
            "Effet chez " + perso2.tokName + " : " + attrEffet2[0].get('current'), attr2.get('name'));
          return false;
        }
        var attrQte2 = charAttribute(perso2.charId, consoPrefix2 + 'equip_qte');
        if (attrQte2.length === 0) {
          quantite2 = 1;
          attrQte2 = createObj('attribute', {
            characterid: perso2.charId,
            name: consoPrefix2 + 'equip_qte',
            current: 2
          });
          evt.attributes.push({
            attribute: attrQte2,
          });
          return true;
        }
        attrQte2 = attrQte2[0];
        quantite2 = parseInt(attrQte2.get('current'));
        if (isNaN(quantite2) || quantite2 < 1) quantite2 = 0;
        attrQte2.set('current', quantite2 + 1);
        evt.attributes.push({
          attribute: attrQte2,
          current: quantite2
        });
        return true;
      } else if (!m1 && attrName == attrName2.trim()) {
        if (attr2.get('max').trim() != effet) {
          error("\xC9change dangereux : pas le m\xEAme effet pour le consommable selon le personnage \n" +
            "Effet chez " + perso1.tokName + " : " + effet + "\n" +
            "Effet chez " + perso2.tokName + " : " + attr2.get('max'), attr2);
          return false;
        }
        quantite2 = parseInt(attr2.get('current'));
        if (isNaN(quantite2) || quantite2 < 1) quantite2 = 0;
        attr2.set('current', quantite2 + 1);
        evt.attributes.push({
          attribute: attr2,
          current: quantite2,
          max: effet
        });
        return true;
      }
      return false;
    });
    // si le consommable n'a pas \xE9t\xE9 trouv\xE9, on le cr\xE9e avec une valeur de 1.
    if (!found) {
      if (m1) {
        var pref = 'repeating_equipement_' + generateRowID() + '_';
        var attre = createObj("attribute", {
          name: pref + 'equip_nom',
          current: consName,
          characterid: perso2.charId
        });
        evt.attributes.push({
          attribute: attre,
        });
        attre = createObj("attribute", {
          name: pref + 'equip_effet',
          current: effet,
          characterid: perso2.charId
        });
        evt.attributes.push({
          attribute: attre,
        });
      } else {
        var attr2 = createObj("attribute", {
          name: attrName,
          current: 1,
          max: effet,
          characterid: perso2.charId
        });
        evt.attributes.push({
          attribute: attr2,
        });
      }
    }
    quantite2++;
    // on envoie un petit message pr\xE9cisant la r\xE9sultante de l'action.
    sendChat('COF', "Echange entre " + perso1.tokName + " et " + perso2.tokName + " termin\xE9e.");
    whisperChar(perso1.charId, " Il vous reste " + quantite1 + " " + consName + ".");
    whisperChar(perso2.charId, " Vous poss\xE9dez d\xE9sormais " + quantite2 + " " + consName + ".");
    // le MJ est notifi\xE9 :
    sendChat('COF', "/w GM " + perso1.tokName + " vient de donner <strong>1</strong> " + consName + " \xE0 " + perso2.tokName + ".");
    addEvent(evt);
  }

  function parseProvocation(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("La commande !cof-provocation requiert 2 arguments", cmd);
      return;
    }
    var voleur = persoOfId(cmd[1]);
    if (voleur === undefined) {
      error("Le premier argument de !cof-provocation n'est pas un token valide");
      return;
    }
    var cible = persoOfId(cmd[2]);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-provocation n'est pas un token valide");
      return;
    }
    if (cmd.length > 3 && cmd[3] == 'raillerie') {
      if (predicateAsBool(cible, 'raillerieImpossible')) {
        sendPerso(cible, "ne semble pas comprendre les railleries de " + voleur.token.get('name'));
        return;
      }
      options.raillerie = true;
      options.bonusAttrs = options.bonusAttrs || [];
      options.bonusAttrs.push('resistanceRaillerie');
    }
    doProvocation(voleur, cible, options);
  }

  function doProvocation(voleur, cible, options) {
    var evt = {
      type: 'provocation',
      action: {
        titre: "Provocation",
        voleur: voleur,
        cible: cible,
        options: options,
      }
    };
    addEvent(evt);
    var nomVoleur = voleur.token.get('name');
    var nomCible = cible.token.get('name');
    var titre = 'Provocation';
    var action = 'provocation';
    if (options.raillerie) {
      titre = 'Raillerie';
      action = 'raillerie';
    }
    var display =
      startFramedDisplay(options.playerId, titre, voleur, {
        perso2: cible
      });
    var explications = [];
    var rollId = 'provocation_' + cible.token.id;
    testOppose(rollId, voleur, 'CHA', options, cible, 'INT',
      options, explications, evt,
      function(res, crit, rt1, rt2) {
        explications.forEach(function(l) {
          addLineToFramedDisplay(display, l);
        });
        var reussite;
        switch (res) {
          case 0: //en cas d'\xE9galit\xE9, on consid\xE8re que la provocation est r\xE9ussie
            diminueMalediction(cible, evt);
            switch (crit) {
              case -1:
                reussite = "Sur un malentendu, la " + action + " r\xE9ussit...";
                if (options.raillerie) setAttrDuree(cible, 'enerve', 1, evt);
                break;
              case 0:
              case 1:
                reussite = "La " + action + " r\xE9ussit tout juste.";
                if (options.raillerie) {
                  setAttrDuree(cible, 'enerve', 1, evt);
                  setTokenAttr(cible, 'resistanceRaillerie',
                    attributeAsInt(cible, 'resistanceRaillerie', 0) + 2, evt);
                }
            }
            break;
          case 1:
            switch (crit) {
              case -1:
                reussite = nomCible + " marche compl\xE8tement, il attaque " + nomVoleur;
                if (options.raillerie) {
                  setAttrDuree(cible, 'enerve', 1, evt);
                  removeTokenAttr(cible, 'resistanceRaillerie', evt);
                }
                break;
              case 0:
                if (options.raillerie) {
                  setAttrDuree(cible, 'enerve', 1, evt);
                  reussite = nomVoleur + " a r\xE9ussi \xE0 bien \xE9nerver " + nomCible;
                  setTokenAttr(cible, 'resistanceRaillerie',
                    attributeAsInt(cible, 'resistanceRaillerie', 0) + 1, evt);
                } else reussite = "La provocation r\xE9ussit.";
                break;
              case 1:
                reussite = "La provocation est une r\xE9ussite critique !";
                setAttrDuree(cible, 'enerve', 1, evt);
                setTokenAttr(cible, 'resistanceRaillerie',
                  attributeAsInt(cible, 'resistanceRaillerie', 0) - 1, evt);
            }
            break;
          case 2:
            switch (crit) {
              case -1:
                reussite = "\xC9chec critique de la " + action + " !";
                if (options.raillerie) {
                  setTokenAttr(cible, 'resistanceRaillerie',
                    attributeAsInt(cible, 'resistanceRaillerie', 0) + 5, evt);
                }
                break;
              case 0:
                if (options.raillerie) {
                  setTokenAttr(cible, 'resistanceRaillerie',
                    attributeAsInt(cible, 'resistanceRaillerie', 0) + 1, evt);
                }
                reussite = "La provocation \xE9choue";
                break;
              case 1:
                if (options.raillerie) {
                  setTokenAttr(cible, 'resistanceRaillerie',
                    attributeAsInt(cible, 'resistanceRaillerie', 0) + 10, evt);
                }
                reussite = nomCible + " voit clair dans le jeu de " + nomCible + ". La provocation \xE9choue.";
            }
        }
        addLineToFramedDisplay(display, reussite);
        sendChat('', endFramedDisplay(display));
      }); //Fin du test oppos\xE9
  }

  function enSelle(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Il faut 2 arguments pour !cof-en-selle", msg.content);
      return;
    }
    cmd.shift();
    const cavalier = persoOfId(cmd[0]);
    if (cavalier === undefined) {
      error("Premier argument de !cof-en-selle incorrect", cmd);
      return;
    }
    const tokenC = cavalier.token;
    const pageId = tokenC.get('pageid');
    let evt = {
      type: 'En selle'
    };
    addEvent(evt);
    let attrMonteSur = tokenAttribute(cavalier, 'monteSur');
    if (attrMonteSur.length > 0) {
      //Alors le cavalier va descendre de sa monture
      attrMonteSur = attrMonteSur[0];
      let monture = persoOfId(attrMonteSur.get('current'), attrMonteSur.get('max'), pageId);
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attrMonteSur);
      attrMonteSur.remove();
      if (monture === undefined) {
        sendPerso(cavalier, "descend de sa monture");
      } else {
        sendPerso(cavalier, "descend de " + monture.token.get('name'));
        removeTokenAttr(monture, 'estMontePar', evt);
        removeTokenAttr(monture, 'positionSurMonture', evt);
      }
      return;
    }
    cmd.shift();
    let nomMonture = cmd.join(' ');
    let monture = persoOfId(nomMonture, nomMonture, pageId);
    if (monture === undefined || !predicateAsBool(monture, 'monture')) {
      sendPerso(cavalier, "ne peut pas monter l\xE0-dessus");
      log(nomMonture);
      return;
    }
    const tokenM = monture.token;
    nomMonture = tokenM.get('name');
    if (attributeAsBool(monture, 'estMontePar')) {
      sendPerso(cavalier, "ne peut monter sur " + nomMonture + " car " + onGenre(monture, 'il', 'elle') + " a d\xE9j\xE0 un cavalier");
      return;
    }
    if (distanceCombat(tokenC, tokenM, pageId) > 0) {
      sendPerso(cavalier, "est trop loin de " + nomMonture);
      return;
    }
    setTokenAttr(cavalier, 'monteSur', tokenM.id, evt, {
      msg: " monte sur " + nomMonture,
      maxVal: nomMonture
    });
    setTokenAttr(monture, 'estMontePar', tokenC.id, evt, {
      maxVal: tokenC.get('name')
    });
    setTokenAttr(monture, 'positionSurMonture', tokenC.get('left') - tokenM.get('left'), evt, {
      maxVal: tokenC.get('top') - tokenM.get('top')
    });
    setTokenAttr(monture, 'directionSurMonture', tokenC.get('rotation') - tokenM.get('rotation'), evt);
    if (stateCOF.combat) {
      updateInit(monture.token, evt);
      if (stateCOF.options.affichage.val.init_dynamique.val) {
        setTokenInitAura(monture);
      }
    }
  }

  function listeElixirs(rang) {
    var liste = [{
      nom: '\xC9lixir fortifiant',
      attrName: 'fortifiant',
      action: "!cof-fortifiant $rang",
      rang: 1
    }];
    if (rang < 2) return liste;
    liste.push({
      nom: '\xC9lixir de feu gr\xE9geois',
      attrName: 'feu_gr\xE9geois',
      action: "!cof-attack @{selected|token_id} @{target|token_id} Feu Gr\xE9geois --auto --dm $rangd6 --feu --psave DEX [[10+@{selected|INT}]] --disque 3 --portee 10 --targetFx burst-fire",
      rang: 2
    });
    if (rang < 3) return liste;
    liste.push({
      nom: '\xC9lixir de gu\xE9rison',
      attrName: '\xE9lixir_de_gu\xE9rison',
      action: "!cof-soin 3d6+$INT",
      rang: 3
    });
    if (rang < 4) return liste;
    liste.push({
      nom: "\xC9lixir d'agrandissement",
      attrName: "potion_d_agrandissement",
      action: "!cof-effet-temp agrandissement [[5+$INT]]",
      rang: 4
    });
    liste.push({
      nom: "\xC9lixir de forme gazeuse",
      attrName: "potion_de_forme_gazeuse",
      action: "!cof-effet-temp formeGazeuse [[1d4+$INT]]",
      rang: 4
    });
    liste.push({
      nom: "\xC9lixir de protection contre les \xE9l\xE9ments",
      attrName: "potion_de_protection_contre_les_\xE9l\xE9ments",
      action: "!cof-effet-temp protectionContreLesElements [[5+$INT]] --valeur $rang",
      rang: 4
    });
    liste.push({
      nom: "\xC9lixir d'armure de mage",
      attrName: "potion_d_armure_de_mage",
      action: "!cof-effet-combat armureDuMage",
      rang: 4
    });
    liste.push({
      nom: "\xC9lixir de chute ralentie",
      attrName: "potion_de_chute_ralentie",
      action: "est l\xE9ger comme une plume.",
      rang: 4
    });
    if (rang < 5) return liste;
    liste.push({
      nom: "\xC9lixir d'invisibilit\xE9",
      attrName: "potion_d_invisibilit\xE9",
      action: "!cof-set-state invisible true --message se rend invisible ([[1d6+$INT]] minutes)",
      rang: 5
    });
    liste.push({
      nom: "\xC9lixir de vol",
      attrName: "potion_de_vol",
      action: "se met \xE0 voler",
      rang: 5
    });
    liste.push({
      nom: "\xC9lixir de respiration aquatique",
      attrName: "potion_de_respiration_aquatique",
      action: "peut respirer sous l'eau",
      rang: 5
    });
    liste.push({
      nom: "\xC9lixir de flou",
      attrName: "potion_de_flou",
      action: "!cof-effet-temp flou [[1d4+$INT]]",
      rang: 5
    });
    liste.push({
      nom: "\xC9lixir de h\xE2te",
      attrName: "potion_de_h\xE2te",
      action: "!cof-effet-temp hate [[1d6+$INT]]",
      rang: 5
    });
    return liste;
  }

  //!cof-creer-elixir token_id elixir
  function creerElixir(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-creer-elixir", msg.content);
      return;
    }
    let forgesort = persoOfId(cmd[1], cmd[1], options.pageId);
    if (forgesort === undefined) {
      if (msg.selected && msg.selected.length == 1) {
        forgesort = persoOfId(msg.selected[0]._id);
      }
      if (forgesort === undefined) {
        error("Impossible de savoir qui cr\xE9e l'\xE9lixir", cmd);
        return;
      }
    }
    var voieDesElixirs = predicateAsInt(forgesort, 'voieDesElixirs', 0);
    if (voieDesElixirs < 1) {
      sendPerso(forgesort, "ne conna\xEEt pas la Voie des \xC9lixirs");
      return;
    }
    var elixir = listeElixirs(voieDesElixirs).find(function(i) {
      return i.attrName == cmd[2];
    });
    if (elixir === undefined) {
      var altElixirs = findObjs({
        _type: 'attribute',
        _characterid: forgesort.charId
      });
      altElixirs.find(function(attr) {
        var attrName = attr.get('name');
        if (!attrName.startsWith('Elixir ')) return false;
        var rang = parseInt(attrName.substring(7));
        if (isNaN(rang) || rang > 3) return false;
        var nomElixir = attr.get('current');
        if (nomElixir != cmd[2]) return false;
        elixir = {
          nom: nomElixir,
          attrName: nomElixir,
          action: attr.get('max'),
          rang: rang
        };
        return true;
      });
      if (elixir === undefined) {
        error(forgesort.token.get('name') + " est incapable de cr\xE9er " + cmd[2], cmd);
        return;
      }
    }
    var evt = {
      type: "Cr\xE9ation d'\xE9lixir"
    };
    addEvent(evt);
    if (reglesOptionelles.mana.val.elixirs_sorts.val && ficheAttributeAsBool(forgesort, 'option_pm', true)) {
      if (reglesOptionelles.mana.val.mana_totale.val) {
        switch (elixir.rang) {
          case 1:
            options.mana = 1;
            break;
          case 2:
            options.mana = 3;
            break;
          case 3:
            options.mana = 6;
            break;
          case 4:
            options.mana = 10;
            break;
          case 5:
            options.mana = 15;
            break;
        }
      } else if (elixir.rang > 2) {
        options.mana = elixir.rang - 2;
      }
    }
    // Robustesse DecrAttr multi-cmd
    var elixirsACreer = charAttribute(forgesort.charId, "elixirsACreer");
    if (elixirsACreer.length === 0) {
      error(forgesort.token.get('name') + " ne peut cr\xE9er d'\xE9lixirs " + cmd[2], cmd);
      return;
    }
    options.decrAttribute = elixirsACreer[0].id;
    if (limiteRessources(forgesort, options, 'elixirsACreer', '\xE9lixirs \xE0 cr\xE9er', evt)) return;
    let attrName = 'elixir_' + elixir.attrName;
    let message = "cr\xE9e un " + elixir.nom;
    let attr = tokenAttribute(forgesort, attrName);
    if (attr.length === 0) {
      var action = elixir.action.replace(/\$rang/g, voieDesElixirs);
      action = action.replace(/\$INT/g, modCarac(forgesort, 'intelligence'));
      setTokenAttr(forgesort, attrName, 1, evt, {
        msg: message,
        maxVal: action
      });
    } else {
      let nb = parseInt(attr[0].get('current'));
      if (isNaN(nb) || nb < 1) nb = 0;
      setTokenAttr(forgesort, attrName, nb + 1, evt, {
        msg: message
      });
    }
  }

  function gestionElixir(msg) {
    getSelected(msg, function(selected, playerId) {
      var player = getObj('player', playerId);
      if (player === undefined) {
        error("Impossible de trouver le joueur", playerId);
        return;
      }
      iterSelected(selected, function(forgesort) {
        var voieDesElixirs = predicateAsInt(forgesort, 'voieDesElixirs', 0);
        if (voieDesElixirs < 1) {
          sendPerso(forgesort, "ne conna\xEEt pas la Voie des \xC9lixirs");
          return;
        }
        var elixirsACreer = voieDesElixirs * 2;
        var attrElixirs = tokenAttribute(forgesort, 'elixirsACreer');
        if (attrElixirs.length === 0) {
          //TODO: ajouter un evenement pour pouvoir faire un undo
          attrElixirs = setTokenAttr(forgesort, 'elixirsACreer', elixirsACreer, {});
        } else {
          attrElixirs = attrElixirs[0];
          elixirsACreer = parseInt(attrElixirs.get('current'));
          if (isNaN(elixirsACreer)) elixirsACreer = 0;
        }
        var titre;
        if (elixirsACreer < 1)
          titre = "Impossible de cr\xE9er un autre \xE9lixir aujourd'hui";
        else titre = "Encore " + elixirsACreer + " \xE9lixirs \xE0 cr\xE9er";
        var display = startFramedDisplay(playerId, titre, forgesort, {
          chuchote: true
        });
        listeElixirs(voieDesElixirs).forEach(function(elixir) {
          if (elixir.rang < 4) {
            //Il est possible de changer l'\xE9lixir par d\xE9faut
            var altElixir = charAttribute(forgesort.charId, 'Elixir ' + elixir.rang);
            if (altElixir.length > 0) {
              elixir.nom = altElixir[0].get('current');
              elixir.attrName = altElixir[0].get('current');
              elixir.action = altElixir[0].get('max');
            }
          }
          var nbElixirs = 0;
          var attr = tokenAttribute(forgesort, 'elixir_' + elixir.attrName);
          if (attr.length > 0) {
            attr = attr[0];
            nbElixirs = parseInt(attr.get('current'));
            if (isNaN(nbElixirs) || nbElixirs < 0) nbElixirs = 0;
          }
          var nomElixir = elixir.nom;
          var options = '';
          var action;
          if (elixirsACreer > 0) {
            action = "!cof-creer-elixir " + forgesort.token.id + ' ' + elixir.attrName;
            options += bouton(action, nbElixirs, forgesort) + ' ';
          } else {
            options = nbElixirs + ' ';
          }
          if (nbElixirs > 0) {
            action = elixir.action;
            action = action.replace(/\$rang/g, voieDesElixirs);
            action = action.replace(/\$INT/g, modCarac(forgesort, 'intelligence'));
            options += bouton(action, nomElixir, forgesort, {
              ressource: attr
            });
          } else {
            options += nomElixir;
          }
          addLineToFramedDisplay(display, options);
        });
        sendChat('', endFramedDisplay(display));
      });
    }); //Fin du getSelected
  }

  function proposerRenouveauElixirs(evt, attrs) {
    var attrsNamed = allAttributesNamed(attrs, 'elixir');
    if (attrsNamed.length === 0) return attrs;
    // Trouver les forgesorts avec des \xE9lixirs sur eux
    var forgesorts = {};
    attrsNamed.forEach(function(attr) {
      // Check de l'existence d'un cr\xE9ateur
      var charId = attr.get('_characterid');
      // Check de l'existence d'un token pr\xE9sent pour le personnage
      var tokensPersonnage =
        findObjs({
          _type: 'graphic',
          _subtype: 'token',
          represents: charId
        });
      if (tokensPersonnage.length < 1) {
        error("Impossible de trouver le token du personnage " + charId + " avec un \xE9lixir sur la carte");
        return;
      }
      var token;
      if (tokensPersonnage.length > 1) {
        var pageIds = characterPageIds(charId);
        tokensPersonnage.forEach(function(t) {
          if (token) return;
          if (pageIds.has(t.get('pageid'))) token = t;
        });
      }
      if (token === undefined) token = tokensPersonnage[0];
      var personnage = {
        token: tokensPersonnage[0],
        charId: charId
      };
      var voieDesElixirs = predicateAsInt(personnage, 'voieDesElixirs');
      //TODO: r\xE9fl\xE9chir \xE0 une solution pour le renouveau des \xE9lixirs \xE9chang\xE9s
      if (voieDesElixirs > 0) {
        var elixirsDuForgesort = forgesorts[charId];
        if (elixirsDuForgesort === undefined) {
          elixirsDuForgesort = {
            forgesort: personnage,
            voieDesElixirs: voieDesElixirs,
            elixirsParRang: {}
          };
        }
        // Check de l'\xE9lixir \xE0 renouveler
        var nomElixir = attr.get('name');
        var typeElixir = listeElixirs(voieDesElixirs).find(function(i) {
          return "elixir_" + i.attrName == nomElixir;
        });
        if (typeElixir === undefined) {
          error("Impossible de trouver l'\xE9lixir \xE0 renouveler");
          return;
        }
        // Check des doses
        var doses = attr.get("current");
        if (isNaN(doses)) {
          error("Erreur interne : \xE9lixir mal form\xE9");
          return;
        }
        if (doses > 0) {
          // Tout est ok, cr\xE9ation de l'item
          var elixirArenouveler = {
            typeElixir: typeElixir,
            doses: doses
          };
          var elixirsParRang = elixirsDuForgesort.elixirsParRang;
          if (elixirsParRang[typeElixir.rang] === undefined) {
            elixirsParRang[typeElixir.rang] = [elixirArenouveler];
          } else elixirsParRang[typeElixir.rang].push(elixirArenouveler);
          forgesorts[charId] = elixirsDuForgesort;
        }
      }
    });
    // Display par personnage
    for (const [forgesortCharId, elixirsDuForgesort] of Object.entries(forgesorts)) {
      // Init du display pour le personnage
      let displayOpt = {
        chuchote: true
      };
      let allPlayers = getPlayerIds({
        charId: forgesortCharId
      });
      var playerId;
      if (allPlayers === undefined || allPlayers.length < 1) {
        displayOpt.chuchote = 'gm';
      } else {
        playerId = allPlayers[0];
      }
      var forgesort = elixirsDuForgesort.forgesort;
      setTokenAttr(forgesort, "elixirsACreer", elixirsDuForgesort.voieDesElixirs * 2, evt);
      var display = startFramedDisplay(allPlayers[0], "Renouveler les \xE9lixirs", forgesort, displayOpt);
      var actionToutRenouveler = "";
      // Boucle par rang de rune
      for (const rang in elixirsDuForgesort.elixirsParRang) {
        var elixirsDeRang = elixirsDuForgesort.elixirsParRang[rang];
        if (elixirsDeRang === undefined || elixirsDeRang.length < 1) continue;
        addLineToFramedDisplay(display, "Elixirs de rang " + rang, undefined, true);
        var actionTout = '';
        var ligneBoutons = '';
        // Boucle par \xE9lixir de ce rang \xE0 renouveler
        for (const i in elixirsDeRang) {
          var elixir = elixirsDeRang[i];
          // Boucle par dose
          for (let j = 0; j < elixir.doses; j++) {
            var action = "!cof-creer-elixir " + forgesort.token.id + " " + elixir.typeElixir.attrName;
            actionTout += action + "\n";
            actionToutRenouveler += action + "\n";
            var nomElixirComplet = elixir.typeElixir.nom;
            ligneBoutons += bouton(action, nomElixirComplet.replace("Elixir de ", "").replace("Elixir d'", ""), forgesort);
          }
        }
        ligneBoutons += bouton(actionTout, "Tout", forgesort, {
          buttonStyle: "background-color: blue;"
        });
        addLineToFramedDisplay(display, ligneBoutons, undefined, true);
      }
      var boutonToutRenouveler =
        bouton(actionToutRenouveler, "Tout renouveler", forgesort, {
          buttonStyle: "background-color: green;"
        });
      addLineToFramedDisplay(display, boutonToutRenouveler, undefined, true);
      sendChat('', endFramedDisplay(display));
    }
    return removeAllAttributes("elixir", evt, attrs);
  }

  function listeRunes(rang) {
    var liste = [];
    if (rang < 2) return liste;
    liste.push({
      nom: "Rune d'\xE9nergie",
      action: "!cof-rune-energie",
      attrName: "runeForgesort_\xE9nergie",
      rang: 2
    });
    if (rang < 3) return liste;
    liste.push({
      nom: "Rune de protection",
      action: "!cof-rune-protection",
      attrName: "runeForgesort_protection",
      rang: 3
    });
    if (rang < 4) return liste;
    liste.push({
      nom: "Rune de puissance",
      action: "!cof-rune-puissance",
      attrName: "runeForgesort_puissance",
      rang: 4
    });
    return liste;
  }

  function gestionRunes(msg) {
    getSelected(msg, function(selected, playerId) {
      const player = getObj('player', playerId);
      if (player === undefined) {
        error("Impossible de trouver le joueur", playerId);
        return;
      }
      iterSelected(selected, function(forgesort) {
        var voieDesRunes = predicateAsInt(forgesort, 'voieDesRunes', 0);
        if (voieDesRunes < 1) {
          sendPerso(forgesort, "ne conna\xEEt pas la Voie des Runes.");
          return;
        } else if (voieDesRunes < 2) {
          sendPerso(forgesort, "ne peut \xE9crire que des Runes de d\xE9fense.");
          return;
        }
        var titre = "Cr\xE9ation de runes";
        var display = startFramedDisplay(playerId, titre, forgesort, {
          chuchote: true
        });
        listeRunes(voieDesRunes).forEach(function(rune) {
          var action = "!cof-creer-rune " + forgesort.token.id + " @{target|token_id} " + rune.rang;
          if (rune.rang === 4) action += " ?{Num\xE9ro de l'arme de la cible?}";
          var options = bouton(action, rune.nom, forgesort);
          addLineToFramedDisplay(display, options);
        });
        sendChat('', endFramedDisplay(display));
      });
    }); //Fin du getSelected
  }

  //!cof-creer-rune token_id rune
  function creerRune(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 4) {
      error("Pas assez d'arguments pour !cof-creer-runes", msg.content);
      return;
    }
    var forgesort = persoOfId(cmd[1], cmd[1], options.pageId);
    if (forgesort === undefined) {
      if (msg.selected && msg.selected.length == 1) {
        forgesort = persoOfId(msg.selected[0]._id);
      }
      if (forgesort === undefined) {
        error("Impossible de savoir qui cr\xE9e la rune", cmd);
        return;
      }
    }
    var target = persoOfId(cmd[2], cmd[2], options.pageId);
    if (target === undefined) {
      error("Impossible de savoir \xE0 qui octroyer la rune", cmd);
      return;
    }
    var voieDesRunes = predicateAsInt(forgesort, 'voieDesRunes', 0);
    if (voieDesRunes < 1) {
      sendPerso(forgesort, "ne conna\xEEt pas la Voie des Runes");
      return;
    } else if (voieDesRunes < 2) {
      sendPerso(forgesort, "ne peut \xE9crire que des Runes de d\xE9fense.");
      return;
    }
    var rune = listeRunes(voieDesRunes).find(function(i) {
      return i.rang == cmd[3];
    });
    if (rune === undefined) {
      error(forgesort.token.get('name') + " est incapable de cr\xE9er " + cmd[3], cmd);
      return;
    }
    var labelArme;
    if (rune.rang == 4) {
      if (cmd.length < 5) {
        error("La rune de puissance n\xE9cessite de choisir un label d'arme.");
        return;
      }
      labelArme = parseInt(cmd[4]);
    }
    var evt = {
      type: "Cr\xE9ation de rune"
    };
    addEvent(evt);
    if (ficheAttributeAsBool(forgesort, 'option_pm', true)) {
      if (reglesOptionelles.mana.val.mana_totale.val) {
        switch (rune.rang) {
          case 2:
            options.mana = 3;
            break;
          case 3:
            options.mana = 6;
            break;
          case 4:
            options.mana = 10;
            break;
        }
      } else if (rune.rang > 2) {
        options.mana = rune.rang - 2;
      }
    }
    let attrName = rune.attrName;
    let message = "re\xE7oit ";
    let typeRune;
    switch (rune.rang) {
      case 2:
        typeRune = "une rune d'\xE9nergie";
        break;
      case 3:
        typeRune = "une rune de protection";
        break;
      case 4:
        typeRune = "une rune de puissance sur son ";
        let arme = getWeaponStats(target, labelArme);
        if (arme) typeRune += arme.name;
        else typeRune += "arme " + labelArme;
        attrName += "(" + labelArme + ")";
        break;
    }
    message += typeRune;
    if (attributeAsInt(target, attrName, 0) > 0) {
      error("La cible poss\xE8de d\xE9j\xE0 une rune " + typeRune, cmd);
      return;
    }
    if (options.mana !== undefined && limiteRessources(forgesort, options, undefined, "cr\xE9er " + typeRune, evt)) return;
    setTokenAttr(target, attrName, 1, evt, {
      msg: message,
      maxVal: forgesort.charId
    });
    if (rune.rang === 3 && reglesOptionelles.dommages.val.max_rune_protection.val) {
      setTokenAttr(target, "runeProtectionMax", voieDesRunes * 10, evt, {
        maxVal: forgesort.charId
      });
    }
  }

  //TODO: passer pageId en argument au lieu de prendre la page des joueurs
  function proposerRenouveauRunes(evt, attrs) {
    let attrsNamed = allAttributesNamed(attrs, 'runeForgesort');
    if (attrsNamed.length === 0) return attrs;
    // Filtrer par Forgesort, dans l'\xE9ventualit\xE9 qu'il y en ait plusieurs actifs
    let forgesorts = {};
    attrsNamed.forEach(function(attr) {
      // Check de l'existence d'un cr\xE9ateur
      let foundForgesortId = attr.get('max');
      if (foundForgesortId === undefined) {
        error("Impossible de retrouver le cr\xE9ateur de la rune : " + attr);
        return;
      }
      let runesDuForgesort = forgesorts[foundForgesortId];
      if (runesDuForgesort === undefined) {
        // Check de l'existence d'un token pr\xE9sent pour le cr\xE9ateur
        let tokensForgesort =
          findObjs({
            _pageid: Campaign().get("playerpageid"),
            _type: 'graphic',
            _subtype: 'token',
            represents: foundForgesortId
          });
        if (tokensForgesort.length < 1) {
          error("Impossible de trouver le token du forgesort " + foundForgesortId + " sur la carte");
          return;
        }
        var forgesort = {
          token: tokensForgesort[0],
          charId: foundForgesortId
        };
        // Check du perso voie des Runes
        var voieDesRunes = predicateAsInt(forgesort, 'voieDesRunes', 0);
        if (voieDesRunes < 1) {
          sendPerso(forgesort, "ne conna\xEEt pas la Voie des Runes");
          return;
        } else if (voieDesRunes < 2) {
          sendPerso(forgesort, "ne peut \xE9crire que des Runes de d\xE9fense.");
          return;
        }
        runesDuForgesort = {
          forgesort: forgesort,
          voieDesRunes: voieDesRunes,
          runesParRang: {}
        };
      }
      // Check de la pr\xE9sence d'un token pour la cible
      var targetCharId = attr.get('characterid');
      var tokensTarget =
        findObjs({
          _pageid: Campaign().get("playerpageid"),
          _type: 'graphic',
          _subtype: 'token',
          represents: targetCharId
        });
      if (tokensTarget.length < 1) {
        error("Impossible de trouver le token de la cible " + targetCharId + " sur la carte");
        return;
      }
      let target = {
        token: tokensTarget[0],
        charId: targetCharId
      };
      // Check de la rune \xE0 renouveler
      let runeName = attr.get('name');
      let typeRune =
        listeRunes(runesDuForgesort.voieDesRunes).find(function(i) {
          return i.attrName == runeName.split("(")[0];
        });
      if (typeRune === undefined) {
        error("Impossible de trouver la rune \xE0 renouveler");
        return;
      }
      // Tout est ok, cr\xE9ation de l'item
      let runeARenouveler = {
        target: target,
        typeRune: typeRune,
        runeName: runeName
      };
      let runesParRang = runesDuForgesort.runesParRang;
      if (runesParRang[typeRune.rang] === undefined) {
        runesParRang[typeRune.rang] = [runeARenouveler];
      } else runesParRang[typeRune.rang].push(runeARenouveler);
      forgesorts[foundForgesortId] = runesDuForgesort;
    });
    // Display par personnage
    for (const [forgesortCharId, runesDuForgesort] of Object.entries(forgesorts)) {
      // Init du desplay pour le personnage
      let displayOpt = {
        chuchote: true
      };
      let allPlayers = getPlayerIds({
        charId: forgesortCharId
      });
      var playerId;
      if (allPlayers === undefined || allPlayers.length < 1) {
        displayOpt.chuchote = 'gm';
      } else {
        playerId = allPlayers[0];
      }
      var forgesort = runesDuForgesort.forgesort;
      var display = startFramedDisplay(allPlayers[0], "Renouveler les runes", forgesort, displayOpt);
      var actionToutRenouveler = "";
      // Boucle par rang de rune
      for (const rang in runesDuForgesort.runesParRang) {
        var runesDeRang = runesDuForgesort.runesParRang[rang];
        if (runesDeRang === undefined || runesDeRang.length < 1) continue;
        addLineToFramedDisplay(display, runesDeRang[0].typeRune.nom, undefined, true);
        var actionTout = "";
        var ligneBoutons = "";
        // Boucle par rune de ce rang \xE0 renouveler
        for (const i in runesDeRang) {
          var rune = runesDeRang[i];
          var action = "!cof-creer-rune " + forgesort.token.id + " " + rune.target.token.id + " " + rang;
          if (rang == 4) {
            var runeName = rune.runeName;
            action += " " + runeName.substring(runeName.indexOf("(") + 1, runeName.indexOf(")"));
          }
          actionTout += action + "\n";
          actionToutRenouveler += action + "\n";
          ligneBoutons += bouton(action, rune.target.token.get('name'), forgesort);
        }
        ligneBoutons += bouton(actionTout, "Tout", forgesort, {
          buttonStyle: "background-color: blue;"
        });
        addLineToFramedDisplay(display, ligneBoutons, undefined, true);
      }
      var boutonToutRenouveler =
        bouton(actionToutRenouveler, "Tout renouveler", forgesort, {
          buttonStyle: "background-color: green;"
        });
      addLineToFramedDisplay(display, boutonToutRenouveler, undefined, true);
      sendChat('', endFramedDisplay(display));
    }
    return removeAllAttributes("runeForgesort", evt, attrs);
  }

  function parseRageDuBerserk(msg) {
    var typeRage = 'rage';
    if (msg.content.includes(' --furie')) typeRage = 'furie';
    getSelected(msg, function(selection, playerId) {
      if (selection.length === 0) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour la rage", playerId);
        return;
      }
      var options = parseOptions(msg);
      if (options === undefined) return;
      if (options.son) playSound(options.son);
      var persos = [];
      iterSelected(selection, function(perso) {
        persos.push(perso);
      });
      doRageDuBerserk(persos, typeRage, options);
    });
  }

  function doRageDuBerserk(persos, typeRage, options) {
    var evt = {
      type: "rage",
      action: {
        persos: persos,
        typeRage: typeRage,
        options: options
      }
    };
    addEvent(evt);
    persos.forEach(function(perso) {
      var attrRage = tokenAttribute(perso, 'rageDuBerserk');
      if (attrRage.length > 0) {
        attrRage = attrRage[0];
        typeRage = attrRage.get('current');
        var difficulte = 13;
        if (typeRage == 'furie') difficulte = 16;
        //Jet de sagesse difficult\xE9 13 pou 16 pour sortir de cet \xE9tat
        var display = startFramedDisplay(options.playerId, "Essaie de calmer sa " + typeRage, perso);
        var testId = 'rageDuBerserk_' + perso.token.id;
        testCaracteristique(perso, 'SAG', difficulte, testId, options, evt,
          function(tr) {
            addLineToFramedDisplay(display, "<b>R\xE9sultat du jet de SAG :</b> " + tr.texte);
            if (tr.reussite) {
              addLineToFramedDisplay(display, "C'est r\xE9ussi, " + perso.token.get('name') + " se calme." + tr.modifiers);
              removeTokenAttr(perso, 'rageDuBerserk', evt);
            } else {
              var msgRate = "C'est rat\xE9, " + perso.token.get('name') + " reste enrag\xE9" + tr.rerolls + tr.modifiers;
              addLineToFramedDisplay(display, msgRate);
            }
            sendChat('', endFramedDisplay(display));
          });
      } else {
        //Le barbare passe en rage
        if (limiteRessources(perso, options, 'rageDuBerserk', "entrer en rage du berserk", evt)) {
          return;
        }
        if (!stateCOF.combat) {
          initiative([{
            _id: perso.token.id
          }], evt);
        }
        setTokenAttr(perso, 'rageDuBerserk', typeRage, evt, {
          msg: "entre dans une " + typeRage + " berserk !"
        });
      }
    });
  }

  //!cof-arme-secrete @{selected|token_id} @{target|token_id}
  function parseArmeSecrete(msg) {
    var options = parseOptions(msg);
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il faut deux arguments \xE0 !cof-arme-secrete", cmd);
      return;
    }
    var barde = persoOfId(cmd[1]);
    var cible = persoOfId(cmd[2]);
    if (barde === undefined || cible === undefined) {
      error("Token non valide pour l'arme secr\xE8te", cmd);
      return;
    }
    if (attributeAsInt(barde, 'armeSecreteBardeUtilisee')) {
      sendPerso(barde, "a d\xE9j\xE0 utilis\xE9 son arme secr\xE8te durant ce combat");
      return;
    }
    doArmeSecrete(barde, cible, options);
  }

  function doArmeSecrete(perso, cible, options) {
    var evt = {
      type: 'armeSecrete',
      action: {
        perso: perso,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    if (!stateCOF.combat) {
      initiative([{
        _id: perso.token.id
      }, {
        _id: cible.token.id
      }], evt);
    }
    setTokenAttr(perso, 'armeSecreteBardeUtilisee', true, evt);
    var intCible = ficheAttributeAsInt(cible, 'intelligence', 10);
    var testId = 'armeSecreteBarde';
    testCaracteristique(perso, 'CHA', intCible, testId, options, evt, function(tr) {
      var display = startFramedDisplay(options.playerId,
        "Arme secr\xE8te", perso, {
          perso2: cible
        });
      var line = "Jet de CHA : " + tr.texte;
      if (tr.reussite) {
        line += " &ge; " + intCible + tr.modifiers;
        addLineToFramedDisplay(display, line);
        addLineToFramedDisplay(display, cible.token.get('name') + " est compl\xE8tement d\xE9stabilis\xE9");
        setAttrDuree(cible, 'armeSecreteBarde', 1, evt);
      } else {
        line += " &lt; " + intCible + tr.rerolls + tr.modifiers;
        addLineToFramedDisplay(display, line);
        addLineToFramedDisplay(display, cible.token.get('name') + " reste insensible au charme de " + perso.token.get('name'));
      }
      sendChat("", endFramedDisplay(display));
    }); //fin testCarac
  }

  function nouveauNomDePerso(nom) {
    var characters = findObjs({
      _type: 'character'
    });
    characters = characters.map(function(c) {
      return c.get('name');
    });
    var trouve = characters.indexOf(nom);
    if (trouve < 0) return nom;
    var n = 2;
    while (1) {
      var nomP = nom + ' ' + n;
      trouve = characters.indexOf(nomP);
      if (trouve < 0) return nomP;
      n++;
    }
  }

  //!cof-animer-arbre lanceur-id target-id [rang]
  function animerUnArbre(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-animer-arbre attend 2 arguments", msg.content);
      return;
    }
    var druide = persoOfId(cmd[1], cmd[1], options.pageId);
    if (druide === undefined) {
      error("Le premier argument de !cof-animer-arbre n'est pas un token valie", cmd);
      return;
    }
    let tokenArbre = getObj('graphic', cmd[2]);
    if (tokenArbre === undefined) {
      error("Le deuxi\xE8me argument de !cof-animer-arbre n'est pas un token", cmd);
      return;
    }
    if (tokenArbre.get('represents') !== '') {
      sendPerso(druide, "ne peut pas animer " + tokenArbre.get('name'));
      return;
    }
    if (options.portee !== undefined) {
      let dist = distanceCombat(druide.token, tokenArbre, options.pageId);
      if (dist > options.portee) {
        sendPerso(druide, "est trop loin de l'arbre");
        return;
      }
    }
    var rang = predicateAsInt(druide, 'voieDesVegetaux', 3);
    if (cmd.length > 3) { //Le rang est sp\xE9cifi\xE9 en argument optionnel
      var cmd3 = parseInt(cmd[3]);
      if (isNaN(cmd3) || cmd3 < 1) {
        error("Le rang n'est pas un nombre valie. On utilise " + rang + " \xE0 la place", cmd);
      } else rang = cmd3;
    }
    const evt = {
      type: "Animation d'un arbre"
    };
    addEvent(evt);
    if (limiteRessources(druide, options, 'animerUnArbre', 'animer un arbre', evt)) return;
    if (!stateCOF.combat) {
      initPerso(druide, evt);
    }
    let niveau = ficheAttributeAsInt(druide, 'niveau', 1);
    let nomArbre = nouveauNomDePerso('Arbre anim\xE9');
    let avatar = "https://s3.amazonaws.com/files.d20.io/images/42323556/6qxlm965aFhBXGoYFy5fqg/thumb.png?1510582137";
    let specArbre = {
      pv: rang * 10,
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: niveau,
        force: 18,
        pnj_for: 4,
        dexterite: 7,
        pnj_dex: -2,
        constitution: 20,
        pnj_con: 5,
        intelligence: 8,
        pnj_int: -1,
        sagesse: 14,
        pnj_sag: 2,
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 5,
        pnj_def: 13,
        pnj_init: 7,
        RDS: '10/feu_hache',
        race: 'arbre',
        taille: 'grand'
      },
      attaques: [{
        nom: 'Branches',
        atk: niveau,
        dmnbde: 1,
        dmde: 6,
        dm: 3,
        typedegats: 'contondant',
      }],
      attributes: [{
        name: 'arbreAnime',
        current: niveau,
        max: getInit(),
      }]
    };
    let charArbre = createCharacter(nomArbre, options.playerId, avatar, tokenArbre, specArbre);
    evt.characters = [charArbre];
    sendChar(charArbre.id, "commence \xE0 s'animer", true);
    initiative([{
      _id: tokenArbre.id
    }], evt);
    // Ajout de l'arbre anim\xE9 aux alli\xE9s du Druide
    let alliesDruide = alliesParPerso[druide.charId] || new Set();
    alliesDruide.add(charArbre.id);
    alliesParPerso[druide.charId] = alliesDruide;
  }

  //!cof-rune-protection
  function runeProtection(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser les runes de protection qu'en combat");
      return;
    }
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    var evt = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evt = findEvent(cmd[1]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
    }
    if (evt.type != 'Attaque') {
      sendChat('', "la derni\xE8re action n'est pas une attaque r\xE9ussie, trop tard pour absorber l'attaque pr\xE9c\xE9dente");
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Personne n'est s\xE9lectionn\xE9 pour utiliser une rune", msg);
        return;
      }
      var action = evt.action;
      iterSelected(selected, function(perso) {
        if (!peutController(msg, perso)) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton", playerId);
          return;
        }
        var cible = action.cibles.find(function(target) {
          return (target.token.id === perso.token.id);
        });
        if (cible === undefined) {
          sendPerso(perso, "n'est pas la cible de la derni\xE8re attaque");
          return;
        }
        if (!attributeAsBool(perso, 'runeForgesort_protection')) {
          sendPerso(perso, "n'a pas de rune de protection");
          return;
        }
        if (attributeAsInt(perso, 'limiteParCombat_runeForgesort_protection', 1) < 1) {
          sendPerso(perso, "a d\xE9j\xE0 utilis\xE9 sa rune de protection durant ce combat");
          return;
        }
        action.choices = action.choices || {};
        action.choices[perso.token.id] = action.choices[perso.token.id] || {};
        action.choices[perso.token.id].runeForgesort_protection = true;
      }); //fin iterSelected
      var options = action.currentOptions || {};
      options.rolls = action.rolls;
      options.choices = action.choices;
      resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, options, evt, action.explications, action.pageId, action.cibles);
    }); //fin getSelected
  }

  function appliquerRuneDeProtection(cible, options, evt) {
    if (reglesOptionelles.dommages.val.max_rune_protection.val) {
      cible.utiliseRuneProtectionMax = attributeAsInt(cible, 'runeProtectionMax', 30);
    } else {
      cible.utiliseRuneProtection = true;
    }
    removePreDmg(options, cible);
  }

  //!cof-delivrance @{selected|token_id} @{target|token_id}
  function delivrance(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-delivrance attend 2 arguments", msg.content);
      return;
    }
    let pretre = persoOfId(cmd[1], cmd[1], options.pageId);
    if (pretre === undefined) {
      error("Le premier argument de !cof-delivrance n'est pas un token valide", msg.content);
      return;
    }
    let cible = persoOfId(cmd[2], cmd[2], options.pageId);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-delivrance n'est pas un token valide", msg.content);
      return;
    }
    cible.tokName = cible.token.get('name');
    if (options.portee !== undefined) {
      let dist = distanceCombat(pretre.token, cible.token, options.pageId);
      if (dist > options.portee) {
        sendPerso(pretre, "est trop loin de " + cible.tokName);
        return;
      }
    }
    const evt = {
      type: "D\xE9livrance",
      deletedAttributes: []
    };
    addEvent(evt);
    if (limiteRessources(pretre, options, 'd\xE9livrance', 'd\xE9livrance', evt)) return;
    let display = startFramedDisplay(getPlayerIdFromMsg(msg), 'D\xE9livrance', pretre, {
      perso2: cible
    });
    let printEffet = function(message) {
      addLineToFramedDisplay(display, cible.tokName + ' ' + message);
    };
    let optFin = {
      print: printEffet,
      pageId: options.pageId
    };
    _.each(messageEffetTemp, function(effet, nomEffet) {
      if (effet.prejudiciable) {
        //Attention, ne fonctionne pas avec les effets g\xE9n\xE9riques
        let attr = tokenAttribute(cible, nomEffet);
        if (attr.length > 0)
          finDEffet(attr[0], nomEffet, attr[0].get('name'), cible.charId, evt, optFin);
      }
    });
    _.each(messageEffetCombat, function(effet, nomEffet) {
      if (effet.prejudiciable) {
        let attr = tokenAttribute(cible, nomEffet);
        if (attr.length > 0) {
          printEffet(effet.fin);
          evt.deletedAttributes.push(attr[0]);
          attr[0].remove();
        }
      }
    });
    _.each(messageEffetIndetermine, function(effet, nomEffet) {
      if (effet.prejudiciable) {
        let attr = tokenAttribute(cible, nomEffet);
        if (attr.length > 0) {
          printEffet(effet.fin);
          evt.deletedAttributes.push(attr[0]);
          attr[0].remove();
        }
      }
    });
    if (attributeAsBool(cible, 'malediction')) {
      printEffet("n'est plus maudite");
      removeTokenAttr(cible, 'malediction', evt);
    }
    //On enl\xE8ve les \xE9tats pr\xE9judiciables
    if (getState(cible, 'aveugle')) {
      printEffet("retrouve la vue");
      setState(cible, 'aveugle', false, evt);
    }
    if (getState(cible, 'affaibli')) {
      printEffet("retrouve des forces");
      setState(cible, 'affaibli', false, evt);
    }
    if (getState(cible, 'etourdi')) {
      printEffet("retrouve ses esprits");
      setState(cible, 'etourdi', false, evt);
    }
    if (getState(cible, 'paralyse')) {
      printEffet("peut \xE0 nouveau bouger");
      setState(cible, 'paralyse', false, evt);
    }
    if (getState(cible, 'ralenti')) {
      printEffet("retrouve une vitesse normale");
      setState(cible, 'ralenti', false, evt);
    }
    if (getState(cible, 'endormi')) {
      printEffet("se r\xE9veille");
      setState(cible, 'endormi', false, evt);
    }
    if (getState(cible, 'apeure')) {
      printEffet("reprend courage");
      setState(cible, 'apeure', false, evt);
    }
    //R\xE9g\xE9n\xE9ration d'une carac affaiblie de 1d4, si il y en a.
    if (attributeAsInt(cible, 'affaiblissementdesagesse', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'sagesse', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points de sagesse");
    } else if (attributeAsInt(cible, 'affaiblissementdecharisme', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'charisme', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points de charisme");
    } else if (attributeAsInt(cible, 'affaiblissementdeintelligence', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'intelligence', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points d'intelligence");
    }
    if (attributeAsInt(cible, 'affaiblissementdeconstitution', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'constitution', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points de constitution");
    } else if (attributeAsInt(cible, 'affaiblissementdeforce', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'force', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points de force");
    } else if (attributeAsInt(cible, 'affaiblissementdedexterite', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'dexterite', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points de dext\xE9rit\xE9");
    }
    sendChat('', endFramedDisplay(display));
  }

  function guerisonPerso(perso, evt, lanceur) {
    let msgSoin;
    if (lanceur) {
      if (lanceur.token.id == perso.token.id) {
        msgSoin = 'se soigne';
      } else {
        msgSoin = 'soigne ' + perso.token.get('name');
      }
    } else {
      msgSoin = 'r\xE9cup\xE8re';
    }
    msgSoin += ' de toutes les blessures subies';
    if (lanceur) sendPerso(lanceur, msgSoin);
    else sendPerso(perso, msgSoin);
    if (getState(perso, 'blesse')) {
      setState(perso, 'blesse', false, evt);
    }
    let soins = perso.token.get('bar1_max') - perso.token.get('bar1_value');
    if (isNaN(soins)) {
      updateCurrentBar(perso, 1, perso.token.get('bar1_max'), evt);
      return;
    }
    //Les affaiblissements de caract\xE9ristiques
    allCaracs.forEach(function(carac) {
      let malus = attributeAsInt(perso, 'affaiblissementde' + carac, 0);
      if (malus > 0) {
        diminueAffaiblissement(perso, carac, malus, evt, malus);
        sendPerso(perso, "r\xE9cup\xE8re " + malus + " points de " + carac);
      }
    });
    if (soins <= 0) {
      //Rien d'autre \xE0 faire (le script ne g\xE8re pas encore le reste)
      return;
    }
    soigneToken(perso, soins, evt);
  }

  //!cof-guerison @{selected|token_id} @{target|token_id}
  function guerison(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-guerison attend le lanceur et la cible en argument", msg.content);
      return;
    }
    let lanceur = persoOfId(cmd[1], cmd[1], options.pageId);
    if (lanceur === undefined) {
      error("Le premier argument de !cof-guerison n'est pas un token valide", msg.content);
      return;
    }
    let cible = persoOfId(cmd[2], cmd[2], options.pageId);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-guerison n'est pas un token valide", msg.content);
      return;
    }
    if (options.dose === undefined && options.decrAttribute === undefined) {
      options.limiteParJour = 1;
    }
    if (options.portee !== undefined) {
      var dist = distanceCombat(lanceur.token, cible.token, options.pageId);
      if (dist > options.portee) {
        sendPerso(lanceur, "est trop loin de " + cible.token.get('name'));
        return;
      }
    }
    const evt = {
      type: "Gu\xE9rison",
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'gu\xE9rison', 'gu\xE9rison', evt)) return;
    guerisonPerso(cible, evt, lanceur);
    if (options.messages) {
      options.messages.forEach(function(m) {
        sendChat('', m);
      });
    }
  }

  function armeDeContact(perso, arme, labelArmeDefaut, armeContact) {
    if (arme) return arme;
    arme = armesEnMain(perso);
    if (arme === undefined && labelArmeDefaut)
      arme = getWeaponStats(perso, labelArmeDefaut);
    //L'arme doit \xEAtre une arme de contact ?
    if (armeContact && arme && arme.portee) {
      sendPerso(perso, armeContact + " " + arme.name + " est une arme \xE0 distance.");
      return;
    }
    if (arme) {
      return arme;
    }
    arme = {
      name: 'Attaque par d\xE9faut',
      attSkillDiv: 0,
      attSkill: "@{ATKCAC}",
      crit: 20,
      parDefaut: true,
    };
    return arme;
  }

  //peuple tokName de l'attaquant et du d\xE9fenseur
  function attaqueContactOpposee(playerId, attaquant, defenseur, evt, options, callback) {
    var explications = [];
    options = options || {
      pasDeDmg: true
    };
    options.contact = true;
    attaquant.tokName = attaquant.tokName || attaquant.token.get('name');
    defenseur.tokName = defenseur.tokName || defenseur.token.get('name');
    entrerEnCombat(attaquant, [defenseur], explications, evt);
    //Recherche des armes utilis\xE9es
    var armeAttaquant = armeDeContact(attaquant, options.armeAttaquant, options.labelArmeAttaquant, options.armeAttaquantContact);
    var armeDefenseur = armeDeContact(defenseur, options.armeDefenseur, options.labelArmeDefenseur, options.armeDefenseurContact);
    var action = options.action || "<b>Attaque oppos\xE9e</b>";
    if (!armeAttaquant.parDefaut) {
      action += " <span style='" + BS_LABEL + " " + BS_LABEL_INFO + "; text-transform: none; font-size: 100%;'>(" + armeAttaquant.name + ")</span>";
    }
    var display = startFramedDisplay(playerId, action, attaquant, {
      perso2: defenseur
    });
    var critAttaquant = critEnAttaque(attaquant, armeAttaquant, options);
    var dice = 20;
    let malusAttaque = 0;
    if (estAffaibli(attaquant)) {
      if (predicateAsBool(attaquant, 'insensibleAffaibli')) {
        malusAttaque = -2;
        explications.push("Attaquant affaibli, mais insensible => -2 en Attaque");
      } else {
        dice = 12;
        explications.push("Attaquant affaibli => D12 au lieu de D20 en Attaque");
      }
    } else if (getState(attaquant, 'immobilise')) {
      dice = 12;
      explications.push("Attaquant immobilis\xE9 => D12 au lieu de D20 en Attaque");
    }
    var toEvaluateAttack = attackExpression(attaquant, 1, dice, critAttaquant, true, armeAttaquant);
    sendChat('', toEvaluateAttack, function(resAttack) {
      var rollsAttack = resAttack[0];
      if (options.rolls && options.rolls.attack)
        rollsAttack = options.rolls.attack;
      var afterEvaluateAttack = rollsAttack.content.split(' ');
      var attRollNumber = rollNumber(afterEvaluateAttack[0]);
      var attSkillNumber = rollNumber(afterEvaluateAttack[1]);
      var d20rollAttaquant = rollsAttack.inlinerolls[attRollNumber].results.total;
      var attSkill = rollsAttack.inlinerolls[attSkillNumber].results.total;
      var attBonus =
        bonusAttaqueA(attaquant, armeAttaquant.name, evt, explications, options);
      attBonus += malusAttaque;
      var pageId = options.pageId || attaquant.token.get('pageid');
      attBonus +=
        bonusAttaqueD(attaquant, defenseur, 0, pageId, evt, explications, options);
      var attackRollAttaquant = d20rollAttaquant + attSkill + attBonus;
      var attRollValue = buildinline(rollsAttack.inlinerolls[attRollNumber]);
      attRollValue += (attSkill > 0) ? "+" + attSkill : (attSkill < 0) ? attSkill : "";
      attRollValue += (attBonus > 0) ? "+" + attBonus : (attBonus < 0) ? attBonus : "";
      if (options.bonusAttaqueAttaquant) {
        options.bonusAttaqueAttaquant.forEach(function(bad) {
          attRollValue += (bad.val > 0) ? "+" + bad.val : (bad.val < 0) ? bad.val : "";
          attackRollAttaquant += bad.val;
          if (bad.explication) explications.push(bad.explication);
        });
      }
      addLineToFramedDisplay(display, "Jet de " + attaquant.tokName + " : " + attRollValue);
      var critDefenseur = critEnAttaque(defenseur, armeDefenseur, options);
      dice = 20;
      malusAttaque = 0;
      if (estAffaibli(defenseur)) {
        if (predicateAsBool(defenseur, 'insensibleAffaibli')) {
          malusAttaque = -2;
          explications.push("D\xE9fenseur affaibli, mais insensible => -2 en Attaque");
        } else {
          dice = 12;
          explications.push("D\xE9fenseur affaibli => D12 au lieu de D20 en Attaque");
        }
      } else if (getState(defenseur, 'immobilise')) {
        dice = 12;
        explications.push("D\xE9fenseur immobilis\xE9 => D12 au lieu de D20 en Attaque");
      }
      toEvaluateAttack = attackExpression(defenseur, 1, dice, critDefenseur, true, armeDefenseur);
      sendChat('', toEvaluateAttack, function(resAttack) {
        var rollsAttack = resAttack[0];
        if (options.rolls && options.rolls.attackDefenseur)
          rollsAttack = options.rolls.attackDefenseur;
        afterEvaluateAttack = rollsAttack.content.split(' ');
        attRollNumber = rollNumber(afterEvaluateAttack[0]);
        attSkillNumber = rollNumber(afterEvaluateAttack[1]);
        var d20rollDefenseur = rollsAttack.inlinerolls[attRollNumber].results.total;
        attSkill = rollsAttack.inlinerolls[attSkillNumber].results.total;
        attBonus =
          bonusAttaqueA(defenseur, armeDefenseur.name, evt, explications, options);
        attBonus += malusAttaque;
        attBonus +=
          bonusAttaqueD(defenseur, attaquant, 0, pageId, evt, explications, options);
        var attackRollDefenseur = d20rollDefenseur + attSkill + attBonus;
        attRollValue = buildinline(rollsAttack.inlinerolls[attRollNumber]);
        attRollValue += (attSkill > 0) ? "+" + attSkill : (attSkill < 0) ? attSkill : "";
        attRollValue += (attBonus > 0) ? "+" + attBonus : (attBonus < 0) ? attBonus : "";
        if (options.bonusAttaqueDefenseur) {
          options.bonusAttaqueDefenseur.forEach(function(bad) {
            attRollValue += (bad.val > 0) ? "+" + bad.val : (bad.val < 0) ? bad.val : "";
            attackRollDefenseur += bad.val;
            if (bad.explication) explications.push(bad.explication);
          });
        }
        addLineToFramedDisplay(display, "Jet de " + defenseur.tokName + " : " + attRollValue);
        var resultat = {
          rollAttaquant: attackRollAttaquant,
          rollDefenseur: attackRollDefenseur,
          armeAttaquant: armeAttaquant
        };
        if (d20rollAttaquant == 1 && d20rollDefenseur > 1) {
          resultat.echec = true;
          resultat.echecCritique = true;
          diminueMalediction(attaquant, evt);
        } else if (d20rollDefenseur == 1 && d20rollAttaquant > 1) {
          resultat.succes = true;
          resultat.echecCritiqueDefenseur = true;
          diminueMalediction(defenseur, evt);
        } else if (d20rollAttaquant >= critAttaquant && d20rollDefenseur < critDefenseur) {
          resultat.succes = true;
          resultat.critique = true;
          diminueMalediction(defenseur, evt);
        } else if (d20rollAttaquant < critAttaquant && d20rollDefenseur >= critDefenseur) {
          resultat.succes = false;
          resultat.critiqueDefenseur = true;
          diminueMalediction(attaquant, evt);
        } else if (attackRollAttaquant < attackRollDefenseur) {
          resultat.echec = true;
          diminueMalediction(attaquant, evt);
        } else {
          resultat.succes = true;
          diminueMalediction(defenseur, evt);
        }
        callback(resultat, display, explications); //evt est mis \xE0 jour
      }); //fin du sendchat pour jet du d\xE9fenseur
    }); //Fin du sendChat pour jet de l'attaquant
  }

  function testAttaqueOpposee(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il faut 2 personnages pour un test d'attaque en opposition", cmd);
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    var defenseur = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-test-attaque-opposee doit \xEAtre un token valide", cmd[1]);
      return;
    }
    if (defenseur === undefined) {
      error("Le deuxi\xE8me argument de !cof-test-attaque-opposee doit \xEAtre un token valide", cmd[2]);
      return;
    }
    var evt = {
      type: "Test d'attaque oppos\xE9e"
    };
    var options = {
      pasDeDmg: true
    };
    if (cmd.length > 3) options.labelArmeAttaquant = cmd[3];
    var playerId = getPlayerIdFromMsg(msg);
    attaqueContactOpposee(playerId, attaquant, defenseur, evt, options,
      function(res, display, explications) {
        if (res.succes)
          addLineToFramedDisplay(display, attaquant.tokName + " remporte le test");
        else
          addLineToFramedDisplay(display, defenseur.tokName + " remporte le test");
        explications.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
        sendChat("", endFramedDisplay(display));
        addEvent(evt);
      });
  }

  //!cof-desarmer attaquant cible, optionellement un label d'arme
  function desarmer(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il manque des arguments \xE0 !cof-desarmer", msg.content);
      return;
    }
    var guerrier = persoOfId(cmd[1], cmd[1]);
    if (guerrier === undefined) {
      error("Le premier argument de !cof-desarmer n'est pas un token valide", cmd);
      return;
    }
    guerrier.tokName = guerrier.token.get('name');
    var cible = persoOfId(cmd[2], cmd[2]);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-desarmer n'est pas un token valide", cmd);
      return;
    }
    cible.tokName = cible.token.get('name');
    var pageId = guerrier.token.get('pageid');
    if (distanceCombat(guerrier.token, cible.token, pageId)) {
      sendPerso(guerrier, "est trop loin de " + cible.tokName + " pour le d\xE9sarmer.");
      return;
    }
    var options = {
      action: "<b>D\xE9sarmement</b>",
      armeContact: "doit porter une arme de contact pour d\xE9sarmer son adversaire.",
      pasDeDmg: true,
      pageId: pageId,
    };
    //On cherche l'arme de la cible. On en aura besoin pour d\xE9sarmer
    var armeCible;
    var attrArmeCible = tokenAttribute(cible, 'armeEnMain');
    if (attrArmeCible.length > 0) {
      attrArmeCible = attrArmeCible[0];
      armeCible = getWeaponStats(cible, attrArmeCible.get('current'));
      if (armeCible) {
        options.armeDefenseur = armeCible;
        if (armeCible.deuxMains) {
          options.bonusAttaqueDefenseur = [{
            val: 5,
            explication: cible.tokName + " porte une arme \xE0 2 mains => +5 \xE0 son jet"
          }];
        }
      }
    } else attrArmeCible = undefined;
    var enleverArmeCible = function() {
      if (attrArmeCible) {
        evt.deletedAttributes = evt.deletedAttributes || [];
        evt.deletedAttributes.push(attrArmeCible);
        attrArmeCible.remove();
      }
    };
    var evt = {
      type: 'D\xE9sarmer'
    };
    if (cmd.length > 3) options.labelArmeAttaquant = cmd[3];
    var playerId = getPlayerIdFromMsg(msg);
    attaqueContactOpposee(playerId, guerrier, cible, evt, options,
      function(res, display, explications) {
        var resultat;
        if (res.echecCritique) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_DANGER + "'><b>\xE9chec&nbsp;critique</b></span>";
        } else if (res.echecCritiqueDefenseur) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succ\xE8s</b></span>, " + cible.tokName + " laisse tomber son arme, difficile de la r\xE9cup\xE9rer...";
          enleverArmeCible();
        } else if (res.critique) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>r\xE9ussite critique</b></span> : " + cible.tokName + " est d\xE9sarm\xE9, et " + guerrier.tokName + " emp\xEAche de reprendre l'arme";
          enleverArmeCible();
        } else if (res.critiqueDefenseur) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>\xE9chec</b></span>, " + cible.tokName + " garde son arme bien en main";
        } else if (res.echec) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>\xE9chec</b></span>, " + guerrier.tokName + " n'a pas r\xE9ussi \xE0 d\xE9sarmer son adversaire";
        } else { //succ\xE8s
          enleverArmeCible();
          if (res.rollAttaquant > res.rollDefenseur + 9) {
            resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succ\xE8s</b></span>, " + guerrier.tokName + " d\xE9sarme son adversaire et l'emp\xEAche de r\xE9cup\xE9rer son arme";
          } else {
            resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succ\xE8s</b></span>, " + guerrier.tokName + " d\xE9sarme son adversaire.";
          }
        }
        addLineToFramedDisplay(display, resultat);
        explications.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
        sendChat("", endFramedDisplay(display));
        addEvent(evt);
      });
  }

  function appliquerBloquer(attaquant, cible, critique, evt, envoyerMessage) {
    var msg;
    if (envoyerMessage) msg = "est bloqu\xE9 par son adversaire";
    setAttrDuree(cible, 'bloqueManoeuvre', 1, evt, msg);
    if (critique)
      appliquerTenirADistance(attaquant, cible, false, evt, envoyerMessage);
  }

  function appliquerTenirADistance(attaquant, cible, critique, evt, envoyerMessage) {
    var msg;
    if (envoyerMessage) msg = "est tenu \xE0 distance par son adversaire";
    setAttrDuree(
      cible, 'tenuADistanceManoeuvre(' + attaquant.token.id + ')', 1, evt, msg);
    if (critique) appliquerBloquer(attaquant, cible, false, evt, envoyerMessage);
  }

  var listeManoeuvres = {
    aveugler: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var duree = 1;
        if (critique) duree = randomInteger(6);
        var msg;
        if (envoyerMessage) msg = "est aveugl\xE9 par son adversaire";
        setAttrDuree(
          cible, 'aveugleManoeuvre', duree, evt, msg);
        return critique; //Pour les DMs en plus
      },
      verbe: 'aveugler',
      duelliste: false
    },
    bloquer: {
      appliquer: appliquerBloquer,
      penalitePlusPetit: true,
      verbe: 'bloquer',
      duelliste: true
    },
    desarmer: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var attrArmeCible = tokenAttribute(cible, 'armeEnMain');
        if (attrArmeCible.length > 0) {
          attrArmeCible = attrArmeCible[0];
          evt.deletedAttributes = evt.deletedAttributes || [];
          evt.deletedAttributes.push(attrArmeCible);
          attrArmeCible.remove();
        }
        if (envoyerMessage) {
          var msgDesarme = "est d\xE9sarm\xE9" + onGenre(cible, '', 'e');
          if (critique) msgDesarme += ", son adversaire lui a pris son arme.";
          else msgDesarme += ".";
          sendPerso(cible, msgDesarme);
        }
      },
      verbe: 'd\xE9sarmer',
      duelliste: true
    },
    faireDiversion: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var msg;
        if (envoyerMessage) msg = "a son attention attir\xE9e ailleurs";
        var malus = -5;
        if (critique) malus = -10;
        setAttrDuree(cible, 'diversionManoeuvre', 1, evt, msg);
        setTokenAttr(cible, 'diversionManoeuvreValeur', malus, evt);
      },
      verbe: 'faire diversion sur',
      duelliste: false
    },
    menacer: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var msg;
        if (envoyerMessage) msg = "est sous le coup d'une menace";
        var effet = 'menaceManoeuvre(' + attaquant.token.id;
        if (critique) effet += ',crit';
        effet += ')';
        setAttrDuree(cible, effet, 1, evt, msg);
      },
      verbe: 'menacer',
      duelliste: false
    },
    renverser: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        if (envoyerMessage) sendPerso(cible, "tombe au sol");
        setState(cible, 'renverse', true, evt);
        return critique; //Pour les DM en plus
      },
      penalitePlusPetit: true,
      verbe: 'renverser',
      duelliste: true
    },
    repousser: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var distance = rollDePlus(6);
        if (critique && distance < 3) distance = 3;
        if (envoyerMessage)
          sendPerso(cible, "est repouss\xE9" + onGenre(cible, '', 'e') + " et doit reculer de " + distance.roll + "m.");
        if (critique) setState(cible, 'renverse', true, evt);
      },
      penalitePlusPetit: true,
      verbe: 'repousser',
      duelliste: true
    },
    tenirADistance: {
      appliquer: appliquerTenirADistance,
      verbe: 'tenir \xE0 distance',
      duelliste: true
    }
  };

  //!cof-appliquer-manoeuvre id1 id2 effet attrId
  //attrId est utilis\xE9 pour limiter le nombre d'utilisations
  function appliquerManoeuvre(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 5) {
      error("cof-appliquer-manoeuvre attend 4 arguments", msg.content);
      return;
    }
    if (!_.has(listeManoeuvres, cmd[3])) {
      error("Manoeuvre " + cmd[3] + " inconnue.", cmd);
      return;
    }
    var limiteAttr = getObj('attribute', cmd[4]);
    if (limiteAttr === undefined) {
      sendPlayer(msg, "La manoeuvre a d\xE9j\xE0 \xE9t\xE9 choisie");
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-appliquer-maneuvre n'est pas un token valide", cmd);
      return;
    }
    var cible = persoOfId(cmd[2], cmd[2]);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-appliquer-manoeuvre n'est pas un token valide", cmd);
      return;
    }
    var effet = listeManoeuvres[cmd[3]];
    var evt = {
      type: 'Application de manoeuvre',
      deletedAttributes: [limiteAttr]
    };
    limiteAttr.remove();
    effet.appliquer(attaquant, cible, false, evt, true);
    addEvent(evt);
  }

  //!cof-manoeuvre id1 id2 effet
  function manoeuvreRisquee(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    options.pasDeDmg = true;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 4) {
      error("cof-manoeuvre attend 3 arguments", msg.content);
      return;
    }
    if (!_.has(listeManoeuvres, cmd[3])) {
      sendPlayer(msg, "Manoeuvre " + cmd[3] + " inconnue.");
      return;
    }
    var effet = listeManoeuvres[cmd[3]];
    var attaquant = persoOfId(cmd[1], cmd[1]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-maneuvre n'est pas un token valide", cmd);
      return;
    }
    attaquant.tokName = attaquant.token.get('name');
    var cible = persoOfId(cmd[2], cmd[2]);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-manoeuvre n'est pas un token valide", cmd);
      return;
    }
    cible.tokName = cible.token.get('name');
    var evt = {
      type: 'manoeuvre'
    };
    if (effet.penalitePlusPetit) {
      var tailleAttaquant = taillePersonnage(attaquant);
      var tailleCible = taillePersonnage(cible);
      if (tailleAttaquant && tailleCible && tailleAttaquant < tailleCible) {
        var penalite = 5 * (tailleAttaquant - tailleCible);
        options.bonusAttaqueAttaquant = [{
          val: penalite,
          explication: attaquant.tokName + " est plus petit que " + cible.tokName + " => " + penalite + " Att"
        }];
      }
    }
    var playerId = getPlayerIdFromMsg(msg);
    var manoeuvreDuelliste = effet.duelliste && predicateAsBool(attaquant, 'manoeuvreDuelliste');
    attaqueContactOpposee(playerId, attaquant, cible, evt, options,
      function(res, display, explications) {
        var dmSupp;
        if (res.succes) {
          addLineToFramedDisplay(display, attaquant.tokName + " r\xE9ussi \xE0 " + effet.verbe + " " + cible.tokName);
          dmSupp = effet.appliquer(attaquant, cible, res.critique, evt);
          if (manoeuvreDuelliste && !dmSupp) {
            var pageId = cible.token.get('pageid');
            var defense = defenseOfPerso(attaquant, cible, pageId, evt, options);
            dmSupp = res.rollAttaquant >= defense + 10;
          }
        } else {
          addLineToFramedDisplay(display, attaquant.tokName + " ne r\xE9ussi pas \xE0 " + effet.verbe + " " + cible.tokName);
          //Envoyer \xE0 la cible la possibilit\xE9 d'appliquer un effet de son choix
        }
        explications.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
        if (dmSupp) {
          var actionGratuite = "!cof-attack " + attaquant.token.id + " " + cible.token.id + " -1 --auto";
          addLineToFramedDisplay(display, attaquant.tokName + " fait en plus des d\xE9g\xE2ts \xE0 " + cible.tokName + boutonSimple(actionGratuite, "lancer une attaque pour d\xE9terminer le montant"), 80);
        }
        sendChat("", endFramedDisplay(display));
        addEvent(evt);
        /*if (dmSupp) {
           turnAction(attaquant, playerId);
        }*/
        if (!res.succes && !manoeuvreDuelliste) {
          var charCible = getObj('character', cible.charId);
          if (charCible === undefined) {
            error("Cible sans personnage associ\xE9", cible);
            return;
          }
          var titre = "Choisir un effet contre " + attaquant.tokName;
          //On cr\xE9e un display sans le header
          display = startFramedDisplay(undefined, titre, cible, {
            retarde: true
          });
          //Attribut pour empecher plusieurs utilisations
          var attrLimit = createObj('attribute', {
            _characterid: cible.charId,
            name: 'limiteApplicationManoeuvre',
            current: '1'
          });
          for (var man in listeManoeuvres) {
            var appliquerManoeuvre = '!cof-appliquer-manoeuvre ' + cible.token.id + ' ' + attaquant.token.id + ' ' + man + ' ' + attrLimit.id;
            var ligneManoeuvre = boutonSimple(appliquerManoeuvre, man);
            addLineToFramedDisplay(display, ligneManoeuvre, 90);
          }
          // on envoie la liste aux joueurs qui g\xE8rent le voleur
          let playerIds = getPlayerIds(cible);
          playerIds.forEach(function(playerid) {
            addFramedHeader(display, playerid, true);
            sendChat('', endFramedDisplay(display));
          });
          if (playerIds.length === 0) {
            addFramedHeader(display, undefined, 'gm');
            sendChat('', endFramedDisplay(display));
          }
        }
      });
  }

  //!cof-expert-combat-bousculer
  function expertDuCombatBousculer(msg) {
    var cmd = msg.content.split(' ');
    if (!stateCOF.combat) {
      error("On ne peut utiliser !cof-expert-combat-bousculer qu'en combat", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("Il manque des arguments \xE0 !cof-expert-combat-bousculer", msg.content);
      return;
    }
    var expert = persoOfId(cmd[1], cmd[1]);
    if (expert === undefined) {
      error("Le premier argument de !cof-expert-combat-bousculer n'est pas un token valide", cmd);
      return;
    }
    expert.tokName = expert.token.get('name');
    var cible = persoOfId(cmd[2], cmd[2]);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-expert-combat-bousculer n'est pas un token valide", cmd);
      return;
    }
    if (!predicateAsBool(expert, 'expertDuCombat')) {
      error(expert.tokName + " n'est pas un expert du combat !", cmd);
      return;
    }
    cible.tokName = cible.token.get('name');
    var pageId = expert.token.get('pageid');
    if (distanceCombat(expert.token, cible.token, pageId)) {
      sendPerso(expert, "est trop loin de " + cible.tokName + " pour le bousculer.");
      return;
    }
    var evt = {
      type: 'Bousculer'
    };
    addEvent(evt);
    if (!persoUtiliseDeExpertDuCombat(expert, evt)) return;
    var deExpertise = rollDePlus(6);
    var playerId = getPlayerIdFromMsg(msg);
    var explications = [];
    testOppose("bouculer", expert, "FOR", {
      bonus: deExpertise.val
    }, cible, "FOR", {}, explications, evt, function(resultat, crit, rt1, rt2) {
      var display = startFramedDisplay(playerId, "Bousculer", expert, {
        perso2: cible
      });
      explications.push("D\xE9 d'expertise : " + deExpertise.roll);
      if (resultat === 1) {
        addLineToFramedDisplay(display, cible.tokName + " est repouss\xE9 de " +
          Math.ceil(deExpertise.val / 2) + " m\xE8tre" + (deExpertise.val > 1 ? "s" : "") + "<br/>S'il est accul\xE9 : " +
          boutonSimple("!cof-dmg " + deExpertise.val + " --target " + cmd[2], "Appliquer " + deExpertise.val + " DM"));
        setState(cible, "renverse", "true", evt);
      } else {
        addLineToFramedDisplay(display, cible.tokName + " n'est pas renvers\xE9");
      }
      explications.forEach(function(expl) {
        addLineToFramedDisplay(display, expl, 80);
      });
      sendChat("", endFramedDisplay(display));
    });
  }

  function sendCommands(from, commands) {
    if (commands.length === 0) return;
    var c = commands.shift();
    if (c.startsWith('!')) {
      _.delay(function() {
        sendChat(from, c);
        sendCommands(from, commands);
      }, 10);
    } else error("multi-commande invalide", c);
  }

  //!cof-multi-command !cmd1 ... --cof-multi-command !cmd2 .. --cof-multi-command !cmd3...
  function multiCommand(msg) {
    var posFirstCommand = msg.content.indexOf('!', 2);
    var commands = msg.content.substr(posFirstCommand).split(' --cof-multi-command ');
    sendCommands(msg.who, commands);
    /* commands.forEach(function(c) {
       if (c.startsWith('!')) sendChat(msg.who, c);
       else error("multi-commande invalide", c);
     });*/
  }

  //Cr\xE9e un nouveau personnage (de type PNJ par d\xE9faut)
  //spec contient les charact\xE9ristiques, attributs et abilities
  //  - attributesFiche contient les attributs d\xE9finis dans la fiche
  //      nom_attribut: valeur
  //  - pv (permet d'\xEAtre ind\xE9pendant de PJ ou PNJ)
  //  - attaques, liste d'attaques, chacune avec (nom, atk, dmnbde, dmde, dm,...)
  //  - attributes autres attributs (name, current, max)
  //  - abilities (name, action), toujours rajout\xE9es \xE0 la liste d'actions
  //  - actions (titre, code), ajout\xE9es aux listes d'actions
  function createCharacter(nom, playerId, avatar, token, spec) {
    let res = createObj('character', {
      name: nom,
      avatar: avatar,
      controlledby: playerId
    });
    if (!res) return;
    let charId = res.id;
    if (token) {
      token.set('represents', charId);
    }
    let attrs = findObjs({
      _type: 'attribute',
      _characterid: charId,
    });
    let attrVersion =
      attrs.find(function(a) {
        return a.get('name').toLowerCase() == 'version';
      });
    if (!attrVersion) {
      createObj('attribute', {
        _characterid: charId,
        name: 'version',
        current: versionFiche
      });
    }
    let pnj = true;
    if (spec.attributesFiche) {
      if (spec.attributesFiche.type_personnage == 'PJ') pnj = false;
      for (var attrName in spec.attributesFiche) {
        /*jshint loopfunc: true */
        let attr =
          attrs.filter(function(a) {
            return a.get('name') == attrName;
          });
        if (attr.length === 0) {
          createObj('attribute', {
            _characterid: charId,
            name: attrName,
            current: spec.attributesFiche[attrName]
          });
        } else {
          attr[0].set('current', spec.attributesFiche[attrName]);
        }
      }
    } //end attributesFiche
    if (pnj) {
      createObj('attribute', {
        _characterid: charId,
        name: 'tab',
        current: 'carac. pnj'
      });
    }
    if (spec.pv) {
      var pvAttr = attrs.filter(function(a) {
        return a.get('name').toUpperCase() == 'PV';
      });
      if (pvAttr.length === 0) {
        pvAttr = createObj('attribute', {
          _characterid: charId,
          name: 'PV',
          current: spec.pv,
          max: spec.pv
        });
      } else {
        pvAttr = pvAttr[0];
        pvAttr.set('current', spec.pv);
        pvAttr.set('max', spec.pv);
      }
      if (pnj) {
        pvAttr = attrs.filter(function(a) {
          return a.get('name').toLowerCase() == 'pnj_pv';
        });
        if (pvAttr.length === 0) {
          pvAttr = createObj('attribute', {
            _characterid: charId,
            name: 'pnj_pv',
            current: spec.pv,
            max: spec.pv
          });
        } else {
          pvAttr = pvAttr[0];
          pvAttr.set('current', spec.pv);
          pvAttr.set('max', spec.pv);
        }
      }
      if (token) {
        token.set('bar1_link', pvAttr.id);
        token.set('bar1_value', spec.pv);
        token.set('bar1_max', spec.pv);
      }
    }
    if (spec.attaques) {
      let maxAttackLabel = 0;
      let prefix_attaques = 'repeating_armes_';
      if (pnj) prefix_attaques = 'repeating_pnjatk_';
      spec.attaques.forEach(function(att) {
        let id = generateRowID();
        let pref = prefix_attaques + id + '_arme';
        _.forEach(att, function(value, field) {
          createObj('attribute', {
            _characterid: charId,
            name: pref + field,
            current: value
          });
        });
        maxAttackLabel++;
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'label',
          current: maxAttackLabel
        });
      });
      createObj('attribute', {
        _characterid: charId,
        name: 'max_attack_label',
        current: maxAttackLabel
      });
    }
    if (spec.attributes) {
      spec.attributes.forEach(function(a) {
        a._characterid = charId;
        createObj('attribute', a);
      });
    }
    if (spec.abilities) {
      spec.abilities.forEach(function(a) {
        a._characterid = charId;
        a.istokenaction = true;
        createObj('ability', a);
      });
    }
    if (spec.actions) {
      var rang = 0;
      spec.actions.forEach(function(a) {
        rang++;
        var pref = 'repeating_actions_' + generateRowID() + '_';
        createObj('attribute', {
          name: pref + 'actionoptflag',
          current: 'off',
          characterid: charId,
        });
        createObj('attribute', {
          name: pref + 'actionrang',
          current: rang,
          characterid: charId,
        });
        createObj('attribute', {
          name: pref + 'actiontitre',
          current: a.titre,
          characterid: charId,
        });
        if (a.code) {
          createObj('attribute', {
            name: pref + 'actioncode',
            current: a.code,
            characterid: charId,
          });
        }
      });
      if (rang > 0) {
        createObj('attribute', {
          name: 'maxrangaction',
          current: rang,
          characterid: charId
        });
      }
    }
    createObj('attribute', {
      name: 'montrerarmeenmain',
      current: 0,
      characterid: charId
    });
    if (token) setDefaultTokenForCharacter(res, token);
    return res;
  }

  const predateurs = {
    loup: {
      nom: 'Loup',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59094468/bX_aTjrVAbIRHjpRn-HwdQ/max.jpg?1532611383",
      token: "https://s3.amazonaws.com/files.d20.io/images/59489165/3R9Ob68sTiqvNeEhwzwWcg/thumb.png?1533047142",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 1,
        force: 12,
        pnj_for: 1,
        dexterite: 12,
        pnj_dex: 1,
        constitution: 12,
        pnj_con: 1,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 3,
        pnj_def: 14,
        pnj_init: 12,
        race: 'loup',
        taille: 'moyen'
      },
      pv: 9,
      attaques: [{
        nom: 'Morsure',
        atk: 2,
        dmnbde: 1,
        dmde: 6,
        dm: 1,
      }],
      attributes: [],
      abilities: []
    },
    loupAlpha: {
      nom: 'Loup alpha',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59094818/J0yWdxryZFKakJtNGJNNvw/max.jpg?1532612061",
      token: "https://s3.amazonaws.com/files.d20.io/images/60183959/QAMH6WtyoK78aa4zX_mR_Q/thumb.png?1533898482",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 2,
        force: 16,
        pnj_for: 3,
        dexterite: 12,
        pnj_dex: 1,
        constitution: 16,
        pnj_con: 3,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 4,
        pnj_def: 15,
        INIT_DIV: 5,
        pnj_init: 17,
        race: 'loup',
        taille: 'moyen'
      },
      pv: 15,
      attaques: [{
        nom: 'Morsure',
        atk: 4,
        dmnbde: 1,
        dmde: 6,
        dm: 3,
      }],
      attributes: [{
        name: 'discr\xE9tion',
        current: 5
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]] --target @{target|token_id}'
      }],
      actions: [{
        titre: 'Attaque en embuscade',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }]
    },
    worg: {
      nom: 'Grand loup',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/25294798/4dJ_60uP2mw6UJA2elkoXA/max.jpg?1479223790",
      token: "https://s3.amazonaws.com/files.d20.io/images/60184237/smG5o2-siD2pChhPblO_sQ/thumb.png?1533899118",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 3,
        force: 16,
        pnj_for: 3,
        dexterite: 12,
        pnj_dex: 1,
        constitution: 16,
        pnj_con: 3,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 4,
        pnj_int: -3,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 6,
        pnj_def: 17,
        INIT_DIV: 5,
        pnj_init: 17,
        race: 'loup',
        taille: 'moyen'
      },
      pv: 35,
      attaques: [{
        nom: 'Morsure',
        atk: 6,
        dmnbde: 1,
        dmde: 6,
        dm: 5,
      }],
      attributes: [{
        name: 'discr\xE9tion',
        current: 5
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]'
      }],
      actions: [{
        titre: 'Attaque en embuscade',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }]
    },
    lion: {
      nom: 'Lion',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486104/SngxPIGXDJKdCqsbrXxRYQ/max.jpg?1533041390",
      token: "https://s3.amazonaws.com/files.d20.io/images/60184437/df1MT2T6lrfo7st02Htxeg/thumb.png?1533899407",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 4,
        force: 20,
        pnj_for: 5,
        dexterite: 18,
        pnj_dex: 4,
        dex_sup: '@{jetsup}',
        pnj_dex_sup: 'on',
        constitution: 20,
        pnj_con: 5,
        intelligence: 4,
        pnj_int: -3,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -3,
        DEFDIV: 4,
        pnj_def: 18,
        INIT_DIV: 5,
        pnj_init: 23,
        race: 'lion',
        taille: 'grand'
      },
      pv: 30,
      attaques: [{
        nom: 'Morsure',
        atk: 7,
        dmnbde: 2,
        dmde: 6,
        dm: 5,
      }],
      attributes: [{
        name: 'discr\xE9tion',
        current: 5
      }, {
        name: 'predicats_script',
        current: 'devorer',
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]'
      }],
      actions: [{
        titre: 'Attaque en embuscade',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }, {
        titre: 'D\xE9vorer',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1'
      }]
    },
    grandLion: {
      nom: 'Grand lion',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486144/8wHs_5WfEIeL_7dKbALHHA/max.jpg?1533041459",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186141/mUZzndi9_sYIzdVVNNka_w/thumb.png?1533903070",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 5,
        force: 22,
        pnj_for: 6,
        dexterite: 18,
        pnj_dex: 3,
        dex_sup: '@{jetsup}',
        pnj_dex_sup: 'on',
        constitution: 20,
        pnj_con: 5,
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 14,
        pnj_cha: 2,
        DEFDIV: 6,
        pnj_def: 20,
        pnj_init: 18,
        race: 'lion',
        taille: 'grand'
      },
      pv: 50,
      attaques: [{
        nom: 'Morsure',
        atk: 9,
        dmnbde: 2,
        dmde: 6,
        dm: 7,
      }],
      attributes: [{
        name: 'discr\xE9tion',
        current: 5
      }, {
        name: 'predicats_script',
        current: 'devorer',
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]'
      }],
      actions: [{
        titre: 'Attaque en embuscade',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }, {
        titre: 'D\xE9vorer',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1'
      }]
    },
    oursPolaire: {
      nom: 'Ours polaire',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486216/UssilagWK_2dfVGuPABBpA/max.png?1533041591",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186288/B1uAii9G01GcPfQFNozIbw/thumb.png?1533903333",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 6,
        force: 26,
        pnj_for: 8,
        for_sup: '@{jetsup}',
        pnj_for_sup: 'on',
        dexterite: 11,
        pnj_dex: 0,
        constitution: 26,
        pnj_con: 8,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 10,
        pnj_def: 20,
        pnj_init: 11,
        race: 'ours',
        taille: 'grand'
      },
      pv: 70,
      attaques: [{
        nom: 'Morsure',
        atk: 12,
        dmnbde: 2,
        dmde: 8,
        dm: 7,
      }],
      attributes: [{
        name: 'predicats_script',
        curreent: 'peutEnrager',
      }],
      actions: [{
        titre: 'Charge',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --m2d20 --pietine}'
      }, ]
    },
    tigreDentsDeSabre: {
      nom: 'Tigre \xE0 dents de sabre',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486272/f5lUcN3Y9H0thmJPrqa6FQ/max.png?1533041702",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186469/ShcrgpvgXKiQsLVOyg4SZQ/thumb.png?1533903741",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 7,
        force: 26,
        pnj_for: 8,
        for_sup: '@{jetsup}',
        pnj_for_sup: 'on',
        dexterite: 18,
        pnj_dex: 4,
        dex_sup: '@{jetsup}',
        pnj_dex_sup: 'on',
        constitution: 26,
        pnj_con: 8,
        intelligence: 2,
        pnj_int: -4,
        sagesse: 12,
        pnj_sag: 1,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 2,
        pnj_cha: -4,
        DEFDIV: 8,
        pnj_def: 22,
        pnj_init: 18,
        race: 'tigre',
        taille: 'grand'
      },
      pv: 90,
      attaques: [{
        nom: 'Morsure',
        atk: 14,
        dmnbde: 2,
        dmde: 6,
        dm: 12,
      }],
      attributes: [{
        name: 'discr\xE9tion',
        current: 5
      }, {
        name: 'predicats_script',
        current: 'devorer',
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]',
      }],
      actions: [{
        titre: 'Attaque en embuscade',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }, {
        titre: 'D\xE9vorer',
        ccode: '!cof-attack @{selected|token_id} @{target|token_id} 1'
      }]
    },
    oursPrehistorique: {
      nom: 'Ours pr\xE9historique',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486323/V6RVSlBbeRJi_aIaIuGGBw/max.png?1533041814",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186633/lNHXvCOsvfPMZDQnqJKQVw/thumb.png?1533904189",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 8,
        force: 32,
        pnj_for: 11,
        dexterite: 10,
        pnj_dex: 0,
        constitution: 32,
        pnj_con: 11,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 12,
        pnj_def: 22,
        pnj_init: 10,
        RDS: 2,
        race: 'ours',
        taille: '\xE9norme'
      },
      pv: 110,
      attaques: [{
        nom: 'Griffes',
        atk: 17,
        dmnbde: 3,
        dmde: 6,
        dm: 13,
      }],
      attributes: [{
        name: 'fauchage',
        current: 'true'
      }],
      actions: [{
        titre: 'Charge',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --m2d20 --pietine}'
      }, ]
    }
  };

  function conjurationPredateur(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Pas de commande", msg.content);
      return;
    }
    let renforce = 0;
    if (cmd.length > 1) {
      renforce = parseInt(cmd[1]);
      if (isNaN(renforce)) {
        error("Il faut un nombre comme premier argument de !cof-conjuration-de-predateur");
        renforce = 0;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        error("pas de lanceur pour la conjuration de pr\xE9dateurs", msg);
        return;
      }
      let evt = {
        type: 'conjuration de pr\xE9dateurs'
      };
      initiative(selected, evt);
      iterSelected(selected, function(invocateur) {
        if (limiteRessources(invocateur, options, 'invocationPredateur', 'lancer une invocation de pr\xE9dateur', evt)) return;
        let pageId = invocateur.token.get('pageid');
        let niveau = ficheAttributeAsInt(invocateur, 'niveau', 1);
        if (!renforce) {
          renforce = predicateAsInt(invocateur, 'voieDeLaConjuration', 0);
          if (renforce == 1) renforce = 0;
        }
        niveau += renforce;
        let predateur;
        if (niveau < 5) predateur = predateurs.loup;
        else if (niveau < 9) predateur = predateurs.loupAlpha;
        else if (niveau < 12) predateur = predateurs.worg;
        else if (niveau < 15) predateur = predateurs.lion;
        else if (niveau < 18) predateur = predateurs.grandLion;
        else if (niveau < 21) predateur = predateurs.oursPolaire;
        else if (niveau < 23) predateur = predateurs.tigreDentsDeSabre;
        else predateur = predateurs.oursPrehistorique;
        let nomPredateur =
          predateur.nom + ' de ' + invocateur.token.get('name');
        let token = createObj('graphic', {
          name: nomPredateur,
          subtype: 'token',
          pageid: pageId,
          imgsrc: predateur.token,
          left: invocateur.token.get('left'),
          top: invocateur.token.get('top'),
          width: 70,
          height: 70,
          layer: 'objects',
          showname: 'true',
          showplayers_bar1: 'true',
          light_hassight: 'true',
          light_angle: 0, //Pour que le joueur ne voit rien par ses yeux
          has_bright_light_vision: true,
          has_limit_field_of_vision: true,
        });
        toFront(token);
        let charPredateur =
          createCharacter(nomPredateur, playerId, predateur.avatar, token, predateur);
        //Tous les pr\xE9dateurs sont des quadrup\xE8des
        let persoPredateur = {
          token: token,
          charId: charPredateur.id
        };
        setPredicate(persoPredateur, 'quadrupede', evt);
        //Attribut de predateur conjur\xE9 pour la disparition automatique
        createObj('attribute', {
          name: 'predateurConjure',
          _characterid: charPredateur.id,
          current: 5 + modCarac(invocateur, 'charisme'),
          max: getInit()
        });
        evt.characters = [charPredateur];
        evt.tokens = [token];
        initiative([{
          _id: token.id
        }], evt);
        // Ajout du Pr\xE9dateur aux alli\xE9s de l'invocateur
        let alliesInvocateur = alliesParPerso[invocateur.charId] || new Set();
        alliesInvocateur.add(charPredateur.id);
        alliesParPerso[invocateur.charId] = alliesInvocateur;
      }); //end iterSelected
      addEvent(evt);
    }); //end getSelected
  }

  //!cof-sphere-de-feu
  function sphereDeFeu(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Pas de commande", msg.content);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        error("pas de lanceur pour la sphere de feu", msg);
        return;
      }
      let evt = {
        type: "invocation d'une sph\xE8re de feu",
      };
      initiative(selected, evt);
      iterSelected(selected, function(invocateur) {
        if (limiteRessources(invocateur, options, 'sphereDeFeu', 'lancer un sort de sph\xE8re de feu', evt)) return;
        let character = getObj('character', invocateur.charId);
        if (character === undefined) {
          error("Impossible de trouver le personnage de " + invocateur.token.get('name'), invocateur);
          return;
        }
        let pageId = invocateur.token.get('pageid');
        let niveau = ficheAttributeAsInt(invocateur, 'niveau', 1);
        let sphere = {
          nom: 'Sph\xE8re de feu',
          avatar: "https://s3.amazonaws.com/files.d20.io/images/260057530/nL8O6US3f1BpeTJkodWNCg/max.png?16394116785",
          token: "https://s3.amazonaws.com/files.d20.io/images/260057530/nL8O6US3f1BpeTJkodWNCg/thumb.png?16394116785",
          attributesFiche: {
            type_personnage: 'PNJ',
            niveau: 1,
          },
          pv: 1,
          attaques: [{
            nom: 'Br\xFBlure',
            atk: 0,
            dmnbde: 3,
            dmde: 6,
            dm: 0,
            typedegats: 'feu',
            modificateurs: 'auto',
            options: '--saveDM DEX ' + (10 + modCarac(invocateur, 'intelligence')),
          }],
          attributes: [{
            name: 'predicats_script',
            current: 'nonVivant immunite_feu sansEsprit',
          }, {
            name: 'initiativeDeriveeDe',
            current: character.get('name'),
          }, {
            name: 'predateurConjure', //Pas exactement \xE7a, mais \xE7a fait ce qu'il faut
            current: niveau,
            max: getInit()
          }],
        };
        let nomSphere =
          sphere.nom + ' de ' + invocateur.token.get('name');
        let token = createObj('graphic', {
          name: nomSphere,
          subtype: 'token',
          pageid: pageId,
          imgsrc: sphere.token,
          left: invocateur.token.get('left'),
          top: invocateur.token.get('top'),
          width: 35,
          height: 35,
          layer: 'objects',
          showname: 'true',
          showplayers_bar1: 'true',
          light_hassight: 'true',
          light_angle: 0, //Pour que le joueur ne voit rien par ses yeux
          has_bright_light_vision: true,
          has_limit_field_of_vision: true,
        });
        if (token === undefined) {
          error("Impossible de cr\xE9er le token de la sph\xE8re de feu ", sphere);
          return;
        }
        toFront(token);
        let charSphere =
          createCharacter(nomSphere, playerId, sphere.avatar, token, sphere);
        evt.characters = [charSphere];
        evt.tokens = [token];
        initiative([{
          _id: token.id
        }], evt);
        // Ajout du Pr\xE9dateur aux alli\xE9s de l'invocateur
        let alliesInvocateur = alliesParPerso[invocateur.charId] || new Set();
        alliesInvocateur.add(charSphere.id);
        alliesParPerso[invocateur.charId] = alliesInvocateur;
      }); //end iterSelected
      addEvent(evt);
    }); //end getSelected
  }

  //!cof-conjuration-armee [d\xE9 de DM] --limiteParJour...
  function conjurationArmee(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Il faut s\xE9lectionner le lanceur de la conjuration d'arm\xE9\xE9", playerId);
        return;
      }
      iterSelected(selected, function(invocateur) {
        var pageId = invocateur.token.get('pageid');
        var niveau = ficheAttributeAsInt(invocateur, 'niveau', 1);
        var evt = {
          type: "Conjuration d'arm\xE9e"
        };
        if (limiteRessources(invocateur, options, 'conjurationArmee', "conjurer une arm\xE9e", evt)) {
          addEvent(evt);
          return;
        }
        var deDM;
        var nbDeDM;
        if (cmd.length > 1) {
          var argDe = cmd[1].split(/d/i);
          if (argDe.length == 2) {
            nbDeDM = parseInt(argDe[0]);
            if (isNaN(nbDeDM) || nbDeDM < 1) nbDeDM = undefined;
            else {
              deDM = parseInt(argDe[1]);
              if (isNaN(deDM) || deDM < 1) deDM = undefined;
            }
          }
        }
        if (deDM === undefined) {
          var rang = predicateAsInt(invocateur, 'voieDeLaConjuration', 3);
          if (rang <= 3) {
            deDM = 6;
            nbDeDM = 1;
          } else if (rang == 4) {
            deDM = 10;
            nbDeDM = 1;
          } else {
            deDM = 6;
            nbDeDM = 2;
          }
        }
        var nomArmee = "Arm\xE9e de " + invocateur.token.get('name');
        var token = createObj('graphic', {
          name: nomArmee,
          subtype: 'token',
          pageid: pageId,
          imgsrc: 'https://s3.amazonaws.com/files.d20.io/images/73283129/-jrKAyQQ1P7zpD09xeTbXw/thumb.png?1549546953',
          left: invocateur.token.get('left'),
          top: invocateur.token.get('top'),
          width: 70,
          height: 70,
          layer: 'objects',
          showname: 'true',
          showplayers_bar1: 'true',
          light_hassight: 'true',
          light_angle: 0, //Pour que le joueur ne voit rien par ses yeux
          has_bright_light_vision: true,
          has_limit_field_of_vision: true,
          aura1_radius: 10,
          aura1_color: "#d56eef",
          aura1_square: true
        });
        toFront(token);
        var avatar = "https://s3.amazonaws.com/files.d20.io/images/73283254/r6sbxbP1QKKtqXyYq-MlLA/max.png?1549547198";
        let attaque = {
          nom: 'Attaque',
          dmnbde: nbDeDM,
          dmde: deDM,
          modificateurs: 'auto',
        };
        let attributes = [{
          name: 'armeeConjuree',
          current: invocateur.charId
        }];
        let charArmee =
          createCharacter(nomArmee, playerId, avatar, token, {
            pv: niveau * 10,
            attaques: [attaque],
            attributes: attributes
          });
        evt.characters = [charArmee];
        evt.tokens = [token];
        if (stateCOF.combat) {
          initiative([{
            _id: token.id
          }], evt);
        }
      });
    });
  }

  function tenebres(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("!cof-tenebres mal form\xE9, il faut un token comme premier argument", msg.content);
      return;
    }
    var necromant = persoOfId(cmd[1], cmd[1], options.pageId);
    if (necromant === undefined) {
      error("Le premier argument de !cof-tenebres n'est pas un token valide", cmd);
      return;
    }
    var targetToken = persoOfId(cmd[2], cmd[2], options.pageId);
    if (targetToken === undefined) {
      error("Le second argument de !cof-tenebres n'est pas un token valide", cmd);
      return;
    }
    options.lanceur = necromant;
    var playerId = getPlayerIdFromMsg(msg);
    if (options.tempeteDeMana) {
      if (options.tempeteDeMana.cout === 0) {
        //On demande de pr\xE9ciser les options
        var optMana = {
          mana: options.mana,
          portee: true,
          duree: true,
          intense: 0,
          rang: 1
        };
        setTempeteDeMana(playerId, options.lanceur, msg.content, optMana);
        return;
      } else {
        if (options.tempeteDeMana.cout > 1) {
          sendPlayerAndGM(msg, playerId, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
        }
      }
    }
    var portee = options.portee || 20;
    if (options.puissantPortee || options.tempeteDeManaPortee) {
      portee = portee * 2;
    }
    var rayon = options.rayon || 5;
    if (options.puissant || options.tempeteDeManaIntense) rayon = Math.floor(Math.sqrt(2) * rayon);
    if (distanceCombat(necromant.token, targetToken.token, options.pageId, {
        strict2: true
      }) > portee) {
      sendPlayer(msg, "Le point vis\xE9 est trop loin (port\xE9e " + portee + ")", playerId);
      return;
    }
    var duree = 5 + modCarac(necromant, 'intelligence');
    if (options.puissantDuree || options.tempeteDeManaDuree) {
      duree = duree * 2;
    }
    var evt = {
      type: 'tenebres'
    };
    addEvent(evt);
    if (limiteRessources(necromant, options, 'tenebres', 'lancer un sort de t\xE9n\xE8bres', evt)) return;
    if (!stateCOF.combat) {
      initPerso(necromant, evt);
    }
    var tokenTenebres = "T\xE9n\xE8bres de " + necromant.token.get('name');
    var token = createObj('graphic', {
      name: tokenTenebres,
      showname: true,
      subtype: 'token',
      pageid: options.pageId,
      imgsrc: 'https://s3.amazonaws.com/files.d20.io/images/192072874/eJXFx20fD931DuBDvzAnQQ/thumb.png?1610469273',
      left: targetToken.token.get("left"),
      top: targetToken.token.get("top"),
      width: 70,
      height: 70,
      layer: 'objects',
      aura1_radius: 0,
      aura1_color: "#c1c114",
      aura1_square: true,
      aura2_radius: scaleDistance(necromant, rayon),
      aura2_color: "#000000",
      showplayers_aura2: true
    });
    evt.tokens = [token];
    if (stateCOF.options.affichage.val.duree_effets.val) {
      sendPerso(necromant, "lance un sort de t\xE9n\xE8bres pour " + duree + " tours");
    }
    // Calcul des cibles \xE0 aveugler
    var cibles = [];
    var allToksDisque =
      findObjs({
        _type: "graphic",
        _pageid: options.pageId,
        _subtype: "token",
        layer: "objects"
      });
    allToksDisque.forEach(function(obj) {
      if (obj.get('bar1_max') == 0) return; // jshint ignore:line
      var objCharId = obj.get('represents');
      if (objCharId === '') return;
      var cible = {
        token: obj,
        charId: objCharId
      };
      if (getState(cible, 'mort')) return; //pas de d\xE9g\xE2ts aux morts
      var distanceCentre =
        distanceCombat(targetToken.token, obj, options.pageId, {
          strict1: true
        });
      if (distanceCentre > rayon) return;
      cibles.push(cible);
    });
    var effetAveugle = {
      effet: 'aveugleTemp',
      duree: duree
    };
    cibles.forEach(function(perso) {
      setEffetTemporaire(perso, effetAveugle, duree, evt, {});
    });
    var effetTenebres = {
      effet: 'tenebres',
      duree: duree,
      valeur: token.id,
      pasDeMessageDActivation: true,
      attaquant: necromant
    };
    setEffetTemporaire(necromant, effetTenebres, duree, evt, options);
    if (targetToken.token.get('bar1_max') == 0) { // jshint ignore:line
      //C'est juste un token utilis\xE9 pour d\xE9finir le disque
      targetToken.token.remove(); //On l'enl\xE8ve, normalement plus besoin
    }
  }

  var demonInvoque = {
    nom: 'D\xE9mon',
    avatar: "https://s3.amazonaws.com/files.d20.io/images/183633585/DWpHYp4SLPCDCMHdmTyKOw/thumb.png?1607339938",
    token: "https://s3.amazonaws.com/files.d20.io/images/183633585/DWpHYp4SLPCDCMHdmTyKOw/thumb.png?1607339938",
    attributesFiche: {
      type_personnage: 'PNJ',
      niveau: 5,
      force: 20,
      pnj_for: 5,
      for_sup: '@{jetsup}',
      pnj_for_sup: 'on',
      dexterite: 14,
      pnj_dex: 2,
      constitution: 18,
      pnj_con: 4,
      con_sup: '@{jetsup}',
      pnj_con_sup: 'on',
      intelligence: 14,
      pnj_int: 2,
      sagesse: 14,
      pnj_sag: 2,
      charisme: 10,
      pnj_cha: 0,
      DEFDIV: 3,
      pnj_def: 17,
      pnj_init: 16,
      race: 'd\xE9mon',
      taille: 'moyen'
    },
    attaques: [{
      nom: 'Griffes',
      dmnbde: 1,
      dmde: 8,
      dm: 5,
      modificateurs: 'magique'
    }],
    attributes: [{
      name: 'predicats_script',
      current: 'd\xE9mon'
    }],
    abilities: []
  };

  function invocationDemon(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("!cof-invoquer-demon mal form\xE9, il faut un token comme premier argument", msg.content);
      return;
    }
    var necromant = persoOfId(cmd[1], cmd[1], options.pageId);
    if (necromant === undefined) {
      error("Le premier argument de !cof-invoquer-demon n'est pas un token valie", cmd);
      return;
    }
    options.lanceur = necromant;
    getSelected(msg, function(selected, playerId) {
      var evt = {
        type: 'invocationDemon',
        action: {
          rolls: {}
        }
      };
      addEvent(evt);
      if (limiteRessources(necromant, options, 'invoquerDemon', 'lance une invocation de d\xE9mon', evt)) return;
      var d6 = rollDePlus(6);
      evt.action.rolls.invocationDemonDmg = d6;
      var r = {
        total: d6.val,
        type: 'normal',
        display: d6.roll
      };
      let explications = [];
      necromant.ignoreTouteRD = true;
      dealDamage(necromant, r, [], evt, false, {}, explications,
        function(dmgDisplay, dmg) {
          if (!stateCOF.combat) {
            initPerso(necromant, evt);
          }
          var tokenDemon = "D\xE9mon de " + necromant.token.get('name');
          var token = createObj('graphic', {
            name: tokenDemon,
            showname: 'true',
            subtype: 'token',
            pageid: options.pageId,
            imgsrc: demonInvoque.token,
            left: necromant.token.get('left'),
            top: necromant.token.get('top'),
            width: 70,
            height: 70,
            layer: 'objects',
            showplayers_bar1: 'true',
            light_hassight: 'true',
            light_angle: 0,
            has_bright_light_vision: true,
            has_limit_field_of_vision: true,
          });
          toFront(token);
          let niveau = ficheAttributeAsInt(necromant, "niveau", 1);
          let demon = {...demonInvoque
          };
          demon.pv = niveau * 5;
          demon.attaques[0].atk = niveau;
          let charDemon = createCharacter(tokenDemon, playerId, demonInvoque.avatar, token, demon);
          evt.characters = [charDemon];
          evt.tokens = [token];
          let duree = 5 + modCarac(necromant, 'intelligence');
          //Attribut de d\xE9mon invoqu\xE9 pour la disparition automatique
          createObj('attribute', {
            name: 'demonInvoque',
            _characterid: charDemon.id,
            current: duree,
            max: getInit()
          });
          createObj('attribute', {
            name: 'resistanceA_nonMagique',
            _characterid: charDemon.id,
            current: 'true',
          });
          initiative([{
            _id: token.id
          }], evt);
          // Ajout du D\xE9mon aux alli\xE9s du N\xE9cromant
          var alliesNecromant = alliesParPerso[necromant.charId] || new Set();
          alliesNecromant.add(charDemon.id);
          alliesParPerso[necromant.charId] = alliesNecromant;
          var msg = "invoque un d\xE9mon";
          if (stateCOF.options.affichage.val.duree_effets.val) msg += " pour " + duree + " tours";
          msg += " mais cela lui co\xFBte " + dmgDisplay + " PV";
          sendPerso(necromant, msg);
        });
    }, options);
  }

  var zombieAnime = {
    nom: 'Zombie',
    avatar: "https://s3.amazonaws.com/files.d20.io/images/147503510/RKFKQefVjSiyNPJtvBuGOg/thumb.png?1593643543",
    token: "https://s3.amazonaws.com/files.d20.io/images/147503510/RKFKQefVjSiyNPJtvBuGOg/thumb.png?1593643543",
    attributesFiche: {
      type_personnage: 'PNJ',
      niveau: 1,
      force: 12,
      pnj_for: 1,
      dexterite: 8,
      pnj_dex: -1,
      constitution: 12,
      pnj_con: 1,
      intelligence: 2,
      pnj_int: -4,
      sagesse: 6,
      pnj_sag: -2,
      charisme: 2,
      pnj_cha: -4,
      pnj_def: 10,
      pnj_init: 8,
      race: 'mort-vivant',
      taille: 'moyen'
    },
    attaques: [{
      nom: 'Coup',
      atk: 3,
      dmnbde: 1,
      dmde: 6,
      dm: 1
    }],
    pv: 12,
    attributes: [],
    abilities: []
  };

  function animerMort(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("!cof-animer-mort mal form\xE9, il faut un token comme premier argument", msg.content);
      return;
    }
    const necromant = persoOfId(cmd[1], cmd[1], options.pageId);
    if (necromant === undefined) {
      error("Le premier argument de !cof-animer-mort n'est pas un token valie", cmd);
      return;
    }
    let zombiesControles = attributeAsInt(necromant, 'zombiesControles', 0);
    let rangVoie = predicateAsInt(necromant, 'voieOutreTombe', 1);
    if (zombiesControles >= rangVoie) {
      sendPerso(necromant, "ne peut plus animer de Zombie car il en contr\xF4le d\xE9j\xE0 assez.");
      return;
    }
    options.lanceur = necromant;
    const evt = {
      type: 'animerMort',
      action: {
        rolls: {}
      },
      characters: [],
      tokens: []
    };
    addEvent(evt);
    if (limiteRessources(necromant, options, 'animerMort', "lancer un sort d'Animation des morts", evt)) return;
    if (!stateCOF.combat) {
      initPerso(necromant, evt);
    }
    let nomToken = "Zombie de " + necromant.token.get('name');
    let token = createObj('graphic', {
      name: nomToken,
      showname: 'true',
      subtype: 'token',
      pageid: options.pageId,
      imgsrc: zombieAnime.token,
      left: necromant.token.get('left'),
      top: necromant.token.get('top'),
      width: 70,
      height: 70,
      layer: 'objects',
      showplayers_bar1: 'true',
      light_hassight: 'true',
      light_angle: 0,
      has_bright_light_vision: true,
      has_limit_field_of_vision: true,
    });
    toFront(token);
    let zombie = {
      ...zombieAnime
    };
    let playerId = getPlayerIdFromMsg(msg);
    let charZombie = createCharacter(nomToken, playerId, zombieAnime.avatar, token, zombie);
    evt.characters.push(charZombie);
    evt.tokens.push(token);
    // D\xE9gradation du Zombie
    createObj('attribute', {
      name: 'degradationZombie',
      _characterid: charZombie.id,
      current: 71,
      max: getInit()
    });
    // Gestion de la limitation des zombies
    createObj('attribute', {
      name: 'necromant',
      _characterid: charZombie.id,
      current: necromant.token.id,
    });
    initiative([{
      _id: token.id
    }], evt);
    // Ajout du Zombie aux alli\xE9s du N\xE9cromant
    let alliesNecromant = alliesParPerso[necromant.charId] || new Set();
    alliesNecromant.add(charZombie.id);
    alliesParPerso[necromant.charId] = alliesNecromant;
    sendPerso(necromant, "anime un Zombie", options.secret);
    if (options.messages) {
      options.messages.forEach(function(m) {
        sendPerso(necromant, m, options.secret);
      });
    }
    setTokenAttr(necromant, "zombiesControles", zombiesControles + 1, evt);
  }

  //Cr\xE9e les macros utiles au jeu
  var gameMacros = [{
    name: 'Actions',
    action: "!cof-liste-actions",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'Attaque',
    action: "!cof-attack @{selected|token_id} @{target|token_id}",
    visibleto: 'all',
    istokenaction: false
  }, {
    name: 'Consommables',
    action: "!cof-consommables",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'Monter',
    action: "!cof-escalier haut",
    visibleto: 'all',
    istokenaction: true,
    inBar: false
  }, {
    name: 'Descendre',
    action: "!cof-escalier bas",
    visibleto: 'all',
    istokenaction: true,
    inBar: false
  }, {
    name: 'Fin-combat',
    action: "!cof-fin-combat",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Init',
    action: "!cof-init",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Jets',
    action: "!cof-jet",
    visibleto: 'all',
    istokenaction: true,
  }, {
    name: 'Jets-GM',
    action: "!cof-jet --secret",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Nuit',
    action: "!cof-nouveau-jour ?{Repos?|Oui,--repos|Non}",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Repos',
    action: "!cof-recuperation",
    visibleto: 'all',
    istokenaction: true,
    inBar: false
  }, {
    name: 'Statut',
    action: "!cof-statut",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'Surprise',
    action: "!cof-surprise ?{difficult\xE9}",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Torche',
    action: "!cof-torche @{selected|token_id}",
    visibleto: 'all',
    istokenaction: true,
  }, {
    name: '\xC9teindre',
    action: "!cof-eteindre-lumiere ?{Quelle lumi\xE8re?|Tout}",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'devient',
    action: "!cof-set-state ?{\xC9tat|mort|surpris|assomme|renverse|aveugle|affaibli|etourdi|paralyse|ralenti|immobilise|endormi|apeure|invisible|blesse|encombre} true",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'enl\xE8ve',
    action: "!cof-set-state ?{\xC9tat|mort|surpris|assomme|renverse|aveugle|affaibli|etourdi|paralyse|ralenti|immobilise|endormi|apeure|invisible|blesse|encombre} false",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Suivre',
    action: "!cof-suivre @{selected|token_id} @{target|token_id}",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'undo',
    action: "!cof-undo",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, ];

  function setGameMacros(msg) {
    var playerId = msg.playerid;
    var force = playerIsGM(playerId) && msg.content.includes('--force');
    var inBar = [];
    var allMacros = findObjs({
      _type: 'macro'
    });
    gameMacros.forEach(function(m) {
      var prev =
        allMacros.find(function(macro) {
          return macro.get('name') == m.name;
        });
      if (prev === undefined) {
        m.playerid = playerId;
        createObj('macro', m);
        sendPlayer(msg, "Macro " + m.name + " cr\xE9\xE9e.");
        if (m.inBar) inBar.push(m.name);
      } else if (force) {
        prev.set('action', m.action);
        prev.set('visibleto', m.visibleto);
        prev.set('istokenaction', m.istokenaction);
        sendPlayer(msg, "Macro " + m.name + " r\xE9\xE9crite.");
        if (m.inBar) inBar.push(m.name);
      } else {
        sendPlayer(msg, "Macro " + m.name + " d\xE9j\xE0 pr\xE9sente (utiliser --force pour r\xE9\xE9crire).");
      }
    });
    if (inBar.length > 0) {
      sendPlayer(msg, "Macros \xE0 mettre dans la barre d'action du MJ : " + inBar.join(', '));
    }
    stateCOF.gameMacros = gameMacros;
  }

  function ajouteLumiere(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Il faut au moins 2 arguments \xE0 !cof-lumiere", cmd);
      return;
    }
    var cible = persoOfId(cmd[1]);
    if (cible === undefined) {
      error("le premier argument de !cof-lumi\xE8re doit \xEAtre un token", cmd);
      return;
    }
    var radius = parseInt(cmd[2]);
    if (isNaN(radius) || radius <= 0) {
      error("La distance de vue de la lumi\xE8re doit \xEAtre positive", cmd[2]);
      return;
    }
    var dimRadius = '';
    if (cmd.length > 3) {
      dimRadius = parseInt(cmd[3]);
      if (isNaN(dimRadius)) {
        error("La distance de vue de la lumi\xE8re assombrie doit \xEAtre un nombre", cmd[3]);
        dimRadius = '';
      }
    }
    var nomToken = 'lumiere';
    if (cmd.length > 4) {
      nomToken = cmd[4].trim();
      if (nomToken === '') nomToken = 'lumiere';
    }
    var evt = {
      type: 'lumiere',
    };
    addEvent(evt);
    if (limiteRessources(options.lanceur, options, 'lumi\xE8re', "lumi\xE8re", evt)) return;
    ajouteUneLumiere(cible, nomToken, radius, dimRadius, evt);
  }

  // prend en compte l'unit\xE9 de mesure utilis\xE9e sur la page
  function ajouteUneLumiere(perso, nomLumiere, radius, dimRadius, evt) {
    radius = scaleDistance(perso, radius);
    if (dimRadius !== '') dimRadius = scaleDistance(perso, dimRadius);
    var ct = perso.token;
    var pageId = ct.get('pageid');
    var page = getObj('page', pageId);
    var udl = page && page.get('dynamic_lighting_enabled');
    var brightLight = radius;
    if (udl) {
      if (isNaN(brightLight) || brightLight < 0) {
        error("Lumi\xE8re avec un rayon n\xE9gatif", radius);
        return;
      }
    }
    var attrName = 'lumiere';
    if (ct.get('bar1_link') === "") attrName += "_" + ct.get('name');
    if (ct.get('bar1_max')) {
      var lumiereSurPerso;
      //Cas particulier o\xF9 le personnage est un vrai personnage qui ne fait pas de lumi\xE8re
      if (!udl && !ct.get('light_radius')) {
        lumiereSurPerso = true;
        setToken(ct, 'light_radius', radius, evt);
        if (dimRadius !== '') setToken(ct, 'light_dimradius', dimRadius, evt);
        setToken(ct, 'light_otherplayers', true, evt);
      } else if (udl && !ct.get('emits_bright_light') && !ct.get('emits_low_light')) {
        lumiereSurPerso = true;
        if (dimRadius !== '') {
          if (dimRadius < 0) dimRadius = 0;
          if (dimRadius < brightLight) {
            setToken(ct, 'emits_low_light', true, evt);
            setToken(ct, 'low_light_distance', brightLight, evt);
            brightLight = dimRadius;
          }
        }
        if (brightLight > 0) {
          setToken(ct, 'emits_bright_light', true, evt);
          setToken(ct, 'bright_light_distance', brightLight, evt);
        }
      }
      if (lumiereSurPerso) {
        var attr1 = createObj('attribute', {
          characterid: perso.charId,
          name: attrName,
          current: nomLumiere,
          max: 'surToken'
        });
        evt.attributes = [{
          attribute: attr1,
        }];
        return;
      }
    }
    var tokLumiere = createObj('graphic', {
      _pageid: pageId,
      imgsrc: "https://s3.amazonaws.com/files.d20.io/images/3233035/xHOXBXoAgOHCHs8omiFAYg/thumb.png?1393406116",
      left: ct.get('left'),
      top: ct.get('top'),
      width: 70,
      height: 70,
      layer: 'walls',
      name: nomLumiere,
    });
    if (tokLumiere === undefined) {
      error("Probl\xE8me lors de la cr\xE9ation du token de lumi\xE8re", perso);
      return;
    }
    evt.tokens = [tokLumiere];
    if (udl) {
      if (dimRadius !== '') {
        if (dimRadius < 0) dimRadius = 0;
        if (dimRadius < brightLight) {
          setToken(tokLumiere, 'emits_low_light', true, evt);
          setToken(tokLumiere, 'low_light_distance', brightLight, evt);
          brightLight = dimRadius;
        }
      }
      if (brightLight > 0) {
        setToken(tokLumiere, 'emits_bright_light', true, evt);
        setToken(tokLumiere, 'bright_light_distance', brightLight, evt);
      }
    } else {
      setToken(tokLumiere, 'light_radius', radius, evt);
      setToken(tokLumiere, 'light_dimradius', dimRadius, evt);
      setToken(tokLumiere, 'light_otherplayers', true, evt);
    }
    if (ct.get('bar1_max')) { //Lumi\xE8re li\xE9e \xE0 un token
      var attr = createObj('attribute', {
        characterid: perso.charId,
        name: attrName,
        current: nomLumiere,
        max: tokLumiere.id
      });
      evt.attributes = [{
        attribute: attr,
      }];
    } else { //cible temporaire, \xE0 effacer
      ct.remove();
    }
  }

  function eteindreUneLumiere(perso, pageId, al, lumName, evt) {
    if (al === undefined) {
      let attrLumiere = tokenAttribute(perso, 'lumiere');
      al = attrLumiere.find(function(a) {
        return a.get('current') == lumName;
      });
      if (al === undefined) return;
    }
    var lumId = al.get('max');
    if (lumId == 'surToken') {
      //Il faut enlever la lumi\xE8re sur tous les tokens
      var allTokens = [perso.token];
      if (perso.token.get('bar1_value') !== '') {
        allTokens = findObjs({
          type: 'graphic',
          represents: perso.charId
        });
        allTokens = allTokens.filter(function(tok) {
          return tok.get('bar1_value') !== '';
        });
      }
      allTokens.forEach(function(token) {
        setToken(token, 'light_radius', '', evt);
        setToken(token, 'light_dimradius', '', evt);
        setToken(token, 'emits_bright_light', false, evt);
        setToken(token, 'emits_low_light', false, evt);
      });
      al.remove();
      return;
    }
    let lumiere = getObj('graphic', lumId);
    if (lumiere === undefined) {
      var tokensLumiere = findObjs({
        _type: 'graphic',
        layer: 'walls',
        name: lumName
      });
      if (tokensLumiere.length === 0) {
        log("Pas de token pour la lumi\xE8re " + lumName);
        al.remove();
        return;
      }
      lumiere = tokensLumiere.shift();
      if (tokensLumiere.length > 0) {
        //On cherche le token le plus proche de perso
        var pos = [perso.token.get('left'), perso.token.get('top')];
        var d =
          VecMath.length(
            VecMath.vec([lumiere.get('left'), lumiere.get('top')], pos));
        var samePage = lumiere.get('pageid') == pageId;
        tokensLumiere.forEach(function(tl) {
          if (tl.get('pageid') != pageId) return;
          if (samePage) {
            var d2 =
              VecMath.length(
                VecMath.vec([tl.get('left'), tl.get('top')], pos));
            if (d2 < d) {
              d = d2;
              lumiere = tl;
            }
          } else {
            lumiere = tl;
          }
        });
      }
    }
    al.remove();
    if (lumiere) lumiere.remove();
  }

  function eteindreLumieres(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lectionn\xE9e pour !cof-eteindre-lumiere", playerId);
        return;
      }
      var cmd = options.cmd;
      var groupe;
      if (cmd.length > 1) groupe = cmd[1];
      if (groupe && groupe.toLowerCase() == 'tout') groupe = '';
      var pageId = options.pageId;
      var evt = {
        type: "Eteindre la lumi\xE8re"
      };
      iterSelected(selected, function(perso) {
        var attrLumiere = tokenAttribute(perso, 'lumiere');
        attrLumiere.forEach(function(al) {
          let lumName = al.get('current');
          if (groupe && !lumName.startsWith(groupe)) return;
          eteindreUneLumiere(perso, pageId, al, lumName, evt);
        });
      });
    }, options);
  }

  function switchTorche(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 2) {
      error("Il faut pr\xE9ciser le token en argument de !cof-torche");
      return;
    }
    var pageId = options.pageId;
    var perso = persoOfId(cmd[1], cmd[1], pageId);
    if (perso === undefined) {
      error("Token invalide", cmd);
      return;
    }
    pageId = pageId || perso.token.get('pageid');
    var diminueDuree = 0;
    if (cmd.length > 2) {
      //Dans ce cas, c'est pour diminuer la dur\xE9e de vie de la torche
      diminueDuree = parseInt(cmd[2]);
      if (isNaN(diminueDuree) || diminueDuree <= 0) {
        sendPlayer(msg, "Le deuxi\xE8me argument de !cof-torche doit \xEAtre un nombre strictement positif " + msg.content);
        return;
      }
    }
    var evt;
    //On commence par chercher si une torche est allum\xE9e
    var torcheAllumee = false;
    var attrLumiere = tokenAttribute(perso, 'lumiere').filter(function(a) {
      return a.get('current').startsWith('torche');
    });
    if (!diminueDuree && attrLumiere.length > 0) {
      torcheAllumee = true;
      evt = {
        type: "\xC9teindre les torches"
      };
      attrLumiere.forEach(function(al) {
        var lumName = al.get('current');
        eteindreUneLumiere(perso, pageId, al, lumName, evt);
      });
    }
    var nbTorches = 0;
    var tempsTorche = 0;
    var attrTorches = tokenAttribute(perso, 'torches');
    if (attrTorches.length > 0) {
      nbTorches = parseInt(attrTorches[0].get('current'));
      if (isNaN(nbTorches) || nbTorches < 0) {
        error("Nombre de torches incorrect", nbTorches);
        if (evt) addEvent(evt);
        return;
      }
      if (!torcheAllumee && nbTorches === 0) {
        whisperChar(perso.charId, "n'a pas de torche.");
        return;
      }
      tempsTorche = parseInt(attrTorches[0].get('max'));
      if (isNaN(tempsTorche) || tempsTorche < 0) {
        error("Temps restant pour la torche incorrect", tempsTorche);
        if (evt) addEvent(evt);
        return;
      }
      if (tempsTorche === 0) {
        if (nbTorches === 0) { //Donc forc\xE9ment torcheAllumee
          //On remet l'attribut dans un \xE9tat convenable
          setTokenAttr(perso, 'torches', 0, evt, {
            maxVal: 60
          });
          addEvent(evt);
          return;
        }
        nbTorches--;
        tempsTorche = 60;
      }
      if (diminueDuree) {
        evt = evt || {
          type: "Diminuer le duree de vie d'une torche"
        };
        var temps = diminueDuree;
        tempsTorche -= diminueDuree;
        if (tempsTorche <= 0) {
          nbTorches--;
          temps += tempsTorche;
          tempsTorche = 60;
          var msgDiminue = "torche \xE9puis\xE9e.";
          if (nbTorches === 0) {
            msgDiminue += " Plus de torche !";
          } else if (nbTorches == 1) {
            msgDiminue += " Plus qu'une torche.";
          } else {
            msgDiminue += " Il lui reste " + nbTorches + " torches.";
          }
          whisperChar(perso.charId, msgDiminue);
        }
        setTokenAttr(perso, 'torches', nbTorches, evt, {
          maxVal: tempsTorche
        });
        sendChar(perso.charId, '/w gm temps de torche diminu\xE9 de ' + temps + ' minutes');
        addEvent(evt);
        return;
      }
      if (torcheAllumee) {
        var msgTorche = "/w gm torche \xE9teinte. ";
        if (nbTorches > 1) {
          msgTorche += "Reste " + (nbTorches - 1) + " torche";
          if (nbTorches > 2) msgTorche += "s neuves";
          else msgTorche += " neuve";
          msgTorche += ", et une torche pouvant encore \xE9clairer " + tempsTorche + " minutes.";
        } else {
          msgTorche += "Elle peut encore \xE9clairer " + tempsTorche + " minutes.";
        }
        sendChar(perso.charId,
          msgTorche +
          boutonSimple("!cof-torche " + perso.token.id + " ?{Dur\xE9e?}", "Temps depuis allumage"));
        addEvent(evt);
        return;
      }
      evt = {
        type: "Allumer une torche"
      };
      ajouteUneLumiere(perso, 'torche', 13, 7, evt);
      var msgAllume =
        "allume une torche, qui peut encore \xE9clairer pendant " + tempsTorche +
        " minute";
      if (tempsTorche > 1) msgAllume += 's';
      msgAllume += '.';
      if (nbTorches > 1) {
        msgAllume += " Il lui reste encore " + (nbTorches - 1);
        if (nbTorches == 2) msgAllume += " autre torche.";
        else msgAllume += " autres torches.";
      }
      whisperChar(perso.charId, msgAllume);
      addEvent(evt);
      return;
    }
    //On ne tient pas le compte pr\xE9cis des torches
    if (torcheAllumee) {
      whisperChar(perso.charId, "\xE9teint sa torche");
    } else {
      evt = {
        type: "Allumer une torche"
      };
      ajouteUneLumiere(perso, 'torche', 13, 7, evt);
      whisperChar(perso.charId, "allume sa torche");
    }
    addEvent(evt);
  }

  //!cof-options
  //!cof-options opt1 [... optn] val, met l'option \xE0 val
  //!cof-options [opt0 ... optk] reset remet toutes les options \xE0 leur valeur patr d\xE9faut
  //Dans tous les cas, affiche les options du niveau demand\xE9
  function setCofOptions(msg) {
    const playerId = getPlayerIdFromMsg(msg);
    if (!playerIsGM(playerId)) {
      sendPlayer(msg, "Seul le MJ peut changer les options du script", playerId);
      return;
    }
    let cmd = msg.content.split(' ');
    let cofOptions = stateCOF.options;
    if (cofOptions === undefined) {
      sendPlayer(msg, "Options non diponibles", playerId);
      return;
    }
    let prefix = '';
    let up;
    let defOpt = defaultOptions;
    let newOption;
    let lastCmd;
    let fini;
    let current = '';
    cmd.shift();
    cmd.forEach(function(c) {
      if (fini) {
        sendPlayer(msg, "Option " + c + " ignor\xE9e", playerId);
        return;
      }
      if (c == 'reset') {
        for (let opt in cofOptions) delete cofOptions[opt];
        copyOptions(cofOptions, defOpt);
        fini = true;
      } else if (cofOptions[c]) {
        if (cofOptions[c].type == 'options') {
          if (defOpt[c] === undefined) {
            sendPlayer(msg, "Option " + c + " inconnue dans les options par d\xE9faut", playerId);
            fini = true;
            return;
          }
          defOpt = defOpt[c].val;
          cofOptions = cofOptions[c].val;
          up = prefix;
          prefix += ' ' + c;
        } else {
          newOption = cofOptions[c];
        }
      } else {
        if (newOption) { //on met newOption \xE0 c
          let val = c;
          switch (newOption.type) {
            case 'bool':
              switch (c) {
                case 'oui':
                case 'true':
                case '1':
                  val = true;
                  break;
                case 'non':
                case 'false':
                case '0':
                  val = false;
                  break;
                default:
                  sendPlayer(msg, "L'option " + lastCmd + " ne peut \xEAtre que true ou false", playerId);
                  val = newOption.val;
              }
              fini = true;
              break;
            case 'int':
              val = parseInt(c);
              if (isNaN(val)) {
                sendPlayer(msg, "L'option " + lastCmd + " est une valeur enti\xE8re", playerId);
                val = newOption.val;
              }
              fini = true;
              break;
            default:
              if (current === '') current = val;
              else current += ' ' + val;
              val = current;
          }
          newOption.val = val;
        } else if (lastCmd) {
          sendPlayer(msg, "L'option " + lastCmd + " ne contient pas de sous-option " + c, playerId);
        } else {
          sendPlayer(msg, "Option " + c + " inconnue.", playerId);
        }
      }
      lastCmd = c;
    });
    let titre = "Options de COFantasy";
    if (prefix !== '') {
      titre += "<br>" + prefix + ' (';
      titre += boutonSimple('!cof-options' + up, 'retour') + ')';
    }
    let display = startFramedDisplay(playerId, titre, undefined, {
      chuchote: true
    });
    for (let opt in cofOptions) {
      let optVu = opt.replace(/_/g, ' ');
      let line = '<span title="' + cofOptions[opt].explications + '">' +
        optVu + '</span> : ';
      let action = '!cof-options' + prefix + ' ' + opt;
      let displayedVal = cofOptions[opt].val;
      let after = '';
      switch (cofOptions[opt].type) {
        case 'options':
          displayedVal = '<span style="font-family: \'Pictos\'">l</span>';
          break;
        case 'bool':
          action += ' ?{Nouvelle valeur de ' + optVu + '|actif,true|inactif,false}';
          if (displayedVal)
          // Bizarrement, le caract\xE8re '*' modifie la suite du tableau
            displayedVal = '<span style="font-family: \'Pictos\'">3</span>';
          else
            displayedVal = '<span style="font-family: \'Pictos\'">&midast;</span>';
          break;
        case 'int':
          action += ' ?{Nouvelle valeur de ' + optVu + '(entier)}';
          break;
        case 'image':
          action += " ?{Entrez l'url pour " + optVu + '}';
          after =
            '<img src="' + displayedVal + '" style="width: 30%; height: auto; border-radius: 6px; margin: 0 auto;">';
          displayedVal = '<span style="font-family: \'Pictos\'">u</span>';
          break;
        case 'son':
          action += " ?{Entrez le nom du son pour " + optVu + '}';
          if (displayedVal === '') {
            displayedVal = '<span title="pas de son" style="font-family: \'Pictos Custom\'">u</span>';
          } else {
            after = boutonSimple('!cof-jouer-son ' + displayedVal,
              '<span style="font-family: \'Pictos\'">&gt;</span> ');
            displayedVal = '<span title="' + displayedVal + '" style="font-family: \'Pictos\'">m</span>';
          }
          break;
        default:
          action += ' ?{Nouvelle valeur de ' + optVu + '}';
      }
      line += boutonSimple(action, displayedVal) + after;
      addLineToFramedDisplay(display, line);
    }
    addLineToFramedDisplay(display, boutonSimple('!cof-options' + prefix + ' reset', 'Valeurs par d\xE9faut'), 70);
    sendChat('', endFramedDisplay(display));
  }

  function lancerDefiSamourai(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-defi-samourai demande au moins 2 options",
        msg.content);
      return;
    }
    var pageId = options.pageId;
    var samourai = persoOfId(cmd[1], cmd[1], pageId);
    if (samourai === undefined) {
      error("Le token s\xE9lectionn\xE9 n'est pas valide", msg.content);
      return;
    }
    samourai.tokName = samourai.token.get('name');
    if (attributeAsBool(samourai, 'defiSamourai')) {
      sendPlayer(msg, samourai.tokName + " a d\xE9j\xE0 lanc\xE9 un d\xE9fi durant ce combat.");
      return;
    }
    var cible = persoOfId(cmd[2], cmd[2], pageId);
    if (cible === undefined) {
      error("Le deuxi\xE8me token s\xE9lectionn\xE9 n'est pas valide", msg.content);
      return;
    }
    cible.tokName = cible.token.get('name');
    var evt = {
      type: 'D\xE9fi samoura\xEF'
    };
    var explications = [];
    entrerEnCombat(samourai, [cible], explications, evt);
    explications.forEach(function(m) {
      sendPerso(samourai, m);
    });
    var bonus;
    if (cmd.length > 3) {
      bonus = parseInt(cmd[3]);
      if (isNaN(bonus) || bonus < 1) {
        error("Bonus de d\xE9fi de samoura\xEF incorrect", cmd[3]);
        bonus = undefined;
      }
    }
    if (bonus === undefined)
      bonus = predicateAsInt(samourai, 'voieDeLHonneur', 2);
    setTokenAttr(samourai, 'defiSamourai', bonus, evt, {
      msg: samourai.tokName + " lance un d\xE9fi \xE0 " + cible.tokName,
      maxVal: cible.token.id + ' ' + cible.tokName
    });
  }

  function parseEnveloppement(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 6) {
      error("Il manque des arguments \xE0 !cof-enveloppement", cmd);
      return;
    }
    var cube = persoOfId(cmd[1]);
    if (cube === undefined) {
      error("Token non d\xE9fini", cmd[1]);
      return;
    }
    if (!peutController(msg, cube)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var cible = persoOfId(cmd[2]);
    if (cible === undefined) {
      error("Token non d\xE9fini", cmd[2]);
      return;
    }
    var difficulte = parseInt(cmd[3]);
    if (isNaN(difficulte)) {
      error("Difficult\xE9 n'est pas un nombre, on prend 15 par d\xE9faut", cmd[3]);
      difficulte = 15;
    }
    var exprDM;
    var type;
    switch (cmd[4]) {
      case 'label':
      case 'ability':
        type = 'enveloppement';
        exprDM = cmd[4] + ' ' + cmd[5];
        break;
      case 'etreinte':
        type = '\xE9treinte';
        exprDM = cmd[4] + ' ' + cmd[5];
        break;
      default:
        error("Impossible de d\xE9terminer les d\xE9g\xE2ts quand envelopp\xE9", cmd[4]);
        return;
    }
    doEnveloppement(cube, cible, difficulte, type, exprDM, options);
  }

  //!cof-enveloppement cubeId targetId Difficulte Attaque
  //Attaque peut \xEAtre soit label l, soit ability a, soit etreinte expr
  function doEnveloppement(attaquant, cible, difficulte, type, exprDM, options) {
    const evt = {
      type: type,
      action: {
        titre: "Enveloppement",
        attaquant: attaquant,
        cible: cible,
        difficulte: difficulte,
        type: type,
        exprDM: exprDM,
        options: options,
      }
    };
    addEvent(evt);
    //Choix de la caract\xE9ristique pour r\xE9sister : FOR ou DEX
    let caracRes = meilleureCarac('FOR', 'DEX', cible, 10 + modCarac(attaquant, 'force'));
    var titre = (type == '\xE9treinte') ? '\xC9treinte' : 'Enveloppement';
    var display = startFramedDisplay(options.playerId, titre, attaquant, {
      perso2: cible
    });
    var explications = [];
    var rollId = 'enveloppement_' + cible.token.id;
    testOppose(rollId, attaquant, 'FOR', options, cible, caracRes, options,
      explications, evt,
      function(res, crit, rt1, rt2) {
        var act = " a absorb\xE9 ";
        switch (res) {
          case 1:
            if (type == '\xE9treinte') act = " s'est enroul\xE9 autour de ";
            explications.push(attaquant.token.get('name') + act + cible.token.get('name'));
            var attaquantId = attaquant.token.id + ' ' + attaquant.token.get('name');
            var maxval = difficulte;
            if (type == '\xE9treinte') maxval = 'etreinte ' + difficulte;
            setTokenAttr(cible, 'enveloppePar', attaquantId, evt, {
              maxVal: maxval
            });
            var cibleId = cible.token.id + ' ' + cible.token.get('name');
            cible.token.set('left', attaquant.token.get('left'));
            cible.token.set('right', attaquant.token.get('right'));
            toFront(attaquant.token);
            setTokenAttr(attaquant, 'enveloppe', cibleId, evt, {
              maxVal: exprDM
            });
            if (type == '\xE9treinte') setState(cible, 'immobilise', true, evt);
            break;
          case 2:
            if (caracRes == 'FOR') {
              if (type == '\xE9treinte') act = '\xE9treindre';
              else act = 'absorber';
              explications.push(cible.token.get('name') + " r\xE9siste et ne se laisse pas " + act);
            } else {
              if (type == '\xE9treinte') act = "l'\xE9treinte";
              else act = "l'absorption";
              explications.push(cible.token.get('name') + " \xE9vite " + act);
            }
            break;
          default: //match null, la cible s'en sort
            if (type == '\xE9treinte') act = "l'\xE9treinte";
            else act = "l'enveloppement";
            explications.push(cible.token.get('name') + " \xE9chappe de justesse \xE0 " + act);
        }
        explications.forEach(function(e) {
          addLineToFramedDisplay(display, e);
        });
        sendChat("", endFramedDisplay(display));
      });
  }

  //!cof-echapper-enveloppement
  function parseEchapperEnveloppement(msg) {
    var options = msg.options || parseOptions(msg);
    if (options === undefined) return;
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "!cof-echapper-enveloppement sans s\xE9lection de token", playerId);
        log("!cof-echapper-enveloppement requiert de s\xE9lectionner des tokens");
        return;
      }
      iterSelected(selected, function(perso) {
        var attr = tokenAttribute(perso, 'enveloppePar');
        if (attr.length === 0) {
          sendPlayer(msg, perso.token.get('name') + " n'est pas englouti.", playerId);
          return;
        }
        attr = attr[0];
        var cube = persoOfIdName(attr.get('current'), options.pageId);
        if (cube === undefined) {
          error("Attribut enveloppePar mal form\xE9, on le supprime", attr.get('current'));
          attr.remove();
          return;
        }
        var etreinte = false;
        var maxAttr = attr.get('max') + '';
        if (maxAttr.startsWith('etreinte ')) {
          etreinte = true;
          maxAttr = maxAttr.substring(9);
        }
        var difficulte = parseInt(maxAttr);
        if (isNaN(difficulte)) {
          error("Difficult\xE9 mal form\xE9e", attr.get('max'));
          difficulte = 15;
        }
        doEchapperEnveloppement(perso, etreinte, cube, difficulte, options);
      });
    });
  }

  function doEchapperEnveloppement(perso, etreinte, cube, difficulte, options) {
    var evt = {
      type: (etreinte) ? "echapperEtreinte" : "echapperEnveloppement",
      personnage: perso,
      action: {
        perso: perso,
        etreinte: etreinte,
        cube: cube,
        difficulte: difficulte,
        options: options,
        rolls: options.rolls || {}
      }
    };
    addEvent(evt);
    var titre = "Tentative de sortir de " + cube.tokName;
    if (etreinte) titre = "Tentative de se lib\xE9rer de l'etreinte de " + cube.tokName;
    var display = startFramedDisplay(options.playerId, titre, perso, {
      chuchote: options.secret
    });
    var testId = 'enveloppement_' + perso.token.id;
    testCaracteristique(perso, 'FOR', difficulte, testId, options, evt,
      function(tr) {
        addLineToFramedDisplay(display, "<b>R\xE9sultat :</b> " + tr.texte);
        if (tr.reussite) {
          addLineToFramedDisplay(display, "C'est r\xE9ussi, " + perso.token.get('name') + " s'extirpe de " + cube.tokName + tr.modifiers);
          toFront(perso.token);
          evt.deletedAttributes = evt.deletedAttributes || [];
          var attr = tokenAttribute(perso, 'enveloppePar')[0];
          evt.deletedAttributes.push(attr);
          attr.remove();
          if (etreinte) setState(perso, 'immobilise', false, evt);
          attr = tokenAttribute(cube, 'enveloppe');
          attr.forEach(function(a) {
            var ca = persoOfIdName(a.get('current'));
            if (ca && ca.token.id == perso.token.id) {
              evt.deletedAttributes.push(a);
              a.remove();
            }
          });
        } else {
          var msgRate = "C'est rat\xE9." + tr.rerolls + tr.modifiers;
          addLineToFramedDisplay(display, msgRate);
        }
        sendChat('', endFramedDisplay(display));
      });
  }

  function parseLibererAgrippe(msg) {
    var options = msg.options || parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Il faut l'id du token en argument de !cof-liberer-agrippe", msg.content);
      return;
    }
    var perso = persoOfId(cmd[1], cmd[1], options.pageId);
    var attrName = 'estAgrippePar';
    var attr = tokenAttribute(perso, 'estAgrippePar');
    if (attr.length === 0) {
      attr = tokenAttribute(perso, 'etreinteImmolePar');
      attrName = 'etreinteImmolePar';
      if (attr.length === 0) {
        attr = tokenAttribute(perso, 'etreinteScorpionPar');
        attrName = 'etreinteScorpionPar';
        if (attr.length === 0) {
          attr = tokenAttribute(perso, 'estDevorePar');
          attrName = 'estDevorePar';
          if (attr.length === 0) {
            sendPlayer(msg, perso.tokName + " n'est pas agripp\xE9.");
            return;
          }
        }
      }
    }
    attr = attr[0];
    var agrippant = persoOfIdName(attr.get('current'), options.pageId);
    if (agrippant === undefined) {
      error("Attribut " + attrName + " mal form\xE9, on le supprime", attr.get('current'));
      attr.remove();
      return;
    }
    doLibererAgrippe(perso, agrippant, attrName, options);
  }

  //!cof-liberer-agrippe token_id
  function doLibererAgrippe(perso, agrippant, attrName, options) {
    var evt = {
      type: 'libererAgrippe',
      action: {
        titre: "Se lib\xE9rer",
        perso: perso,
        agrippant: agrippant,
        attrName: attrName,
        options: options
      }
    };
    addEvent(evt);
    var titre = "Tentative de se lib\xE9rer de " + agrippant.token.get('name');
    var playerId = options.playerId;
    var display = startFramedDisplay(playerId, titre, perso, {
      chuchote: options.secret
    });
    var explications = [];
    var rollId = 'libererAgrippe_' + perso.token.id;
    var options1 = {...options
    };
    if (attrName == 'etreinteImmolePar') options1.dice = 20;
    testOppose(rollId, perso, 'FOR', options1, agrippant, 'FOR',
      options, explications, evt,
      function(tr, crit, rt1, rt2) {
        explications.forEach(function(e) {
          addLineToFramedDisplay(display, e);
        });
        if (tr == 2) {
          var msgRate = "C'est rat\xE9, " + perso.token.get('name') + " est toujours ";
          if (attrName == 'etreinteImmolePar' || attrName == 'etreinteScorpionPar')
            msgRate += "prisonnier de l'\xE9treinte de " + agrippant.token.get('name');
          else if (attrName == 'estDevorePar')
            msgRate += 'saisi' + eForFemale(perso) + '.';
          else msgRate += "agripp\xE9" + eForFemale(perso) + ".";
          addLineToFramedDisplay(display, msgRate);
          if (attrName == 'etreinteScorpionPar') { // Cas d'\xE9treinte de scorpion avec dommages automatiques
            var d6 = evt.action.rolls.etreinteDmg || rollDePlus(6, {
              bonus: 3
            });
            evt.action.rolls.etreinteDmg = d6;
            var r = {
              total: d6.val,
              type: 'normal',
              display: d6.roll
            };
            let explications2 = [];
            perso.ignoreTouteRD = true;
            dealDamage(perso, r, [], evt, false, {}, explications2, function(dmgDisplay) {
              var dmgMsg = "L'\xE9treinte du scorpion inflige " + dmgDisplay + " d\xE9g\xE2ts.";
              setTokenAttr(perso, "etreinteScorpionRatee", true, evt);
              addLineToFramedDisplay(display, dmgMsg);
              explications2.forEach(function(expl) {
                addLineToFramedDisplay(display, expl, 80);
              });
              sendChat('', endFramedDisplay(display));
            });
          } else {
            sendChat('', endFramedDisplay(display));
          }
        } else {
          if (tr === 0)
            addLineToFramedDisplay(display, "R\xE9ussi de justesse, " + perso.token.get('name') + " se lib\xE8re.");
          else //tr == 1
            addLineToFramedDisplay(display, "R\xE9ussi, " + perso.token.get('name') + " se lib\xE8re.");
          toFront(perso.token);
          evt.deletedAttributes = evt.deletedAttributes || [];
          var attr = tokenAttribute(perso, attrName);
          attr[0].remove();
          evt.deletedAttributes.push(attr[0]);
          if (attrName == 'estAgrippePar') removeTokenAttr(perso, 'agrippeParUnDemon', evt);
          if (attrName == 'etreinteImmolePar' || attrName == 'estDevorePar' || attr[0].get('max'))
            setState(perso, 'immobilise', false, evt);
          if (attrName == 'etreinteScorpionPar') {
            var etrScorpAttr = tokenAttribute(perso, "etreinteScorpionRatee");
            if (etrScorpAttr && etrScorpAttr.length > 0) {
              etrScorpAttr[0].remove();
              evt.deletedAttributes.push(etrScorpAttr[0]);
            }
          }
          var attrAgrippant = 'agrippe';
          if (attrName == 'etreinteImmolePar') attrAgrippant = 'etreinteImmole';
          if (attrName == 'etreinteScorpionPar') attrAgrippant = 'etreinteScorpionSur';
          if (attrName == 'estDevorePar') attrAgrippant = 'devore';
          attr = tokenAttribute(agrippant, attrAgrippant);
          attr.forEach(function(a) {
            var ca = persoOfIdName(a.get('current'));
            if (ca && ca.token.id == perso.token.id) {
              evt.deletedAttributes.push(a);
              a.remove();
            }
          });
          sendChat('', endFramedDisplay(display));
          if (attrName == 'etreinteScorpionPar') {
            turnAction(perso);
          }
        }
      });
  }

  //!cof-animer-cadavre lanceur cible
  function animerCadavre(msg) {
    var options = msg.options || parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-animer-cadavre attend 2 arguments", msg.content);
      return;
    }
    var lanceur = persoOfId(cmd[1], cmd[1], options.pageId);
    if (lanceur === undefined) {
      error("Le premier argument de !cof-animer-cadavre n'est pas un token valide", msg.content);
      return;
    }
    var cible = persoOfId(cmd[2], cmd[2], options.pageId);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-animer-cadavre n'est pas un token valide", msg.content);
      return;
    }
    cible.tokName = cible.token.get('name');
    if (!getState(cible, 'mort')) {
      sendPlayer(msg, cible.tokName + " n'est pas mort" + eForFemale(cible) + ".");
      return;
    }
    if (attributeAsBool(cible, 'cadavreAnime')) {
      sendPlayer(msg, cible.tokName + " a d\xE9j\xE0 \xE9t\xE9 anim\xE9" + eForFemale(cible) + ".");
      return;
    }
    var niveauLanceur = ficheAttributeAsInt(lanceur, 'niveau', 1);
    var niveauCible = ficheAttributeAsInt(cible, 'niveau', 1);
    if (niveauCible > niveauLanceur) {
      sendPlayer(msg, cible.tokName + " est de NC " + niveauCible + ", sup\xE9rieur \xE0 celui de " + lanceur.token.get('name') + " (" + niveauLanceur + ")");
      return;
    }
    var evt = {
      type: "Animer un cadvre"
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'animerUnCadavre', "animer un cadavre", evt)) return;
    sendPerso(lanceur, 'r\xE9anime ' + cible.tokName);
    setState(cible, 'mort', false, evt);
    var pvmax = parseInt(cible.token.get("bar1_max"));
    updateCurrentBar(cible, 1, pvmax, evt);
    setTokenAttr(cible, 'cadavreAnime', true, evt, {
      msg: 'se rel\xE8ve'
    });
  }

  var niveauxEbriete = [
    "sobre",
    "pompette",
    "bourr\xE9",
    "ivre-mort",
    "en coma \xE9thylique"
  ];

  function augmenteEbriete(personnage, evt, expliquer) {
    personnage.tokName = personnage.tokName || personnage.token.get('name');
    var n = attributeAsInt(personnage, 'niveauEbriete', 0) + 1;
    if (n >= niveauxEbriete.length) {
      expliquer(personnage.tokName + " est d\xE9j\xE0 en coma \xE9thylique.");
      return;
    }
    expliquer(personnage.tokName + " devient " + niveauxEbriete[n]);
    setTokenAttr(personnage, 'niveauEbriete', n, evt);
  }

  function diminueEbriete(personnage, evt, expliquer) {
    personnage.tokName = personnage.tokName || personnage.token.get('name');
    var n = attributeAsInt(personnage, 'niveauEbriete', 0);
    if (n < 1) return;
    n--;
    if (n >= niveauxEbriete.length) n = niveauxEbriete.length - 1;
    expliquer(personnage.tokName + " redevient " + niveauxEbriete[n]);
    setTokenAttr(personnage, 'niveauEbriete', n, evt);
  }

  function parseVapeursEthyliques(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cibles = [];
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "pas de cible trouv\xE9e, action annul\xE9e", playerId);
        return;
      }
      iterSelected(selected, function(perso) {
        cibles.push(perso);
      });
      doVapeursEthyliques(playerId, cibles, options);
    }, options); //fin getSelected
  }

  function doVapeursEthyliques(playerId, persos, options) {
    var evt = {
      type: 'vapeursEthyliques',
      action: {
        playerId: playerId,
        persos: persos,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(options.lanceur, options, 'vapeursEthyliques', "lancer une fiole de vapeurs \xE9thyliques", evt)) {
      addEvent(evt);
      return;
    }
    var display = startFramedDisplay(playerId, 'Vapeurs \xE9thyliques');
    var expliquer = function(m) {
      addLineToFramedDisplay(display, m);
    };
    var explications = [];
    if (options.save) {
      explications.push(" Jet de " + options.save.carac + " " + options.save.seuil + " pour r\xE9sister \xE0 l'alcool");
    }
    entrerEnCombat(options.lanceur, persos, explications, evt);
    explications.forEach(explication => expliquer(explications));
    var count = persos.length;
    var finalize = function() {
      if (count == 1) sendChat('', endFramedDisplay(display));
      count--;
    };
    persos.forEach(function(perso) {
      perso.tokName = perso.tokName || perso.token.get('name');
      if (options.save) {
        var saveOpts = {
          hideSaveTitle: true,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: 'poison'
        };
        var saveId = 'vapeursEthyliques_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt,
          function(succes, rollText) {
            if (!succes) {
              augmenteEbriete(perso, evt, expliquer);
              setTokenAttr(perso, 'vapeursEthyliques', 0, evt, {
                maxVal: options.save.seuil
              });
            }
            finalize();
          });
      } else { //pas de save
        augmenteEbriete(perso, evt, expliquer);
        setTokenAttr(perso, 'vapeursEthyliques', 0, evt);
        finalize();
      }
    });
  }

  function desaouler(msg) {
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Aucune s\xE9lection pour !cof-desaouler", playerId);
        return;
      }
      var evt = {
        type: 'desao\xFBler'
      };
      var expliquer = function(s) {
        sendChat('', s);
      };
      iterSelected(selected, function(perso) {
        diminueEbriete(perso, evt, expliquer);
      });
      addEvent(evt);
    });
  }

  function parseBoireAlcool(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var persos = [];
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        persos.push(perso);
      });
      doBoireAlcool(playerId, persos, options);
    }, options); //fin getSelected
  }

  function doBoireAlcool(playerId, persos, options) {
    var evt = {
      type: 'boireAlcool',
      action: {
        playerId: playerId,
        persos: persos,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(options.lanceur, options, 'boireAlcool', "est affect\xE9 par l'alcool", evt)) {
      return;
    }
    var display = startFramedDisplay(playerId, 'Alcool');
    var expliquer = function(m) {
      addLineToFramedDisplay(display, m);
    };
    if (options.save) {
      expliquer("Jet de " + options.save.carac + " " + options.save.seuil + " pour r\xE9sister \xE0 l'alcool");
    }
    var count = persos.length;
    var finalize = function() {
      if (count == 1) sendChat('', endFramedDisplay(display));
      count--;
    };
    persos.forEach(function(perso) {
      perso.tokName = perso.tokName || perso.token.get('name');
      if (options.save) {
        var saveOpts = {
          hideSaveTitle: true,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: 'poison'
        };
        var saveId = 'boireAlcool_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt,
          function(succes, rollText) {
            if (!succes) {
              augmenteEbriete(perso, evt, expliquer);
            }
            finalize();
          });
      } else { //pas de save
        augmenteEbriete(perso, evt, expliquer);
        finalize();
      }
    });
  }

  function jouerSon(msg) {
    var sonIndex = msg.content.indexOf(' ');
    if (sonIndex > 0) {
      //On joue un son
      var son = msg.content.substring(sonIndex + 1);
      playSound(son);
    } else { //On arr\xEAte tous les sons
      var AMdeclared;
      try {
        AMdeclared = Roll20AM;
      } catch (e) {
        if (e.name != "ReferenceError") throw (e);
      }
      if (AMdeclared) {
        //With Roll20 Audio Master
        sendChat("GM", "!roll20AM --audio,stop|");
      } else {
        var jukebox = findObjs({
          type: 'jukeboxtrack',
          playing: true
        });
        jukebox.forEach(function(track) {
          track.set('playing', false);
        });
      }
    }
  }

  function bonusCouvert(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    var nouveauBonus = 0;
    if (cmd.length > 1) {
      nouveauBonus = parseInt(cmd[1]);
      if (isNaN(nouveauBonus) || nouveauBonus < 0) {
        error("Il faut un argument positif pour !cof-bonus-couvert", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error('pas de token s\xE9lectionn\xE9 pour !cof-bonus-couvert');
        return;
      }
      var evt = {
        type: 'Bonus couvert'
      };
      addEvent(evt);
      if (limiteRessources(options.lanceur, options, 'bonus couvert', 'bonus couvert', evt)) return;
      iterSelected(selected, function(perso) {
        if (nouveauBonus) {
          setTokenAttr(perso, 'bonusCouvert', nouveauBonus, evt, {
            msg: "se met \xE0 couvert",
            secret: options.secret
          });
        } else {
          removeTokenAttr(perso, 'bonusCouvert', evt, {
            msg: "n'est plus \xE0 couvert",
            secret: options.secret
          });
        }
      }); //fin iterSelected
    }, options); //fin getSelected
  }

  //!cof-set-attribute nom valeur [max]
  function setAttributeInterface(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) return;
    if (cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-set-attribute", cmd);
      return;
    }
    let opt = {
      secret: options.secret
    };
    if (cmd.length > 3) {
      opt.maxVal = cmd[3];
    }
    if (options.messages && options.messages.length > 0)
      opt.msg = options.messages[0];
    getSelected(msg, function(selected, playerId) {
      /*if (!playerIsGM(playerId)) {
        sendChat('COF', "Seul le MJ peut utiliser la commande !cof-set-attributes");
        return;
      }*/
      if (selected.length === 0) {
        error('pas de token s\xE9lectionn\xE9 pour !cof-set-attribute');
        return;
      }
      const evt = {
        type: 'Changement attribut'
      };
      addEvent(evt);
      if (limiteRessources(options.lanceur, options, 'changementAttribut', 'changementAttribut', evt)) return;
      iterSelected(selected, function(perso) {
        setTokenAttr(perso, cmd[1], cmd[2], evt, opt);
        if (options.etats) {
          for (let etat in options.etats) {
            setState(perso, etat, options.etats[etat], evt);
          }
        }
      }); //fin iterSelected
    }, options);
  }

  function setPredicate(perso, predicat, evt) {
    let pred = ficheAttribute(perso, 'predicats_script', '');
    if (pred.includes(predicat)) {
      return;
    }
    if (pred === '') pred = predicat;
    else pred = pred + ' ' + predicat;
    evt = evt || {};
    setFicheAttr(perso, 'predicats_script', pred, evt);
  }

  //!cof-set-predicate nom [valeur]
  function setPredicateInterface(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) return;
    if (cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-set-predicate", cmd);
      return;
    }
    let predicat = cmd[1].trim();
    let set = true;
    if (cmd.length > 2) {
      set = cmd[2];
    }
    let opt = {
      secret: options.secret
    };
    if (options.messages && options.messages.length > 0)
      opt.msg = options.messages[0];
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error('pas de token s\xE9lectionn\xE9 pour !cof-set-predicate');
        return;
      }
      const evt = {
        type: 'Changement predicat'
      };
      addEvent(evt);
      if (limiteRessources(options.lanceur, options, 'changementPredicat', 'changementPredicat', evt)) return;
      iterSelected(selected, function(perso) {
        let pred = ficheAttribute(perso, 'predicats_script', '');
        switch (set) {
          case 'true':
          case 'vrai':
          case 'oui':
            if (pred.includes(predicat)) {
              sendPlayer(msg, 'Pr\xE9dicat ' + predicat + ' d\xE9j\xE0 pr\xE9sent', playerId);
              return;
            }
            if (pred === '') pred = predicat;
            else pred = pred + ' ' + predicat;
            setFicheAttr(perso, 'predicats_script', pred, evt);
            sendPlayer(msg, 'Pr\xE9dicat ' + predicat + ' ajout\xE9', playerId);
            break;
          case 'false':
          case 'faux':
          case 'non':
            let regPred = new RegExp('(^| |,|\n)' + predicat + '($| |,|\n)');
            let newPred = pred.replace(regPred, ' ');
            if (newPred == pred) {
              sendPlayer(msg, 'Pr\xE9dicat ' + predicat + ' non trouv\xE9', playerId);
            } else {
              setFicheAttr(perso, 'predicats_script', newPred, evt);
              sendPlayer(msg, 'Pr\xE9dicat ' + predicat + ' enlev\xE9', playerId);
            }
            break;
          default:
            error("L'argument de " + msg.content + " est inutilisable", set);
            return;
        }
        if (options.etats) {
          for (var etat in options.etats) {
            setState(perso, etat, options.etats[etat], evt);
          }
        }
      }); //fin iterSelected
    }, options);
  }
  //!cof-defense-armee-des-morts tokenId
  function defenseArmeeDesMorts(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    if (cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-defense-armee-des-morts", cmd);
      return;
    }
    var perso = persoOfId(cmd[1]);
    if (perso === undefined) {
      error("Le token renseign\xE9 pour !cof-defense-armee-des-morts est inconnu", cmd);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "ne peut pas faire \xE7a.");
      return;
    }
    var evt = {
      type: "DefenseArmeeDesMorts"
    };
    addEvent(evt);
    var opt = {
      msg: "se d\xE9fend contre les morts"
    };
    setTokenAttr(perso, "defenseArmeeDesMorts", true, evt, opt);
  }

  function addLigneOptionAttaque(display, perso, val, texte, attr) {
    var box;
    var action = "!cof-options-d-attaque " + attr + "_check ?{" + texte + "?|";
    if (val) {
      box = '<span style="font-family: \'Pictos\'">3</span>';
      action += "Non|Oui}";
    } else {
      box = ' ';
      action += "Oui|Non}";
    }
    action += " --target " + perso.token.id;
    var ligne = boutonSimple(action, box) + texte;
    addLineToFramedDisplay(display, ligne);
  }

  //!cof-options-d-attaque, affiche les options d'attaque du token s\xE9lectionn\xE9
  // si on donne reset en argument, remet tout \xE0 z\xE9ro
  // si on donne en argument option valeur, change la valeur de l'option
  function optionsDAttaque(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    var evt = {
      type: "Option d'attaque"
    };
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        //D'abord on lit les valeurs
        var aepc = ficheAttributeAsBool(perso, 'attaque_en_puissance_check');
        var arc = ficheAttributeAsBool(perso, 'attaque_risquee_check');
        var aac = ficheAttributeAsBool(perso, 'attaque_assuree_check');
        var adtc = ficheAttributeAsBool(perso, 'attaque_dm_temp_check');
        var aep = ficheAttributeAsInt(perso, 'attaque_en_puissance', 1);
        var adg;
        if (persoEstPNJ(perso)) {
          adg = ficheAttributeAsInt(perso, 'attaque_de_groupe', 1);
        }
        if (cmd.length > 1 && cmd[1] == 'reset') {
          if (adg > 1) {
            setFicheAttr(perso, 'attaque_de_groupe', 1, evt);
            adg = 1;
          }
          if (aepc) {
            setFicheAttr(perso, 'attaque_en_puissance_check', 0, evt);
            aepc = false;
          }
          if (arc) {
            setFicheAttr(perso, 'attaque_risquee_check', 0, evt);
            arc = false;
          }
          if (aac) {
            setFicheAttr(perso, 'attaque_assuree_check', 0, evt);
            aac = false;
          }
          if (adtc) {
            setFicheAttr(perso, 'attaque_dm_temp_check', 0, evt);
            adtc = false;
          }
          turnAction(perso, playerId);
          return;
        } else if (cmd.length > 2) {
          switch (cmd[1]) {
            case 'attaque_en_puissance_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!aepc) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  aepc = true;
                  aac = false;
                }
              } else {
                if (aepc) {
                  setFicheAttr(perso, cmd[1], 0, evt);
                  aepc = false;
                }
              }
              break;
            case 'attaque_risquee_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!arc) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  arc = true;
                }
              } else {
                if (arc) {
                  setFicheAttr(perso, cmd[1], 0, evt);
                  arc = false;
                }
              }
              break;
            case 'attaque_assuree_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!aac) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  aac = true;
                  aepc = false;
                }
              } else {
                if (aac) {
                  setFicheAttr(perso, cmd[1], 0, evt);
                  aac = false;
                }
              }
              break;
            case 'attaque_dm_temp_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!adtc) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  adtc = true;
                }
              } else {
                if (adtc) {
                  setFicheAttr(perso, cmd[1], 0, evt);
                  adtc = false;
                }
              }
              break;
            case 'attaque_de_groupe':
              if (persoEstPNJ(perso)) {
                var nadg = parseInt(cmd[2]);
                if (isNaN(nadg) || nadg < 1) nadg = 1;
                if (nadg != adg) {
                  setFicheAttr(perso, cmd[1], nadg, evt);
                  adg = nadg;
                }
              }
              break;
            case 'attaque_en_puissance':
              var naep = parseInt(cmd[2]);
              if (isNaN(naep) || naep < 1) naep = 1;
              if (naep != aep) {
                setFicheAttr(perso, cmd[1], naep, evt);
                aep = naep;
              }
              break;
            default:
              error("Argument de !cof-options-d-attaque non reconnu", cmd);
              //Mais on peut quand m\xEAme afficher les options
          }
          turnAction(perso, playerId);
          return;
        }
        var action;
        var title = "Options d'attaque";
        var opt_display = {
          chuchote: true
        };
        if (aepc || arc || aac || adtc || (persoEstPNJ(perso) && adg > 1)) {
          action = "!cof-options-d-attaque reset --target " + perso.token.id;
          opt_display.action_right = boutonSimple(action, 'r\xE9init.');
        }
        var display = startFramedDisplay(playerId, title, perso, opt_display);
        var ligne = '';
        var overlay = '';
        if (persoEstPNJ(perso)) {
          ligne = "Attaque de groupe : ";
          action = "!cof-options-d-attaque attaque_de_groupe ?{Combien d'adversaires par jet?}";
          action += " --target " + perso.token.id;
          overlay = 'title="+2 Att. par cr\xE9ature, si Att > DEF + 5, DM x2, si critique DM x3"';
          ligne += boutonSimple(action, adg, overlay);
          if (adg < 2) {
            ligne += "attaquant";
          } else {
            ligne += "attaquants";
          }
          addLineToFramedDisplay(display, ligne);
        }
        var text;
        action = "!cof-options-d-attaque attaque_en_puissance_check ?{Attaque en puissance?|";
        if (aepc) {
          text = '<span style="font-family: \'Pictos\'">3</span>';
          action += "Non|Oui}";
        } else {
          text = '<span> </span>';
          action += "Oui|Non}";
        }
        action += " --target " + perso.token.id;
        ligne = boutonSimple(action, text) + "Attaque en puissance";
        action = "!cof-options-d-attaque attaque_en_puissance ?{nombre de d\xE9s de bonus (-5 att par d\xE9)?}";
        action += " --target " + perso.token.id;
        ligne += "(+" + boutonSimple(action, aep) + "d";
        if (predicateAsBool(perso, 'tropPetit')) {
          ligne += "4 DM)";
        } else {
          ligne += "6 DM)";
        }
        addLineToFramedDisplay(display, ligne);
        addLigneOptionAttaque(display, perso, arc, "Attaque risqu\xE9e", 'attaque_risquee');
        addLigneOptionAttaque(display, perso, aac, "Attaque assur\xE9e", 'attaque_assuree');
        addLigneOptionAttaque(display, perso, adtc, "Attaque pour assommer", 'attaque_dm_temp');
        sendChat('', endFramedDisplay(display));
      });
    });
    if (evt.attributes) addEvent(evt);
  }

  //si evt est d\xE9fini, on ajoute les actions \xE0 evt
  function nePlusSuivre(perso, pageId, evt, reutilise) {
    perso.tokName = perso.tokName || perso.token.get('name');
    var attrSuit = tokenAttribute(perso, 'suit');
    if (attrSuit.length > 0) {
      attrSuit = attrSuit[0];
      var idSuivi = attrSuit.get('current');
      var suivi = persoOfIdName(idSuivi, pageId);
      if (evt) {
        evt.attributes = evt.attribute || [];
        evt.attributes.push({
          attribute: attrSuit,
          current: idSuivi,
          max: attrSuit.get('max')
        });
      }
      if (!reutilise) attrSuit.remove();
      if (suivi === undefined) {
        sendPerso(perso, "ne suit plus personne");
        return;
      } else {
        sendPerso(perso, "ne suit plus " + suivi.token.get('name'));
        var suivantDeSuivi = tokenAttribute(suivi, 'estSuiviPar');
        if (suivantDeSuivi.length > 0) {
          suivantDeSuivi = suivantDeSuivi[0];
          var currentSuivantDeSuivi = suivantDeSuivi.get('current');
          var found;
          var csds = currentSuivantDeSuivi.split(':::').filter(function(idn) {
            if (found) return true;
            var sp = splitIdName(idn);
            if (sp === undefined) return false;
            if (sp.id == perso.id) {
              found = true;
              return false;
            }
            if (sp.name == perso.tokName) {
              found = true;
              return false;
            }
            return true;
          });
          if (csds.length === 0) {
            if (evt) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              evt.deletedAttributes.push(suivantDeSuivi);
            }
            suivantDeSuivi.remove();
          } else {
            if (evt) {
              evt.attributes.push({
                attribute: suivantDeSuivi,
                current: currentSuivantDeSuivi
              });
            }
            suivantDeSuivi.set('current', csds.join(':::'));
          }
        }
      }
      return attrSuit;
    }
  }

  //!cof-suivre @{selected|token_id} @{target|token_id}
  function suivre(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    if (cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-suivre", cmd);
      return;
    }
    var perso = persoOfId(cmd[1], cmd[1], options.pageId);
    if (perso === undefined) {
      error("Token s\xE9lectionne incorrect pour !cof-suivre", cmd);
      return;
    }
    var pageId = perso.token.get('pageid');
    var cible = persoOfId(cmd[2], cmd[2], pageId);
    if (cible === undefined) {
      error("Cible incorrecte pour !cof-suivre", cmd);
      return;
    }
    var evt = {
      type: 'Suivre',
      attributes: []
    };
    //D'abord on arr\xEAte de suivre si on suivait quelqu'un
    var attrSuit = nePlusSuivre(perso, pageId, evt, true);
    var cibleId = cible.token.id + ' ' + cible.token.get('name');
    var attr = tokenAttribute(cible, 'estSuiviPar');
    var suiveurs;
    if (attr.length === 0) {
      attr = setTokenAttr(cible, 'estSuiviPar', '', evt);
      suiveurs = [];
    } else {
      attr = attr[0];
      suiveurs = attr.get('current');
      evt.attributes.push({
        attribute: attr,
        current: suiveurs,
      });
      suiveurs = suiveurs.split(':::');
    }
    var xt = perso.token.get('left');
    var yt = perso.token.get('top');
    var xc = cible.token.get('left');
    var yc = cible.token.get('top');
    var distance = Math.floor(Math.sqrt((xc - xt) * (xc - xt) + (yc - yt) * (yc - yt)));
    if (attrSuit) {
      //alors evt contient d\xE9j\xE0 attrSuit
      attrSuit.set('current', cibleId);
      attrSuit.set('max', distance);
    } else {
      setTokenAttr(perso, 'suit', cibleId, evt, {
        maxVal: distance
      });
    }
    suiveurs.push(perso.token.id + ' ' + perso.token.get('name'));
    attr.set('current', suiveurs.join(':::'));
    sendPerso(perso, "suit " + cible.token.get('name'));
    addEvent(evt);
  }

  // !cof-centrer-sur-token tid (ou nom de token)
  function centrerSurToken(msg) {
    var cmd = msg.content.split(' ').filter(function(c) {
      return c !== '';
    });
    if (cmd.length < 2) {
      error("Il faut pr\xE9ciser un token sur lequel se centrer", cmd);
      return;
    }
    var playerId = getPlayerIdFromMsg(msg);
    var pageId;
    if (playerIsGM(playerId)) {
      var p = getObj('player', playerId);
      if (p === undefined) {
        error("Impossible de trouver le joueur qui a lanc\xE9 la commande", msg);
        return;
      }
      pageId = p.get('_lastpage');
    } else {
      var c = Campaign();
      var ps = c.get('playerspecificpages');
      if (ps) pageId = ps[playerId];
      if (pageId === undefined) pageId = c.get('playerpageid');
    }
    var indexNom = msg.content.indexOf(' ');
    var nom = msg.content.substring(indexNom).trim();
    var perso = persoOfId(cmd[1], nom, pageId);
    if (perso === undefined) {
      error("Impossible de trouver le personnage sur lequel se centrer", cmd);
      return;
    }
    var token = perso.token;
    sendPing(token.get('left'), token.get('top'), pageId, playerId, true, playerId);
  }

  function afficherRichesse(perso, dest) {
    var msg = '';
    var possede;
    var pp = ficheAttributeAsInt(perso, 'bourse_pp', 0);
    if (pp > 0) {
      msg = pp + " PP";
      possede = true;
    }
    var po = ficheAttributeAsInt(perso, 'bourse_po', 0);
    if (po > 0) {
      if (possede) msg += ', ';
      else possede = true;
      msg += po + " PO";
    }
    var pa = ficheAttributeAsInt(perso, 'bourse_pa', 0);
    if (pa > 0) {
      if (possede) msg += ', ';
      else possede = true;
      msg += pa + " PA";
    }
    var pc = ficheAttributeAsInt(perso, 'bourse_pc', 0);
    if (pc > 0) {
      if (possede) msg += ' et ';
      else possede = true;
      msg += pc + " PC";
    }
    if (possede) msg = 'poss\xE8de ' + msg;
    else msg = "n'a pas d'argent";
    if (dest) sendPlayer(dest, perso.token.get('name') + ' ' + msg);
    else whisperChar(perso.charId, msg);
  }

  function depenserSous(perso, unite, bourse, depense) {
    if (depense <= 0) return 0;
    var retenue = 0;
    if (bourse[unite] < depense) {
      retenue = Math.ceil((depense - bourse[unite]) / 10);
      bourse[unite] += retenue * 10;
    }
    bourse[unite] -= depense;
    return retenue;
  }

  function ajouteLignePieces(perso, display, unite, nom, piece) {
    var finAction = unite + " --target " + perso.token.id;
    var val = ficheAttributeAsInt(perso, 'bourse_' + unite, 0);
    var line = '<table style="width:100%"><tr><td>';
    var action =
      "!cof-bourse fixer ?{Nouveau montant de pi\xE8ces " + piece + " ?} " + finAction;
    line += boutonSimple(action, val) + '<b>' + nom + '</b>';
    line += '</td><td style="text-align: right;">';
    action = "!cof-bourse depenser ?{Pi\xE8ces " + piece + " \xE0 d\xE9penser ?} " + finAction;
    line += boutonSimple(action, 'D\xE9penser');
    action = "!cof-bourse gagner ?{Pi\xE8ces " + piece + "  ?} " + finAction;
    line += boutonSimple(action, 'Gagner');
    line += '</td></tr></table>';
    addLineToFramedDisplay(display, line);
  }

  //!cof-bourse [action]
  //Les actions peuvent \xEAtre depenser val [unite], fixer val unite ou gagner val [unite]
  function gestionBourse(msg) {
    var cmd = msg.content.split(' ').filter(function(c) {
      return c.trim() !== '';
    });
    var action = '';
    var montant;
    var unite = 'pa';
    var depense = {
      pc: 0,
      pa: 0,
      po: 0,
      pp: 0
    };
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'depenser':
        case 'd\xE9penser':
        case 'gagner':
        case 'fixer':
          if (cmd.length < 3) {
            error("Il faut sp\xE9cifier un montant \xE0 " + cmd[1], msg.content);
            return;
          }
          montant = parseInt(cmd[2]);
          if (isNaN(montant)) {
            error("montant " + cmd[2] + " incorrect", cmd);
            return;
          }
          if (cmd[1] == 'gagner') {
            montant = -montant;
            action = 'depenser';
          } else if (cmd[1] == 'fixer') {
            if (montant < 0) {
              error("On ne peut avoir qu'un nombre positif de pi\xE8ces", cmd);
              return;
            }
            action = 'fixer';
          } else action = 'depenser';
          if (cmd.length > 3 && !cmd[3].startsWith('--')) {
            unite = cmd[3].toLowerCase().trim();
            if (unite != 'pp' && unite != 'po' && unite != 'pa' && unite != 'pc') {
              error("Pi\xE8ces non reconnues : " + cmd[3], cmd);
              return;
            }
            depense[unite] = montant;
          } else if (action == 'fixer') {
            error("Il faut pr\xE9ciser les unit\xE9s pour !cof-bourse fixer", msg.content);
            return;
          }
          depense.total = depense.pc + 10 * (depense.pa + 10 * (depense.po + 10 * depense.pp));
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de personnage s\xE9lectionn\xE9 pour !cof-bourse", playerId);
        return;
      }
      var evt = {
        type: 'bourse'
      };
      iterSelected(selected, function(perso) {
        switch (action) {
          case 'depenser':
            var pc = ficheAttributeAsInt(perso, 'bourse_pc', 0);
            var pa = ficheAttributeAsInt(perso, 'bourse_pa', 0);
            var po = ficheAttributeAsInt(perso, 'bourse_po', 0);
            var pp = ficheAttributeAsInt(perso, 'bourse_pp', 0);
            if (depense.total < 0) {
              if (depense.pc < 0) {
                pc -= depense.pc;
                setTokenAttr(perso, 'bourse_pc', pc, evt, {
                  charAttr: true
                });
              }
              if (depense.pa < 0) {
                pa -= depense.pa;
                setTokenAttr(perso, 'bourse_pa', pa, evt, {
                  charAttr: true
                });
              }
              if (depense.po < 0) {
                po -= depense.po;
                setTokenAttr(perso, 'bourse_po', po, evt, {
                  charAttr: true
                });
              }
              if (depense.pp < 0) {
                pp -= depense.pp;
                setTokenAttr(perso, 'bourse_pp', pp, evt, {
                  charAttr: true
                });
              }
              addEvent(evt);
              afficherRichesse(perso);
              return;
            }
            var montantPossede = pc + 10 * (pa + 10 * (po + 10 * pp));
            if (montantPossede < depense.total) {
              sendPerso(perso, "ne poss\xE8de pas assez d'argent pour cette d\xE9pense");
              afficherRichesse(perso, msg);
              return;
            }
            var bourse = {
              pc: pc,
              pa: pa,
              po: po,
              pp: pp
            };
            // On privil\xE9gie les d\xE9penses directes
            var dpp = depense.pp;
            if (dpp <= bourse.pp) {
              bourse.pp -= dpp;
              dpp = 0;
            } else {
              dpp -= bourse.pp;
              bourse.pp = 0;
            }
            var dpo = depense.po;
            if (dpo < bourse.po) {
              bourse.po -= dpo;
              dpo = 0;
            } else {
              dpo -= bourse.po;
              bourse.po = 0;
            }
            var dpa = depense.pa;
            if (dpa <= bourse.pa) {
              bourse.pa -= dpa;
              dpa = 0;
            } else {
              dpa -= bourse.pa;
              bourse.pa = 0;
            }
            var dpc = depense.pc;
            if (dpc < bourse.pc) {
              bourse.pc -= dpc;
              dpc = 0;
            } else {
              dpc -= bourse.pc;
              bourse.pc = 0;
            }
            // Puis on d\xE9pense d'abord la petite monnaie
            var v = dpc + 10 * (dpa + 10 * (dpo + 10 * dpp));
            v = depenserSous(perso, 'pc', bourse, v);
            v = depenserSous(perso, 'pa', bourse, v);
            v = depenserSous(perso, 'po', bourse, v);
            v = depenserSous(perso, 'pp', bourse, v);
            if (v > 0) {
              error("Erreur interne de calcul, il reste " + v + " PP \xE0 d\xE9penser ??", bourse);
              return;
            }
            if (bourse.pc != pc)
              setTokenAttr(perso, 'bourse_pc', bourse.pc, evt, {
                charAttr: true
              });
            if (bourse.pa != pa)
              setTokenAttr(perso, 'bourse_pa', bourse.pa, evt, {
                charAttr: true
              });
            if (bourse.po != po)
              setTokenAttr(perso, 'bourse_po', bourse.po, evt, {
                charAttr: true
              });
            if (bourse.pp != pp)
              setTokenAttr(perso, 'bourse_pp', bourse.pp, evt, {
                charAttr: true
              });
            addEvent(evt);
            afficherRichesse(perso);
            return;
          case 'fixer':
            addEvent(evt);
            setTokenAttr(perso, 'bourse_' + unite, montant, evt, {
              charAttr: true
            });
            afficherRichesse(perso);
            return;
          default:
            if (selected.length > 1) {
              afficherRichesse(perso, msg);
              return;
            }
            var optionsDisplay = {
              chuchote: true,
              image: 'https://www.on6rm.be/wp-content/uploads/2015/08/vignette_2_bourse-argent.png'
            };
            var titre = "Bourse de " + perso.token.get('name');
            var display = startFramedDisplay(playerId, titre, perso, optionsDisplay);
            ajouteLignePieces(perso, display, 'pp', 'Platine', "de platine");
            ajouteLignePieces(perso, display, 'po', 'Or', "d'or");
            ajouteLignePieces(perso, display, 'pa', 'Argent', "d'argent");
            ajouteLignePieces(perso, display, 'pc', 'Cuivre', "de cuivre");
            sendChat('', endFramedDisplay(display));
        }
      });
    });
  }

  //!cof-mot-de-pouvoir-immobilise --lanceur toid
  function motDePouvoirImmobilise(msg) {
    let options = parseOptions(msg);
    let pageId = options.pageId;
    let evt = {
      type: 'Mot de pouvoir'
    };
    addEvent(evt);
    if (options.lanceur) {
      sendPerso(options.lanceur, "prononce un mot avec la Voix d'une puissance sup\xE9rieure. Tous ses ennemis sont immobilis\xE9s et ses alli\xE9s sont galvanis\xE9s.");
      let allies = alliesParPerso[options.lanceur.charId];
      if (allies) {
        let tokens = findObjs({
          _type: 'graphic',
          _subtype: 'token',
          _pageid: pageId,
          layer: 'objects'
        });
        tokens.forEach(function(tok) {
          let ci = tok.get('represents');
          if (ci === '') return;
          if (!allies.has(ci)) return;
          let perso = {
            charId: ci,
            token: tok
          };
          setAttrDuree(perso, 'bonusAttaqueTemp', 1, evt);
        });
      }
    }
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        if (predicateAsBool(perso, 'liberteDAction') ||
          predicateAsBool(perso, 'actionLibre') ||
          (predicateAsInt(perso, 'voieDeLArchange', 1) > 1 && attributeAsBool(perso, 'formeDAnge'))
        ) {
          sendPerso(perso, "reste libre de ses mouvements");
          return;
        }
        setState(perso, 'immobilise', true, evt);
        setAttrDuree(perso, 'immobiliseTemp', 1, evt);
      });
    }, options);
  }

  // Ajoute evt \xE0 l'historique si pr\xE9sent
  // msg n'est pas forc\xE9ment pr\xE9sent
  function nextTurnChargeFantastique(msg, oldTurnOrder) {
    if (oldTurnOrder) Campaign().set('turnorder', oldTurnOrder);
    var cf = stateCOF.chargeFantastique;
    if (cf === undefined) {
      sendChat("Pas de charge fantastique en cours");
      return;
    }
    if (stateCOF.chargeFantastique.activeTokenId && !peutController(msg, persoOfId(stateCOF.chargeFantastique.activeTokenId))) {
      sendPlayer(msg, "ne peut utiliser ce bouton maintenant");
      return;
    }
    var evt = {
      type: "Tour de charge fantastique",
      chargeFantastique: cf
    };
    var tid, perso;
    if (cf.mouvements && cf.mouvements.length > 0) {
      evt.chargeFantastique.mouvements = [...cf.mouvements];
      evt.chargeFantastique.attaques = cf.attaques;
      tid = cf.mouvements.shift();
      perso = persoOfId(tid);
      if (perso === undefined) {
        error("Personnage en charge fantastique manquant", tid);
        return;
      }
      addEvent(evt);
      let playerIds = getPlayerIds(perso);
      let playerId;
      let optionsDisplay = {
        chuchote: 'gm'
      };
      if (playerIds.length > 0) {
        playerId = playerIds[0];
        optionsDisplay.chuchote = true;
      }
      stateCOF.chargeFantastique.activeTokenId = perso.token.id;
      setTokenInitAura(perso);
      var display = startFramedDisplay(playerId, "Charge fantastique", perso, optionsDisplay);
      addLineToFramedDisplay(display, "Phase de mouvement : d\xE9placez votre token en ligne droite");
      addLineToFramedDisplay(display, "puis " + boutonSimple("!cof-next-charge-fantastique", "cliquez ici"));
      sendChat('', endFramedDisplay(display));
      return;
    }
    if (cf.attaques && cf.attaques.length > 0) {
      evt.chargeFantastique.attaques = [...cf.attaques];
      tid = cf.attaques.shift();
      cf.tokenAttaque = tid;
      if (cf.attaques.length === 0) cf.attaques = undefined;
      perso = persoOfId(tid);
      if (perso === undefined) {
        error("Personnage en charge fantastique manquant", tid);
        return;
      }
      addEvent(evt);
      stateCOF.chargeFantastique.activeTokenId = perso.token.id;
      setTokenInitAura(perso);
      turnAction(perso);
      return;
    }
    stateCOF.chargeFantastique = undefined;
  }

  // !cof-charge-fantastique token_id
  function chargeFantastque(msg) {
    var options = parseOptions(msg);
    var cmd = options.cmd;
    if (!cmd || cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-charge-fantastique", cmd);
      return;
    }
    var chevalier = persoOfId(cmd[1], cmd[1], options.pageId);
    if (chevalier === undefined) {
      error("Le token s\xE9lectionn\xE9 ne repr\xE9sente pas un personnage", cmd);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error('pas de token s\xE9lectionn\xE9 pour !cof-charge-fantastique', msg.content);
        return;
      }
      var evt = {
        type: 'Charge fantastique'
      };
      addEvent(evt);
      if (limiteRessources(chevalier, options, 'chargeFantastique', 'charge fantastique', evt)) return;
      sendPerso(chevalier, "m\xE8ne une charge fantastique !");
      initiative(selected, evt);
      stateCOF.chargeFantastique = {};
      var ordreActions = [];
      var chevalierIn;
      iterSelected(selected, function(perso) {
        if (perso.token.id == chevalier.token.id) {
          chevalierIn = true;
          return;
        }
        ordreActions.push({
          init: persoInit(perso, evt),
          perso: perso
        });
      });
      ordreActions.sort(function(p1, p2) {
        if (p1.init < p2.init) return 1;
        if (p1.init > p2.init) return -1;
        // Priorit\xE9 aux joueurs
        // Premier crit\xE8re : la barre de PV des joueurs est li\xE9e
        if (p1.perso.token.get('bar1_link') === '') {
          if (p2.perso.token.get('bar1_link') === '') return 0;
          return 1;
        }
        if (p2.perso.token.get('bar1_link') === '') return -1;
        // Deuxi\xE8me crit\xE8re : les joueurs ont un DV
        let dvA = ficheAttributeAsInt(p1.perso, "DV", 0);
        let dvB = ficheAttributeAsInt(p2.perso, "DV", 0);
        if (dvA === 0) {
          if (dvB === 0) return 0;
          return 1;
        }
        if (dvB === 0) return -1;
        //Entre joueurs, priorit\xE9 \xE0 la plus grosse sagesse
        let sagA = ficheAttributeAsInt(p1.perso, 'sagesse', 10);
        let sagB = ficheAttributeAsInt(p2.perso, 'sagesse', 10);
        if (sagA < sagB) return 1;
        if (sagB > sagA) return -1;
        return 0;
      });
      let mouvements = ordreActions.map(function(p) {
        return p.perso.token.id;
      });
      if (chevalierIn) mouvements.unshift(chevalier.token.id);
      stateCOF.chargeFantastique.mouvements = mouvements;
      stateCOF.chargeFantastique.attaques = [...mouvements];
      nextTurnChargeFantastique();
    }, {
      lanceur: chevalier
    }); //fin du getSelected
  }

  //!cof-prescience token_id
  function utiliserPrescience(msg) {
    let options = parseOptions(msg);
    let cmd = options.cmd;
    if (!cmd || cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-prescience", cmd);
      return;
    }
    var ensorceleur = persoOfId(cmd[1], cmd[1], options.pageId);
    if (ensorceleur === undefined) {
      error("Impossible de trouver le personnage qui utilise prescience", cmd);
      return;
    }
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser prescience qu'en combat");
      return;
    }
    if (stateCOF.prescience === undefined) {
      error("Pas de sauvegarde disponible pour la prescience", stateCOF);
      return;
    }
    var testPrescience =
      testLimiteUtilisationsCapa(ensorceleur, 'prescience', 'combat',
        "ne peut plus utiliser son pouvoir de prescience pendant ce combat",
        "ne peut pas faire de prescience");
    if (testPrescience === undefined) {
      return;
    }
    //On commence par faire les undo
    var evt = lastEvent();
    if (evt === undefined) {
      error("Impossible d'utiliser la prescience car l'historique est vide", cmd);
      return;
    }
    //Au cas o\xF9, on v\xE9rifie que l'\xE9v\xE9nement de d\xE9but de tour est bien pr\xE9sent
    if (!findEvent(stateCOF.prescience.evt.id)) {
      error("Impossible de trouver le d\xE9but du tour dans l'historique.", stateCOF.prescience);
      return;
    }
    while (evt && evt.id != stateCOF.prescience.evt.id) {
      undoEvent();
      evt = lastEvent();
    }
    //Ensuite on remet les tokens en position
    stateCOF.prescience.dernieresPositions.forEach(function(pos) {
      pos.token.set('left', pos.left);
      pos.token.set('top', pos.top);
    });
    //Et enfin, on diminue les utilisations de prescience et on diminue la mana si possible.
    utiliseCapacite(ensorceleur, testPrescience, {});
    //Pas d'undo possible
    //on cherche si un autre personnage dispose de prescience
    var allToks =
      findObjs({
        _type: 'graphic',
        _pageid: stateCOF.combat_pageid,
        _subtype: 'token',
      });
    var prescienceActif = allToks.find(function(tok) {
      var ci = tok.get('represents');
      if (ci === undefined) return false;
      var perso = {
        token: tok,
        charId: ci
      };
      return capaciteDisponible(perso, 'prescience', 'combat');
    });
    if (!prescienceActif) stateCOF.prescience = undefined;
    if (limiteRessources(ensorceleur, options, 'prescience', "lancer un sort de prescience", {})) return;
    setTokenAttr(ensorceleur, 'prescienceUtilisee', true, {});
    initiative([{
      _id: ensorceleur.token.id
    }], {}, true);
    updateNextInit(ensorceleur);
  }

  //Synchronise les tokens de m\xEAme nom entre les cartes
  function multiCartes(msg) {
    let options = parseOptions(msg);
    let enlever = options && options.cmd && options.cmd.length > 1 &&
      options.cmd[1] == 'false';
    getSelected(msg, function(selected, playerId) {
      let evt = {
        type: "Synchronisation des tokens"
      };
      if (selected.length === 0) {
        if (enlever) {
          removeAllAttributes('tokensSynchronises', evt);
          addEvent(evt);
          return;
        }
        sendPlayer(msg, "Aucun token selectionn\xE9 pour !cof-multi-cartes", playerId);
        return;
      }
      addEvent(evt);
      if (enlever) {
        iterSelected(selected, function(perso) {
          sendPlayer(msg, perso.token.get('name') + " n'est plus synchronis\xE9", playerId);
          removeTokenAttr(perso, 'tokensSynchronises', evt);
        });
        return;
      }
      let allTokens = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        layer: 'objects',
      });
      iterSelected(selected, function(perso) {
        let name = perso.token.get('name');
        let left = perso.token.get('left');
        let top = perso.token.get('top');
        let listTokens = [perso.token.id];
        //On cherche les tokens de m\xEAme nom et on les met en m\xEAme position
        allTokens.forEach(function(tok) {
          if (tok.get('represents') != perso.charId) return;
          if (tok.get('name') != name) return;
          if (tok.id == perso.token.id) return;
          tok.set('left', left);
          tok.set('top', top);
          listTokens.push(tok.id);
        });
        if (listTokens.length < 2) {
          sendPlayer(msg, name + " n'a qu'un seul token sur toutes les cartes", playerId);
          return;
        }
        setTokenAttr(perso, 'tokensSynchronises', listTokens.join(), evt);
      });
    });
  }

  function ombreMouvante(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour !cof-ombre-mouvante", playerId);
        return;
      }
      iterSelected(selected, function(perso) {
        doOmbreMouvante(perso, playerId, options);
      });
    });
  }

  function doOmbreMouvante(voleur, playerId, options) {
    const evt = {
      type: "ombre_mouvante",
      action: {
        perso: voleur,
        playerId: playerId,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(voleur, options, 'ombreMouvante', 'dispara\xEEtre dans les ombres', evt)) return;
    let optionsDisplay = {
      secret: options.secret
    };
    let display = startFramedDisplay(playerId, 'Ombre mouvante', voleur, optionsDisplay);
    testCaracteristique(voleur, 'DEX', 10, 'ombreMouvante', options, evt,
      function(tr, explications) {
        let msgRes = "<b>R\xE9sultat :</b> " + tr.texte;
        if (tr.reussite) {
          msgRes += ", " + voleur.token.get('name') + " dispara\xEEt dans les ombres";
          addLineToFramedDisplay(display, msgRes + tr.modifiers);
          let ef = {
            effet: 'invisibleTemp',
            duree: true,
            pasDeMessageDActivation: true
          };
          setEffetTemporaire(voleur, ef, 1, evt, {});
          if (options.fx)
            spawnFx(voleur.token.get('left'), voleur.token.get('top'), options.fx, voleur.token.get('pageid'));
        } else {
          msgRes += ", " + voleur.token.get('name') + " ne r\xE9ussit pas \xE0 se fondre dans les ombres.";
          addLineToFramedDisplay(display, msgRes + tr.rerolls + tr.modifiers);
        }
        explications.forEach(function(m) {
          addLineToFramedDisplay(display, m, 80);
        });
        if (options.messages) {
          options.messages.forEach(function(m) {
            addLineToFramedDisplay(display, m);
          });
        }
        if (display.retarde) {
          addFramedHeader(display, playerId, true);
          sendChat('', endFramedDisplay(display));
          addFramedHeader(display, undefined, 'gm');
          sendChat('', endFramedDisplay(display));
        } else sendChat('', endFramedDisplay(display));
      });
  }

  const attributesWithTokNames = new RegExp('^enveloppe($|_)|^enveloppePar($|_)|^agrippe($|_)|^agrippePar($|_)|^devore($|_)|^devorePar($|_)|^aGobe($|_)|^estGobePar($|_)|^etreinteImmole($|_)|^etreinteImmolePar($|_)|^etreinteScorpion($|_)|^etreinteScorpionPar($|_)|^capitaine($|_)|^suit($|_)|^estSuiviPar($|_)');

  //!cof-reveler-nom [nouveau nom des tokens]
  function revelerNom(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour !cof-reveler-nom", playerId);
        return;
      }
      var nouveauNomToken;
      if (cmd.length > 1) nouveauNomToken = cmd.slice(1).join(' ');
      if (selected.length > 1 && nouveauNomToken) {
        sendPlayer(msg, "Attention, on ne peut s\xE9lectionner qu'un seul token quand on pr\xE9cise le nouveau nom des tokens", playerId);
        return;
      }
      var evt = {
        type: "R\xE9v\xE9lation de nom",
        characterNames: [],
        defaultTokens: [],
        attributes: []
      };
      addEvent(evt);
      var allAttrs = findObjs({
        _type: 'attribute',
      });
      var attrsWithTokNames = allAttrs.filter(function(attr) {
        return attributesWithTokNames.test(attr.get('name'));
      });
      var attrsWithCharNames;
      var treated = new Set(); //On ne veut pas traiter un personnage plus d'une fois.
      iterSelected(selected, function(perso) {
        if (treated.has(perso.charId)) return;
        treated.add(perso.charId);
        var character = getObj('character', perso.charId);
        if (character === undefined) {
          error("Personnage de " + perso.token.get('name') + " perdu", perso);
          return;
        }
        var displayName = ficheAttribute(perso, 'displayname', '@{character_name}');
        var ancienNom;
        var nouveauNom;
        if (displayName == '@{alias}') {
          setFicheAttr(perso, 'displayname', '@{character_name}', evt);
          ancienNom = ficheAttribute(perso, 'alias', '');
          nouveauNom = character.get('name');
          sendChat('', ancienNom + " \xE9tait en r\xE9alit\xE9 " + nouveauNom + " !");
        } else {
          nouveauNom = ficheAttribute(perso, 'alias', '');
          ancienNom = character.get('name');
          if (nouveauNom === '') {
            sendPlayer(msg, ancienNom + " n'a pas d'alias, rien \xE0 r\xE9v\xE9ler.");
            return;
          }
          setFicheAttr(perso, 'alias', '', evt);
          sendChar(perso.charId, "\xE9tait en r\xE9alit\xE9 " + nouveauNom + " !");
          evt.characterNames.push({
            character: character,
            name: ancienNom
          });
          character.set('name', nouveauNom);
          //On change aussi les attributs qui stoquent le nom du personnage
          if (attrsWithCharNames === undefined) {
            attrsWithCharNames = allAttrs.filter(function(attr) {
              return attr.get('name') == 'PVPartagesAvec';
            });
          }
          attrsWithCharNames.forEach(function(attr) {
            if (attr.get('current') == ancienNom) {
              evt.attributes.push({
                attribute: attr,
                current: attr.get('current'),
              });
              attr.set('current', nouveauNom);
            }
          });
        }
        if (!nouveauNomToken) nouveauNomToken = nouveauNom;
        var traitementEnCours;
        character.get('defaulttoken', function(defaultToken) {
          if (traitementEnCours) return;
          traitementEnCours = true;
          var defaultTokenName;
          var defaultTokenToSet;
          if (defaultToken !== '') {
            defaultToken = JSON.parse(defaultToken);
            evt.defaultTokens.push({
              character: character,
              defaultToken: {...defaultToken
              }
            });
            defaultTokenName = defaultToken.name;
            defaultToken.name = nouveauNomToken;
            defaultTokenToSet = true;
          }
          var tokens =
            findObjs({
              _type: 'graphic',
              _subtype: 'token',
              represents: perso.charId
            });
          tokens.forEach(function(tok) {
            var tokName = tok.get('name');
            if (defaultTokenToSet) {
              defaultTokenToSet = false;
              setDefaultTokenFromSpec(character, defaultToken, tok);
            }
            var tokAttr;
            if (tok.get('bar1_link') === '') {
              if (defaultTokenName) {
                if (tokName.startsWith(defaultTokenName)) {
                  var suffix = tokName.substring(defaultTokenName.length);
                  var localTokName = nouveauNomToken + suffix;
                  setToken(tok, 'name', localTokName, evt);
                  tokAttr = tokAttr || findObjs({
                    _type: 'attribute',
                    _characterid: perso.charId
                  });
                  var endName = "_" + tokName;
                  tokAttr.forEach(function(attr) {
                    var attrName = attr.get('name');
                    if (attrName.endsWith(endName)) {
                      evt.attributes.push({
                        attribute: attr,
                        current: attr.get('current'),
                        name: attrName
                      });
                      var posEnd = attrName.length - tokName.length;
                      attrName = attrName.substring(0, posEnd) + localTokName;
                      attr.set('name', attrName);
                    }
                  });
                  attrsWithTokNames = attrsWithTokNames.filter(function(attr) {
                    var sp = splitIdName(attr.get('current'));
                    if (sp === undefined) return false;
                    if (sp.id == tok.id || sp.name == tokName) {
                      evt.attributes.push({
                        attribute: attr,
                        current: attr.get('current'),
                      });
                      attr.set('current', sp.id + ' ' + localTokName);
                      return false;
                    } else {
                      return true;
                    }
                  });
                } else {
                  sendPlayer(msg, "Pas de renommage de " + tokName, playerId);
                }
              } else {
                sendPlayer(msg, "Pas de token par d\xE9faut pour " + tokName + ", ce n'est pas encore g\xE9r\xE9 dans !cof-reveler-nom", playerId);
              }
            } else {
              if (defaultTokenName && tokName == defaultTokenName) {
                setToken(tok, 'name', nouveauNomToken, evt);
                attrsWithTokNames = attrsWithTokNames.filter(function(attr) {
                  var sp = splitIdName(attr.get('current'));
                  if (sp === undefined) return false;
                  if (sp.id == tok.id || sp.name == tokName) {
                    evt.attributes.push({
                      attribute: attr,
                      current: attr.get('current'),
                    });
                    attr.set('current', sp.id + ' ' + nouveauNomToken);
                    return false;
                  } else {
                    return true;
                  }
                });
              } else {
                sendPlayer(msg, "Pas de renommage de " + tokName, playerId);
              }
            }
          });
        });
      });
    });
  }

  function tenebresMagiques(msg) {
    var cmd = msg.content.split(' ');
    cmd = cmd.filter(function(c) {
      return c.trim() !== '';
    });
    var b = true;
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'true':
        case 'oui':
        case 'noir':
          b = true;
          break;
        case 'non':
        case 'sortir':
        case 'false':
        case 'fin':
          b = false;
          break;
        default:
          error("Option de !cof-tenebres-magiques non reconnue", cmd);
          return;
      }
    }
    if (b) {
      if (stateCOF.tenebresMagiques) {
        sendPlayer('GM', "Les personnages sont d\xE9j\xE0 dans des t\xE9n\xE8bres magiques");
        return;
      }
      sendPlayer('GM', "Les personnages entrent dans des t\xE9n\xE8bres magiques");
      stateCOF.tenebresMagiques = {};
    } else {
      stateCOF.tenebresMagiques = undefined;
      sendPlayer('GM', "Les personnages sortent des t\xE9n\xE8bres magiques");
    }
  }

  function fioleDeLumiere(msg) {
    var cmd = msg.content.split(' ');
    var tm = stateCOF.tenebresMagiques;
    if (tm === undefined) {
      sendPlayer(msg, "Pas de t\xE9n\xE8bres magiques, pas d'effet de fiole");
      return;
    }
    cmd = cmd.filter(function(c) {
      return c.trim() !== '';
    });
    if (cmd.length < 2) {
      error("Il faut un argument \xE0 !cof-fiole-de-lumiere", cmd);
      return;
    }
    var distance = parseInt(cmd[1]);
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Aucun personnage s\xE9lectionn\xE9", cmd);
        return;
      }
      if (selected.length > 1) {
        error("Il n'y a qu'une seule fiole de lumi\xE8re", cmd);
        return;
      }
      var evt = {
        type: 'fioleDeLumiere'
      };
      addEvent(evt);
      iterSelected(selected, function(perso) {
        if (cmd[1] == 'fin' || isNaN(distance) || distance < 0) {
          tm.fioleDeLumiere = undefined;
          var pageId = perso.token.get('pageid');
          eteindreUneLumiere(perso, pageId, undefined, 'fioleDeLumiere', evt);
        } else {
          tm.fioleDeLumiere = {
            porteur: perso,
            distance: distance
          };
          var dimRadius = '';
          if (cmd.length > 3) {
            dimRadius = parseInt(cmd[3]);
            if (isNaN(dimRadius)) {
              error("La distance de vue de la lumi\xE8re assombrie doit \xEAtre un nombre", cmd[3]);
              dimRadius = '';
            }
          }
          ajouteUneLumiere(perso, 'fioleDeLumiere', distance, dimRadius, evt);
        }
      });
    });
  }

  //!cof-agripper-de-demon @{selected|token_id} @{target|token_id}
  function agripperDeDemon(msg) {
    var cmd = msg.content.split(' ');
    cmd = cmd.filter(function(c) {
      return c !== '';
    });
    if (cmd.length < 3) {
      error("Il faut sp\xE9cifier un attaquant et un d\xE9fenseur pour !cof-agripper-de-demon", cmd);
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    var defenseur = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-agripper-de-demon doit \xEAtre un token valide", cmd[1]);
      return;
    }
    if (defenseur === undefined) {
      error("Le deuxi\xE8me argument de !cof-agripper-de-demon doit \xEAtre un token valide", cmd[2]);
      return;
    }
    if (attributeAsBool(defenseur, 'armureDEau')) {
      sendChat("L'armure d'eau emp\xEAche " + defenseur.token.get('name') + " d'\xEAtre aggrip\xE9");
      return;
    }
    var evt = {
      type: "Agripper (d\xE9mon)"
    };
    var options = {
      pasDeDmg: true
    };
    if (cmd.length > 3) options.labelArmeAttaquant = cmd[3];
    var playerId = getPlayerIdFromMsg(msg);
    attaqueContactOpposee(playerId, attaquant, defenseur, evt, options,
      function(res, display, explications) {
        if (res.succes) {
          addLineToFramedDisplay(display, attaquant.tokName + " agrippe fermement " + defenseur.tokName);
          setTokenAttr(attaquant, 'agrippe', defenseur.token.id + ' ' + defenseur.tokName, evt);
          setTokenAttr(defenseur, 'estAgrippePar', attaquant.token.id + ' ' + attaquant.tokName, evt);
          setTokenAttr(defenseur, 'agrippeParUnDemon', true, evt);
        } else {
          addLineToFramedDisplay(display, defenseur.tokName + " \xE9chappe \xE0 la tentative de saisie.");
        }
        explications.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
        sendChat("", endFramedDisplay(display));
        addEvent(evt);
      });
  }

  function deleteAttribute(attr, evt) {
    evt.deletedAttributes.push(attr);
    attr.remove();
  }

  function changeAttributeName(attr, nom, evt) {
    evt.attributes.push({
      attribute: attr,
      name: nom
    });
    attr.set('name', nom);
  }

  function ajouteCompetence(perso, comp, carac, val, evt) {
    let prefix = 'repeating_competences_' + generateRowID() + '_comp_';
    let attrSpec = {
      characterid: perso.charId
    };
    attrSpec.name = prefix + 'nom';
    attrSpec.current = comp;
    let attr = createObj('attribute', attrSpec);
    evt.attributes.push({
      attribute: attr
    });
    attrSpec.name = prefix + 'bonus';
    attrSpec.current = val;
    let attrBonus = createObj('attribute', attrSpec);
    evt.attributes.push({
      attribute: attrBonus
    });
    attrSpec.name = prefix + 'bonusTotal';
    attr = createObj('attribute', attrSpec);
    evt.attributes.push({
      attribute: attr
    });
    attrSpec.name = prefix + 'carac';
    attrSpec.current = carac;
    attr = createObj('attribute', attrSpec);
    evt.attributes.push({
      attribute: attr
    });
    if ((carac == 'DEX' && comp != 'crochetage' && comp != 'd\xE9samor\xE7age') ||
      (carac == 'CON' && comp == 'survie') ||
      comp == 'natation' || comp == 'escalade') {
      attrSpec.name = prefix + 'malus';
      attrSpec.current = 'armure';
      attr = createObj('attribute', attrSpec);
      evt.attributes.push({
        attribute: attr
      });
      attrBonus.setWithWorker('current', val);
      attr.setWithWorker('current', 'armure');
    } else if (comp == 'perception' || comp == 'vigilance') {
      attrSpec.name = prefix + 'malus';
      attrSpec.current = 'casque';
      attr = createObj('attribute', attrSpec);
      evt.attributes.push({
        attribute: attr
      });
      attrBonus.setWithWorker('current', val);
      attr.setWithWorker('current', 'casque');
    }
  }

  const regAtkPF1 = new RegExp("^(repeating_npcatk-(melee|ranged|special)_[^_]*_)(.*)$");
  const regAbilitiesPF1 = new RegExp("^(repeating_abilities_[^_]*_)(.*)$");
  const regFeatsPF1 = new RegExp("^(repeating_feats_[^_]*_)(.*)$");

  //Transforme les personnages des tokens de Pathfinder 1 en COF
  //Suppose qu'il s'agit d'un PNJ
  function translateFromPathfinder1(msg) {
    let treatedChars = new Set();
    const optAttr = {
      charAttr: true
    };
    getSelected(msg, function(selected, playerId) {
      let evt = {
        type: 'Tranformation depuis Pathfinder 1',
        deletedAttributes: [],
        attributes: [],
        defaultTokens: []
      };
      addEvent(evt);
      iterSelected(selected, function(perso) {
        if (treatedChars.has(perso.charId)) return;
        treatedChars.add(perso.charId);
        if (!charAttributeAsBool(perso, 'ac')) {
          sendPlayer(msg, perso.token.get('name') + " d\xE9j\xE0 converti (pas d'attribut ac)");
          return;
        }
        let setAttr = function(nom, valeur) {
          setTokenAttr(perso, nom, valeur, evt, optAttr);
        };
        let attributes = findObjs({
          _type: 'attribute',
          _characterid: perso.charId,
        });
        setAttr('type_personnage', 'PNJ');
        setAttr('tab', 'carac. pnj');
        let attributsIgnores = '';
        let predicats = '';
        let capacites = '';
        let notes = '';
        let equip_div = '';
        let dexterite = 10;
        let mod_dex = 0;
        let init = 0;
        let rd = '';
        let race = '';
        let attaques = {};
        let abilities = {};
        let feats = {};
        let def;
        attributes.forEach(function(attr) {
          let nom = attr.get('name');
          switch (nom) {
            case 'ac':
              def = parseInt(attr.get('current'));
              changeAttributeName(attr, 'pnj_def', evt);
              return;
            case 'class':
              let c = attr.get('current');
              if (c.startsWith('Female ')) {
                setFicheAttr(perso, 'sexe', 'F', evt);
                c = c.substring(7).trim();
                attr.set('current', c);
              } else if (c.startsWith('Male ')) {
                setFicheAttr(perso, 'sexe', 'M', evt);
                c = c.substring(5).trim();
                attr.set('current', c);
              }
              if (c.startsWith('goblin ')) {
                race = "Gobelin";
                c = c.substring(7).trim();
                attr.set('current', c);
              } else if (c.startsWith('human')) {
                race = "Humain";
                c = c.substring(6).trim();
                attr.set('current', c);
              }
              changeAttributeName(attr, 'profil', evt);
              return;
            case 'defensive_abilities':
              let da = attr.get('current');
              let nonPrisEnCompte = '';
              da.split(',').forEach(function(d) {
                d = d.trim();
                if (d === '') return;
                switch (d) {
                  case 'incorporeal':
                    predicats += 'immunite_nonMagique ';
                    return;
                  default:
                    if (d.startsWith('channel resistance')) {} else {
                      log("Capacit\xE9 d\xE9fensive " + d + " non connue");
                    }
                    if (nonPrisEnCompte === '')
                      nonPrisEnCompte = 'Capacit\xE9s d\xE9fensives : ' + d;
                    else nonPrisEnCompte += ', ' + d;
                }
              });
              if (nonPrisEnCompte !== '') notes += nonPrisEnCompte + '\n';
              return;
            case 'hp':
              changeAttributeName(attr, 'PV', evt);
              return;
            case 'hp_notes':
              let hpNote = attr.get('current');
              if (hpNote.startsWith('fast healing ')) {
                let n = parseInt(hpNote.substring(13));
                if (!isNaN(n) && n > 0) {
                  setAttr('vitaliteSurnaturelle', n);
                  let index = 13 + ('' + n).length;
                  hpNote = hpNote.substring(index);
                }
              }
              if (hpNote === '') deleteAttribute(attr, evt);
              else attributsIgnores += 'hp_notes : ' + hpNote + ' .\n';
              return;
            case 'immune':
              let immunites = attr.get('current').split(' ');
              let immunitesNonTraitees = '';
              immunites.forEach(function(i) {
                i = i.trim();
                if (i === '') return;
                switch (i) {
                  case 'acid':
                    predicats += 'immunite_acide ';
                    return;
                  case 'cold':
                    predicats += 'immunite_froid ';
                    return;
                  case 'disease':
                    predicats += 'immunite_maladie ';
                    return;
                  case 'electricity':
                    predicats += 'immunite_electrique ';
                    return;
                  case 'fire':
                    predicats += 'immunite_feu ';
                    return;
                  case 'mind-affecting':
                    predicats += 'sansEsprit';
                    return;
                  case 'paralysis':
                    predicats += 'immunite_paralyse';
                    return;
                  case 'poison':
                    predicats += 'immunite_poison';
                    return;
                  case 'undead':
                  case 'traits':
                  case 'effects':
                    return;
                  default:
                    log("Immunit\xE9 \xE0 " + i + " non trait\xE9e");
                    immunitesNonTraitees += i + ' ';
                }
              });
              if (immunitesNonTraitees !== '') {
                log("Immunit\xE9s non trait\xE9es : " + immunitesNonTraitees);
                attributsIgnores += 'immune : ' + immunitesNonTraitees + '.\n';
              }
              deleteAttribute(attr, evt);
              return;
            case 'resist':
              let resistances = attr.get('current').split(', ');
              let resistancesNonTraitees = '';
              resistances.forEach(function(r) {
                r = r.trim();
                if (r === '') return;
                let res = r.split(' ');
                if (res.length != 2) {
                  resistancesNonTraitees += r + ', ';
                  return;
                }
                let resVal = parseInt(res[1]);
                if (isNaN(resVal) || resVal < 1) {
                  resistancesNonTraitees += r + ', ';
                  return;
                }
                switch (res[0]) {
                  case 'acid':
                    if (rd === '') rd = 'acide:' + resVal;
                    else rd += ', acide:' + resVal;
                    return;
                  case 'cold':
                    if (rd === '') rd = 'froid:' + resVal;
                    else rd += ', froid:' + resVal;
                    return;
                  case 'disease':
                    if (rd === '') rd = 'maladie:' + resVal;
                    else rd += ', maladie:' + resVal;
                    return;
                  case 'electricity':
                    if (rd === '') rd = 'electrique:' + resVal;
                    else rd += ', electrique:' + resVal;
                    return;
                  case 'fire':
                    if (rd === '') rd = 'feu:' + resVal;
                    else rd += ', feu:' + resVal;
                    return;
                  case 'poison':
                    if (rd === '') rd = 'poison:' + resVal;
                    else rd += ', poison:' + resVal;
                    return;
                  default:
                    log("R\xE9sistance \xE0 " + res[0] + " non trait\xE9e");
                    resistancesNonTraitees += r + ', ';
                }
              });
              if (resistancesNonTraitees !== '') {
                log("Resistances non trait\xE9es : " + resistancesNonTraitees);
                attributsIgnores += 'resist : ' + resistancesNonTraitees + '.\n';
              }
              deleteAttribute(attr, evt);
              return;
            case 'initiative':
              init = parseInt(attr.get('current'));
              if (isNaN(init)) init = 0;
              deleteAttribute(attr, evt);
              return;
            case 'languages':
              capacites += 'Langues: ' + attr.get('current') + '\n';
              deleteAttribute(attr, evt);
              return;
            case 'npc_cr':
              changeAttributeName(attr, 'niveau', evt);
              return;
            case 'npc_alignment':
              if (attr.get('current').includes('E')) predicats += 'mauvais ';
              deleteAttribute(attr, evt);
              return;
            case 'npc_dr':
              let rdn = attr.get('current');
              if (rdn) {
                rdn = '' + rdn;
                rdn = rdn.replace('bludgeoning', 'contondant').replace('slashing', 'tranchant').replace('piercing', 'percant').replace('silver', 'argent').replace('magic', 'magique');
                if (rd === '') rd = rdn;
                else rd += ', ' + rdn;
              }
              deleteAttribute(attr, evt);
              return;
            case 'npc_type':
              let npcType = attr.get('current');
              switch (npcType.split(' ')[0]) {
                case 'aberration':
                  predicats += 'aberration ';
                  break;
                case 'humanoid':
                  predicats += 'humanoide ';
                  break;
                case 'animal':
                  predicats += 'animal ';
                  break;
                case 'construct':
                  predicats += 'nonVivant ';
                  break;
                case 'fey':
                  predicats += 'f\xE9e ';
                  break;
                case 'outsider':
                  predicats += 'ext\xE9rieur ';
                  break;
                case 'undead':
                  predicats += 'nonVivant mortVivant ';
                  break;
                case 'vermin':
                  predicats += 'insecte ';
                  break;
                default:
                  log("npc_type non reconnue : " + npcType);
                  if (race === '') race = npcType;
              }
              deleteAttribute(attr, evt);
              return;
            case 'size':
              let taille = '';
              switch (attr.get('current')) {
                case 'fine':
                case 'diminutive':
                  taille = 'minuscule';
                  break;
                case 'tiny':
                  taille = 'tr\xE8s petit';
                  break;
                case 'small':
                  taille = 'petite';
                  break;
                case 'medium':
                  break;
                case 'large':
                  taille = 'grand';
                  break;
                case 'huge':
                  taille = '\xE9norme';
                  break;
                case 'gargantuan':
                case 'colossal':
                  taille = 'colossal';
                  break;
                default:
                  taille = attr.get('current');
              }
              if (taille !== '') setAttr('taille', taille);
              deleteAttribute(attr, evt);
              return;
            case 'tactics':
              let tactics = attr.get('current');
              if (tactics !== '') notes += 'Tactiques : ' + tactics + '\n';
              deleteAttribute(attr, evt);
              return;
            case 'background':
              let background = attr.get('current');
              if (background !== '') notes += 'Background : ' + background + '\n';
              deleteAttribute(attr, evt);
              return;
            case 'treasure':
            case 'combat_gear':
              let gear = attr.get('current');
              if (gear != 'none' && gear !== '') equip_div += gear + '\n';
              deleteAttribute(attr, evt);
              return;
            case 'charisma':
              changeAttributeName(attr, 'charisme', evt);
              return;
            case 'charisma_mod':
              changeAttributeName(attr, 'pnj_cha', evt);
              return;
            case 'constitution':
              return;
            case 'constitution_mod':
              changeAttributeName(attr, 'pnj_con', evt);
              return;
            case 'dexterity':
              dexterite = parseInt(attr.get('current'));
              changeAttributeName(attr, 'dexterite', evt);
              return;
            case 'dexterity_mod':
              mod_dex = parseInt(attr.get('current'));
              changeAttributeName(attr, 'pnj_dex', evt);
              return;
            case 'intelligence':
              return;
            case 'intelligence_mod':
              changeAttributeName(attr, 'pnj_int', evt);
              return;
            case 'strength':
              changeAttributeName(attr, 'force', evt);
              return;
            case 'strength_mod':
              changeAttributeName(attr, 'pnj_for', evt);
              return;
            case 'wisdom':
              changeAttributeName(attr, 'sagesse', evt);
              return;
            case 'wisdom_mod':
              changeAttributeName(attr, 'pnj_sag', evt);
              return;
            case 'acrobatics':
              ajouteCompetence(perso, 'acrobatie', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'appraise':
              ajouteCompetence(perso, 'estimation', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'bluff':
              ajouteCompetence(perso, 'mentir', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'climb':
              ajouteCompetence(perso, 'escalade', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'craft':
              ajouteCompetence(perso, 'artisanat', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'diplomacy':
              ajouteCompetence(perso, 'diplomatie', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'disable_device':
              ajouteCompetence(perso, 'd\xE9samor\xE7age', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'disguise':
              ajouteCompetence(perso, 'd\xE9guisement', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'escape_artist':
              ajouteCompetence(perso, '\xE9vasion', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'fly':
              ajouteCompetence(perso, 'vol', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'handle_animal':
              ajouteCompetence(perso, 'dressage', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'heal':
              ajouteCompetence(perso, 'soigner', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'intimidate':
              ajouteCompetence(perso, 'intimidation', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_arcana':
              ajouteCompetence(perso, 'connaissance (arcanes)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_dungeoneering':
              ajouteCompetence(perso, 'connaissance (donjons)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_engineering':
              ajouteCompetence(perso, 'connaissance (ing\xE9ni\xE9rie)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_geography':
              ajouteCompetence(perso, 'connaissance (g\xE9ographie)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_history':
              ajouteCompetence(perso, 'connaissance (histoire)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_local':
              ajouteCompetence(perso, 'connaissance (local)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_nature':
              ajouteCompetence(perso, 'connaissance (nature)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_nobility':
              ajouteCompetence(perso, 'connaissance (noblesse)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_planes':
              ajouteCompetence(perso, 'connaissance (plans)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_religion':
              ajouteCompetence(perso, 'connaissance (religion)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'linguistics':
              ajouteCompetence(perso, 'linguistique', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'perception':
              ajouteCompetence(perso, 'perception', 'SAG', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'perform':
              ajouteCompetence(perso, 'arts', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'profession':
              ajouteCompetence(perso, 'profession', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'ride':
              ajouteCompetence(perso, '\xC9quitation', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'sense_motive':
              ajouteCompetence(perso, 'psychologie', 'SAG', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'sleight_of_hand':
              ajouteCompetence(perso, 'pick-pocket', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'spellcraft':
              ajouteCompetence(perso, 'sortil\xE8ges', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'stealth':
              ajouteCompetence(perso, 'discr\xE9tion', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'survival':
              ajouteCompetence(perso, 'survie', 'SAG', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'swim':
              ajouteCompetence(perso, 'natation', 'FOR', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'use_magic_device':
              ajouteCompetence(perso, 'objets magiques', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'version':
              evt.attributes.push({
                attribute: attr,
                current: versionFiche
              });
              attr.set('current', versionFiche);
              return;
            case 'whispertype':
              if (attr.get('current') == '/w gm') {
                changeAttributeName(attr, 'jets_caches', evt);
              } else {
                deleteAttribute(attr, evt);
              }
              return;
            case 'scriptVersion':
            case 'bab':
            case 'environment':
            case 'skills_racial_modifiers':
            case 'fortitude':
            case 'reflex':
            case 'will': //On n'y touche pas pour l'instant. \xC0 voir plus tard
              let x = attr.get('current');
              if (x === undefined || x === '') deleteAttribute(attr, evt);
              return;
            case 'ac_ability_primary':
            case 'ac_ability_maximum':
            case 'ac_flatfooted':
            case 'ac_notes':
            case 'ac_touch':
            case 'alignment':
            case 'ask_modifier':
            case 'ask_atk_modifier':
            case 'ask_dmg_modifier':
            case 'ask_whisper':
            case 'ask_public_roll':
            case 'ask_whisper_roll':
            case 'bab_multi':
            case 'caster1_dc_level_0':
            case 'class_favored':
            case 'class1_level':
            case 'cmb_mod':
            case 'cmd_mod':
            case 'encumbrance':
            case 'encumbrance_ability_maximum':
            case 'encumbrance_drag_push':
            case 'encumbrance_lift_head':
            case 'encumbrance_lift_ground':
            case 'encumbrance_load_light':
            case 'encumbrance_load_medium':
            case 'encumbrance_load_heavy':
            case 'encumbrance_run_factor':
            case 'encumbrance_size':
            case 'fob_multi':
            case 'hd':
            case 'hd_roll':
            case 'level':
            case 'npc':
            case 'npc_speed':
            case 'npcdrop_name':
            case 'npcdrop_category':
            case 'npcdrop_data':
            case 'options-flag-npc':
            case 'build-flag-npc':
            case 'npc_fromcompendium':
            case 'armor_spell_failure':
            case 'npc_icon_climate':
            case 'npc_icon_terrain':
            case 'npc_icon_type':
            case 'npc_expansion':
            case 'npc_xp':
            case 'organization':
            case 'senses':
            case 'size_display':
            case 'space':
            case 'speed':
            case 'spell_flag':
            case 'spellabilities_flag':
            case 'sq':
            case 'xp':
            case 'l1mancer_status': //Attributs ignor\xE9s
              deleteAttribute(attr, evt);
              return;
            default:
              if (nom.endsWith('_display') || nom.endsWith('_flag') ||
                nom.endsWith('half_mod')) {
                deleteAttribute(attr, evt);
                return;
              }
              let m = regAtkPF1.exec(nom);
              if (m) {
                attaques[m[1]] = attaques[m[1]] || {};
                attaques[m[1]][m[3]] = attr.get('current');
                deleteAttribute(attr, evt);
                return;
              }
              m = regAbilitiesPF1.exec(nom);
              if (m) {
                abilities[m[1]] = abilities[m[1]] || {};
                abilities[m[1]][m[2]] = attr.get('current');
                deleteAttribute(attr, evt);
                return;
              }
              m = regFeatsPF1.exec(nom);
              if (m) {
                feats[m[1]] = feats[m[1]] || {};
                feats[m[1]][m[2]] = attr.get('current');
                deleteAttribute(attr, evt);
                return;
              }
              let v = attr.get('current');
              if (v && ('' + v).trim() !== '') {
                attributsIgnores += nom + ' : ' + v;
                let max = attr.get('max');
                if (max) attributsIgnores += ' , ' + max;
                attributsIgnores += ' .\n';
              }
              deleteAttribute(attr, evt);
          }
        });
        let maxAttackLabel = 0;
        for (let pref in attaques) {
          let attaque = attaques[pref];
          log(attaque);
          let nomAttaque = attaque.atkname || 'Attaque';
          if (nomAttaque.startsWith('favored enemy ')) {
            let i = nomAttaque.indexOf('(');
            let j = nomAttaque.indexOf(')');
            if (i < 1 || i > j) {
              notes += nomAttaque + '\n';
            } else {
              let ennemis = nomAttaque.substring(i + 1, j).split(' ');
              let ennemiJure = '';
              let pasDEnnemi = true;
              for (let e in ennemis) {
                e = e.trim();
                if (e === '') continue;
                switch (e) {
                  case 'goblinoids':
                    if (pasDEnnemi) {
                      ennemiJure = 'gobelin';
                      pasDEnnemi = false;
                    } else ennemiJure += ', gobelin';
                    break;
                  case 'elves':
                    if (pasDEnnemi) {
                      ennemiJure = 'elfe';
                      pasDEnnemi = false;
                    } else ennemiJure += ', elfe';
                    break;
                  default:
                    if (!e.startsWith('+')) {
                      log("Ennemi jur\xE9 non reconnu : " + e);
                    }
                }
              }
              if (ennemiJure !== '') setAttr('ennemiJure', ennemiJure);
              else notes += nomAttaque + '\n';
            }
            continue;
          } else if (nomAttaque.startsWith("weapon training (")) {
            continue;
          }
          let prefix = 'repeating_pnjatk_' + generateRowID() + '_arme';
          createObj('attribute', {
            _characterid: perso.charId,
            name: prefix + 'nom',
            current: nomAttaque
          });
          let spec = '';
          let options = '';
          for (let field in attaque) {
            switch (field) {
              case 'atkmod':
                createObj('attribute', {
                  _characterid: perso.charId,
                  name: prefix + 'atk',
                  current: attaque.atkmod
                });
                break;
              case 'atkcritrange':
                createObj('attribute', {
                  _characterid: perso.charId,
                  name: prefix + 'crit',
                  current: attaque.atkcritrange
                });
                break;
              case 'dmgbase':
                let dm = parseDmg(attaque.dmgbase);
                if (dm) {
                  if (dm.nbDe)
                    createObj('attribute', {
                      _characterid: perso.charId,
                      name: prefix + 'dmnbde',
                      current: dm.nbDe
                    });
                  if (dm.dice != 4)
                    createObj('attribute', {
                      _characterid: perso.charId,
                      name: prefix + 'dmde',
                      current: dm.dice
                    });
                  if (dm.bonus)
                    createObj('attribute', {
                      _characterid: perso.charId,
                      name: prefix + 'dm',
                      current: dm.bonus
                    });
                }
                break;
              case 'dmgtype':
                let types = attaque.dmgtype.split('; ');
                let typeInconnu = true;
                for (let t of types) {
                  switch (t) {
                    case 'piercing':
                      if (typeInconnu) {
                        createObj('attribute', {
                          _characterid: perso.charId,
                          name: prefix + 'typedegats',
                          current: 'percant'
                        });
                        typeInconnu = false;
                      }
                      break;
                    case 'bludgeoning':
                      if (typeInconnu) {
                        createObj('attribute', {
                          _characterid: perso.charId,
                          name: prefix + 'typedegats',
                          current: 'contondant'
                        });
                        typeInconnu = false;
                      }
                      break;
                    case 'slashing':
                      typeInconnu = false;
                      break;
                    default:
                      spec += t + ' ';
                  }
                }
                break;
              case 'atkrange':
                let range = parseInt(attaque.atkrange);
                if (isNaN(range) || range < 0) range = 1;
                else range = Math.floor(range / 2);
                createObj('attribute', {
                  _characterid: perso.charId,
                  name: prefix + 'portee',
                  current: range
                });
                break;
              case 'dmgcritmulti':
                let cm = parseInt(attaque.dmgcritmulti);
                if (!isNaN(cm) && cm > 2) {
                  options += '--incrCritCoef ' + (cm - 2) + ' ';
                }
                break;
              case 'atkname': //d\xE9j\xE0 trait\xE9 plus haut
              case 'options-flag':
              case 'dmgflag':
              case 'dmg2type':
              case 'atkdisplay':
              case 'multipleatk':
              case 'atkmod2':
                break;
              default:
                spec += field + ' : ' + attaque[field];
            }
          }
          if (spec)
            createObj('attribute', {
              _characterid: perso.charId,
              name: prefix + 'spec',
              current: spec
            });
          if (options)
            createObj('attribute', {
              _characterid: perso.charId,
              name: prefix + 'options',
              current: options
            });
          createObj('attribute', {
            _characterid: perso.charId,
            name: prefix + 'optflag',
            current: 'on'
          });
          maxAttackLabel++;
          createObj('attribute', {
            _characterid: perso.charId,
            name: prefix + 'label',
            current: maxAttackLabel
          });
        }
        for (let pref in abilities) {
          let ab = abilities[pref];
          if (ab.name) notes += ab.name + ' : ';
          if (ab.description) notes += ab.description + '\n';
        }
        for (let pref in feats) {
          let feat = feats[pref];
          switch (feat.name) {
            case undefined:
              continue;
            case 'Improved Initiative':
            case 'Toughness':
            case 'Weapon Finesse':
            case 'Dodge':
            case 'Combat Casting':
            case 'Brew Potion':
              continue;
            case 'Defect Arrows':
              predicats += 'paradeDeProjectiles ';
              break;
            case 'Point-Blank Shot':
              predicats += 'tirPrecis:1 ';
              break;
            case 'Iron Will':
              predicats += 'bonusSagesseMagie:2 ';
              break;
            default:
              if (feat.name.startsWith('Weapon Focus (')) continue;
              if (feat.name.startsWith('Weapon Specialization (')) continue;
              notes += feat.name + ' : ';
              if (feat.benefits) notes += feat.benefits + '\n';
              else if (feat.description) notes += feat.description + '\n';
              attributsIgnores += 'Feat ' + feat.name + ' : {';
              for (let field in feat) {
                if (field == 'name') continue;
                attributsIgnores += ' ' + field + ' : ' + feat[field] + ',';
              }
              attributsIgnores += '} .\n';
          }
        }
        if (maxAttackLabel > 0) setAttr('max_attack_label', maxAttackLabel);
        //Puis on met les attributs n\xE9cessaires
        if (attributsIgnores !== '')
          setAttr('Attributs Pathfinder', attributsIgnores);
        if (predicats !== '') setAttr('predicats_script', predicats);
        if (capacites !== '') setAttr('capacites_pnj', capacites);
        if (notes !== '') setAttr('notes', notes);
        if (equip_div !== '') setAttr('equip_div', equip_div);
        if (rd !== '') setAttr('RDS', rd);
        if (race !== '') setAttr('race', race);
        setTokenAttr(perso, 'scriptVersion', 'true', evt, {
          charAttr: true,
          maxVal: stateCOF.version
        });
        let initiative = dexterite + init - mod_dex;
        if (isNaN(initiative)) initiative = 10 + 2 * init;
        setAttr('pnj_init', initiative);
        // N\xE9cessaire pour \xE9viter que les sheetworkers re-calculent init et def
        if (initiative != dexterite) setAttr('INIT_DIV', initiative - dexterite);
        if (def != 10 + mod_dex) setAttr('DEFDIV', def - 10 - mod_dex);
        //Finalement, on change le token par d\xE9faut
        let acAttr = perso.token.get('bar2_link');
        affectToken(perso.token, 'bar2_link', acAttr, evt);
        perso.token.set('bar2_link', '');
        let ac = perso.token.get('bar2_value');
        affectToken(perso.token, 'bar2_value', ac, evt);
        perso.token.set('bar2_value', '');
        let character = getObj('character', perso.charId);
        if (character) {
          let defaultToken = JSON.parse(JSON.stringify(perso.token));
          evt.defaultTokens.push({
            character: character,
            defaultToken: defaultToken
          });
          setDefaultTokenForCharacter(character, perso.token);
          sendChat('COFantasy', "/w gm traduction de " + character.get('name') + " vers COF");
        } else {
          sendChat('COFantasy', "/w gm traduction de " + perso.token.get('name') + " vers COF, mais personnage introuvable");
        }
      });
    });
  }

  //!cof-canaliser [positif|negatif] --soin expr --dm expr
  function canaliser(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Il manque le type de canalisation", msg.content);
      return;
    }
    let positif = true;
    if (cmd[1] === 'false' || cmd[1] === 'negatif' || cmd[1] === 'n\xE9gatif')
      positif = false;
    if (options.soin === undefined && options.dm === undefined) {
      sendPlayer(msg, "Rien \xE0 canaliser. Il faut pr\xE9ciser un montant de soins ou de d\xE9g\xE2ts");
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length != 1) {
        sendPlayer(msg, "Il faut s\xE9lectionner un personnage", playerId);
        return;
      }
      let token = getObj('graphic', selected[0]._id);
      if (token === undefined) {
        error("Token non reconnu", selected);
        return;
      }
      let charId = token.get('represents');
      if (charId === undefined || charId === '') {
        error("Le token ne repr\xE9sente pas un personnage", token);
        return;
      }
      let pretre = {
        token: token,
        charId: charId
      };
      let evt = {
        type: 'canalisation'
      };
      addEvent(evt);
      if (limiteRessources(pretre, options, 'canalisation', 'canalisation', evt)) {
        return;
      }
      let display = startFramedDisplay(playerId, "Canalisation", pretre);
      let pageId = token.get('pageid');
      let page = getObj('page', pageId);
      let murs = getWalls(page, pageId);
      let pc;
      if (murs) {
        pc = {
          x: token.get('left'),
          y: token.get('top')
        };
      }
      let allToks =
        findObjs({
          _type: "graphic",
          _pageid: pageId,
          _subtype: 'token',
          layer: 'objects'
        });
      let cibles = [];
      allToks.forEach(function(obj) {
        let objCharId = obj.get('represents');
        if (objCharId === '') return;
        if (obj.get('bar1_max') == 0) return; // jshint ignore:line
        let cible = {
          token: obj,
          charId: objCharId
        };
        if (getState(cible, 'mort')) return; //pas d'effet aux morts
        let objChar = getObj('character', objCharId);
        if (objChar === undefined) return;
        let distance = distanceCombat(token, obj, pageId, {
          strict1: true
        });
        if (distance > 10) return;
        if (murs) {
          if (obstaclePresent(obj.get('left'), obj.get('top'), pc, murs)) return;
        }
        cibles.push(cible);
      });
      let nbCibles = cibles.length;
      if (options.soin && options.dm) nbCibles += nbCibles;
      let ciblesAttaquees = [];
      let sync = function() {
        nbCibles--;
        if (nbCibles < 1) {
          if (ciblesAttaquees.length > 0) {
            let explications = [];
            entrerEnCombat(pretre, ciblesAttaquees, explications, evt);
            explications.forEach(function(e) {
              addLineToFramedDisplay(display, e);
            });
          }
          sendChat('', endFramedDisplay(display));
        }
      };
      if (options.soin) {
        let soins = '[[' + options.soin + ']]';
        cibles.forEach(function(target) {
          if (estMortVivant(target) == positif) {
            sync();
            return;
          }
          try {
            sendChat('', soins, function(res) {
              let soins = res[0].inlinerolls[0].results.total;
              let soinTxt = buildinline(res[0].inlinerolls[0], 'normal', true);
              if (soins <= 0) {
                sendPerso(pretre, "ne r\xE9ussit pas \xE0 soigner (total de soins " + soinTxt + ")", true);
                sync();
                return;
              }
              //TODO: tenir compte des PV partag\xE9s
              soigneToken(target, soins, evt,
                function(soinsEffectifs) {
                  let line =
                    "<b>" + target.token.get('name') + "</b> : + ";
                  if (soinsEffectifs == soins) {
                    line += soinTxt + 'PV';
                  } else {
                    line += soinsEffectifs + 'PV (jet: ' + soinTxt + ')';
                  }
                  addLineToFramedDisplay(display, line);
                  sync();
                },
                function() {
                  addLineToFramedDisplay(display, "<b>" + target.token.get('name') + "</b> : pas besoin de soins.");
                  sync();
                }, options);
            });
          } catch (rollError) {
            error("Jet " + options.soin + " mal form\xE9", options);
          }
        });
      }
      if (options.dm) {
        parseDmgOptions(msg.content, options);
        let dm = '[[' + options.dm + ']]';
        if (options.maxDmg) {
          dm = dm.replace(/d([1-9])/g, "*$1");
        }
        let dmgType = options.type || 'magique';
        cibles.forEach(function(target) {
          if (estMortVivant(target) != positif) {
            sync();
            return;
          }
          ciblesAttaquees.push(target);
          try {
            sendChat('', dm, function(res) {
              let dmg = {
                type: dmgType,
                value: options.dm,
                roll: res[0],
              };
              let afterEvaluateDmg = dmg.roll.content.split(' ');
              let dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
              dmg.total = dmg.roll.inlinerolls[dmgRollNumber].results.total;
              dmg.display = buildinline(dmg.roll.inlinerolls[dmgRollNumber], dmg.type, options.magique);
              let explications = [];
              copyDmgOptionsToTarget(target, options);
              dealDamage(target, dmg, [], evt, false, options, explications, function(dmgDisplay, dmgFinal) {
                addLineToFramedDisplay(display,
                  target.token.get('name') + " re\xE7oit " + dmgDisplay + " DM");
                explications.forEach(function(e) {
                  addLineToFramedDisplay(display, e, 80, false);
                });
                sync();
              });
            });
          } catch (rollError) {
            error("Jet " + options.dm + " mal form\xE9", dm);
          }
        });
      }
    });
  }

  const objetsAnimes = {
    1: {
      token: "https://s3.amazonaws.com/files.d20.io/images/250177368/mJsYWMFqDeEmJDJy8tJKWA/thumb.png?1634130296",
      avatar: "https://s3.amazonaws.com/files.d20.io/images/250177753/IMzDqEpNpuznVnAMYRil8A/max.jpg?1634130507",
      taille: 'tr\xE8s petite',
      force: 4,
      pnj_for: -3,
      constitution: 4,
      pnj_con: -3,
      pnj_def: 10,
      pv: 4,
      dmnbde: 0,
      dmde: 4,
      dm: 1,
    },
    2: {
      token: "https://s3.amazonaws.com/files.d20.io/images/250179877/-j9v1JoPrX7StcH0jGTtMQ/thumb.png?1634132408",
      avatar: "https://s3.amazonaws.com/files.d20.io/images/250179870/ana7iPnNx6lgPLRtSmBzXA/max.jpg?1634132399",
      taille: 'petite',
      force: 6,
      pnj_for: -2,
      constitution: 6,
      pnj_con: -2,
      pnj_def: 10,
      pv: 8,
      dmnbde: 1,
      dmde: 4,
      dm: 0,
    },
    4: {
      token: "https://s3.amazonaws.com/files.d20.io/images/250181751/L0JdDzCXjJnOlbUPJufU7A/thumb.png?1634133729",
      avatar: "https://s3.amazonaws.com/files.d20.io/images/250181765/aELyP7xCTkSddnD6-8Kllw/max.jpg?1634133738",
      taille: 'moyenne',
      force: 10,
      pnj_for: 0,
      constitution: 10,
      pnj_con: 0,
      pnj_def: 12,
      pv: 15,
      dmnbde: 1,
      dmde: 6,
      dm: 0,
    },
    7: {
      token: "https://s3.amazonaws.com/files.d20.io/images/250303501/Kj38iSV6T0BIZMhGm74xqA/thumb.png?1634197833",
      avatar: "https://s3.amazonaws.com/files.d20.io/images/250303491/pzSiwMs-tZqTiluuFIz8tA/max.jpg?1634197823",
      taille: 'moyenne',
      force: 16,
      pnj_for: 3,
      constitution: 16,
      pnj_con: 3,
      pnj_def: 14,
      pv: 30,
      dmnbde: 1,
      dmde: 6,
      dm: 3,
    },
    10: {
      token: "https://s3.amazonaws.com/files.d20.io/images/250303495/k0LqXjurwtySR-aZQjsI1Q/thumb.png?1634197828",
      avatar: "https://s3.amazonaws.com/files.d20.io/images/250303482/COH6jsSUovSjVQfvbjU51Q/max.jpg?1634197812",
      taille: 'grande',
      force: 22,
      pnj_for: 6,
      constitution: 22,
      pnj_con: 6,
      pnj_def: 16,
      pv: 50,
      dmnbde: 2,
      dmde: 6,
      dm: 6,
    }
  };

  //!cof-animation-des-objets lid niveau [tid]
  // la cible optionelle correspond \xE0 un token existant non associ\xE9 \xE0 un personnage
  function animationDesObjets(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("Usage : !cof-animation-des-objets @{selected|token_id} niveau", msg.content);
      return;
    }
    let lanceur = persoOfId(cmd[1], cmd[1], options.pageId);
    if (lanceur === undefined) {
      error("Token incorrect", cmd);
      return;
    }
    let niveauObjet = parseInt(cmd[2]);
    if (isNaN(niveauObjet) || niveauObjet < 1) {
      error("Le niveau de l'objet anim\xE9 doit \xEAtre un nombre positif", cmd);
      return;
    }
    if (niveauObjet > 10) niveauObjet = 10;
    let stats = objetsAnimes[niveauObjet];
    while (stats === undefined) {
      niveauObjet--;
      stats = objetsAnimes[niveauObjet];
    }
    let niveau = ficheAttributeAsInt(lanceur, 'niveau', 1);
    let dejaAnime = attributeAsInt(lanceur, 'niveauDesObjetsAnimes', 0);
    let playerId = getPlayerIdFromMsg(msg);
    if (dejaAnime + niveauObjet > niveau) {
      sendPlayer(msg, "Impossible d'animer plus d'objets pour le moment : somme des niveau anim\xE9s = " + dejaAnime, playerId);
      return;
    }
    let tokenSize = 70;
    switch (stats.taille) {
      case 'tr\xE8s petite':
        tokenSize = 35;
        break;
      case 'petite':
        tokenSize = 50;
        break;
      case 'grande':
        tokenSize = 105;
        break;
    }
    let tokenObjet;
    let aPartirDExistant;
    if (cmd.length > 3) {
      tokenObjet = getObj('graphic', cmd[3]);
      aPartirDExistant = (tokenObjet !== undefined);
    }
    let pageId = lanceur.token.get('pageid');
    tokenObjet = tokenObjet ||
      createObj('graphic', {
        name: 'Objet anim\xE9',
        subtype: 'token',
        pageid: pageId,
        imgsrc: stats.token,
        left: lanceur.token.get('left'),
        top: lanceur.token.get('top'),
        width: tokenSize,
        height: tokenSize,
        layer: 'objects',
        showname: 'true',
        showplayers_bar1: 'true',
        light_hassight: 'true',
        light_losangle: 0,
        has_bright_light_vision: true,
        has_limit_field_of_vision: true,
        limit_field_of_vision_total: 0,
      });
    if (tokenObjet === undefined) {
      error("Impossible de cr\xE9er le token", stats);
      return;
    }
    toFront(tokenObjet);
    let persoObjet = {
      nom: 'Objet anim\xE9 par ' + lanceur.token.get('name'),
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: niveauObjet,
        force: stats.force,
        pnj_for: stats.pnj_for,
        dexterite: 10,
        pnj_dex: 0,
        constitution: stats.constitution,
        pnj_con: stats.pnj_con,
        intelligence: 2,
        pnj_int: -4,
        sagesse: 2,
        pnj_sag: -4,
        charisme: 2,
        pnj_cha: -4,
        pnj_def: stats.pnj_def,
        pnj_init: 10
      },
      pv: stats.pv,
      attaques: [{
        nom: 'Frapper',
        atk: computeArmeAtk(lanceur, '@{ATKMAG}'),
        typedegats: 'contondant',
        dmnbde: stats.dmnbde,
        dmde: stats.dmde,
        dm: stats.dm
      }],
      attributes: [{
        name: 'objetAnime',
        current: 5 + modCarac(lanceur, 'intelligence'),
        max: getInit()
      }, {
        name: 'objetAnimePar',
        current: lanceur.token.id + ' ' + lanceur.token.get('name')
      }, {
        name: 'predicats_script',
        current: 'nonVivant'
      }]
    };
    let charObjet =
      createCharacter(persoObjet.nom, playerId, stats.avatar, tokenObjet, persoObjet);
    let evt = {
      type: "Animation d'objet",
      tokens: [tokenObjet],
      characters: [charObjet.id]
    };
    addEvent(evt);
    if (aPartirDExistant)
      setPredicate({
        token: tokenObjet,
        charId: charObjet.id
      }, 'animeAPartirDExistant', evt);
    initiative([{
      _id: lanceur.token.id,
    }, {
      _id: tokenObjet.id
    }], evt);
    setTokenAttr(lanceur, 'niveauDesObjetsAnimes', dejaAnime + niveauObjet, evt);
    let allies = alliesParPerso[lanceur.charId] || new Set();
    allies.add(charObjet.charId);
    alliesParPerso[lanceur.charId] = allies;
  }

  //!cof-soigner-affaiblissement carac valeur
  function soignerAffaiblissement(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("Usage : !cof-soigner-affaiblissement carac valeur", msg.content);
      return;
    }
    let carac;
    switch (cmd[1]) {
      case 'FOR':
      case 'force':
        carac = 'force';
        break;
      case 'DEX':
      case 'dexterite':
      case 'dexterit\xE9':
      case 'dext\xE9rit\xE9':
      case 'dext\xE9rite':
        carac = 'dexterite';
        break;
      case 'CON':
      case 'constution':
        carac = 'constitution';
        break;
      case 'INT':
      case 'intelligence':
        carac = 'intelligence';
        break;
      case 'SAG':
      case 'sagesse':
        carac = 'sagess';
        break;
      case 'CHA':
      case 'charisme':
        carac = 'charisme';
        break;
      default:
        error("Caract\xE9ristique " + carac + " non reconnue", cmd);
        return;
    }
    let valeur = parseInt(cmd[2]);
    if (isNaN(valeur) || valeur < 1) {
      error("La valeur de soin d'affaiblissement doit \xEAtre un nombre positif", cmd);
      return;
    }
    let lanceur = options.lanceur;
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lection\xE9e pour le soin d'affaiblissement", playerId);
        return;
      }
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine du soin", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) {
            options.lanceur = lanceur;
          }
        }
      }
      let evt = {
        type: "Soin d'affaiblissement de " + carac
      };
      addEvent(evt);
      if (limiteRessources(lanceur, options, carac, carac, evt)) return;
      iterSelected(selected, function(perso) {
        if (options.portee !== undefined) {
          if (options.puissantPortee) options.portee = options.portee * 2;
          let dist = distanceCombat(lanceur.token, perso.token);
          if (dist > options.portee) {
            sendPerso(perso, " est trop loin de " + perso.token.get('name'));
            return;
          }
        }
        let malus = attributeAsInt(perso, 'affaiblissementde' + carac, 0);
        if (malus === 0) {
          sendPerso(perso, "n'a pas d'affaiblissement de " + carac);
          return;
        }
        diminueAffaiblissement(perso, carac, valeur, evt, malus);
      });
    });
  }

  //!cof-affaiblir-carac carac valeur
  function parseAffaiblirCarac(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("Usage : !cof-affaiblir-carac carac valeur", msg.content);
      return;
    }
    let carac;
    switch (cmd[1]) {
      case 'FOR':
      case 'force':
        carac = 'force';
        break;
      case 'DEX':
      case 'dexterite':
      case 'dexterit\xE9':
      case 'dext\xE9rit\xE9':
      case 'dext\xE9rite':
        carac = 'dexterite';
        break;
      case 'CON':
      case 'constution':
        carac = 'constitution';
        break;
      case 'INT':
      case 'intelligence':
        carac = 'intelligence';
        break;
      case 'SAG':
      case 'sagesse':
        carac = 'sagess';
        break;
      case 'CHA':
      case 'charisme':
        carac = 'charisme';
        break;
      default:
        error("Caract\xE9ristique " + carac + " non reconnue", cmd);
        return;
    }
    let valeur = parseInt(cmd[2]);
    if (isNaN(valeur) || valeur < 1) {
      error("La valeur d'affaiblissement doit \xEAtre un nombre positif", cmd);
      return;
    }
    let lanceur = options.lanceur;
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lection\xE9e pour l'affaiblissement", playerId);
        return;
      }
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine de l'affaiblissement", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) {
            options.lanceur = lanceur;
          }
        }
      }
      let cibles = [];
      iterSelected(selected, function(perso) {
        if (options.portee !== undefined) {
          if (options.puissantPortee) options.portee = options.portee * 2;
          let dist = distanceCombat(lanceur.token, perso.token);
          if (dist > options.portee) {
            sendPerso(perso, " est trop loin de " + perso.token.get('name'));
            return;
          }
        }
        if (options.type && immuniseAuType(perso, options.type, lanceur)) {
          sendPerso(perso, "ne semble pas affect\xE9 par " + stringOfType(options.type));
          return;
        }
        cibles.push(perso);
      });
      if (cibles.length == 0) {
        return;
      }
      affaiblirCarac(playerId, cibles, carac, valeur, options);
    }, options);
  }

  function affaiblirCaracPerso(perso, carac, valeur, expliquer, evt) {
    let nomAttr = 'affaiblissementde' + carac;
    let malus = addToAttributeAsInt(perso, nomAttr, 0, valeur, evt);
    let cn = caracNormale(perso, carac);
    if (malus > cn) {
      valeur += cn - malus;
      setTokenAttr(perso, nomAttr, cn, evt);
    }
    if (valeur < 1) return;
    expliquer("perd " + valeur + " points de " + carac);
    if (carac == 'constitution') {
      if (malus >= cn) {
        mort(perso, expliquer, evt);
        return;
      }
      let perteMod = Math.floor(valeur / 2);
      if (valeur % 2 == 1) {
        if ((cn - malus) % 2 == 1) perteMod++;
      }
      if (perteMod > 0) {
        let niveau = ficheAttributeAsInt(perso, 'niveau', 1);
        let pvPerdus = niveau * perteMod;
        let bar1 = parseInt(perso.token.get("bar1_value"));
        let pvmax = parseInt(perso.token.get("bar1_max"));
        if (isNaN(bar1) || isNaN(pvmax)) {
          error("Affaiblissement de constitution sur un token sans points de vie", perso);
          return;
        }
        let attrpvMaxNormaux = tokenAttribute(perso, 'pvMaxNormaux');
        if (attrpvMaxNormaux.length === 0) {
          setTokenAttr(perso, 'pvMaxNormaux', pvmax, evt);
        }
        pvmax -= pvPerdus;
        if (pvmax < 1) {
          pvPerdus += pvmax - 1;
          pvmax = 1;
        }
        bar1 -= pvPerdus;
        if (bar1 < 0) bar1 = 0;
        updateCurrentBar(perso, 1, bar1, evt, pvmax);
        if (bar1 === 0) mort(perso, expliquer, evt);
      }
    } else { //autre caract\xE9ristiques
      if (malus >= cn) {
        setState(perso, 'renverse', true, evt);
        setState(perso, 'assomme', true, evt);
      }
    }
  }

  function affaiblirCarac(playerId, cibles, carac, valeur, options) {
    const evt = {
      type: 'affaiblissement',
      action: {
        titre: "Affaiblissement de " + carac,
        playerId: playerId,
        cibles: cibles,
        carac: carac,
        valeur: valeur,
        options: options
      }
    };
    let lanceur = options.lanceur;
    let explications = options.messages || [];
    let whisper = '';
    if (options.secret) {
      let player;
      if (playerId) player = getObj('player', playerId);
      if (player !== undefined) {
        whisper = '/w "' + player.get('displayname') + '" ';
      }
    }
    addEvent(evt);
    if (limiteRessources(lanceur, options, carac, carac, evt)) return;
    explications.forEach(function(e) {
      sendChat('', e);
    });
    cibles.forEach(function(perso) {
      let expliquer = function(s) {
        sendPerso(perso, s);
      };
      if (options.save) {
        let saveOpts = {
          msgPour: " pour r\xE9sister \xE0 un affaiblissement de " + carac,
          msgRate: ", rat\xE9.",
          attaquant: lanceur,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: options.type
        };
        let saveId = 'affaiblissement' + carac + "_" + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt,
          function(reussite, rollText) {
            if (!reussite) {
              affaiblirCaracPerso(perso, carac, valeur, expliquer, evt);
            }
          });
      } else {
        affaiblirCaracPerso(perso, carac, valeur, expliquer, evt);
      }
    });
  }

  // !cof-fin-reaction-violente token_id
  function finReactionViolente(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Usage : !cof-fin-reaction-violente token_id", msg.content);
      return;
    }
    let perso = persoOfId(cmd[1]);
    if (perso === undefined) {
      error("Le premier argument de !cof-fin-reatcion-violente n'est pas un token valide", cmd);
      return;
    }
    let playerId = getPlayerIdFromMsg(msg);
    let attr = tokenAttribute(perso, 'reactionViolente');
    if (attr.length === 0) {
      sendPlayer(msg, "Action inutile, " + perso.token.ge('name') + " n'est pas sous l'effet d'une r\xE9action violente", playerId);
      return;
    }
    attr = attr[0];
    let duree = attr.get('current');
    if (duree == 'tourFinal') duree = 1;
    else {
      duree = parseInt(duree);
      if (isNaN(duree) || duree < 1) duree = 1;
    }
    let evt = {
      type: "Fin de r\xE9action violente",
      deletedAttributes: [attr]
    };
    addEvent(evt);
    attr.remove();
    sendPerso(perso, "prend sur " + onGenre(perso, 'lui', 'elle') + " pour contenir sa r\xE9action violente");
    options.ignoreRD = true;
    let degats = rollDePlus(6, {
      nbDes: duree
    });
    let dmg = {
      type: 'normal',
      total: degats.val,
      display: degats.roll
    };
    dealDamage(perso, dmg, [], evt, false, options, undefined,
      function(dmgDisplay, dmgFinal) {
        sendPerso(perso, "s'inflige " + dmgDisplay + " DM");
      });
  }

  //!cof-explosion correspond \xE0 !cof-attack token token --explosion pour chaque  token s\xE9lectionn\xE9
  function attaqueExplosion(msg) {
    if (!msg.content) return;
    let index = msg.content.indexOf(' ');
    if (index < 1) {
      error("Il manque le label de l'attaque \xE0 utiliser pour !cof-explosion", msg.content);
      return;
    }
    let args_msg = msg.content.substring(index);
    //On va ensuite enlever tout ce qui vient apr\xE8s --target
    index = args_msg.indexOf(' --target ');
    if (index > 0) args_msg = args_msg.substring(0, index);
    args_msg += ' --explosion';
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        let id = perso.token.id;
        let msga = {...msg,
          content: '!cof-attack ' + id + ' ' + id + args_msg
        };
        parseAttack(msga);
      });
    }, {
      ignoreAllies: true,
      ignoreDisque: true
    }); //On ignore les options d'alli\xE9s dans le getSelected
  }

  function apiCommand(msg) {
    msg.content = msg.content.replace(/\s+/g, ' '); //remove duplicate whites
    const command = msg.content.split(' ', 1);
    // First replace inline rolls by their values
    replaceInline(msg);
    switch (command[0]) {
      case '!cof-affaiblir-carac':
        parseAffaiblirCarac(msg);
        return;
      case '!cof-animation-des-objets':
        animationDesObjets(msg);
        return;
      case '!cof-attack':
        parseAttack(msg);
        return;
      case '!cof-bouton-chance':
        boutonChance(msg);
        return;
      case '!cof-canaliser':
        canaliser(msg);
        return;
      case '!cof-confirmer-attaque':
        confirmerAttaque(msg);
        return;
      case "!cof-expert-combat":
      case "!cof-expert-combat-touche":
      case "!cof-expert-combat-dm":
        expertDuCombat(msg);
        return;
      case "!cof-expert-combat-def":
        expertDuCombatDEF(msg);
        return;
      case "!cof-expert-combat-bousculer":
        expertDuCombatBousculer(msg);
        return;
      case "!cof-explosion":
        attaqueExplosion(msg);
        return;
      case '!cof-hors-combat': //ancienne syntaxe, plus document\xE9e
      case '!cof-fin-combat':
        sortirDuCombat();
        return;
      case '!cof-fin-reaction-violente':
        finReactionViolente(msg);
        return;
      case '!cof-jet':
        jet(msg);
        return;
      case '!cof-montrer-resultats-attaque':
        montrerResultatsAttaque(msg);
        return;
      case '!cof-nouveau-jour':
        parseNouveauJour(msg);
        return;
      case '!cof-options':
        setCofOptions(msg);
        return;
      case '!cof-pathfinder1':
        translateFromPathfinder1(msg);
        return;
      case "!cof-recharger":
        recharger(msg);
        return;
      case '!cof-recuperation':
        parseRecuperer(msg);
        return;
      case '!cof-resultat-jet':
        resultatJet(msg);
        return;
      case '!cof-soigner-affaiblissement':
        soignerAffaiblissement(msg);
        return;
      case '!cof-sphere-de-feu':
        sphereDeFeu(msg);
        return;
      case '!cof-undo':
        undoEvent();
        return;
      case "!cof-bouton-rune-energie":
      case "!cof-rune-energie":
        runeEnergie(msg);
        return;
      case "!cof-rune-puissance":
      case "!cof-bouton-rune-puissance":
        runePuissance(msg);
        return;
      case "!cof-bouton-pousser-kiai":
        kiai(msg);
        return;
      case "!cof-rune-protection":
        runeProtection(msg);
        return;
      case "!cof-surprise":
        parseSurprise(msg);
        return;
      case "!cof-init":
        initiativeInterface(msg);
        return;
      case '!cof-turn-action':
      case '!cof-liste-actions':
        apiTurnAction(msg);
        return;
      case "!cof-attendre":
        attendreInit(msg);
        return;
      case "!cof-statut":
        statut(msg);
        return;
      case "!cof-armure-magique":
        armureMagique(msg);
        return;
      case "!cof-buf-def":
        bufDef(msg);
        return;
      case "!cof-remove-buf-def":
        removeBufDef(msg);
        return;
      case "!cof-aoe": //deprecated
      case "!cof-dmg":
        parseDmgDirects(msg);
        return;
      case "!cof-set-state":
        parseSetState(msg);
        return;
      case "!cof-save-state":
        parseSaveState(msg);
        return;
      case "!cof-degainer":
        parseDegainer(msg);
        return;
      case "!cof-echange-init":
        echangeInit(msg);
        return;
      case "!cof-a-couvert":
        aCouvert(msg);
        return;
      case "!cof-bonus-couvert":
        bonusCouvert(msg);
        return;
      case "!cof-effet-temp":
        parseEffetTemporaire(msg);
        return;
      case "!cof-effet-combat":
        effetCombat(msg);
        return;
      case "!cof-effet":
        effetIndetermine(msg);
        return;
      case "!cof-fin-classe-effet":
        finClasseDEffet(msg);
        return;
      case "!cof-attaque-magique":
        parseAttaqueMagique(msg);
        return;
      case "!cof-injonction":
        parseAttaqueMagique(msg, 'injonction');
        return;
      case "!cof-sommeil":
        parseSommeil(msg);
        return;
      case "!cof-attaque-magique-contre-pv":
        attaqueMagiqueContrePV(msg);
        return;
      case "!cof-transe-guerison":
        transeGuerison(msg);
        return;
      case "!cof-soin":
      case "!cof-soins":
        soigner(msg);
        return;
      case "!cof-nature-nourriciere":
        parseNatureNourriciere(msg);
        return;
      case "!cof-ignorer-la-douleur":
        ignorerLaDouleur(msg);
        return;
      case "!cof-fortifiant":
        fortifiant(msg);
        return;
      case "!cof-intercepter":
        intercepter(msg);
        return;
      case "!cof-interposer":
        interposer(msg);
        return;
      case "!cof-esquive-fatale":
        doEsquiveFatale(msg);
        return;
      case "!cof-exemplaire":
        exemplaire(msg);
        return;
      case "!cof-intervention-divine":
        interventionDivine(msg);
        return;
      case "!cof-lancer-sort":
        lancerSort(msg);
        return;
      case "!cof-as":
        emulerAs(msg);
        return;
      case "!cof-peur":
        parsePeur(msg);
        return;
      case "!cof-distribuer-baies":
        distribuerBaies(msg);
        return;
      case "!cof-consommer-baie":
        consommerBaie(msg);
        return;
      case "!cof-proteger-un-allie":
        protegerUnAllie(msg);
        return;
      case "!cof-action-defensive":
        actionDefensive(msg);
        return;
      case "!cof-strangulation":
        strangulation(msg);
        return;
      case "!cof-ombre-mortelle":
        ombreMortelle(msg);
        return;
      case "!cof-escalier":
        escalier(msg);
        return;
      case "!cof-defaut-dans-la-cuirasse":
        defautDansLaCuirasse(msg);
        return;
      case '!cof-posture-de-combat':
        postureDeCombat(msg);
        return;
      case '!cof-attaque-a-outrance':
        attaqueAOutrance(msg);
        return;
      case '!cof-mur-de-force':
        murDeForce(msg);
        return;
      case '!cof-capitaine':
        devientCapitaine(msg);
        return;
      case '!cof-tueur-fantasmagorique':
        parseAttaqueMagique(msg, 'tueurFantasmagorique');
        return;
      case '!cof-injonction-mortelle':
        parseInjonctionMortelle(msg);
        return;
      case '!cof-tour-de-force': // Deprecrated
        parseTourDeForce(msg);
        return;
      case '!cof-prouesse':
        boutonProuesse(msg);
        return;
      case '!cof-tour-force':
        boutonTourDeForce(msg);
        return;
      case '!cof-pacte-sanglant':
        boutonPacteSanglant(msg);
        return;
      case '!cof-pacte-sanglant-def':
        boutonPacteSanglantDef(msg);
        return;
      case '!cof-encaisser-un-coup':
        doEncaisserUnCoup(msg);
        return;
      case '!cof-devier-les-coups':
        doDevierLesCoups(msg);
        return;
      case '!cof-parade-projectiles':
        doParadeProjectiles(msg);
        return;
      case "!cof-parade-au-bouclier":
        doParadeAuBouclier(msg);
        return;
      case "!cof-esquive-acrobatique":
        doEsquiveAcrobatique(msg);
        return;
      case "!cof-resister-a-la-magie":
        resisterALaMagie(msg);
        return;
      case "!cof-cercle-protection":
        cercleDeProtection(msg);
        return;
      case "!cof-parade-magistrale":
        doParadeMagistrale(msg);
        return;
      case "!cof-esquive-magistrale":
        doEsquiveMagistrale(msg);
        return;
      case "!cof-absorber-au-bouclier":
      case "!cof-absorber-coup-au-bouclier":
        absorberCoupAuBouclier(msg);
        return;
      case "!cof-absorber-sort-au-bouclier":
        absorberSortAuBouclier(msg);
        return;
      case "!cof-chair-a-canon":
        doChairACanon(msg);
        return;
      case "!cof-demarrer-statistiques":
        if (stateCOF.statistiquesEnPause) {
          stateCOF.statistiques = stateCOF.statistiquesEnPause;
          delete stateCOF.statistiquesEnPause;
        } else {
          stateCOF.statistiques = {}; //remet aussi les statistiques \xE0 0
        }
        return;
      case "!cof-arreter-statistiques":
        delete stateCOF.statistiques;
        return;
      case "!cof-pause-statistiques":
        if (stateCOF.statistiques) {
          stateCOF.statistiquesEnPause = stateCOF.statistiques;
          delete stateCOF.statistiques;
        } // sinon, ne pas \xE9craser les statistiques d\xE9j\xE0 en pause
        return;
      case '!cof-statistiques':
        displayStatistics(msg);
        return;
      case '!cof-destruction-des-morts-vivants':
        parseDestructionDesMortsVivants(msg);
        return;
      case '!cof-enduire-poison':
        parseEnduireDePoison(msg);
        return;
      case '!cof-consommables':
        listeConsommables(msg);
        return;
      case '!cof-utilise-consommable': //Usage interne seulement
        utiliseConsommable(msg);
        return;
      case '!cof-echange-consommable': //Usage interne seulement
        echangeConsommable(msg);
        return;
      case '!cof-provocation':
        parseProvocation(msg);
        return;
      case '!cof-en-selle':
        enSelle(msg);
        return;
      case '!cof-creer-elixir': //usage interne seulement
        creerElixir(msg);
        return;
      case '!cof-elixirs':
        gestionElixir(msg);
        return;
      case '!cof-runes':
        gestionRunes(msg);
        return;
      case '!cof-creer-rune': // usage interne seulement
        creerRune(msg);
        return;
      case '!cof-rage-du-berserk':
        parseRageDuBerserk(msg);
        return;
      case '!cof-arme-secrete':
        parseArmeSecrete(msg);
        return;
      case '!cof-animer-arbre':
        animerUnArbre(msg);
        return;
      case '!cof-delivrance':
      case '!cof-guerir':
        delivrance(msg);
        return;
      case '!cof-guerison':
        guerison(msg);
        return;
      case '!cof-test-attaque-opposee':
        testAttaqueOpposee(msg);
        return;
      case '!cof-manoeuvre':
        manoeuvreRisquee(msg);
        return;
      case '!cof-appliquer-manoeuvre':
        appliquerManoeuvre(msg);
        return;
      case '!cof-desarmer':
        desarmer(msg);
        return;
      case '!cof-tempete-de-mana':
        optionsDeTempeteDeMana(msg);
        return;
      case '!cof-deplacer-token':
        deplacerToken(msg);
        return;
      case '!cof-permettre-deplacement':
        permettreDeplacement(msg);
        return;
      case '!cof-tour-suivant':
        tourSuivant(msg);
        return;
      case '!cof-multi-command':
        multiCommand(msg);
        return;
      case '!cof-conjuration-de-predateur':
        conjurationPredateur(msg);
        return;
      case '!cof-conjuration-armee':
        conjurationArmee(msg);
        return;
      case '!cof-set-macros':
        setGameMacros(msg);
        return;
      case '!cof-lumiere':
        ajouteLumiere(msg);
        return;
      case '!cof-eteindre-lumiere':
        eteindreLumieres(msg);
        return;
      case '!cof-torche':
        switchTorche(msg);
        return;
      case '!cof-defi-samourai':
        lancerDefiSamourai(msg);
        return;
      case '!cof-enveloppement':
        parseEnveloppement(msg);
        return;
      case '!cof-echapper-enveloppement':
        parseEchapperEnveloppement(msg);
        return;
      case '!cof-liberer-agrippe':
        parseLibererAgrippe(msg);
        return;
      case '!cof-animer-cadavre':
        animerCadavre(msg);
        return;
      case '!cof-vapeurs-ethyliques':
        parseVapeursEthyliques(msg);
        return;
      case '!cof-desaouler':
        desaouler(msg);
        return;
      case '!cof-boire-alcool':
        parseBoireAlcool(msg);
        return;
      case '!cof-jouer-son':
        jouerSon(msg);
        return;
      case '!cof-bouton-echec-total':
        echecTotal(msg);
        return;
      case '!cof-usure-off':
        stateCOF.usureOff = true;
        sendChat('COF', "/w GM Pas d'usure de la DEF sur ce combat");
        return;
      case '!cof-set-attribute':
        setAttributeInterface(msg);
        return;
      case '!cof-set-predicate':
        setPredicateInterface(msg);
        return;
      case '!cof-options-d-attaque':
        optionsDAttaque(msg);
        return;
      case '!cof-petit-veinard':
      case '!cof-bouton-petit-veinard':
        petitVeinard(msg);
        return;
      case '!cof-suivre':
        suivre(msg);
        return;
      case '!cof-centrer-sur-token':
        centrerSurToken(msg);
        return;
      case '!cof-bourse':
        gestionBourse(msg);
        return;
      case '!cof-mot-de-pouvoir-immobilise':
        motDePouvoirImmobilise(msg);
        return;
      case '!cof-charge-fantastique':
        chargeFantastque(msg);
        return;
      case '!cof-next-charge-fantastique':
        nextTurnChargeFantastique(msg);
        return;
      case '!cof-tenebres':
        tenebres(msg);
        return;
      case '!cof-defense-armee-des-morts':
        defenseArmeeDesMorts(msg);
        return;
      case '!cof-invoquer-demon':
        invocationDemon(msg);
        return;
      case '!cof-animer-mort':
        animerMort(msg);
        return;
      case '!cof-prescience':
        utiliserPrescience(msg);
        return;
      case '!cof-multi-cartes':
        multiCartes(msg);
        return;
      case '!cof-ombre-mouvante':
        ombreMouvante(msg);
        return;
      case '!cof-reveler-nom':
        revelerNom(msg);
        return;
      case '!cof-tenebres-magiques':
        tenebresMagiques(msg);
        return;
      case '!cof-fiole-de-lumiere':
        fioleDeLumiere(msg);
        return;
      case '!cof-agripper-de-demon':
        agripperDeDemon(msg);
        return;
      default:
        error("Commande " + command[0] + " non reconnue.", command);
        return;
    }
  }

  //Attributs possibles :
  // activation : message \xE0 l'activation
  // activationF : message \xE0 l'activation si la cible est f\xE9minine
  // actif : message de statut
  // fin : message \xE0 la fin de l'effet
  // dm : permet d'infliger des dm
  // soins : soigne
  // prejudiciable: est un effet pr\xE9judiciable, qui peut \xEAtre enlev\xE9 par d\xE9livrance
  // generic: admet un argument entre parenth\xE8ses
  // seulementVivant: ne peut s'appliquer qu'aux cr\xE9atures vivantes
  // visible : l'effet est visible
  // msgSave: message \xE0 afficher quand on r\xE9siste \xE0 l'effet. Sera pr\xE9c\xE9d\xE9 de "pour "
  // entrave: effet qui immobilise, paralyse ou ralentit
  // statusMarker: marker par d\xE9faut pour l'effet
  const messageEffetTemp = {
    formeDAnge: {
      activation: "prend la forme d'un ange ail\xE9",
      actif: "est en forme d'ange et peut jeter des sorts en vol stationnaire",
      fin: "retrouve sa forme normale. Esp\xE9rons qu'il \xE9tait au sol...",
      visible: true,
    },
    aCouvert: {
      activation: "reste \xE0 couvert",
      actif: "est \xE0 couvert",
      fin: "n'est plas \xE0 couvert"
    },
    imageDecalee: {
      activation: "d\xE9cale l\xE9g\xE8rement son image",
      actif: "a d\xE9cal\xE9 son image",
      fin: "appara\xEEt \xE0 nouveau l\xE0 o\xF9 il se trouve",
      visible: false
    },
    chantDesHeros: {
      activation: "\xE9coute le chant du barde",
      actif: "est inspir\xE9 par le Chant des H\xE9ros",
      fin: "n'est plus inspir\xE9 par le Chant des H\xE9ros"
    },
    benediction: {
      activation: "est touch\xE9 par la b\xE9n\xE9diction",
      activationF: "est touch\xE9e par la b\xE9n\xE9diction",
      actif: "est b\xE9ni",
      fin: "l'effet de la b\xE9n\xE9diction s'estompe"
    },
    peauDEcorce: {
      activation: "donne \xE0 sa peau la consistance de l'\xE9corce",
      actif: "a la peau dure comme l'\xE9corce",
      fin: "retrouve une peau normale",
      visible: true
    },
    rayonAffaiblissant: {
      activation: "est touch\xE9 par un rayon affaiblissant",
      activationF: "est touch\xE9e par un rayon affaiblissant",
      actif: "est sous l'effet d'un rayon affaiblissant",
      msgSave: "ne plus \xEAtre affaibli",
      fin: "n'est plus affaibli",
      prejudiciable: true
    },
    apeureTemp: {
      activation: "prend peur",
      actif: "est domin\xE9 par sa peur",
      fin: "retrouve du courage",
      msgSave: "retrouver du courage",
      prejudiciable: true,
      visible: true
    },
    peurEtourdi: {
      activation: "prend peur: il peut fuir ou rester recroquevill\xE9",
      activationF: "prend peur: elle peut fuir ou rester recroquevill\xE9",
      actif: "est paralys\xE9 par la peur",
      fin: "retrouve du courage et peut \xE0 nouveau agir",
      msgSave: "retrouver du courage",
      prejudiciable: true,
      visible: true
    },
    aveugleTemp: {
      activation: "n'y voit plus rien !",
      actif: "est aveugl\xE9",
      fin: "retrouve la vue",
      msgSave: "retrouver la vue",
      prejudiciable: true,
      visible: true
    },
    ralentiTemp: {
      activation: "est ralenti : une seule action, pas d'action limit\xE9e",
      activationF: "est ralentie : une seule action, pas d'action limit\xE9e",
      actif: "est ralenti",
      msgSave: "ne plus \xEAtre ralenti",
      fin: "n'est plus ralenti",
      prejudiciable: true,
      visible: true,
      entrave: true
    },
    paralyseTemp: {
      activation: "est paralys\xE9 : aucune action ni d\xE9placement possible",
      activationF: "est paralys\xE9e : aucune action ni d\xE9placement possible",
      actif: "est paralys\xE9",
      fin: "n'est plus paralys\xE9",
      msgSave: "ne plus \xEAtre paralys\xE9",
      prejudiciable: true,
      visible: true,
      entrave: true
    },
    paralyseGoule: {
      activation: "est paralys\xE9 : aucune action ni d\xE9placement possible",
      activationF: "est paralys\xE9e : aucune action ni d\xE9placement possible",
      actif: "est paralys\xE9",
      fin: "n'est plus paralys\xE9",
      msgSave: "ne plus \xEAtre paralys\xE9",
      prejudiciable: true,
      visible: true
    },
    immobiliseTemp: {
      activation: "est immobilis\xE9 : aucun d\xE9placement possible",
      activationF: "est immobilis\xE9e : aucun d\xE9placement possible",
      actif: "est immobilis\xE9",
      fin: "n'est plus immobilis\xE9",
      msgSave: "pouvoir bouger",
      prejudiciable: true,
      visible: true,
      entrave: true
    },
    etourdiTemp: {
      activation: "est \xE9tourdi : aucune action et -5 en DEF",
      activationF: "est \xE9tourdie : aucune action et -5 en DEF",
      actif: "est \xE9tourdi",
      fin: "n'est plus \xE9tourdi",
      msgSave: "se reprendre",
      prejudiciable: true,
      visible: true
    },
    affaibliTemp: {
      activation: "se sent faible",
      actif: "est affaibli",
      fin: "se sent moins faible",
      msgSave: "retrouver des forces",
      prejudiciable: true
    },
    assommeTemp: {
      activation: "est assomm\xE9",
      activationF: "est assomm\xE9e",
      actif: "est assomm\xE9",
      fin: "reprend conscience",
      msgSave: "reprendre conscience",
      prejudiciable: true,
      visible: true
    },
    nauseeuxTemp: {
      activation: "souffre de violentes douleurs au ventre",
      actif: "est naus\xE9eux, seul le mouvement est possible",
      fin: "se sent mieux",
      msgSave: "ne plus \xEAtre naus\xE9eux",
      prejudiciable: true,
      visible: true
    },
    invisibleTemp: {
      activation: "dispara\xEEt",
      actif: "est invisible",
      fin: "r\xE9appara\xEEt",
      msgSave: "ne pas devenir invisible",
      visible: true
    },
    aveugleManoeuvre: {
      activation: "est aveugl\xE9 par la manoeuvre",
      activationF: "est aveugl\xE9e par la manoeuvre",
      actif: "a du mal \xE0 voir o\xF9 sont ses adversaires",
      fin: "retrouve une vision normale",
      msgSave: "voir \xE0 nouveau",
      prejudiciable: true,
      visible: true
    },
    bloqueManoeuvre: {
      activation: "est bloqu\xE9 par la manoeuvre",
      activationF: "est bloqu\xE9e par la manoeuvre",
      actif: "est bloqu\xE9 et ne peut pas se d\xE9placer",
      fin: "peut \xE0 nouveau se d\xE9placer",
      msgSave: "pouvoir se d\xE9placer",
      prejudiciable: true,
      entrave: true
    },
    diversionManoeuvre: {
      activation: "est d\xE9concentr\xE9",
      activationF: "est d\xE9concentr\xE9e",
      actif: "a \xE9t\xE9 perturb\xE9 par une diversion",
      fin: "se reconcentre sur le combat",
      msgSave: "se reconcentrer sur le combat",
      prejudiciable: true,
      visible: true
    },
    menaceManoeuvre: {
      activation: "est menac\xE9",
      activationF: "est menac\xE9e",
      actif: "a \xE9t\xE9 menac\xE9e, risque de plus de DM",
      fin: "n'est plus sous la menace",
      msgSave: "ne plus \xEAtre sous la menace",
      prejudiciable: true,
      generic: true
    },
    tenuADistanceManoeuvre: {
      activation: "est tenu \xE0 distance",
      activationF: "est tenue \xE0 distance",
      actif: "est tenu \xE0 distance de son adversaire, il ne peut pas l'attaquer",
      fin: "peut \xE0 nouveau attaquer son adversaire",
      msgSave: "pouvoir \xE0 nouveau attaquer son adversaire",
      prejudiciable: true,
      generic: true,
      visible: true,
      entrave: true
    },
    epeeDansante: {
      activation: "fait appara\xEEtre une lame d'\xE9nergie lumineuse",
      actif: "contr\xF4le une lame d'\xE9nergie lumineuse",
      fin: "La lame d'\xE9nergie lumineuse dispara\xEEt",
      dm: true,
      visible: true
    },
    rapiereDansante: {
      activation: "fait appara\xEEtre une rapi\xE8re d'\xE9nergie lumineuse",
      actif: "contr\xF4le une rapi\xE8re d'\xE9nergie lumineuse",
      fin: "La rapi\xE8re d'\xE9nergie lumineuse dispara\xEEt",
      dm: true,
      visible: true
    },
    putrefaction: {
      activation: "vient de contracter une sorte de l\xE8pre fulgurante",
      actif: "est en pleine putr\xE9faction",
      fin: "La putr\xE9faction s'arr\xEAte.",
      msgSave: "r\xE9sister \xE0 la putr\xE9faction",
      prejudiciable: true,
      dm: true,
      visible: true
    },
    forgeron: {
      activation: "enflamme son arme",
      actif: "a une arme en feu",
      fin: "L'arme n'est plus enflamm\xE9e.",
      dm: true,
      generic: true,
      visible: true
    },
    armeEnflammee: {
      activation: "voit son arme prendre feu",
      actif: "a une arme enflamm\xE9e",
      fin: "L'arme n'est plus enflamm\xE9e.",
      dm: true,
      generic: true,
      visible: true
    },
    armesEnflammees: {
      activation: "voit ses armes prendre feu",
      actif: "a des armes enflamm\xE9es",
      fin: "Les armes ne sont plus enflamm\xE9es.",
      dm: true,
      visible: true
    },
    dotGen: {
      activation: "subit un effet",
      actif: "subit r\xE9guli\xE8rement des d\xE9g\xE2ts",
      fin: "ne subit plus ces effets de d\xE9g\xE2ts",
      dm: true,
      prejudiciable: true,
      generic: true
    },
    rechargeGen: {
      activation: "doit maintenant attendre un peu avant de pouvoir le refaire",
      actif: "attends avant de pouvoir refaire une attaque",
      fin: "a r\xE9cup\xE9r\xE9",
      generic: true
    },
    dmgArme: {
      activation: "enduit son arme d'une huile magique",
      actif: "a une arme plus puissante",
      fin: "L'arme retrouve sa puissance normale",
      dm: true,
      generic: true
    },
    flou: {
      activation: "devient flou",
      activationF: "devient floue",
      actif: "appara\xEEt flou",
      fin: "redevient net",
      visible: true
    },
    agrandissement: {
      activation: "se met \xE0 grandir",
      actif: "est vraiment tr\xE8s grand",
      fin: "retrouve sa taille normale",
      visible: true
    },
    formeGazeuse: {
      activation: "semble perdre de la consistance",
      actif: "est en forme gazeuse",
      fin: "retrouve sa consistance normale",
      visible: true
    },
    intangible: {
      activation: "devient translucide",
      actif: "est intangible",
      fin: "redevient solide",
      visible: true
    },
    intangibleInvisible: {
      activation: "dispara\xEEt",
      actif: "est intangible et invisible",
      fin: "r\xE9appara\xEEt",
      visible: true
    },
    sousTension: {
      activation: "se charge d'\xE9nergie \xE9lectrique",
      actif: "est charg\xE9 d'\xE9nergie \xE9lectrique",
      fin: "n'est plus charg\xE9 d'\xE9nergie \xE9lectrique",
      dm: true,
      visible: false
    },
    strangulation: {
      activation: "commence \xE0 \xE9touffer",
      actif: "est \xE9trangl\xE9",
      fin: "respire enfin",
      msgSave: "pouvoir respirer",
      prejudiciable: true,
      seulementVivant: true,
      dm: true,
      visible: true
    },
    ombreMortelle: {
      activation: "voit son ombre s'animer et l'attaquer !",
      actif: "est une ombre anim\xE9e",
      fin: "retrouve une ombre normale",
      dm: true,
      visible: true
    },
    dedoublement: {
      activation: "voit un double translucide sortir de lui",
      activationF: "voit un double translucide sortir d'elle",
      actif: "est un double translucide",
      fin: "le double dispara\xEEt",
      dm: true,
      visible: true
    },
    zoneDeSilence: {
      activation: "n'entend plus rien",
      actif: "est totalement sourd",
      fin: "peut \xE0 nouveau entendre"
    },
    danseIrresistible: {
      activation: "se met \xE0 danser",
      actif: "danse malgr\xE9 lui",
      fin: "s'arr\xEAte de danser",
      msgSave: "s'arr\xEAter de danser",
      prejudiciable: true,
      visible: true
    },
    confusion: {
      activation: "ne sait plus tr\xE8s bien ce qu'il fait l\xE0",
      activationF: "ne sait plus tr\xE8s bien ce qu'elle fait l\xE0",
      actif: "est en pleine confusion",
      fin: "retrouve ses esprits",
      msgSave: "retrouver ses esprits",
      prejudiciable: true,
      visible: true
    },
    murDeForce: {
      activation: "fait appara\xEEtre un mur de force",
      actif: "en entour\xE9 d'un mur de force",
      fin: "voit son mur de force dispara\xEEtre",
      visible: true
    },
    asphyxie: {
      activation: "commence \xE0 manquer d'air",
      actif: "\xE9touffe",
      fin: "peut \xE0 nouveau respirer",
      msgSave: "pouvoir respirer normalement",
      prejudiciable: true,
      seulementVivant: true,
      statusMarker: 'blue',
      dm: true,
      visible: true
    },
    forceDeGeant: {
      activation: "devient plus fort",
      activationE: "devient plus forte",
      actif: "a une force de g\xE9ant",
      fin: "retrouve sa force normale"
    },
    saignementsSang: {
      activation: "commence \xE0 saigner du nez, des oreilles et des yeux",
      actif: "saigne de tous les orifices du visage",
      fin: "ne saigne plus",
      msgSave: "ne plus saigner",
      prejudiciable: true,
      statusMarker: 'red',
      dm: true,
      visible: true
    },
    encaisserUnCoup: {
      activation: "se place de fa\xE7on \xE0 d\xE9vier un coup sur son armure",
      actif: "est plac\xE9 de fa\xE7on \xE0 d\xE9vier un coup",
      fin: "n'est plus en position pour encaisser un coup"
    },
    seulContreTous: {
      activation: "se place de fa\xE7on \xE0 faire face \xE0 tous ses adversaires",
      actif: "riposte",
      fin: "ne fait plus face \xE0 tous ses adversaires"
    },
    absorberUnCoup: {
      activation: "se pr\xE9pare \xE0 absorber un coup avec son bouclier",
      actif: "est pr\xEAt \xE0 absorber un coup avec son bouclier",
      fin: "n'est plus en position de prendre le prochain coup sur son bouclier"
    },
    absorberUnSort: {
      activation: "se pr\xE9pare \xE0 absorber un sort avec son bouclier",
      actif: "est pr\xEAt \xE0 absorber un sort avec son bouclier",
      fin: "n'est plus en position de se prot\xE9ger d'un sort avec son bouclier"
    },
    nueeDInsectes: {
      activation: "est attaqu\xE9 par une nu\xE9e d'insectes",
      activationF: "est attaqu\xE9e par une nu\xE9e d'insectes",
      actif: "est entour\xE9 d'une nu\xE9e d'insectes",
      fin: "est enfin d\xE9barass\xE9 des insectes",
      msgSave: "se d\xE9barasser des insectes",
      prejudiciable: true,
      dm: true,
      visible: true
    },
    nueeDeCriquets: {
      activation: "est attaqu\xE9 par une nu\xE9e de criquets",
      activationF: "est attaqu\xE9e par une nu\xE9e de criquets",
      actif: "est entour\xE9 d'une nu\xE9e de criquets",
      fin: "est enfin d\xE9barass\xE9 des criquets",
      msgSave: "se d\xE9barasser des criquets",
      prejudiciable: true,
      dm: true,
      visible: true
    },
    nueeDeScorpions: {
      activation: "est attaqu\xE9 par une nu\xE9e de scorpions",
      activationF: "est attaqu\xE9e par une nu\xE9e de scorpions",
      actif: "est entour\xE9 d'une nu\xE9e de scorpions",
      fin: "est enfin d\xE9barass\xE9 des scorpions",
      msgSave: "se d\xE9barasser des scorpions",
      prejudiciable: true,
      dm: true,
      visible: true
    },
    toiles: {
      activation: "voit des toiles d'araign\xE9es appara\xEEtre tout autour",
      actif: "est bloqu\xE9 par des toiles d'araign\xE9es",
      fin: "se lib\xE8re des toiles",
      msgSave: "se lib\xE9rer des toiles",
      prejudiciable: true,
      statusMarker: 'cobweb',
      visible: true,
      entrave: true
    },
    prisonVegetale: {
      activation: "voit des plantes pousser et s'enrouler autour de ses jambes",
      actif: "est bloqu\xE9 par des plantes",
      fin: "se lib\xE8re des plantes",
      msgSave: "se lib\xE9rer des plantes",
      prejudiciable: true,
      statusMarker: 'green',
      visible: true,
      entrave: true
    },
    protectionContreLesElements: {
      activation: "lance un sort de protection contre les \xE9l\xE9ments",
      actif: "est prot\xE9g\xE9 contre les \xE9l\xE9ments",
      fin: "n'est plus prot\xE9g\xE9 contre les \xE9l\xE9ments"
    },
    masqueMortuaire: {
      activation: "prend l'apparence de la mort",
      actif: "semble mort et anim\xE9",
      fin: "retrouve une apparence de vivant",
      visible: true
    },
    armeBrulante: {
      activation: "sent son arme lui chauffer la main",
      actif: "se br\xFBle la main sur son arme",
      fin: "sent son arme refroidir",
      dm: true
    },
    armureBrulante: {
      activation: "sent son armure chauffer",
      actif: "br\xFBle dans son armure",
      fin: "sent son armure refroidir",
      dm: true
    },
    masqueDuPredateur: {
      activation: "prend les traits d'un pr\xE9dateur",
      actif: "a les traits d'un pr\xE9dateur",
      fin: "redevient normal",
      visible: true
    },
    aspectDeLaSuccube: {
      activation: "acquiert une beaut\xE9 fascinante",
      actif: "est d'une beaut\xE9 fascinante",
      fin: "retrouve sa beaut\xE9 habituelle",
      visible: true
    },
    aspectDuDemon: {
      activation: "prend l\x2019apparence d\x2019un d\xE9mon",
      actif: "a l\x2019apparence d\x2019un d\xE9mon",
      fin: "retrouve son apparence habituelle",
      visible: true
    },
    sangMordant: {
      activation: "transforme son sang",
      actif: "a du sang acide",
      fin: "retrouve un sang normal"
    },
    armeSecreteBarde: {
      activation: "est d\xE9stabilis\xE9",
      activationF: "est d\xE9stabilis\xE9e",
      actif: "est d\xE9stabilis\xE9 par une action de charme",
      fin: "retrouve ses esprits",
      msgSave: "retrouver ses esprits",
      prejudiciable: true,
      visible: true
    },
    regeneration: {
      activation: "commence \xE0 se r\xE9g\xE9n\xE9rer",
      actif: "se r\xE9g\xE9n\xE8re",
      fin: "a fini de se r\xE9g\xE9n\xE9rer",
      soins: true,
      visible: true
    },
    arbreAnime: {
      activation: "commence \xE0 bouger",
      actif: "est un arbre anim\xE9",
      fin: "redevient un arbre ordinaire",
      visible: true
    },
    objetAnime: {
      activation: "commence \xE0 bouger",
      actif: "est un objet anim\xE9",
      fin: "redevient un objet ordinaire",
      visible: true
    },
    magnetisme: {
      activation: "contr\xF4le le magn\xE9tisme",
      actif: "contr\xF4le le magn\xE9tisme",
      fin: "relache son contr\xF4le du magn\xE9tisme"
    },
    hate: {
      activation: "voit son m\xE9tabolisme s'acc\xE9l\xE9rer",
      actif: "peut faire une action de plus par tour",
      fin: "retrouve un m\xE9tabolisme normal (plus d'action suppl\xE9mentaire)"
    },
    ailesCelestes: {
      activation: "sent des ailes c\xE9lestes lui pousser dans le dos",
      actif: "poss\xE8de des ailes c\xE9lestes",
      fin: "n'a plus d'aile c\xE9leste. Esp\xE9rons qu'il \xE9tait au sol...",
      visible: true
    },
    sanctuaire: {
      activation: "lance un sort de sanctuaire",
      actif: "est prot\xE9g\xE9 par un sanctuaire",
      fin: "n'est plus prot\xE9g\xE9 par le sanctuaire"
    },
    rechargeSouffle: {
      activation: "doit maintenant attendre un peu avant de pouvoir le refaire",
      actif: "attends avant de pouvoir refaire un souffle",
      fin: "a r\xE9cup\xE9r\xE9"
    },
    paralysieRoublard: {
      activation: "est paralys\xE9 par la douleur",
      activationF: "est paralys\xE9e par la douleur",
      actif: "ne peut pas attaquer ni se d\xE9placer",
      fin: "peut \xE0 nouveau attaquer et se d\xE9placer",
      msgSave: "r\xE9sister \xE0 la douleur",
      prejudiciable: true,
      seulementVivant: true,
      visible: true,
      entrave: true
    },
    mutationOffensive: {
      activation: "\xE9change une partie de son corps avec celle d'une cr\xE9ature monstrueuse",
      actif: "poss\xE8de un appendice monstrueux",
      fin: "retrouve un corps normal",
      visible: true
    },
    formeDArbre: {
      activation: "se transorme en arbre",
      actif: "est transform\xE9 en arbre",
      fin: "retrouve sa forme normale",
      visible: true
    },
    statueDeBois: {
      activation: "se transforme en statue de bois",
      actif: "est transform\xE9 en statue de bois",
      fin: "retrouve sa forme normale",
      msgSave: "ne plus \xEAtre une statue de bois",
      prejudiciable: true,
      visible: true
    },
    clignotement: {
      activation: "dispara\xEEt, puis r\xE9appara\xEEt",
      actif: "clignote",
      fin: "ne dispara\xEEt plus",
      visible: true
    },
    agitAZeroPV: {
      activation: "continue \xE0 agir malgr\xE9 les blessures",
      actif: "devrait \xEAtre \xE0 terre",
      fin: "subit l'effet de ses blessures",
      visible: true
    },
    predateurConjure: {
      activation: "appara\xEEt depuis un autre plan",
      actif: "est un pr\xE9dateur conjur\xE9",
      fin: "dispara\xEEt",
      dm: true
    },
    champDeProtection: {
      activation: "devient prot\xE9g\xE9 par un champ t\xE9l\xE9kin\xE9tique",
      actif: "est prot\xE9g\xE9 par un champ t\xE9l\xE9kin\xE9tique",
      fin: "n'est plus sous l'effet d'un champ de protection",
    },
    attaqueArmeeConjuree: {
      activation: "se bat contre une arm\xE9e conjur\xE9e",
      actif: "se bat contre une arm\xE9e conjur\xE9e",
      fin: "ne se bat plus contre l'arm\xE9e conjur\xE9e"
    },
    rechargeDuKiai: {
      activation: "pousse un kiai",
      actif: "ne peut pas encore pousser un autre kiai",
      fin: "peut pousser un autre kiai"
    },
    memePasMalBonus: {
      activation: "enrage suite au coup critique",
      actif: "a subit un coup critique",
      fin: "ne b\xE9n\xE9ficie plus des effets de m\xEAme pas mal"
    },
    attaqueRisquee: {
      activation: "fait une attaque risqu\xE9e",
      actif: "s'est mis en danger par une attaque risqu\xE9e",
      fin: "retrouve une position moins risqu\xE9e",
    },
    peauDePierreMag: {
      activation: "transforme sa peau en pierre",
      actif: "voit ses d\xE9g\xE2ts r\xE9duits par sa Peau de pierre",
      fin: "retrouve sa peau normale",
      visible: true
    },
    expose: {
      activation: "s'expose aux attaques de sa cible",
      actif: "est expos\xE9 aux attaques de son adversaire",
      fin: "n'est plus expos\xE9",
      msgSave: "ne plus s'exposer",
      prejudiciable: true
    },
    effetRetarde: {
      activation: "il va bient\xF4t se produire quelque chose",
      actif: "s'attend \xE0 un effet",
      fin: "effet retard\xE9 activ\xE9",
      generic: true,
      prejudiciable: true
    },
    messageRetarde: {
      activation: "il va bient\xF4t se produire quelque chose",
      actif: "s'attend \xE0 un effet",
      fin: "effet activ\xE9",
      generic: true
    },
    detectionDeLInvisible: {
      activation: "voit les choses invibles et cach\xE9es",
      actif: "d\xE9tecte l'invisible",
      fin: "ne voit plus les choses invisibles",
    },
    bonusAttaqueTemp: {
      activation: "affecte son attaque",
      actif: "a son attaque affect\xE9e",
      fin: "retrouve son attaque normale",
    },
    enerve: {
      activation: "est \xE9nerv\xE9 par ces railleries",
      activationF: "est \xE9nerv\xE9e par ces railleries",
      actif: "est \xE9nerv\xE9",
      fin: "retrouve son calme",
      msgSave: "retrouver son calme",
      prejudiciable: true,
      visible: true
    },
    cercleDeProtection: {
      activation: "est prot\xE9g\xE9 par le Cercle de protection",
      activationF: "est prot\xE9g\xE9e par le Cercle de protection",
      actif: "est dans le Cercle de protection",
      fin: "sort du Cercle de protection",
    },
    tenebres: {
      activation: "lance un sort de T\xE9n\xE8bres",
      actif: "maintient un sort de T\xE9n\xE8bres",
      fin: "les t\xE9n\xE8bres se dissipent",
      visible: true
    },
    progresserACouvert: {
      activation: "est \xE0 couvert de bouclier",
      actif: "est \xE0 couvert de bouclier",
      fin: "n'est plus \xE0 couvert de bouclier"
    },
    cyclone: {
      activation: "se transforme en tourbillon de mati\xE8re \xE9l\xE9mentaire",
      actif: "est en cyclone",
      fin: "retrouve sa forme habituelle",
      visible: true
    },
    momentDePerfection: {
      activation: "atteint un instant de perfection",
      actif: "semble tout voir au ralenti autour de lui",
      fin: "voit le temps reprendre son cours normal",
    },
    armeeDesMorts: {
      activation: "invoque d'innombrables squelettes \xE9mergeant du sol",
      actif: "invoque d'innombrables squelettes",
      fin: "laisse les morts en paix",
      visible: true
    },
    demonInvoque: {
      activation: "appara\xEEt depuis un autre plan",
      actif: "est un d\xE9mon invoqu\xE9",
      fin: "dispara\xEEt",
      dm: true
    },
    degradationZombie: {
      activation: "se rel\xE8ve d'entre les morts",
      actif: "est un zombie anim\xE9",
      fin: "tombe en poussi\xE8re",
      dm: true
    },
    hemorragie: {
      activation: "saigne \xE0 la moindre blessure",
      actif: "saigne \xE0 la moindre blessure",
      fin: "soigne son h\xE9morragie",
      msgSave: "gu\xE9rir de son h\xE9morragie",
      prejudiciable: true
    },
    lienDeSang: {
      activation: "est li\xE9 par le sang",
      activationF: "est li\xE9e par le sang",
      actif: "a un lien de sang",
      fin: "perd son lien de sang",
      msgSave: "ne plus \xEAtre li\xE9 par le sang",
      prejudiciable: true
    },
    tenirADistance: {
      activation: "utilise son allonge pour tenir ses ennemis \xE0 distance",
      actif: "utilise son allonge pour tenir ses ennemis \xE0 distance",
      fin: "ne tient plus ses ennemis \xE0 distance"
    },
    reactionViolente: {
      activation: "est pris de folie et attaque la personne qui s'est moqu\xE9e de lui",
      activationF: "est prise de folie et attaque la personne qui s'est moqu\xE9e d'elle",
      actif: "a une r\xE9action violente et doit attaquer",
      fin: "reprend son calme",
      msgSave: "r\xE9sister \xE0 la provocation",
      prejudiciable: true,
    },
  };

  function buildPatternEffets(listeEffets, postfix) {
    if (postfix && postfix.length === 0) postfix = undefined;
    var expression = "(";
    expression = _.reduce(listeEffets, function(reg, msg, effet) {
      var res = reg;
      if (res !== "(") res += "|";
      res += "^" + effet;
      if (msg.generic) res += "\\([^)_]*\\)";
      res += "(";
      if (postfix) {
        postfix.forEach(function(p, i) {
          if (i) res += "|";
          res += p + "$|" + p + "_";
        });
      } else res += "$|_";
      res += ")";
      return res;
    }, expression);
    expression += ")";
    return new RegExp(expression);
  }

  var patternEffetsTemp = buildPatternEffets(messageEffetTemp);

  function estEffetTemp(name) {
    return (patternEffetsTemp.test(name));
  }

  var patternAttributEffetsTemp = buildPatternEffets(messageEffetTemp, ["Puissant", "Valeur", "SaveParTour", "SaveParTourType", "TempeteDeManaIntense", "Options"]);

  function estAttributEffetTemp(name) {
    return (patternAttributEffetsTemp.test(name));
  }

  //On sait d\xE9j\xE0 que le nom a pass\xE9 le test estEffetTemp
  function effetTempOfAttribute(attr) {
    var ef = attr.get('name');
    if (ef === undefined || messageEffetTemp[ef]) return ef;
    //D'abord on enl\xE8ve le nom du token
    var pu = ef.indexOf('_');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetTemp[ef]) return ef;
    }
    //Ensuite on enl\xE8ve les parties entre parenth\xE8se pour les effets g\xE9n\xE9riques
    pu = ef.indexOf('(');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetTemp[ef]) return ef;
    }
    error("Impossible de d\xE9terminer l'effet correspondant \xE0 " + ef, attr);
  }

  function messageOfEffetTemp(effetC) {
    var res = messageEffetTemp[effetC];
    if (res) return res;
    var p = effetC.indexOf('(');
    if (p > 0) {
      var ef = effetC.substring(0, p);
      res = messageEffetTemp[ef];
      return res;
    }
    error("Effet temporaire non trouv\xE9", effetC);
  }

  const messageEffetCombat = {
    armureMagique: {
      activation: "est entour\xE9 d'un halo magique",
      actif: "est prot\xE9g\xE9 par une armure magique",
      fin: "n'est plus entour\xE9 d'un halo magique"
    },
    armureDuMage: {
      activation: "fait appara\xEEtre un nuage magique argent\xE9 qui le prot\xE8ge",
      actif: "est entour\xE9 d'une armure du mage",
      fin: "n'a plus son armure du mage"
    },
    armureDEau: {
      activation: "fait appara\xEEtre une couche d'eau de quelques centim\xE8tres qui le prot\xE8ge",
      actif: "est entour\xE9 d'une armure d'eau'",
      fin: "n'a plus son armure d'eau'"
    },
    armeDArgent: {
      activation: "cr\xE9e une arme d'argent et de lumi\xE8re",
      actif: "poss\xE8de une arme d'argent et de lumi\xE8re",
      fin: "ne poss\xE8de plus d'arme d'argent et de lumi\xE8re",
      dm: true
    },
    criDeGuerre: {
      activation: "pousse son cri de guerre",
      actif: "a effray\xE9 ses adversaires",
      fin: ""
    },
    criDuPredateur: {
      activation: "pousse un hurlement effrayant",
      actif: "a lib\xE9r\xE9 son \xE2me de pr\xE9dateur",
      fin: ""
    },
    danseDesLames: {
      activation: "entre en transe",
      actif: "danse la danse des lames",
      fin: "termine sa danse des lames"
    },
    protectionContreLeMal: {
      activation: "re\xE7oit une b\xE9n\xE9diction de protection contre le mal",
      actif: "est prot\xE9g\xE9 contre le mal",
      fin: "n'est plus prot\xE9g\xE9 contre le mal"
    },
    rageDuBerserk: {
      activation: "entre dans une rage berserk",
      actif: "est dans une rage berserk",
      fin: "retrouve son calme",
      msgSave: "retrouver son calme",
    },
    enrage: {
      activation: "devient enrag\xE9",
      actif: "est enrag\xE9",
      fin: "retrouve son calme",
      msgSave: "retrouver son calme",
    },
    bonusInitEmbuscade: { //Effet interne pour la capacit\xE9 Surveillance
      activation: "a un temps d'avance en cas d'embuscade",
      actif: "a un temps d'avance",
      fin: ""
    },
    putrefactionOutreTombe: {
      activation: "sent ses chairs pourrir",
      actif: "subit le contrecoup d'une putr\xE9faction",
      fin: "se remet de la putr\xE9faction",
      msgSave: "ne plus \xEAtre putr\xE9fi\xE9",
      prejudiciable: true,
      dm: true
    },
    bonusInitVariable: {
      activation: "entre en combat",
      actif: "est en combat",
      fin: ''
    },
    defiSamourai: {
      activation: "lance un d\xE9fi",
      actif: "a lanc\xE9 un d\xE9fi",
      fin: ''
    },
    agrippe: {
      activation: "agrippe sa cible",
      actif: "agrippe sa cible",
      fin: "lache sa cible"
    },
    estAgrippePar: {
      activation: "est agripp\xE9",
      actif: "est agripp\xE9",
      fin: "se lib\xE8re",
      msgSave: "se lib\xE9rer",
      entrave: true
    },
    devore: {
      activation: "saisit sa cible",
      actif: "saisit sa cible",
      fin: "lache sa cible",
    },
    estDevorePar: {
      activation: "est saisi",
      actif: "est saisi",
      fin: "se lib\xE8re",
      msgSave: "se lib\xE9rer",
      entrave: true
    },
    aGobe: {
      activation: "avale sa cible",
      actif: "a aval\xE9 une cr\xE9ature vivante",
      fin: "dig\xE8re sa cible"
    },
    estGobePar: {
      activation: "est aval\xE9",
      actif: "est dans le ventre d'une cr\xE9ature",
      fin: "fin de la digestion, sort du ventre",
      msgSave: "sortir du ventre",
      entrave: true
    },
    inconfort: {
      activation: "commence \xE0 \xEAtre g\xEAn\xE9 par son armure",
      actif: "est g\xEAn\xE9 par son armure",
      fin: "r\xE9ajuste son armure",
    },
    noyade: {
      activation: "commence \xE0 se noyer",
      actif: "se noie",
      fin: "peut \xE0 nouveau respirer",
      msgSave: "surnager",
      prejudiciable: true,
      seulementVivant: true,
      dm: true,
      visible: true
    },
    blessureQuiSaigne: {
      activation: "re\xE7oit une blessure qui saigne",
      actif: "saigne \xE0 cause d'une blessure",
      fin: "saigne beaucoup moins",
      msgSave: "ne plus saigner",
      prejudiciable: true,
      dm: true
    },
  };

  var patternEffetsCombat = buildPatternEffets(messageEffetCombat);

  function estEffetCombat(name) {
    return (patternEffetsCombat.test(name));
  }

  var patternAttributEffetsCombat = buildPatternEffets(messageEffetCombat, ["Puissant", "Valeur", "SaveParTour", "SaveParTourType", "TempeteDeManaIntense", "Options"]);

  function estAttributEffetCombat(name) {
    return (patternAttributEffetsCombat.test(name));
  }

  function effetCombatOfAttribute(attr) {
    var ef = attr.get('name');
    if (ef === undefined || messageEffetCombat[ef]) return ef;
    //D'abord on enl\xE8ve le nom du token
    var pu = ef.indexOf('_');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetCombat[ef]) return ef;
    }
    error("Impossible de d\xE9terminer l'effet correspondant \xE0 " + ef, attr);
  }

  // Si un effet est prejudiciable, enlev\xE9 par d\xE9livrance
  const messageEffetIndetermine = {
    foretVivanteEnnemie: {
      activation: "est g\xEAn\xE9 par la for\xEAt",
      actif: "est d\xE9sorient\xE9 par la for\xEAt",
      fin: "se retrouve dans une for\xEAt normale",
      entrave: true
    },
    marcheSylvestre: {
      activation: "se deplace maintenant en terrain difficile",
      actif: "profite du terrain difficile",
      fin: "est maintenant en terrain normal"
    },
    mutationCuirasse: {
      activation: "endurcit sa peau",
      actif: "a la peau recouverte d'une cuirasse",
      fin: "retrouve une peau normale"
    },
    mutationEcaillesRouges: {
      activation: "recouvre sa peau d'\xE9cailles rouges",
      actif: "a la peau recouverte d'\xE9cailles rouges",
      fin: "retrouve une peau normale"
    },
    mutationFourrureViolette: {
      activation: "se fait pousser une fourrure violette",
      actif: "a la peau recouverte d'une fourrure violette",
      fin: "retrouve une peau normale"
    },
    mutationMusclesHypertrophies: {
      activation: "devient plus muscl\xE9",
      actif: "a les muscles hypertrophi\xE9s",
      fin: "retrouve des muscles normaux",
    },
    mutationOuies: {
      activation: "se fait pousser des ou\xEFes",
      actif: "poss\xE8de des ou\xEFes",
      fin: "n'a plus d'ou\xEFes"
    },
    mutationSangNoir: {
      activation: "prend un teint plus sombre",
      actif: "a le sang noir",
      fin: "retrouve un sang normal"
    },
    mutationSilhouetteFiliforme: {
      activation: "devient plus fin",
      actif: "a une silhouette filiforme",
      fin: "retrouve une silhouette normale",
    },
    mutationSilhouetteMassive: {
      activation: "devient plus massif",
      actif: "a une silhouette massive",
      fin: "retrouve une silhouette normale",
    },
    fievreux: {
      activation: "se sent fi\xE9vreux",
      activationF: "se sent fi\xE9vreuse",
      actif: "est fi\xE9vreux",
      fin: "se sent mieux",
      prejudiciable: true
    },
    presenceGlaciale: {
      activation: "transforme son corps en glace vivante",
      actif: "est form\xE9 de glace",
      fin: "retrouve un corps normal",
    },
    sixiemeSens: {
      activation: "fait un rituel de divination",
      actif: "sait un peu \xE0 l'avance ce qu'il va se passer",
      fin: "l'effet du rituel de divination prend fin",
    },
    charme: {
      activation: "devient un ami de longue date",
      actif: "est sous le charme de quelqu'un",
      fin: "retrouve ses esprits",
      prejudiciable: true
    },
    constructionTailleHumaine: {
      activation: "rentre dans une construction de taille humaine.",
      actif: "est un peu \xE0 l'\xE9troit, le b\xE2timent est trop petit",
      fin: "sort de la construction de taille humains."
    },
    espaceExigu: {
      activation: "entre dans un espace exigu.",
      actif: "est \xE0 l'\xE9troit.",
      fin: "sort de l'espace exigu."
    },
    sangDeLArbreCoeur: {
      activation: "boit une potion de Sang de l'Arbre-Coeur",
      actif: "a bu une potion de Sang de l'Arbre-Coeur",
      fin: "les effets de la potion de Sang de l'Arbre-Coeur diminuent un peu"
    },
    ondesCorruptrices: { //nombre, \xE0 mettre avec !cof-effet ondesCorruptrices 2
      activation: "se sent naus\xE9eux",
      actif: "se sent naus\xE9eux",
      fin: "se sent un peu mieux",
      prejudiciable: true
    },
    reactionAllergique: {
      activation: "ressent de fortes d\xE9mangeaisons",
      actif: "est victime d'une r\xE9action allergique",
      fin: "les d\xE9amgeaisons cessent",
      prejudiciable: true
    },
  };

  const patternEffetsIndetermine = buildPatternEffets(messageEffetIndetermine);

  function estEffetIndetermine(name) {
    return (patternEffetsIndetermine.test(name));
  }

  function effetIndetermineOfAttribute(attr) {
    let ef = attr.get('name');
    if (ef === undefined || messageEffetIndetermine[ef]) return ef;
    //D'abord on enl\xE8ve le nom du token
    let pu = ef.indexOf('_');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetIndetermine[ef]) return ef;
    }
    error("Impossible de d\xE9terminer l'effet correspondant \xE0 " + ef, attr);
  }

  function attributeExtending(charId, attrName, effetC, extension) {
    var nameWithExtension = effetC + extension + attrName.substr(effetC.length);
    return findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: nameWithExtension
    });
  }

  //L'argument effetC doit \xEAtre le nom complet, pas la base
  //evt.deletedAttributes doit \xEAtre d\xE9fini
  function enleverEffetAttribut(charId, effetC, attrName, extension, evt) {
    var attrSave = attributeExtending(charId, attrName, effetC, extension);
    attrSave.
    forEach(function(attrS) {
      evt.deletedAttributes.push(attrS);
      attrS.remove();
    });
  }

  //Nom de l'effet, avec la partie g\xE9n\xE9rique, mais sans le nom de token
  function effetComplet(effet, attrName) {
    if (effet == attrName) return effet;
    //On a un effet li\xE9 \xE0 un token ou bien un effet g\xE9n\xE9rique
    if (attrName.charAt(effet.length) == '(') {
      var p = attrName.indexOf(')', effet.length);
      if (p > 0) return attrName.substring(0, p + 1);
    }
    return effet;
  }

  function rollAndDealDmg(perso, dmg, type, effet, attrName, msg, count, evt, options, callback, display) {
    var dmgExpr = dmg;
    var tdmi = attributeAsInt(perso, effet + 'TempeteDeManaIntense', 0);
    if (dmg.de) {
      if (tdmi) {
        dmgExpr = (tdmi + dmg.nbDe) + 'd' + dmg.de;
        removeTokenAttr(perso, effet + 'TempeteDeManaIntense', evt);
      } else dmgExpr = dmg.nbDe + 'd' + dmg.de;
    } else if (dmg.cst) {
      if (tdmi) {
        dmgExpr = dmg.cst * (1 + tdmi);
        removeTokenAttr(perso, effet + 'TempeteDeManaIntense', evt);
      } else dmgExpr = dmg.cst;
    } else if (options.dotGen) {
      //alors dmg = '' et type = ''
      var valAttr = tokenAttribute(perso, effet + 'Valeur');
      if (valAttr.length === 0) {
        //Par d\xE9faut, 1d6 DM normaux
        dmgExpr = "1d6";
        type = 'normal';
      } else {
        dmgExpr = valAttr[0].get('current');
        type = valAttr[0].get('max');
        if (type === '') type = 'normal';
      }
    }
    var optionsAttr = tokenAttribute(perso, effet + 'Options');
    optionsAttr.forEach(function(oAttr) {
      parseDmgOptions(oAttr.get('current'), options);
    });
    copyDmgOptionsToTarget(perso, options);
    sendChat('', "[[" + dmgExpr + "]]", function(res) {
      var rolls = res[0];
      var dmgRoll = rolls.inlinerolls[0];
      var r = {
        total: dmgRoll.results.total,
        type: type,
        display: buildinline(dmgRoll, type)
      };
      var explications;
      if (display) explications = [];
      dealDamage(perso, r, [], evt, false, options, explications,
        function(dmgDisplay, dmg) {
          if (dmg > 0) {
            var msgDm;
            if (msg) msgDm = msg + '. ' + onGenre(perso, 'Il', 'Elle');
            else msgDm = '';
            if (display) {
              explications.forEach(function(m) {
                addLineToFramedDisplay(display, m);
              });
              addLineToFramedDisplay(display, perso.token.get('name') + ' ' + msgDm + " subit " + dmgDisplay + " DM");
              sendChat('', endFramedDisplay(display));
            } else if (effet == attrName) {
              sendPerso(perso, msgDm + " subit " + dmgDisplay + " DM");
            } else {
              var tokenName = attrName.substring(attrName.indexOf('_') + 1);
              sendChat('', tokenName + ' ' + msgDm + " subit " + dmgDisplay + " DM");
            }
          }
          count.v--;
          if (count.v === 0) callback();
        });
    }); //fin sendChat du jet de d\xE9
  }

  //asynchrone
  // effet est le nom complet de l'effet
  function degatsParTour(charId, pageId, effet, attrName, dmg, type, msg, evt, options, callback) {
    options = options || {};
    let count;
    iterTokensOfAttribute(charId, pageId, effet, attrName,
      function(token, total) {
        if (count === undefined) count = {
          v: total
        };
        let perso = {
          token: token,
          charId: charId
        };
        if (getState(perso, 'mort')) {
          if (callback) callback();
          return;
        }
        if (options.save) {
          let playerId = getPlayerIds(perso);
          let nameEffet = effet;
          if (effet.startsWith('dotGen('))
            nameEffet = effet.substring(7, effet.indexOf(')'));
          let display = startFramedDisplay(playerId, "Effet de " + nameEffet, perso);
          let saveId = "degatsParTour_" + effet + "_" + token.id;
          let expliquer = function(m) {
            addLineToFramedDisplay(display, m);
          };
          let msgPour = " pour ne pas prendre de d\xE9g\xE2ts de " + nameEffet;
          let sujet = onGenre(perso, 'il', 'elle');
          let msgReussite = ", " + sujet + " ne perd pas de PV ce tour";
          let saveOpts = {
            msgPour: msgPour,
            msgReussite: msgReussite,
            rolls: options.rolls,
            chanceRollId: options.chanceRollId,
            type: type
          };
          save(options.save, perso, saveId, expliquer, saveOpts, evt, function(reussite, texte) {
            if (reussite) {
              sendChat('', endFramedDisplay(display));
              return;
            }
            rollAndDealDmg(perso, dmg, type, effet, attrName, msg, count, evt, options, callback, display);
          });
          return;
        }
        rollAndDealDmg(perso, dmg, type, effet, attrName, msg, count, evt, options, callback);
      }); //fin iterTokensOfAttribute
  }

  //asynchrone
  function soigneParTour(charId, pageId, effet, attrName, soinsExpr, msg, evt, options, callback) {
    options = options || {};
    msg = msg || '';
    var count = -1;
    iterTokensOfAttribute(charId, pageId, effet, attrName,
      function(token, total) {
        if (count < 0) count = total;
        var perso = {
          token: token,
          charId: charId
        };
        var tdmi = attributeAsInt(perso, effet + "TempeteDeManaIntense", 0);
        if (tdmi) {
          soinsExpr = "(" + soinsExpr + ")*" + (1 + tdmi);
          removeTokenAttr(perso, effet + "TempeteDeManaIntense", evt);
        }
        var localSoinsExpr = soinsExpr;
        if (options.valeur) {
          var attrsVal = tokenAttribute(perso, options.valeur);
          if (attrsVal.length > 0) localSoinsExpr = attrsVal[0].get('current');
        }
        sendChat('', "[[" + localSoinsExpr + "]]", function(res) {
          var rolls = res[0];
          var soinRoll = rolls.inlinerolls[0];
          var soins = soinRoll.results.total;
          var displaySoins = buildinline(soinRoll, 'normal', true);
          soigneToken(perso, soins, evt,
            function(s) {
              if (s < soins) sendPerso(perso, "r\xE9cup\xE8re tous ses PV.");
              else sendPerso(perso, "r\xE9cup\xE8re " + displaySoins + " PV.");
              count--;
              if (count === 0) callback();
            },
            function() {
              count--;
              if (count === 0) callback();
            });
        }); //fin sendChat du jet de d\xE9
      }); //fin iterTokensOfAttribute
  }

  function getEffectOptions(perso, effet) {
    var options = {};
    var optionsAttr = tokenAttribute(perso, effet + 'Options');
    optionsAttr.forEach(function(oAttr) {
      parseDmgOptions(oAttr.get('current'), options);
    });
    copyDmgOptionsToTarget(perso, options);
    return options;
  }

  // gestion des effets qui se d\xE9clenchent \xE0 la fin de chaque tour
  // N'ajoute pas evt \xE0 l'historique
  // Asynchrone (\xE0 cause des saves par tour)
  function changementDeTour(tour, attrs, evt, pageId, options) {
    // Enlever les bonus d'un tour
    attrs = removeAllAttributes('limiteParTour', evt, attrs);
    attrs = removeAllAttributes('actionConcertee', evt, attrs);
    attrs = removeAllAttributes('interposer', evt, attrs);
    attrs = removeAllAttributes('exemplaire', evt, attrs);
    attrs = removeAllAttributes('peutEtreDeplace', evt, attrs);
    attrs = removeAllAttributes('attaqueMalgreMenace', evt, attrs);
    attrs = removeAllAttributes('prescienceUtilisee', evt, attrs);
    attrs = removeAllAttributes('increvableHumainUtilise', evt, attrs);
    resetAttr(attrs, 'cercleDeProtectionActif', evt);
    // Pour d\xE9faut dans la cuirasse, on diminue si la valeur est 2, et on supprime si c'est 1
    let defautsDansLaCuirasse = allAttributesNamed(attrs, 'defautDansLaCuirasse');
    defautsDansLaCuirasse.forEach(function(attr) {
      if (attr.get('current') < 2) {
        if (evt.deletedAttributes) evt.deletedAttributes.push(attr);
        else evt.deletedAttributes = [attr];
        attr.remove();
      } else {
        var prevAttr = {
          attribute: attr,
          current: 2
        };
        evt.attributes.push(prevAttr);
        attr.set('current', 1);
      }
    });
    // Pour la feinte, on augmente la valeur, et on supprime si la valeur est 2
    let feinte = allAttributesNamed(attrs, 'feinte');
    feinte.forEach(function(attr) {
      var valFeinte = parseInt(attr.get('current'));
      if (isNaN(valFeinte) || valFeinte > 0) {
        evt.deletedAttributes.push(attr);
        attr.remove();
      } else {
        var prevAttr = {
          attribute: attr,
          current: 0
        };
        evt.attributes.push(prevAttr);
        attr.set('current', 1);
      }
    });
    //Les tests rat\xE9s
    let trTour = allAttributesNamed(attrs, 'testsRatesDuTour');
    trTour.forEach(function(tr) {
      let curTr = tr.get('current');
      if (curTr === '') {
        evt.deletedAttributes.push(tr);
        tr.remove();
      } else {
        let maxTr = tr.get('max');
        evt.attributes.push({
          attribute: tr,
          current: curTr,
          max: maxTr
        });
        tr.set('max', curTr);
        tr.set('current', '');
      }
    });
    let vapeth = allAttributesNamed(attrs, 'vapeursEthyliques');
    vapeth.forEach(function(attr) {
      let ve = parseInt(attr.get('current'));
      if (isNaN(ve)) ve = 0;
      evt.attributes.push({
        attribute: attr,
        current: 0
      });
      attr.set('current', ve + 1);
      var veCharId = attr.get('characterid');
      if (veCharId === undefined || veCharId === '') {
        error("Attribut sans personnage associ\xE9", attr);
        return;
      }
      var veSeuil = parseInt(attr.get('max'));
      if (isNaN(veSeuil)) veSeuil = 0;
      veSeuil -= Math.floor(ve / 2);
      iterTokensOfAttribute(veCharId, stateCOF.combat_pageid,
        'vapeursEthyliques', attr.get('name'),
        function(tok) {
          var perso = {
            charId: veCharId,
            token: tok
          };
          var testId = 'vapeursEthyliques_' + perso.token.id;
          testCaracteristique(perso, 'CON', veSeuil, testId, options, evt, function(testRes) {
            var res = "tente un jet de CON " + veSeuil + " pour combattre les vapeurs \xE9thyliques " + testRes.texte;
            if (testRes.reussite) {
              res += " => r\xE9ussi." + testRes.modifiers;
              var expliquer;
              if (attr.get('name') == 'vapeursEthyliques') {
                expliquer = function(s) {
                  sendChar(veCharId, s, true);
                };
              } else {
                perso.tokName = tok.get('name');
                expliquer = function(s) {
                  sendChat('', perso.tokName + ' ' + s);
                };
              }
              expliquer(res);
              diminueEbriete(perso, evt, expliquer);
            } else {
              res += " => rat\xE9" + testRes.rerolls + testRes.modifiers;
              sendPerso(perso, res);
            }
          });
        });
    });
    // nouveau tour : enlever le statut surpris
    // et faire les actions de d\xE9but de tour
    let selected = [];
    updateNextInitSet.forEach(function(id) {
      selected.push({
        _id: id
      });
    });
    let allTokens = findObjs({
      _type: 'graphic',
      _subtype: 'token',
      _pageid: pageId,
      layer: 'objects'
    });
    let allPersos = [];
    allTokens.forEach(function(token) {
      let charId = token.get('represents');
      if (charId === '') return;
      let c = getObj('character', charId);
      if (c === undefined) {
        token.remove();
        return;
      }
      allPersos.push({
        token,
        charId
      });
    });
    allPersos.forEach(function(perso) {
      if (getState(perso, 'surpris')) { //surprise
        setState(perso, 'surpris', false, {});
        selected.push({
          _id: perso.token.id
        });
      }
      if (getState(perso, 'enseveli')) {
        let degats = rollDePlus(6, {
          nbDes: 2
        });
        let dmg = {
          type: 'magique',
          total: degats.val,
          display: degats.roll
        };
        dealDamage(perso, dmg, [], evt, false, {}, undefined,
          function(dmgDisplay, dmgFinal) {
            sendPerso(perso, " est \xE9cras\xE9 ! " +
              onGenre(perso, 'Il', 'Elle') + " subit " + dmgDisplay + " DM");
          });
      }
      let enflammeAttr = tokenAttribute(perso, 'enflamme');
      if (enflammeAttr.length > 0) {
        let enflamme = parseInt(enflammeAttr[0].get('current'));
        // Pour ne pas faire les d\xE9g\xE2ts plusieurs fois (plusieurs tokens pour un m\xEAme personnage), on utilise la valeur max de l'attribut
        var dernierTourEnflamme = parseInt(enflammeAttr[0].get('max'));
        if ((isNaN(dernierTourEnflamme) || dernierTourEnflamme < tour) &&
          !isNaN(enflamme) && enflamme > 0) {
          let d6Enflamme = randomInteger(6);
          let feu = d6Enflamme + enflamme - 1;
          let dmgEnflamme = {
            type: 'feu',
            total: feu,
            display: feu
          };
          if (getState(perso, 'mort')) {
            sendChat('', "Le cadavre de " + perso.token.get('name') + " continue de br\xFBler");
          } else {
            dealDamage(perso, dmgEnflamme, [], evt, false, {}, undefined,
              function(dmgDisplay, dmgFinal) {
                sendPerso(perso, " est en flamme ! " +
                  onGenre(perso, 'Il', 'Elle') + " subit " + dmgDisplay + " DM");
              });
          }
          if (d6Enflamme < 3) {
            sendPerso(perso, ": les flammes s'\xE9teignent");
            removeTokenAttr(perso, 'enflamme', evt);
          } else {
            enflammeAttr[0].set('max', tour);
          }
        }
      }
      if (attributeAsBool(perso, 'estGobePar') && !getState(perso, 'mort')) {
        let jet = rollDePlus(6, {
          nbDes: 3
        });
        let dmg = {
          type: 'normal', //correspond \xE0 de l'asphyxie
          total: jet.val,
          display: jet.roll
        };
        if (immuniseAsphyxie(perso)) dmg.type = 'acide';
        dealDamage(perso, dmg, [], evt, false, {}, undefined,
          function(dmgDisplay, dmgFinal) {
            sendPerso(perso, "est en train d'\xEAtre dig\xE9r\xE9. " + onGenre(perso, 'Il', 'Elle') + " perd " + dmgDisplay + " PVs");
          });
      }
      if (attributeAsBool(perso, 'blessureQuiSaigne') &&
        !getState(perso, 'mort') &&
        !predicateAsBool(perso, 'immuniteSaignement') &&
        !predicateAsBool(perso, 'controleSanguin')) {
        let jetSaignement = rollDePlus(6);
        let dmgSaignement = {
          type: 'normal',
          total: jetSaignement.val,
          display: jetSaignement.roll
        };
        let optDMSaignements = getEffectOptions(perso, 'blessureQuiSaigne');
        dealDamage(perso, dmgSaignement, [], evt, false, optDMSaignements, undefined,
          function(dmgDisplay, dmgFinal) {
            sendPerso(perso, "saigne. " + onGenre(perso, 'Il', 'Elle') + " perd " + dmgDisplay + " PVs");
          });
      }
      if (attributeAsBool(perso, 'noyade') && !getState(perso, 'mort') && !immuniseAsphyxie(perso)) {
        let playerId = getPlayerIds(perso);
        let display = startFramedDisplay(playerId, "Noyade", perso);
        let saveId = "Noyade_" + perso.token.id;
        let expliquer = function(m) {
          addLineToFramedDisplay(display, m);
        };
        let msgPour = " pour ne pas prendre de d\xE9g\xE2ts de noyade";
        let sujet = onGenre(perso, 'il', 'elle');
        let msgReussite = ", " + sujet + " ne perd pas de PV ce tour";
        let saveOpts = {
          msgPour: msgPour,
          msgReussite: msgReussite,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: 'normal'
        };
        var saveNoyade = {
          carac: 'CON',
          seuil: 15
        };
        save(saveNoyade, perso, saveId, expliquer, saveOpts, evt, function(reussite, texte) {
          if (reussite) {
            sendChat('', endFramedDisplay(display));
            return;
          }
          var jetNoyade = rollDePlus(6);
          var dmNoyade = {
            type: 'normal',
            total: jetNoyade.val,
            display: jetNoyade.roll
          };
          var explications = [];
          dealDamage(perso, dmNoyade, [], evt, false, options, explications,
            function(dmgDisplay, dmg) {
              explications.forEach(function(m) {
                addLineToFramedDisplay(display, m);
              });
              addLineToFramedDisplay(display, perso.token.get('name') + "se noie et subit " + dmgDisplay + " DM");
              sendChat('', endFramedDisplay(display));
            });
        });
      }
      let vitaliteSurnatAttr = charAttribute(perso.charId, 'vitaliteSurnaturelle');
      if (vitaliteSurnatAttr.length > 0) {
        var vitaliteSurnat = vitaliteSurnatAttr[0].get('current');
        var regenereMemeMort;
        if ((vitaliteSurnat + '').trim().endsWith('+')) {
          vitaliteSurnat = vitaliteSurnat.substr(0, vitaliteSurnat.length - 1);
          regenereMemeMort = true;
        }
        if (regenereMemeMort || !getState(perso, 'mort')) {
          vitaliteSurnat = parseInt(vitaliteSurnat);
          if (vitaliteSurnat > 0) {
            soigneToken(perso, vitaliteSurnat, evt,
              function(s) {
                whisperChar(perso.charId, 'r\xE9cup\xE8re ' + s + ' PVs.');
              },
              function() {}, {
                saufDMType: vitaliteSurnatAttr[0].get('max').split(',')
              }
            );
          }
        }
      }
      if (attributeAsBool(perso, 'sangDeLArbreCoeur') && !getState(perso, 'mort')) {
        soigneToken(perso, 5, evt,
          function(s) {
            whisperChar(perso.charId, "r\xE9g\xE9n\xE8re " + s + " PVs. (gr\xE2ce \xE0 la potion de sang de l'Arbre Coeur)");
          },
          function() {}
        );
      }
      let increvableActif = tokenAttribute(perso, 'increvableActif');
      if (increvableActif.length > 0) {
        increvableActif[0].remove();
        let soins = randomInteger(6) + randomInteger(6) + randomInteger(6) + modCarac(perso, 'constitution');
        soigneToken(perso, soins, evt, function(soinsEffectifs) {
          let msgSoins = "est increvable et r\xE9cup\xE8re ";
          if (soinsEffectifs == soins) msgSoins += soins + " points de vie";
          else msgSoins += soinsEffectifs + " PV (le jet \xE9tait " + soins + ")";
          whisperChar(perso.charId, msgSoins);
        });
      }
      let degradationZombie = attributeAsInt(perso, 'degradationZombie', -1);
      if (degradationZombie % 6 === 0) {
        let r = {
          total: 1,
          type: 'normal',
          display: 1
        };
        perso.ignoreTouteRD = true;
        dealDamage(perso, r, [], evt, false, {}, [], function() {
          // V\xE9rification si le Zombie est toujours vivant
          let tokens = getObj('graphic', perso.token.id);
          if (tokens) whisperChar(perso.charId, "se d\xE9grade et perd 1 PV");
        });
      }
    });
    setActiveToken(undefined, evt);
    initiative(selected, evt, true); // met Tour \xE0 la fin et retrie
    updateNextInitSet = new Set();
    // Saves \xE0 faire \xE0 la fin de chaque tour. Asynchrone, mais pas grave ?
    attrs.forEach(function(attr) {
      var attrName = attr.get('name');
      var indexSave = attrName.indexOf('SaveParTour');
      if (indexSave < 0) return;
      var indexSaveType = attrName.indexOf('SaveParTourType');
      if (indexSaveType > 0) return;
      var effetC = attrName.substring(0, indexSave);
      var effetTemp = estEffetTemp(effetC);
      if (!effetTemp && !estEffetCombat(effetC)) return;
      var carac = attr.get('current');
      if (!isCarac(carac)) {
        error("Save par tour " + attrName + " mal form\xE9", carac);
        return;
      }
      var seuil = parseInt(attr.get('max'));
      if (isNaN(seuil)) {
        error("Save par tour " + attrName + " mal form\xE9", seuil);
        return;
      }
      let charId = attr.get('characterid');
      attrName = effetC + attrName.substr(indexSave + 11);
      var token;
      iterTokensOfAttribute(charId, pageId, effetC, attrName, function(tok) {
        if (token === undefined) token = tok;
      });
      if (token === undefined) {
        log("Pas de token pour le save " + attrName);
        return;
      }
      var perso = {
        token: token,
        charId: charId
      };
      if (getState(perso, 'mort')) {
        return;
      }
      var attrEffet = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attrName
      });
      if (attrEffet === undefined || attrEffet.length === 0) {
        if (getObj('attribute', attr.id)) {
          error("Save sans effet temporaire " + attrName, attr);
          findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: attr.get('name').replace('SaveParTour', 'SaveParTourType')
          }).forEach(function(a) {
            a.remove();
          });
          attr.remove();
        }
        return;
      }
      attrEffet = attrEffet[0];
      var expliquer = function(msg) {
        sendPerso(perso, msg);
      };
      var met;
      if (effetTemp) met = messageOfEffetTemp(effetC);
      else met = messageEffetCombat[effetC];
      var msgPour = " pour ";
      if (met.msgSave) msgPour += met.msgSave;
      else {
        msgPour += "ne plus \xEAtre sous l'effet de ";
        if (effetC.startsWith('dotGen('))
          msgPour += effetC.substring(7, effetC.indexOf(')'));
        else msgPour += effetC;
      }
      var sujet = onGenre(perso, 'il', 'elle');
      var msgReussite = ", " + sujet + " " + met.fin;
      var msgRate = ", " + sujet + " " + met.actif;
      var saveOpts = {
        msgPour: msgPour,
        msgReussite: msgReussite,
        msgRate: msgRate,
        rolls: options.rolls,
        chanceRollId: options.chanceRollId
      };
      var attrType = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attr.get('name').replace('SaveParTour', 'SaveParTourType')
      });
      if (attrType.length > 0) {
        saveOpts.type = attrType[0].get('current');
      }
      var saveId = 'saveParTour_' + attrEffet.id + '_' + perso.token.id;
      var s = {
        carac: carac,
        seuil: seuil,
        entrave: met.entrave
      };
      save(s, perso, saveId, expliquer, saveOpts, evt,
        function(reussite, texte) { //asynchrone
          if (reussite) {
            var eff = effetC;
            if (effetTemp) eff = effetTempOfAttribute(attrEffet);
            finDEffet(attrEffet, eff, attrName, charId, evt, {
              attrSave: attr,
              pageId: pageId
            });
          }
        });
    }); //fin boucle attrSave
    //les effets d'aura possiblement aussi -> aucun ordre garanti
    let auras = attrs.filter(function(a) {
      return a.get('name').trim() == 'aura';
    });
    let gmId;
    auras.forEach(function(aura) {
      let portee = parseInt(aura.get('current'));
      if (isNaN(portee) || portee < 0) return;
      let charId = aura.get('characterid');
      let targets = {};
      //For each token representing that character
      allPersos.forEach(function(perso) {
        if (perso.charId != charId) return;
        if (getState(perso, 'mort')) return;
        let tokName;
        //On cherche ensuite les tokens \xE0 portee
        allPersos.forEach(function(target) {
          if (target.token.id == perso.token.id) return;
          if (target.charId == charId) return;
          if (distanceCombat(perso.token, target.token, pageId) > portee) return;
          tokName = tokName || perso.token.get('name');
          targets[target.token.id] = tokName;
        });
      });
      if (_.isEmpty(targets)) return;
      if (!gmId) {
        let gm = findObjs({
          _type: "player"
        }).find(function(p) {
          return playerIsGM(p.id);
        });
        if (gm) gmId = gm.id;
        else {
          error("Impossible de trouver un MJ");
          return;
        }
      }
      let effet = aura.get('max');
      if (effet.includes('$TOKEN')) {
        //On groupe les cibles par token qui g\xE9n\xE8re l'aura
        let targetsPerSource = {};
        _.forEach(targets, function(auraTokName, tid) {
          targetsPerSource[auraTokName] = targetsPerSource[auraTokName] || new Set();
          targetsPerSource[auraTokName].add(tid);
        });
        _.forEach(targetsPerSource, function(tset, auraTokenName) {
          var effetFinal = effet.replace(/\$TOKEN/g, auraTokenName);
          tset.forEach(function(tid) {
            effetFinal += " --target " + tid;
          });
          sendChat('player|' + gmId, effetFinal);
        });
      } else {
        //Toutes les cibles ensemble
        _.forEach(targets, function(auraTokenName, tid) {
          effet += " --target " + tid;
        });
        sendChat('player|' + gmId, effet);
      }
    });
    var armeesDesMorts = allAttributesNamed(attrs, 'armeeDesMorts');
    var degatsArmeeFull = {};
    var degatsArmeeDefense = {};
    armeesDesMorts.forEach(function(armee) {
      var charId = armee.get('characterid');
      var boost = 0;
      if (charAttribute(charId, "armeeDesMortsPuissant").length > 0) boost = 1;
      else boost = attrAsInt(charAttribute(charId, "armeeDesMortsTempeteDeManaIntense"), 0);
      var rayon = Math.floor(20 * Math.sqrt(1 + boost));
      var allies = alliesParPerso[charId] || new Set();
      //Pour chaque token representant ce perso
      allPersos.forEach(function(perso) {
        if (perso.charId != charId) return;
        //On cherche ensuite les tokens \xE0 portee
        allPersos.forEach(function(target) {
          if (target.token.id == perso.token.id) return;
          let tokRepresents = target.charId;
          if (tokRepresents == charId) return;
          if (allies.has(tokRepresents)) return;
          if (degatsArmeeDefense[target.token.id] != undefined || degatsArmeeFull[target.token.id] != undefined) return;
          if (distanceCombat(perso.token, target.token, pageId) > rayon) return;
          if (attributeAsBool(target, 'defenseArmeeDesMorts')) {
            degatsArmeeDefense[target.token.id] = target;
          } else {
            degatsArmeeFull[target.token.id] = target;
          }
        });
      });
      if (!gmId) {
        let gm = findObjs({
          _type: "player"
        }).find(function(p) {
          return playerIsGM(p.id);
        });
        if (gm) gmId = gm.id;
        else {
          error("Impossible de trouver un MJ");
          return;
        }
      }
    });
    let targetLine = "";
    Object.keys(degatsArmeeFull).forEach(function(tokId) {
      targetLine += " --target " + tokId;
    });
    if (targetLine != "")
      sendChat('player|' + gmId, "!cof-dmg 3d6" + targetLine + " --titre D\xE9g\xE2ts des morts-vivants anim\xE9s");
    targetLine = "";
    Object.keys(degatsArmeeDefense).forEach(function(tokId) {
      targetLine += " --target " + tokId;
    });
    if (targetLine != "")
      sendChat('player|' + gmId, "!cof-dmg 1d6" + targetLine + " --titre D\xE9g\xE2ts des morts-vivants anim\xE9s sur les cibles qui les combattent");
    removeAllAttributes("defenseArmeeDesMorts", evt, attrs);
    if (stateCOF.prescience) {
      //On affiche la prescience aux joueurs concern\xE9s
      allPersos.forEach(function(perso) {
        if (capaciteDisponible(perso, 'prescience', 'combat')) {
          whisperChar(perso.charId, "Possibilit\xE9 d'utiliser la " + boutonSimple('!cof-prescience ' + perso.token.id + ' --mana 2', "Prescience"));
        }
      });
      stateCOF.nextPrescience = {
        evt: evt,
        dernieresPositions: []
      };
      allTokens.forEach(function(tok) {
        stateCOF.nextPrescience.dernieresPositions.push({
          token: tok,
          left: tok.get('left'),
          top: tok.get('top')
        });
      });
    }
    if (stateCOF.tenebresMagiques && stateCOF.tenebresMagiques.attaques) {
      stateCOF.tenebresMagiques.attaques = undefined;
    }
  }

  //evt a un champ attributes et un champ deletedAttributes
  //evt n'est pas ajout\xE9 \xE0 l'historique dans cette fonction
  function nextTurnOfActive(active, attrs, evt, pageId, options) {
    if (active === undefined) return;
    if (active.id == "-1" && active.custom == "Tour") { //Nouveau tour
      let tour = parseInt(active.pr);
      if (isNaN(tour)) {
        error("Tour invalide", active);
        return;
      }
      evt.tour = tour - 1;
      evt.updateNextInitSet = updateNextInitSet;
      active.pr = tour - 1; // pr\xE9paration au calcul de l'undo
      sendChat("GM", "D\xE9but du tour " + tour);
      stateCOF.tour = tour;
      stateCOF.init = 1000;
      changementDeTour(tour, attrs, evt, pageId, options);
    } else { // change le token actif
      setActiveToken(active.id, evt);
    }
  }

  //Appel\xE9 si le turn order change, mais aussi en interne
  //si evt est d\xE9j\xE0 d\xE9fini, ne l'ajoute pas au turn order
  function nextTurn(cmp, options, evt) {
    if (!cmp.get('initiativepage')) return;
    let turnOrder = cmp.get('turnorder');
    let pageId = stateCOF.combat_pageid;
    if (pageId === undefined) {
      pageId = cmp.get('playerpageid');
      stateCOF.combat_pageid = pageId;
    }
    if (turnOrder === '') return; // nothing in the turn order
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length < 1) return; // Juste le compteur de tour
    if (stateCOF.nextPrescience) {
      stateCOF.prescience = stateCOF.nextPrescience;
      stateCOF.nextPrescience = undefined;
    }
    let active = turnOrder[0];
    // Si on a chang\xE9 d'initiative, alors diminue les effets temporaires
    let init = parseInt(active.pr);
    if (active.id == "-1" && active.custom == "Tour") {
      init = 0;
      let tour = parseInt(active.pr);
      if (isNaN(tour)) {
        error("Le tour n'est pas un nombre");
        return;
      }
      turnOrder[0] = {...active
      };
      turnOrder[0].pr = tour - 1;
    }
    let lastHead = turnOrder.pop();
    turnOrder.unshift(lastHead);
    if (evt === undefined) {
      evt = {
        type: 'nextTurn',
        attributes: [],
        deletedAttributes: [],
        turnorder: JSON.stringify(turnOrder)
      };
      addEvent(evt);
    } else {
      evt.attributes = evt.attributes || [];
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.turnorder = evt.turnorder || JSON.stringify(turnOrder);
    }
    if (stateCOF.chargeFantastique) {
      //cmp.set('turnorder', evt.turnorder);
      if (stateCOF.chargeFantastique.attaques) {
        nextTurnChargeFantastique(undefined, evt.turnorder);
        return;
      }
      stateCOF.chargeFantastique = undefined;
    }
    let attrs = findObjs({
      _type: 'attribute'
    });
    let count = 0; // pour l'aspect asynchrone des effets temporaires
    if (stateCOF.init > init) {
      if (stateCOF.tokensTemps && stateCOF.tokensTemps.length > 0) {
        stateCOF.tokensTemps = stateCOF.tokensTemps.filter(function(tt) {
          if (init < tt.init && tt.init <= stateCOF.init) {
            if (tt.duree > 1) {
              evt.tokensTemps = evt.tokensTemps || [];
              evt.tokensTemps.push({
                tt,
                ancienneDuree: tt.duree
              });
              tt.duree--;
              return true;
            } else {
              let token = getObj('graphic', tt.tid);
              if (token) {
                let ett = {...tt
                };
                ett.deletedToken = getTokenFields(token);
                evt.deletedTokensTemps = evt.deletedTokensTemps || [];
                evt.deletedTokensTemps.push(ett);
                token.remove();
              }
              return false;
            }
          } else {
            return true;
          }
        });
      }
      let attrsTemp = attrs.filter(function(obj) {
        if (!estEffetTemp(obj.get('name'))) return false;
        let obji = obj.get('max');
        return (init < obji && obji <= stateCOF.init);
      });
      evt.init = stateCOF.init;
      stateCOF.init = init;
      // Boucle sur les effets temps peut \xEAtre asynchrone \xE0 cause des DM
      count = attrsTemp.length;
      attrsTemp.forEach(function(attr) {
        let charId = attr.get('characterid');
        const effet = effetTempOfAttribute(attr);
        if (effet === undefined) {
          //erreur, on stoppe tout
          log(attr);
          count--;
          return;
        }
        let attrName = attr.get('name');
        let effetC = effetComplet(effet, attrName);
        let v = attr.get('current');
        let effetActif = true;
        if (v == 'tourFinal') { //L'effet arrive en fin de vie, doit \xEAtre supprim\xE9
          //Sauf si on a accumul\xE9 plusieurs fois l'effet
          var accumuleAttr = attributeExtending(charId, attrName, effetC, 'DureeAccumulee');
          if (accumuleAttr.length > 0) {
            accumuleAttr = accumuleAttr[0];
            let dureeAccumulee = accumuleAttr.get('current') + '';
            let listeDureeAccumulee = dureeAccumulee.split(',');
            evt.attributes.push({
              attribute: attr,
              current: 'tourFinal'
            });
            let nDuree = parseInt(listeDureeAccumulee.pop());
            if (isNaN(nDuree)) {
              v = 'tourFinal';
              count--;
              effetActif = false;
            } else v = nDuree;
            attr.set('current', nDuree);
            if (listeDureeAccumulee.length === 0) {
              evt.deletedAttributes.push(accumuleAttr);
              accumuleAttr.remove();
            } else {
              evt.attributes.push({
                attribute: accumuleAttr,
                current: dureeAccumulee
              });
              accumuleAttr.set('current', listeDureeAccumulee.join(','));
            }
          } else {
            let effetFinal = finDEffet(attr, effet, attrName, charId, evt, {
              pageId: pageId
            });
            if (effetFinal && effetFinal.oldTokenId == active.id) {
              active.id = effetFinal.newTokenId;
              if (active.id === undefined) {} else if (active.id == '-1') {
                active.custom = 'Tour';
              }
            }
            count--;
            effetActif = false;
          }
        }
        if (effetActif) { //Effet encore actif
          evt.attributes.push({
            attribute: attr,
            current: v
          });
          if (v > 1) attr.set('current', v - 1);
          else attr.set('current', 'tourFinal');
          switch (effet) { //rien apr\xE8s le switch, donc on sort par un return
            case 'putrefaction': //prend 1d6 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  nbDe: 1,
                  de: 6
                }, 'maladie',
                "pourrit", evt, {
                  magique: true
                },
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'asphyxie': //prend 1d6 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  nbDe: 1,
                  de: 6
                }, 'normal',
                "ne peut plus respirer", evt, {
                  asphyxie: true
                },
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'saignementsSang': //prend 1d6 DM
              if (charPredicateAsBool(charId, 'immuniteSaignement') || charPredicateAsBool(charId, 'controleSanguin')) {
                count--;
                if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                return;
              }
              degatsParTour(charId, pageId, effet, attrName, {
                  nbDe: 1,
                  de: 6
                }, 'normal',
                "saigne par tous les orifices du visage", evt, {
                  magique: true
                },
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'armureBrulante': //prend 1d4 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  nbDe: 1,
                  de: 4
                }, 'feu',
                "br\xFBle dans son armure", evt, {},
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'nueeDInsectes': //prend 1 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  cst: 1
                }, 'normal',
                "est piqu\xE9 par les insectes", evt, {},
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'nueeDeCriquets': //prend 1 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  cst: 2
                }, 'normal',
                "est piqu\xE9 par les criquets", evt, {},
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'nueeDeScorpions': //prend 1D6 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  nbDe: 1,
                  de: 6
                }, 'normal',
                "est piqu\xE9 par les scorpions", evt, {},
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'armeBrulante': //prend 1 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  cst: 1
                }, 'feu',
                "se br\xFBle avec son arme", evt, {},
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'regeneration': //soigne
              soigneParTour(charId, pageId, effet, attrName, 3, "r\xE9g\xE9n\xE8re", evt, {
                  valeur: 'regenerationValeur'
                },
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });

              return;
            case 'strangulation':
              let nameDureeStrang = 'dureeStrangulation';
              if (effet != attrName) { //concerne un token non li\xE9
                nameDureeStrang += attrName.substring(attrName.indexOf('_'));
              }
              let dureeStrang = findObjs({
                _type: 'attribute',
                _characterid: charId,
                name: nameDureeStrang
              });
              if (dureeStrang.length === 0) {
                let attrDuree = createObj('attribute', {
                  characterid: charId,
                  name: nameDureeStrang,
                  current: 0,
                  max: false
                });
                evt.attributes.push({
                  attribute: attrDuree,
                });
              } else {
                let strangUpdate = dureeStrang[0].get('max');
                if (strangUpdate) { //a \xE9t\xE9 mis \xE0 jour il y a au plus 1 tour
                  evt.attributes.push({
                    attribute: dureeStrang[0],
                    current: dureeStrang[0].get('current'),
                    max: strangUpdate
                  });
                  dureeStrang[0].set('max', false);
                } else { //a fait trop longtemps, on arr\xEAte tout
                  sendChar(charId, messageEffetTemp[effet].fin, true);
                  attr.set('current', v);
                  evt.attributes.pop(); //On enl\xE8ve des attributs modifi\xE9s pour mettre dans les attribute supprim\xE9s.
                  evt.deletedAttributes.push(attr);
                  attr.remove();
                  evt.deletedAttributes.push(dureeStrang[0]);
                  dureeStrang[0].remove();
                }
              }
              count--;
              return;
            case 'dotGen':
              degatsParTour(charId, pageId, effetC, attrName, {}, '', "", evt, {
                  dotGen: true
                },
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            default:
              count--;
              return;
          }
        }
      }); //fin de la boucle sur tous les attributs d'effets temporaires
    }
    if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
  }

  //Fonction appel\xE9e par !cof-tour-suivant
  function tourSuivant(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "Vous n'\xEAtes pas en combat");
      return;
    }
    let cmp = Campaign();
    let turnOrder = cmp.get('turnorder');
    if (turnOrder === '') {
      error("Personne n'est en combat", turnOrder);
      return;
    }
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length < 1) {
      error("Personne n'est en combat", turnOrder);
      return;
    }
    let active = turnOrder.shift();
    let persoActif = persoOfId(active.id);
    if (persoActif === undefined) {
      error("Impossible de trouver le personnage actif", active);
      return;
    }
    if (!peutController(msg, persoActif)) {
      sendPlayer(msg, "Ce n'est pas votre tour (personnage actif : " + persoActif.token.get('name') + ")");
      return;
    }
    turnOrder.push(active);
    if (turnOrder[0].id == "-1" && turnOrder[0].custom == "Tour") {
      //Il faut aussi augmenter la valeur du tour
      let tour = parseInt(turnOrder[0].pr);
      if (isNaN(tour)) {
        error("Tour invalide", turnOrder);
        return;
      }
      turnOrder[0].pr = tour + 1;
    }
    cmp.set('turnorder', JSON.stringify(turnOrder));
    nextTurn(cmp);
  }

  //nb \xE0 11 pour ne pas retenter de lire les attributs
  function scriptVersionToCharacter(character, nb) {
    var charId = character.id;
    //On v\xE9rifie que les attributs sont peupl\xE9s
    var attrs = findObjs({
      _type: 'attribute',
      _characterid: charId,
    });
    if (attrs.length === 0) {
      nb = nb || 1;
      if (nb > 10) {
        error("Impossible de trouver d'attribut", character);
        return;
      }
      _.delay(function() {
        scriptVersionToCharacter(character, nb + 1);
      }, 2000);
      return;
    }
    attrs = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: 'scriptVersion',
    }, {
      caseInsensitive: true
    });
    if (attrs.length === 0) {
      createObj('attribute', {
        characterid: charId,
        name: 'scriptVersion',
        current: true,
        max: state.COFantasy.version
      });
    } else {
      attrs[0].setWithWorker({
        current: true,
        max: state.COFantasy.version
      });
    }
  }

  function destroyToken(token) { //to remove unused local attributes
    var charId = token.get('represents');
    if (charId === "") return;
    var perso = {
      charId: charId,
      token: token
    };
    nePlusSuivre(perso, token.get('pageid'));
    var deplacementsSynchronises = tokenAttribute(perso, 'tokensSynchronises');
    var keepToken;
    deplacementsSynchronises.forEach(function(attr) {
      var listTokens = attr.get('current').split(',');
      listTokens = listTokens.filter(function(tid) {
        return tid != token.id;
      });
      if (listTokens.length < 2) attr.remove();
      else keepToken = true;
    });
    if (keepToken || token.get('bar1_link') !== "") return;
    var endName = "_" + token.get('name');
    var tokAttr = findObjs({
      _type: 'attribute',
      _characterid: charId
    });
    tokAttr = tokAttr.filter(function(obj) {
      return obj.get('name').endsWith(endName);
    });
    if (tokAttr.length > 0) {
      log("Removing token local attributes");
      log(tokAttr);
      tokAttr.forEach(function(attr) {
        attr.remove();
      });
    }
  }

  function nePeutPasBouger(perso) {
    if (attributeAsBool(perso, 'peutEtreDeplace')) return false;
    var players = getPlayerIds(perso);
    if (!players || players.every(playerIsGM)) return false;
    if (isActive(perso)) {
      if (getState(perso, 'immobilise')) return true;
      if (attributeAsBool(perso, 'bloqueManoeuvre')) return true;
      if (attributeAsBool(perso, 'enveloppePar')) return true;
      if (attributeAsBool(perso, 'prisonVegetale')) return true;
      if (attributeAsBool(perso, 'toiles')) return true;
      if (attributeAsBool(perso, 'estGobePar')) return true;
      if (attributeAsBool(perso, 'agrippeParUnDemon')) return true;
      if (attributeAsBool(perso, 'etreinteScorpionPar')) return true;
      return false;
    }
    return true;
  }

  function permettreDeplacement(msg) {
    getSelected(msg, function(selected, playerId) {
      let evt = {
        type: 'Permettre le d\xE9placement pour un tour'
      };
      iterSelected(selected, function(perso) {
        setTokenAttr(perso, 'peutEtreDeplace', true, evt);
      });
      addEvent(evt);
    });
  }

  function determinant(xa, ya, xb, yb) {
    return xa * yb - ya * xb;
  }

  //Calcule si le segment [a,b] intersecte le segment [c,d]
  function segmentIntersecte(a, b, c, d) {
    var d1 = determinant(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);
    var d2 = determinant(b.x - a.x, b.y - a.y, d.x - a.x, d.y - a.y);
    if (d1 > 0 && d2 > 0) return false;
    if (d1 < 0 && d2 < 0) return false;
    d1 = determinant(d.x - c.x, d.y - c.y, a.x - c.x, a.y - c.y);
    d2 = determinant(d.x - c.x, d.y - c.y, b.x - c.x, b.y - c.y);
    if (d1 > 0 && d2 > 0) return false;
    if (d1 < 0 && d2 < 0) return false;
    return true;
  }

  //traduction des coordon\xE9es de path en coordon\xE9es r\xE9elles sur la carte
  function translatePathCoordinates(x, y, p) {
    //D'abord on calcule les coordonn\xE9es relatives au centre
    x -= p.width / 2;
    y -= p.height / 2;
    //Puis on applique le scale
    x *= p.scaleX;
    y *= p.scaleY;
    //Puis on fait la rotation
    var c = Math.cos(p.angle);
    var s = Math.sin(p.angle);
    x = c * x + s * y;
    y = c * y - s * x;
    //Et finalement on ajoute les coordonn\xE9es du centre
    x += p.left;
    y += p.top;
    return {
      x: x,
      y: y
    };
  }

  //v\xE9rifie si de la nouvelle position on peut voir le suivi
  function obstaclePresent(nsx, nsy, pt, murs) {
    if (nsx == pt.x && nsy == pt.y) return false;
    var ps = {
      x: nsx,
      y: nsy
    };
    var obstacle = murs && murs.find(function(path) {
      if (path.length === 0) return false;
      var pc = path[0];
      return path.find(function(v, i) {
        if (i === 0) return false;
        if (segmentIntersecte(ps, pt, pc, v)) return true;
        pc = v;
        return false;
      });
    });
    return obstacle;
  }

  //R\xE9agit au d\xE9placement manuel d'un token.
  // suivis est l'ensemble des tokens qui a d\xE9j\xE0 \xE9t\xE9 boug\xE9 suite \xE0 ce d\xE9placement
  function moveToken(token, prev, synchronisation, suivis) {
    var charId = token.get('represents');
    if (charId === '') return;
    var perso = {
      token: token,
      charId: charId
    };
    var pageId = token.get('pageid');
    var x = token.get('left');
    var y = token.get('top');
    var deplacement = prev && (prev.left != x || prev.top != y);
    if (!deplacement) return;
    if (!synchronisation) {
      var deplacementsSynchronises = tokenAttribute(perso, 'tokensSynchronises');
      deplacementsSynchronises.forEach(function(attr) {
        var listTokens = attr.get('current');
        listTokens.split(',').forEach(function(tid) {
          if (tid == token.id) return;
          var tok = getObj('graphic', tid);
          if (tok === undefined) {
            error("Impossible de trouver le token d'id " + tid + " synchronis\xE9 avec " + token.get('name'), attr);
            return;
          }
          tok.set('left', x);
          tok.set('top', y);
          moveToken(tok, prev, true);
        });
      });
    }
    if (nePeutPasBouger(perso)) {
      whisperChar(charId, "ne peut pas se d\xE9placer.");
      sendChat('COF', "/w GM " +
        '<a href="!cof-deplacer-token ' + x + ' ' + y + ' --target ' + token.id + '">D\xE9placer </a>' +
        '<a href="!cof-permettre-deplacement --target ' + token.id + '">D\xE9coincer</a>');
      token.set('left', prev.left);
      token.set('top', prev.top);
      return;
    }
    suivis = suivis || new Set();
    //On regarde d'abord si perso est sur une monture
    let attrMonteSur = tokenAttribute(perso, 'monteSur');
    if (attrMonteSur.length > 0) {
      let monture = persoOfId(attrMonteSur[0].get('current'), attrMonteSur[0].get('max'), pageId);
      if (monture === undefined) {
        sendPerso(perso, "descend de sa monture");
        attrMonteSur[0].remove();
      } else {
        if (monture.token.get('pageid') != pageId) {
          sendPerso(perso, "descend de " + monture.token.get('name'));
          removeTokenAttr(monture, 'estMontePar');
          removeTokenAttr(monture, 'positionSurMonture');
          attrMonteSur[0].remove();
        } else if (!suivis.has(monture.token.id)) {
          let position = tokenAttribute(monture, 'positionSurMonture');
          if (position.length > 0) {
            let dx = parseInt(position[0].get('current'));
            let dy = parseInt(position[0].get('max'));
            if (!(isNaN(dx) || isNaN(dy))) {
              let sprev = {
                left: monture.token.get('left'),
                top: monture.token.get('top'),
              };
              monture.token.set('left', x - dx);
              monture.token.set('top', y - dy);
              monture.token.set('rotation', token.get('rotation') - attributeAsInt(monture, 'directionSurMonture', 0));
              suivis.add(token.id);
              moveToken(monture.token, sprev, synchronisation, suivis);
            }
          }
        }
        if (stateCOF.combat) {
          var evt = {
            type: "initiative"
          };
          updateInit(monture.token, evt);
          // R\xE9adapter l'init_dynamique au token du perso
          if (stateCOF.options.affichage.val.init_dynamique.val) {
            setTokenInitAura(perso);
          }
        }
      }
    }
    //Si il est invisible, on bouge aussi l'autre token
    var attrInvisible = tokenAttribute(perso, 'tokenInvisible');
    if (attrInvisible.length > 0) {
      attrInvisible = attrInvisible[0];
      var tidInv1 = attrInvisible.get('current'); //Originel, normalement sur le gmlayer
      var tidInv2 = attrInvisible.get('max');
      var autreInvisible;
      if (token.id == tidInv1) {
        autreInvisible = getObj('graphic', tidInv2);
        if (!autreInvisible) {
          autreInvisible =
            findObjs({
              _type: 'graphic',
              _subtype: 'token',
              _pageid: token.get('pageid'),
              layer: 'objects',
              represents: perso.charId,
              name: token.get('name')
            });
          if (autreInvisible.length > 0) autreInvisible = autreInvisible[0];
          else autreInvisible = undefined;
        }
      } else if (token.id == tidInv2) {
        autreInvisible = getObj('graphic', tidInv1);
        if (!autreInvisible) {
          autreInvisible =
            findObjs({
              _type: 'graphic',
              _subtype: 'token',
              _pageid: token.get('pageid'),
              layer: 'gmlayer',
              represents: perso.charId,
              name: token.get('name')
            });
          if (autreInvisible.length > 0) autreInvisible = autreInvisible[0];
          else autreInvisible = undefined;
        }
      }
      if (!autreInvisible) {
        switch (token.get('layer')) {
          case 'objects':
            autreInvisible =
              findObjs({
                _type: 'graphic',
                _subtype: 'token',
                _pageid: token.get('pageid'),
                layer: 'gmlayer',
                represents: perso.charId,
                name: token.get('name')
              });
            if (autreInvisible.length > 0) autreInvisible = autreInvisible[0];
            else autreInvisible = undefined;
            break;
          case 'gmlayer':
            autreInvisible =
              findObjs({
                _type: 'graphic',
                _subtype: 'token',
                _pageid: token.get('pageid'),
                layer: 'objects',
                represents: perso.charId,
                name: token.get('name')
              });
            if (autreInvisible.length > 0) autreInvisible = autreInvisible[0];
            else autreInvisible = undefined;
            break;
          default:
            error("Impossible de trouver la couche du token " + token.get('name'), token);
        }
      }
      if (autreInvisible) {
        autreInvisible.set('left', x);
        autreInvisible.set('top', y);
      }
    }
    //si non, perso est peut-\xEAtre une monture
    let attrMontePar = tokenAttribute(perso, 'estMontePar');
    attrMontePar.forEach(function(a) {
      let cavalier = persoOfId(a.get('current'), a.get('max'), pageId);
      if (cavalier === undefined) {
        a.remove();
        return;
      }
      if (!suivis.has(cavalier.token.id)) {
        let position = tokenAttribute(perso, 'positionSurMonture');
        if (position.length > 0) {
          let dx = parseInt(position[0].get('current'));
          let dy = parseInt(position[0].get('max'));
          if (!(isNaN(dx) || isNaN(dy))) {
            x += dx;
            y += dy;
          }
        }
        cavalier.token.set('left', x);
        cavalier.token.set('top', y);
        cavalier.token.set('rotation', token.get('rotation') + attributeAsInt(perso, 'directionSurMonture', 0));
      }
    });
    //Si le token suivait quelqu'un, ce n'est plus le cas
    if (prev.suit === undefined) nePlusSuivre(perso, pageId);
    //On bouge tous les tokens qui suivent le personnage
    //sauf si on a d\xE9j\xE0 \xE9t\xE9 boug\xE9.
    if (!suivis.has(token.id)) {
      suivis.add(token.id);
      var attrSuivi = tokenAttribute(perso, 'estSuiviPar');
      var page = getObj('page', pageId);
      if (page === undefined) {
        error("Impossible de trouver la page du token", perso);
        return;
      }
      if (attrSuivi.length > 0) {
        var width = page.get('width') * PIX_PER_UNIT;
        var height = page.get('height') * PIX_PER_UNIT;
        var pt = {
          x: x,
          y: y
        };
        let murs = getWalls(page, pageId, prev.murs);
        let distance =
          Math.sqrt((x - prev.left) * (x - prev.left) + (y - prev.top) * (y - prev.top));
        attrSuivi.forEach(function(as) {
          let suivants = as.get('current').split(':::');
          let removedSuivant;
          suivants = suivants.filter(function(idn) {
            let suivant = persoOfIdName(idn, pageId);
            if (suivant === undefined) {
              removedSuivant = true;
              return false;
            }
            var sw = suivant.token.get('width');
            var sh = suivant.token.get('height');
            if (sw > width) return false;
            if (sh > width) return false;
            var sx = suivant.token.get('left');
            var sy = suivant.token.get('top');
            //On essaie de garder la m\xEAme position par rapport au token, en supposant qu'on \xE9tait derri\xE8re lui
            var attrSuit = tokenAttribute(suivant, 'suit');
            var dp;
            if (attrSuit.length > 0) {
              dp = parseInt(attrSuit[0].get('max'));
            }
            if (dp === undefined || isNaN(dp) || dp < 1) {
              dp = Math.sqrt((prev.left - sx) * (prev.left - sx) + (prev.top - sy) * (prev.top - sy));
            }
            var nsx = x + (prev.left - x) * dp / distance;
            var nsy = y + (prev.top - y) * dp / distance;
            if (nsx < 0) nsx = 0;
            if (nsy < 0) nsy = 0;
            if (nsx + sw / 2 > width) nsx = Math.floor(width - sw / 2);
            if (nsy + sh / 2 > height) nsy = Math.floor(height - sh / 2);
            //v\xE9rifie si de la nouvelle position on peut voir le suivi
            if (obstaclePresent(nsx, nsy, pt, murs)) {
              //On essaie de suivre le chemin du token, \xE0 la place
              //D'abord se d\xE9placer vers l'ancienne position de perso, au maximum de distance pixels
              var distLoc = distance;
              if (distLoc - dp < 5) {
                nsx = prev.left;
                nsy = prev.top;
              } else {
                if (dp > distLoc) {
                  nsx = sx + (prev.left - sx) * distLoc / dp;
                  nsy = sy + (prev.top - sy) * distLoc / dp;
                  if (obstaclePresent(nsx, nsy, pt, murs)) {
                    sendPerso(suivant, "ne peut plus suivre " + perso.token.get('name') + " car " + onGenre(suivant, 'il', 'elle') + " ne " + onGenre(perso, 'le', 'la') + " voit plus");
                    removeTokenAttr(suivant, 'suit');
                    removedSuivant = true;
                    return false;
                  }
                } else {
                  //On part de l'ancienne position, et on peut encore avancer
                  distLoc -= dp;
                  nsx = prev.left + (x - prev.left) * distLoc / distance;
                  nsy = prev.top + (y - prev.top) * distLoc / distance;
                  if (obstaclePresent(nsx, nsy, pt, murs)) {
                    nsx = prev.left;
                    nsy = prev.top;
                  }
                }
              }
            }
            suivant.token.set('left', nsx);
            suivant.token.set('top', nsy);
            let sprev = {
              left: sx,
              top: sy,
              suit: true,
              murs: murs
            };
            moveToken(suivant.token, sprev, synchronisation, suivis); //pour faire suivre ceux qui le suivent
            return true;
          });
          if (removedSuivant) {
            if (suivants.length === 0) {
              as.remove();
            } else {
              as.set('current', suivants.join(':::'));
            }
          }
        });
      }
    }
    // Update position du token d'initiative dynamique
    if (stateCOF.options.affichage.val.init_dynamique.val && roundMarker) {
      if ((!stateCOF.chargeFantastique && stateCOF.activeTokenId == token.id) ||
        (stateCOF.chargeFantastique && stateCOF.chargeFantastique.activeTokenId == token.id)) {
        roundMarker.set('left', x);
        roundMarker.set('top', y);
      } else {
        // Cas sp\xE9ciaux du cavaliers : au tour du cavalier, l'init_dynamique suit la monture
        let estMontePar = tokenAttribute(perso, "estMontePar");
        if (estMontePar.length > 0 && stateCOF.activeTokenId == estMontePar[0].get("current")) {
          let cavalierId = estMontePar[0].get("current");
          let cavalier = persoOfId(cavalierId);
          roundMarker.set('left', cavalier.token.get('left'));
          roundMarker.set('top', cavalier.token.get('top'));
        }
      }
    }
    //On d\xE9place les tokens de lumi\xE8re, si il y en a
    let attrLumiere = tokenAttribute(perso, 'lumiere');
    attrLumiere.forEach(function(al) {
      let lumId = al.get('max');
      if (lumId == 'surToken') return;
      let lumiereExiste;
      let lumiere = getObj('graphic', lumId);
      if (lumiere && lumiere.get('pageid') != pageId) {
        lumiere = undefined;
        lumiereExiste = true;
      }
      if (lumiere === undefined) {
        let tokensLumiere = findObjs({
          _type: 'graphic',
          _pageid: pageId,
          layer: 'walls',
          name: al.get('current')
        });
        if (tokensLumiere.length === 0) {
          if (lumiereExiste) return;
          log("Pas de token pour la lumi\xE8re " + al.get('current'));
          al.remove();
          return;
        }
        lumiere = tokensLumiere.shift();
        if (tokensLumiere.length > 0) {
          //On cherche le token le plus proche de la position pr\xE9c\xE9dente
          var d =
            VecMath.length(
              VecMath.vec([lumiere.get('left'), lumiere.get('top')], [prev.left, prev.top]));
          tokensLumiere.forEach(function(tl) {
            var d2 =
              VecMath.length(
                VecMath.vec([tl.get('left'), tl.get('top')], [prev.left, prev.top]));
            if (d2 < d) {
              d = d2;
              lumiere = tl;
            }
          });
        }
      }
      if (lumiere === undefined) {
        if (lumiereExiste) return;
        log("Pas de token pour la lumi\xE8re " + al.get('current'));
        al.remove();
        return;
      }
      lumiere.set('left', x);
      lumiere.set('top', y);
    });
    var attrEnveloppe = tokenAttribute(perso, 'enveloppe');
    attrEnveloppe = attrEnveloppe.concat(tokenAttribute(perso, 'aGobe'));
    attrEnveloppe.forEach(function(a) {
      var cible = persoOfIdName(a.get('current'), pageId);
      if (cible === undefined) {
        a.remove();
        return;
      }
      cible.token.set('left', x);
      cible.token.set('top', y);
    });
  }

  function deplacerToken(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il manque un argument \xE0 !cof-deplacer-token", cmd);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Il faut s\xE9lectionner un token", cmd);
        return;
      }
      if (selected.length > 1) {
        error("D\xE9placement de plusieurs tokens au m\xEAme endroit", selected);
        return;
      }
      iterSelected(selected, function(perso) {
        perso.token.set('left', cmd[1]);
        perso.token.set('top', cmd[2]);
        moveToken(perso.token);
      });
    });
  }

  function synchronisationDesEtats(perso) {
    for (let etat in cof_states) {
      // R\xE9cup\xE8re la valeur de l'\xE9tat sur la fiche
      let valEtat;
      if (etat == 'affaibli') { // Cas particulier affaibli sur la fiche perso
        valEtat = (ficheAttributeAsInt(perso, 'affaibli', 20) == 12);
      } else { // Autre cas
        valEtat = ficheAttributeAsBool(perso, etat, false);
      }
      let field = cof_states[etat];
      if (perso.token.get(field) != valEtat) perso.token.set(field, valEtat);
    }
  }

  //Op\xE9rations diverses au moment o\xF9 on pose un token.
  //Si le token repr\xE9sente un personnage et avec la barre de vie non li\xE9e,
  // assure un nom unique en ajoutant un num\xE9ro
  // On en profite aussi pour mettre certaines valeurs par d\xE9faut
  // retourne un perso si c'est un token de personnage
  function renameToken(token, tokenName) {
    let charId = token.get('represents');
    if (charId === undefined || charId === '') return;
    let perso = {
      token: token,
      charId: charId
    };
    const pageId = token.get('pageid');
    //Vision
    let visionNoir = predicateAsInt(perso, 'visionDansLeNoir', 0);
    if (visionNoir > 0) {
      visionNoir = scaleDistance(perso, visionNoir);
      let page = getObj('page', pageId);
      let udl = page && page.get('dynamic_lighting_enabled');
      if (udl) {
        token.set('has_night_vision', true);
        //token.set('night_vision_tint', '#555555');
        token.set('night_vision_distance', visionNoir);
      } else {
        token.set('light_radius', visionNoir);
        token.set('light_dimradius', -1);
        token.set('light_otherplayers', false);
        token.set('light_hassight', true);
        token.set('light_angle', 360);
      }
    }
    if (token.get('bar1_link') !== '') {
      //Cas des tokens non mooks
      let attrMonteSur = tokenAttribute(perso, 'monteSur');
      if (attrMonteSur.length > 0) {
        let monture = persoOfId(attrMonteSur[0].get('current'), attrMonteSur[0].get('max'), pageId);
        if (monture === undefined) {
          sendPerso(perso, "descend de sa monture");
          attrMonteSur[0].remove();
        } else {
          if (monture.token.get('pageid') != pageId) {
            sendPerso(perso, "descend de " + monture.token.get('name'));
            removeTokenAttr(monture, 'estMontePar');
            removeTokenAttr(monture, 'positionSurMonture');
            attrMonteSur[0].remove();
          }
        }
        synchronisationDesEtats(perso);
      }
      return perso;
    }
    //cas des mooks : num\xE9rotation
    var copyOf = 0;
    var tokenBaseName = tokenName;
    if (tokenBaseName.includes('%%NUMBERED%%')) {
      if (typeof TokenNameNumber !== 'undefined') return perso; //On laisse tokenNameNumber g\xE9rer \xE7a
      tokenBaseName = tokenBaseName.replace('%%NUMBERED%%', '');
    } else {
      // On regarde si le nom se termine par un entier
      var lastSpace = tokenBaseName.lastIndexOf(' ');
      if (lastSpace > 0) {
        copyOf = +tokenBaseName.substring(lastSpace + 1);
        if (isNaN(copyOf)) copyOf = 0;
        else tokenBaseName = tokenBaseName.substring(0, lastSpace);
      }
    }
    var otherTokens = findObjs({
      _type: 'graphic',
      //_pageid: token.get('pageid'),
      represents: charId
    });
    otherTokens = otherTokens.filter(function(tok) {
      var pid = tok.get('pageid');
      var page = getObj('page', pid);
      if (page) {
        return !(page.get('archived'));
      }
      return false;
    });
    var numero = 1;
    var nePasModifier = false;
    if (typeof TokenNameNumber !== 'undefined' && tokenBaseName.length > 0) {
      if (!isNaN(tokenBaseName[tokenBaseName.length - 1]))
        nePasModifier = true;
    }
    otherTokens.forEach(function(ot) {
      if (ot.id == token.id) return;
      var name = ot.get('name');
      if (nePasModifier && name == tokenBaseName) nePasModifier = false;
      if (name.startsWith(tokenBaseName)) {
        var suffixe = name.replace(tokenBaseName + ' ', '');
        if (isNaN(suffixe)) return;
        var n = parseInt(suffixe);
        if (n == copyOf) {
          if (ot.get('pageid') == pageId) copyOf = 0;
        }
        if (n >= numero) numero = n + 1;
      }
    });
    if (nePasModifier || copyOf > 0) return perso;
    token.set('name', tokenBaseName + ' ' + numero);
    return perso;
  }

  function initTokenMarkers(token) {
    let charId = token.get('represents');
    if (charId === undefined || charId === '') return; // Si token li\xE9 \xE0 un perso
    if (token.get('bar1_link') === '') return; // Si unique
    let perso = {
      token: token,
      charId: charId
    };
    synchronisationDesEtats(perso);
  }


  function addToken(token, nb) {
    let tokenName = token.get('name');
    //La plupart du temps, il faut attendre un peu que le nom soit affect\xE9
    if (tokenName !== '') {
      let perso = renameToken(token, tokenName);
      if (perso === undefined) return;
      const arme = predicateAsBool(perso, 'armeParDefaut');
      if (arme !== undefined && arme !== true) {
        degainerArme(perso, arme, {}, {
          secret: true
        });
      }
      return;
    }
    nb = nb || 1;
    if (nb > 10) return; //Tant pis, peut-\xEAtre que le nom est vide
    _.delay(function() {
      addToken(token, nb + 1);
    }, 50);
  }

  // Surveillance sur le changement d'\xE9tat du token
  function changeMarker(token, prev) {
    var charId = token.get('represents');
    if (charId === undefined || charId === '') return; // Uniquement si token li\xE9 \xE0 un perso
    var perso = {
      token: token,
      charId: charId
    };
    var evt = {
      type: "set_state",
    };
    affectToken(token, 'statusmarkers', prev.statusmarkers, evt);
    var currentMarkers = [];
    var markers = token.get("statusmarkers");
    if (markers !== '') {
      currentMarkers = markers.split(',');
    }
    var previousMarkers = [];
    if (prev.statusmarkers !== '') {
      previousMarkers = prev.statusmarkers.split(',');
    }
    // Pour tous les markers disparus
    previousMarkers.forEach(function(marker) {
      if (currentMarkers.includes(marker)) return;
      var etat = etat_de_marker[marker];
      if (etat) {
        setState(perso, etat, false, evt);
      } else {
        var effet = effet_de_marker[marker];
        if (effet) {
          var attr = tokenAttribute(perso, effet);
          if (attr.length === 0) return;
          finDEffet(attr[0], effetTempOfAttribute(attr[0]), attr[0].get('name'), perso.charId, evt);
        }
      }
    });
    // Ensuite les markers apparus
    currentMarkers.forEach(function(marker) {
      if (previousMarkers.includes(marker)) return;
      var etat = etat_de_marker[marker];
      if (etat) {
        var succes = setState(perso, etat, true, evt);
        if (!succes) token.set('status_' + marker, false);
      }
    });
    addEvent(evt);
  }

  function initAllMarkers(campaign) {
    var currentMap = getObj('page', campaign.get('playerpageid'));
    var tokens = findObjs({
      _pageid: currentMap.id,
      _type: 'graphic',
      _subtype: 'token'
    });
    tokens.forEach(initTokenMarkers);
  }

  return {
    apiCommand: apiCommand,
    nextTurn: nextTurn,
    destroyToken: destroyToken,
    moveToken: moveToken,
    changeHandout: changeHandout,
    addToken: addToken,
    changeMarker: changeMarker,
    initAllMarkers: initAllMarkers,
    setStateCOF: setStateCOF,
    scriptVersionToCharacter: scriptVersionToCharacter,
  };

}();

on('ready', function() {
  const scriptVersion = '3.05';
  on('add:token', COFantasy.addToken);
  on("change:campaign:playerpageid", COFantasy.initAllMarkers);
  state.COFantasy = state.COFantasy || {
    combat: false,
    tour: 0,
    init: 1000,
    eventId: 0,
    version: scriptVersion,
  };
  COFantasy.setStateCOF();
  if (state.COFantasy.version === undefined) {
    state.COFantasy.eventId = 0;
  }
  const handout = findObjs({
    _type: 'handout'
  });
  const characters = findObjs({
    _type: 'character',
  });
  if (state.COFantasy.version < 1.0) {
    log("Mise \xE0 jour des attributs et macros vers la version 1.0");
    //Mise \xE0 jour des effets temporaires avec _
    let strReg = "(rayon_affaiblissant|peau_d_ecorce|chant_des_heros|image_decalee|a_couvert|sous_tension|forgeron_|armeEnflammee)";
    let regName = new RegExp("^" + strReg);
    let regText = new RegExp(strReg);
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      let attrName = attr.get('name');
      if (regName.test(attrName)) {
        attrName = attrName.replace(/rayon_affaiblissant/, 'rayonAffaiblissant');
        attrName = attrName.replace(/peau_d_ecorce/, 'peauDEcorce');
        attrName = attrName.replace(/chant_des_heros/, 'chantDesHeros');
        attrName = attrName.replace(/image_decalee/, 'imageDecalee');
        attrName = attrName.replace(/a_couvert/, 'aCouvert');
        attrName = attrName.replace(/sous_tension/, 'sousTension');
        attrName = attrName.replace(/forgeron_([^_\s)]*)/, 'forgeron($1)');
        attrName = attrName.replace(/armeEnflammee([^_\s)]*)/, 'armeEnflammee($1)');
        attr.set('name', attrName);
      }
      //Pour les consommables, il faut aussi changer le champ max;
      let attrMax = attr.get('max');
      if (regText.test(attrMax)) {
        attrMax = attrMax.replace(/rayon_affaiblissant/g, 'rayonAffaiblissant');
        attrMax = attrMax.replace(/peau_d_ecorce/g, 'peauDEcorce');
        attrMax = attrMax.replace(/chant_des_heros/g, 'chantDesHeros');
        attrMax = attrMax.replace(/image_decalee/g, 'imageDecalee');
        attrMax = attrMax.replace(/a_couvert/g, 'aCouvert');
        attrMax = attrMax.replace(/sous_tension/g, 'sousTension');
        attrMax = attrMax.replace(/forgeron_([^_\s)]*)/g, 'forgeron($1)');
        attrMax = attrMax.replace(/armeEnflammee([^_\s)]*)/g, 'armeEnflammee($1)');
        attr.set('max', attrMax);
      }
    });
    let macros = findObjs({
      _type: 'macro'
    }).concat(findObjs({
      _type: 'ability'
    }));
    macros.forEach(function(m) {
      let action = m.get('action');
      if (regText.test(action)) {
        action = action.replace(/rayon_affaiblissant/g, 'rayonAffaiblissant');
        action = action.replace(/peau_d_ecorce/g, 'peauDEcorce');
        action = action.replace(/chant_des_heros/g, 'chantDesHeros');
        action = action.replace(/image_decalee/g, 'imageDecalee');
        action = action.replace(/a_couvert/g, 'aCouvert');
        action = action.replace(/sous_tension/g, 'sousTension');
        action = action.replace(/forgeron_([^_\s)]*)/g, 'forgeron($1)');
        action = action.replace(/armeEnflammee([^_\s)]*)/g, 'armeEnflammee($1)');
        m.set('action', action);
      }
    });
    log("Mise \xE0 jour effectu\xE9e.");
  }
  if (state.COFantasy.version < 2.0) {
    log("Mise \xE0 jour des attributs et macros vers la version 2.0");
    let strReg = "(--argent)";
    let regName = new RegExp("^" + strReg);
    let regText = new RegExp(strReg);
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      let attrName = attr.get('name');
      if (regName.test(attrName)) {
        attrName = attrName.replace(/--argent/, '--armeDArgent');
        attr.set('name', attrName);
      }
      //Pour les consommables, il faut aussi changer le champ max;
      let attrMax = attr.get('max');
      if (regText.test(attrMax)) {
        attrMax = attrMax.replace(/--argent/g, '--armeDArgent');
        attr.set('max', attrMax);
      }
    });
    let macros = findObjs({
      _type: 'macro'
    }).concat(findObjs({
      _type: 'ability'
    }));
    macros.forEach(function(m) {
      let action = m.get('action');
      if (regText.test(action)) {
        action = action.replace(/--argent/g, '--armeDArgent');
        m.set('action', action);
      }
    });
    log("Mise \xE0 jour effectu\xE9e.");
  }
  if (state.COFantasy.version < 2.02) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      let attrName = attr.get('name');
      if (attrName == 'mort-vivant') attr.set('name', 'mortVivant');
    });
    log("Mise \xE0 jour effectu\xE9e.");
  }
  if (state.COFantasy.version < 2.03) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      let attrName = attr.get('name');
      if (attrName == 'runeDEnergie') attr.set('name', 'runeForgesort_\xE9nergie');
      if (attrName == 'runeDeProtection') attr.set('name', 'runeForgesort_protection');
      if (attrName.includes('runeDePuissance')) {
        attr.set('name', 'runeForgesort_puissance(' + attrName.substring(attrName.indexOf("(") + 1, attrName.indexOf(")")) + ')');
      }
    });
    log("Mise \xE0 jour des runes effectu\xE9e.");
  }
  if (state.COFantasy.version < 2.04) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      let attrName = a.get('name');
      if (!attrName.startsWith('RD_')) return;
      if (attrName == 'RD_critique') return;
      let rds = parseInt(a.get('current'));
      if (isNaN(rds) || rds < 1) {
        a.remove();
        return;
      }
      let cid = a.get('characterid');
      let attrRD = 'RDS';
      let attrRDS = findObjs({
        _type: 'attribute',
        _characterid: cid,
        name: attrRD
      }, {
        caseInsensitive: true
      });
      if (attrRDS.length === 0) {
        attrRDS = createObj('attribute', {
          characterid: cid,
          name: attrRD,
          current: '',
          max: ''
        });
      } else attrRDS = attrRDS[0];
      let rdPerso = attrRDS.get('current');
      attrName = attrName.substring(3);
      if (attrName.startsWith('sauf_')) {
        attrName = attrName.substr(5);
        if (rdPerso.trim() === '') rdPerso = rds + '/' + attrName;
        else rdPerso += ', ' + rds + '/' + attrName;
        attrRDS.set('current', rdPerso);
        a.remove();
        return;
      }
      if (attrName == 'rdt' || attrName == 'sauf') return;
      if (rdPerso.trim() === '') rdPerso = attrName + ':' + rds;
      else rdPerso += ', ' + attrName + ':' + rds;
      attrRDS.set('current', rdPerso);
      a.remove();
    });
    log("Mise \xE0 jour de la RD effectu\xE9e");
  }
  if (state.COFantasy.version < 2.05) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      let attrName = a.get('name');
      if (!attrName.startsWith('dose_') && !attrName.startsWith('consommable_')) return;
      let action = a.get('max');
      if (!action.startsWith('!cof-lancer-sort')) return;
      let mana = action.charAt(17);
      let message = action.substring(19);
      a.set("max", "!cof-lancer-sort --message " + message + " --mana " + mana);
    });
    log("Mise \xE0 jour des consommables !cof-lancer-sort effectu\xE9e");
    let macros = findObjs({
      _type: 'macro'
    }).concat(findObjs({
      _type: 'ability'
    }));
    macros.forEach(function(m) {
      let macro = m.get("action");
      if (!macro.startsWith('!cof-lancer-sort')) return;
      let mana = macro.charAt(17);
      let message = macro.substring(19);
      m.set("action", "!cof-lancer-sort --message " + message + " --mana " + mana);
    });
    log("Mise \xE0 jour des ability & macros !cof-lancer-sort effectu\xE9e");
  }
  if (state.COFantasy.version < 2.10) {
    let tokens = findObjs({
      _type: 'graphic',
      _subtype: 'token'
    });
    tokens.forEach(function(token) {
      let charId = token.get('represents');
      if (charId === '') return;
      let bar1_link = token.get('bar1_link');
      if (bar1_link === '') return;
      let attrLie = getObj('attribute', bar1_link);
      if (attrLie === undefined) return;
      if (attrLie.get('name') != 'pnj_pv') return;
      let attrPV = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'PV'
      }, {
        caseInsensitive: true
      });
      if (attrPV.length === 0) return;
      token.set('bar1_link', attrPV[0].id);
    });
    let charsToTreat = characters.length;
    let removeAttrs = function() {
      charsToTreat--;
      if (charsToTreat > 0) return;
      log("Supression des attributs obsol\xE8tes");
      let attrs = findObjs({
        _type: 'attribute',
      });
      attrs.forEach(function(a) {
        switch (a.get('name')) {
          case 'PR1':
          case 'PR2':
          case 'PR3':
          case 'PR4':
          case 'PR5':
          case 'pnj_pv':
          case 'pnj_dmtemp':
          case 'pnj_rd':
            a.remove();
        }
      });
    };
    if (charsToTreat === 0) removeAttrs();
    const pageId = Campaign().get('playerpageid');
    characters.forEach(function(character) {
      character.get('defaulttoken', function(token) {
        if (token === '') {
          removeAttrs();
          return;
        }
        token = JSON.parse(token);
        if (!token) {
          removeAttrs();
          return;
        }
        let bar1_link = token.bar1_link;
        if (bar1_link === '') {
          removeAttrs();
          return;
        }
        let attrLie = getObj('attribute', bar1_link);
        if (attrLie === undefined) {
          removeAttrs();
          return;
        }
        if (attrLie.get('name') != 'pnj_pv') {
          removeAttrs();
          return;
        }
        let attrPV = findObjs({
          _type: 'attribute',
          _characterid: character.id,
          name: 'PV'
        }, {
          caseInsensitive: true
        });
        if (attrPV.length === 0) {
          removeAttrs();
          return;
        }
        token.bar1_link = attrPV[0].id;
        token.pageid = pageId;
        token.imgsrc = token.imgsrc.replace('/med.png', '/thumb.png');
        token.imgsrc = token.imgsrc.replace('/max.png', '/thumb.png');
        let newToken = createObj('graphic', token);
        if (newToken) {
          setDefaultTokenForCharacter(character, newToken);
          newToken.remove();
        } else {
          log('Impossible de cr\xE9er un token pour ' + token.name);
          log(token);
        }
        removeAttrs();
      });
    });
    log("Mise \xE0 jour des attributs et tokens effectu\xE9e");
  }
  if (state.COFantasy.version < 2.11) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      if (a.get('name') != 'capitaine') return;
      let nomCapitaine = a.get('current');
      let idCapitaine = a.get('max');
      let na = {
        current: idCapitaine + ' ' + nomCapitaine,
        max: 2
      };
      a.set(na);
    });
    log("Mise \xE0 jour des attributs de capitaine effectu\xE9e");
  }
  if (state.COFantasy.version < 2.12) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      let attrName = a.get('name');
      if (!attrName.startsWith('dose_') && !attrName.startsWith('consommable_')) return;
      let charId = a.get('characterid');
      //On ne passe dans la liste que pour les persos de type PJ
      let typePerso = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'type_personnage',
      }, {
        caseInsensitive: true
      });
      if (typePerso.length > 0 && typePerso[0].get('current') != 'PJ') return;
      let consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ');
      if (consName === '') return;
      let quantite = parseInt(a.get('current'));
      if (isNaN(quantite) || quantite < 0) return;
      let pref = 'repeating_equipement_' + generateRowID() + '_';
      let versionFiche = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'version',
      }, {
        caseInsensitive: true
      });
      if (versionFiche.length === 0) versionFiche = 0;
      else versionFiche = parseFloat(versionFiche[0].get('current'));
      if (versionFiche < 4.01) {
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip-nom',
          current: consName
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip-qte',
          current: quantite
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip-effet',
          current: a.get('max').trim(),
        });
      } else {
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip_nom',
          current: consName
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip_qte',
          current: quantite
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip_effet',
          current: a.get('max').trim(),
        });
      }
      a.remove();
    });
    log("D\xE9placement des attributs de consommables vers la fiche");
  }
  if (state.COFantasy.version < 2.13) {
    //On enl\xE8ve les attributs obsol\xE8tes de la verison 4.00 de la fiche
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      if (a.get('name').toLowerCase() == 'equip-div') {
        if (a.get('current') === '') {
          a.remove();
          return;
        }
        let charId = a.get('characterid');
        let newAttr = findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: 'equip_div',
        }, {
          caseInsensitive: true
        });
        newAttr = newAttr.filter(function(na) {
          if (na.get('current') === '') {
            na.remove();
            return false;
          }
          return true;
        });
        if (newAttr.length === 0) {
          a.set('name', 'equip_div');
        } else {
          let character = getObj('character', charId);
          if (character === undefined) return;
          sendChat("COFantasy", "Supprimer l'attribut 'equip-div' du personnage" + character.get('name'));
          log("Supprimer l'attribut 'equip-div' du personnage" + character.get('name'));
          log("valeur courante " + newAttr[0].get('current'));
          log("Ancienne valeur " + a.get('current'));
          return;
        }
      }
    });
  }
  if (state.COFantasy.version < 2.14) {
    //Migration des \xE9l\xE9ments de r\xE8gles optionnels
    //Divers
    if (state.COFantasy.options.regles.val.poudre_explosif) {
      state.COFantasy.options.regles.val.divers.val.poudre_explosif.val = state.COFantasy.options.regles.val.poudre_explosif.val;
      delete state.COFantasy.options.regles.val.poudre_explosif;
    }
    if (state.COFantasy.options.regles.val.forme_d_arbre_amelioree) {
      state.COFantasy.options.regles.val.divers.val.forme_d_arbre_amelioree.val = state.COFantasy.options.regles.val.forme_d_arbre_amelioree.val;
      delete state.COFantasy.options.regles.val.forme_d_arbre_amelioree;
    }
    if (state.COFantasy.options.regles.val.interchangeable_attaque) {
      state.COFantasy.options.regles.val.divers.val.interchangeable_attaque.val = state.COFantasy.options.regles.val.interchangeable_attaque.val;
      delete state.COFantasy.options.regles.val.interchangeable_attaque;
    }
    //Dommages
    if (state.COFantasy.options.regles.val.dm_minimum) {
      state.COFantasy.options.regles.val.dommages.val.dm_minimum.val = state.COFantasy.options.regles.val.dm_minimum.val;
      delete state.COFantasy.options.regles.val.dm_minimum;
    }
    if (state.COFantasy.options.regles.val.crit_elementaire) {
      state.COFantasy.options.regles.val.dommages.val.crit_elementaire.val = state.COFantasy.options.regles.val.crit_elementaire.val;
      delete state.COFantasy.options.regles.val.crit_elementaire;
    }
    if (state.COFantasy.options.regles.val.blessures_graves) {
      state.COFantasy.options.regles.val.dommages.val.blessures_graves.val = state.COFantasy.options.regles.val.blessures_graves.val;
      delete state.COFantasy.options.regles.val.blessures_graves;
    }
    //Haute DEF
    if (state.COFantasy.options.regles.val.usure_DEF) {
      state.COFantasy.options.regles.val.haute_DEF.val.usure_DEF.val = state.COFantasy.options.regles.val.usure_DEF.val;
      delete state.COFantasy.options.regles.val.usure_DEF;
    }
    if (state.COFantasy.options.regles.val.generer_options_attaques) {
      log("Options d'attaques supprim\xE9es ; veuiller utiliser le bouton 'Options' de la liste d'Actions \xE0 la place");
      sendChat('COFantasy', "Options d'attaques supprim\xE9es ; veuiller utiliser le bouton 'Options' de la liste d'Actions \xE0 la place");
      delete state.COFantasy.options.regles.val.generer_options_attaques;
    }
    if (state.COFantasy.options.regles.val.generer_attaque_groupe) {
      log("Attaques de groupe supprim\xE9es ; veuiller utiliser le bouton 'Options' de la liste d'Actions \xE0 la place");
      sendChat('COFantasy', "Options d'attaques supprim\xE9es ; veuiller utiliser le bouton 'Options' de la liste d'Actions \xE0 la place");
      delete state.COFantasy.options.regles.val.generer_attaque_groupe;
    }
    if (state.COFantasy.options.regles.val.bonus_attaque_groupe) {
      state.COFantasy.options.regles.val.haute_DEF.val.bonus_attaque_groupe.val = state.COFantasy.options.regles.val.bonus_attaque_groupe.val;
      delete state.COFantasy.options.regles.val.bonus_attaque_groupe;
    }
    if (state.COFantasy.options.regles.val.crit_attaque_groupe) {
      state.COFantasy.options.regles.val.haute_DEF.val.crit_attaque_groupe.val = state.COFantasy.options.regles.val.crit_attaque_groupe.val;
      delete state.COFantasy.options.regles.val.crit_attaque_groupe;
    }
    //Initiative
    if (state.COFantasy.options.regles.val.initiative_variable) {
      state.COFantasy.options.regles.val.initiative.val.initiative_variable.val = state.COFantasy.options.regles.val.initiative_variable.val;
      delete state.COFantasy.options.regles.val.initiative_variable;
    }
    if (state.COFantasy.options.regles.val.initiative_variable_individuelle) {
      state.COFantasy.options.regles.val.initiative.val.initiative_variable_individuelle.val = state.COFantasy.options.regles.val.initiative_variable_individuelle.val;
      delete state.COFantasy.options.regles.val.initiative_variable_individuelle;
    }
    //Mana
    if (state.COFantasy.options.regles.val.mana_totale) {
      state.COFantasy.options.regles.val.mana.val.mana_totale.val = state.COFantasy.options.regles.val.mana_totale.val;
      delete state.COFantasy.options.regles.val.mana_totale;
    }
    if (state.COFantasy.options.regles.val.elixirs_sorts) {
      state.COFantasy.options.regles.val.mana.val.elixirs_sorts.val = state.COFantasy.options.regles.val.elixirs_sorts.val;
      delete state.COFantasy.options.regles.val.elixirs_sorts;
    }
    log("R\xE8gles optionelles mises \xE0 jour");
  }
  if (state.COFantasy.version < 2.15) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      let attrName = a.get('name');
      if (!attrName.startsWith('dose_') && !attrName.startsWith('consommable_')) return;
      let charId = a.get('characterid');
      //On ne passe dans la liste que pour les persos de type PNJ
      let typePerso = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'type_personnage',
      }, {
        caseInsensitive: true
      });
      if (typePerso.length > 0 && typePerso[0].get('current') == 'PJ') return;
      let consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ');
      if (consName === '') return;
      let quantite = parseInt(a.get('current'));
      if (isNaN(quantite) || quantite < 0) return;
      let pref = 'repeating_equipement_' + generateRowID() + '_';
      createObj('attribute', {
        _characterid: charId,
        name: pref + 'equip_nom',
        current: consName
      });
      createObj('attribute', {
        _characterid: charId,
        name: pref + 'equip_qte',
        current: quantite
      });
      createObj('attribute', {
        _characterid: charId,
        name: pref + 'equip_effet',
        current: a.get('max').trim(),
      });
      a.remove();
    });
    log("D\xE9placement des attributs de consommables de PNJs vers la fiche");
  }
  if (state.COFantasy.version < 2.16) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    let handouts = findObjs({
      _type: 'handout'
    });
    let handhoutComp = handouts.find(function(h) {
      let handName = h.get('name');
      return (handName == 'Comp\xE9tences' || handName == 'Competences');
    });
    if (handhoutComp) {
      let listeCompetences = {
        FOR: [],
        DEX: [],
        CON: [],
        SAG: [],
        INT: [],
        CHA: [],
        nombre: 0
      };
      handhoutComp.get('notes', function(note) { // asynchronous
        let carac; //La carac dont on sp\xE9cifie les comp\xE9tences actuellement
        note = note.trim();
        if (note.startsWith('<p>')) note = note.substring(3);
        note = note.trim().replace(/<span[^>]*>|<\/span>/g, '');
        note = note.replace(/<p>/g, '<br>');
        note = note.replace(/<\/p>/g, '');
        let lignes = note.trim().split('<br>');
        lignes.forEach(function(ligne) {
          ligne = ligne.trim();
          let header = ligne.split(':');
          if (header.length > 1) {
            let c = header.shift().trim().toUpperCase();
            if (c != 'FOR' && c != 'CON' && c != 'DEX' && c != 'INT' && c != 'SAG' && c != 'CHA') return;
            carac = c;
            ligne = header.join(':').trim();
          }
          if (ligne.length === 0) return;
          if (carac === undefined) {
            log("Comp\xE9tences sans caract\xE9ristique associ\xE9e");
            return;
          }
          let comps = ligne.split(/, |\/| /);
          comps.forEach(function(comp) {
            if (comp.length === 0) return;
            listeCompetences[carac].push(comp);
            listeCompetences.nombre++;
          });
        });
        let compToCarac = {};
        listeCompetences.FOR.forEach(function(c) {
          compToCarac[c] = 'FOR';
          compToCarac[c.toLowerCase()] = 'FOR';
        });
        listeCompetences.CON.forEach(function(c) {
          compToCarac[c] = 'CON';
          compToCarac[c.toLowerCase()] = 'CON';
        });
        listeCompetences.DEX.forEach(function(c) {
          compToCarac[c] = 'DEX';
          compToCarac[c.toLowerCase()] = 'DEX';
        });
        listeCompetences.INT.forEach(function(c) {
          compToCarac[c] = 'INT';
          compToCarac[c.toLowerCase()] = 'INT';
        });
        listeCompetences.SAG.forEach(function(c) {
          compToCarac[c] = 'SAG';
          compToCarac[c.toLowerCase()] = 'SAG';
        });
        listeCompetences.CHA.forEach(function(c) {
          compToCarac[c] = 'CHA';
          compToCarac[c.toLowerCase()] = 'CHA';
        });
        attrs.forEach(function(a) {
          let attrName = a.get('name');
          switch (attrName) {
            case 'RACE':
              a.set('name', 'race');
              return;
            case 'PROFIL':
              a.set('name', 'profil');
              return;
            case 'NIVEAU':
              a.set('name', 'niveau');
              return;
            case 'SEXE':
              a.set('name', 'sexe');
              return;
            case 'AGE':
              a.set('name', 'age');
              return;
            case 'TAILLE':
              a.set('name', 'taille');
              return;
            case 'POIDS':
              a.set('name', 'poids');
              return;
            case 'FORCE':
              a.set('name', 'force');
              return;
            case 'DEXTERITE':
              a.set('name', 'dexterite');
              return;
            case 'CONSTITUTION':
              a.set('name', 'constitution');
              return;
            case 'INTELLIGENCE':
              a.set('name', 'intelligence');
              return;
            case 'SAGESSE':
              a.set('name', 'sagesse');
              return;
            case 'CHARISME':
              a.set('name', 'charisme');
              return;
          }
          //Les comp\xE9tences
          let charId = a.get('characterid');
          //On ne bouge les comp\xE9tences que pour les persos de type PJ
          let typePerso = findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: 'type_personnage',
          }, {
            caseInsensitive: true
          });
          if (typePerso.length > 0 && typePerso[0].get('current') != 'PJ') return;
          if (compToCarac[attrName] === undefined) return;
          let prefix = 'repeating_competences_' + generateRowID() + '_comp_';
          let attrSpec = {
            characterid: charId
          };
          attrSpec.name = prefix + 'nom';
          attrSpec.current = attrName;
          createObj('attribute', attrSpec);
          attrSpec.name = prefix + 'bonus';
          attrSpec.current = a.get('current');
          let attrBonus = createObj('attribute', attrSpec);
          attrSpec.name = prefix + 'bonusTotal';
          createObj('attribute', attrSpec);
          attrSpec.name = prefix + 'carac';
          attrSpec.current = compToCarac[attrName];
          createObj('attribute', attrSpec);
          let attrMalus;
          if ((attrSpec.current == 'DEX' && attrName != 'crochetage' && attrName != 'd\xE9samor\xE7age') ||
            (attrSpec.current == 'CON' && attrName == 'survie') ||
            attrName == 'natation' || attrName == 'escalade') {
            attrSpec.name = prefix + 'malus';
            attrSpec.current = 'armure';
            attrMalus = createObj('attribute', attrSpec);
            attrBonus.setWithWorker('current', a.get('current'));
            attrMalus.setWithWorker('current', 'armure');
          } else if (attrName == 'perception' || attrName == 'vigilance') {
            attrSpec.name = prefix + 'malus';
            attrSpec.current = 'casque';
            attrMalus = createObj('attribute', attrSpec);
            attrBonus.setWithWorker('current', a.get('current'));
            attrMalus.setWithWorker('current', 'casque');
          }
          a.remove();
        });
      }); //end hand.get(notes)
    } else {
      attrs.forEach(function(a) {
        let attrName = a.get('name');
        switch (attrName) {
          case 'RACE':
            a.set('name', 'race');
            return;
          case 'PROFIL':
            a.set('name', 'profil');
            return;
          case 'NIVEAU':
            a.set('name', 'niveau');
            return;
          case 'SEXE':
            a.set('name', 'sexe');
            return;
          case 'AGE':
            a.set('name', 'age');
            return;
          case 'TAILLE':
            a.set('name', 'taille');
            return;
          case 'POIDS':
            a.set('name', 'poids');
            return;
          case 'FORCE':
            a.set('name', 'force');
            return;
          case 'DEXTERITE':
            a.set('name', 'dexterite');
            return;
          case 'CONSTITUTION':
            a.set('name', 'constitution');
            return;
          case 'INTELLIGENCE':
            a.set('name', 'intelligence');
            return;
          case 'SAGESSE':
            a.set('name', 'sagesse');
            return;
          case 'CHARISME':
            a.set('name', 'charisme');
            return;
        }
      });
    }
    log("Mise \xE0 jour des attributs de comp\xE9tence effectu\xE9");
  }
  if (state.COFantasy.version < 2.17) {
    let macros = findObjs({
      _type: 'macro'
    }).concat(findObjs({
      _type: 'ability'
    }));
    macros.forEach(function(m) {
      let macro = m.get("action");
      let newMacro = macro.replace("!cof-tenebres @{selected|token_id} --disque @{target|token_id} 5 20",
        "!cof-tenebres @{selected|token_id} @{target|token_id}");
      if (macro !== newMacro)
        m.set("action", newMacro);
    });
    log("Mise \xE0 jour des ability T\xE9n\xE8bres effectu\xE9e");
  }
  let updateReset = function(a, nom, typ) {
    let c = parseInt(a.get('current'));
    let m = parseInt(a.get('max'));
    if (c === m) return;
    if (isNaN(m)) return;
    a.set('current', m);
    createObj('attribute', {
      name: 'limitePar' + typ + '__' + nom,
      characterid: a.get('characterid'),
      current: c
    });
  };
  if (state.COFantasy.version < 2.18) {
    if (state.COFantasy.combat) {
      let attrs = findObjs({
        _type: 'attribute',
      });
      attrs.forEach(function(a) {
        let nom = a.get('name');
        switch (nom) {
          case 'chairACanon':
          case 'attaqueEnTraitre':
          case 'paradeDeProjectiles':
          case 'prouesse':
          case 'devierLesCoups':
            updateReset(a, nom, 'Tour');
            return;
          case 'increvable':
          case 'esquiveFatale':
          case 'interventionDivine':
          case 'petitVeinard':
          case 'prescience':
          case 'kiai':
            updateReset(a, nom, 'Combat');
            return;
          default:
            return;
        }
      });
    }
    log("Mise \xE0 jour des attributs effectu\xE9e");
  }
  if (state.COFantasy.version < 3.00) {
    let macros = findObjs({
      _type: 'macro'
    });
    characters.forEach(function(c) {
      let cid = c.id;
      let abilities = findObjs({
        _type: 'ability',
        _characterid: cid,
      });
      let actionsDuTour;
      let actionAbilities = abilities.filter(function(a) {
        let an = a.get('name');
        if (an.startsWith('#') && an.endsWith('#')) {
          if (actionsDuTour) return true;
          if (an == '#TurnAction#' || an == '#Actions#') {
            actionsDuTour = a;
            return false;
          }
          return true;
        }
        return false;
      });
      let listeARemplir = 1;
      let abilitiesInList = new Set();
      actionAbilities.forEach(function(a) {
        if (listeARemplir > 4) return;
        let listeActions = a.get('action')
          .replace(/\n/gm, '').replace(/\r/gm, '')
          .replace(/%#([^#]*)#/g, '\n!cof-liste-actions $1')
          .replace(/\/\/%/g, '\n\/\/__pc')
          .replace(/\/\/#/g, '\n\/\/__mc')
          .replace(/\/\/!/g, '\n\/\/__cmd')
          .replace(/%/g, '\n%').replace(/#/g, '\n#').replace(/!/g, '\n!')
          .split('\n');
        if (listeActions.length === 0) return;
        let n = 0;
        let attrRang = findObjs({
          _type: 'attribute',
          _characterid: cid,
          name: 'maxrangaction' + listeARemplir
        }, {
          caseInsensitive: true
        });
        if (attrRang && attrRang.length > 0) {
          attrRang = attrRang[0];
          n = parseInt(attrRang.get('current'));
          if (isNaN(n) || n < 0) n = 0;
        } else {
          attrRang = createObj('attribute', {
            name: 'maxrangaction' + listeARemplir,
            current: 0,
            characterid: cid
          });
        }
        listeActions.forEach(function(action) {
          action = action.trim();
          if (action === '') return;
          if (n === 0 && action.startsWith('!options')) {
            createObj('attribute', {
              name: 'optionslisteactions' + listeARemplir,
              current: action.substring(8).trim(),
              characterid: cid,
            });
            createObj('attribute', {
              name: 'action' + listeARemplir + 'optflag',
              current: 'on',
              characterid: cid,
            });
            return;
          }
          let pref = 'repeating_actions' + listeARemplir + '_' + generateRowID() + '_';
          n++;
          if (action.startsWith('//')) {
            action = action.substring(2);
            if (action.startsWith('__pc')) {
              action = action.substr(4);
              abilitiesInList.add(action.split(' ')[0]);
              action = '%' + action;
            } else if (action.startsWith('__mc')) action = '#' + action.substr(4);
            else if (action.startsWith('__cmd')) action = '!' + action.substr(5);
            createObj('attribute', {
              name: pref + 'actiontitre',
              current: action,
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actionmontree',
              current: 0,
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actionoptflag',
              current: 'off',
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actionrang',
              current: n,
              characterid: cid,
            });
            return;
          }
          if (action.startsWith('!cof-liste-actions ')) {
            action = action.substring(19);
            createObj('attribute', {
              name: pref + 'actiontype',
              current: 'liste',
              characterid: cid,
            });
          } else if (action.startsWith('%')) {
            let abName = action.split(' ')[0].substr(1);
            abilitiesInList.add(abName);
          }
          createObj('attribute', {
            name: pref + 'actiontitre',
            current: action,
            characterid: cid,
          });
          createObj('attribute', {
            name: pref + 'actionoptflag',
            current: 'off',
            characterid: cid,
          });
          createObj('attribute', {
            name: pref + 'actionrang',
            current: n,
            characterid: cid,
          });
        });
        if (n === 0) return;
        let an = a.get('name');
        createObj('attribute', {
          name: 'nomlisteaction' + listeARemplir,
          current: an.substring(1, an.length - 1),
          characterid: cid,
        });
        attrRang.set('current', n);
        listeARemplir++;
        a.remove();
      });
      let n = 0;
      let attrRang = findObjs({
        _type: 'attribute',
        _characterid: cid,
        name: 'maxrangaction'
      }, {
        caseInsensitive: true
      });
      if (attrRang && attrRang.length > 0) {
        attrRang = attrRang[0];
        n = parseInt(attrRang.get('current'));
        if (isNaN(n) || n < 0) n = 0;
      } else {
        attrRang = createObj('attribute', {
          name: 'maxrangaction',
          current: 0,
          characterid: cid
        });
      }
      if (actionsDuTour) {
        let actions = actionsDuTour.get('action')
          .replace(/\n/gm, '').replace(/\r/gm, '')
          .replace(/%#([^#]*)#/g, '\n!cof-liste-actions $1')
          .replace(/\/\/%/g, '\n\/\/__pc')
          .replace(/\/\/#/g, '\n\/\/__mc')
          .replace(/\/\/!/g, '\n\/\/__cmd')
          .replace(/%/g, '\n%').replace(/#/g, '\n#').replace(/!/g, '\n!')
          .split('\n');
        actions.forEach(function(action) {
          action = action.trim();
          if (action === '') return;
          let pref;
          let actionMontree = true;
          if (action.startsWith('//')) {
            action = action.substring(2);
            if (action.startsWith('__pc')) action = '%' + action.substr(4);
            else if (action.startsWith('__mc')) action = '#' + action.substr(4);
            else if (action.startsWith('__cmd')) action = '!' + action.substr(5);
            actionMontree = false;
          }
          if (action.startsWith('!cof-liste-actions ')) {
            n++;
            pref = 'repeating_actions_' + generateRowID() + '_';
            createObj('attribute', {
              name: pref + 'actionoptflag',
              current: 'off',
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actionrang',
              current: n,
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actiontitre',
              current: action.substring(19),
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actiontype',
              current: 'liste',
              characterid: cid,
            });
            if (!actionMontree) createObj('attribute', {
              name: pref + 'actionmontree',
              current: 0,
              characterid: cid,
            });
            return;
          }
          let actionCommands = action.split(' ');
          actionCommands = actionCommands.filter(function(c) {
            return c !== '';
          });
          let actionCmd = actionCommands[0];
          let actionText = actionCmd.replace(/-/g, ' ').replace(/_/g, ' ');
          let found = false;
          switch (actionCmd.charAt(0)) {
            case '%':
              // Ability
              actionCmd = actionCmd.substr(1);
              actionText = actionText.substr(1);
              abilities.forEach(function(abilitie, index) {
                if (found) return;
                if (abilitie.get('name') === actionCmd) {
                  // l'ability existe
                  found = true;
                  n++;
                  pref = 'repeating_actions_' + generateRowID() + '_';
                  createObj('attribute', {
                    name: pref + 'actionoptflag',
                    current: 'off',
                    characterid: cid,
                  });
                  createObj('attribute', {
                    name: pref + 'actionrang',
                    current: n,
                    characterid: cid,
                  });
                  if (!actionMontree) createObj('attribute', {
                    name: pref + 'actionmontree',
                    current: 0,
                    characterid: cid,
                  });
                  if (abilitiesInList.has(actionCmd) || abilitie.get('istokenaction')) {
                    //On garde le texte partag\xE9 de l'ability.
                    createObj('attribute', {
                      name: pref + 'actiontitre',
                      current: action,
                      characterid: cid,
                    });
                    return;
                  }
                  let command = abilitie.get('action').trim();
                  if (actionCommands.length > 1) {
                    //On rajoute les options de l'ability
                    command += action.substr(action.indexOf(' '));
                  }
                  createObj('attribute', {
                    name: pref + 'actiontitre',
                    current: actionText,
                    characterid: cid,
                  });
                  createObj('attribute', {
                    name: pref + 'actioncode',
                    current: command,
                    characterid: cid,
                  });
                  //On peut effacer l'ability
                  abilitie.remove();
                }
              });
              return;
            case '#':
              n++;
              pref = 'repeating_actions_' + generateRowID() + '_';
              createObj('attribute', {
                name: pref + 'actionoptflag',
                current: 'off',
                characterid: cid,
              });
              createObj('attribute', {
                name: pref + 'actionrang',
                current: n,
                characterid: cid,
              });
              if (!actionMontree) createObj('attribute', {
                name: pref + 'actionmontree',
                current: 0,
                characterid: cid,
              });
              // Macro
              //D'abord le cas de #Attaque, car le nom affich\xE9 est celui de l'arme
              if (actionCmd == '#Attaque' && actionCommands.length > 1) {
                createObj('attribute', {
                  name: pref + 'actiontitre',
                  current: action,
                  characterid: cid,
                });
                return;
              }
              actionCmd = actionCmd.substr(1);
              actionText = actionText.substr(1);
              macros.forEach(function(macro, index) {
                if (found) return;
                if (macro.get('name') === actionCmd) {
                  found = true;
                  let command = macro.get('action').trim();
                  if (actionCommands.length > 1) {
                    //On rajoute les options de la macro
                    command += action.substr(action.indexOf(' '));
                  }
                  createObj('attribute', {
                    name: pref + 'actiontitre',
                    current: actionText,
                    characterid: cid,
                  });
                  createObj('attribute', {
                    name: pref + 'actioncode',
                    current: command,
                    characterid: cid,
                  });
                }
              });
              return;
            default:
              n++;
              pref = 'repeating_actions_' + generateRowID() + '_';
              createObj('attribute', {
                name: pref + 'actionoptflag',
                current: 'off',
                characterid: cid,
              });
              createObj('attribute', {
                name: pref + 'actionrang',
                current: n,
                characterid: cid,
              });
              createObj('attribute', {
                name: pref + 'actiontitre',
                current: action,
                characterid: cid,
              });
              if (!actionMontree) createObj('attribute', {
                name: pref + 'actionmontree',
                current: 0,
                characterid: cid,
              });
          }
        });
        actionsDuTour.remove();
      } else if (state.COFantasy.options &&
        state.COFantasy.options.affichage &&
        state.COFantasy.options.affichage.val &&
        state.COFantasy.options.affichage.val.actions_par_defaut.val) {
        //Par d\xE9faut, on montrait la liste de toutes les abilities
        abilities.forEach(function(a) {
          n++;
          let pref = 'repeating_actions_' + generateRowID() + '_';
          createObj('attribute', {
            name: pref + 'actionoptflag',
            current: 'off',
            characterid: cid,
          });
          createObj('attribute', {
            name: pref + 'actionrang',
            current: n,
            characterid: cid,
          });
          let nom = a.get('name');
          if (nom.startsWith('#') && nom.endsWith('#')) {
            createObj('attribute', {
              name: pref + 'actiontitre',
              current: nom.substring(1, nom.length - 2),
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actiontype',
              current: 'liste',
              characterid: cid,
            });
          } else if (a.get('istokenaction')) {
            createObj('attribute', {
              name: pref + 'actiontitre',
              current: '%' + nom,
              characterid: cid,
            });
          } else { //On copie l'ability et on l'efface
            let actionText = nom.replace(/-/g, ' ').replace(/_/g, ' ');
            let command = a.get('action').trim();
            createObj('attribute', {
              name: pref + 'actiontitre',
              current: actionText,
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actioncode',
              current: command,
              characterid: cid,
            });
            a.remove();
          }
        });
      }
      if (n > 0) attrRang.set('current', n);
    });
    log("Mise \xE0 jour des listes d'action effectu\xE9e");
    //Ensuite les pr\xE9dicats bool\xE9ens
    let predicates = '^(' +
      'actionLibre|agripper|ambidextreDuelliste|animal|argumentDeTaille' +
      '|armureProtection|armureProtection|aucuneActionCombat|baroudHonneur' +
      '|botteMortelle|bouclierPsi|briseurDOs|bucheron|champion' +
      '|chasseurEmerite|chatimentDuMale|chimiste|ciblesMultiples' +
      '|combatEnPhalange|combatKinetique|commandant|controleDuMetabolisme' +
      '|creatureArtificielle|crocEnJambe|defenseIntuitive|d\xE9mon|devorer' +
      '|durACuire|ecuyer|elfeNoir|enchainement|energieDeLaMort' +
      '|estUneIllusion|exsangue|f\xE9e|fievreChene|frappeChirurgicale|gober' +
      '|graceFeline|graceFelineVoleur|grosMonstreGrosseArme|grosseTete' +
      '|hachesEtMarteaux|hausserLeTon|horsDePortee|humanoide' +
      '|ignorerLaDouleur|immuniteAuxArmes|immuniteAuxSournoises' +
      '|immuniteSaignement|increvableHumain|inderacinable|insecte' +
      '|insensibleAffaibli|instinctDeSurvieHumain|intelligenceDuCombat' +
      '|invisibleEnCombat|invulnerable|joliCoup|langageSombreHetre' +
      '|liberteDAction|manoeuvreDuelliste|mauvais|memePasMal|monture' +
      '|montureLoyale|montureMagique|morsureDuSerpent|mortVivant' +
      '|nAbandonneJamais|natureNourriciereBaies|nonVivant' +
      '|ordreDuChevalierDragon|peauDePierre|peutEnrager|projection' +
      '|proprioception|protectionDMZone|quadrupede|raillerieImpossible' +
      '|reduireLaDistance|riposte|saisirEtBroyer|sangDeFerIf' +
      '|sansEsprit|sansPeur|scienceDuCritique|secondSouffle|sensAffutes' +
      '|sergent|tirParabolique|tourDeForce|tropPetit|ventreMou' +
      '|vieArtificielle' +
      '|diviseEffet_.*|immunite_.*|protectionDMZone_.*' +
      ')$';
    let predicateRegExp = new RegExp(predicates);
    let parChar = {};
    findObjs({
      _type: 'attribute',
    }).forEach(function(attribute) {
      let nom = attribute.get('name');
      if (predicateRegExp.test(nom)) {
        let charId = attribute.get('characterid');
        parChar[charId] = parChar[charId] || new Set();
        parChar[charId].add(nom);
        attribute.remove();
      } else {
        switch (nom) {
          case 'immunitePeur':
            {
              let charId = attribute.get('characterid');
              parChar[charId] = parChar[charId] || new Set();
              parChar[charId].add('immunite_peur');
              attribute.remove();
            }
            break;
          case 'immuniteContreSurprise':
            {
              let charId = attribute.get('characterid');
              parChar[charId] = parChar[charId] || new Set();
              parChar[charId].add('immunite_surpris');
              attribute.remove();
            }
            break;
          case 'geant':
            {
              let charId = attribute.get('characterid');
              parChar[charId] = parChar[charId] || new Set();
              parChar[charId].add('g\xE9ant');
              attribute.remove();
            }
            break;
        }
      }
    });
    for (let charId in parChar) {
      let pred = parChar[charId];
      let predText = '';
      for (let p of pred) {
        predText += p + ' ';
      }
      let attr = findObjs({
        _tyoe: 'attribute',
        _characterid: charId,
        name: 'predicats_script'
      }, {
        caseInsensitive: true
      });
      if (attr.length === 0) {
        createObj('attribute', {
          name: 'predicats_script',
          current: predText,
          characterid: charId
        });
      } else {
        attr = attr[0];
        attr.set('current', predText + attr.get('current'));
      }
    }
    log("Transformation des attributs bool\xE9ens en pr\xE9dicats");
  }
  let getPredicateAttr = function(charId) {
    let attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: 'predicats_script'
    }, {
      caseInsensitive: true
    });
    let predText = '';
    if (attr.length === 0) {
      attr = createObj('attribute', {
        name: 'predicats_script',
        current: '',
        characterid: charId
      });
    } else {
      attr = attr[0];
      predText = attr.get('current');
      if (predText !== '') predText += '\n';
    }
    return {
      attr,
      predText
    };
  };
  if (state.COFantasy.version < 3.01) {
    let predicates = '^(' +
      'absorptionEnergie|adaptable|armureDeVent|attaqueEnMeute' +
      '|cavalierEmerite|coefPVMana|DEF_magie|dentellesEtRapiere' +
      '|esquiveVoleur|faireMouche|frenesie|initEnMain' +
      '|increvable|instinctDeSurvie|interventionDivine|loupParmiLesLoups' +
      '|piquresDInsectes|prouesse|radarMental|RD_critique|reflexesFelins' +
      '|siphonDesAmes|siphonDesAmesPrioritaire|tirPrecis|vetementsSacres' +
      '|visionDansLeNoir|voieDeLaConjuration|voieDeLArcEtDuCheval' +
      '|voieDeLaMagieElementaire|voieDeLaSurvie|voieDeLaTelekinesie' +
      '|voieDeLHonneur|voieDesElixirs|voieDesMutations|voieDesRunes' +
      '|voieDesSoins|voieDesVegetaux|voieDuGuerisseur' +
      '|voieDuMeneurDHomme|voieDuMetal|voieDuSoldat|vulnerableCritique' +
      '|initEnMain.*' +
      ')$';
    let predicateRegExp = new RegExp(predicates);
    let parChar = {};
    findObjs({
      _type: 'attribute',
    }).forEach(function(attribute) {
      let nom = attribute.get('name');
      if (predicateRegExp.test(nom)) {
        let charId = attribute.get('characterid');
        parChar[charId] = parChar[charId] || {};
        parChar[charId][nom] = attribute.get('current');
        attribute.remove();
      }
    });
    for (let charId in parChar) {
      let pred = parChar[charId];
      let {
        attr,
        predText
      } = getPredicateAttr(charId);
      for (let p in pred) {
        let val = pred[p];
        if (val === 'true') predText += p + ' ';
        else predText += p + ':' + val + ' ';
      }
      attr.set('current', predText);
    }
    log("Transformation des attributs num\xE9riques en pr\xE9dicats");
  }
  if (state.COFantasy.version < 3.02) {
    const regPJ = new RegExp("^(repeating_armes_[^_]*_)(.*)$");
    const regPNJ = new RegExp("^(repeating_pnjatk_[^_]*_)(.*)$");
    characters.forEach(function(c) {
      const charId = c.id;
      let reg;
      const attrType = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'type_personnage'
      }, {
        caseInsensitive: true
      });
      if (attrType.length === 0 || attrType[0].get('current') == 'PJ') {
        reg = regPJ;
      } else {
        reg = regPNJ;
      }
      let attributes = findObjs({
        _type: 'attribute',
        _characterid: charId,
      });
      let munitions = {}; //map de nom de munition d'attaques vers attribut
      let attaques = {};
      attributes.forEach(function(attr) {
        const nom = attr.get('name');
        if (nom.length > 9 && nom.startsWith('munition_')) {
          let fin = nom.substring(9);
          munitions[fin] = attr;
          return;
        }
        const m = reg.exec(nom);
        if (!m) return;
        attaques[m[1]] = attaques[m[1]] || {};
        attaques[m[1]][m[2]] = attr;
      });
      _.forEach(attaques, function(att, pref) {
        if (att.armetypeattaque === undefined) return;
        if (att.armetypeattaque.get('current') != 'Arme de jet') return;
        let options = [];
        if (att.armeoptions !== undefined) {
          options = att.armeoptions.get('current');
          if (options.startsWith('-')) options = ' ' + options;
          options = options.split(' --');
        }
        let typesMunitions = 0;
        let current = 1;
        let max = 1;
        let taux = 0;
        let attrMunition;
        let optionsSansMunitions = options.filter(function(opt) {
          opt = opt.trim();
          let cmd = opt.split(' ');
          if (cmd.length < 2) return true;
          if (cmd[0] != 'munition') return true;
          let ma = munitions[cmd[1]];
          if (ma === undefined) return true;
          attrMunition = ma;
          typesMunitions++;
          max = parseInt(ma.get('max'));
          if (isNaN(max) || max < 0) max = 1;
          current = parseInt(ma.get('current'));
          if (isNaN(current) || current < 0 || current > max) current = max;
          if (cmd.length > 2) {
            taux = parseInt(cmd[2]);
            if (isNaN(taux) || taux < 0 || taux > 100) taux = 0;
          } else {
            taux = 100; //La valeur par d\xE9faut en option.
          }
          return false;
        });
        if (typesMunitions == 1) {
          let qte = att.armejetqte;
          if (qte === undefined) {
            if (current !== 1 || max !== 1) {
              createObj('attribute', {
                characterid: charId,
                name: pref + 'armejetqte',
                current: current,
                max: max
              });
            }
          } else {
            qte.set('current', current);
            qte.set('max', max);
          }
          let at = att.armejettaux;
          if (at === undefined) {
            if (taux !== 0) {
              createObj('attribute', {
                characterid: charId,
                name: pref + 'armejettaux',
                current: taux
              });
            }
          } else {
            at.set('current', taux);
          }
          att.armeoptions.set('current', optionsSansMunitions.join(' --'));
          attrMunition.remove();
        } else { // On ne sait pas faire la traduction
          let mod = att.armemodificateurs;
          if (mod === undefined) {
            createObj('attribute', {
              characterid: charId,
              name: pref + 'armemodificateurs',
              current: 'retourneEnMain'
            });
          } else {
            mod.set('current', mod.get('current') + ' retourneEnMain');
          }
        }
      });
    });
    log("Mise \xE0 jour des armes de jet effectu\xE9e");
  }
  if (state.COFantasy.version < 3.03) {
    findObjs({
      _type: 'attribute',
    }).forEach(function(attribute) {
      let nom = attribute.get('name');
      if (nom != 'armeParDefaut') return;
      let charId = attribute.get('characterid');
      let arme = attribute.get('current');
      attribute.remove();
      let {
        attr,
        predText
      } = getPredicateAttr(charId);
      predText += 'armeParDefaut';
      if (arme.trim() !== '') predText += ':' + arme;
      attr.set('current', predText);
    });
    log("Mise \xE0 jour de pr\xE9dicats effectu\xE9e");
  }
  if (state.COFantasy.version < 3.04) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    if (state.COFantasy.combat) {
      attrs.forEach(function(a) {
        let nom = a.get('name');
        switch (nom) {
          case 'resistanceALaMagieBarbare':
          case 'esquiveAcrobatique':
          case 'paradeMagistrale':
          case 'paradeAuBouclier':
            updateReset(a, nom, 'Tour');
            return;
          default:
            return;
        }
      });
    }
    let predicates = '^(' +
      'armureLourdeGuerrier|attaqueEnTraitre|bonusFeinte|chairACanon' +
      '|corpsElementaire|devierLesCoups' +
      '|esquiveAcrobatique|esquiveFatale|fauchage|frappeDuVide|interchangeable|kiai|pacifisme|pacteSanglant|paradeAuBouclier|paradeMagistrale' +
      '|paradeDeProjectiles|petitVeinard|porteurDuBouclierDeGrabuge|prescience|resistanceALaMagie' +
      '|resistanceALaMagieBarbare|riposteGuerrier|tirFatal|traquenard|voieOutreTombe' +
      '|bonusSaveContre_.*|eclaire_.*' +
      ')$';
    let predicateRegExp = new RegExp(predicates);
    let parChar = {};
    attrs.forEach(function(attribute) {
      let nom = attribute.get('name');
      if (predicateRegExp.test(nom)) {
        let charId = attribute.get('characterid');
        parChar[charId] = parChar[charId] || {};
        parChar[charId][nom] = attribute.get('current');
        if (nom == 'bonusFeinte') {
          let nbDesFeinte = attribute.get('max');
          if (nbDesFeinte !== '') parChar[charId].nbDesFeinte = nbDesFeinte;
        } else if (nom == 'pacifisme') {
          parChar[charId][nom] = attribute.get('max');
        } else if (nom == 'traquenard') {
          parChar[charId][nom] = 'true';
        } else if (nom == 'fauchage') {
          let tailleFauchage = attribute.get('max');
          if (tailleFauchage !== '')
            parChar[charId].tailleFauchage = tailleFauchage;
        } else if (nom.startsWith('eclaire_')) {
          let eclaireFaible = attribute.get('max');
          if (eclaireFaible !== '') {
            let nomFaible = nom.replace('eclaire_', 'eclaireFaible_');
            parChar[charId][nomFaible] = eclaireFaible;
          }
        }
        attribute.remove();
      }
      if (nom.startsWith('charge_')) {
        let charId = attribute.get('characterid');
        parChar[charId] = parChar[charId] || {};
        parChar[charId][nom] = attribute.get('current');
        //On n'efface pas, l'attribut reste pour la valeur courante de charge
      } else if (nom == 'defierLaMort') {
        let charId = attribute.get('characterid');
        parChar[charId] = parChar[charId] || {};
        parChar[charId][nom] = 'true';
      }
    });
    for (let charId in parChar) {
      let pred = parChar[charId];
      let {
        attr,
        predText
      } = getPredicateAttr(charId);
      for (let p in pred) {
        let val = pred[p];
        if (val === 'true' || val === '' || val == 1) predText += p + ' ';
        else predText += p + ':' + val + ' ';
      }
      attr.set('current', predText);
    }
    log("Transformation d'attributs de combat en pr\xE9dicats");
  }
  if (state.COFantasy.version < 3.05) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      let name = a.get('name');
      if (name == 'pnj_armure' || name == 'pnj_bouclier') a.remove();
    });
    log("Suppression des attributs pnj d'armure et de bouclier");
  }
  state.COFantasy.version = scriptVersion;
  handout.forEach(function(hand) {
    COFantasy.changeHandout(hand);
  });
  //V\xE9rification de la version sur les fiches
  characters.forEach(function(c) {
    COFantasy.scriptVersionToCharacter(c, 11);
  });
  COF_loaded = true;
  log("COFantasy " + scriptVersion + " loaded");
});

on("chat:message", function(msg) {
  "use strict";
  if (COF_loaded && msg.type == "api" && msg.content.startsWith('!cof-')) {
    if (COF_BETA) {
      COFantasy.apiCommand(msg);
    } else {
      try {
        COFantasy.apiCommand(msg);
      } catch (e) {
        sendChat('COF', "Erreur durant l'ex\xE9cution de " + msg.content);
        log("Erreur durant l'ex\xE9cution de " + msg.content);
        log(msg);
        var errMsg = e.name;
        if (e.lineNumber) errMsg += " at " + e.lineNumber;
        else if (e.number) errMsg += " at " + e.number;
        errMsg += ': ' + e.message;
        sendChat('COF', errMsg);
        log(errMsg);
      }
    }
  }
});

on("change:handout", COFantasy.changeHandout);
on("destroy:handout", function(prev) {
  COFantasy.changeHandout(undefined, prev);
});
on("change:campaign:turnorder", COFantasy.nextTurn);
on("destroy:token", COFantasy.destroyToken);
on("change:graphic:statusmarkers", COFantasy.changeMarker);
on("change:token", COFantasy.moveToken);
on("add:character", function(c) {
  if (COF_loaded) {
    COFantasy.scriptVersionToCharacter(c);
  }
});
