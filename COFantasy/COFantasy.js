// ------------------ generateRowID code from the Aaron ---------------------
const generateUUID = (function() {
    "use strict";
    let a = 0,
      b = [];
    return function() {
      let c = (new Date()).getTime() + 0,
        d = c === a;
      a = c;
      let e = new Array(8);
      for (let f = 7; 0 <= f; f--) {
        e[f] = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c % 64);
        c = Math.floor(c / 64);
      }
      c = e.join("");
      if (d) {
        let f = 11;
        for (; 0 <= f && 63 === b[f]; f--) {
          b[f] = 0;
        }
        b[f]++;
      } else {
        for (let f = 0; 12 > f; f++) {
          b[f] = Math.floor(64 * Math.random());
        }
      }
      for (let f = 0; 12 > f; f++) {
        c += "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);
      }
      return c;
    };
  }()),

  generateRowID = function() {
    "use strict";
    return generateUUID().replace(/_/g, "Z");
  };
//--------------- end generateRowID ----------------------------------------

const COF_BETA = false;

let COF_loaded = false;

// Le script utilise la partie COFantasy de la variable d'\xE9tat state
// Pour plus de facilit\xE9, on utilise stateCOF = state.COFantasy
// Champs utilis\xE9s:
// - options : les options de jeu
// - setting_arran : toutes les fiches utilisent les r\xE8gles Terres d'Arran
// - setting_mixte : on a un mixte de fiches classiques et Terres d'Arran
// - roundMarkerId : l'id du token utilis\xE9 pour l'aura d'initiative
// - combat : d\xE9fini si le jeu est en mode tour par tour, contient :
//   - pageId        : la pageid du combat
//   - activeTokenId : id du token dont c'est le tour
//   - activeTokenName : nom du token dont c'est le tour, au cas o\xF9 l'id change
//   - tour          : num\xE9ro de tour dans le combat
//   - init          : niveau d'initiative courant
//   - armeesDesMorts : map de token id vers perso
//   - auras         : liste des auras actives
//   - aurasCounts   : computeur pour id des auras
//   - usureOff      : on ne compte plus l'usure du combat
// - personnageCibleCree : pour savoir si on a cr\xE9\xE9 un personnage cible (avec 0 PV pour centrer les aoe)
// - tablesCrees : pour savoir si on a cr\xE9\xE9 les tables par d\xE9faut
// - gameMacros : la liste des macros cr\xE9\xE9es par le script
// - chargeFantastique : tout ce dont on a besoin pour une charge fantastique en cours (TODO: passer sous combat)
// - eventId : compteur d'events pour avoir une id unique
// - tokensTemps : liste de tokens \xE0 dur\xE9e de vie limit\xE9e, effac\xE9s \xE0 la fin du combat
// - foudreDuTemps : \xE9tat g\xE9n\xE9ral de foudres du temps
// - tenebresMagiques : \xE9tat g\xE9n\xE9ral de t\xE9n\xE8bres magiques
// - jetsEnCours : pour laisser le MJ montrer ou non un jet qui lui a \xE9t\xE9 montr\xE9 \xE0 lui seul
// - currentAttackDisplay : pour pouvoir remontrer des display aux joueurs
// - pause : le jeu est en pause
// - prescience : un personnage sur la carte de combat a la capacit\xE9 prescience (TODO: passer sous combat)
// - nextPrescience : pour le changement de tour car prescience ne revient que d'un tour
// - afterDisplay : donn\xE9es \xE0 afficher apr\xE8s un display
// - version : la version du script en cours, pour d\xE9tecter qu'on change de version

var COFantasy = COFantasy || function() {

  "use strict";

  const versionFiche = 5.01;

  const PIX_PER_UNIT = 70;
  const HISTORY_SIZE = 200;
  const BS_LABEL = 'text-transform: uppercase; display: inline; padding: .2em .6em .3em; font-size: 75%; line-height: 2; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: .25em;';
  const BS_LABEL_SUCCESS = 'background-color: #5cb85c;';
  const BS_LABEL_INFO = 'background-color: #5bc0de;';
  const BS_LABEL_WARNING = 'background-color: #f0ad4e;';
  const BS_LABEL_DANGER = 'background-color: #d9534f;';
  const DEFAULT_DYNAMIC_INIT_IMG = 'https://s3.amazonaws.com/files.d20.io/images/4095816/086YSl3v0Kz3SlDAu245Vg/thumb.png?1400535580';
  const IMG_INVISIBLE = 'https://s3.amazonaws.com/files.d20.io/images/24377109/6L7tn91HZLAQfrLKQI7-Ew/thumb.png?1476950708';

  let markerCatalog = {};
  let eventHistory = [];
  let updateNextInitSet = new Set();

  const flashyInitMarkerScale = 1.6;

  const attaqueAMainsNues = {
    name: 'Mains nues',
    attSkill: '@{ATKCAC}',
    attNbDices: 1,
    attDice: 4,
    attDMBonusCommun: 0,
    attCarBonus: '@{FOR}',
    crit: 20,
    divers: '',
    portee: 0,
    typeDegats: 'contondant',
    options: '--tempDmg',
  };

  const defaultOptions = {
    regles: {
      explications: "Options qui influent sur les r\xE8gles du jeu",
      type: 'options',
      val: {
        divers: {
          explications: "Options diverses",
          type: 'options',
          val: {
            forme_d_arbre_amelioree: {
              explications: "+50% \xE0 l'effet de la peau d'\xE9corce en forme d'arbre.",
              val: true,
              type: 'bool'
            },
            poudre_explosif: {
              explications: "Les armes \xE0 poudre font des d\xE9g\xE2ts explosifs",
              val: true,
              type: 'bool'
            },
            interchangeable_attaque: {
              explications: "La capacit\xE9 interchangeable donne moins de DEF mais plus d'attaque",
              val: true,
              type: 'bool'
            },
            coups_critiques_etendus: {
              explications: "Coup critique \xE0 une attaque d\xE8s qu'elle d\xE9passe DEF + 10",
              val: false,
              type: 'bool'
            },
            echec_critique_boule_de_feu: {
              explications: "Nombre de m\xE8tre dont le centre d'une boule de feu peut \xEAtre d\xE9plac\xE9 de mani\xE8re al\xE9atoire en cas d'\xE9chec critique. La probabilit\xE9 est inversement proportionelle \xE0 la distance.",
              val: 12,
              type: 'int'
            }
          }
        },
        dommages: {
          explications: "R\xE8gles optionnelles sur les dommages",
          type: 'options',
          val: {
            blessures_graves: {
              explications: "Si on arrive \xE0 0 PV, on perd 1PR, et si on a plus de PR, on a une blessure grave.",
              val: true,
              type: 'bool'
            },
            degats_importants: {
              explications: "Si les DMs d\xE9passent CON+niveau en une attaque, on applique aussi la r\xE8gle de blessure grave. Si la valeur de cette option est 0, la r\xE8gles n'est pas appliqu\xE9e. Sinon, la r\xE8gle n'est appliqu\xE9e que si, de plus, les DMs d\xE9passent maxPV / valeur.",
              val: 3,
              type: 'int'
            },
            dm_minimum: {
              explications: "D\xE9g\xE2ts minimum d'une attaque ou autre source de DM.",
              val: 0,
              type: 'int'
            },
            crit_elementaire: {
              explications: "Les DMs constants d'un autre type que celui de l'arme sont aussi multipli\xE9s en cas de critique",
              val: false,
              type: 'bool'
            },
            max_rune_protection: {
              explications: "Les DMs qu'une rune de protection est capable d'absorber sont limit\xE9s \xE0 10x le rang du forgesort dans la voie des runes",
              val: true,
              type: 'bool'
            },
            dm_explosifs: {
              explications: "Tous les d\xE9s de DM sont explosifs",
              val: false,
              type: 'bool'
            }
          }
        },
        haute_DEF: {
          explications: "Options de jeu pour g\xE9rer la haute DEF",
          type: 'options',
          val: {
            usure_DEF: {
              explications: "Malus de -2 en DEF tous les n tours. Mettre \xE0 0 pour ne pas avoir de malus d'usure",
              val: 6,
              type: 'int'
            },
            bonus_attaque_groupe: {
              explications: "Lors d'une attaque de groupe, bonus \xE0 la touche par cr\xE9ature suppl\xE9mentaire",
              val: 2,
              type: 'int'
            },
            crit_attaque_groupe: {
              explications: "Lors d'une attaque de groupe, si le jet de touche d\xE9passe DEF + cette valeur, les dommages sont doubl\xE9s (0 = jamais)",
              val: 5,
              type: 'int'
            }
          }
        },
        initiative: {
          explications: "Options qui influent sur les r\xE8gles du jeu",
          type: 'options',
          val: {
            initiative_variable: {
              explications: "Ajoute 1d6 \xE0 l'initiative, lanc\xE9 une fois par combat par type de cr\xE9ature",
              val: false,
              type: 'bool'
            },
            initiative_variable_individuelle: {
              explications: "Lancer l'initiative variable pour chaque cr\xE9ature (n\xE9cessite d'activer l'Initiative variable)",
              val: false,
              type: 'bool'
            },
            joueurs_lancent_init: {
              explications: "Fait appara\xEEtre un bouton pour que les joueurs lancent leur initiative (n\xE9cessite d'activer l'Initiative variable)",
              val: false,
              type: 'bool'
            }
          }
        },
        mana: {
          explications: "Options de Mana",
          type: 'options',
          val: {
            mana_totale: {
              explications: "Tous les sorts ont un co\xFBt, celui des temp\xEAtes de mana est multipli\xE9 par 3",
              val: false,
              type: 'bool'
            },
            contrecoup: {
              explications: "Avec la Mana Totale, permet au lanceur de sort de payer un d\xE9ficit de PM en PV (COF p. 181)",
              val: false,
              type: 'bool'
            },
            brulure_de_magie: {
              explications: "Permettre d'utiliser ses PV comme PM (Magie de CO Terres d'Arran, incompatible avec Mana Totale)",
              val: false,
              type: 'bool'
            },
            elixirs_sorts: {
              explications: "Toutes fabrications d'\xE9lixir sont consid\xE9r\xE9es comme des sorts (qui peuvent co\xFBter de la mana)",
              val: true,
              type: 'bool'
            },
          }
        }
      }
    },
    affichage: {
      explications: "Options d'affichage",
      type: 'options',
      val: {
        MJ_voit_actions: {
          explications: "\xC0 chaque nouveau personnage en combat, montre le choix d'actions au MJ, m\xEAme pour les PJs.",
          val: false,
          type: 'bool'
        },
        MJ_valide_affichage_attaques: {
          explications: "Les r\xE9sultats des attaques sont d'abord montr\xE9es au MJ seul, qui peut ensuite les montrer aux joueurs",
          val: false,
          type: 'bool'
        },
        MJ_valide_affichage_jets: {
          explications: "Les r\xE9sultats des jets de caract\xE9ristiques sont d'abord montr\xE9es au MJ seul, qui peut ensuite les montrer aux joueurs",
          val: false,
          type: 'bool'
        },
        avatar_dans_cadres: {
          explications: "Si faux, on utilise l'image du token.",
          val: true,
          type: 'bool'
        },
        manoeuvres: {
          explications: "Affiche les manoeuvres dans la liste d'actions",
          val: true,
          type: 'bool'
        },
        actions_par_defaut: {
          explications: "Sans ability #Actions#, affiche la liste des abilities",
          val: true,
          type: 'bool'
        },
        montre_def: {
          explications: "montre la DEF des adversaires dans les cadres de combat",
          val: true,
          type: 'bool'
        },
        duree_effets: {
          explications: "Le script indique la dur\xE9e des effets associ\xE9s aux tokens",
          val: false,
          type: 'bool'
        },
        init_dynamique: {
          explications: "Fait appara\xEEtre une aura dynamique sur le token qui a l'initiative",
          val: true,
          type: 'bool'
        },
        markers_personnalises: {
          explications: "Utilisation des markers personnalis\xE9s commen\xE7ant par cof",
          val: true,
          type: 'bool'
        },
        table_crit: {
          explications: "Utilisation d'une table de critiques nomm\xE9e Echec-Critique-Contact",
          val: false,
          type: 'bool'
        },
        depense_mana: {
          explications: "Le script pr\xE9cise la quantit\xE9 de mana utilis\xE9e dans le chat \xE0 chaque fois",
          val: false,
          type: 'bool'
        }
      }
    },
    images: {
      explications: "Images par d\xE9faut",
      type: 'options',
      val: {
        image_init: {
          explications: "Image utilis\xE9e pour indiquer le personnage dont c'est le tour",
          type: 'image',
          val: DEFAULT_DYNAMIC_INIT_IMG
        },
        image_double: {
          explications: 'Image utilis\xE9e pour la capacit\xE9 d\xE9doublement',
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/33854984/q10B3KtWsCxcMczLo4BSUw/thumb.png?1496303265"
        },
        image_ombre: {
          explications: "Image utilis\xE9e pour l'ombre mortelle",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/2781735/LcllgIHvqvu0HAbWdXZbJQ/thumb.png?13900368485"
        },
        image_arbre: {
          explications: "Image utilis\xE9e pour la forme d'arbre",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/52767134/KEGYUXeKnxZr5dbDwQEO4Q/thumb.png?15248300835"
        },
        image_mur_de_force: {
          explication: "Image utilis\xE9e pour un mur de force sph\xE9rique",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/33213510/5r3NGSso1QBJMJewTEKv0A/thumb.png?1495195634"
        },
        image_mur_de_vent: {
          explication: "Image utilis\xE9e pour un mur de vent sph\xE9rique",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/308931095/X5zH4itb9QI9La8O7KfMBQ/thumb.png?1665585092"
        },
        prison_vegetale: {
          explication: "Image utilis\xE9e pour un mur de force sph\xE9rique",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/254738719/c97DFw6JlEePDVXBf-MPsA/thumb.png?1636471250"
        },
      }
    },
    sons: {
      explications: "Sons par d\xE9faut",
      type: 'options',
      val: {
        attaque_echec_critique: {
          explication: "Son utilis\xE9 pour les \xE9checs critiques d'attaques",
          type: 'son',
          val: ''
        },
        attaque_reussite_critique: {
          explication: "Son utilis\xE9 pour les r\xE9ussites critiques d'attaques",
          type: 'son',
          val: ''
        }
      }
    },
    macros_a_jour: {
      explications: "Met automatiquement les macros \xE0 jour",
      type: 'bool',
      val: true
    }
  };

  function copyOptions(dst, src) {
    for (let o in src) {
      let opt = src[o];
      let isOption = opt.type == 'options';
      if (dst[o] === undefined) {
        dst[o] = {
          explications: opt.explications,
          val: {},
          type: opt.type,
        };
        if (!isOption) dst[o].val = opt.val;
      }
      if (isOption) copyOptions(dst[o].val, opt.val);
    }
  }

  //Liste de tables par d\xE9faut
  const gameTables = [{
    name: "Echec-Critique-Contact",
    showplayers: false,
    items: [{
      name: "FOR - Bouscul\xE9  : le personnage est renvers\xE9 par son adversaire. Il subit un d\xE9 malus au test de FOR si l\x2019adversaire " +
        "est d\x2019une cat\xE9gorie de taille sup\xE9rieure et b\xE9n\xE9ficie d\x2019un d\xE9 bonus dans le cas inverse. " +
        "Il subit une attaque gratuite de la part d\x2019un adversaire pendant qu\x2019il est \xE9tal\xE9 au sol (-5 en DEF).",
      weight: 1,
    }, {
      name: "DEX - Maladresse : le personnage laisse tomber au sol l'objet avec lequel il attaque. S\x2019il essaye de le ramasser, " +
        "il subit une attaque gratuite.",
      weight: 1,
    }, {
      name: "CON - Coup de mou: le personnage subit l\x2019\xE9tat affaibli pendant 3 rounds. Ou il peut annuler cet \xE9tat en reprenant" +
        "son souffle par une action limit\xE9e.",
      weight: 1,
    }, {
      name: "INT - Erreur tactique : le personnage subit une attaque (gratuite) d\x2019un adversaire \xE0 son contact.",
      weight: 1,
    }, {
      name: "SAG - Distrait : le personnage se laisse distraire et ne voit pas venir la prochaine attaque, " +
        "l\x2019adversaire b\xE9n\xE9ficiera d\x2019un bonus de +10.",
      weight: 1,
    }, {
      name: "CHA - Ridicule : le personnage fait un faux mouvement \xE0 la fois douloureux et ridicule, il subit " +
        "l\x2019\xE9tat \xE9tourdi pendant un round pour reprendre contenance.",
      weight: 1,
    }, {
      name: "Votre arme se brise. S\x2019il s\x2019agit d\x2019une arme magique, le d\xE9 DM est simplement r\xE9duit d'une cat\xE9gorie " +
        "(2d6/d12=>d10=>d8=>d6=>d4=>d3) jusqu\x2019\xE0 la fin du combat.",
      weight: 1,
    }, {
      name: "Une pi\xE8ce d\x2019armure bouge et elle devient plus g\xEAnante que protectrice : malus en DEF et en attaque pour le reste du combat. Cuir : -1, Maille : -2, Plaque -3.",
      weight: 1,
    }, {
      name: "Simple \xE9chec de l'attaque",
      weight: 12,
    }, ],
  }, ];

  let stateCOF = state.COFantasy;
  let reglesOptionelles; // = stateCOF.options.regles.val;

  // List of states:
  const cof_states = {
    assomme: 'status_pummeled',
    mort: 'status_dead',
    surpris: 'status_lightning-helix',
    renverse: 'status_back-pain',
    aveugle: 'status_bleeding-eye',
    affaibli: 'status_half-heart',
    etourdi: 'status_half-haze',
    paralyse: 'status_fishing-net',
    ralenti: 'status_snail',
    immobilise: 'status_cobweb',
    endormi: 'status_sleepy',
    apeure: 'status_screaming',
    invisible: 'status_ninja-mask',
    blesse: 'status_arrowed',
    encombre: 'status_frozen-orb',
    penombre: 'status_archery-target',
    enseveli: 'status_edge-crack',
    chef: 'status_black-flag'
  };

  //Remplis quand on sait quels sont les markers dans setStateCOF
  const etat_de_marker = {};
  const effet_de_marker = {};

  // Donne le nom de l'attribut, selon qu'il concerne un mook ou un personnage
  // unique
  // perso peut ne pas avoir de token
  function fullAttributeName(perso, attribute, options) {
    if (perso.token && (!options || !options.charAttr)) {
      let link = perso.token.get('bar1_link');
      if (link === '') return attribute + '_' + perso.token.get('name');
    }
    return attribute;
  }

  //Retourne une liste d'attributs
  //personnage peut ne pas avoir de token
  function tokenAttribute(personnage, name) {
    let fullName = fullAttributeName(personnage, name);
    return findObjs({
      _type: 'attribute',
      _characterid: personnage.charId,
      name: fullName
    });
  }

  function charAttribute(charId, name, option) {
    return findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: name
    }, option);
  }

  function toInt(n, def) {
    let res = parseInt(n);
    if (isNaN(res)) return def;
    return res;
  }

  function attrAsInt(attr, def, defPresent) {
    if (attr.length === 0) return def;
    if (defPresent === undefined) defPresent = def;
    return toInt(attr[0].get('current'), defPresent);
  }

  function attrAsBool(attr) {
    if (attr.length === 0) return false;
    attr = attr[0].get('current');
    if (attr == '0' || attr == 'false') return false;
    if (attr) return true;
    return false;
  }

  // Attention, def, la valeur par d\xE9faut, doit \xEAtre la m\xEAme que sur la fiche
  // personnage peut ne pas avoir de token
  function ficheAttribute(personnage, name, def) {
    let attr = charAttribute(personnage.charId, name, {
      caseInsensitive: true
    });
    if (attr.length === 0) return def;
    return attr[0].get('current');
  }

  //personnage peut ne pas avoir de token
  function ficheAttributeAsInt(personnage, name, def, defPresent) {
    let attr = charAttribute(personnage.charId, name, {
      caseInsensitive: true
    });
    if (attr === undefined) return def;
    return attrAsInt(attr, def, defPresent);
  }

  //Il faut une valeur par d\xE9faut, qui correspond \xE0 celle de la fiche
  function ficheAttributeAsBool(personnage, name, def) {
    let attr = charAttribute(personnage.charId, name, {
      caseInsensitive: true
    });
    if (attr.length === 0) return def;
    return attrAsBool(attr);
  }

  //Attention \xE0 ne pas utiliser si l'attribut ne d\xE9pend pas du token
  //defPresent est optionnel
  //personnage peut ne pas avoir de token
  function attributeAsInt(personnage, name, def, defPresent) {
    let attr = tokenAttribute(personnage, name);
    return attrAsInt(attr, def, defPresent);
  }

  //personnage peut ne pas avoir de token
  function attributeAsBool(personnage, name) {
    let attr = tokenAttribute(personnage, name);
    return attrAsBool(attr);
  }

  function charAttributeAsInt(perso, name, def, defPresent) {
    let attr = charAttribute(perso.charId, name);
    return attrAsInt(attr, def, defPresent);
  }

  function charAttributeAsBool(perso, name) {
    let attr = charAttribute(perso.charId, name);
    return attrAsBool(attr);
  }

  function assignPredicate(pred, name, val) {
    if (pred[name]) {
      if (!Array.isArray(pred[name])) pred[name] = [pred[name]];
      pred[name].push(val);
    } else pred[name] = val;
  }

  function predicateOfRaw(raw) {
    let pred = {};
    let last, assign;
    //On coupe d'abord par ligne
    let lignes = raw.split('\n');
    lignes.forEach(function(ligne) {
      let indexPredComplexe = ligne.indexOf('::');
      let indexCommentaire = ligne.indexOf('//');
      let valeurPredComplexe = '';
      if (indexPredComplexe > 0 &&
        (indexCommentaire == -1 || indexCommentaire > indexPredComplexe)) {
        valeurPredComplexe = ligne.substring(indexPredComplexe + 2);
        ligne = ligne.substring(0, indexPredComplexe);
      } else if (indexCommentaire > 0) {
        ligne = ligne.substring(0, indexCommentaire);
      }
      ligne.split(/,| /).forEach(function(p) {
        p = p.trim();
        if (p === '') return;
        if (p === ':') {
          if (last) assign = true;
          return;
        }
        let i = p.indexOf(':');
        if (i < 0) {
          if (last) {
            if (assign) {
              assignPredicate(pred, last, p);
              assign = false;
            } else pred[last] = true;
          }
          last = p;
          return;
        }
        //p contient ':' mais pas seulement
        if (i === 0) {
          if (last) {
            assignPredicate(pred, last, p.substring(1));
            last = undefined;
          } else {
            last = p.substring(1);
          }
          assign = false;
          return;
        } //p ne commence pas par ':'
        if (last) pred[last] = true;
        if (i == p.length - 1) {
          last = p.substring(0, i);
          assign = true;
        } else {
          assignPredicate(pred, p.substring(0, i), p.substring(i + 1));
          last = undefined;
          assign = false;
        }
      });
      if (last && valeurPredComplexe !== '') {
        assignPredicate(pred, last, valeurPredComplexe);
        last = undefined;
      }
    });
    if (last) pred[last] = true;
    return pred;
  }

  function charPredicateAsBool(charId, name) {
    let pred = stateCOF.predicats[charId];
    if (pred) return pred;
    let raw = '';
    let attr = charAttribute(charId, 'predicats_script', {
      caseInsensitive: true
    });
    if (attr.length > 0) {
      raw = attr[0].get('current');
    }
    let attrArmes = charAttribute(charId, 'armeEnMain');
    if (attrArmes.length > 0) {
      let att;
      let attaques;
      let labelArme = attrArmes[0].get('current');
      if (labelArme) {
        attaques = listAllAttacks({
          charId
        });
        let att = attaques[labelArme];
        if (att) {
          let rawArme = fieldAsString(att, 'armepredicats', '');
          if (rawArme) raw += '\n' + rawArme;
        }
      }
      //Ensuite l'arme gauche
      labelArme = attrArmes[0].get('max');
      if (labelArme) {
        if (!att) {
          attaques = attaques || listAllAttacks({
            charId
          });
          att = attaques[labelArme];
        }
        if (att) {
          let rawArme = fieldAsString(att, 'armepredicats', '');
          if (rawArme) raw += '\n' + rawArme;
        }
      }
    }
    pred = predicateOfRaw(raw);
    stateCOF.predicats[charId] = pred;
    return pred[name];
  }


  //Probl\xE8me : \xE7a ne peut pas marcher pour les boucliers en main gauche
  //car \xE7a utilise lui-m\xEAme un bouclier...
  function getPredicates(perso) {
    if (perso.predicates === undefined) {
      const estMook = perso.token && perso.token.get('bar1_link') === '';
      if (!estMook && stateCOF.predicats[perso.charId]) {
        perso.predicates = stateCOF.predicats[perso.charId];
        return perso.predicates;
      }
      let raw = ficheAttribute(perso, 'predicats_script', '');
      if (perso.armesEnMain) {
        if (perso.arme && perso.arme.predicats)
          raw += '\n' + perso.arme.predicats;
        if (perso.armeGauche && perso.armeGauche.predicats)
          raw += '\n' + perso.armeGauche.predicats;
      } else if (perso.arme) { //possible si appel\xE9 depuis armesEnMain
        if (perso.arme.predicats)
          raw += '\n' + perso.arme.predicats;
      } else { //il faut chercher les pr\xE9dicats des armes en main
        //On n'appelle pas armesEnMain pour \xE9viter la r\xE9cursion
        //et pour \xE9viter trop de calcul
        let attrArmes = tokenAttribute(perso, 'armeEnMain');
        if (attrArmes.length > 0) {
          let att;
          let labelArme = attrArmes[0].get('current');
          if (labelArme) {
            let attaques = listAllAttacks(perso);
            let att = attaques[labelArme];
            if (att) {
              let rawArme = fieldAsString(att, 'armepredicats', '');
              if (rawArme) raw += '\n' + rawArme;
            }
          }
          //Ensuite l'arme gauche
          labelArme = attrArmes[0].get('max');
          if (labelArme) {
            if (!att) {
              let attaques = listAllAttacks(perso);
              att = attaques[labelArme];
            }
            if (att) {
              let rawArme = fieldAsString(att, 'armepredicats', '');
              if (rawArme) raw += '\n' + rawArme;
            }
          }
        }
      }
      let pred = predicateOfRaw(raw);
      perso.predicates = pred;
      if (!estMook) stateCOF.predicats[perso.charId] = pred;
    }
    return perso.predicates;
  }

  function predicateAsBool(perso, name) {
    let pred = getPredicates(perso);
    if (Array.isArray(pred)) pred = pred[0];
    return pred[name];
  }

  function predicateAsInt(perso, name, def, defPresent) {
    let pred = getPredicates(perso);
    let r = pred[name];
    if (r === undefined) return def;
    if (defPresent !== undefined) def = defPresent;
    if (Array.isArray(r)) r = r[0];
    if (r === true) return def;
    return toInt(r, def);
  }

  function predicatesNamed(perso, name) {
    let pred = getPredicates(perso);
    let r = pred[name];
    if (!r) return [];
    if (Array.isArray(r)) return r;
    return [r];
  }

  function predicateOrAttributeAsBool(perso, name) {
    let p = predicateAsBool(perso, name);
    if (p) return p;
    return attributeAsBool(perso, name);
  }

  function error(msg, obj) {
    log(msg);
    log(obj);
    if (msg) {
      try {
        sendChat('COFantasy', msg);
      } catch (e) {
        msg = msg.replace('[', '[ ');
        sendChat('COFantasy', "Message sans jet : " + msg);
      }
    }
  }

  function determineSettingDeJeu() {
    let characters = findObjs({
      _type: 'character'
    });
    let charsGenerique = [];
    let charsArran = [];
    characters.forEach(function(c) {
      let typePerso = charAttribute(c.id, 'type_personnage', {
        caseInsensitive: true
      });
      if (typePerso.length > 0 && typePerso[0].get('current') == 'PNJ')
        return; //Les fiches de PNJ sont les m\xEAmes
      let setting = charAttribute(c.id, 'option_setting', {
        caseInsensitive: true
      });
      if (setting.length === 0) {
        charsGenerique.push(c);
        return;
      }
      if (setting[0].get('current') == 'arran') charsArran.push(c);
      else charsGenerique.push(c);
    });
    if (charsArran.length <= charsGenerique.length) {
      log("Utilisation des r\xE8gles COF g\xE9n\xE9riques");
      if (charsArran.length > 0) {
        error("Attention, des personnages suivent les options de jeu des Terres d'Arran (voir le log pour la liste)", charsArran);
        charsArran.forEach(function(c) {
          let g = getObj('character', c.id);
          if (g) log(g.get('name'));
          else log(c);
        });
        stateCOF.setting_mixte = true;
      }
      return;
    }
    log("Utilisation des r\xE8gles des Terres d'Arran");
    if (charsGenerique.length > 0) {
      error("Attention, des personnages ne suivent pas les options de jeu des Terres d'Arran (voir le log pour la liste)", charsGenerique);
      charsGenerique.forEach(function(c) {
        let g = getObj('character', c.id);
        if (g) log(g.get('name'));
        else log(c);
      });
      stateCOF.setting_mixte = true;
      return;
    }
    stateCOF.setting_arran = true;
  }

  function persoArran(perso) {
    if (stateCOF.setting_arran) return true;
    if (!stateCOF.setting_mixte) return false;
    if (perso.arran === undefined) {
      perso.arran =
        ficheAttribute(perso, 'option_setting', 'generique') == 'arran';
    }
    return perso.arran;
  }

  let statusForInitAlly;
  let statusForInitEnemy;

  function registerMarkerEffet(marker, effet, mEffet, ms) {
    let m = markerCatalog[marker];
    if (m) {
      mEffet.statusMarker = m.tag;
      effet_de_marker[m.tag] = effet;
    } else if (ms) {
      if (effet_de_marker[ms] && effet_de_marker[ms] != effet) {
        sendChat('COF', effet_de_marker[ms] + " et " + effet + " ont le m\xEAme icone");
      }
      effet_de_marker[ms] = effet;
    } else {
      log("Marker " + m + " introuvable. Pas de marker pour l'effet " + effet);
    }
  }

  function splitIdName(idn) {
    let pos = idn.indexOf(' ');
    if (pos < 1 || pos >= idn.length) {
      error("idName mal form\xE9", idn);
      return;
    }
    let name = idn.substring(pos + 1);
    return {
      id: idn.substring(0, pos),
      name: name
    };
  }

  //Renvoie le token et le charId. Si l'id ne correspond \xE0 rien, cherche si
  //on trouve un nom de token, sur la page pass\xE9e en argument (ou sinon
  //sur la page active de la campagne)
  function persoOfId(id, name, pageId, allPages) {
    let token = getObj('graphic', id);
    if (token === undefined) {
      if (name === undefined) return undefined;
      if (pageId === undefined) {
        pageId = Campaign().get('playerpageid');
      }
      let tokens = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        name: name
      });
      if (tokens.length === 0) {
        if (allPages) {
          let pages = findObjs({
            _type: 'page'
          });
          pages.find(function(p) {
            if (p.id == pageId) return false;
            if (p.get('archived')) return false;
            tokens = findObjs({
              _type: 'graphic',
              _subtype: 'token',
              _pageid: pageId,
              name: name
            });
            return tokens.length > 0;
          });
          if (tokens.length === 0) return undefined;
        } else return undefined;
      }
      if (tokens.length > 1) {
        error("Ambig\xFCit\xE9 sur le choix d'un token : il y a " +
          tokens.length + " tokens nomm\xE9s " + name, tokens);
      }
      token = tokens[0];
    }
    let charId = token.get('represents');
    if (charId === '') {
      error("le token s\xE9lectionn\xE9 ne repr\xE9sente pas de personnage", token);
      return undefined;
    }
    return {
      token: token,
      charId: charId
    };
  }

  //Retourne le perso correspondant \xE0 un token id suivi du nom de token
  //Permet d'avoir une information robuste en cas d'interruption du script
  //peuple tokName
  function persoOfIdName(idn, pageId, allPages) {
    let sp = splitIdName(idn);
    if (sp === undefined) return;
    let perso = persoOfId(sp.id, sp.name, pageId, allPages);
    if (perso === undefined) {
      log("Impossible de trouver le personnage correspondant \xE0 " + sp.name);
      return;
    }
    perso.tokName = perso.token.get('name');
    if (perso.tokName == sp.name) return perso;
    log("En cherchant le token " + idn + ", on trouve " + perso.tokName);
    log(perso);
    return perso;
  }

  function idName(perso) {
    return perso.token.id + ' ' + perso.token.get('name');
  }

  let roundMarker;

  const roundMarkerSpec = {
    represents: '',
    rotation: 0,
    layer: 'map',
    name: 'Init marker',
    aura1_color: '#ff00ff',
    aura2_color: '#00ff00',
    imgsrc: DEFAULT_DYNAMIC_INIT_IMG,
    shownname: false,
    light_hassight: false,
    has_bright_light_vision: false,
    has_night_vision: false,
    is_drawing: true
  };
  let threadSync = 0;

  function removeRoundMarker() {
    if (roundMarker) {
      roundMarker.remove();
      roundMarker = undefined;
      stateCOF.roundMarkerId = undefined;
    } else if (stateCOF.roundMarkerId) {
      let roundMarkers = findObjs({
        _type: 'graphic',
        represents: '',
        name: 'Init marker',
      });
      roundMarkers.forEach(function(rm) {
        rm.remove();
      });
      stateCOF.roundMarkerId = undefined;
    }
  }

  function activateRoundMarker(sync, token) {
    if (!stateCOF.combat) {
      removeRoundMarker();
      threadSync = 0;
      return;
    }
    if (sync != threadSync) return;
    if (token) {
      // Cas sp\xE9ciaux du cavaliers
      let pageId = token.get('pageid');
      let personnage = persoOfId(token.id);
      let monteSur = tokenAttribute(personnage, 'monteSur');
      let estMontePar = tokenAttribute(personnage, 'estMontePar');
      let monture;
      let cavalier;
      if (monteSur.length > 0) {
        cavalier = personnage;
        monture = persoOfIdName(monteSur[0].get('current'), pageId);
        if (monture !== undefined) token = monture.token;
      } else if (estMontePar.length > 0) {
        monture = personnage;
        cavalier = persoOfIdName(estMontePar[0].get('current'), pageId);
      }
      removeRoundMarker();
      roundMarkerSpec._pageid = pageId;
      let tokenLayer = token.get('layer');
      if (tokenLayer !== 'objects') roundMarkerSpec.layer = tokenLayer;
      else roundMarkerSpec.layer = 'map';
      roundMarkerSpec.left = token.get('left');
      roundMarkerSpec.top = token.get('top');
      let width = (token.get('width') + token.get('height')) / 2 * flashyInitMarkerScale;
      roundMarkerSpec.width = width;
      roundMarkerSpec.height = width;
      roundMarkerSpec.imgsrc = stateCOF.options.images.val.image_init.val;
      let localImage;
      let gmNotes = token.get('gmnotes');
      try {
        gmNotes = _.unescape(decodeURIComponent(gmNotes)).replace('&nbsp;', ' ');
        gmNotes = linesOfNote(gmNotes);
        gmNotes.find(function(l) {
          if (l.startsWith('init_aura:')) {
            roundMarkerSpec.imgsrc = l.substring(10).trim();
            return true;
          }
          return false;
        });
      } catch (uriError) {
        log("Erreur de d\xE9codage URI dans la note GM de " + token.get('name') + " : " + gmNotes);
      }
      roundMarker = createObj('graphic', roundMarkerSpec);
      if (roundMarker === undefined && localImage) {
        error("Image locale de " + token.get('name') + " incorrecte (" + roundMarkerSpec.imgsrc + ")", gmNotes);
        roundMarkerSpec.imgsrc = stateCOF.options.images.val.image_init.val;
        roundMarker = createObj('graphic', roundMarkerSpec);
      }
      if (roundMarker === undefined && roundMarkerSpec.imgsrc != DEFAULT_DYNAMIC_INIT_IMG) {
        error("Image d'aura d'initiative incorrecte (" + roundMarkerSpec.imgsrc + ")", gmNotes);
        roundMarkerSpec.imgsrc = DEFAULT_DYNAMIC_INIT_IMG;
        roundMarker = createObj('graphic', roundMarkerSpec);
      }
      if (roundMarker === undefined) {
        error("Impossible de cr\xE9er le token pour l'aura dynamique", roundMarkerSpec);
        return false;
      }
      stateCOF.roundMarkerId = roundMarker.id;
      if (roundMarkerSpec.layer === 'map') toFront(roundMarker);
      // Ne pas amener une monture mont\xE9e en avant pour \xE9viter de cacher le cavalier
      if (cavalier && monture) {
        toFront(monture.token);
        toFront(cavalier.token);
      } else {
        toFront(token);
      }
      setTimeout(_.bind(activateRoundMarker, undefined, sync), 200);
    } else if (roundMarker) { //rotation
      let rotation = roundMarker.get('rotation');
      roundMarker.set('rotation', (rotation + 0.5) % 365);
      let timeout = 100;
      //let page = getObj('page', roundMarker.get('pageid'));
      //if (page && (page.get('dynamic_lighting_enabled') || page.get('showlighting'))) timeout = 2000;
      setTimeout(_.bind(activateRoundMarker, undefined, sync), timeout);
    }
  }

  function removeTokenFlagAura(token) {
    if (stateCOF.options.affichage.val.init_dynamique.val) {
      removeRoundMarker();
      stateCOF.roundMarkerId = undefined;
      return;
    }
    if (aura_token_on_turn) {
      token.set('aura2_radius', '');
      token.set('showplayers_aura2', false);
    } else {
      // Cas des tokens personnalis\xE9s
      if (statusForInitEnemy && statusForInitAlly) {
        token.set(statusForInitAlly, false);
        token.set(statusForInitEnemy, false);
      } else token.set('status_flying-flag', false);
    }
  }

  //Appel\xE9 au lancement du script, mise \xE0 jour de certaines variables globales
  function setStateCOF() {
    stateCOF = state.COFantasy;
    stateCOF.predicats = {}; //pr\xE9dicats par charId.
    if (stateCOF.roundMarkerId) {
      roundMarker = getObj('graphic', stateCOF.roundMarkerId);
      if (roundMarker === undefined) {
        log("Le marqueur d'init a chang\xE9 d'id");
        let roundMarkers = findObjs({
          _type: 'graphic',
          represents: '',
          name: 'Init marker',
        });
        if (roundMarkers.length > 0) {
          roundMarker = roundMarkers[0];
          stateCOF.roundMarkerId = roundMarker.id;
          roundMarkers.forEach(function(rm) {
            if (rm.id != roundMarker.id) rm.remove();
          });
        } else {
          roundMarker = undefined;
          stateCOF.roundMarkerId = undefined;
        }
      }
    }
    let combat = stateCOF.combat;
    if (combat && combat.pageId) {
      let pageCombat = getObj('page', combat.pageId);
      if (pageCombat === undefined) {
        if (stateCOF.roundMarkerId && roundMarker) {
          combat.pageId = roundMarker.get('pageid');
        } else {
          combat.pageId = Campaign().get('playerpageid');
        }
      }
    }
    if (!stateCOF.personnageCibleCree) {
      //On cherche si un personnage cible existe d\xE9j\xE0
      let persos = findObjs({
        _type: 'character',
        name: 'Cible',
        controlledby: 'all'
      });
      if (persos.length === 0) {
        let pages = findObjs({
          _type: 'page'
        });
        if (pages.length > 0) {
          let pageId = pages[0].id;
          let charCible = createObj('character', {
            name: 'Cible',
            controlledby: 'all',
            inplayerjournals: 'all',
            avatar: 'https://s3.amazonaws.com/files.d20.io/images/33041174/5JdDVh-34C-kZglTE1aq-w/max.png?1494837870',
          });
          if (charCible) {
            let attrPV = charAttribute(charCible.id, 'PV', {
              caseInsensitive: true
            });
            if (attrPV.length > 0) attrPV = attrPV[0];
            else attrPV = createObj('attribute', {
              name: 'PV',
              characterid: charCible.id,
              current: 0,
              max: 0
            });
            let attrType = charAttribute(charCible.id, 'type_personnage', {
              caseInsensitive: true
            });
            if (attrType.length > 0) {
              attrType[0].setWithWorker('current', 'PNJ');
            } else {
              attrType = createObj('attribute', {
                name: 'type_personnage',
                characterid: charCible.id,
                current: 'PJ',
              });
              attrType.setWithWorker('current', 'PNJ');
            }
            let tokenCible = createObj('graphic', {
              name: 'Cible',
              layer: 'objects',
              _pageid: pageId,
              imgsrc: 'https://s3.amazonaws.com/files.d20.io/images/33041174/5JdDVh-34C-kZglTE1aq-w/thumb.png?1494837870',
              represents: charCible.id,
              width: PIX_PER_UNIT,
              height: PIX_PER_UNIT,
              bar1_link: attrPV ? attrPV.id : ''
            });
            if (tokenCible) {
              setDefaultTokenForCharacter(charCible, tokenCible);
              tokenCible.remove();
            }
          }
        }
      }
      stateCOF.personnageCibleCree = true;
    }
    //Cr\xE9ation des tables par d\xE9faut
    if (!stateCOF.tablesCrees) {
      let allTables = findObjs({
        _type: 'rollabletable',
      });
      gameTables.forEach(function(gameTable) {
        let table = allTables.find(function(table) {
          return table.get('name') == gameTable.name;
        });
        if (table === undefined) {
          table = createObj('rollabletable', {
            name: gameTable.name,
            showplayers: gameTable.showplayers,
          });
          gameTable.items.forEach(function(tableItem) {
            tableItem.rollabletableid = table.id;
            createObj('tableitem', tableItem);
          });
        }
      });
      stateCOF.tablesCrees = true;
    }
    // Le setting
    determineSettingDeJeu();
    // Les options de jeu
    if (stateCOF.options === undefined) stateCOF.options = {};
    copyOptions(stateCOF.options, defaultOptions);
    reglesOptionelles = stateCOF.options.regles.val;
    // Les macros utiles en jeu
    if (stateCOF.options.macros_a_jour.val) {
      let macros = findObjs({
        _type: 'macro'
      });
      let players = findObjs({
        _type: 'player'
      });
      let mjs = [];
      players.forEach(function(p) {
        if (playerIsGM(p.id)) mjs.push(p.id);
      });
      let inBar = [];
      if (stateCOF.gameMacros) {
        //Check modified or removed macros
        stateCOF.gameMacros.forEach(function(gm) {
          let ngm = gameMacros.find(function(ngm) {
            return ngm.name == gm.name;
          });
          if (ngm) {
            if (ngm.action == gm.action && ngm.visibleto == gm.visibleto && ngm.istokenaction == gm.istokenaction) return;
            macros.forEach(function(m) {
              if (m.get('name') != ngm.name) return;
              if (ngm.action != gm.action && m.get('action') == gm.action)
                m.set('action', ngm.action);
              if (ngm.visibleto != gm.visibleto && m.get('visibleto') == gm.visibleto)
                m.set('visibleto', ngm.visibleto);
              if (ngm.istokenaction != gm.istokenaction && m.get('istokenaction') == gm.istokenaction)
                m.set('istokenaction', ngm.istokenaction);
              sendChat('COF', '/w GM Macro ' + ngm.name + ' mise \xE0 jour.');
            });
          } else {
            ngm = gameMacros.find(function(ngm) {
              return ngm.oldName == gm.name;
            });
            if (ngm) {
              macros.forEach(function(m) {
                if (m.get('name') != ngm.oldName) return;
                if (ngm.action == gm.action && ngm.visibleto == gm.visibleto && ngm.istokenaction == gm.istokenaction) {
                  sendChat('COF', '/w GM Macro ' + gm.name + ' change de nom et devient ' + ngm.name);
                }
                m.set('name', ngm.name);
                if (ngm.action != gm.action && m.get('action') == gm.action)
                  m.set('action', ngm.action);
                if (ngm.visibleto != gm.visibleto && m.get('visibleto') == gm.visibleto)
                  m.set('visibleto', ngm.visibleto);
                if (ngm.istokenaction != gm.istokenaction && m.get('istokenaction') == gm.istokenaction)
                  m.set('istokenaction', ngm.istokenaction);
                sendChat('COF', '/w GM Macro ' + ngm.name + ' mise \xE0 jour.');
              });
            } else {
              macros.forEach(function(m) {
                if (m.get('name') != gm.name) return;
                if (m.get('action') != gm.action) return;
                m.remove();
                sendChat('COF', '/w GM Macro ' + gm.name + ' effac\xE9e.');
              });
            }
          }
        });
        //Nouvelles macros
        gameMacros.forEach(function(ngm) {
          let gm = stateCOF.gameMacros.find(function(gm) {
            return ngm.name == gm.name;
          });
          if (!gm) {
            let prev =
              macros.find(function(macro) {
                return macro.get('name') == ngm.name;
              });
            if (prev === undefined) {
              sendChat('COF', '/w GM Macro ' + ngm.name + ' cr\xE9\xE9e.');
              if (ngm.inBar) inBar.push(ngm.name);
              mjs.forEach(function(playerId, i) {
                if (i === 0 || ngm.visibleto === '') {
                  ngm.playerid = playerId;
                  createObj('macro', ngm);
                }
              });
            }
          }
        });
      } else {
        //Peut-\xEAtre la premi\xE8re fois, v\xE9rifier les macros
        if (stateCOF.macros) {
          //ancienne version, et on avait copi\xE9 les macros
          //on enl\xE8ve juste Escalier, et on remplace par Monter et Descendre
          let mesc = macros.find(function(m) {
            return m.get('name') == 'Escalier';
          });
          if (mesc) {
            createObj('macro', {
              name: 'Monter',
              action: "!cof-escalier",
              visibleto: '',
              istokenaction: true,
              inBar: false,
              _playerid: mesc.playerid
            });
            createObj('macro', {
              name: 'Descendre',
              action: "!cof-escalier bas",
              visibleto: '',
              istokenaction: true,
              inBar: false,
              _playerid: mesc.playerid
            });
            mesc.remove();
          }
        } else {
          gameMacros.forEach(function(m) {
            let prev =
              macros.find(function(macro) {
                return macro.get('name') == m.name;
              });
            if (prev === undefined) {
              sendChat('COF', '/w GM Macro ' + m.name + ' cr\xE9\xE9e.');
              if (m.inBar) inBar.push(m.name);
              mjs.forEach(function(playerId, i) {
                if (i === 0 || m.visibleto === '') {
                  m.playerid = playerId;
                  createObj('macro', m);
                }
              });
            }
          });
        }
      }
      if (inBar.length > 0) {
        sendChat('COF', "/w GM Macros \xE0 mettre dans la barre d'action du MJ : " + inBar.join(', '));
      }
      stateCOF.gameMacros = gameMacros;
    }
    // R\xE9cup\xE9ration des token Markers attach\xE9s \xE0 la campagne image, nom, tag, Id
    const markers = JSON.parse(Campaign().get('token_markers'));
    markers.forEach(function(m) {
      markerCatalog[m.name] = m;
    });
    // Option Markers personnalis\xE9s activ\xE9
    if (stateCOF.options.affichage.val.markers_personnalises.val) {
      const cof_states_perso = {
        assomme: 'status_cof-assomme',
        surpris: 'status_cof-surpris',
        renverse: 'status_cof-renverse',
        aveugle: 'status_cof-aveugle',
        affaibli: 'status_cof-affaibli',
        etourdi: 'status_cof-etourdi',
        paralyse: 'status_cof-paralyse',
        ralenti: 'status_cof-ralenti',
        immobilise: 'status_cof-immobilise',
        endormi: 'status_cof-endormi',
        apeure: 'status_cof-apeure',
        invisible: 'status_cof-invisible',
        blesse: 'status_cof-blesse',
        encombre: 'status_cof-encombre',
        penombre: 'status_cof-penombre',
        //enseveli: 'status_edge-crack' -> \xC0 dessiner
        chef: 'status_cof-chef',
      };
      // On boucle sur la liste des \xE9tats pour v\xE9rifier que les markers sont bien pr\xE9sents !
      let markersAbsents = [];
      let ancientSet = true;
      for (let etat in cof_states_perso) {
        let markerName = cof_states_perso[etat].substring(7);
        let marker_perso = markerCatalog[markerName];
        if (marker_perso) {
          cof_states[etat] = 'status_' + marker_perso.tag;
          ancientSet = false;
        } else {
          markersAbsents.push(markerName);
        }
      }
      // Cas particulier des deux markers d'initiative
      if (markerCatalog['cof-init-ally']) {
        statusForInitAlly = 'status_' + markerCatalog['cof-init-ally'].tag;
      } else {
        markersAbsents.push('cof-init-ally');
      }
      if (markerCatalog['cof-init-enemy']) {
        statusForInitEnemy = 'status_' + markerCatalog['cof-init-enemy'].tag;
      } else {
        markersAbsents.push('cof-init-enemy');
      }
      // Cas des markers d'effet temporaire, 3 cas particuliers :
      // uniquement le tag sans "status_" devant
      for (let effet in messageEffetTemp) {
        let m = messageEffetTemp[effet];
        let ms = m.statusMarker;
        switch (effet) {
          case 'asphyxie':
            registerMarkerEffet('cof-asphyxie', effet, m, ms);
            break;
          case 'saignementsSang':
            registerMarkerEffet('cof-saigne', effet, m, ms);
            break;
          case 'prisonVegetale':
            registerMarkerEffet('cof-prison-vegetale', effet, m, ms);
            break;
          default:
            if (ms) {
              if (effet_de_marker[ms] && effet_de_marker[ms] != effet) {
                sendChat('COF', effet_de_marker[ms] + " et " + effet + " ont le m\xEAme icone");
              }
              effet_de_marker[ms] = effet;
            }
        }
      }
      for (let effet in messageEffetCombat) {
        let m = messageEffetCombat[effet];
        let ms = m.statusMarker;
        switch (effet) {
          case 'enflamme':
            registerMarkerEffet('cof-flamme', effet, m, ms);
            break;
          default:
            if (ms) {
              if (effet_de_marker[ms] && effet_de_marker[ms] != effet) {
                sendChat('COF', effet_de_marker[ms] + " et " + effet + " ont le m\xEAme icone");
              }
              effet_de_marker[ms] = effet;
            }
        }
      }
      if (!ancientSet) {
        markersAbsents.forEach(function(m) {
          log("Marker " + m + " introuvable");
        });
        log("Markers personnalis\xE9s activ\xE9s.");
      } else {
        log("Utilisation des markers par d\xE9faut");
      }
    }
    //Construction de la table markers => etat
    for (let etat in cof_states) {
      let marker = cof_states[etat].substring(7);
      etat_de_marker[marker] = etat;
    }
    stateCOF.jetsEnCours = undefined;
  }

  function etatRendInactif(etat) {
    let res =
      etat == 'mort' || etat == 'surpris' || etat == 'assomme' ||
      etat == 'etourdi' || etat == 'paralyse' || etat == 'endormi' ||
      etat == 'apeure';
    return res;
  }

  // retourne un tableau contenant la liste des ID de joueurs connect\xE9s controllant le personnage li\xE9 au Token
  function getPlayerIds(perso) {
    let character = getObj('character', perso.charId);
    if (character === undefined) return;
    let charControlledby = character.get('controlledby');
    if (charControlledby === '') return [];
    let playerIds = [];
    charControlledby.split(',').forEach(function(controlledby) {
      let player = getObj('player', controlledby);
      if (player === undefined) return;
      if (player.get('online')) playerIds.push(controlledby);
    });
    return playerIds;
  }

  function characterPageIds(charId) {
    let character = getObj('character', charId);
    if (character === undefined) return;
    let charControlledBy = character.get('controlledby');
    let playersIds = new Set();
    if (charControlledBy !== '') {
      charControlledBy.split(",").forEach(function(controlledby) {
        if (controlledby == 'all') {
          let players = findObjs({
            _type: 'player'
          });
          players.forEach(function(p) {
            if (p.get('online')) playersIds.add(p.id);
          });
        }
        let player = getObj('player', controlledby);
        if (player === undefined) return;
        if (player.get('online')) playersIds.add(controlledby);
      });
    }
    if (playersIds.size === 0) {
      findObjs({
        _type: 'player'
      }).forEach(function(p) {
        if (playerIsGM(p.id)) playersIds.add(p.id);
      });
    }
    let res = new Set();
    playersIds.forEach(function(pid) {
      res.add(getPageId(pid));
    });
    return res;
  }

  //PNJ au sens de la fiche utilis\xE9e, pas forc\xE9ment en jeu
  //perso peut ne pas avoir de token
  function persoEstPNJ(perso) {
    if (perso.pnj) return true;
    else if (perso.pj) return false;
    const typePerso = ficheAttribute(perso, 'type_personnage', 'PJ');
    perso.pnj = (typePerso == 'PNJ');
    perso.pj = !perso.pnj;
    return perso.pnj;
  }

  function getAttackName(attackLabel, perso) {
    const attaques = listAllAttacks(perso);
    const arme = attaques[attackLabel];
    if (arme === undefined) return;
    return arme.armenom;
  }

  function getState(personnage, etat) {
    let token = personnage.token;
    let charId = personnage.charId;
    let res = false;
    let attrInvisible = tokenAttribute(personnage, 'tokenInvisible');
    if (attrInvisible.length > 0 && token.id == attrInvisible[0].get('max')) {
      let tokenInvisible = getObj('graphic', attrInvisible[0].get('current'));
      if (tokenInvisible) token = tokenInvisible;
    }
    if (token !== undefined) {
      res = token.get(cof_states[etat]);
      if (token.get('bar1_link') === '') return res;
      // else, look for the character value, if any
      if (charId === undefined) charId = token.get('represents');
      personnage.charId = charId;
    }
    if (charId === '') {
      error("token with a linked bar1 but representing no character", token);
      return false;
    }
    if (etat == 'affaibli') { //special case due to new character sheet
      let de = ficheAttributeAsInt(personnage, 'ETATDE', 20);
      if (de === 20) {
        if (res && token !== undefined) token.set(cof_states[etat], false);
        return false;
      } else if (de === 12) {
        if (!res && token !== undefined) token.set(cof_states[etat], true);
        return true;
      }
    }
    let attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: etat
    });
    if (attr.length === 0) {
      if (res && token !== undefined) token.set(cof_states[etat], false);
      return false;
    }
    if (!res && token !== undefined) token.set(cof_states[etat], true);
    return true;
  }

  //Met le champ field \xE0 value du token dans evt, pour permettre le undo
  //Retourne evt.affectes[token.id]
  function affectToken(token, field, value, evt) {
    evt.affectes = evt.affectes || {};
    let aff = evt.affectes[token.id];
    if (aff === undefined) {
      aff = {
        affecte: token,
        prev: {}
      };
      evt.affectes[token.id] = aff;
    }
    if (aff.prev[field] === undefined) aff.prev[field] = value;
    return aff;
  }

  function estAffaibli(perso) {
    if (perso.affaibli !== undefined) return perso.affaibli;
    if (getState(perso, 'affaibli') || getState(perso, 'blesse') ||
      attributeAsBool(perso, 'poisonAffaiblissant') ||
      attributeAsBool(perso, 'poisonAffaiblissantLong')) {
      perso.affaibli = true;
      return true;
    }
    perso.affaibli = false;
    return false;
  }

  function setToken(token, field, newValue, evt) {
    let prevValue = token.get(field);
    affectToken(token, field, prevValue, evt);
    token.set(field, newValue);
  }

  function isActive(perso) {
    let inactif =
      getState(perso, 'mort') || getState(perso, 'surpris') ||
      getState(perso, 'assomme') || getState(perso, 'etourdi') ||
      getState(perso, 'paralyse') || getState(perso, 'endormi') ||
      getState(perso, 'apeure') || attributeAsBool(perso, 'statueDeBois') ||
      attributeAsBool(perso, 'souffleDeMort');
    return !inactif;
  }

  function sendChar(charId, msg, checkAlias) {
    let dest = '';
    if (charId) {
      if (checkAlias) {
        let attrDisplay = charAttribute(charId, 'displayname', {
          caseInsensitive: true
        });
        if (attrDisplay.length > 0 && attrDisplay[0].get('current') == '@{alias}') {
          let attrAlias = charAttribute(charId, 'alias', {
            caseInsensitive: true
          });
          if (attrAlias.length > 0) {
            msg = attrAlias[0].get('current') + ' ' + msg;
          } else {
            dest = 'character|' + charId;
          }
        } else {
          dest = 'character|' + charId;
        }
      } else {
        dest = 'character|' + charId;
      }
    }
    sendChat(dest, msg);
  }

  //Chuchote le message \xE0 tous les joueurs pr\xE9sents qui controllent le
  //personnage, plus le MJ
  function whisperChar(charId, msg) {
    let character = getObj('character', charId);
    if (character) {
      let controlled = character.get('controlledby');
      if (controlled.includes('all')) sendChar(charId, msg);
      else {
        controlled.split(',').forEach(function(c) {
          if (c !== '' && !playerIsGM(c)) {
            let p = getObj('player', c);
            if (p && p.get('online')) {
              sendChar(charId, '/w "' + p.get('_displayname') + '" ' + msg);
            }
          }
        });
        sendChar(charId, "/w GM " + msg);
      }
    } else {
      sendChar(charId, "/w GM " + msg);
    }
  }

  function nomPerso(perso) {
    if (perso.tokName) return perso.tokName;
    if (perso.token) {
      perso.tokName = perso.token.get('name');
      return perso.tokName;
    }
    if (perso.alias === undefined) {
      perso.alias =
        ficheAttribute(perso, 'displayname', '@{character_name}') == '@{alias}';
    }
    if (perso.alias) perso.tokName = ficheAttribute(perso, 'alias', 'inconnu');
    else perso.tokName = ficheAttribute(perso, 'character_name', 'inconnu');
    return perso.tokName;
  }

  function sendPerso(perso, msg, secret) {
    if (perso.token && perso.token.get('bar1_link') === '') {
      msg = perso.token.get('name') + ' ' + msg;
      if (secret) {
        let character = getObj('character', perso.charId);
        if (character) {
          let controlled = character.get('controlledby');
          if (controlled.includes('all')) sendChat('', msg);
          else {
            controlled.split(',').forEach(function(c) {
              if (c !== '' && !playerIsGM(c)) {
                let p = getObj('player', c);
                if (p && p.get('online')) {
                  sendChat('', '/w "' + p.get('_displayname') + '" ' + msg);
                }
              }
            });
            sendChat('', "/w GM " + msg);
          }
        } else sendChat('', msg);
      } else sendChat('', msg);
    } else {
      if (secret) whisperChar(perso.charId, msg);
      else {
        if (perso.alias === undefined) {
          perso.alias =
            ficheAttribute(perso, 'displayname', '@{character_name}') == '@{alias}';
        }
        if (perso.alias) sendChat('', nomPerso(perso) + ' ' + msg);
        else sendChar(perso.charId, msg);
      }
    }
  }

  const couleurType = {
    'normal': {
      background: '#F1E6DA',
      color: '#000'
    },
    'magique': {
      background: '#FFFFFF',
      color: '#534200'
    },
    'maladie': { //Pour l'instant, comme normal
      background: '#F1E6DA',
      color: '#000'
    },
    'feu': {
      background: '#FF3011',
      color: '#440000'
    },
    'froid': {
      background: '#77FFFF',
      color: '#004444'
    },
    'acide': {
      background: '#80BF40',
      color: '#020401'
    },
    'sonique': {
      background: '#E6CCFF',
      color: '#001144'
    },
    'electrique': {
      background: '#FFFF80',
      color: '#222200'
    },
    'poison': {
      background: '#5A752F',
      color: '#DDDDAA'
    },
    'argent': {
      background: '#F1E6DA',
      color: '#C0C0C0'
    },
    'drain': {
      background: '#0D1201',
      color: '#E8F5C9'
    },
    'energie': {
      background: '#FFEEAA',
      color: '#221100'
    },
  };

  // options: bonus:int, deExplosif:bool, nbDes:int, type, maxResult
  //      resultatDesSeuls (rempli par la fonction si true)
  //Renvoie 1dk + bonus, avec le texte
  //champs val et roll
  //de peut \xEAtre un nombre > 0 ou bien le r\xE9sultat de parseDice
  function rollDePlus(de, options) {
    options = options || {};
    options.nbDes = options.nbDes || 1;
    if (de.dice !== undefined) {
      if (!de.nbDe) {
        return {
          val: de.bonus,
          roll: '' + de.bonus
        };
      }
      options.nbDes = options.nbDes || de.nbDe;
      options.bonus = options.bonus || de.bonus;
      de = de.dice;
    }
    let count = options.nbDes;
    let bonus = options.bonus || 0;
    let explose = options.deExplosif || false;
    let texteJetDeTotal = '';
    let jetTotal = 0;
    do {
      let jetDe = randomInteger(de);
      if (options.maxResult) jetDe = de;
      texteJetDeTotal += jetDe;
      jetTotal += jetDe;
      explose = explose && (jetDe === de);
      if (explose) {
        texteJetDeTotal += ',';
      } else {
        count--;
        if (count > 0) {
          texteJetDeTotal += ',';
        }
      }
    } while ((explose || count > 0) && jetTotal < 1000);
    if (options.resultatDesSeuls) options.resultatDesSeuls = jetTotal;
    let res = {
      val: jetTotal + bonus
    };
    let style = 'display: inline-block; border-radius: 5px; padding: 0 4px;';
    let type = options.type || 'normal';
    let couleurs = couleurType[type];
    if (couleurs === undefined) couleurs = couleurType.normal;
    style += ' background-color: ' + couleurs.background + ';';
    style += ' color: ' + couleurs.color + ';';
    let msg = '<span style="' + style + '"';
    msg += ' title="' + options.nbDes + 'd' + de;
    if (options.deExplosif) msg += '!';
    if (bonus > 0) {
      msg += '+' + bonus;
      texteJetDeTotal += '+' + bonus;
    } else if (bonus < 0) {
      msg += bonus;
      texteJetDeTotal += bonus;
    }
    msg += ' = ' + texteJetDeTotal + '" class="a inlinerollresult showtip tipsy-n">';
    msg += res.val + "</span>";
    res.roll = msg;
    return res;
  }

  //Si evt est d\xE9fini, alors on consid\xE8re qu'il faut y mettre la valeur actuelle
  function updateCurrentBar(perso, barNumber, val, evt, maxVal) {
    let token = perso.token;
    let prevToken;
    let HTdeclared;
    try {
      HTdeclared = HealthColors;
    } catch (e) {
      if (e.name != "ReferenceError") throw (e);
    }
    if (HTdeclared) {
      //Pour pouvoir annuler les effets de HealthColor sur le statut
      affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
      prevToken = JSON.parse(JSON.stringify(token));
    }
    let fieldv = 'bar' + barNumber + '_value';
    let fieldm;
    if (maxVal) fieldm = 'bar' + barNumber + '_max';
    let attrId = token.get('bar' + barNumber + '_link');
    let attr;
    if (attrId !== '') attr = getObj('attribute', attrId);
    if (attr === undefined) {
      let prevVal = token.get(fieldv);
      if (evt) affectToken(token, fieldv, prevVal, evt);
      token.set(fieldv, val);
      if (maxVal) {
        if (evt) affectToken(token, fieldm, token.get(fieldm), evt);
        token.set(fieldm, val);
      }
      if (HTdeclared) HealthColors.Update(token, prevToken);
      return;
    }
    if (evt) {
      evt.attributes = evt.attributes || [];
      evt.attributes.push({
        attribute: attr,
        current: attr.get('current'),
        max: attr.get('max'),
      });
    }
    let aset = {
      current: val,
      withWorker: true
    };
    if (maxVal) aset.max = maxVal;
    attr.setWithWorker(aset);
    if (HTdeclared) HealthColors.Update(token, prevToken);
    //Gestion du lien des PVs entre familier et son ma\xEEtre
    if (barNumber == 1) {
      let nomPersoLie = predicateAsBool(perso, 'PVPartagesAvec');
      if (nomPersoLie) {
        let charLie = findObjs({
          _type: 'character',
          name: nomPersoLie
        });
        if (charLie.length > 0) {
          let attrLie = charAttribute(charLie[0].id, 'pv', {
            caseInsensitive: true
          });
          if (attrLie.length > 0) {
            attrLie = attrLie[0];
            if (evt) {
              evt.attributes.push({
                attribute: attrLie,
                current: attrLie.get('current'),
                max: attrLie.get('max')
              });
            }
            attrLie.setWithWorker(aset);
            if (val < 1 && evt) { //Il faut aussi faire mourir l'autre perso
              let pageId = token.get('pageid');
              let charIdLie = charLie[0].id;
              let tokensLies = findObjs({
                _type: 'graphic',
                _subtype: 'token',
                _pageid: pageId,
                represents: charIdLie
              });
              if (tokensLies.length === 0) {
                tokensLies = findObjs({
                  _type: 'graphic',
                  _subtype: 'token',
                  represents: charIdLie
                });
              }
              if (tokensLies.length > 0) {
                let persoLie = {
                  charId: charIdLie,
                  token: tokensLies[0]
                };
                mort(persoLie, undefined, evt);
              }
            }
          }
        }
      }
    }
  }

  function getValeurOfEffet(perso, effet, def, predDef) {
    let attrsVal = tokenAttribute(perso, effet + 'Valeur');
    if (attrsVal.length === 0) {
      if (predDef) return predicateAsInt(perso, predDef, def);
      return def;
    }
    return toInt(attrsVal[0].get('current'), def);
  }

  function getTokenFields(token, pageId, charId) {
    return {
      _pageid: pageId || token.get('pageid'),
      imgsrc: token.get('imgsrc'),
      represents: charId || token.get('represents'),
      left: token.get('left'),
      top: token.get('top'),
      width: token.get('width'),
      height: token.get('height'),
      rotation: token.get('rotation'),
      layer: token.get('layer'),
      flipv: token.get('flipv'),
      fliph: token.get('fliph'),
      name: token.get('name'),
      tooltip: token.get('tooltip'),
      show_tooltip: token.get('show_tooltip'),
      controlledby: token.get('controlledby'),
      bar1_link: token.get('bar1_link'),
      bar2_link: token.get('bar2_link'),
      bar3_link: token.get('bar3_link'),
      bar1_value: token.get('bar1_value'),
      bar2_value: token.get('bar2_value'),
      bar3_value: token.get('bar3_value'),
      bar1_max: token.get('bar1_max'),
      bar2_max: token.get('bar2_max'),
      bar3_max: token.get('bar3_max'),
      bar_location: token.get('bar_location'),
      compact_bar: token.get('compact_bar'),
      aura1_radius: token.get('aura1_radius'),
      aura2_radius: token.get('aura2_radius'),
      aura1_color: token.get('aura1_color'),
      aura2_color: token.get('aura2_color'),
      aura1_square: token.get('aura1_square'),
      aura2_square: token.get('aura2_square'),
      tint_color: token.get('tint_color'),
      statusmarkers: token.get('statusmarkers'),
      showname: token.get('showname'),
      showplayers_name: token.get('showplayers_name'),
      showplayers_bar1: token.get('showplayers_bar1'),
      showplayers_bar2: token.get('showplayers_bar2'),
      showplayers_bar3: token.get('showplayers_bar3'),
      showplayers_aura1: token.get('showplayers_aura1'),
      showplayers_aura2: token.get('showplayers_aura2'),
      playersedit_name: token.get('playersedit_name'),
      playersedit_bar1: token.get('playersedit_bar1'),
      playersedit_bar2: token.get('playersedit_bar2'),
      playersedit_bar3: token.get('playersedit_bar3'),
      playersedit_aura1: token.get('playersedit_aura1'),
      playersedit_aura2: token.get('playersedit_aura2'),
      lastmove: token.get('lastmove'),
      sides: token.get('sides'),
      currentSide: token.get('currentSide'),
      lockMovement: token.get('lockMovement'),
      /* Dynamic Lighting */
      has_bright_light_vision: token.get('has_bright_light_vision'),
      has_night_vision: token.get('has_night_vision'),
      night_vision_distance: token.get('night_vision_distance'),
      emits_bright_light: token.get('emits_bright_light'),
      bright_light_distance: token.get('bright_light_distance'),
      emits_low_light: token.get('emits_low_light'),
      low_light_distance: token.get('low_light_distance'),
      light_sensitivity_multiplier: token.get('light_sensitivity_multiplier'),
      night_vision_effect: token.get('night_vision_effect'),
      has_limit_field_of_vision: token.get('has_limit_field_of_vision'),
      limit_field_of_vision_center: token.get('limit_field_of_vision_center'),
      limit_field_of_vision_total: token.get('limit_field_of_vision_total'),
      has_limit_field_of_night_vision: token.get('has_limit_field_of_night_vision'),
      limit_field_of_night_vision_center: token.get('limit_field_of_night_vision_center'),
      limit_field_of_night_vision_total: token.get('limit_field_of_night_vision_total'),
      has_directional_bright_light: token.get('has_directional_bright_light'),
      directional_bright_light_center: token.get('directional_bright_light_center'),
      directional_bright_light_total: token.get('directional_bright_light_total'),
      has_directional_dim_light: token.get('has_directional_dim_light'),
      directional_dim_light_center: token.get('directional_dim_light_center'),
      directional_dim_light_total: token.get('directional_dim_light_total'),
      light_color: token.get('light_color'),
      /* Legacy Dynamic Lighting */
      light_radius: token.get('light_radius'),
      light_dimradius: token.get('light_dimradius'),
      light_otherplayers: token.get('light_otherplayers'),
      light_hassight: token.get('light_hassight'),
      light_angle: token.get('light_angle'),
      light_losangle: token.get('light_losangle'),
      light_multiplier: token.get('light_multiplier'),
      adv_fow_view_distance: token.get('adv_fow_view_distance'),
    };
  }

  function caracOfMod(m, accent) {
    switch (m) {
      case 'FOR':
        return 'force';
      case 'DEX':
        if (accent) return 'dext\xE9rit\xE9';
        return 'dexterite';
      case 'CON':
        return 'constitution';
      case 'INT':
        return 'intelligence';
      case 'SAG':
        return 'sagesse';
      case 'CHA':
        return 'charisme';
      default:
        return;
    }
  }

  function PNJCaracOfMod(m) {
    return 'pnj_' + m.toLowerCase();
  }

  //Retourne le mod de la caract\xE9ristque enti\xE8re.
  //si carac n'est pas une carac, retourne 0
  //perso peut ne pas avoir de token ou \xEAtre juste un charId
  function modCarac(perso, carac) {
    if (perso.charId === undefined) perso = {
      charId: perso
    };
    let mod = 0;
    if (persoEstPNJ(perso)) {
      switch (carac) {
        case 'force':
        case 'FORCE':
          mod = ficheAttributeAsInt(perso, 'pnj_for', 0);
          break;
        case 'dexterite':
        case 'DEXTERITE':
          mod = ficheAttributeAsInt(perso, 'pnj_dex', 0);
          break;
        case 'constitution':
        case 'CONSTITUTION':
          mod = ficheAttributeAsInt(perso, 'pnj_con', 0);
          break;
        case 'intelligence':
        case 'INTELLIGENCE':
          mod = ficheAttributeAsInt(perso, 'pnj_int', 0);
          break;
        case 'sagesse':
        case 'SAGESSE':
          mod = ficheAttributeAsInt(perso, 'pnj_sag', 0);
          break;
        case 'charisme':
        case 'CHARISME':
          mod = ficheAttributeAsInt(perso, 'pnj_cha', 0);
          break;
        default:
          return 0;
      }
      mod -= Math.floor(attributeAsInt(perso, 'affaiblissementde' + carac, 0) / 2);
    } else {
      // On a une fiche de PJ
      let valCarac =
        ficheAttributeAsInt(perso, carac, 10) - attributeAsInt(perso, 'affaiblissementde' + carac, 0);
      mod = Math.floor((valCarac - 10) / 2);
    }
    if (carac == 'force' || carac == 'FORCE') {
      if (attributeAsBool(perso, 'mutationMusclesHypertrophies')) mod += 2;
      if (attributeAsBool(perso, 'grandeTaille')) mod += 2;
    } else if ((carac == 'DEXTERITE' || carac == 'dexterite') && attributeAsBool(perso, 'mutationSilhouetteFiliforme')) mod += 4;
    return mod;
  }

  //Renvoie stateCOF.combat, garanti non false
  function initPerso(personnage, evt, recompute) {
    return initiative([{
      _id: personnage.token.id
    }], evt, recompute);
  }

  //options peut contenir
  // msg: un message \xE0 afficher
  // maxVal: la valeur max de l'attribut
  // secret: le message n'est pas affich\xE9 pour tout le monde.
  // charAttr: si pr\xE9sent, on utilise un attribut de personnage
  // renvoie l'attribut cr\xE9\xE9 ou mis \xE0 jour
  function setTokenAttr(personnage, attribute, value, evt, options) {
    let charId = personnage.charId;
    let token = personnage.token;
    let maxval = '';
    if (options && options.maxVal !== undefined) maxval = options.maxVal;
    if (options && options.msg !== undefined) {
      sendPerso(personnage, options.msg, options.secret);
    }
    evt.attributes = evt.attributes || [];
    let fullAttribute = fullAttributeName(personnage, attribute, options);
    if (!fullAttribute) {
      let args = {
        personnage,
        attribute,
        value,
        options
      };
      let name = 'inconnu';
      if (token) name = token.get('name');
      error("Cr\xE9ation d'un attribut undefined pour " + name, args);
      return;
    }
    let attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: fullAttribute
    });
    if (attr.length === 0) {
      attr = createObj('attribute', {
        characterid: charId,
        name: fullAttribute,
        current: value,
        max: maxval
      });
      evt.attributes.push({
        attribute: attr,
      });
      if (token) {
        let pageId = token.get('pageid');
        switch (attribute) {
          case 'agrandissement':
            personnage.taille = undefined;
            let arme = armesEnMain(personnage);
            if (arme.armeDeGrand) {
              let taille = taillePersonnage(personnage, 4);
              if (taille == 5) {
                arme.deuxMains = false;
                sendPerso(personnage, "peut maintenant tenir " + arme.name + " \xE0 une main");
                degainerArme(personnage, arme.label, evt);
              }
            }
            let width = token.get('width');
            let height = token.get('height');
            affectToken(token, 'width', width, evt);
            affectToken(token, 'height', height, evt);
            width += width / 2;
            height += height / 2;
            token.set('width', width);
            token.set('height', height);
            break;
          case 'formeDArbre':
            //On copie les PVs pour pouvoir les restaurer \xE0 la fin de l'effet
            setTokenAttr(personnage, 'anciensPV', token.get('bar1_value'), evt, {
              maxVal: token.get('bar1_max')
            });
            //On va cr\xE9er une copie de token, mais avec une image d'arbre
            let tokenFields = getTokenFields(token, pageId, personnage.charId);
            let tokenArbre;
            let imageArbre = predicateAsBool(personnage, 'tokenFormeDArbre');
            if (imageArbre) {
              tokenFields.imgsrc = imageArbre;
              tokenArbre = createObj('graphic', tokenFields);
            }
            if (tokenArbre === undefined) {
              tokenFields.imgsrc = stateCOF.options.images.val.image_arbre.val;
              tokenArbre = createObj('graphic', tokenFields);
            }
            if (tokenArbre) {
              evt.tokens = evt.tokens || [];
              evt.tokens.push(tokenArbre);
              //On met l'ancien token dans le gmlayer, car si l'image vient du marketplace, il est impossible de le recr\xE9er depuis l'API
              setToken(token, 'layer', 'gmlayer', evt);
              setTokenAttr(personnage, 'changementDeToken', true, evt);
              replaceInTurnTracker(token.id, tokenArbre.id, evt);
              personnage.token = tokenArbre;
              token = tokenArbre;
            }
            //On met maintenant les nouveaux PVs
            //selon Kegron http://www.black-book-editions.fr/forums.php?topic_id=4800&tid=245841#msg245841
            let niveau = ficheAttributeAsInt(personnage, 'niveau', 1);
            let nouveauxPVs = getValeurOfEffet(personnage, 'formeDArbre', niveau * 5);
            updateCurrentBar(personnage, 1, nouveauxPVs, evt, nouveauxPVs);
            //L'initiative change
            initPerso(personnage, evt, true);
            break;
          case 'bloqueManoeuvre':
          case 'enveloppePar':
          case 'prisonVegetale':
          case 'toiles':
          case 'statueDeBois':
          case 'estGobePar':
          case 'agrippeParUnDemon':
          case 'etreinteScorpionPar':
          case 'estEcrasePar':
            nePlusSuivre(personnage, pageId, evt);
            lockToken(personnage, evt);
            break;
          case 'armeeDesMorts':
            affectToken(personnage.token, "aura2_radius", personnage.token.get("aura2_radius"), evt);
            affectToken(personnage.token, "aura2_color", personnage.token.get("aura2_color"), evt);
            affectToken(personnage.token, "showplayers_aura2", personnage.token.get("showplayers_aura2"), evt);
            personnage.token.set("aura2_radius", 20);
            personnage.token.set("aura2_color", "#b6d7a8");
            personnage.token.set("showplayers_aura2", true);
            break;
          case 'armeeDesMortsPuissant':
            personnage.token.set("aura2_radius", 28);
            break;
          case 'armeeDesMortsTempeteDeManaIntense':
            personnage.token.set("aura2_radius", Math.floor(20 * Math.sqrt(1 + value)));
            break;
          case 'masqueDuPredateur':
            {
              //L'initiative change
              initPerso(personnage, evt, true);
              let lie = personnageAmeLiee(personnage);
              if (lie) {
                setTokenAttr(lie, 'masqueDuPredateurAmeLiee', value, evt, {
                  maxVal: options.maxVal
                });
                let valeur = getValeurOfEffet(personnage, 'masqueDuPredateur', modCarac(personnage, 'sagesse'));
                valeur = Math.floor(valeur / 2);
                if (valeur > 1)
                  setTokenAttr(lie, 'masqueDuPredateurAmeLieeValeur', valeur, evt);
                initPerso(lie, evt, true);
              }
            }
            break;
          case 'masqueMortuaire':
            {
              let lie = personnageAmeLiee(personnage);
              if (lie) {
                setTokenAttr(lie, 'masqueMortuaireAmeLiee', value, evt, {
                  maxVal: options.maxVal
                });
              }
            }
            break;
          case 'peauDEcorce':
            {
              let lie = personnageAmeLiee(personnage);
              if (lie) {
                setTokenAttr(lie, 'peauDEcorceAmeLiee', value, evt, {
                  maxVal: options.maxVal
                });
                let valeur = getValeurOfEffet(personnage, 'peauDEcorce', 1, 'voieDesVegetaux');
                valeur = Math.floor(valeur / 2);
                if (valeur > 1)
                  setTokenAttr(lie, 'peauDEcorceAmeLieeValeur', valeur, evt);
              }
            }
            break;
        }
      }
      return attr;
    }
    attr = attr[0];
    evt.attributes.push({
      attribute: attr,
      current: attr.get('current'),
      max: attr.get('max')
    });
    attr.set('current', value);
    if (options && options.maxVal !== undefined) attr.set('max', maxval);
    return attr;
  }

  // evt peut \xEAtre undefined
  // options peut avoir les champs msg et secret
  function removeTokenAttr(personnage, attribute, evt, options) {
    attribute = fullAttributeName(personnage, attribute, options);
    let attr = findObjs({
      _type: 'attribute',
      _characterid: personnage.charId,
      name: attribute
    });
    if (attr.length === 0) return;
    if (options && options.msg !== undefined) {
      sendPerso(personnage, options.msg, options.secret);
    }
    attr = attr[0];
    if (evt) {
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attr);
    }
    attr.remove();
    switch (attribute) {
      case 'enveloppePar':
      case 'agrippeParUnDemon':
      case 'etreinteScorpionPar':
      case 'estGobePar':
      case 'estEcrasePar':
        unlockToken(personnage, evt);
    }
  }

  function removeCharAttr(charId, attribute, evt, msg) {
    removeTokenAttr({
      charId: charId
    }, attribute, evt, {
      msg: msg
    });
  }

  //cherche l'attribut attribute de valeur par d\xE9faut def
  //et lui ajoute la valeur val. Cr\xE9e l'attribut si besoin
  //retourne la nouvelle valeur de l'attribut
  function addToAttributeAsInt(perso, attribute, def, val, evt) {
    evt.attributes = evt.attributes || [];
    let fullAttribute = fullAttributeName(perso, attribute);
    let attr = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
      name: fullAttribute
    });
    if (attr.length === 0) {
      attr = createObj('attribute', {
        characterid: perso.charId,
        name: fullAttribute,
        current: def + val,
      });
      evt.attributes.push({
        attribute: attr,
      });
      return def + val;
    }
    attr = attr[0];
    let c = parseInt(attr.get('current'));
    evt.attributes.push({
      attribute: attr,
      current: c
    });
    if (isNaN(c)) c = def;
    c += val;
    attr.set('current', c);
    return c;
  }

  function persoOfToken(token) {
    let charId = token.get('represents');
    if (charId === '') {
      return undefined;
    }
    return {
      token,
      charId
    };
  }

  //options:
  //fromTemp si on est en train de supprimer un effet temporaire
  //affectToken si on a d\xE9j\xE0 chang\xE9 le statusmarkers (on vient donc d'un changement \xE0 la main d'un marker
  function setState(personnage, etat, value, evt, options) {
    let token = personnage.token;
    if (value && predicateAsBool(personnage, 'immunite_' + etat)) {
      sendPerso(personnage, 'ne peut pas \xEAtre ' + stringOfEtat(etat, personnage));
      return false;
    }
    options = options || {};
    let aff = options.affectToken ||
      affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
    if (stateCOF.combat && value && etatRendInactif(etat) &&
      (options.affectToken || isActive(personnage)) &&
      (etat != 'surpris' || !compagnonPresent(personnage, 'surveillance'))
    ) {
      removeFromTurnTracker(personnage, evt);
    }
    if (!options.affectToken) token.set(cof_states[etat], value);
    if (token.get('bar1_link') !== '') {
      let charId = personnage.charId;
      if (charId === '') {
        error("token with a linked bar1 but representing no character", token);
        return true;
      }
      if (etat == 'affaibli') { //special case due to new character sheet
        let v = 20;
        if (value) v = 12;
        setFicheAttr(personnage, 'ETATDE', v, evt, {
          default: 20
        });
      } else {
        let attrEtat =
          findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: etat
          });
        if (value) {
          if (attrEtat.length === 0) {
            attrEtat =
              createObj('attribute', {
                characterid: charId,
                name: etat,
                current: value
              });
            evt.attributes = evt.attributes || [];
            evt.attributes.push({
              attribute: attrEtat,
            });
          }
        } else {
          if (attrEtat.length > 0) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(attrEtat[0]);
            attrEtat[0].remove();
          }
        }
      }
    }
    if (!value) { //On enl\xE8ve le save si il y en a un
      removeTokenAttr(personnage, etat + 'Save', evt);
      removeTokenAttr(personnage, etat + 'SaveParTour', evt);
    }
    let pageId = token.get('pageid');
    if (etat == 'aveugle') {
      // On change la vision du token
      let page = getObj('page', pageId);
      let udl = page && page.get('dynamic_lighting_enabled');
      if (udl) {
        if (aff.prev.has_limit_field_of_vision === undefined)
          aff.prev.has_limit_field_of_vision = token.get('has_limit_field_of_vision');
        if (aff.prev.has_limit_field_of_night_vision === undefined)
          aff.prev.has_limit_field_of_night_vision = token.get('has_limit_field_of_night_vision');
      } else {
        if (aff.prev.light_losangle === undefined)
          aff.prev.light_losangle = token.get('light_losangle');
      }
      if (value) {
        if (udl) {
          token.set('has_limit_field_of_vision', true);
          token.set('has_limit_field_of_night_vision', true);
        } else {
          token.set('light_losangle', 0);
        }
        //Normalement, ne peut plus suivre personne ?
        //Si il peut parce qu'il touche ou tient une corde, r\xE9utiliser la macro
        //pour suivre
        nePlusSuivre(personnage, pageId, evt);
      } else {
        if (!(options.fromTemp))
          removeTokenAttr(personnage, 'aveugleTemp', evt);
        if (udl) {
          token.set('has_limit_field_of_vision', false);
          token.set('has_limit_field_of_night_vision', false);
        } else {
          token.set('light_losangle', 360);
        }
      }
    } else if (etat == 'invisible') {
      let attrInvisible = tokenAttribute(personnage, 'tokenInvisible');
      if (value) {
        if (attrInvisible.length === 0) {
          //On va cr\xE9er une copie de token, mais avec une image invisible et aura visible seulement de ceux qui contr\xF4lent le token
          let tokenFields = getTokenFields(token, pageId, personnage.charId);
          tokenFields.layer = 'objects';
          tokenFields.aura1_radius = 0;
          tokenFields.aura1_color = "#FF9900";
          tokenFields.aura1_square = false;
          tokenFields.showplayers_aura1 = false;
          tokenFields.statusmarkers = '';
          tokenFields.showplayers_name = false;
          tokenFields.showplayers_bar1 = false;
          tokenFields.showplayers_bar2 = false;
          tokenFields.showplayers_bar3 = false;
          tokenFields.imgsrc = IMG_INVISIBLE;
          let tokenInvisible = createObj('graphic', tokenFields);
          if (tokenInvisible) {
            if (tokenFields.has_bright_light_vision)
              tokenInvisible.set('has_bright_light_vision', true);
            evt.tokens = evt.tokens || [];
            evt.tokens.push(tokenInvisible);
            //On met l'ancien token dans le gmlayer, car si l'image vient du marketplace, il est impossible de le recr\xE9er depuis l'API
            setToken(token, 'layer', 'gmlayer', evt);
            setTokenAttr(personnage, 'tokenInvisible', token.id, evt, {
              maxVal: tokenInvisible.id
            });
            let combat = stateCOF.combat;
            if (stateCOF.options.affichage.val.init_dynamique.val &&
              roundMarker && combat && (
                (!stateCOF.chargeFantastique && combat.activeTokenId == token.id) ||
                (stateCOF.chargeFantastique && stateCOF.chargeFantastique.activeTokenId == token.id))) {
              setToken(roundMarker, 'layer', 'gmlayer', evt);
            }
          }
        }
      } else { //On enl\xE8ve l'\xE9tat invisible
        if (attrInvisible.length > 0) {
          let tokenOriginel = getObj('graphic', attrInvisible[0].get('current'));
          if (!tokenOriginel) {
            if (token.get('layer') == 'gmlayer') tokenOriginel = token;
            else {
              tokenOriginel =
                findObjs({
                  _type: 'graphic',
                  _subtype: 'token',
                  _pageid: token.get('pageid'),
                  layer: 'gmlayer',
                  represents: personnage.charId,
                  name: token.get('name')
                });
              if (tokenOriginel.length > 0) tokenOriginel = tokenOriginel[0];
              else {
                error("Impossible de retrouver le token de d\xE9part de " + token.get('name') + " quand on enl\xE8ve l'\xE9tat invisible", attrInvisible);
                tokenOriginel = false;
              }
            }
          }
          let tokenCourant = getObj('graphic', attrInvisible[0].get('max'));
          if (!tokenCourant) {
            if (token.get('layer') == 'objects') tokenCourant = token;
            else {
              tokenCourant =
                findObjs({
                  _type: 'graphic',
                  _subtype: 'token',
                  _pageid: token.get('pageid'),
                  layer: 'objects',
                  represents: personnage.charId,
                  name: token.get('name')
                });
              if (tokenCourant.length > 0) tokenCourant = tokenCourant[0];
              else {
                error("Impossible de retrouver le token visible de " + token.get('name') + " quand on enl\xE8ve l'\xE9tat invisible", attrInvisible);
                tokenCourant = false;
              }
            }
          }
          removeTokenAttr(personnage, 'tokenInvisible', evt);
          if (!options.fromTemp) {
            removeTokenAttr(personnage, 'invisibleTemp', evt);
          }
          if (tokenOriginel) {
            setToken(tokenOriginel, 'layer', 'objects', evt);
            if (tokenCourant) {
              setToken(tokenOriginel, 'left', tokenCourant.get('left'), evt);
              setToken(tokenOriginel, 'top', tokenCourant.get('top'), evt);
              setToken(tokenOriginel, 'width', tokenCourant.get('width'), evt);
              setToken(tokenOriginel, 'height', tokenCourant.get('height'), evt);
              setToken(tokenOriginel, 'rotation', tokenCourant.get('rotation'), evt);
              setToken(tokenOriginel, 'flipv', tokenCourant.get('flipv'), evt);
              setToken(tokenOriginel, 'fliph', tokenCourant.get('fliph'), evt);
              if (tokenCourant.get('bar1_link') === '') {
                setToken(tokenOriginel, 'bar1_value', tokenCourant.get('bar1_value'), evt);
              }
              setToken(tokenOriginel, 'bar2_value', tokenCourant.get('bar2_value'), evt);
              setToken(tokenOriginel, 'aura2_radius', tokenCourant.get('aura2_radius'), evt);
              setToken(tokenOriginel, 'aura2_color', tokenCourant.get('aura2_color'), evt);
              setToken(tokenOriginel, 'aura2_square', tokenCourant.get('aura2_square'), evt);
              setToken(tokenOriginel, 'showplayers_aura2', tokenCourant.get('showplayers_aura2'), evt);
              setToken(tokenOriginel, 'statusmarkers', tokenCourant.get('statusmarkers'), evt);
              setToken(tokenOriginel, 'light_angle', tokenCourant.get('light_angle'), evt);
              setToken(tokenOriginel, 'has_limit_field_of_vision', tokenCourant.get('has_limit_field_of_vision'), evt);
              setToken(tokenOriginel, 'has_limit_field_of_night_vision', tokenCourant.get('has_limit_field_of_night_vision'), evt);
            }
          }
          if (tokenCourant) deleteTokenWithUndo(tokenCourant, evt);
        }
      }
    } else if (value) {
      switch (etat) {
        case 'mort':
          //On s'assure de mettre les PV de la cible \xE0 0 (pour les insta kills sans dommages)
          if (token.get('bar1_value') > 0) updateCurrentBar(personnage, 1, 0, evt);
          nePlusSuivre(personnage, pageId, evt);
          lockToken(personnage, evt);
          if (stateCOF.combat)
            setTokenAttr(personnage, 'a0PVDepuis', stateCOF.combat.tour, evt, {
              maxVal: stateCOF.combat.init
            });
          let persoMonte = tokenAttribute(personnage, 'estMontePar');
          if (persoMonte.length > 0) {
            const cavalier = persoOfIdName(persoMonte[0].get('current'), pageId);
            if (cavalier !== undefined) {
              removeTokenAttr(cavalier, 'monteSur', evt);
            }
            removeTokenAttr(personnage, 'estMontePar', evt);
            removeTokenAttr(personnage, 'positionSurMonture', evt);
          }
          //On lib\xE8re les personnages envelopp\xE9s, si il y en a.
          let attrEnveloppe = tokenAttribute(personnage, 'enveloppe');
          attrEnveloppe.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              let envDM = a.get('max');
              if (envDM.startsWith('etreinte')) {
                //On a une \xE9treinte, on enl\xE8ve donc l'\xE9tat immobilis\xE9
                setState(cible, 'immobilise', false, evt);
              }
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'enveloppePar');
              attrCible.forEach(function(a) {
                let cube = persoOfIdName(a.get('current', pageId));
                if (cube === undefined) {
                  evt.deletedAttributes.push(a);
                  a.remove();
                } else if (cube.token.id == personnage.token.id) {
                  sendPerso(cible, 'se lib\xE8re de ' + cube.tokName);
                  toFront(cible.token);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
                unlockToken(cible, evt);
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //Si le mort est envelopp\xE9, il est relach\xE9
          attrEnveloppe = tokenAttribute(personnage, 'enveloppePar');
          attrEnveloppe.forEach(function(a) {
            let cube = persoOfIdName(a.get('current'), pageId);
            if (cube) {
              let envDiff = a.get('max');
              if (envDiff.startsWith('etreinte')) {
                //On a une \xE9treinte, on enl\xE8ve donc l'\xE9tat immobilis\xE9
                setState(personnage, 'immobilise', false, evt);
              }
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCube = tokenAttribute(cube, 'enveloppe');
              attrCube.forEach(function(a) {
                let cible = persoOfIdName(a.get('current', pageId));
                if (cible === undefined) {
                  evt.deletedAttributes.push(a);
                  a.remove();
                } else if (cible.token.id == personnage.token.id) {
                  sendPerso(cube, 'relache ' + nomPerso(personnage));
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On lib\xE8re les personnages agripp\xE9s, si il y en a.
          let attrAgrippe = tokenAttribute(personnage, 'agrippe');
          attrAgrippe.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'estAgrippePar');
              attrCible.forEach(function(a) {
                let agrippant = persoOfIdName(a.get('current', pageId));
                if (agrippant.token.id == personnage.token.id) {
                  sendPerso(cible, 'se lib\xE8re de ' + agrippant.tokName);
                  toFront(cible.token);
                  if (a.get('max')) setState(cible, 'immobilise', false, evt);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
              removeTokenAttr(cible, 'agrippeParUnDemon', evt);
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On lib\xE8re les personnages d\xE9vor\xE9s, si il y en a.
          let attrDevore = tokenAttribute(personnage, 'devore');
          attrDevore.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'estDevorePar');
              attrCible.forEach(function(a) {
                let agrippant = persoOfIdName(a.get('current', pageId));
                if (agrippant.token.id == personnage.token.id) {
                  sendPerso(cible, 'se lib\xE8re de ' + agrippant.tokName);
                  toFront(cible.token);
                  setState(cible, 'immobilise', false, evt);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On lib\xE8re les personnages \xE9cras\xE9s, si il y en a.
          let attrEcrase = tokenAttribute(personnage, 'ecrase');
          attrEcrase.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'estEcrasePar');
              attrCible.forEach(function(a) {
                let agrippant = persoOfIdName(a.get('current', pageId));
                if (agrippant.token.id == personnage.token.id) {
                  sendPerso(cible, 'se lib\xE8re de ' + agrippant.tokName);
                  toFront(cible.token);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On lib\xE8re les personnages aval\xE9s, si il y en a.
          let attrGobe = tokenAttribute(personnage, 'aGobe');
          attrGobe.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'estGobePar');
              attrCible.forEach(function(a) {
                let gobant = persoOfIdName(a.get('current', pageId));
                if (gobant.token.id == personnage.token.id) {
                  sendPerso(cible, 'peut enfin sortir du ventre de ' + gobant.tokName);
                  toFront(cible.token);
                  evt.deletedAttributes.push(a);
                  a.remove();
                  unlockToken(cible, evt);
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On lib\xE8re les personnages sous \xE9treinte et immolation
          let attrEtreinteImmole = tokenAttribute(personnage, 'etreinteImmole');
          attrEtreinteImmole.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'etreinteImmolePar');
              attrCible.forEach(function(a) {
                let agrippant = persoOfIdName(a.get('current', pageId));
                if (agrippant.token.id == personnage.token.id) {
                  sendPerso(cible, 'se lib\xE8re de ' + agrippant.tokName);
                  toFront(cible.token);
                  setState(cible, 'immobilise', false, evt);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On lib\xE8re les personnages sous \xE9treinte de scorpion
          let attrEtreinteScorpion = tokenAttribute(personnage, 'etreinteScorpionSur');
          attrEtreinteScorpion.forEach(function(a) {
            let cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              let attrCible = tokenAttribute(cible, 'etreinteScorpionPar');
              let attrRatee = tokenAttribute(cible, 'etreinteScorpionRatee');
              attrCible.forEach(function(a) {
                let agrippant = persoOfIdName(a.get('current', pageId));
                if (agrippant.token.id == personnage.token.id) {
                  sendPerso(cible, 'se lib\xE8re de ' + agrippant.tokName);
                  toFront(cible.token);
                  evt.deletedAttributes.push(a);
                  a.remove();
                  attrRatee.forEach(function(attrR) {
                    evt.deletedAttributes.push(attrR);
                    attrR.remove();
                  });
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On fait l'explosion finale
          if (predicateAsBool(personnage, 'explosionFinale')) {
            let label = predicateAsBool(personnage, 'explosionFinale');
            let character = getObj('character', personnage.charId);
            if (character === undefined) {
              error("Impossible de trouver le personnage de " + personnage.token.get('name'), personnage);
              return true;
            }
            let msg = {
              who: 'GM',
              selected: [{
                _id: personnage.token.id
              }]
            };
            let pids = character.get('controlledby');
            pids = pids.split(',');
            if (pids[0] === '' || pids[0] == 'all') {
              pids = findObjs({
                type: 'player'
              }).map(function(p) {
                return p.id;
              });
            }
            if (pids.length > 0) {
              if (pids.length === 0) {
                msg.playerid = pids[0];
              } else {
                msg.playerid = pids.find(playerIsGM);
                if (msg.playerid === undefined) msg.playerid = pids[0];
              }
              msg.content = '!cof-explosion ' + label;
              attaqueExplosion(msg);
            }
          }
          //On termine les effets temporaires li\xE9s au personnage
          let etlAttr = tokenAttribute(personnage, 'effetsTemporairesLies');
          if (etlAttr.length > 0) {
            etlAttr = etlAttr[0];
            evt.deletedAttributes = evt.deletedAttributes || [];
            let etl = etlAttr.get('current').split(',');
            etl.forEach(function(attrId) {
              let attrEffet = getObj('attribute', attrId);
              if (attrEffet === undefined) return;
              let nomAttrEffet = attrEffet.get('name');
              let charId = attrEffet.get('characterid');
              if (estEffetTemp(nomAttrEffet)) {
                finDEffet(attrEffet, effetTempOfAttribute(attrEffet), nomAttrEffet, charId, evt);
              } else if (estEffetCombat(nomAttrEffet)) {
                let mc = messageFin(personnage, messageEffetCombat[effetCombatOfAttribute(attrEffet)]);
                if (mc && mc !== '') sendChar(charId, mc, true);
                evt.deletedAttributes.push(attrEffet);
                attrEffet.remove();
              }
            });
            evt.deletedAttributes.push(etlAttr);
            etlAttr.remove();
          }
          //On enl\xE8ve les auras
          if (stateCOF.combat &&
            (predicateAsBool(personnage, 'auraDrainDeForce') || attributeAsBool(personnage, 'aura'))
          ) {
            let auras = stateCOF.combat.auras;
            if (auras) {
              if (!evt.combat) evt.combat = {...stateCOF.combat
              };
              stateCOF.combat.auras = auras.filter(function(aura) {
                return personnage.token.id == aura.origineId;
              });
            }
          }
          if (attributeAsBool(personnage, 'objetAnime')) {
            let attr = tokenAttribute(personnage, 'objetAnime')[0];
            let nom = attr.get('name');
            finDEffet(attr, 'objetAnime', nom, personnage.charId, evt);
          } else if (charAttributeAsBool(personnage, 'armeeConjuree')) {
            removeFromTurnTracker(personnage, evt);
            deleteTokenWithUndo(personnage.token, evt);
            sendPerso(personnage, 'dispara\xEEt');
            let armeeChar = getObj('character', personnage.charId);
            if (armeeChar) {
              evt.deletedCharacters = evt.deletedCharacters || [];
              evt.deletedCharacters.push({
                id: personnage.charId,
                name: armeeChar.get('name'),
                avatar: armeeChar.get('avatar'),
                attributes: findObjs({
                  _type: 'attributes',
                  _characterid: personnage.charId
                }),
                abilities: findObjs({
                  _type: 'ability',
                  _characterid: personnage.charId
                })
              });
              armeeChar.remove();
            }
          } else if (!estNonVivant(personnage)) {
            //Cherche si certains peuvent siphoner l'\xE2me
            let allToks =
              findObjs({
                _type: 'graphic',
                _pageid: pageId,
                _subtype: 'token',
                layer: 'objects'
              });
            //On cherche d'abord si un siphon des \xE2mes est prioritaire
            let prioriteSiphon = [];
            allToks = allToks.filter(function(tok) {
              if (tok.id == token.id) return false;
              let p = persoOfToken(tok);
              if (p === undefined) return false;
              if (getState(p, 'mort')) return false;
              if (distanceCombat(token, tok, pageId) > 20) return false;
              if (predicateAsBool(p, 'siphonDesAmes')) {
                prioriteSiphon.push({
                  perso: p,
                  priorite: predicateAsInt(p, 'siphonDesAmesPrioritaire', 0)
                });
              }
              return true;
            });
            if (prioriteSiphon.length > 0) {
              let pvMax = parseInt(personnage.token.get('bar1_max'));
              if (isNaN(pvMax) || pvMax < 1) pvMax = 1;
              if (estPJ(personnage) || predicateAsBool(personnage, 'PVPartagesAvec')) {
                let siphoneur = prioriteSiphon[0].perso;
                let bonus = predicateAsInt(siphoneur, 'siphonDesAmes', 0);
                let jetSiphon = "(1d6";
                if (bonus > 0) jetSiphon += '+' + bonus;
                jetSiphon += ")";
                sendChat('COF', "/w GM " + personnage.token.get('name') + " est un personnage joueur, possible qu'il ne soit pas vraiment mort mais juste inconscient. S'il est vraiment mort, faire le siphon des \xE2mes par " + siphoneur.token.get('name') + " \xE0 la main " + jetSiphon);
              } else {
                prioriteSiphon.sort(function(a, b) {
                  return b.priorite - a.priorite;
                });
                let fraction = 100;
                let fractionPriorite = fraction;
                let priorite = prioriteSiphon[0].priorite;
                prioriteSiphon.forEach(function(x) {
                  if (x.priorite < priorite) {
                    priorite = x.priorite;
                    fractionPriorite = fraction;
                  }
                  let p = x.perso;
                  if (fractionPriorite < 1) {
                    whisperChar(p.charId, "ne r\xE9ussit pas \xE0 siphoner l'\xE2me de " + token.get('name') + " un autre pouvoir l'a siphon\xE9e avant lui");
                    return true;
                  }
                  let bonus = predicateAsInt(p, 'siphonDesAmes', 0);
                  let nbDes = 1 + Math.floor(pvMax / 60);
                  let soin = rollDePlus(6, {
                    bonus,
                    nbDes
                  });
                  let soinTotal = soin.val;
                  //Le montant total des soins ne peut exc\xE9der les pv max du personnage qui vient de mourrir.
                  let display = true;
                  if (soinTotal > pvMax) {
                    soinTotal = pvMax;
                    display = false;
                  }
                  if (soinTotal < 1) soinTotal = 1;
                  soin.val = soinTotal;
                  soin.val = Math.ceil(soin.val * fractionPriorite / 100);
                  //Cherche si il y a un perso li\xE9
                  let lie = personnageAmeLiee(p, pageId, allToks);
                  soigneToken(p, soin.val, evt,
                    function(s) {
                      let siphMsg = "siphone l'\xE2me de " + token.get('name') +
                        ". " + onGenre(p, 'Il', 'Elle') + " r\xE9cup\xE8re ";
                      if (s == soinTotal) {
                        if (display) siphMsg += soin.roll + " pv.";
                        else siphMsg += s + " pv (jet " + soin.roll + ").";
                        fraction = 0;
                      } else {
                        siphMsg += s + " pv (jet " + soin.roll + ").";
                        fraction -= Math.ceil(s * 100 / soinTotal);
                      }
                      pvMax -= s;
                      whisperChar(p.charId, siphMsg);
                      if (pvMax > 0 && lie && (s > 4 || s < soinTotal)) {
                        let soin2 = soinTotal - s + Math.floor(s / 5);
                        soigneToken(lie, soin2, evt, function(s) {
                          let siphMsg =
                            "r\xE9cup\xE8re une partie de l'\xE2me de " + token.get('name') +
                            " siphon\xE9e par " + nomPerso(p) + ". " + onGenre(lie, 'Il', 'Elle') + " r\xE9cup\xE8re " + s + " pv.";
                          if (s == soin2) {
                            fraction = 0;
                          } else {
                            fraction -= Math.ceil(s * 100 / soin2);
                          }
                          pvMax -= s;
                          whisperChar(lie.charId, siphMsg);
                        }, function() {
                          whisperChar(lie.charId, "sent qu'" + onGenre(lie, 'il', 'elle') + " aurait pu b\xE9n\xE9ficier d'une \xE2me");
                        });
                      }
                    },
                    function() {
                      if (lie) {
                        soigneToken(lie, soin.val, evt, function(s) {
                          let siphMsg = "siphone l'\xE2me de " + token.get('name') +
                            " gr\xE2ce \xE0 " + nomPerso(p) + ". " + onGenre(lie, 'Il', 'Elle') + " r\xE9cup\xE8re ";
                          if (s == soinTotal) {
                            siphMsg += soin.roll + " pv.";
                            fraction = 0;
                          } else {
                            siphMsg += s + " pv (jet " + soin.roll + ").";
                            fraction -= Math.ceil(s * 100 / soinTotal);
                          }
                          pvMax -= s;
                          whisperChar(lie.charId, siphMsg);
                        }, function() {
                          whisperChar(p.charId,
                            "est d\xE9j\xE0 au maximum de point de vie. " + onGenre(p, 'Il', 'Elle') + " laisse \xE9chapper l'\xE2me de " + token.get('name'));
                        });
                      } else {
                        whisperChar(p.charId,
                          "est d\xE9j\xE0 au maximum de point de vie. " + onGenre(p, 'Il', 'Elle') + " laisse \xE9chapper l'\xE2me de " + token.get('name'));
                      }
                    });
                });
              }
            }
          }
          break;
        case 'immobilise':
        case 'surpris':
        case 'assomme':
        case 'etourdi':
        case 'paralyse':
        case 'endormi':
        case 'apeure':
          nePlusSuivre(personnage, pageId, evt);
          lockToken(personnage, evt);
      }
    } else { //value est false
      if (etat == 'mort' && stateCOF.combat)
        removeTokenAttr(personnage, 'a0PVDepuis', evt);
      if (!options.fromTemp)
        removeTokenAttr(personnage, etat + 'Temp', evt);
    }
    if (!value) {
      unlockToken(personnage, evt);
      if (stateCOF.combat && etatRendInactif(etat) && isActive(personnage) ||
        etat == 'aveugle') updateInit(token, evt);
    }
    return true;
  }

  //fonction avec callback, mais synchrone
  // n'ajoute pas evt \xE0 l'historique
  function soigneToken(perso, soins, evt, callTrue, callMax, options) {
    options = options || {};
    let token = perso.token;
    let bar1 = parseInt(token.get("bar1_value"));
    let pvmax = parseInt(token.get("bar1_max"));
    if (isNaN(bar1) || isNaN(pvmax)) {
      error("Soins sur un token sans points de vie", token);
      return;
    }
    let updateBar1;
    if (bar1 >= pvmax) bar1 = pvmax;
    else updateBar1 = true;
    if (soins < 0) soins = 0;
    let nonSoignable = 0;
    //Update des dm suivis
    let attrs = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    let regSuivis = '^DMSuivis([^_]+)';
    let link = token.get('bar1_link');
    if (link === '') regSuivis += "_" + token.get('name') + '$';
    else regSuivis += '$';
    regSuivis = new RegExp(regSuivis);
    let soinsSuivis = soins;
    let soinsImpossible = new Set(options.saufDMType);
    attrs.forEach(function(a) {
      if (soinsSuivis === 0) return;
      let an = a.get('name');
      an = an.match(regSuivis);
      if (an && an.length > 0) {
        let ds = parseInt(a.get('current'));
        if (ds > 0) {
          if (an[0].length < 2) {
            error("Match non trouv\xE9 pour les soins", an);
            return;
          }
          if (soinsImpossible.has(an[1])) {
            nonSoignable += ds;
          } else {
            if (ds > soinsSuivis) {
              evt.attributes = evt.attributes || [];
              evt.attributes.push({
                attribute: a,
                current: ds
              });
              ds -= soinsSuivis;
              a.set('current', ds);
              soinsSuivis = 0;
            } else {
              soinsSuivis -= ds;
              ds = 0;
            }
          }
        } else ds = 0;
        if (ds === 0) {
          evt.deletedAttributes = evt.deletedAttributes || [];
          evt.deletedAttributes.push(a);
          a.remove();
        }
      }
    });
    pvmax -= nonSoignable;
    if (pvmax <= 0) {
      if (callMax) callMax();
      return;
    }
    if (bar1 === 0) {
      if (attributeAsBool(perso, 'etatExsangue')) {
        removeTokenAttr(perso, 'etatExsangue', evt, {
          msg: "retrouve des couleurs"
        });
      } else if (getState(perso, 'mort')) {
        setState(perso, 'renverse', true, evt);
        setState(perso, 'mort', false, evt);
      }
    }
    if (predicateAsBool(perso, 'vieArtificielle')) {
      soins = Math.floor(soins / 2);
    }
    bar1 += soins;
    let soinsEffectifs = soins;
    if (bar1 > pvmax) {
      if (attributeAsBool(perso, 'formeDArbre')) {
        let apv = tokenAttribute(perso, 'anciensPV');
        if (apv.length > 0) {
          apv = apv[0];
          let anciensPV = parseInt(apv.get('current'));
          let anciensMax = parseInt(apv.get('max'));
          if (!(isNaN(anciensPV) || isNaN(anciensMax)) &&
            anciensPV < anciensMax) {
            let soinsTransferes = bar1 - pvmax;
            if (anciensMax - anciensPV < soinsTransferes)
              soinsTransferes = anciensMax - anciensPV;
            anciensPV += soinsTransferes;
            bar1 -= soinsTransferes;
            setTokenAttr(perso, 'anciensPV', anciensPV, evt, {
              maxVal: anciensMax
            });
          }
        }
      }
      // On  cherche si il y a des DM temporaires \xE0 soigner
      if (bar1 > pvmax) {
        let hasMana = (ficheAttributeAsInt(perso, 'PM', 0) > 0);
        let dmgTemp;
        const estMook = token.get('bar1_link') === '';
        if (hasMana) {
          if (estMook) dmgTemp = attributeAsInt(perso, 'DMTEMP', 0);
          else dmgTemp = ficheAttributeAsInt(perso, 'DMTEMP', 0);
        } else {
          dmgTemp = toInt(token.get('bar2_value'), 0);
        }
        if (dmgTemp > 0) {
          let newDmgTemp = dmgTemp - bar1 + pvmax;
          if (newDmgTemp < 0) {
            newDmgTemp = 0;
            bar1 -= dmgTemp;
          } else bar1 = pvmax;
          if (hasMana) setTokenAttr(perso, 'DMTEMP', newDmgTemp, evt);
          else updateCurrentBar(perso, 2, newDmgTemp, evt);
        }
        soinsEffectifs -= (bar1 - pvmax);
        bar1 = pvmax;
      }
    }
    if (bar1 == pvmax && attributeAsBool(perso, 'osBrises')) {
      removeTokenAttr(perso, 'osBrises', evt, {
        msg: "soigne ses os"
      });
    }
    if (updateBar1) updateCurrentBar(perso, 1, bar1, evt);
    if (soinsEffectifs > 0) {
      if (!options.recuperation) {
        if (attributeAsBool(perso, 'blessureQuiSaigne')) {
          removeTokenAttr(perso, 'blessureQuiSaigne', evt, {
            msg: ": les soins referment la blessure"
          });
          removeTokenAttr(perso, 'blessureQuiSaignePuissant', evt);
          removeTokenAttr(perso, 'blessureQuiSaigneValeur', evt);
          removeTokenAttr(perso, 'blessureQuiSaigneSaveParTour', evt);
          removeTokenAttr(perso, 'blessureQuiSaigneSaveParTourType', evt);
          removeTokenAttr(perso, 'blessureQuiSaigneTempeteDeManaIntense', evt);
          removeTokenAttr(perso, 'blessureQuiSaigneOptions', evt);
        }
        if (attributeAsBool(perso, 'reactionAllergique')) {
          removeTokenAttr(perso, 'reactionAllergique', evt, {
            msg: ": les soins mettent fin \xE0 la r\xE9action allergique"
          });
        }
      }
      if (callTrue) callTrue(soinsEffectifs);
    } else {
      if (callMax) callMax();
    }
  }

  function computeScale(pageId) {
    const page = getObj("page", pageId);
    let scale = parseFloat(page.get('scale_number'));
    if (isNaN(scale) || scale <= 0) return 1.0;
    let cellSize = parseFloat(page.get('snapping_increment'));
    if (!isNaN(cellSize) && cellSize > 0) scale /= cellSize;
    const unit = page.get('scale_units');
    switch (unit) {
      case 'ft':
        scale *= 0.3048;
        break;
      case 'cm':
        scale *= 0.01;
        break;
      case 'km':
        scale *= 1000;
        break;
      case 'mi':
        scale *= 1609.34;
        break;
      case 'in':
        scale *= 0.0254;
        break;
    }
    return scale;
  }

  // si le token est plus grand que thresh, r\xE9duit la distance
  function tokenSize(tok, thresh) {
    let size = (tok.get('width') + tok.get('height')) / 2;
    if (size > thresh) return ((size - thresh) / 2);
    return 0;
  }

  function vecteurUnitaire(pt1, pt2) {
    let x = pt2.x - pt1.x;
    let y = pt2.y - pt1.y;
    let n = Math.sqrt(x * x + y * y);
    x = x / n;
    y = y / n;
    return {
      x,
      y
    };
  }

  function distancePoints(pt1, pt2) {
    let x = pt2.x - pt1.x;
    let y = pt2.y - pt1.y;
    return Math.sqrt(x * x + y * y);
  }

  function distanceTokenPrev(token, prev) {
    let x = token.get('left') - prev.left;
    let y = token.get('top') - prev.top;
    return Math.sqrt(x * x + y * y);
  }

  //Distance en pixels entre 2 tokens
  function distancePixToken(tok1, tok2) {
    let x = tok1.get('left') - tok2.get('left');
    let y = tok1.get('top') - tok2.get('top');
    return Math.sqrt(x * x + y * y);
  }

  function pointOfToken(token) {
    return {
      x: token.get('left'),
      y: token.get('top')
    };
  }

  //Distance en pixels entre un token et un segment
  //le segment est donn\xE9 par ses extr\xE9mit\xE9s, sous forme de {x, y}
  function distancePixTokenSegment(token, pt1, pt2) {
    let pt = pointOfToken(token);
    let seg = {
      x: pt2.x - pt1.x,
      y: pt2.y - pt1.y
    };
    let vec = {
      x: pt.x - pt1.x,
      y: pt.y - pt1.y
    }; //vecteur de pt1 \xE0 pt
    //On regarde d'abord si le projet\xE9 de token sur (pt1, pt2) est dans le segment
    let ps = seg.x * vec.x + seg.y * vec.y;
    if (ps <= 0) { //On est avant pt1
      return Math.sqrt(vec.x * vec.x + vec.y * vec.y);
    }
    let dseg = seg.x * seg.x + seg.y * seg.y;
    if (ps >= dseg) { //On est apr\xE8s pt2, on retourne donc la distance pt pt2
      let x = pt.x - pt2.x;
      let y = pt.y - pt2.y;
      return Math.sqrt(x * x + y * y);
    }
    //On calcule le d\xE9terminant de vec et seg
    let det = vec.x * seg.y - vec.y * seg.x;
    //Et on divise par la longueur du segment
    return Math.abs(det) / Math.sqrt(dseg);
  }

  //options peut avoir les champs:
  // - strict1 = true si on consid\xE8re que tok1 doit avoir une taille nulle
  // - strict2
  // - allonge
  function distanceCombat(tok1, tok2, pageId, options) {
    if (pageId === undefined) {
      pageId = tok1.get('pageid');
    }
    options = options || {};
    //perso mont\xE9s
    let pseudoTok1 = tok1;
    if (!options.strict1) {
      let perso1 = persoOfToken(tok1);
      if (perso1) {
        let attrMonture1 = tokenAttribute(perso1, 'monteSur');
        if (attrMonture1.length > 0) {
          let pseudoPerso1 = persoOfIdName(attrMonture1[0].get('current'), pageId);
          if (pseudoPerso1) pseudoTok1 = pseudoPerso1.token;
        }
      }
    }
    let pseudoTok2 = tok2;
    if (!options.strict2) {
      let perso2 = persoOfToken(tok2);
      if (perso2) {
        let attrMonture2 = tokenAttribute(perso2, 'monteSur');
        if (attrMonture2.length > 0) {
          let pseudoPerso2 = persoOfIdName(attrMonture2[0].get('current'), pageId);
          if (pseudoPerso2) pseudoTok2 = pseudoPerso2.token;
        }
      }
    }
    let scale = computeScale(pageId);
    let distance_pix = distancePixToken(pseudoTok1, pseudoTok2);
    if (!options.strict1) distance_pix -= tokenSize(pseudoTok1, PIX_PER_UNIT / 2);
    if (!options.strict2) distance_pix -= tokenSize(pseudoTok2, PIX_PER_UNIT / 2);
    if (options.allonge) distance_pix -= (options.allonge * PIX_PER_UNIT) / scale;
    if ((!options.strict1 || !options.strict2) && distance_pix < PIX_PER_UNIT * 1.3) return 0; //cases voisines
    return ((distance_pix / PIX_PER_UNIT) * scale);
  }

  //Attention, seulement faire pour les tokens avec une image dans la librairie
  //C'est toujours le cas pour un token cr\xE9\xE9 par le script
  function deleteTokenWithUndo(token, evt) {
    let tokenFields = getTokenFields(token);
    evt.deletedTokens = evt.deletedTokens || [];
    evt.deletedTokens.push(tokenFields);
    token.remove();
  }

  function finDEffet(attr, effet, attrName, charId, evt, options) { //L'effet arrive en fin de vie, doit \xEAtre supprim\xE9
    options = options || {};
    evt.deletedAttributes = evt.deletedAttributes || [];
    let res;
    let newInit = [];
    let efComplet = effetComplet(effet, attrName);
    //Si on a un attrSave, alors on a d\xE9j\xE0 imprim\xE9 le message de fin d'effet
    if (options.attrSave) { //on a un attribut associ\xE9 \xE0 supprimer)
      evt.deletedAttributes.push(options.attrSave);
      options.attrSave.remove();
    } else if (options.gardeAutresAttributs === undefined) { //On cherche si il y en a un
      enleverEffetAttribut(charId, efComplet, attrName, 'SaveParTour', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'SaveActifParTour', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'SaveParTourType', evt);
    }
    let mEffet = messageEffetTemp[effet];
    if (mEffet === undefined) mEffet = messageEffetCombat[effet];
    if (mEffet && mEffet.statusMarker) {
      iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
        affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
        token.set('status_' + mEffet.statusMarker, false);
      }, {
        tousLesTokens: true
      });
    }
    let character;
    let combat = stateCOF.combat;
    switch (effet) {
      case 'affecteParAura': //voir si l'aura est toujours l\xE0
        if (combat && combat.auras && efComplet.length > 15) {
          let id = efComplet.substring(15, efComplet.length - 1);
          let aura = combat.auras.find(function(a) {
            return a.id == id;
          });
          if (aura) {
            let origine = persoOfId(aura.origineId, aura.origineName, options.pageId);
            if (origine) {
              let affectes = 0;
              let pageId = origine.token.get('pageid');
              iterTokensOfAttribute(charId, pageId, efComplet, attrName, function(token) {
                if (token.id == origine.token.id) return;
                let perso = {
                  charId,
                  token
                };
                affectes += appliquerAura(origine, [perso], pageId, aura, evt, true);
              });
              if (affectes) return; //On n'efface pas l'attribut !
            }
          }
        }
        break;
      case 'agrandissement': //redonner sa taille normale
        character = getObj('character', charId);
        if (character === undefined) {
          error("Personnage introuvable");
          return;
        }
        character.get('_defaulttoken', function(normalToken) {
          if (normalToken === '') return;
          normalToken = JSON.parse(normalToken);
          let largeWidth = normalToken.width + normalToken.width / 2;
          let largeHeight = normalToken.height + normalToken.height / 2;
          iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
            let width = token.get('width');
            let height = token.get('height');
            affectToken(token, 'width', width, evt);
            token.set('width', normalToken.width);
            affectToken(token, 'height', height, evt);
            token.set('height', normalToken.height);
            let perso = {
              token,
              charId
            };
            let arme = armesEnMain(perso);
            if (arme && arme.armeDeGrand) {
              let taille = taillePersonnage(perso, 4);
              if (taille == 4 && arme.label != perso.attrArmeEnMain.get('max')) {
                sendPerso(perso, "ne peut plus tenir " + arme.name + " \xE0 une main");
                degainerArme(perso, arme.label, evt, {
                  deuxMains: true
                });
              }
            }
          }, {
            filterAffected: function(token) {
              if (token.get('width') == largeWidth) return true;
              if (token.get('height') == largeHeight) return true;
              return false;
            }
          });
        });
        break;
      case 'aveugleTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'aveugle', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'penombreTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'penombre', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'ralentiTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'ralenti', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'paralyseTemp':
      case 'paralyseGoule':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'paralyse', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'immobiliseTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'immobilise', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'etourdiTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'etourdi', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'affaibliTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'affaibli', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'assommeTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'assomme', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'invisibleTemp':
      case 'intangibleInvisible':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'invisible', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'apeureTemp':
      case 'peurEtourdi':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'apeure', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'ombreMortelle':
      case 'dedoublement':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
          deleteTokenWithUndo(token, evt);
        });
        break;
      case 'murDeForce':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
          let attrM = tokenAttribute({
            charId: charId,
            token: token
          }, 'murDeForceId');
          if (attrM.length === 0) return;
          let imageMur = getObj('graphic', attrM[0].get('current'));
          if (imageMur) {
            imageMur.remove();
          }
          attrM[0].remove();
        });
        break;
      case 'regeneration': //faire les soins restants
        let toursRestant = parseInt(attr.get('current'));
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            let perso = {
              token: token,
              charId: charId
            };
            if (!isNaN(toursRestant) && toursRestant > 0) {
              let regen = getValeurOfEffet(perso, 'regeneration', 3);
              let soins = regen * (toursRestant + attributeAsInt(perso, 'regenerationTempeteDeManaIntense', 0));
              soigneToken(perso, soins, evt,
                function(s) {
                  options.print = function(m) {}; //Pour ne pas afficher le message final.
                  let tempsEffectif = Math.ceil(s / regen);
                  sendPerso(perso, "r\xE9cup\xE8re encore " + s + " PV en " + tempsEffectif + " tours.");
                });
            }
            //R\xE9g\xE9n\xE9ration d'une carac physique affaiblie de 1d4, si il y en a.
            if (attributeAsInt(perso, 'affaiblissementdeconstitution', 0) > 0) {
              let d4 = rollDePlus(4);
              diminueAffaiblissement(perso, 'constitution', d4.val, evt);
              sendPerso(perso, "r\xE9cup\xE8re " + d4.roll + " points de constitution");
            } else if (attributeAsInt(perso, 'affaiblissementdeforce', 0) > 0) {
              let d4 = rollDePlus(4);
              diminueAffaiblissement(perso, 'force', d4.val, evt);
              sendPerso(perso, "r\xE9cup\xE8re " + d4.roll + " points de force");
            } else if (attributeAsInt(perso, 'affaiblissementdedexterite', 0) > 0) {
              let d4 = rollDePlus(4);
              diminueAffaiblissement(perso, 'dexterite', d4.val, evt);
              sendPerso(perso, "r\xE9cup\xE8re " + d4.roll + " points de dext\xE9rit\xE9");
            }
          });
        break;
      case 'demonInvoque':
      case 'predateurConjure':
      case 'arbreAnime':
      case 'objetAnime':
      case 'degradationZombie': //effacer le personnage
        //Dans le cas d'un Zombie, diminuer la limite du n\xE9cromant si n\xE9cessaire
        if (effet == 'degradationZombie') {
          let attrNecromant = charAttribute(charId, 'necromant');
          if (attrNecromant.length > 0) {
            let id = attrNecromant[0].get('current');
            let necromant = persoOfId(id, id, options.pageId);
            if (necromant) {
              let attrNbZombie = tokenAttribute(necromant, 'zombiesControles');
              if (attrNbZombie.length > 0) {
                let nbZombie = attrAsInt(attrNbZombie, 1);
                if (nbZombie > 1)
                  setTokenAttr(necromant, 'zombiesControles', nbZombie - 1, evt);
                else attrNbZombie[0].remove();
              }
            }
          }
        }
        if (effet == 'objetAnime') {
          let attr = charAttribute(charId, 'objetAnimePar');
          if (attr.length > 0) {
            let nid = attr[0].get("current");
            let lanceur = persoOfIdName(nid, options.pageId);
            if (lanceur) {
              let attrNbObjets = tokenAttribute(lanceur, 'niveauDesObjetsAnimes');
              if (attrNbObjets.length > 0) {
                let niveauObjets = ficheAttributeAsInt({
                  charId
                }, 'niveau', 1);
                let nbObjets = attrAsInt(attrNbObjets, niveauObjets);
                if (nbObjets > niveauObjets)
                  setTokenAttr(lanceur, 'niveauDesObjetsAnimes', nbObjets - niveauObjets, evt);
                else attrNbObjets[0].remove();
              }
            }
          }
        }
        //On efface d'abord les attributs et les abilities
        let charAttributes = findObjs({
          _type: 'attribute',
          _characterid: charId
        });
        charAttributes.forEach(
          function(otherAttr) {
            if (otherAttr.id != attr.id) otherAttr.remove();
          }
        );
        let charAbilities = findObjs({
          _type: 'ability',
          _characterid: charId
        });
        charAbilities.forEach(
          function(ab) {
            ab.remove();
          }
        );
        if (effet == 'arbreAnime' || (effet == 'objetAnime' && charPredicateAsBool(charId, 'animeAPartirDExistant'))) {
          iterTokensOfAttribute(charId, options.pageId, effet, attrName,
            function(token) {
              let perso = {
                token: token,
                charId: charId
              };
              let nA = removeFromTurnTracker(perso, evt);
              if (nA) {
                res = res || {};
                res.oldTokenId = token.id;
                res.newTokenId = nA.nextId;
              }
              setToken(token, 'bar1_link', '', evt);
              setToken(token, 'bar1_value', '', evt);
              setToken(token, 'bar1_max', '', evt);
              setToken(token, 'showplayers_bar1', false, evt);
              setToken(token, 'represents', '', evt);
              setToken(token, 'showname', false, evt);
              setToken(token, 'showplayers_name', false, evt);
              setToken(token, 'name', '', evt);
            });
        } else {
          iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
            let perso = {
              token: token,
              charId: charId
            };
            let nP = removeFromTurnTracker(perso, evt);
            if (nP) {
              res = res || {};
              res.oldTokenId = token.id;
              res.newTokenId = nP.nextId;
            }
            deleteTokenWithUndo(token, evt);
          });
        }
        attr.remove();
        let msgFin = messageFin({
          charId
        }, mEffet);
        if (options.print && mEffet) options.print(msgFin);
        else {
          sendChar(charId, msgFin, true);
          options.print = function(m) {};
        }
        character = getObj('character', charId);
        if (character) {
          evt.deletedCharacters = evt.deletedCharacters || [];
          let deletedChar = {
            id: charId,
            name: character.get('name'),
            avatar: character.get('avatar'),
            attributes: charAttributes,
            abilities: charAbilities,
            allies: []
          };
          // Retrait du perso de toutes les listes d'alli\xE9s
          for (const [perso, alliesPerso] of Object.entries(alliesParPerso)) {
            if (alliesPerso.has(charId)) {
              deletedChar.allies.push(perso);
              alliesPerso.delete(charId);
            }
          }
          character.remove();
          evt.deletedCharacters.push(deletedChar);
        }
        return res; //Pas besoin de faire le reste, car plus de perso
      case 'formeDArbre':
        {
          let iterTokOptions = {
            filterAffected: function(token) {
              return token.get('layer') == 'objects';
            }
          };
          iterTokensOfAttribute(charId, options.pageId, effet, attrName,
            function(token) {
              let perso = {
                token: token,
                charId: charId
              };
              let tokenChange = attributeAsBool(perso, 'changementDeToken');
              if (tokenChange) {
                let tokenMJ =
                  findObjs({
                    _type: 'graphic',
                    _subtype: 'token',
                    _pageid: token.get('pageid'),
                    layer: 'gmlayer',
                    represents: charId,
                    name: token.get('name')
                  });
                if (tokenMJ.length === 0) return;
                removeTokenAttr(perso, 'changementDeToken', evt);
                let nouveauToken = tokenMJ[0];
                setToken(nouveauToken, 'layer', 'objects', evt);
                setToken(nouveauToken, 'left', token.get('left'), evt);
                setToken(nouveauToken, 'top', token.get('top'), evt);
                setToken(nouveauToken, 'width', token.get('width'), evt);
                setToken(nouveauToken, 'height', token.get('height'), evt);
                setToken(nouveauToken, 'rotation', token.get('rotation'), evt);
                setToken(nouveauToken, 'bar2_value', token.get('bar2_value'), evt);
                setToken(nouveauToken, 'aura1_radius', token.get('aura1_radius'), evt);
                setToken(nouveauToken, 'aura1_color', token.get('aura1_color'), evt);
                setToken(nouveauToken, 'aura1_square', token.get('aura1_square'), evt);
                setToken(nouveauToken, 'showplayers_aura1', token.get('showplayers_aura1'), evt);
                setToken(nouveauToken, 'aura2_radius', token.get('aura2_radius'), evt);
                setToken(nouveauToken, 'aura2_color', token.get('aura2_color'), evt);
                setToken(nouveauToken, 'aura2_square', token.get('aura2_square'), evt);
                setToken(nouveauToken, 'showplayers_aura2', token.get('showplayers_aura2'), evt);
                setToken(nouveauToken, 'statusmarkers', token.get('statusmarkers'), evt);
                setToken(nouveauToken, 'light_angle', token.get('light_angle'), evt);
                setToken(nouveauToken, 'has_limit_field_of_vision', token.get('has_limit_field_of_vision'), evt);
                setToken(nouveauToken, 'has_limit_field_of_night_vision', token.get('has_limit_field_of_night_vision'), evt);
                if (combat) {
                  replaceInTurnTracker(token.id, nouveauToken.id, evt);
                }
                res = res || {};
                res.oldTokenId = token.id;
                res.newTokenId = nouveauToken.id;
                res.newToken = nouveauToken;
                deleteTokenWithUndo(token, evt);
                token = nouveauToken;
                perso.token = nouveauToken;
              }
              let apv = tokenAttribute(perso, 'anciensPV');
              if (apv.length > 0) {
                updateCurrentBar(perso, 1, apv[0].get('current'), evt, apv[0].get('max'));
                removeTokenAttr(perso, 'anciensPV', evt);
                if (combat) {
                  newInit.push({
                    _id: token.id
                  });
                }
              }
            },
            iterTokOptions);
          break;
        }
      case 'agitAZeroPV':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
          let perso = {
            charId: charId,
            token: token
          };
          let pv = token.get('bar1_value');
          if (pv == 0) { //jshint ignore:line
            mort(perso, undefined, evt);
          } else {
            //On note qu'il l'a d\xE9j\xE0 fait pour qu'il ne puisse le refaire dans le combat
            setTokenAttr(perso, 'aAgiAZeroPV', true, evt);
          }
        });
        break;
      case 'forgeron':
      case 'armeEnflammee':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          let perso = {
            token: token,
            charId: charId
          };
          eteindreUneLumiere(perso, options.pageId, undefined, efComplet, evt);
        });
        break;
      case 'effetRetarde':
        if (efComplet.length > 14) {
          let effetRetarde = efComplet.substring(13, efComplet.length - 1);
          if (_.has(cof_states, effetRetarde)) {
            iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
              let perso = {
                token: token,
                charId: charId
              };
              if (getState(perso, 'mort')) return;
              setState(perso, effetRetarde, true, evt);
            });
          } else if (estEffetTemp(effetRetarde)) {
            options.print = function(m) {}; //Pour ne pas afficher le message final.
            let pp = effetRetarde.indexOf('(');
            let mEffetRetarde = (pp > 0) ? messageEffetTemp[effetRetarde.substring(effetRetarde, pp)] : messageEffetTemp[effetRetarde];
            let ef = {
              effet: effetRetarde,
              duree: 1,
              message: mEffetRetarde,
              whisper: true,
            };
            iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
              let perso = {
                token,
                charId
              };
              if (getState(perso, 'mort')) return;
              if (!combat) {
                sendChat('', "Il restait un effet retard\xE9 " + effetRetarde + " qui devait se d\xE9clencher pour " + token.get('name'));
                return;
              }
              let duree = getValeurOfEffet(perso, efComplet, 1);
              ef.duree = duree;
              setEffetTemporaire(perso, ef, duree, evt, {});
            });
          } else {
            options.print = function(m) {}; //Pour ne pas afficher le message final.
            iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
              let perso = {
                token: token,
                charId: charId
              };
              if (getState(perso, 'mort')) return;
              let val = true;
              let valAttr = tokenAttribute(perso, efComplet + 'Valeur');
              if (valAttr.length > 0) val = valAttr[0].get('current');
              whisperChar(charId, effetRetarde + ' ' + val);
              setTokenAttr(perso, effetRetarde, val, evt, {});
            });
          }
        }
        break;
      case 'poisonAffaiblissantLatent':
        options.print = function(m) {}; //Pour ne pas afficher le message final.
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          let perso = {
            token: token,
            charId: charId
          };
          if (getState(perso, 'mort')) return;
          whisperChar(charId, "Le poison commence \xE0 faire effet !");
          setTokenAttr(perso, 'poisonAffaiblissantLong', true, evt, {});
        });
        break;
      case 'messageRetarde':
        if (efComplet.length > 16) {
          let messageRetarde = efComplet.substring(15, efComplet.length - 1);
          iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
            whisperChar(charId, messageRetarde);
            //Puis on regarde si il y a une valeur \xE0 afficher
            let perso = {
              token: token,
              charId: charId
            };
            let valAttr = tokenAttribute(perso, efComplet + 'Valeur');
            if (valAttr.length > 0)
              whisperChar(charId, valAttr[0].get('current').replace(/_/g, ' '));
          });
        }
        break;
      case 'tenebres':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          //Puis on regarde si il y a une valeur \xE0 afficher
          let perso = {
            token: token,
            charId: charId
          };
          let valAttr = tokenAttribute(perso, efComplet + 'Valeur');
          let tokenTenebres = getObj('graphic', valAttr[0].get('current'));
          if (tokenTenebres) tokenTenebres.remove();
        });
        break;
      case 'brumes':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          //Puis on regarde si il y a une valeur \xE0 afficher
          let perso = {
            token: token,
            charId: charId
          };
          let valAttr = tokenAttribute(perso, efComplet + 'Valeur');
          let tokenTenebres = getObj('graphic', valAttr[0].get('current'));
          if (tokenTenebres) tokenTenebres.remove();
        });
        break;
      case 'armeeDesMorts':
        {
          iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
            token.set("aura2_radius", 0);
            if (combat.armeesDesMorts && combat.armeesDesMorts[token.id]) {
              if (!evt.combat) evt.combat = {...combat
              };
              evt.combat.armeesDesMorts = {...combat.armeesDesMorts
              };
              combat.armeesDesMorts[token.id] = undefined;
            }
          });
          break;
        }
      case 'lienDeSang':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          let perso = {
            token: token,
            charId: charId
          };
          let attrsLienDeSangDe = tokenAttribute(perso, "lienDeSangDe");
          if (attrsLienDeSangDe.length > 0) {
            let tokenLie = persoOfId(attrsLienDeSangDe[0].get("current"));
            if (tokenLie) {
              tokenAttribute(tokenLie, "lienDeSangVers").forEach(function(attr) {
                attr.remove();
              });
            }
          }
          attrsLienDeSangDe.forEach(function(attr) {
            attr.remove();
          });
        });
        break;
      default:
    }
    if (options.attrSave === undefined && charId) {
      let estMort = true;
      iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
        estMort = estMort && getState({
          charId: charId,
          token: token
        }, 'mort');
      });
      if (!estMort && mEffet) {
        let msgFin = messageFin({
          charId
        }, mEffet);
        if (options.print) options.print(msgFin);
        else {
          if (attrName == efComplet)
            sendChar(charId, msgFin, true);
          else {
            let tokenName = attrName.substring(attrName.indexOf('_') + 1);
            sendChat('', tokenName + ' ' + msgFin);
          }
        }
      }
    }
    if (options.gardeAutresAttributs === undefined && charId) {
      enleverEffetAttribut(charId, efComplet, attrName, 'Puissant', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'Valeur', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'TempeteDeManaIntense', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'DureeAccumulee', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'Options', evt);
    }
    evt.deletedAttributes.push(attr);
    attr.remove();
    //D\xE9bloque les tokens si l'effet les immobilisait
    switch (effet) {
      case 'bloqueManoeuvre':
      case 'prisonVegetale':
      case 'toiles':
      case 'statueDeBois':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          let perso = {
            token: token,
            charId: charId
          };
          unlockToken(perso, evt);
        });
    }
    if (newInit.length > 0) initiative(newInit, evt, true);
    return res;
  }

  function lockToken(perso, evt) {
    let lock = perso.token.get('lockMovement');
    if (!lock) {
      affectToken(perso.token, 'lockMovement', false, evt);
      perso.token.set('lockMovement', true);
    }
  }

  //retourne le personnage du compagnon s'il est pr\xE9sent et actif
  function compagnonPresent(personnage, nomCompagnon) {
    let compagnon = predicateAsBool(personnage, nomCompagnon);
    if (compagnon) {
      let compToken = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: personnage.token.get('pageid'),
        layer: 'objects',
        name: compagnon
      });
      let res;
      compToken.forEach(function(tok) {
        if (res) return;
        let compCharId = tok.get('represents');
        if (compCharId === '') return;
        compagnon = {
          token: tok,
          charId: compCharId
        };
        if (isActive(compagnon)) res = compagnon;
      });
      return res;
    }
    return;
  }

  function personnageAmeLiee(perso, pageId, allToks) {
    let lie = predicateAsBool(perso, 'ameLieeAvec');
    if (!lie) return;
    let tokenLie;
    if (allToks) {
      tokenLie = allToks.find(function(tok) {
        return tok.get('name') == lie;
      });
      if (tokenLie) return persoOfToken(tokenLie);
    } else {
      pageId = pageId || perso.token.get('pageid');
      tokenLie = findObjs({
        _type: 'graphic',
        _pageid: pageId,
        _subtype: 'token',
        layer: 'objects',
        name: lie
      });
      if (tokenLie.length > 0) {
        let p;
        let t = tokenLie.find(function(tok) {
          if (tok.id == perso.token.id) return false;
          p = persoOfToken(tok);
          if (p === undefined) return false;
          if (getState(p, 'mort')) return false;
          return true;
        });
        if (t) return p;
      } else {
        return;
      }
    }
  }

  function estControlleParJoueur(charId) {
    let character = getObj('character', charId);
    if (character === undefined) return false;
    return character.get('controlledby').length > 0;
  }

  //Pour savoir si un personnage est un personnage joueur
  // -> fiche de PJ + d\xE9 de vie + token li\xE9 + controll\xE9 par au moins un joueur.
  function estPJ(perso) {
    if (persoEstPNJ(perso)) return false;
    let dv = ficheAttributeAsInt(perso, 'DV', 0);
    if (dv === 0) return false;
    if (perso.token.get('bar1_link') === '') return false;
    return estControlleParJoueur(perso.charId);
  }


  /*
  function logEvents() {
    let l = eventHistory.length;
    log("Historique de taille " + l);
    eventHistory.forEach(function(evt, i) {
      log("evt " + i);
      log(evt);
    });
  }*/

  /* \xC9v\xE9nements, utilis\xE9s pour les undo, en particulier undo pour refaire
   * une action quand une r\xE8gle le permet (utilisation de points de chance, etc..)
   * Champ d'un \xE9v\xE9nement (variables evt en g\xE9n\xE9ral dans le code):
   * id               : identificateur unique (int)
   * type             : description de l'\xE9v\xE9nement (string)
   * affectes         : liste de tokens affect\xE9s par l'\xE9v\xE9nement
   * tokens           : liste des tokens cr\xE9\xE9s
   * deletedTokens    : liste de tokens effac\xE9s
   * !!!!! -> ne garde pas les tokens effac\xE9s si on n'est pas s\xFBr que son image est au bon endroit. Typiquement, on ne va le faire que pour les tokens cr\xE9es dans le script
   * attributes       : liste de attributs cr\xE9\xE9s ou modifi\xE9s
   * deletesAttributes: lites des attributs effac\xE9s
   * characters       : liste des personnages cr\xE9\xE9s
   * characterNames   : liste de character * name
   * defaultTokens    : liste de tokens par d\xE9faut (objet)
   *   (character, defaultToken)
   * deletedCharacters: liste des personnages effac\xE9s
   * combat           : valeur de la variable d'\xE9tat combat
   * updateNextInitSet: valeur de l'ensemble des tokens dont il faut recalculer l'init
   * turnorder        : le turnorder (si il a chang\xE9)
   * initiativepage   : true si le turnorder est actif
   * personnage       : le perso qui 'fait' l'\xE9v\xE9nement
   * succes           : stoque si l'attaque \xE9tait un succ\xE8s (bool)
   * action           : sauvegarde des param\xE8tres de l'evt, pour la rejouer
   *   - caracteristique : carac test\xE9e (pour un jet)
   *   - titre : titre du jet
   *   - playerId : id du joueur qui a lanc\xE9 l'action
   *   - selected : cibles s\xE9lectionn\xE9s des l'action
   *   - attaquant: personnage attaquant (TODO: voir si doublon avec personnage)
   *   - cibles: liste des cibles d'attaque, avec leurs tags
   *   - weaponStats: stats de l'arme (ou attaque) utilis\xE9e
   *   - rolls: les jets de l'action, pour les avoir \xE0 l'identique
   *     les d\xE9g\xE2ts sont stoqu\xE9s dans chaque cible, dans cible.rollsDmg
   *     - attack: les jets de l'attaque
   *     - etat_e_index_targetid: save pour entrer dans l'\xE9tat e
   *     - effet_e_index_targetid: save pour l'effet e
   *     - attaquant_pietinement_targetid: jet de l'attaquant pour le pi\xE9tinement
   *     - defenseur_pietinement_targetid: jet de du d\xE9fenseur pour le pi\xE9tinement
   *   - options : options de l'action
   * attenteResultat  : permet de savoir que le jet est en attente de d\xE9cision pour savoir si c'est un succ\xE8s ou non (quand il n'y a pas de difficult\xE9 donn\xE9e et que le personnage est sous l'emprise d'une mal\xE9diction)
   */

  function addEvent(evt) {
    if (evt.id) {
      error("Tentative d'ajouter un \xE9v\xE9nement d\xE9j\xE0 dans l'historique", evt);
      return;
    }
    evt.id = stateCOF.eventId++;
    eventHistory.push(evt);
    if (eventHistory.length > HISTORY_SIZE) {
      eventHistory.shift();
    }
  }

  function findEvent(id) {
    return eventHistory.find(function(evt) {
      return (evt.id == id);
    });
  }

  function lastEvent() {
    let l = eventHistory.length;
    if (l === 0) return undefined;
    return eventHistory[l - 1];
  }

  function setDefaultTokenFromSpec(character, spec, token) {
    let oldTokenFields = {};
    for (const field in spec) {
      if (field.startsWith('_')) continue;
      if (field == 'imgsrc' || field == 'represents' || field == 'top' ||
        field == 'left' || field == 'page_id' || field == 'layer' ||
        field == 'lastmove') continue;
      let oldValue = token.get(field);
      if (oldValue == spec[field]) continue;
      oldTokenFields[field] = oldValue;
      token.set(field, spec[field]);
    }
    setDefaultTokenForCharacter(character, token);
    for (const otf in oldTokenFields) {
      token.set(otf, oldTokenFields[otf]);
    }
  }

  //Si evt n'est pas d\xE9fini, annule le dernier evt
  function undoEvent(evt) {
    if (evt === undefined) {
      if (eventHistory.length === 0) {
        sendChat('COF', "/w GM Historique d'\xE9v\xE8nements vide");
        return;
      }
      evt = eventHistory.pop();
    } else {
      eventHistory = eventHistory.filter(function(e) {
        return (e.id != evt.id);
      });
    }
    if (evt === undefined) {
      error("No event to undo", eventHistory);
      return;
    }
    sendChat("COF", "/w GM undo " + evt.type);
    if (evt.affectes) undoTokenEffect(evt);
    if (evt.attributes) {
      // some attributes where modified too
      evt.attributes.forEach(function(attr) {
        if (attr.current === undefined) attr.attribute.remove();
        else {
          let aset = {
            current: attr.current
          };
          if (attr.max !== undefined) aset.max = attr.max;
          if (attr.name !== undefined) aset.name = attr.name;
          if (attr.withWorker) attr.attribute.setWithWorker(aset);
          else attr.attribute.set(aset);
        }
      });
    }
    if (evt.characterNames) {
      evt.characterNames.forEach(function(cn) {
        if (cn.name && cn.character)
          cn.character.set('name', cn.name);
      });
    }
    if (evt.defaultTokens) {
      evt.defaultTokens.forEach(function(dt) {
        //On cherche d'abord un token qui repr\xE9sente dt.character
        let tokens = findObjs({
          _type: 'graphic',
          represents: dt.character.id
        });
        if (tokens.length === 0) return;
        setDefaultTokenFromSpec(dt.character, dt.defaultToken, tokens[0]);
      });
    }
    if (evt.deletedTokens) {
      evt.deletedTokens.forEach(function(token) {
        log("Restoring token " + token.name);
        let t = createObj('graphic', token);
        if (token.layer == 'map') toFront(t);
      });
    }
    if (evt.deletedCharacters) {
      evt.deletedCharacters.forEach(function(character) {
        log("Restoring character " + character.name);
        let newCharacter =
          createObj('character', {
            name: character.name,
            avatar: character.avatar
          });
        let charId = newCharacter.id;
        let tokens = findObjs({
          _type: 'graphic',
          represents: character.id
        });
        tokens.forEach(function(tok) {
          tok.set('represents', charId);
        });
        eventHistory.forEach(function(evt2) {
          if (evt2.characters) {
            evt2.characters = evt2.characters.map(function(oldCharac) {
              if (oldCharac.id == character.id) return newCharacter;
              return oldCharac;
            });
          }
          if (evt2.deletedAttributes) {
            evt2.deletedAttributes.forEach(function(attr) {
              if (attr.get('characterid') == character.id) attr.newCharId = charId;
            });
          }
        });
        if (evt.deletedAttributes) {
          evt.deletedAttributes.forEach(function(attr) {
            if (attr.get('characterid') == character.id) {
              attr.newCharId = charId;
            }
          });
        }
        //Maintenant on remet les attributs
        if (character.attributes) {
          character.attributes.forEach(function(attr) {
            let oldId = attr.id;
            let newAttr = createObj('attribute', {
              characterid: charId,
              name: attr.get('name'),
              current: attr.get('current'),
              max: attr.get('max')
            });
            eventHistory.forEach(function(evt) {
              if (evt.attributes) {
                evt.attributes.forEach(function(attr) {
                  if (attr.attribute.id == oldId) attr.attribute = newAttr;
                });
              }
            });
            tokens.forEach(function(tok) {
              if (tok.get('bar1_link') == oldId)
                tok.set('bar1_link', newAttr.id);
            });
          });
        }
        if (character.abilities) {
          character.abilities.forEach(function(ab) {
            createObj('ability', {
              characterid: charId,
              name: ab.get('name'),
              action: ab.get('action'),
              istokenaction: ab.get('istokenaction')
            });
          });
        }
        // On le remet chez ses alli\xE9s
        if (character.allies.length > 0) {
          Object.values(character.allies).forEach(function(allie) {
            let alliesPerso = alliesParPerso[allie] || new Set();
            alliesPerso.add(charId);
            alliesParPerso[allie] = alliesPerso;
          });
        }
      });
    }
    // deletedAttributes have a quadratic cost in the size of the history
    if (evt.deletedAttributes) {
      evt.deletedAttributes.forEach(function(attr) {
        let oldId = attr.id;
        let nameDel = attr.get('name');
        log("Restoring attribute " + nameDel);
        let newAttr =
          createObj('attribute', {
            characterid: attr.newCharId || attr.get('characterid'),
            name: nameDel,
            current: attr.get('current'),
            max: attr.get('max')
          });
        eventHistory.forEach(function(evt) {
          if (evt.attributes !== undefined) {
            evt.attributes.forEach(function(attr2) {
              if (attr2.attribute && attr2.attribute.id == oldId) attr2.attribute = newAttr;
            });
          }
        });
      });
    }
    if (evt.characters) {
      evt.characters.forEach(function(character) {
        let charId = character.id;
        findObjs({
          _type: 'attribute',
          _characterid: charId
        }).forEach(function(attr) {
          attr.remove();
        });
        findObjs({
          _type: 'ability',
          _characterid: charId
        }).forEach(function(ab) {
          ab.remove();
        });
        character.remove();
      });
    }
    if (evt.tokens) {
      evt.tokens.forEach(function(token) {
        if (stateCOF.tokensTemps) {
          stateCOF.tokensTemps = stateCOF.tokensTemps.filter(function(tt) {
            return tt.tid != token.id;
          });
        }
        token.remove();
      });
    }
    if (evt.movedTokens) {
      evt.movedTokens.forEach(function(movedToken) {
        movedToken.token.set('left', movedToken.oldPosition.left);
        movedToken.token.set('top', movedToken.oldPosition.top);
      });
    }
    if (_.has(evt, 'combat')) {
      let combat = stateCOF.combat;
      //regarde si le token actif a chang\xE9
      if (evt.combat &&
        (!combat || evt.combat.activeTokenId != combat.activeTokenId) &&
        stateCOF.options.affichage.val.init_dynamique.val) {
        let activeToken = getObj('graphic', evt.combat.activeTokenId);
        if (activeToken) {
          threadSync++;
          activateRoundMarker(threadSync, activeToken);
        }
      }
      stateCOF.combat = evt.combat;
    }
    if (_.has(evt, 'updateNextInitSet'))
      updateNextInitSet = evt.updateNextInitSet;
    if (_.has(evt, 'turnorder')) Campaign().set('turnorder', evt.turnorder);
    if (_.has(evt, 'initiativepage'))
      Campaign().set('initiativepage', evt.initiativepage);
    if (evt.chargeFantastique)
      stateCOF.chargeFantastique = evt.chargeFantastique;
    if (evt.deletedTokensTemps && evt.deletedTokensTemps.length > 0) {
      stateCOF.tokensTemps = stateCOF.tokensTemps || [];
      evt.deletedTokensTemps.forEach(function(tt) {
        log("Restoring temp token " + tt.deletedToken.name);
        let t = createObj('graphic', tt.deletedToken);
        if (tt.deletedToken.layer == 'map') toFront(t);
        delete tt.deletedToken;
        tt.tid = t.id;
        stateCOF.tokensTemps.push(tt);
      });
    }
    if (evt.tokensTemps) { //ceux pour lesquels on a diminu\xE9 la dur\xE9e
      evt.tokensTemps.forEach(function(tt) {
        if (tt.tt) tt.tt.duree = tt.ancienneDuree;
      });
    }
  }

  //origin peut \xEAtre un message ou un nom de joueur
  function sendPlayer(origin, msg, playerId) {
    let dest = origin;
    if (origin.who) {
      playerId = playerId || getPlayerIdFromMsg(origin);
      if (playerIsGM(playerId)) dest = 'GM';
      else dest = origin.who;
    }
    if (dest.includes('"')) {
      sendChat('COF', msg);
      log("Impossible d'envoyer des messages priv\xE9s \xE0 " + dest + " car le nom contient des guillemets");
    }
    sendChat('COF', '/w "' + dest + '" ' + msg);
  }

  function sendPlayerAndGM(origin, playerId, msg) {
    sendPlayer(origin, msg, playerId);
    if (playerIsGM(playerId)) return;
    sendChat('COF', '/w GM ' + msg);
  }

  function isCarac(x) {
    switch (x) {
      case 'FOR':
      case 'DEX':
      case 'CON':
      case 'SAG':
      case 'INT':
      case 'CHA':
        return true;
      default:
        return false;
    }
  }

  function deCarac(x) {
    switch (x) {
      case 'FOR':
        return "de force";
      case 'DEX':
        return "de dext\xE9rit\xE9";
      case 'CON':
        return "de constitution";
      case 'SAG':
        return "de sagesse";
      case 'INT':
        return "d'intelligence";
      case 'CHA':
        return "de charisme";
      default:
        return "de " + x;
    }
  }

  //msg peut \xEAtre un message ou un playerId
  function peutController(msg, perso) {
    if (msg === undefined) return true;
    let playerId = getPlayerIdFromMsg(msg);
    if (playerIsGM(playerId)) return true;
    if (msg.selected && msg.selected.length > 0) {
      if (perso.token.id == msg.selected[0]._id) return true;
      let selectedPerso = persoOfId(msg.selected[0]._id);
      if (selectedPerso !== undefined && selectedPerso.charId == perso.charId) return true;
    }
    let character = getObj('character', perso.charId);
    if (character === undefined) return false;
    let cb = character.get('controlledby');
    let res = cb.split(',').find(function(pid) {
      if (pid == 'all') return true;
      return (pid == playerId);
    });
    return (res !== undefined);
  }

  // !cof-confirmer-attaque evtid
  function confirmerAttaque(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "Trop tard pour continuer l'attaque, on est hors combat");
      return;
    }
    let cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-confirmer-attaque", cmd);
      return;
    }
    let evt = findEvent(cmd[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
      return;
    }
    let action = evt.action;
    if (action === undefined) {
      error("Erreur interne du bouton de confirmation: l'\xE9v\xE8nement n'a pas d'action", cmd);
      return;
    }
    let options = action.currentOptions || {};
    let playerId = getPlayerIdFromMsg(msg);
    let ctrl = playerIsGM(playerId);
    if (!ctrl && options.preDmg) {
      let tokens = _.allKeys(options.preDmg);
      ctrl = tokens.every(function(tid) {
        let perso = persoOfId(tid);
        if (perso === undefined) return true;
        let character = getObj('character', perso.charId);
        if (character === undefined) return true;
        let cb = character.get('controlledby');
        let res = cb.split(',').find(function(pid) {
          return (pid == 'all' || pid == playerId);
        });
        return (res !== undefined);
      });
    }
    if (!ctrl) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton", playerId);
      return;
    }
    options.rolls = action.rolls;
    options.choices = action.choices || {};
    options.choices.Continuer = true;
    resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, options, evt, action.explications, action.pageId, action.cibles);
  }

  function undoTokenEffect(evt) {
    let HTdeclared;
    try {
      HTdeclared = HealthColors;
    } catch (e) {
      if (e.name != "ReferenceError") throw (e);
    }
    _.each(evt.affectes, function(aff) {
      let prev = aff.prev;
      let tok = aff.affecte;
      if (prev === undefined || tok === undefined) {
        error("Pas d'\xE9tat pr\xE9c\xE9dant", aff);
        return;
      }
      let prevTok;
      if (HTdeclared) prevTok = JSON.parse(JSON.stringify(tok));
      _.each(prev, function(val, key) {
        tok.set(key, val);
      });
      if (HTdeclared) HealthColors.Update(tok, prevTok);
      sendChat("COF", "\xC9tat de " + tok.get("name") + " restaur\xE9.");
    });
  }

  function boutonSimple(action, texte, style) {
    action = action.replace(/%/g, '&#37;').replace(/\)/g, '&#41;').replace(/\?/g, '&#63;').replace(/@/g, '&#64;').replace(/\[/g, '&#91;').replace(/]/g, '&#93;').replace(/"/g, '&#34;').replace(/{/g, '&#123;').replace(/}/g, '&#125;').replace(/\|/g, '&#124;').replace(/\*/g, '&#42;');
    action = action.replace(/\'/g, '&apos;'); // escape quotes
    action = action.replace(/:/g, '&amp;#58;'); // double escape colon
    style = style || '';
    return '<a href="' + action + '"' + style + '>' + texte + '</a>';
  }

  // on, remplace tous les selected par @{character name|attr}
  function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
  }

  //Remplace une macro ou ability par sa d\xE9finition (r\xE9cursivement)
  function replaceAction(action, perso, macros, abilities) {
    let remplacement = false;
    if (action.indexOf('#') >= 0) {
      macros = macros || findObjs({
        _type: 'macro'
      });
      macros.forEach(function(m, i) {
        let mName = m.get('name');
        if (mName === '') return;
        mName = '#' + mName;
        if (action.indexOf(mName) >= 0) {
          mName = new RegExp(mName + "\\b", "g");
          action = action.replace(mName, m.get('action'));
          if (!remplacement)
            macros = macros.filter(function(m, k) {
              return (k != i);
            }); //Pour \xE9viter la r\xE9cursion
          remplacement = true;
        }
      });
    }
    if (action.indexOf('%') >= 0) {
      abilities = abilities || findObjs({
        _type: 'ability',
        _characterid: perso.charId
      });
      abilities.forEach(function(a, i) {
        let aName = a.get('name');
        if (aName === '') return;
        let daName = '%' + aName;
        if (action.indexOf(daName) >= 0) {
          action = action.replace(daName, a.get('action'));
          if (!remplacement) abilities = abilities.splice(i); //Pour \xE9viter la r\xE9cursion
          remplacement = true;
        }
        daName = '%{selected|' + aName + '}';
        if (action.indexOf(daName) >= 0) {
          action = action.replace(daName, a.get('action'));
          if (!remplacement)
            abilities = abilities.filter(function(m, k) {
              return (k != i);
            }); //Pour \xE9viter la r\xE9cursion
          remplacement = true;
        }
      });
    }
    if (remplacement) return replaceAction(action, perso, macros, abilities);
    return action;
  }

  function identifierArme(weaponStats, pred, nom, pattern) {
    let p = pred[nom] ||
      (weaponStats.name.search(pattern) > -1) ||
      (weaponStats.modificateurs.search(pattern) > -1);
    if (p) {
      weaponStats[nom] = true;
    }
  }

  function fieldAsString(obj, field, def) {
    let res = obj[field];
    if (res === undefined) return def;
    return res;
  }


  function fieldAsInt(obj, field, def) {
    let res = obj[field];
    if (res === undefined) return def;
    return toInt(res, def);
  }

  function armeDeCreatureFeerique(perso, weaponStats, dice) {
    if (!predicateAsBool(perso, 'tropPetit')) return;
    if (attributeAsBool(perso, 'grandeTaille')) return;
    weaponStats.addNbDice = 1;
    weaponStats.attDice = dice;
    if (!predicateAsBool(perso, 'lutinGrosBill') || weaponStats.attCarBonus == '@{FOR}')
      weaponStats.attCarBonus = '';
  }

  //perso peut ne pas avoir de token
  function getWeaponStats(perso, attackLabel) {
    let weaponStats = {
      name: 'Attaque',
      attSkill: '@{ATKCAC}',
      attNbDices: 1,
      attDice: 4,
      attDMBonusCommun: 0,
      crit: 20,
      divers: '',
      portee: 0,
      typeDegats: 'contondant',
      options: '',
    };
    if (attackLabel === undefined) return weaponStats;
    let attaques = listAllAttacks(perso);
    let att = attaques[attackLabel];
    if (att === undefined) {
      weaponStats.name = attackLabel;
      return weaponStats;
    }
    weaponStats.label = attackLabel;
    weaponStats.name = att.armenom;
    weaponStats.attNbDices = fieldAsInt(att, 'armedmnbde', 1);
    weaponStats.attDice = fieldAsInt(att, 'armedmde', 4);
    weaponStats.crit = fieldAsInt(att, 'armecrit', 20);
    weaponStats.divers = fieldAsString(att, 'armespec', '');
    if (persoEstPNJ(perso)) {
      weaponStats.attSkill = fieldAsInt(att, 'armeatk', 0);
      weaponStats.attDMBonusCommun = fieldAsInt(att, 'armedm', 0);
    } else {
      weaponStats.attSkill = fieldAsString(att, 'armeatk', '@{ATKCAC}');
      weaponStats.attSkillDiv = fieldAsInt(att, 'armeatkdiv', 0);
      weaponStats.attCarBonus = fieldAsString(att, 'armedmcar', '@{FOR}');
      weaponStats.attDMBonusCommun = fieldAsInt(att, 'armedmdiv', 0);
    }
    weaponStats.portee = fieldAsInt(att, 'armeportee', 0);
    weaponStats.typeAttaque = fieldAsString(att, 'armetypeattaque', 'Naturel');
    weaponStats.modificateurs = fieldAsString(att, 'armemodificateurs', '');
    weaponStats.typeDegats = fieldAsString(att, 'armetypedegats', 'tranchant');
    weaponStats.options = fieldAsString(att, 'armeoptions', '');
    weaponStats.options = weaponStats.options.trim();
    weaponStats.predicats = fieldAsString(att, 'armepredicats', '');
    switch (weaponStats.typeAttaque) {
      case 'Naturel':
        weaponStats.armeNaturelle = true;
        break;
      case 'Arme 1 main':
        weaponStats.arme = true;
        armeDeCreatureFeerique(perso, weaponStats, 3);
        break;
      case 'Arme 2 mains':
        weaponStats.arme = true;
        weaponStats.deuxMains = true;
        armeDeCreatureFeerique(perso, weaponStats, 4);
        break;
      case 'Sortilege':
        weaponStats.sortilege = true;
        break;
      case 'Arme gauche':
        weaponStats.armeGauche = true;
        armeDeCreatureFeerique(perso, weaponStats, 3);
        break;
      case 'Arme de jet':
        weaponStats.armeDeJet = true;
        weaponStats.tauxDePerte = fieldAsInt(att, 'armejettaux', 0);
        weaponStats.nbArmesDeJet = fieldAsInt(att, 'armejetqte', 1);
        weaponStats.nbArmesDeJetMax = fieldAsInt(att, 'armejetqte_max', 1);
        weaponStats.prefixe = att.prefixe; //pour trouver l'attribut
        armeDeCreatureFeerique(perso, weaponStats, 3);
        break;
      default:
        //On cherche si c'est une arme \xE0 2 mains
        //Ne devrait pas servir, on a toujours un type, maintenant
        let t = weaponStats.name.toLowerCase();
        if (t.includes('2 mains') || t.includes('deux mains')) {
          weaponStats.deuxMains = true;
        } else {
          t = weaponStats.divers;
          if (t) {
            t = t.toLowerCase();
            if (t.includes('2 mains') || t.includes('deux mains')) {
              weaponStats.deuxMains = true;
            }
          }
        }
    }
    //Informations dans le champ sp\xE9cial
    let champDivers = weaponStats.divers;
    if (champDivers === '') champDivers = weaponStats.predicats;
    else if (weaponStats.predicats !== '')
      champDivers += '\n' + weaponStats.predicats;
    let pred = predicateOfRaw(champDivers);
    //On transfert les pr\xE9dicats connus dans weaponStats
    if (pred.charge) weaponStats.charge = toInt(pred.charge, 1);
    weaponStats.eclaire = toInt(pred.eclaire);
    weaponStats.eclaireFaible = toInt(pred.eclaireFaible);
    weaponStats.batarde = pred.batarde;
    if (weaponStats.batarde && weaponStats.deuxMains) {
      error("L'arme " + weaponStats.name + " est d\xE9clar\xE9e comme bat\xE2rde, il faudrait en faire une arme \xE0 une main par d\xE9faut", weaponStats);
      weaponStats.deuxMains = undefined;
    }
    if (pred.armeDeGrand) {
      weaponStats.armeDeGrand = true;
      let taille = taillePersonnage(perso, 4);
      if (taille < 5) weaponStats.deuxMains = true;
      else weaponStats.deuxMains = false;
    }
    //Identification des cat\xE9gories d'armes utilis\xE9es en jeu
    identifierArme(weaponStats, pred, 'arc', /\barc\b/i);
    identifierArme(weaponStats, pred, 'arbalete', /\barbal[e\xE8]te\b/i);
    identifierArme(weaponStats, pred, 'baton', /\bb[a\xE2]ton\b/i);
    identifierArme(weaponStats, pred, 'hache', /\bhache\b/i);
    identifierArme(weaponStats, pred, 'epee', /\b[e\xE9]p[e\xE9]e\b/i);
    identifierArme(weaponStats, pred, 'epieu', /\b[e\xE9]pieu\b/i);
    identifierArme(weaponStats, pred, 'fronde', /\bfronde\b/i);
    identifierArme(weaponStats, pred, 'marteau', /\bmarteau\b/i);
    identifierArme(weaponStats, pred, 'masse', /\bmasse\b/i);
    identifierArme(weaponStats, pred, 'rapiere', /\brapi[e\xE8]re\b/i);
    identifierArme(weaponStats, pred, 'poudre', /\bpoudre\b/i);
    identifierArme(weaponStats, pred, 'sabre', /\b(katana|wakizachi|boken|demi-lame|vivelame|sabre)\b/i);
    if (weaponStats.arc && predicateAsBool(perso, 'arcDeMaitre')) {
      weaponStats.portee += 20;
    }
    return weaponStats;
  }

  function depenseManaPossible(personnage, cout, msg) {
    if (isNaN(cout) || cout === 0) return {
      cout_nul: true
    };
    let token = personnage.token;
    let charId = personnage.charId;
    let manaAttr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: 'PM'
    }, {
      caseInsensitive: true
    });
    let hasMana = false;
    if (manaAttr.length > 0) {
      let manaMax = parseInt(manaAttr[0].get('max'));
      hasMana = !isNaN(manaMax) && manaMax > 0;
    }
    if (hasMana) {
      let bar2;
      if (token) {
        bar2 = parseInt(token.get('bar2_value'));
        if (isNaN(bar2)) {
          if (token.get('bar1_link') === '') bar2 = 0;
          else { //devrait \xEAtre li\xE9 \xE0 la mana courante
            sendPerso(personnage, "*** Attention, la barre de mana du token n'est pas li\xE9e \xE0 la mana de la fiche ***");
            bar2 = parseInt(manaAttr[0].get('current'));
          }
        }
      } else bar2 = parseInt(manaAttr[0].get('current'));
      msg = msg || '';
      if ((reglesOptionelles.mana.val.contrecoup.val && bar2 <= 0) ||
        (!reglesOptionelles.mana.val.contrecoup.val && !reglesOptionelles.mana.val.brulure_de_magie.val && bar2 < cout)) {
        if (msg) sendPerso(personnage, "n'a pas assez de points de mana pour " + msg);
        return false;
      }
      if (bar2 < cout && (reglesOptionelles.mana.val.contrecoup.val ||
          reglesOptionelles.mana.val.brulure_de_magie.val)) {
        let degats = cout - bar2;
        if (reglesOptionelles.mana.val.brulure_de_magie.val) {
          let famille = ficheAttribute(personnage, 'famille', 'aventurier').trim();
          if (famille == "combattant") degats *= 2;
          degats = Math.ceil(degats / predicateAsInt(personnage, 'coefPVMana', 1));
        }
        let bar1;
        if (token) bar1 = parseInt(token.get('bar1_value'));
        else bar1 = ficheAttributeAsInt(personnage, 'PV', 0);
        if (bar1 < degats) {
          if (msg) sendPerso(personnage, "n'a pas assez de points de mana et de PV pour " + msg);
          return false;
        }
        return {
          pm: 0,
          depense_pm: bar2,
          pv: bar1 - degats,
          depense_pv: degats
        };
      }
      return {
        pm: bar2 - cout,
        depense_pm: cout
      };
    }
    sendPerso(personnage, "n'a pas de points de mana, action impossible");
    return false;
  }

  //depasse est un string qui commence par --depasseLimite
  //args doit \xEAtre d\xE9fini et contient des valeur \xE0 modifier :
  // - mana
  // - text
  function peutDepasserLimite(depasse, perso, attrName, args) {
    let depArg = depasse.split(' ', 3);
    let step = 1;
    if (depArg.length > 1) {
      step = parseInt(depArg[1]);
      if (isNaN(step) || step < 0) step = 1;
    }
    let d = attributeAsInt(perso, 'depasse' + attrName, 0) + step;
    if (d < 1) return true;
    let mana = d;
    if (args.mana !== undefined) {
      args.mana += d;
      mana = args.mana;
    }
    if (depenseManaPossible(perso, mana)) {
      if (args.text) args.text += " (+" + d + "PM)";
      return true;
    }
    return false;
  }

  //options est un tableaux d'options obtenues par split(' --')
  // peut retourner une struct avec champ extraText
  function actionImpossible(perso, options, defResource, tref) {
    let coutMana = 0;
    let ai = options.some(function(opt) {
      opt = opt.trim();
      if (opt === '') return false;
      const cmd = opt.split(' ');
      switch (cmd[0]) {
        case 'si':
          let condition = parseCondition(cmd.slice(1));
          switch (condition.type) {
            case 'etat':
              return !getState(perso, condition.etat);
            case 'attribut':
              if (condition.valeur === undefined)
                return !attributeAsBool(perso, condition.attribute);
              return testAttribut(perso, condition.attrbute, condition.valeur, condition);
          }
          return false;
        case 'mana':
          if (cmd.length < 2) return false;
          let mana = parseInt(cmd[1]);
          if (isNaN(mana) || mana < 0) return false;
          coutMana += mana;
          return !depenseManaPossible(perso, coutMana) ||
            attributeAsBool(perso, 'frappeDesArcanes');
        case 'limiteParJour':
          if (cmd.length < 2) return false;
          let limiteParJour = parseInt(cmd[1]);
          if (isNaN(limiteParJour) || limiteParJour < 1) return false;
          let ressourceParJour = defResource;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            ressourceParJour = cmd.join('_');
          }
          ressourceParJour = 'limiteParJour_' + ressourceParJour;
          if (attributeAsInt(perso, ressourceParJour, limiteParJour) > 0) {
            return false;
          }
          //Reste le cas o\xF9 on peut d\xE9passer cette limite par jour
          let depasse = options.find(function(o) {
            return o.startsWith('depasseLimite ');
          });
          if (depasse) {
            let da = {
              mana: coutMana
            };
            if (tref) da.text = tref.text;
            let dp = peutDepasserLimite(depasse, perso, ressourceParJour, da);
            if (dp) {
              coutMana = da.mana;
              if (tref) tref.text = da.text;
              return false;
            }
            return true;
          }
          return true;
        case 'limiteParCombat':
          if (cmd.length < 2) return false;
          let limiteParCombat = parseInt(cmd[1]);
          if (isNaN(limiteParCombat) || limiteParCombat < 1) return false;
          let ressourceParCombat = defResource;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            ressourceParCombat = cmd.join('_');
          }
          ressourceParCombat = "limiteParCombat_" + ressourceParCombat;
          return attributeAsInt(perso, ressourceParCombat, limiteParCombat) === 0;
        case 'tempsRecharge':
          if (cmd.length < 2) return false;
          let effet = cmd[1];
          if (!estEffetTemp(effet)) return false;
          return attributeAsBool(perso, effet);
        case 'aussiArmeDeJet':
          if (cmd.length < 2) return false;
          let armeAssociee = getWeaponStats(perso, cmd[1]);
          return armeAssociee && armeAssociee.armeDeJet && armeAssociee.nbArmesDeJet < 1;
      }
      return false;
    });
    return ai;
  }

  //Enl\xE8ve les cha\xEEnes de type ?{..} pour \xEAtre s\xFBr que l'action est impossible
  function removeUserInputs(act) {
    let m = act.match(/\?\{[^\}]*\}/g);
    if (!m) return act;
    m.forEach(function(ma) {
      act = act.replace(ma, '');
    });
    return act;
  }

  //Remplis les champs arme et armeGauche de perso
  //renvoie undefined si aucune arme en main principale
  //sinon renvoie l'arme principale
  function armesEnMain(perso) {
    if (perso.armesEnMain) return perso.arme;
    let attr = tokenAttribute(perso, 'armeEnMain');
    if (attr.length > 0) {
      perso.attrArmeEnMain = attr[0];
      let labelArmePrincipale = attr[0].get('current');
      if (labelArmePrincipale) perso.arme = getWeaponStats(perso, labelArmePrincipale);
      let labelArmeGauche = attr[0].get('max');
      if (labelArmeGauche) {
        if (labelArmeGauche == labelArmePrincipale) { //arme tenue \xE0 2 mains
          perso.arme.deuxMains = true;
        } else {
          perso.armeGauche = getWeaponStats(perso, labelArmeGauche);
        }
      } else if (predicateAsBool(perso, 'attaqueAuBouclier') && ficheAttributeAsInt(perso, 'defbouclieron', 0)) {
        //Alors il porte le bouclier en tant qu'arme en main gauche
        perso.armeGauche = getWeaponStats(perso, predicateAsBool(perso, 'attaqueAuBouclier'));
      }
      perso.armesEnMain = 'calculee';
      return perso.arme;
    }
    return;
  }

  function listAllMunitions(perso) {
    if (perso.munitions) return perso.munitions;
    let rawList = extractRepeating(perso, 'munitions');
    let liste = {}; //liste tri\xE9e par label de munition
    for (let pref in rawList) {
      let ra = rawList[pref];
      if (ra.labelmunition === undefined) ra.labelmunition = 0;
      if (liste[ra.labelmunition]) {
        error("Plusieurs munitions de label " + ra.labelmunitions, ra);
        continue;
      }
      ra.prefixe = pref;
      liste[ra.labelmunition] = ra;
    }
    perso.munitions = liste;
    return liste;
  }

  //Les options de l'arme doivent d\xE9j\xE0 \xEAtre dans act
  function demandeMunition(perso, weaponStats, options, act) {
    if (act.includes('--munition')) return act;
    let typeMunition;
    if (weaponStats.arc) typeMunition = 'Fl\xE8che';
    else if (weaponStats.arbalete) typeMunition = 'Carreau';
    else if (weaponStats.poudre) typeMunition = 'Balle';
    else if (weaponStats.fronde) typeMunition = 'Autre'; //TODO: ajouter le type bille sur la fiche
    if (!typeMunition) return act;
    let munitions = listAllMunitions(perso);
    let munitionsDeType = [];
    for (let label in munitions) {
      let munition = munitions[label];
      let tm = fieldAsString(munition, 'typemunition', 'Fl\xE8che');
      if (tm != typeMunition) return;
      let nb = fieldAsInt(munition, 'qtemunition', 1);
      if (nb > 0) munitionsDeType.push(munition);
    }
    if (munitionsDeType.length === 0) return act;
    let demande = ' ?{Munition|Normale,&amp;#32;';
    munitionsDeType.forEach(function(m) {
      demande += '|' +
        fieldAsString(m, 'nommunition', typeMunition + ' ' + m.labelmunition) +
        ', --munition ' + m.labelmunition;
    });
    return act + demande + '}';
  }

  //options peut avoir les champs:
  // - ressource, un attribut
  // - overlay
  // - buttonStyle
  // - attackStats
  // et la fonction peut \xE9crire actionImpossible = true dans options.
  function bouton(action, text, perso, options) {
    if (action === undefined || action.trim() === '') return text;
    else action = action.trim();
    options = options || {};
    //Expansion des macros et abilities
    action = replaceAction(action, perso);
    const tid = perso.token.id;
    if (perso.name === undefined) {
      const character = getObj('character', perso.charId);
      if (character) perso.name = character.get('name');
      else perso.name = nomPerso(perso);
    }
    //Cas de plusieurs actions apr\xE8s expansion
    let actions = action.split('\n');
    //Cherche le picto et le style
    let style = '';
    let picto = '';
    let groupe; //Pour g\xE9n\xE9rer un bouton d'attaque de groupe. \xC0 revoir
    actions = actions.map(function(act) {
      act = act.trim();
      if (act.startsWith("/as ")) {
        act = "!cof-as" + act.substring(3);
      }
      if (act.charAt(0) == '!') {
        if (act.startsWith('!cof-')) {
          let actSansChoix = removeUserInputs(act);
          const args = actSansChoix.split(' --');
          let defRessource = '';
          if (act.startsWith('!cof-guerison ')) defRessource = 'gu\xE9rison';
          let dai = {
            text
          };
          if (actionImpossible(perso, args, defRessource, dai))
            options.actionImpossible = true;
          else text = dai.text;
          if (!options.actionImpossible) {
            if (act.startsWith('!cof-soin ') && !actSansChoix.includes('--limitePar') && !actSansChoix.includes('--dose')) { //Limitations sp\xE9ficiques
              let rangSoin = predicateAsInt(perso, 'voieDesSoins', 0);
              let cmd = args[0].split(' ');
              if (cmd.includes('leger')) {
                let soinsLegers = attributeAsInt(perso, 'soinsLegers', 0);
                if (soinsLegers >= rangSoin) {
                  //Peut-\xEAtre qu'on peut encore d\xE9passer la limite
                  let depasse = actSansChoix.indexOf('--depasseLimite ');
                  if (depasse > 0) {
                    let dp = {
                      text
                    };
                    let pdl =
                      peutDepasserLimite(actSansChoix.substring(depasse), perso, 'soinsLegers', dp);
                    if (pdl) text = dp.text;
                    else options.actionImpossible = true;
                  } else options.actionImpossible = true;
                }
              } else if (cmd.includes('modere')) {
                let soinsModeres = attributeAsInt(perso, 'soinsModeres', 0);
                if (soinsModeres >= rangSoin) {
                  //Peut-\xEAtre qu'on peut encore d\xE9passer la limite
                  let depasse = actSansChoix.indexOf('--depasseLimite ');
                  if (depasse > 0) {
                    let dp = {
                      text
                    };
                    let pdl =
                      peutDepasserLimite(actSansChoix.substring(depasse), perso, 'soinsModeres', dp);
                    if (pdl) text = dp.text;
                    else options.actionImpossible = true;
                  } else options.actionImpossible = true;
                }
              }
            } else if (act.startsWith('!cof-recharger ')) {
              let cmd = act.split(' ');
              if (cmd.length > 1) {
                let attackLabel = cmd[1];
                let arme = getWeaponStats(perso, attackLabel);
                if (arme !== undefined && arme.charge) {
                  let currentCharge = attributeAsInt(perso, 'charge_' + attackLabel, 0);
                  if (currentCharge >= arme.charge)
                    options.actionImpossible = true;
                }
              }
            } else if (act.startsWith('!cof-attack ')) {
              let cmd = act.split(' ');
              if (cmd.length > 3 && cmd[3] == '-1') {
                //Selon l'arme en main, une action peut \xEAtre possible ou non
                let weaponStats = armesEnMain(perso);
                if (weaponStats) {
                  options.attackStats = options.attackStats || weaponStats;
                  options.actionImpossible =
                    (weaponStats.deuxMains && attributeAsBool(perso, 'espaceExigu')) ||
                    (weaponStats.portee &&
                      (cmd.includes('--attaqueFlamboyante') || cmd.includes('--seulementContact'))) ||
                    (cmd.includes('--ricochets') && !(weaponStats.armeDeJet || weaponStats.options.includes('--aussiArmeDeJet')));
                }
              }
              options.actionImpossible = options.actionImpossible ||
                (actSansChoix.includes(' --frappeDesArcanes') && attributeAsBool(perso, 'frappeDesArcanes'));
            }
          }
          if (options.ressource) act += " --decrAttribute " + options.ressource.id;
          if (picto === '') {
            // Pictos : https://wiki.roll20.net/CSS_Wizardry#Pictos
            let typeAction = act.split(' ', 1)[0].substring(5);
            switch (typeAction) {
              case 'attack':
              case 'attaque':
              case 'confirmer-attaque':
              case 'explosion':
                let portee = 0;
                let sortilege;
                let cmd = args.shift().split(' ');
                let attackStats = options.attackStats;
                if (attackStats === undefined) {
                  let attackLabel;
                  if (typeAction == 'explosion' && cmd.length > 1) {
                    attackLabel = cmd[1].trim();
                  } else if (cmd.length > 3) {
                    attackLabel = cmd[3].trim();
                  }
                  if (attackLabel && !attackLabel.startsWith('?{')) {
                    attackStats = getWeaponStats(perso, attackLabel);
                  }
                }
                if (attackStats) {
                  portee = attackStats.portee;
                  sortilege = attackStats.sortilege;
                  if (attackStats.options) {
                    let firstOptionIndex = act.indexOf(' --');
                    if (firstOptionIndex > 0) {
                      act = act.substring(0, firstOptionIndex) + ' --attaqueOptions ' + attackStats.options + act.substring(firstOptionIndex);
                    } else {
                      act += ' --attaqueOptions ' + attackStats.options;
                    }
                  }
                  act = demandeMunition(perso, attackStats, options, act);
                }
                //On cherche la port\xE9e dans les options (\xE7a a la priorit\xE9)
                args.forEach(function(o) {
                  if (o.startsWith('portee ')) {
                    let p = parseInt(o.substring(7));
                    if (!isNaN(p) && p >= 0) portee = p;
                  }
                });
                if (sortilege || act.indexOf(' --sortilege') !== -1) {
                  // attaque magique
                  picto = '<span style="font-family: \'Pictos Three\'">g</span> ';
                  style = 'background-color:#9900ff';
                } else if (portee > 0) {
                  // attaque distance
                  picto = '<span style="font-family: \'Pictos Custom\'">[</span> ';
                  style = 'background-color:#48b92c';
                } else {
                  // attaque contact
                  picto = '<span style="font-family: \'Pictos Custom\'">t</span> ';
                  style = 'background-color:#cc0000';
                }
                break;
              case 'lancer-sort':
              case 'injonction':
              case 'injonction-mortelle':
              case 'attaque-magique':
              case 'tueur-fantasmagorique':
              case 'mot-de-pouvoir-immobilise':
              case 'animation-des-objets':
              case 'sphere-de-feu':
                picto = '<span style="font-family: \'Pictos Three\'">g</span> ';
                style = 'background-color:#9900ff';
                break;
              case 'soin':
              case 'transe-guerison':
              case 'delivrance':
              case 'guerir':
              case 'guerison':
              case 'consommer-baie':
                picto = '<span style="font-family: \'Pictos\'">k</span> ';
                style = 'background-color:#ffe599;color:#333';
                break;
              case 'effet':
              case 'effet-temp':
              case 'effet-combat':
              case 'set-state':
              case 'lumiere':
                if (act.includes(' --mana')) {
                  picto = '<span style="font-family: \'Pictos Three\'">g</span> ';
                  style = 'background-color:#9900ff';
                } else {
                  picto = '<span style="font-family: \'Pictos\'">S</span> ';
                  style = 'background-color:#4a86e8';
                }
                break;
              case 'fortifiant':
                picto = '<span style="font-family: \'Pictos\'">S</span> ';
                style = 'background-color:#4a86e8';
                break;
              case 'enduire-poison':
                picto = '<span style="font-family: \'Pictos Three\'">i</span> ';
                style = 'background-color:#05461c';
                break;
              case 'desarmer':
                picto = '<span style="font-family: \'Pictos Custom\'">t</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'surprise':
                picto = '<span style="font-family: \'Pictos\'">e</span> ';
                style = 'background-color:#4a86e8';
                break;
              case 'recharger':
                picto = '<span style="font-family: \'Pictos\'">0</span> ';
                style = 'background-color:#e69138';
                break;
              case 'action-defensive':
                picto = '<span style="font-family: \'Pictos Three\'">b</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'manoeuvre':
                picto = '<span style="font-family: \'Pictos Three\'">d</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'attendre':
              case 'tour-suivant':
                picto = '<span style="font-family: \'Pictos\'">t</span> ';
                style = 'background-color:#999999';
                break;
              case 'dmg':
              case 'bouton-echec-total':
                picto = '<span style="font-family: \'Pictos\'">\'</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'peur':
                picto = '<span style="font-family: \'Pictos\'">`</span> ';
                style = 'background-color:#B445FE';
                break;
              case 'consommables':
                picto = '<span style="font-family: \'Pictos\'">b</span> ';
                style = 'background-color:#ce0f69';
                break;
              case 'liste-actions':
                picto = '<span style="font-family: \'Pictos\'">l</span> ';
                style = 'background-color:#272751';
                break;
            }
          }
        } else if (!act.startsWith('!&#13')) return act; //On ne touche pas aux commandes des autres scripts
      } else {
        if (options.ressource) {
          act = "!cof-utilise-consommable " + tid + ' ' + options.ressource.id + ' ' + act;
          picto = '<span style="font-family: \'Pictos\'">b</span> ';
          style = 'background-color:#ce0f69';
        } else {
          act = "!cof-lancer-sort " + act;
          picto = '<span style="font-family: \'Pictos Three\'">g</span> ';
          style = 'background-color:#9900ff';
        }
      }
      if (act.indexOf('@{selected') !== -1) {
        // cas sp\xE9cial pour @{selected|token_id} o\xF9 l'on remplace toutes les occurences par token.id
        act = act.replace(new RegExp(escapeRegExp('@{selected|token_id}'), 'g'), tid);
        act = act.replace(new RegExp(escapeRegExp('@{selected|token_name}'), 'g'), nomPerso(perso));
        let tmp = act.split('@{selected');
        tmp.forEach(function(elem) {
          if (elem.startsWith('|')) {
            // attribut demand\xE9
            let attribute_name = elem.substring(0, elem.indexOf("}")).substr(1);
            let carac = caracOfMod(attribute_name);
            let replacement;
            if (carac) {
              replacement = modCarac(perso, carac);
            } else {
              let attrs = findObjs({
                _type: 'attribute',
                _characterid: perso.charId,
                name: attribute_name
              });
              if (attrs.length === 0)
                replacement = '@{' + perso.name + '|' + attribute_name + '}';
              else
                replacement = attrs[0].get('current');
            }
            act = act.replace(new RegExp(escapeRegExp('@{selected|' + attribute_name + '}'), 'g'), replacement);
          }
        });
      }
      if (act.startsWith('!cof-lancer-sort') && act.indexOf('--lanceur') == -1) {
        act += " --lanceur " + tid;
      }
      if (act.indexOf('@{target|') == -1 &&
        act.indexOf('cof-lancer-sort') == -1 &&
        act.indexOf('cof-surprise') == -1 &&
        act.indexOf('cof-attack') == -1 &&
        act.indexOf('cof-soin') == -1 &&
        act.indexOf('cof-guerison') == -1 &&
        act.indexOf('cof-as ') == -1 &&
        act.indexOf('cof-jouer-son ') == -1 &&
        act.indexOf('cof-utilise-consommable ') == -1 &&
        act.indexOf('--equipe') == -1 &&
        act.indexOf('--enVue') == -1 &&
        act.indexOf('--disque') == -1 &&
        act.indexOf('--target ' + tid) == -1) {
        //Si on n'a pas de cible, on fait comme si le token \xE9tait s\xE9lectionn\xE9.
        let add_token = " --target " + tid;
        if (act.indexOf(' --allie') >= 0) {
          if (act.indexOf('--lanceur') == -1)
            add_token = " --lanceur " + tid;
          else add_token = ""; //La cible sont les alli\xE9s de --lanceur.
        }
        if (act.indexOf(' --message ') != -1) act = act.replace(' --message ', add_token + ' --message ');
        else act += add_token;
      }
      return act;
    });
    text = picto + text;
    let buttonStyle = '';
    if (options.buttonStyle) buttonStyle = ' style="' + options.buttonStyle + '"';
    else if (style !== '') buttonStyle = ' style="' + style + '"';
    let overlay = '';
    if (options.overlay) overlay = ' title="' + options.overlay + '"';
    if (actions.length == 1) {
      action = actions[0];
      let toReturn = boutonSimple(action, text, buttonStyle + overlay);
      if (groupe) {
        toReturn += "<br/>" + boutonSimple(action + " --attaqueDeGroupe ?{Attaque en groupe ?}", text + " (groupe)", buttonStyle + overlay);
      }
      return toReturn;
    } else {
      action = "!cof-multi-command " + actions.join(' --cof-multi-command ');
      return boutonSimple(action, text, buttonStyle + overlay);
    }
  }

  function improve_image(image_url) {
    if (image_url) {
      image_url = image_url.replace('/med.png', '/thumb.png');
      image_url = image_url.replace('/max.png', '/thumb.png');
      let index = image_url.indexOf('?');
      if (index > 0) image_url = image_url.substring(0, index);
      return image_url;
    }
  }

  //Fonction s\xE9par\xE9e pour pouvoir envoyer un frame \xE0 plusieurs joueurs
  // playerId peut \xEAtre undefined (en particulier pour envoyer au mj)
  function addFramedHeader(display, playerId, chuchote) {
    let perso1 = display.perso1;
    let perso2 = display.perso2;
    let action = display.action;
    let playerBGColor = '#333';
    let playerTXColor = '#FFF';
    let displayname;
    let player;
    if (playerId) player = getObj('player', playerId);
    if (player !== undefined) {
      playerBGColor = player.get("color");
      playerTXColor = (getBrightness(playerBGColor) < 50) ? "#FFF" : "#000";
      displayname = player.get('displayname');
    }
    let res = '/direct ';
    if (chuchote) {
      let who;
      if (chuchote !== true) who = chuchote;
      else who = displayname;
      if (who) res = '/w "' + who + '" ';
      else chuchote = false;
    }
    let name1, name2 = '';
    let avatar1, avatar2;
    if (perso2) {
      let img2;
      if (stateCOF.options.affichage.val.avatar_dans_cadres.val || !perso2.token) {
        let character2 = getObj('character', perso2.charId);
        if (character2) img2 = improve_image(character2.get('avatar'));
      } else img2 = improve_image(perso2.token.get('imgsrc'));
      if (img2) {
        avatar2 = '<img src="' + img2 + '" style="width: 50%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
        name2 = '<b>' + nomPerso(perso2) + '</b>';
      }
    }
    if (perso1) {
      let img1;
      if (stateCOF.options.affichage.val.avatar_dans_cadres.val || !perso1.token) {
        let character1 = getObj('character', perso1.charId);
        if (character1) img1 = improve_image(character1.get('avatar'));
      } else img1 = improve_image(perso1.token.get('imgsrc'));
      if (img1) {
        avatar1 = '<img src="' + img1 + '" style="width: ' + (avatar2 ? 50 : 100) + '%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
        name1 = '<b>' + nomPerso(perso1) + '</b>';
      }
    }
    res +=
      '<div class="all_content" style="-webkit-box-shadow: 2px 2px 5px 0px rgba(0,0,0,0.75); -moz-box-shadow: 2px 2px 5px 0px rgba(0,0,0,0.75); box-shadow: 2px 2px 5px 0px rgba(0,0,0,0.75); border: 1px solid #000; border-radius: 6px; -moz-border-radius: 6px; -webkit-border-radius: 6px; overflow: hidden; position: relative;">';
    if (display.image) {
      res +=
        '<div class="line_header" style="overflow:auto; text-align: center; vertical-align: middle; padding: 5px 5px; border-bottom: 1px solid #000; color: ' + playerTXColor + '; background-color: ' + playerBGColor + ';" title=""> ';
      res += '<img src="' + display.image + '" style="width: ' + 100 + '%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
      res += '</div>';
    } else if (avatar1) {
      res +=
        '<div class="line_header" style="overflow:auto; text-align: center; vertical-align: middle; padding: 5px 5px; border-bottom: 1px solid #000; color: ' + playerTXColor + '; background-color: ' + playerBGColor + ';" title=""> ' +
        '<table>';
      if (avatar2) {
        res +=
          '<tr style="text-align: center">' +
          '<td style="width: 44%; vertical-align: middle;">' + name1 + '</td>' +
          '<td style="width: 12%;height: 28px;line-height: 30px;border: 2px solid #900;border-radius: 100%;position: absolute;margin-top: 25px;font-weight: bold;background-color: #EEE;color: #900;">' + 'VS' + '</td>' +
          '<td style="width: 44%; vertical-align: middle;">' + name2 + '</td>' +
          '</tr>' +
          '<tr style="text-align: center">' +
          '<td style="width: 42%; vertical-align: middle;">' + avatar1 + '</td>' +
          '<td style="width: 16%; vertical-align: middle;">&nbsp;</td>' +
          '<td style="width: 42%; vertical-align: middle;">' + avatar2 + '</td>' +
          '</tr>';
      } else {
        let bar1_info = '',
          bar2_info = '',
          bar3_info = '';
        if (chuchote && perso1.token && peutController(playerId, perso1)) {
          // on chuchote donc on peut afficher les informations concernant les barres du Token
          if (perso1.token.get('bar1_link') === '') {
            bar1_info = '<b>PV</b> : ' + perso1.token.get('bar1_value') + ' / ' + perso1.token.get('bar1_max');
          } else {
            let bar1 = getObj('attribute', perso1.token.get('bar1_link'));
            if (bar1)
              bar1_info = '<b>' + bar1.get('name') + '</b> : ' + bar1.get('current') + ' / ' + bar1.get('max') + '';
          }
          let pvTemporaires = attributeAsInt(perso1, 'PVTemporaires', 0);
          if (pvTemporaires > 0) bar1_info += ' (+' + pvTemporaires + ')';
          if (perso1.token.get('bar2_link') === '') {
            let dmTemp = perso1.token.get('bar2_value');
            if (dmTemp !== '') {
              dmTemp = parseInt(dmTemp);
              if (!isNaN(dmTemp) && dmTemp > 0)
                bar2_info = '<b>DM temp</b> : ' + dmTemp;
            }
          } else {
            let bar2 = findObjs({
              _type: 'attribute',
              _id: perso1.token.get('bar2_link')
            });
            if (bar2 && bar2.length > 0) bar2_info = '<b>' + bar2[0].get('name') + '</b> : ' + bar2[0].get('current') + ' / ' + bar2[0].get('max') + '';
          }
          if (perso1.token.get('bar3_link').length > 0) {
            let bar3 = findObjs({
              _type: 'attribute',
              _id: perso1.token.get('bar3_link')
            });
            if (bar3[0] !== undefined) bar3_info = '<b>' + bar3[0].get('name') + '</b> : ' + bar3[0].get('current') + ' / ' + bar3[0].get('max') + '';
          }
        }
        res +=
          '<tr style="text-align: left">' +
          '<td style="width:25%; vertical-align: middle;">' + avatar1 +
          '</td>' +
          '<td style="width:75%; vertical-align: middle; position: relative;">' +
          '<div>' + name1 + '</div>' +
          '<div style="position: absolute;top: -6px;right: -5px;border: 1px solid #000;background-color: #333;">' +
          '<div style="text-align: right; margin: 0 5px; color: #7cc489">' + bar1_info + '</div>' +
          '<div style="text-align: right; margin: 0 5px; color: #7c9bc4">' + bar2_info + '</div>' +
          '<div style="text-align: right; margin: 0 5px; color: #b21d1d">' + bar3_info + '</div>' +
          '</div>' +
          '</td>' +
          '</tr>';
      }
      res +=
        '</table>' +
        '</div>'; // line_header
    }
    // La ligne de titre
    res +=
      '<div class="line_title" style="font-size: 85%; text-align: left; vertical-align: middle; padding: 5px 5px; border-bottom: 1px solid #000; color: #a94442; background-color: #f2dede;" title=""> ';
    if (display.action_right) {
      res += '<table style="width:100%"><tr><td>' + action + '</td><td style="text-align: right;">' + display.action_right + '</td></tr></table>';
    } else {
      res += action;
    }
    res += '</div>'; // line_title
    res += '<div class="line_content">';
    display.header = res;
  }

  //Si options.chuchote est vrai, la frame est chuchot\xE9e au joueur qui fait l'action
  //Si options.chuchote est un nom, on chuchote la frame \xE0 ce nom
  //Pour retarder la d\xE9cision sur la cible de chuchotement, utiliser options.retarder
  function startFramedDisplay(playerId, action, perso, options) {
    options = options || {};
    if (options.secret) {
      if (playerIsGM(playerId)) {
        if (!options.chuchote) options.chuchote = true;
      } else {
        let character = getObj('character', perso.charId);
        if (character) {
          if (!options.chuchote)
            options.chuchote = '"' + character.get('name') + '"';
          let controledByGM = false;
          let charControlledby = character.get('controlledby');
          charControlledby.split(",").forEach(function(controlledby) {
            if (playerIsGM(controlledby)) controledByGM = true;
          });
          if (!controledByGM) options.retarde = true;
        } else options.retarde = true;
      }
    }
    let display = {
      output: '',
      isOdd: true,
      isfirst: true,
      perso1: perso,
      perso2: options.perso2,
      action: action,
      action_right: options.action_right,
      image: options.image,
      retarde: options.retarde
    };
    if (!options.retarde)
      addFramedHeader(display, playerId, options.chuchote);
    return display;
  }

  function addLineToFramedDisplay(display, line, size, newLine) {
    size = size || 100;
    newLine = (newLine !== undefined) ? newLine : true;
    let background_color, border = '',
      separator = '';
    if (!newLine) display.isOdd = !display.isOdd;
    if (display.isOdd) {
      background_color = "#FFF";
      display.isOdd = false;
    } else {
      background_color = "#f3f3f3";
      display.isOdd = true;
    }
    if (size < 100) background_color = "#fcf8e3";
    if (!display.isfirst) {
      if (newLine) border = "border-top: 1px solid #333;";
    } else display.isfirst = false;
    let formatedLine = '<div style="padding: 0 5px 0; background-color: ' + background_color + '; color: #000;' + border + '">';

    if (!newLine) separator = "border-top: 1px solid #ddd;";
    formatedLine += '<div style="padding: 4px 0; font-size: ' + size + '%;' + separator + '">' + line + '</div>';
    formatedLine += '</div>';
    display.output += formatedLine;
  }

  function startTableInFramedDisplay(display, options) {
    display.output += "<table>";
    display.endColumn = true;
  }

  function endTableInFramedDisplay(display) {
    if (!display.endColumn) display.output += "</tr>";
    display.output += "</table>";
  }

  //newLine indique qu'on commence une nouvelle rang\xE9e
  function addCellInFramedDisplay(display, cell, size, newLine, fond) {
    size = size || 100;
    if (display.endColumn) {
      display.output += '<tr>';
      display.endColumn = false;
    } else if (newLine) display.output += '</tr><tr>';
    let color = '#FFF';
    if (fond) color = "#d3d3d3";
    display.output += '<td style="background-color: ' + color + '; font-size: ' + size + '%;">' + cell + '</td>';
  }

  function endFramedDisplay(display) {
    if (display.header === undefined) {
      error("Pas de titre pour le cadre", display);
      return;
    }
    let res = display.header + display.output;
    res += '</div>'; // line_content
    res += '</div>'; // all_content
    return res;
  }

  function nomLimiteCapa(capa, unite) {
    let nomLimite = 'limitePar';
    switch (unite) {
      case 'tour':
      case 'Tour':
        nomLimite += 'Tour';
        break;
      case 'combat':
      case 'Combat':
        nomLimite += 'Combat';
        break;
      case 'jour':
      case 'Jour':
        nomLimite += 'Jour';
        break;
      default:
        error("Unit\xE9 d'utilisation de capacit\xE9 " + capa + " non reconnue", unite);
        return;
    }
    return nomLimite + '__' + capa;
  }

  function capaciteDisponibleSachantPred(perso, capa, unite) {
    let nomLimite = nomLimiteCapa(capa, unite);
    if (nomLimite === undefined) return false;
    return attributeAsInt(perso, nomLimite, 1) > 0;
  }

  function capaciteDisponible(perso, capa, unite) {
    if (!predicateAsBool(perso, capa)) return false;
    return capaciteDisponibleSachantPred(perso, capa, unite);
  }

  function bonusInteractionsSociales(perso, expliquer) {
    let bonus = 0;
    let perteDeSubstance = predicateAsInt(perso, 'perteDeSubstance', 0);
    if (perteDeSubstance >= 3) {
      if (perteDeSubstance < 7) {
        expliquer("Perte de substance : -2 aux interactions sociales");
        bonus -= 2;
      } else if (perteDeSubstance < 10) {
        expliquer("Perte de substance : -5 aux interactions sociales");
        bonus -= 5;
      } else {
        expliquer("Perte de substance : -10 aux interactions sociales");
        bonus -= 10;
        if (perteDeSubstance >= 15) {
          expliquer("Perte de substance : faire un test de CHA pour se faire remarquer");
        }
      }
    }
    return bonus;
  }

  //expliquer est optionnel, et si pr\xE9sent, il faut msg
  function malusArmure(personnage, expliquer, msg) {
    let malusArmure = 0;
    if (personnage.malusArmure === undefined) {
      if (ficheAttributeAsInt(personnage, 'defarmureon', 0))
        malusArmure += ficheAttributeAsInt(personnage, 'defarmuremalus', 0);
      if (ficheAttributeAsInt(personnage, 'defbouclieron', 0))
        malusArmure += ficheAttributeAsInt(personnage, 'defboucliermalus', 0);
      personnage.malusArmures = malusArmure;
    } else malusArmure = personnage.malusArmure;
    if (expliquer && malusArmure > 0) {
      expliquer("Armure : -" + malusArmure + msg);
    }
    return malusArmure;
  }

  function bonusAuxCompetences(personnage, comp, expliquer) {
    let bonus = 0;
    switch (comp) {
      case 'acrobatie':
      case 'acrobaties':
        {
          if (predicateAsBool(personnage, 'graceFelineVoleur')) {
            let bonusGraceFeline = modCarac(personnage, 'charisme');
            if (bonusGraceFeline > 0) {
              expliquer("Gr\xE2ce f\xE9line : +" + bonusGraceFeline + " en acrobaties");
              bonus += bonusGraceFeline;
            }
          }
          if (predicateAsBool(personnage, 'pirouettes') && malusArmure(personnage) <= 4) {
            expliquer("Pirouettes : +5 en acrobaties");
            bonus += 5;
          }
          let a = predicateAsInt(personnage, 'ameFeline', 0);
          if (a > 0) {
            expliquer("\xC2me f\xE9line : +" + a + " en acrobaties");
            bonus += a;
          }
          break;
        }
      case 'baratiner':
      case 'bluffer':
      case 'convaincre':
        bonus += bonusInteractionsSociales(personnage, expliquer);
        break;
      case 'course':
        {
          if (predicateAsBool(personnage, 'graceFelineVoleur')) {
            let bonusGraceFeline = modCarac(personnage, 'charisme');
            if (bonusGraceFeline > 0) {
              expliquer("Gr\xE2ce f\xE9line : +" + bonusGraceFeline + " en course");
              bonus += bonusGraceFeline;
            }
          }
          let a = predicateAsInt(personnage, 'ameFeline', 0);
          if (a > 0) {
            expliquer("\xC2me f\xE9line : +" + a + " en course");
            bonus += a;
          }
          a = predicateAsInt(personnage, 'vitesseDuFelin', 0);
          if (a > 0) {
            expliquer("Vitesse du f\xE9lin : +" + a + " en course");
            bonus += a;
          }
          break;
        }
      case 'danse':
        if (predicateAsBool(personnage, 'pirouettes') && malusArmure(personnage) <= 4) {
          expliquer("Pirouettes : +5 en danse");
          bonus += 5;
        }
        break;
      case 'discr\xE9tion':
      case 'discretion':
        if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
          expliquer("For\xEAt hostile : -5 en discr\xE9tion");
          bonus -= 5;
        }
        let perteDeSubstance = predicateAsInt(personnage, 'perteDeSubstance', 0);
        if (perteDeSubstance >= 5) {
          if (perteDeSubstance < 7) {
            expliquer("Perte de substance : +2 en discr\xE9tion");
            bonus += 2;
          } else if (perteDeSubstance < 10) {
            expliquer("Perte de substance : +5 en discr\xE9tion");
            bonus += 5;
          } else {
            expliquer("Perte de substance : +10 en discr\xE9tion");
            bonus += 10;
          }
        }
        if (predicateAsBool(personnage, 'toutPetit') && !attributeAsBool(personnage, 'grandeTaille')) {
          expliquer("Tout petit : +5 en discr\xE9tion");
          bonus += 5;
        }
        break;
      case 'intimidation':
        bonus += bonusArgumentDeTaille(personnage, expliquer);
        if (predicateAsBool(personnage, 'ordreDuChevalierDragon') && attributeAsBool(personnage, 'monteSur')) {
          expliquer("Chevalier Dragon mont\xE9 : +5 en intimidation");
          bonus += 5;
        }
        bonus += bonusInteractionsSociales(personnage, expliquer);
        break;
      case 'escalade':
        {
          if (predicateAsBool(personnage, 'graceFelineVoleur')) {
            let bonusGraceFeline = modCarac(personnage, 'charisme');
            if (bonusGraceFeline > 0) {
              expliquer("Gr\xE2ce f\xE9line : +" + bonusGraceFeline + " en escalade");
              bonus += bonusGraceFeline;
            }
          }
          let a = predicateAsInt(personnage, 'ameFeline', 0);
          if (a > 0) {
            expliquer("\xC2me f\xE9line : +" + a + " en escalade");
            bonus += a;
          }
          a = predicateAsInt(personnage, 'vitesseDuFelin', 0);
          if (a > 0) {
            expliquer("Vitesse du f\xE9lin : +" + a + " en escalade");
            bonus += a;
          }
          break;
        }
      case 'mentir':
        bonus += bonusInteractionsSociales(personnage, expliquer);
        break;
      case 'n\xE9gociation':
      case 'negociation':
        bonus += bonusArgumentDeTaille(personnage, expliquer);
        bonus += bonusInteractionsSociales(personnage, expliquer);
        break;
      case 'orientation':
        if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
          expliquer("For\xEAt hostile : -5 en orientation");
          bonus -= 5;
        }
        break;
      case 'perception':
        if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
          expliquer("For\xEAt hostile : -5 en perception");
          bonus -= 5;
        }
        if (compagnonPresent(personnage, 'guetteur')) {
          expliquer("Guetteur : +5 en perception");
          bonus += 5;
        }
        let lie = personnageAmeLiee(personnage);
        if (lie && compagnonPresent(lie, 'guetteur')) {
          expliquer("Guetteur de " + nomPerso(lie) + " : +2 en perception");
          bonus += 2;
        }
        break;
      case 'persuasion':
        bonus += bonusArgumentDeTaille(personnage, expliquer);
        if (predicateAsBool(personnage, 'ordreDuChevalierDragon') && attributeAsBool(personnage, 'monteSur')) {
          expliquer("Chevalier Dragon mont\xE9 : +5 en persuasion");
          bonus += 5;
        }
        bonus += bonusInteractionsSociales(personnage, expliquer);
        break;
      case 'saut':
      case 'sauter':
        {
          if (predicateAsBool(personnage, 'graceFelineVoleur')) {
            let bonusGraceFeline = modCarac(personnage, 'charisme');
            if (bonusGraceFeline > 0) {
              expliquer("Gr\xE2ce f\xE9line : +" + bonusGraceFeline + " en saut");
              bonus += bonusGraceFeline;
            }
          }
          let a = predicateAsInt(personnage, 'ameFeline', 0);
          if (a > 0) {
            expliquer("\xC2me f\xE9line : +" + a + " en saut");
            bonus += a;
          }
          a = predicateAsInt(personnage, 'vitesseDuFelin', 0);
          if (a > 0) {
            expliquer("Vitesse du f\xE9lin : +" + a + " en saut");
            bonus += a;
          }
          break;
        }
      case 'survie':
        if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
          expliquer("For\xEAt hostile : -5 en survie");
          bonus -= 5;
        }
        break;
    }
    return bonus;
  }

  function bonusTestToutesCaracs(personnage, options, testId, evt, expliquer) {
    if (options && options.cacheBonusToutesCaracs) {
      if (options.cacheBonusToutesCaracs.val !== undefined) {
        return options.cacheBonusToutesCaracs.val;
      }
    }
    let bonus = 0;
    if (attributeAsBool(personnage, 'chantDesHeros')) {
      let bonusChantDesHeros = getValeurOfEffet(personnage, 'chantDesHeros', 1);
      let chantDesHerosIntense = attributeAsInt(personnage, 'chantDesHerosTempeteDeManaIntense', 0);
      bonusChantDesHeros += chantDesHerosIntense;
      expliquer("Chant des h\xE9ros : +" + bonusChantDesHeros + " au jet");
      bonus += bonusChantDesHeros;
      if (chantDesHerosIntense && evt)
        removeTokenAttr(personnage, 'chantDesHerosTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'benediction')) {
      let bonusBenediction = getValeurOfEffet(personnage, 'benediction', 1);
      let benedictionIntense = attributeAsInt(personnage, 'benedictionTempeteDeManaIntense', 0);
      bonusBenediction += benedictionIntense;
      expliquer("B\xE9n\xE9diction : +" + bonusBenediction + " au jet");
      bonus += bonusBenediction;
      if (benedictionIntense && evt)
        removeTokenAttr(personnage, 'benedictionTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'inspiration')) {
      let b = getValeurOfEffet(personnage, 'inspiration', 1);
      let intense = attributeAsInt(personnage, 'inspirationTempeteDeManaIntense', 0);
      b += intense;
      expliquer("Inspiration : +" + b + " au jet");
      bonus += b;
      if (intense && evt)
        removeTokenAttr(personnage, 'inspirationTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'lameDeLigneePerdue')) {
      expliquer("Lame de lign\xE9e perdue : -1 au jet");
      bonus -= 1;
    }
    if (attributeAsBool(personnage, 'strangulation')) {
      let malusStrangulation =
        1 + attributeAsInt(personnage, 'dureeStrangulation', 0);
      expliquer("Strangulation : -" + malusStrangulation + " au jet");
      bonus -= malusStrangulation;
    }
    if (attributeAsBool(personnage, 'nueeDInsectes')) {
      let malusNuee = 2 + attributeAsInt(personnage, 'nueeDInsectesTempeteDeManaIntense', 0);
      expliquer("Nu\xE9e d\'insectes : -" + malusNuee + " au jet");
      bonus -= malusNuee;
      if (malusNuee > 2 && evt)
        removeTokenAttr(personnage, 'nueeDInsectesTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'nueeDeCriquets')) {
      let malusNueeCriquets =
        3 + attributeAsInt(personnage, 'nueeDeCriquetsTempeteDeManaIntense', 0);
      expliquer("Nu\xE9e de criquets : -" + malusNueeCriquets + " au jet");
      bonus -= malusNueeCriquets;
      if (malusNueeCriquets > 3 && evt)
        removeTokenAttr(personnage, 'nueeDeCriquetsTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'nueeDeScorpions')) {
      expliquer("Nu\xE9e de scorpions : -3 au jet");
      bonus -= 3;
    }
    if (attributeAsBool(personnage, 'etatExsangue')) {
      expliquer("Exsangue : -2 au jet");
      bonus -= 2;
    }
    if (attributeAsBool(personnage, 'putrefactionOutrTombe')) {
      expliquer("Putr\xE9fi\xE9 : -2 au jet");
      bonus -= 2;
    }
    let fortifie = attributeAsInt(personnage, 'fortifie', 0);
    if (fortifie > 0) {
      expliquer("Fortifi\xE9 : +3 au jet");
      bonus += 3;
      if (evt) {
        fortifie--;
        if (fortifie === 0) {
          removeTokenAttr(personnage, 'fortifie', evt);
        } else {
          setTokenAttr(personnage, 'fortifie', fortifie, evt);
        }
      }
    }
    if (attributeAsBool(personnage, 'ondesCorruptrices') &&
      !predicateAsBool(personnage, 'porteurDuBouclierDeGrabuge') &&
      !attributeAsBool(personnage, 'sangDeLArbreCoeur')) {
      let malusOndesCorruptrices = attributeAsInt(personnage, 'ondesCorruptrices', 2);
      let msgOndesCorruptrices = "Naus\xE9eu" + onGenre(personnage, "x", "se");
      msgOndesCorruptrices += " : -" + malusOndesCorruptrices;
      expliquer(msgOndesCorruptrices + " aux tests");
      bonus -= malusOndesCorruptrices;
    }
    if (attributeAsBool(personnage, 'fievreux')) {
      bonus -= 2;
      expliquer("Fi\xE9vreu" + onGenre(personnage, 'x', 'se') + " : -2 aux tests");
    }
    if (attributeAsBool(personnage, 'secoue')) {
      bonus -= 2;
      expliquer("Secou\xE9" + eForFemale(personnage) + " : -2 aux tests");
    }
    let bonusCondition = attributeAsInt(personnage, 'modificateurTests', 0);
    if (bonusCondition != 0) {
      bonus += bonusCondition;
      if (bonusCondition > 0) {
        expliquer("Bonus de condition : +" + bonusCondition);
      } else {
        expliquer("P\xE9nalit\xE9 de condition : " + bonusCondition);
      }
    }
    if (options) {
      if (options.bonus) bonus += options.bonus;
      if (options.chanceRollId && options.chanceRollId[testId])
        bonus += options.chanceRollId[testId];
      let malusCasque = false;
      if (options.bonusAttrs) {
        options.bonusAttrs.forEach(function(attr) {
          let bonusAttribut = charAttributeAsInt(personnage, attr, 0);
          if (bonusAttribut !== 0) {
            expliquer("Attribut " + attr + " : " + ((bonusAttribut < 0) ? "-" : "+") + bonusAttribut);
            bonus += bonusAttribut;
          }
          if (!options.competence || attr != options.competence.trim().toLowerCase())
            bonus += bonusAuxCompetences(personnage, attr, expliquer);
        });
      }
      if (options.bonusPreds) {
        options.bonusPreds.forEach(function(pred) {
          let bonusPred = predicateAsInt(personnage, pred, 0);
          if (bonusPred !== 0) {
            expliquer("Pr\xE9dicat " + pred + " : " + ((bonusPred < 0) ? "-" : "+") + bonusPred);
            bonus += bonusPred;
          }
        });
      }
      if (malusCasque && ficheAttributeAsBool(personnage, 'casque_on', false)) {
        malusCasque = ficheAttributeAsInt(personnage, 'casque_malus', 0);
        if (malusCasque > 0) {
          expliquer("Malus de casque : -" + malusCasque);
          bonus -= malusCasque;
        }
      }
      if (options.cacheBonusToutesCaracs) {
        options.cacheBonusToutesCaracs.val = bonus;
      }
    }
    return bonus;
  }

  function bonusArgumentDeTaille(perso, expliquer) {
    let bonus = 0;
    if (predicateAsBool(perso, 'argumentDeTaille')) {
      let modFor = modCarac(perso, 'force');
      if (modFor > 0) {
        bonus += modFor;
        expliquer("Argument de taille : +" + modFor);
      }
    }
    let allies = alliesParPerso[perso.charId];
    if (allies === undefined) return bonus;
    const pageId = perso.token.get('pageid');
    const tokens = findObjs({
      _type: 'graphic',
      _subtype: 'token',
      _pageid: pageId,
      layer: 'objects'
    });
    tokens.forEach(function(tok) {
      if (tok.id == perso.token.id) return;
      let ci = tok.get('represents');
      if (ci === '') return;
      if (!allies.has(ci)) return;
      let allie = {
        token: tok,
        charId: ci
      };
      if (!predicateAsBool(allie, 'argumentDeTaille')) return;
      if (distanceCombat(perso.token, tok, pageId) > 0) return;
      let modFor = modCarac(allie, 'force');
      if (modFor <= 0) return;
      bonus += modFor;
      expliquer("Argument de taille de " + tok.get('name') + " : +" + modFor);
    });
    return bonus;
  }

  //retourne un entier
  // evt n'est d\xE9fini que si la caract\xE9ristique est effectivement utilis\xE9e
  function bonusTestCarac(carac, personnage, options, testId, evt, explications) {
    const expliquer = function(msg) {
      if (explications) explications.push(msg);
    };
    // D'abord la partie qui d\xE9pend de la caract\xE9ristique
    let bonus = modCarac(personnage, caracOfMod(carac));
    if (!persoEstPNJ(personnage)) {
      bonus += ficheAttributeAsInt(personnage, carac + "_BONUS", 0);
    }
    let txt = "Bonus " + deCarac(carac) + " : ";
    if (bonus > 0) txt += '+';
    expliquer(txt + bonus);
    let bonusCarac = bonus;
    let bonusAspectDuDemon;
    let bonusForce;
    switch (carac) {
      case 'DEX':
        {
          if (attributeAsBool(personnage, 'agrandissement')) {
            expliquer("Agrandi : -2 au jet de DEX");
            bonus -= 2;
          }
          if (attributeAsBool(personnage, 'aspectDuDemon')) {
            bonusAspectDuDemon = getValeurOfEffet(personnage, 'aspectDuDemon', 2);
            expliquer("Aspect du d\xE9mon : +" + bonusAspectDuDemon + " au jet de DEX");
            bonus += bonusAspectDuDemon;
          }
          if (attributeAsBool(personnage, 'osBrises')) {
            expliquer("Des os sont bris\xE9s : -2 au jet de DEX");
            bonus -= 2;
          }
          if (attributeAsBool(personnage, 'espaceExigu')) {
            bonusForce = modCarac(personnage, 'force');
            if (bonusForce < 1) bonusForce = 1;
            expliquer("Espace exigu : -" + bonusForce + " au jet de DEX");
            bonus -= bonusForce;
          } else if (attributeAsBool(personnage, 'constructionTailleHumaine')) {
            expliquer("Construction de taille humaine : -1 au jet de DEX");
            bonus -= 1;
          }
          if (attributeAsBool(personnage, 'reactionAllergique')) {
            expliquer("D\xE9mangeaisons : -2 au jet de DEX");
            bonus -= 2;
          }
          let conditions = attributeAsInt(personnage, 'conditionsHostiles', 0, 2);
          if (conditions > 0 && (!predicateAsBool(personnage, 'marcheSylvestre') || conditions > 4)) {
            let msgConditions = "Conditions ";
            if (conditions < 5) msgConditions += "hostiles";
            else msgConditions += "extr\xEAmes";
            msgConditions += " : -" + conditions + " au jet de DEX";
            expliquer(msgConditions);
            bonus -= conditions;
          }
        }
        break;
      case 'FOR':
        {
          if (attributeAsBool(personnage, 'rayonAffaiblissant')) {
            let malusRayonAffaiblissant = getValeurOfEffet(personnage, 'rayonAffaiblissant', 2);
            expliquer("Affaibli : -" + malusRayonAffaiblissant + " au jet de FOR");
            bonus -= malusRayonAffaiblissant;
          }
          if (attributeAsBool(personnage, 'agrandissement')) {
            expliquer("Agrandi : +2 au jet de FOR");
            bonus += 2;
          }
          if (attributeAsBool(personnage, 'aspectDuDemon')) {
            bonusAspectDuDemon = getValeurOfEffet(personnage, 'aspectDuDemon', 2);
            expliquer("Aspect du d\xE9mon : +" + bonusAspectDuDemon + " au jet de FOR");
            bonus += bonusAspectDuDemon;
          }
          if (attributeAsBool(personnage, 'osBrises')) {
            expliquer("Des os sont bris\xE9s : -2 au jet de FOR");
            bonus -= 2;
          }
          if (attributeAsBool(personnage, 'espaceExigu')) {
            bonusForce = modCarac(personnage, 'force');
            if (bonusForce < 1) bonusForce = 1;
            expliquer("Espace exigu : -" + bonusForce + " au jet de FOR");
            bonus -= bonusForce;
          } else if (attributeAsBool(personnage, 'constructionTailleHumaine')) {
            expliquer("Construction de taille humaine : -1 au jet de FOR");
            bonus -= 1;
          }
          if (predicateAsBool(personnage, 'grosseTete')) {
            let bonusInt;
            if (persoEstPNJ(personnage)) {
              bonusInt = ficheAttributeAsInt(personnage, 'pnj_int', 0);
            } else {
              bonusInt = modCarac(personnage, 'intelligence');
              bonusInt += ficheAttributeAsInt(personnage, "INT_BONUS", 0);
            }
            if (bonusInt > bonusCarac) {
              let msgGrosseTete = "Grosse t\xEAte : ";
              if (bonusInt > 0) msgGrosseTete += '+';
              msgGrosseTete += bonusInt + " au lieu de ";
              if (bonusCarac > 0) msgGrosseTete += '+';
              msgGrosseTete += bonusCarac;
              expliquer(msgGrosseTete);
              bonus += bonusInt - bonusCarac;
            }
          }
          let conditions = attributeAsInt(personnage, 'conditionsHostiles', 0, 2);
          if (conditions > 0 && (!predicateAsBool(personnage, 'marcheSylvestre') || conditions > 4)) {
            let msgConditions = "Conditions ";
            if (conditions < 5) msgConditions += "hostiles";
            else msgConditions += "extr\xEAmes";
            msgConditions += " : -" + conditions + " au jet de FOR";
            expliquer(msgConditions);
            bonus -= conditions;
          }
        }
        break;
      case 'INT':
        if (attributeAsBool(personnage, 'secretsDeLAuDela')) {
          bonus += 5;
          expliquer("Secrets de l'au-del\xE0 : +5");
        }
        break;
      case 'CHA':
        if (attributeAsBool(personnage, 'aspectDeLaSuccube')) {
          let bonusAspectDeLaSuccube = getValeurOfEffet(personnage, 'aspectDeLaSuccube', 5);
          expliquer("Aspect de la succube : +" + bonusAspectDeLaSuccube + " au jet de CHA");
          bonus += bonusAspectDeLaSuccube;
        }
        if (attributeAsBool(personnage, 'reactionAllergique')) {
          expliquer("Plaques allergiques : -2 au jet de CHA");
          bonus -= 2;
        }
        break;
      case 'CON':
        if (attributeAsBool(personnage, 'mutationSilhouetteMassive')) {
          expliquer("Silhouette massive : +5 au jet de CON");
          bonus += 5;
        }
        if (predicateAsBool(personnage, 'controleDuMetabolisme')) {
          let mod = modCarac(personnage, 'charisme');
          if (mod > 0) {
            expliquer("Controle du m\xE9tabolisme : +" + mod + " au jet de CON");
            bonus += mod;
          }
        }
        if (attributeAsBool(personnage, 'aspectDuDemon')) {
          bonusAspectDuDemon = getValeurOfEffet(personnage, 'aspectDuDemon', 2);
          expliquer("Aspect du d\xE9mon : +" + bonusAspectDuDemon + " au jet de CON");
          bonus += bonusAspectDuDemon;
        }
        break;
    }
    let bonusCompetence;
    if (options && options.competence) {
      let comp = options.competence.trim().toLowerCase();
      let competences = extractRepeating(personnage, 'competences');
      let bestFit = false;
      let competenceTrouvee;
      for (let id in competences) {
        if (bestFit) continue;
        let c = competences[id];
        if (c.comp_nom === undefined) continue;
        if (c.comp_nom.trim().toLowerCase() != comp) continue;
        competenceTrouvee = c;
        bonusCompetence = fieldAsInt(c, 'comp_bonus', 0);
        let compCarac = fieldAsString(c, 'comp_carac', 'FOR');
        if (compCarac == carac) {
          bestFit = true;
        } else if (c.comp_caracs) {
          let caracsLimitees = c.comp_caracs.split(',');
          bestFit = caracsLimitees.includes(carac);
        }
      }
      if (bonusCompetence === undefined) {
        let compSansBlanc = options.competence.toLowerCase().replace(/ /g, '_');
        options.bonusAttrs = options.bonusAttrs || [];
        options.bonusAttrs.push(compSansBlanc);
        options.bonusPreds = options.bonusPreds || [];
        options.bonusPreds.push(compSansBlanc);
        if (comp == 'perception' || comp == 'vigilance') {
          //Appliquer le malus du casque

          if (ficheAttributeAsBool(personnage, 'casque_on', false)) {
            let malusCasque = ficheAttributeAsInt(personnage, 'casque_malus', 0);
            if (malusCasque > 0) {
              expliquer("Casque : -" + malusCasque);
              bonus -= malusCasque;
            }
          }
        }
      } else {
        let msgComp = "Comp\xE9tence " + options.competence + " : ";
        if (bonusCompetence === 0) {
          msgComp += 0;
        } else {
          bonus += bonusCompetence;
          if (bonusCompetence > 0) msgComp += "+" + bonusCompetence;
          else msgComp += bonusCompetence;
        }
        expliquer(msgComp);
        let malus = fieldAsString(competenceTrouvee, 'comp_malus', '');
        if (malus == 'armure') {
          bonus -= malusArmure(personnage, expliquer, '');
        } else if (malus == 'casque' && ficheAttributeAsBool(personnage, 'casque_on', false)) {
          let malusCasque = ficheAttributeAsInt(personnage, 'casque_malus', 0);
          if (malusCasque > 0) {
            expliquer("Casque : -" + malusCasque);
            bonus -= malusCasque;
          }
        }
      }
      bonus += bonusAuxCompetences(personnage, comp, expliquer);
    }
    if (bonusCompetence === undefined) {
      if (carac == 'DEX') {
        bonus -= malusArmure(personnage, expliquer, ' aux jets de DEX');
      }
    }
    // Puis la partie commune
    options = options || {};
    bonus += bonusTestToutesCaracs(personnage, options, testId, evt, expliquer);
    //Pas besoin de mettre la valeur de caract\xE9ristique si c'est le seul bonus
    if (explications && explications.length == 1) explications.pop();
    return bonus;
  }

  function deTest(personnage, carac) {
    let dice = 20;
    if ((estAffaibli(personnage) && !predicateAsBool(personnage, 'insensibleAffaibli')) ||
      getState(personnage, 'immobilise') ||
      attributeAsBool(personnage, 'mortMaisNAbandonnePas'))
      dice = 12;
    else {
      let ebriete = attributeAsInt(personnage, 'niveauEbriete', 0);
      if (ebriete > 2) dice = 12;
      else if (ebriete > 1 && carac != 'CON') dice = 12;
    }
    return dice;
  }

  function computeDice(lanceur, options) {
    options = options || {};
    let nbDe = options.nbDe;
    if (nbDe === undefined) nbDe = 1;
    let plusFort = options.plusFort;
    if (plusFort === undefined) plusFort = true;
    let dice = options.dice;
    if (dice === undefined) dice = deTest(lanceur, options.carac);
    if (attributeAsBool(lanceur, 'malediction')) {
      if (plusFort) {
        if (nbDe > 1) nbDe--;
        else {
          nbDe = 2;
          plusFort = false;
        }
      } else nbDe++;
    }
    let de = nbDe + "d" + dice;
    if (nbDe > 1) {
      if (plusFort) de += "kh1";
      else de += "kl1";
    }
    return de;
  }

  function foudreDuTemps(perso, d20roll, delayed, more) {
    if (stateCOF.foudreDuTemps.min > d20roll) return;
    if (stateCOF.foudreDuTemps.max < d20roll) return;
    if (delayed === undefined) {
      setTimeout(_.bind(foudreDuTemps, undefined, perso, d20roll, true), 2000);
      return;
    }
    playSound('Foudre');
    if (getState(perso, 'mort')) return;
    let d6 = rollDePlus(6);
    let titre = "La foudre frappe ! " + d6.roll;
    let pl = getPlayerIds(perso);
    if (pl === undefined) return;
    let playerId;
    if (pl.length > 0) playerId = pl[0]; //Utilis\xE9 juste pour la couleur
    let display = startFramedDisplay(playerId, titre, perso);
    let explications = [];
    let np = nomPerso(perso);
    switch (d6.val) {
      case 1:
        {
          addLineToFramedDisplay(display, np + " est frapp\xE9" + eForFemale(perso) + " de plein fouet !");
          let options = {
            partialSave: {
              carac: 'DEX',
              seuil: 15
            }
          };
          let dmg = {
            type: 'electrique',
            value: '3d6',
          };
          //Un evt pour pouvoir utiliser les points de chance sur le save
          let evt = {
            type: 'dmgDirects',
            action: {
              titre,
              playerId,
              playerName: 'GM',
              cibles: [perso],
              dmg,
              options
            }
          };
          addEvent(evt);
          sendChat('', '[[3d6]]', function(resDmg) {
            dmg.roll = resDmg[0];
            let afterEvaluateDmg = dmg.roll.content.split(' ');
            let dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
            dmg.total = dmg.roll.inlinerolls[dmgRollNumber].results.total;
            dmg.display = buildinline(dmg.roll.inlinerolls[dmgRollNumber], dmg.type);
            dealDamage(perso, dmg, [], evt, false, options, explications, function(dmgDisplay, dmgFinal) {
              addLineToFramedDisplay(display,
                np + " re\xE7oit " + dmgDisplay + " DM");
              explications.forEach(function(e) {
                addLineToFramedDisplay(display, e, 80, false);
              });
              sendChat('', endFramedDisplay(display));
            });
          });
          return;
        }
      case 2:
      case 3:
        {
          let distance = rollDePlus(6);
          //Un evt pour pouvoir utiliser les points de chance sur le save
          let options = {
            save: {
              carac: 'FOR',
              seuil: 10,
              msgPour: "pour ne pas \xEAtre tomber"
            }
          };
          let evt = {
            type: 'set_state',
            action: {
              titre,
              cibles: [perso],
              etat: 'renverse',
              valeur: true,
              options
            }
          };
          addEvent(evt);
          let saveOpts = {
            msgPour: options.msgPour,
            msgRate: ", rat\xE9.",
          };
          let expliquer = function(s) {
            explications.push(s);
          };
          let saveId = "effet_renverse_" + perso.token.id;
          save(options.save, perso, saveId, expliquer, saveOpts, evt, function(reussite, rolltext) {
            let textDist = distance.roll;
            let seuil = 1;
            if (reussite) {
              textDist = distance.val / 2;
              seuil = 2;
            }
            textDist += distance.val > seuil ? ' m\xE8tres' : ' m\xE8tre';
            sendChat('', '[[2d6]]', function(resDmg) {
              let afterEvaluateDmg = resDmg[0].content.split(' ');
              let dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
              let dmg = {
                total: resDmg[0].inlinerolls[dmgRollNumber].results.total,
                display: buildinline(resDmg[0].inlinerolls[dmgRollNumber], 'electrique'),
                type: 'electrique'
              };
              dealDamage(perso, dmg, [], evt, false, options, explications, function(dmgDisplay, dmgFinal) {
                addLineToFramedDisplay(display, np + " est projet\xE9" + eForFemale(perso) + " de " + textDist + " par la foudre, et subit " + dmgDisplay + " DM");
                explications.forEach(function(e) {
                  addLineToFramedDisplay(display, e, 80, false);
                });
                if (reussite) {
                  addLineToFramedDisplay(display, np + " r\xE9siste, la distance de projection passe de " + distance.roll + " \xE0 " + (distance.val / 2));
                } else {
                  setState(perso, 'renverse', true, evt);
                }
                sendChat('', endFramedDisplay(display));
              });
            });
          });
          return;
        }
      default:
        {
          addLineToFramedDisplay(display, np + " est dans la zone d'impact !");
          if (getState(perso, 'affaibli')) {
            sendChat('', endFramedDisplay(display));
            return;
          }
          let options = {
            save: {
              carac: 'CON',
              seuil: 10,
              msgPour: ' pour ne pas \xEAtre affaibli' + eForFemale(perso)
            }
          };
          const evt = {
            type: 'effetTemp',
            action: {
              titre,
              playerId,
              cibles: [perso],
              effet: 'affaibliTemp',
              mEffet: messageEffetTemp.affaibliTemp,
              duree: 1,
              options: options
            }
          };
          addEvent(evt);
          activerEffetTemporaire(undefined, [perso], 'affaibliTemp', messageEffetTemp.affaibliTemp, 1, options, evt, '', explications, display);
        }
    }
  }

  function pointsDeChance(perso) {
    if (!estPJ(perso)) return 0;
    let optionPC = ficheAttributeAsInt(perso, 'option_pc', 1);
    if (optionPC === 0) return 0;
    return ficheAttributeAsInt(perso, 'pc', 3);
  }

  // Test de caract\xE9ristique
  // options : bonusAttrs, bonusPreds, bonus, roll
  // Apr\xE8s le test, lance callback(testRes, explications
  // testRes.texte est l'affichage du jet de d\xE9
  // testRes.reussite indique si le jet est r\xE9ussi
  // testRes.echecCritique, testRes.critique pour le type
  // testRes.valeur pour la valeur totale du jet
  // testRes.rerolls pour le texte avec les boutons de rerolls adapt\xE9s.
  // testRes.modifiers pour les boutons qui peuvent \xEAtre activ\xE9s sur le roll, qu'il soit r\xE9ussi ou non.
  // Pour que les boutons de rerolls fonctionnent, le type d'\xE9v\xE8nement doit \xEAtre support\xE9 par redoEvent()
  // ne rajoute pas evt \xE0 l'historique
  function testCaracteristique(personnage, carac, seuil, testId, options, evt, callback) { //asynchrone
    options = options || {};
    let testRes = {};
    let explications = [];
    let bonusCarac = bonusTestCarac(carac, personnage, options, testId, evt, explications);
    let jetCache = ficheAttributeAsBool(personnage, 'jets_caches', false);
    let testsRatesDuTour;
    let listeTestsRatesDuTour;
    let testDejaRate;
    let adaptable = predicateAsInt(personnage, 'adaptable', 0);
    if (adaptable) {
      testsRatesDuTour = tokenAttribute(personnage, 'testsRatesDuTour');
      if (testsRatesDuTour.length > 0) {
        testsRatesDuTour = testsRatesDuTour[0];
        listeTestsRatesDuTour = testsRatesDuTour.get('current').split(' ');
        let testRate = listeTestsRatesDuTour.includes(testId);
        if (testRate) {
          testDejaRate = true;
          bonusCarac += adaptable;
        } else {
          testRate = testsRatesDuTour.get('max').split(' ').includes(testId);
          if (testRate) {
            bonusCarac += adaptable;
          }
        }
      } else testsRatesDuTour = undefined;
    }
    let carSup = nbreDeTestCarac(carac, personnage);
    let de = computeDice(personnage, {
      nbDe: carSup,
      carac: carac
    });
    if (estAffaibli(personnage) && predicateAsBool(personnage, 'insensibleAffaibli')) bonusCarac -= 2;
    let plageEC = 1;
    let plageECText = '1';
    if (options.plageEchecCritique) {
      plageEC = options.plageEchecCritique;
      if (plageEC > 1) plageECText = '<' + plageEC;
    }
    let rollExpr = "[[" + de + "cs20cf" + plageECText + "]]";
    try {
      sendChat("", rollExpr, function(res) {
        options.rolls = options.rolls || {};
        let roll = options.rolls[testId] || options.roll || res[0].inlinerolls[0];
        roll.token = personnage.token;
        evt.action = evt.action || {};
        evt.action.rolls = evt.action.rolls || {};
        evt.action.rolls[testId] = roll;
        testRes.roll = roll;
        let d20roll = roll.results.total;
        let bonusText = (bonusCarac > 0) ? "+" + bonusCarac : (bonusCarac === 0) ? "" : bonusCarac;
        testRes.texte = jetCache ? d20roll + bonusCarac : buildinline(roll) + bonusText;
        if (stateCOF.foudreDuTemps) foudreDuTemps(personnage, d20roll);
        if (d20roll == 20) {
          testRes.reussite = true;
          testRes.critique = true;
        } else if (d20roll <= plageEC) {
          testRes.reussite = false;
          testRes.echecCritique = true;
          diminueMalediction(personnage, evt);
        } else if (d20roll + bonusCarac >= seuil) {
          testRes.reussite = true;
        } else {
          diminueMalediction(personnage, evt);
          testRes.reussite = false;
        }
        testRes.valeur = d20roll + bonusCarac;
        if (adaptable) {
          if (testRes.reussite) {
            if (testsRatesDuTour && listeTestsRatesDuTour) {
              if (listeTestsRatesDuTour.includes(testId)) {
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: testsRatesDuTour,
                  current: testsRatesDuTour.get('current'),
                });
                listeTestsRatesDuTour = listeTestsRatesDuTour.filter(function(i) {
                  return i != testId;
                });
                testsRatesDuTour.set('current', listeTestsRatesDuTour.join(' '));
              }
            }
          } else if (!testDejaRate) {
            if (testsRatesDuTour && listeTestsRatesDuTour) {
              listeTestsRatesDuTour.push(testId);
              evt.attributes = evt.attributes || [];
              evt.attributes.push({
                attribute: testsRatesDuTour,
                current: testsRatesDuTour.get('current'),
              });
              testsRatesDuTour.set('current', listeTestsRatesDuTour.join(' '));
            } else {
              setTokenAttr(personnage, 'testsRatesDuTour', testId, evt);
            }
          }
        }
        testRes.rerolls = '';
        let pc = pointsDeChance(personnage);
        if (!testRes.echecCritique && pc > 0) {
          testRes.rerolls += '<br/>' +
            boutonSimple("!cof-bouton-chance " + evt.id + " " + testId, "Chance") +
            " (reste " + pc + " PC)";
        }
        if (stateCOF.combat && attributeAsBool(personnage, 'runeForgesort_\xE9nergie') &&
          attributeAsInt(personnage, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0 &&
          (carac == 'FOR' || carac == 'CON' || carac == 'DEX')) {
          testRes.rerolls += '<br/>' + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + testId, "Rune d'\xE9nergie");
        }
        if (stateCOF.combat && capaciteDisponible(personnage, 'petitVeinard', 'combat')) {
          testRes.rerolls += '<br/>' + boutonSimple("!cof-bouton-petit-veinard " + evt.id + " " + testId, "Petit veinard");
        }
        if (stateCOF.combat && !testRes.echecCritique &&
          capaciteDisponible(personnage, 'prouesse', 'tour') &&
          (carac == 'FOR' || carac == 'DEX')) {
          testRes.rerolls += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + testId, "Prouesse");
        }
        testRes.modifiers = '';
        if (predicateAsBool(personnage, 'tourDeForce') && carac == 'FOR') {
          testRes.modifiers += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + testId, "Tour de Force");
        }
        let pacteSanglant = predicateAsInt(personnage, 'pacteSanglant', 0);
        if (pacteSanglant >= 3) {
          testRes.modifiers += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + testId, "Pacte sanglant (+3)");
          if (pacteSanglant >= 5) {
            testRes.modifiers += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + testId, "Pacte sanglant (+5)");
          }
        }
        if (jetCache) sendChat('COF', "/w GM Jet cach\xE9 : " + buildinline(roll) + bonusText);
        callback(testRes, explications);
      });
    } catch (e) {
      error("Erreur pendant l'\xE9valuation de " + rollExpr + " dans un test de caract\xE9ristiques");
      log(e.name + ": " + e.message);
    }
  }

  //callback peut prendre en argument une structure avec les champs:
  // - texte: Le texte du jet
  // - total : Le r\xE9sultat total du jet
  // - echecCritique, critique pour indiquer si 1 ou 20
  // - roll: le inlineroll
  function jetCaracteristique(personnage, carac, options, testId, evt, callback) {
    let explications = [];
    let bonusCarac = bonusTestCarac(carac, personnage, options, testId, evt, explications);
    let carSup = nbreDeTestCarac(carac, personnage);
    let jetCache = ficheAttributeAsBool(personnage, 'jets_caches', false);
    let de = computeDice(personnage, {
      nbDe: carSup,
      carac: carac,
      dice: options.dice
    });
    if (estAffaibli(personnage) && predicateAsBool(personnage, 'insensibleAffaibli')) bonusCarac -= 2;
    let bonusText = '';
    if (bonusCarac > 0) {
      bonusText = ' + ' + bonusCarac;
    } else if (bonusCarac < 0) {
      bonusText = ' - ' + (-bonusCarac);
    }
    let plageEC = 1;
    let plageECText = '1';
    if (options && options.plageEchecCritique) {
      plageEC = options.plageEchecCritique;
      if (plageEC > 1) plageECText = '<' + plageEC;
    }
    let rollExpr = "[[" + de + "cs20cf" + plageECText + "]]";
    sendChat("", rollExpr, function(res) {
      options.rolls = options.rolls || {};
      let roll = options.rolls[testId] || res[0].inlinerolls[0];
      evt.action = evt.action || {};
      evt.action.rolls = evt.action.rolls || {};
      evt.action.rolls[testId] = roll;
      roll.token = personnage.token;
      let d20roll = roll.results.total;
      if (stateCOF.foudreDuTemps) foudreDuTemps(personnage, d20roll);
      let rtext = jetCache ? d20roll + bonusCarac : buildinline(roll) + bonusText;
      let rt = {
        total: d20roll + bonusCarac,
      };
      if (d20roll <= plageEC) {
        rtext += " -> \xE9chec critique";
        rt.echecCritique = true;
      } else if (d20roll == 20) {
        rtext += " -> r\xE9ussite critique";
        rt.critique = true;
      } else if (bonusCarac !== 0 && !jetCache) rtext += " = " + rt.total;
      rt.texte = rtext;
      rt.roll = roll;
      if (jetCache) sendChat('COF', "/w GM Jet cach\xE9 de caract\xE9ristique : " + buildinline(roll) + bonusText);
      callback(rt, explications);
    });
  }

  function montrerResultatJet(msg) {
    let cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("manque l'argument de !cof-montrer-resultats-jet", cmd);
      return;
    }
    if (!stateCOF.jetsEnCours) {
      error("Pas de jet en cours", stateCOF);
      return;
    }
    let display = stateCOF.jetsEnCours[cmd[1]];
    if (display === undefined) {
      error("Pas de jet en cours pour ce joueur", stateCOF.jetsEnCours);
      return;
    }
    if (display.retarde) {
      addFramedHeader(display, cmd[1], false);
      sendChat('', endFramedDisplay(display));
    } else {
      sendChat('', endFramedDisplay(display));
    }
  }

  function sendDisplayJetPerso(display, playerId, options) {
    if (!options.chanceRollId && stateCOF.options.affichage.val.MJ_valide_affichage_jets.val) {
      let players = findObjs({
        _type: 'player'
      });
      let joueur;
      let gm;
      let joueurJ;
      players.forEach(function(p) {
        if (!p.get('online')) return;
        if (playerId == p.id) joueurJ = p;
        if (playerIsGM(p.id)) gm = true;
        else joueur = true;
      });
      if (gm && joueur) {
        stateCOF.jetsEnCours = stateCOF.jetsEnCours || {};
        stateCOF.jetsEnCours[playerId] = {...display
        };
        addLineToFramedDisplay(display, boutonSimple('!cof-montrer-resultats-jet ' + playerId, "Montrer aux joueurs"));
        addFramedHeader(display, undefined, 'gm');
        sendChat('', endFramedDisplay(display));
        if (!playerIsGM(playerId)) {
          let dest = joueurJ.get('displayname');
          if (dest.includes('"')) {
            sendChat('COF', display.action);
            log("Impossible d'envoyer des messages priv\xE9s \xE0 " + dest + " car le nom contient des guillemets");
          }
          sendChat('COF', '/w "' + dest + '" ' + display.action);
        }
        return;
      }
    }
    if (display.retarde) {
      addFramedHeader(display, playerId, true);
      sendChat('', endFramedDisplay(display));
      addFramedHeader(display, undefined, 'gm');
      sendChat('', endFramedDisplay(display));
    } else sendChat('', endFramedDisplay(display));
  }

  function jetPerso(perso, caracteristique, difficulte, titre, playerId, options) {
    options = options || {};
    const evt = options.evt || {
      type: 'jetPerso',
      personnage: perso,
      action: {
        caracteristique: caracteristique,
        difficulte: difficulte,
        titre: titre,
        playerId: playerId,
        options: options
      }
    };
    addEvent(evt);
    let optionsDisplay = {
      secret: options.secret ||
        (!options.chanceRollId && stateCOF.options.affichage.val.MJ_valide_affichage_jets.val)
    };
    const display = startFramedDisplay(playerId, titre, perso, optionsDisplay);
    const testId = 'jet_' + perso.charId + '_' + caracteristique;
    if (difficulte === undefined) {
      jetCaracteristique(perso, caracteristique, options, testId, evt,
        function(rt, explications) {
          addLineToFramedDisplay(display, "<b>R\xE9sultat :</b> " + rt.texte);
          explications.forEach(function(m) {
            addLineToFramedDisplay(display, m, 80);
          });
          addStatistics(playerId, ["Jet de carac", caracteristique], rt.roll);
          // Maintenant, on diminue la mal\xE9diction si le test est un \xE9chec
          let attrMalediction = tokenAttribute(perso, 'malediction');
          if (attrMalediction.length > 0) {
            if (rt.echecCritique)
              diminueMalediction(perso, evt, attrMalediction);
            else if (!rt.critique) {
              let action = "!cof-resultat-jet " + evt.id;
              let ligne = "L'action est-elle ";
              ligne += bouton(action + " reussi", "r\xE9ussie", perso);
              ligne += " ou " + bouton(action + " rate", "rat\xE9e", perso);
              ligne += " ?";
              addLineToFramedDisplay(display, ligne);
              evt.attenteResultat = true;
            }
          }
          let boutonsReroll = '';
          let pc = pointsDeChance(perso);
          if (pc > 0 && !rt.echecCritique) {
            boutonsReroll +=
              '<br/>' + boutonSimple("!cof-bouton-chance " + evt.id + " " + testId, "Chance") +
              " (reste " + pc + " PC)";
          }
          if (stateCOF.combat && attributeAsBool(perso, 'runeForgesort_\xE9nergie') &&
            attributeAsInt(perso, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0 &&
            (caracteristique == 'FOR' || caracteristique == 'CON' || caracteristique == 'DEX')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + testId, "Rune d'\xE9nergie");
          }
          if (stateCOF.combat && capaciteDisponible(perso, 'petitVeinard', 'combat')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-bouton-petit-veinard " + evt.id + " " + testId, "Petit veinard");
          }
          if (stateCOF.combat &&
            !rt.echecCritique && capaciteDisponible(perso, 'prouesse', 'tour') &&
            (caracteristique == 'FOR' || caracteristique == 'DEX')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + testId, "Prouesse");
          }
          if (caracteristique == 'FOR' && predicateAsBool(perso, 'tourDeForce')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + testId, "Tour De Force");
          }
          let pacteSanglant = predicateAsInt(perso, 'pacteSanglant', 0);
          if (pacteSanglant >= 3) {
            boutonsReroll += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + testId, "Pacte sanglant (+3)");
            if (pacteSanglant >= 5) {
              boutonsReroll += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + testId, "Pacte sanglant (+5)");
            }
          }
          addLineToFramedDisplay(display, boutonsReroll);
          sendDisplayJetPerso(display, playerId, options);
        });
    } else {
      testCaracteristique(perso, caracteristique, difficulte, testId, options, evt,
        function(tr, explications) {
          addLineToFramedDisplay(display, "<b>R\xE9sultat :</b> " + tr.texte);
          explications.forEach(function(m) {
            addLineToFramedDisplay(display, m, 80);
          });
          if (tr.reussite) {
            addLineToFramedDisplay(display, "C'est r\xE9ussi." + tr.modifiers);
          } else {
            let msgRate = "C'est rat\xE9." + tr.rerolls + tr.modifiers;
            addLineToFramedDisplay(display, msgRate);
          }
          sendDisplayJetPerso(display, playerId, options);
        });
    }
  }

  //Par construction, msg.content ne doit pas contenir d'option --nom,
  //et commencer par !cof-jet
  function boutonsCompetences(display, perso, carac, msg, fond) {
    let action = msg.content;
    action = action.replace(/ --competences /, '');
    action = action.replace(/ --competences/, ''); //au cas o\xF9 ce serait le dernier argument
    let args = action.substring(9); //on enl\xE8ve !cof-jet
    if (!args.startsWith(carac)) action = "!cof-jet " + carac + " " + args;
    let overlay;
    switch (carac) {
      case 'FOR':
        overlay = 'Force';
        break;
      case 'DEX':
        overlay = 'Dext\xE9rit\xE9';
        break;
      case 'CON':
        overlay = 'Constitution';
        break;
      case 'INT':
        overlay = 'Intelligence';
        break;
      case 'SAG':
        overlay = 'Sagesse';
        break;
      case 'CHA':
        overlay = 'Charisme';
        break;
    }
    let charButtonStyle = ' style="border-radius:10px;" title="' + overlay + '"';
    let cell = boutonSimple(action, carac, charButtonStyle);
    addCellInFramedDisplay(display, cell, 60, true, fond);
    let comps = [...listeCompetences[carac].list];
    let competences = extractRepeating(perso, 'competences');
    let compsMinuscules = listeCompetences[carac].elts;
    for (let id in competences) {
      const c = competences[id];
      let compCarac = fieldAsString(c, 'comp_carac', 'FOR');
      if (compCarac != carac) {
        let compCaracs = c.comp_caracs;
        if (compCaracs === undefined) continue;
        compCaracs = compCaracs.split(',');
        if (!compCaracs.includes(carac)) continue;
      }
      let nom = c.comp_nom;
      if (nom === undefined) continue;
      let nomCompMinuscule = nom.trim().toLowerCase();
      if (compsMinuscules.has(nomCompMinuscule)) continue;
      comps.push(nom);
    }
    cell = '';
    let sec = false;
    comps.forEach(function(comp) {
      if (sec) cell += ' ';
      else sec = true;
      let buttonStyle = ' style="background-color:#996600; padding:1px 2px; border-radius:5px;"';
      cell += boutonSimple(action + " --nom " + comp, comp, buttonStyle);
    });
    addCellInFramedDisplay(display, cell, 80, false, fond);
  }

  // prend une distance en m\xE8tre et retourne une distance dans l'unit\xE9
  // utilis\xE9e sur la page du personnage
  function scaleDistance(perso, distance) {
    if (perso.scale) return distance * perso.scale;
    let pageId = perso.pageId;
    if (pageId === undefined) {
      pageId = perso.token.get('pageid');
      perso.pageId = pageId;
    }
    const page = getObj('page', pageId);
    if (page === undefined) {
      perso.scale = 1;
      return distance;
    }
    let unit = page.get('scale_units');
    switch (unit) {
      case 'm':
        perso.scale = 1;
        break;
      case 'ft':
        perso.scale = 3.28084;
        break;
      case 'cm':
        perso.scale = 100;
        break;
      case 'km':
        perso.scale = 0.001;
        break;
      case 'mi':
        perso.scale = 0.000621371;
        break;
      case 'in':
        perso.scale = 39.3701;
        break;
      default:
        sendChat('COF', "Attention, unit\xE9 de mesure de la page (" + unit + ") non reconnue");
        perso.scale = 1;
    }
    return distance * perso.scale;
  }

  function getPageId(playerId) {
    let pageId;
    if (playerIsGM(playerId)) {
      let player = getObj('player', playerId);
      pageId = player.get('lastpage');
    }
    if (pageId === undefined || pageId === "") {
      let pages = Campaign().get('playerspecificpages');
      if (pages && pages[playerId] !== undefined) {
        return pages[playerId];
      }
      return Campaign().get('playerpageid');
    }
    return pageId;
  }

  // si d\xE9fini, callback est appel\xE9 \xE0 chaque \xE9l\xE9ment de selected
  // qui n'est pas un personnage
  // iter seulement sur les \xE9l\xE9ment qui correspondent \xE0 des personnages
  function iterSelected(selected, iter, callback) {
    selected.forEach(function(sel) {
      let token = getObj('graphic', sel._id);
      if (token === undefined) {
        if (callback !== undefined) callback();
        return;
      }
      let charId = token.get('represents');
      if (charId === undefined || charId === "") {
        if (callback !== undefined) callback();
        return;
      }
      iter({
        token: token,
        charId: charId
      });
    });
  }

  function determinant(xa, ya, xb, yb) {
    return xa * yb - ya * xb;
  }

  //Calcule si le segment [a,b] intersecte le segment [c,d]
  function segmentIntersecte(a, b, c, d) {
    let d1 = determinant(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);
    let d2 = determinant(b.x - a.x, b.y - a.y, d.x - a.x, d.y - a.y);
    if (d1 > 0 && d2 > 0) return false;
    if (d1 < 0 && d2 < 0) return false;
    d1 = determinant(d.x - c.x, d.y - c.y, a.x - c.x, a.y - c.y);
    d2 = determinant(d.x - c.x, d.y - c.y, b.x - c.x, b.y - c.y);
    if (d1 > 0 && d2 > 0) return false;
    if (d1 < 0 && d2 < 0) return false;
    return true;
  }

  //traduction des coordon\xE9es de path en coordon\xE9es r\xE9elles sur la carte
  function translatePathCoordinates(x, y, p) {
    //D'abord on calcule les coordonn\xE9es relatives au centre
    x -= p.width / 2;
    y -= p.height / 2;
    //Puis on applique le scale
    x *= p.scaleX;
    y *= p.scaleY;
    //Puis on fait la rotation
    let c = Math.cos(p.angle);
    let s = Math.sin(p.angle);
    x = c * x + s * y;
    y = c * y - s * x;
    //Et finalement on ajoute les coordonn\xE9es du centre
    x += p.left;
    y += p.top;
    return {
      x,
      y
    };
  }

  function getWalls(page, pageId, murs) {
    if (murs) return murs;
    if (!page.get('lightrestrictmove')) return;
    murs = findObjs({
      _type: 'path',
      _pageid: pageId,
      layer: 'walls'
    });
    murs = murs.map(function(path) {
      let chemin = JSON.parse(path.get('_path'));
      if (chemin.length < 2) return [];
      if (chemin[1][0] != 'L') return [];
      let p = {
        angle: path.get('rotation') / 180 * Math.PI,
        width: path.get('width'),
        height: path.get('height'),
        top: path.get('top'),
        left: path.get('left'),
        scaleX: path.get('scaleX'),
        scaleY: path.get('scaleY'),
      };
      chemin = chemin.map(function(v) {
        return translatePathCoordinates(v[1], v[2], p);
      });
      return chemin;
    });
    //On rajoute les portes ferm\xE9es.
    let doors = findObjs({
      _type: 'door',
      _pageid: pageId,
    });
    doors.forEach(function(door) {
      if (door.get('isOpen')) return;
      let path = door.get('path');
      let x = door.get('x');
      let y = door.get('y');
      let chemin = [{
        x: x + path.handle0.x,
        y: path.handle0.y - y,
      }, {
        x: x + path.handle1.x,
        y: path.handle1.y - y,
      }];
      murs.push(chemin);
    });
    return murs;
  }

  //v\xE9rifie si de la nouvelle position on peut voir le suivi
  function obstaclePresent(nsx, nsy, pt, murs) {
    if (nsx == pt.x && nsy == pt.y) return false;
    let ps = {
      x: nsx,
      y: nsy
    };
    let obstacle = murs && murs.find(function(path) {
      if (path.length === 0) return false;
      let pc = path[0];
      return path.find(function(v, i) {
        if (i === 0) return false;
        if (isNaN(v.x) || isNaN(v.y)) return false;
        if (segmentIntersecte(ps, pt, pc, v)) return true;
        pc = v;
        return false;
      });
    });
    return obstacle;
  }

  // callback(selected, playerId, aoe)
  function getSelected(msg, callback, options) {
    options = options || {};
    let playerId = getPlayerIdFromMsg(msg);
    let pageId;
    if (options.pageId) pageId = options.pageId;
    else pageId = getPageId(playerId);
    let args = msg.content.split(' --');
    let selected = [];
    let enleveAuxSelected = [];
    let count = args.length - 1;
    let called;
    let actif = options.lanceur;
    if (actif === undefined) {
      if (msg.selected !== undefined && msg.selected.length == 1) {
        actif = persoOfId(msg.selected[0]._id, msg.selected[0]._id, pageId);
      }
    }
    let page;
    let murs;
    let pt;
    let aoe;
    let finalCall = function() {
      called = true;
      let seen = new Set();
      let res = selected.filter(function(sel) {
        if (seen.has(sel._id)) return false;
        seen.add(sel._id);
        let interdit = enleveAuxSelected.find(function(i) {
          return (i._id == sel._id);
        });
        return (interdit === undefined);
      });
      callback(res, playerId, aoe);
    };
    if (args.length > 1) {
      args.shift();
      args.forEach(function(cmd) {
        count--;
        const cmdSplit = cmd.split(' ');
        switch (cmdSplit[0]) {
          case 'equipe':
            let nomEquipe = 'Equipe' + cmd.substring(cmd.indexOf(' '));
            let equipes = findObjs({
              _type: 'handout',
              name: nomEquipe
            });
            if (equipes.length === 0) {
              error(nomEquipe + " inconnue", msg.content);
              return;
            }
            if (equipes.length > 1) {
              error("Plus d'une " + nomEquipe, cmd);
            }
            count += equipes.length;
            equipes.forEach(function(equipe) {
              equipe.get('notes', function(note) { //asynchrone
                let persos = charactersInHandout(note, nomEquipe);
                let tokens = findObjs({
                  _type: 'graphic',
                  _subtype: 'token',
                  _pageid: pageId,
                  layer: 'objects'
                });
                let uneCible = false;
                tokens.forEach(function(tok) {
                  let tokCharId = tok.get('represents');
                  if (persos.has(tokCharId)) {
                    uneCible = true;
                    selected.push({
                      _id: tok.id
                    });
                  }
                });
                if (!uneCible) {
                  error("Pas de token de l'" + nomEquipe + " sur la page");
                }
                count--;
                if (count === 0) finalCall();
              });
            });
            return;
          case 'allies':
          case 'saufAllies':
            {
              if (options.ignoreAllies) return;
              let selection = selected;
              let saufAllies = (cmdSplit[0] == 'saufAllies');
              if (saufAllies) selection = enleveAuxSelected;
              let actives = [];
              let allies = new Set();
              // First get the acting token (in msg.selected)
              if (actif) {
                actives = [actif];
                allies = alliesParPerso[actif.charId] || allies;
                if (saufAllies) allies = (new Set(allies)).add(actif.charId);
              } else {
                if (msg.selected === undefined || msg.selected.length === 0) {
                  error("Pas d'alli\xE9 car pas de token s\xE9lectionn\xE9", msg);
                  return;
                }
                iterSelected(msg.selected, function(personnage) {
                  actives.push(personnage);
                  let alliesPerso = alliesParPerso[personnage.charId];
                  if (alliesPerso) {
                    alliesPerso.forEach(function(ci) {
                      allies.add(ci);
                    });
                  }
                  if (saufAllies) allies.add(personnage.charId);
                });
              }
              let portee;
              if (cmdSplit.length > 1) {
                portee = parseInt(cmdSplit[1]);
                if (isNaN(portee) || portee < 0) portee = undefined;
              }
              let tokens = findObjs({
                _type: 'graphic',
                _subtype: 'token',
                _pageid: pageId,
                layer: 'objects'
              });
              tokens.forEach(function(tok) {
                let ci = tok.get('represents');
                if (ci === '') return;
                if (!allies.has(ci)) return;
                //On enl\xE8ve le token actif, mais seulement pour allies
                if (cmdSplit[0] == 'allies') {
                  if (actives.indexOf(function(perso) {
                      return perso.charId == ci;
                    }) >= 0) return;
                }
                if (portee === undefined || !actif || distanceCombat(tok, actif.token, pageId) <= portee) {
                  selection.push({
                    _id: tok.id
                  });
                }
              });
              return;
            }
          case 'self':
            if (actif) {
              selected.push({
                _id: actif.token.id
              });
              return;
            }
            if (msg.selected === undefined) return;
            msg.selected.forEach(function(obj) {
              let inSelf = selected.findIndex(function(o) {
                return (o._id == obj._id);
              });
              if (inSelf < 0) selected.push(obj);
            });
            return;
          case 'target':
            if (cmdSplit.length < 2) {
              error("Il manque l'id de la cible (apr\xE8s --target)", cmd);
              return;
            }
            selected.push({
              _id: cmdSplit[1]
            });
            return;
          case 'disque':
          case 'disquePasseMur':
            if (options.ignoreDisque) return;
            let centre;
            let rayon;
            if (cmdSplit.length < 3) {
              if (actif && cmdSplit.length > 1) {
                centre = actif;
                rayon = parseInt(cmdSplit[1]);
              } else {
                error("Pas assez d'arguments pour d\xE9finir un disque", cmdSplit);
                return;
              }
            } else {
              centre = persoOfId(cmdSplit[1], cmdSplit[1], pageId);
              if (centre === undefined) {
                error("le premier argument du disque n'est pas un token valide", cmdSplit);
                return;
              }
              rayon = parseInt(cmdSplit[2]);
            }
            if (isNaN(rayon) || rayon < 0) {
              error("Rayon du disque mal d\xE9fini", cmdSplit);
              return;
            }
            let tokenCentre = centre.token;
            let portee = 0;
            if (cmdSplit.length > 3) {
              portee = parseInt(cmdSplit[3]);
              if (isNaN(portee) || portee < 0) {
                error("La port\xE9e du disque est mal form\xE9e", cmdSplit);
                return;
              }
              if (actif === undefined) {
                error("Pas de token s\xE9lectionn\xE9 pour calculer la distance du disque", msg);
                return;
              }
              if (distanceCombat(tokenCentre, actif.token, pageId, {
                  strict1: true
                }) > portee) {
                sendPerso(actif, "Le centre de l'effet est plac\xE9 trop loin (port\xE9e " + portee + " m)");
                return;
              }
            }
            aoe = aoe || {};
            aoe.type = 'disque';
            aoe.centre = tokenCentre;
            aoe.rayon = rayon;
            page = page || getObj("page", pageId);
            if (cmdSplit[0] == 'disque')
              murs = getWalls(page, pageId, murs);
            let pc;
            if (murs) {
              pc = {
                x: tokenCentre.get('left'),
                y: tokenCentre.get('top')
              };
            }
            let allToksDisque =
              findObjs({
                _type: "graphic",
                _pageid: pageId,
                _subtype: 'token',
                layer: 'objects'
              });
            allToksDisque.forEach(function(obj) {
              if (actif && portee === 0 && obj.id == actif.token.id) return; //on ne se cible pas si le centre de l'aoe est soi-m\xEAme
              let objCharId = obj.get('represents');
              if (objCharId === '') return;
              if (getState({
                  token: obj,
                  charId: objCharId
                }, 'mort')) return; //pas d'effet aux morts
              if (obj.get('bar1_max') == 0) return; // jshint ignore:line
              let objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              let distanceCentre = distanceCombat(tokenCentre, obj, pageId, {
                strict1: true
              });
              if (distanceCentre > rayon) return;
              if (murs) {
                if (obstaclePresent(obj.get('left'), obj.get('top'), pc, murs)) return;
              }
              selected.push({
                _id: obj.id
              });
            });
            if (options.targetFx) {
              spawnFx(tokenCentre.get('left'), tokenCentre.get('top'), options.targetFx, pageId);
            }
            if (tokenCentre.get('bar1_max') == 0) { // jshint ignore:line
              //C'est juste un token utilis\xE9 pour d\xE9finir le disque
              tokenCentre.remove(); //On l'enl\xE8ve, normalement plus besoin
              delete options.targetFx;
            }
            return;
          case 'enVue':
            let observateur = actif;
            if (cmdSplit.length > 1) {
              observateur = persoOfId(cmdSplit[1], cmdSplit[1], pageId);
            }
            if (observateur === undefined) {
              error("Impossible de trouver la personne \xE0 partir de laquelle on s\xE9lectionne les tokens en vue", msg);
              return;
            }
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            if (murs) {
              pt = pt || {
                x: observateur.token.get('left'),
                y: observateur.token.get('top')
              };
            }
            let tokensEnVue = findObjs({
              _type: 'graphic',
              _pageid: pageId,
              _subtype: 'token',
              layer: 'objects'
            });
            tokensEnVue.forEach(function(obj) {
              if (actif && obj.id == actif.token.id) return; //on ne se cible pas si le centre de l'aoe est soi-m\xEAme
              let objCharId = obj.get('represents');
              if (objCharId === '') return;
              if (obj.get('bar1_max') == 0) return; // jshint ignore:line
              let objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              if (murs) {
                if (obstaclePresent(obj.get('left'), obj.get('top'), pt, murs)) return;
              }
              selected.push({
                _id: obj.id
              });
            });
            return;
          case 'alliesEnVue':
            if (actif === undefined) {
              error("Impossible de trouver la personne dont on s\xE9lectionne les lli\xE9s en vue", msg);
              return;
            }
            let alliesEnVue = alliesParPerso[actif.charId];
            if (alliesEnVue === undefined) {
              log("Personnage sans alli\xE9", actif);
              return;
            }
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            if (murs) {
              pt = pt || {
                x: actif.token.get('left'),
                y: actif.token.get('top')
              };
            }
            let tokensAlliesEnVue = findObjs({
              _type: 'graphic',
              _pageid: pageId,
              _subtype: 'token',
              layer: 'objects'
            });
            tokensAlliesEnVue.forEach(function(obj) {
              if (obj.id == actif.token.id) return; //on ne se cible pas si le centre de l'aoe est soi-m\xEAme
              let objCharId = obj.get('represents');
              if (objCharId === '') return;
              if (!alliesEnVue.has(objCharId)) return;
              if (obj.get('bar1_max') == 0) return; // jshint ignore:line
              let objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              if (murs) {
                if (obstaclePresent(obj.get('left'), obj.get('top'), pt, murs)) return;
              }
              selected.push({
                _id: obj.id
              });
            });
            return;
          default:
        }
      });
    }
    if (count === 0) {
      if (selected.length === 0) {
        if (msg.selected) {
          if (!called) {
            let res = msg.selected.filter(function(sel) {
              let interdit = enleveAuxSelected.find(function(i) {
                return (i._id == sel._id);
              });
              return (interdit === undefined);
            });
            callback(res, playerId, aoe);
          }
          return;
        }
        if (!called) callback([], playerId, aoe);
        return;
      }
      if (!called) finalCall();
    }
  }

  //msg peut \xEAtre directement le playerId ou un message
  function getPlayerIdFromMsg(msg) {
    if (msg.playerid === undefined) return msg;
    let playerId = msg.playerid;
    if (playerId == 'API') {
      let nom = msg.who;
      if (nom === undefined) return playerId;
      nom = nom.replace(/ \(GM\)/, '');
      //On regarde si un joueur s'appelle nom
      let players = findObjs({
        type: 'player',
        displayname: nom
      });
      if (players.length === 0) {
        let characters = findObjs({
          type: 'character',
          name: nom
        });
        if (characters.length === 0) {
          error("Impossible de trouver l'id du joueur " + nom, msg);
          return playerId;
        }
        let pids = characters[0].get('controlledby');
        pids = pids.split(',');
        if (pids[0] == 'all') {
          players = findObjs({
            type: 'player'
          });
          playerId = players[0].id;
        } else playerId = pids[0];
      } else playerId = players[0].id;
    }
    return playerId;
  }

  //!cof-jet [carac] [difficulte]
  // - carac : FOR, DEX, CON, INT, SAG, CHA
  // Les tokens s\xE9lectionn\xE9s sont ceux qui doivent faire le jet
  function jet(msg) {
    let opts = msg.content.split(' --');
    let cmd = opts.shift().split(' ');
    let options = {
      bonusAttrs: [],
      bonusPreds: []
    };
    opts.forEach(function(o) {
      let args = o.split(' ');
      switch (args[0]) {
        case 'nom':
          if (args.length < 2) {
            error("Il manque un argument \xE0 l'option " + args[0], opts);
            return;
          }
          args.shift();
          let nom = args.join(' ');
          if (options.nom && options.nom != nom) {
            error("Nom du jet d\xE9fini deux fois !", options.nom);
          }
          options.nom = nom;
          if (options.competence) {
            options.bonusAttrs.push(nom.toLowerCase());
            options.bonusPreds.push(nom.toLowerCase());
          } else options.competence = nom;
          return;
        case 'attribut':
          if (args.length < 2) {
            error("Il manque un argument \xE0 l'option " + args[0], opts);
            return;
          }
          options.bonusAttrs.push(args[1]);
          return;
        case 'predicat':
          if (args.length < 2) {
            error("Il manque un argument \xE0 l'option " + args[0], opts);
            return;
          }
          options.bonusPreds.push(args[1]);
          return;
        case 'bonus':
          if (args.length < 2) {
            error("Il manque un argument \xE0 l'option " + args[0], opts);
            return;
          }
          let bonus = parseInt(args[1]);
          if (isNaN(bonus)) {
            error("Le bonus doit \xEAtre un nombre", opts);
            return;
          }
          options.bonus = (options.bonus || 0) + bonus;
          return;
        case 'secret':
        case 'competences':
          options[args[0]] = true;
          return;
        case 'plageEchecCritique':
          if (args.length < 2) {
            error("Il manque un argument \xE0 l'option " + args[0], opts);
            return;
          }
          let plageEC = parseInt(args[1]);
          if (isNaN(plageEC) || plageEC < 0 || plageEC > 19) {
            error("La plage d'\xE9checs critqiques doit \xEAtre un nombre positif inf\xE9rieur \xE0 19", opts);
            return;
          }
          options.plageEchecCritique = plageEC;
      }
    });
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Utilisation de !cof-jet sans s\xE9lection de token", playerId);
        return;
      }
      if (cmd.length < 2) { //On demande la carac et la comp\xE9tence, si d\xE9finies dans un handout Comp\xE9tence
        if (options.nom) {
          error("Il manque la caract\xE9ristique \xE0 utiliser pour la comp\xE9tence " + options.nom, msg.content);
          return;
        }
        let fond = listeCompetences.nombre > 25;
        iterSelected(selected, function(perso) {
          let display = startFramedDisplay(playerId, "Jet de caract\xE9ristique", perso, {
            chuchote: true
          });
          startTableInFramedDisplay(display);
          boutonsCompetences(display, perso, 'FOR', msg);
          boutonsCompetences(display, perso, 'DEX', msg, fond);
          boutonsCompetences(display, perso, 'CON', msg);
          boutonsCompetences(display, perso, 'SAG', msg, fond);
          boutonsCompetences(display, perso, 'INT', msg);
          boutonsCompetences(display, perso, 'CHA', msg, fond);
          endTableInFramedDisplay(display);
          sendChat('', endFramedDisplay(display));
        }); //fin de iterSelected
        return;
      }
      let caracteristique = cmd[1];
      if (!isCarac(caracteristique)) {
        error("Caracteristique '" + caracteristique + "' non reconnue (FOR, DEX, CON, INT, SAG, CHA).", cmd);
        return;
      }
      if (options.competences && options.nom === undefined) {
        iterSelected(selected, function(perso) {
          let display = startFramedDisplay(playerId, "Jet " + deCarac(caracteristique), perso, {
            chuchote: true
          });
          addLineToFramedDisplay(display, "Choisissez la comp\xE9tence");
          startTableInFramedDisplay(display);
          boutonsCompetences(display, perso, caracteristique, msg);
          endTableInFramedDisplay(display);
          sendChat('', endFramedDisplay(display));
        }); //fin de iterSelected
        return;
      }
      let difficulte;
      if (cmd.length > 2) {
        difficulte = parseInt(cmd[2]);
        if (isNaN(difficulte)) difficulte = undefined;
      }
      let titre = "Jet d";
      let nomJet;
      if (options.nom && options.nom.length > 0) {
        nomJet = options.nom;
      } else {
        nomJet = caracOfMod(caracteristique, true);
      }
      let nj = nomJet.toLowerCase();
      switch (nj[0]) {
        case 'a':
        case 'e':
        case 'i':
        case 'o':
        case 'u':
          titre += "'<b>";
          break;
        default:
          titre += "e <b>";
      }
      titre += nomJet;
      titre += "</b>";
      if (nj == 'perception') {
        options.bonusAttrs.push('diversionManoeuvreValeur');
      }
      if (options.bonus)
        titre += " (" + ((options.bonus > 0) ? '+' : '') + options.bonus + ")";
      if (difficulte !== undefined) titre += " difficult\xE9 " + difficulte;
      iterSelected(selected, function(perso) {
        jetPerso(perso, caracteristique, difficulte, titre, playerId, options);
      }); //fin de iterSelected
    }); //fin de getSelected
  }

  function resultatJet(msg) {
    let args = msg.content.split(' ');
    if (args.length < 3) {
      error("La fonction !cof-resultat-jet n'a pas assez d'arguments", args);
      return;
    }
    const evt = findEvent(args[1]);
    if (evt === undefined) {
      error("Le jet est trop ancien ou \xE9te annul\xE9", args);
      return;
    }
    if (evt.personnage === undefined) {
      error("Erreur interne ", evt);
      return;
    }
    if (evt.attenteResultat) {
      let message = evt.type + " ";
      if (args[2] == 'rate') {
        diminueMalediction(evt.personnage, evt);
        message += "rat\xE9.";
      } else message += "r\xE9ussi.";
      sendPerso(evt.personnage, message);
      delete evt.attenteResultat;
    } else {
      sendPlayer(msg, "R\xE9sultat d\xE9j\xE0 d\xE9cid\xE9");
    }
  }

  let tempeteDeManaCourante = {
    vide: true
  };

  function ajouterOptionTempete(display, option, texte, restant) {
    let line = texte + " : ";
    if (tempeteDeManaCourante[option])
      line += boutonSimple("!cof-tempete-de-mana -" + option, "Oui");
    else if (restant > 0)
      line += boutonSimple("!cof-tempete-de-mana " + option, "Non");
    else line += "Non";
    addLineToFramedDisplay(display, line);
  }

  function optionsDeTempeteDeMana(msg) {
    if (tempeteDeManaCourante.vide) {
      error("Pas de temp\xEAte de mana en cours", tempeteDeManaCourante);
      return;
    }
    let perso = tempeteDeManaCourante.perso;
    let cmd = msg.content.split(' ');
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'duree':
        case 'portee':
        case 'rapide':
          if (tempeteDeManaCourante[cmd[1]]) break;
          tempeteDeManaCourante[cmd[1]] = true;
          tempeteDeManaCourante.cout++;
          break;
        case '-duree':
        case '-portee':
        case '-rapide':
        case '-altruiste':
          let opt = cmd[1].substring(1);
          if (tempeteDeManaCourante[opt]) {
            tempeteDeManaCourante[opt] = false;
            tempeteDeManaCourante.cout--;
          }
          break;
        case 'altruiste':
          if (cmd.length < 3) {
            error("Il manque l'id du token pour l'option altruiste de la tempete de mana", cmd);
            return;
          }
          let cible = persoOfId(cmd[2]);
          if (cmd[2] == perso.token.id) cible = undefined;
          if (cible) {
            if (!tempeteDeManaCourante.altruiste) tempeteDeManaCourante.cout++;
          } else {
            if (tempeteDeManaCourante.altruiste) tempeteDeManaCourante.cout--;
          }
          tempeteDeManaCourante.altruiste = cible;
          break;
        default:
          let it = parseInt(cmd[1]);
          if (isNaN(it) || it < 0) {
            error("Argument de !cof-tempete-de-mana inconnu", cmd);
            return;
          }
          if (tempeteDeManaCourante.intense === undefined)
            tempeteDeManaCourante.intense = 0;
          tempeteDeManaCourante.cout += it - tempeteDeManaCourante.intense;
          tempeteDeManaCourante.intense = it;
      }
    }
    let title = "Temp\xEAte de mana";
    if (tempeteDeManaCourante.cout) {
      title += " de puissance " + tempeteDeManaCourante.cout;
    }
    let restant = 100;
    if (tempeteDeManaCourante.max) {
      title += " (max " + tempeteDeManaCourante.max + ")";
      restant = tempeteDeManaCourante.max - tempeteDeManaCourante.cout;
    }
    let display = startFramedDisplay(tempeteDeManaCourante.playerId, title, perso, {
      chuchote: true
    });
    if (tempeteDeManaCourante.dureeDeBase &&
      tempeteDeManaCourante.dm === undefined &&
      tempeteDeManaCourante.soins === undefined)
      ajouterOptionTempete(display, "duree", "Dur\xE9e", restant);
    if (tempeteDeManaCourante.porteeDeBase)
      ajouterOptionTempete(display, "portee", "Port\xE9e", restant);
    ajouterOptionTempete(display, "rapide", "Rapide", restant);
    if (tempeteDeManaCourante.altruistePossible) {
      let la = 'Magie altruiste : ';
      if (restant || tempeteDeManaCourante.altruiste) {
        let tla = "S\xE9lectionner";
        if (tempeteDeManaCourante.altruiste) {
          tla = nomPerso(tempeteDeManaCourante.altruiste);
        }
        la += boutonSimple("!cof-tempete-de-mana altruiste @{target|token_id}", tla);
      } else la += 'Non';
      addLineToFramedDisplay(display, la);
    }
    let line = "Magie intense :";
    let magieIntense = 0;
    if (tempeteDeManaCourante.intense)
      magieIntense = tempeteDeManaCourante.intense;
    let maxMagieIntense = magieIntense + restant;
    if (maxMagieIntense > 5 && restant > 0) maxMagieIntense = magieIntense + 1;
    for (let i = 0; i <= maxMagieIntense; i++) {
      if (i == magieIntense) line += " " + i;
      else line += " " + boutonSimple("!cof-tempete-de-mana " + i, i);
    }
    addLineToFramedDisplay(display, line);
    let v = tempeteDeManaCourante.cmd;
    let vopt = '';
    if (tempeteDeManaCourante.cout) {
      vopt = "--tempeteDeMana";
      if (tempeteDeManaCourante.duree) vopt += " duree";
      if (tempeteDeManaCourante.portee) vopt += " portee";
      if (tempeteDeManaCourante.rapide) vopt += " rapide";
      if (tempeteDeManaCourante.altruiste)
        vopt += " altruiste " + tempeteDeManaCourante.altruiste.token.id;
      if (tempeteDeManaCourante.intense)
        vopt += " " + tempeteDeManaCourante.intense;
    }
    v = v.replace(/--tempeteDeMana/, vopt);
    addLineToFramedDisplay(display, boutonSimple(v, "Valider"));
    sendChat("", endFramedDisplay(display));
  }

  function setTempeteDeMana(playerId, perso, cmd, options) {
    tempeteDeManaCourante = {
      perso: perso,
      playerId: playerId,
      cmd: cmd,
      rapide: options.rapide,
      dm: options.dm,
      soins: options.soins,
      intense: options.intense,
      porteeDeBase: options.portee,
      dureeDeBase: options.duree,
      altruistePossible: options.altruiste,
      cout: options.cout || 0
    };
    let max;
    if (options.rang) max = options.rang;
    let mana = options.mana || 0;
    const niveau = ficheAttributeAsInt(perso, 'niveau', 1);
    let cout_par_effet = 1;
    if (reglesOptionelles.mana.val.mana_totale.val) cout_par_effet = 3;
    if (max === undefined || max > niveau - (mana / cout_par_effet))
      max = Math.floor(niveau - (mana / cout_par_effet));
    if (max < 1) {
      sendPerso(perso, "ne peut pas d\xE9penser plus de mana en temp\xEAte de mana (niveau " + niveau + ", mana d\xE9j\xE0 d\xE9pens\xE9e " + mana + ")");
      return;
    }
    tempeteDeManaCourante.max = max;
    optionsDeTempeteDeMana({
      content: '!cof-tempete-de-mana'
    });
  }

  function parseTempeteDeMana(cmd, options) {
    cmd.shift();
    options.tempeteDeMana = {
      cout: 0
    };
    let altruiste = false;
    cmd.forEach(function(ta) {
      switch (ta) {
        case 'portee':
          if (options.tempeteDeManaPortee) break;
          options.tempeteDeMana.cout++;
          options.tempeteDeManaPortee = true;
          altruiste = false;
          break;
        case 'duree':
          if (options.tempeteDeManaDuree) break;
          options.tempeteDeMana.cout++;
          options.tempeteDeManaDuree = true;
          altruiste = false;
          break;
        case 'rapide':
          if (options.magieRapide) break;
          options.magieRapide = true;
          options.tempeteDeMana.cout++;
          break;
        case 'altruiste':
          options.altruiste = true;
          altruiste = true;
          break;
        default:
          if (altruiste) {
            altruiste = false;
            let cible = persoOfId(ta);
            if (cible) {
              options.tempeteDeMana.cout++;
              options.tempeteDeMana.altruiste = cible;
            }
          } else {
            let intensite = parseInt(ta);
            if (isNaN(ta) || ta <= 0) {
              error("Option de temp\xEAte de mana " + ta + " non reconnue", cmd);
              break;
            }
            options.tempeteDeManaIntense = options.tempeteDeManaIntense || 0;
            options.tempeteDeManaIntense += intensite;
            options.tempeteDeMana.cout += intensite;
          }
      }
    });
    options.mana = options.mana || 0;
    if (reglesOptionelles.mana.val.mana_totale.val)
      options.mana += options.tempeteDeMana.cout * 3;
    else options.mana += options.tempeteDeMana.cout;
  }

  function parseCondition(args) {
    if (args.length > 0 && (args[0] == 'crit' || args[0] == 'critique')) {
      return {
        type: 'critique'
      };
    }
    switch (args[0]) {
      case 'etat':
        if (args.length < 2) {
          error("condition non reconnue", args);
          return;
        }
        if (_.has(cof_states, args[1])) {
          return {
            type: 'etat',
            etat: args[1],
            text: args[1]
          };
        }
        return {
          type: 'attribut',
          attribute: args[1],
          text: args[1]
        };
      case 'attribut':
        if (args.length < 3) {
          error("Il manque un argument pour comparer l'attribut", args);
          return;
        }
        let res = {
          type: 'attribut',
          attribute: args[1],
          valeur: args[2].toLowerCase(),
          text: args[1] + ' ' + args[2]
        };
        if (args.length > 3) {
          if (args[3] == 'local') {
            res.local = true;
          } else if (args[3] == 'fiche') {
            res.fiche = {};
            if (args.length > 4) {
              res.fiche.def = args[4];
            }
          }
        }
        return res;
      case 'etatCible':
        if (args.length < 2) {
          error("condition non reconnue", args);
          return;
        }
        if (_.has(cof_states, args[1])) {
          return {
            type: 'etatCible',
            etat: args[1],
            text: args[1]
          };
        }
        return {
          type: 'attributCible',
          attribute: args[1],
          local: true,
          text: args[1]
        };
      case 'attributCible':
        if (args.length < 3) {
          error("Il manque un argument pour comparer l'attribut de la cible", args);
          return;
        }
        res = {
          type: 'attribut',
          attribute: args[1],
          valeur: args[2].toLowerCase(),
          text: args[1] + ' ' + args[2]
        };
        if (args.length > 3) {
          if (args[3] == 'local') {
            res.local = true;
          } else if (args[3] == 'fiche') {
            res.fiche = {};
            if (args.length > 4) {
              res.fiche.def = args[4];
            }
          }
        }
        return res;
      case 'predicatCible':
        if (args.length < 2) {
          error("Il manque le pr\xE9dicat de la cible", args);
          return;
        }
        let valeur;
        if (args.length > 2) valeur = args[2];
        return {
          type: 'predicatCible',
          predicat: args[1],
          valeur: valeur,
          text: args[1] + ' ' + valeur
        };
      case 'typeCible':
        if (args.length < 2) {
          error("Il manque le type de la cible", args);
          return;
        }
        return {
          type: 'typeCible',
          race: args[1],
          text: args[1]
        };
      case 'deAttaque':
        if (args.length < 2) {
          error("condition non reconnue", args);
          return;
        }
        let valeurDeAttaque = parseInt(args[1]);
        if (isNaN(valeurDeAttaque)) {
          error("La condition de d\xE9 d'attaque doit \xEAtre un nombre", args);
          // on continue expr\xE8s pour tomber dans le cas par d\xE9faut
        } else {
          return {
            type: 'deAttaque',
            seuil: valeurDeAttaque,
            text: args[1]
          };
        }
        /* falls through */
      default:
        return {
          type: args[0],
          attribute: args[1],
          text: args[1]
        };
    }
  }

  function closeIte(scope) {
    let ps = scope.parentScope;
    if (ps === undefined) return;
    log("Il manque un endif");
    delete scope.parentScope;
    closeIte(ps);
  }

  function getFx(cmd, argName, obj, funName) {
    if (cmd.length < 2) {
      let errMsg = "Il manque un argument \xE0 l'option --" + argName;
      if (funName) errMsg += " de " + funName;
      sendChat("COF", errMsg);
      return;
    }
    if (cmd[1] == 'custom' && cmd.length > 2) {
      let effet = findObjs({
        _type: 'custfx',
        name: cmd[2]
      });
      if (effet.length === 0) {
        sendChat("COF", "L'effet custom " + cmd[2] + " est inconnu.");
        return;
      }
      obj[argName] = effet[0].id;
    } else obj[argName] = cmd[1];
  }

  //parse les expressions du type 3d6+4
  //renvoie un structure avec les champs nbDe, dice et bonus
  function parseDice(expr, msg) {
    let dm = {
      nbDe: 0,
      dice: 4,
      bonus: 0
    };
    let exprDM = expr.trim().toLowerCase();
    let indexD = exprDM.indexOf('d');
    if (indexD > 0) {
      dm.nbDe = parseInt(exprDM.substring(0, indexD));
      if (isNaN(dm.nbDe) || dm.nbDe < 0) {
        if (msg)
          error("Expression de " + msg + ' ' + exprDM + " mal form\xE9e", expr);
        return;
      }
      exprDM = exprDM.substring(indexD + 1);
      indexD = exprDM.search(/[+\-]/);
      if (indexD <= 0) {
        dm.dice = parseInt(exprDM);
        if (isNaN(dm.dice) || dm.dice < 1) {
          if (msg)
            error("Nombre de faces incorrect dans l'expression de " + msg, expr);
          return;
        }
        return dm;
      }
      exprDM = exprDM.replace('+-', '-');
      dm.dice = parseInt(exprDM.substring(0, indexD));
      if (isNaN(dm.dice) || dm.dice < 1) {
        if (msg)
          error("Nombre de faces incorrect dans l'expression de " + msg, expr);
        return;
      }
      exprDM = exprDM.substring(indexD).trim();
    }
    dm.bonus = parseInt(exprDM);
    if (isNaN(dm.bonus)) {
      if (msg)
        error("Expression de " + msg + " incorrecte", expr);
      return;
    }
    return dm;
  }

  function dePositif(d) {
    return d && (d.nbDe * d.dice + d.bonus > 0);
  }

  //Retourne un objet avec
  // - carac, et possiblement carac2 (si on a le choix)
  // - seuil
  function parseSave(cmd) {
    if (cmd.length < 3) {
      if (cmd.length > 0)
        error("Usage : --" + cmd[0] + " carac seuil", cmd);
      else
        error("parsing de sauvegarde", cmd);
      return;
    }
    const res = parseCarac(cmd[1]);
    if (res === undefined) {
      error("Le premier argument de save n'est pas une caract\xE9ristique", cmd);
      return;
    }
    res.seuil = parseInt(cmd[2]);
    if (isNaN(res.seuil)) {
      error("Le deuxi\xE8me argument de --psave n'est pas un nombre", cmd);
      return;
    }
    if (cmd.length > 3) {
      let optArgs = cmd.slice(3).join(' ');
      optArgs = optArgs.split(' +');
      optArgs.forEach(function(oa) {
        oa = oa.trim().split(' ');
        switch (oa[0]) {
          case 'carac':
          case 'carac2':
          case 'seuil':
            error("Argument suppl\xE9mentaire de save inconnu", cmd);
            return;
          case 'tempete':
            let ti = 1;
            if (oa.length > 1) {
              ti = parseInt(oa[1]);
              if (isNaN(ti)) ti = 1;
            }
            res.tempete = ti;
            return;
          case 'contact':
            if (oa.length < 2) {
              error("Il manque la difficult\xE9 pour les cibles au contact");
              return;
            }
            let diff = parseInt(oa[1]);
            if (isNaN(diff)) {
              error("La difficult\xE9 pour les cibles au contact n'est pas un nombre");
              return;
            }
            res.contact = diff;
            return;
          default:
            res[oa[0]] = true;
        }
      });
    }
    return res;
  }

  //juste le traitement d'une liste d'options
  // lastEtat : dernier de etats et effets
  // lastType : dernier type de d\xE9g\xE2ts inflig\xE9s
  // scope : pour les conditionnelles
  function parseAttackOptions(attaquant, optArgs, lastEtat, lastType, scope, playerId, msg, targetToken, attackLabel, weaponStats, options) {
    optArgs.forEach(function(arg) {
      arg = arg.trim();
      let cmd = arg.split(' ');
      cmd = cmd.filter(function(c) {
        return c !== '';
      });
      if (cmd.length === 0) cmd = [arg];
      switch (cmd[0]) {
        case 'enflamme':
        case 'ignoreMoitieRD':
        case 'malediction':
        case 'pressionMortelle':
        case 'pietine':
        case 'percute':
        case 'maxDmg':
        case 'ouvertureMortelle':
        case 'seulementVivant':
        case 'etreinteImmole':
        case 'etreinteScorpion':
        case 'seulementDistance':
        case 'seulementContact':
        case 'tempDmg':
          scope[cmd[0]] = true;
          return;
        case 'affute':
        case 'arc':
        case 'arbalete':
        case 'armeDArgent':
        case 'attaqueAssuree':
        case 'attaqueFlamboyante':
        case 'attaqueRisquee':
        case 'attaqueOptions':
        case 'beni':
        case 'peutAgripper':
        case 'spectral':
        case 'choc':
        case 'epieu':
        case 'hache':
        case 'marteau':
        case 'vicieux':
        case 'artificiel':
        case 'asDeLaGachette':
        case 'attaqueMentale':
        case 'auto':
        case 'avecd12':
        case 'demiAuto':
        case 'energiePositive':
        case 'explodeMax':
        case 'explosion':
        case 'feinte':
        case 'ignoreObstacles':
        case 'mainsDEnergie':
        case 'pasDeDmg':
        case 'pointsVitaux':
        case 'poudre':
        case 'metal':
        case 'adamantium':
        case 'ferFroid':
        case 'reroll1':
        case 'reroll2':
        case 'semonce':
        case 'sortilege':
        case 'strigeSuce':
        case 'tirDeBarrage':
        case 'test':
        case 'traquenard':
        case 'tueurDeGeants': //obsol\xE8te
        case 'tueurDeGrands':
        case 'grenaille':
        case 'attaqueArmeeConjuree':
        case 'difficultePVmax':
        case 'difficultePV':
        case 'lamesJumelles':
        case 'riposte':
        case 'secret':
        case 'saufAllies':
        case 'tirAveugle':
        case 'attaqueBouclierRenverse':
        case 'necromancie':
        case 'runeDePuissance':
          options[cmd[0]] = true;
          return;
        case 'aussiArmeDeJet':
          if (cmd.length < 2) {
            error("Il faut pr\xE9ciser l'arme associ\xE9e \xE0 celle-ci pour --aussiArmeDeJet", cmd);
            return;
          }
          options.aussiArmeDeJet = cmd[1];
          return;
        case 'm2d20':
        case 'avantage':
          options.avantage = options.avantage || 1;
          options.avantage++;
          return;
        case 'd\xE9savantage':
        case 'desavantage':
          options.avantage = options.avantage || 1;
          options.avantage--;
          return;
        case 'avecd12crit':
          options.avecd12 = {
            crit: true
          };
          return;
        case 'tranchant':
        case 'contondant':
        case 'percant':
          options.contondant = undefined;
          options.percant = undefined;
          options.tranchant = undefined;
          options[cmd[0]] = true;
          return;
        case 'nom':
        case 'special':
          if (cmd.length < 1) {
            error("Il manque le nom apr\xE8s l'option --" + cmd[0], cmd);
            return;
          }
          options[cmd[0]] = cmd.slice(1).join(' ').trim();
          return;
        case 'toucher':
        case 'modifiePortee':
          if (cmd.length < 1) {
            error("Il manque la valeur apr\xE8s l'option --" + cmd[0], cmd);
            return;
          }
          let intArg = parseInt(cmd[1]);
          if (isNaN(intArg)) {
            error("valeur de " + cmd[0] + " incorrecte", cmd);
            return;
          }
          options[cmd[0]] = intArg;
          return;
        case 'crit':
          if (cmd.length < 1) {
            error("Il manque la valeur apr\xE8s l'option --crit", cmd);
            return;
          }
          let crit = parseInt(cmd[1]);
          if (isNaN(crit)) {
            error("valeur de critique incorrecte", cmd);
            return;
          }
          if (crit < 2) crit = 2;
          else if (crit > 20) crit = 20;
          options.crit = crit;
          return;
        case 'dm':
          if (cmd.length < 1) {
            error("Il manque la valeur apr\xE8s l'option --dm", cmd);
            return;
          }
          let dm = parseDice(cmd.slice(1).join(''), 'd\xE9g\xE2ts');
          if (dm) options.dm = dm;
          return;
        case 'portee':
          if (cmd.length < 1) {
            error("Il manque la valeur apr\xE8s l'option --portee", cmd);
            return;
          }
          let portee = parseInt(cmd[1]);
          if (isNaN(portee) || portee < 0) {
            error("valeur de critique incorrecte", cmd);
            return;
          }
          options.portee = portee;
          return;
        case 'frappeDesArcanes':
          options.frappeDesArcanes = 2;
          if (cmd.length > 1) {
            options.frappeDesArcanes = parseInt(cmd[1]);
            if (isNaN(options.frappeDesArcanes) || options.frappeDesArcanes < 1)
              options.frappeDesArcanes = 2;
          }
          return;
        case 'attaqueMagiqueDe':
          if (cmd.length < 1) {
            error("Il manque le nom du personnage apr\xE8s l'option --attaqueMagiqueDe", cmd);
            return;
          }
          let attaqueMagiqueDe = cmd.slice(1).join(' ');
          let ficheAttaqueMagique = findObjs({
            type: 'character',
            name: attaqueMagiqueDe
          });
          if (ficheAttaqueMagique.length === 0) {
            error("Il n'existe pas de personnage nomm\xE9 " + attaqueMagiqueDe, cmd);
            return;
          }
          if (ficheAttaqueMagique.length > 1) {
            error("Attention, il existe plus d'un pesonnage nomm\xE9 " + attaqueMagiqueDe, cmd);
          }
          let amCid = {
            charId: ficheAttaqueMagique[0].id
          };
          let toucher = computeArmeAtk(amCid, '@{ATKMAG}');
          if (isNaN(toucher)) {
            error("Impossible de d\xE9terminer l'attaque de " + attaqueMagiqueDe, toucher);
            return;
          }
          if (options.toucher !== undefined) {
            error("Attention, on a \xE0 la fois une option toucher et une option attaqueMagiqueDe. On ignore l'option --toucher", optArgs);
          }
          options.toucher = toucher;
          return;
        case 'imparable': //deprecated
          options.m2d20 = true;
          return;
        case 'tirDouble':
          if (cmd.length > 1)
            options.tirDouble = {
              label: cmd[1]
            };
          else options.tirDouble = options.tirDouble || true;
          return;
        case 'ignoreRD':
          if (cmd.length < 2) {
            scope.ignoreTouteRD = true;
            return;
          }
          scope.ignoreRD = parseInt(cmd[1]);
          if (isNaN(scope.ignoreRD) || scope.ignoreRD < 1) {
            log("Pas un nombre positif apr\xE8s --ignoreRD, interpr\xE9t\xE9 comme ignore toute la RD");
            scope.ignoreRD = undefined;
            scope.ignoreTouteRD = true;
          }
          return;
        case 'tueurDe':
          if (cmd.length < 2) {
            log("Il faut pr\xE9ciser --tueurDe quoi");
            return;
          }
          options.tueurDe = options.tueurDe || [];
          options.tueurDe.push(cmd[1]);
          return;
        case 'magique':
          let niveauMagie = 1;
          if (cmd.length > 1) {
            niveauMagie = parseInt(cmd[1]);
            if (isNaN(niveauMagie) || niveauMagie < 1) {
              error("Le niveau de magie doit \xEAtre au moins 1", cmd);
              niveauMagie = 1;
            }
          }
          options.magique = niveauMagie;
          return;
        case 'si':
          options.conditionAttaquant = parseCondition(cmd.slice(1));
          return;
        case 'tempsRecharge':
          if (cmd.length < 3) {
            error("Il manque un argument \xE0 l'option --tempsRecharge de !cof-attack", cmd);
            return;
          }
          if (!estEffetTemp(cmd[1])) {
            error("Le premier argument de l'option --tempsRecharge doit \xEAtre un effet temporaire r\xE9pertori\xE9", cmd);
            return;
          }
          let tr = parseInt(cmd[2]);
          if (isNaN(tr)) {
            error("Le deuxi\xE8me argument de l'option --tempsRecharge doit \xEAtre un nombre", cmd);
            return;
          }
          options.tempsRecharge = {
            effet: cmd[1],
            duree: tr
          };
          return;
        case 'plus':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --plus de !cof-attack", cmd);
            return;
          }
          let val = arg.substring(arg.indexOf(' ') + 1);
          scope.additionalDmg = scope.additionalDmg || [];
          scope.additionalDmg.push({
            value: val,
            type: scope.type
          });
          break;
        case 'plusCrit':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --plusCrit de !cof-attack", cmd);
            return;
          }
          let valCrit = arg.substring(arg.indexOf(' ') + 1);
          scope.additionalCritDmg = scope.additionalCritDmg || [];
          scope.additionalCritDmg.push({
            value: valCrit,
            type: scope.type
          });
          break;
        case 'dmSiRate':
        case 'dmCible':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --" + cmd[0] + " de !cof-attack", cmd);
            return;
          }
          let valDm = arg.substring(arg.indexOf(' ') + 1);
          options[cmd[0]] = {
            value: valDm,
            type: scope.type
          };
          break;
        case 'effet':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --effet de !cof-attack", cmd);
            return;
          }
          let effet = cmd[1];
          if (cof_states[effet] && cmd.length > 2) { //remplacer par sa version effet temporaire
            effet += 'Temp';
          }
          if (estEffetTemp(effet)) {
            let duree = 1;
            if (cmd.length > 2) {
              duree = parseInt(cmd[2]);
              if (isNaN(duree) || duree < 1) {
                error(
                  "Le deuxi\xE8me argument de --effet doit \xEAtre un nombre positif",
                  cmd);
                return;
              }
            }
            let m = messageOfEffetTemp(effet);
            lastEtat = {
              effet: effet,
              duree: duree,
              message: m,
              typeDmg: lastType
            };
            scope.seulementVivant = scope.seulementVivant || (m && m.seulementVivant);
          } else if (estEffetCombat(effet)) {
            lastEtat = {
              effet: effet,
              typeDmg: lastType,
              message: messageEffetCombat[effet]
            };
          } else if (estEffetIndetermine(effet)) {
            lastEtat = {
              effet: effet,
              effetIndetermine: true,
              typeDmg: lastType
            };
          } else {
            error(cmd[1] + " n'est pas un effet temporaire r\xE9pertori\xE9", cmd);
            return;
          }
          scope.effets = scope.effets || [];
          scope.effets.push(lastEtat);
          return;
        case 'valeur':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --valeur de !cof-attack", cmd);
            return;
          }
          if (scope.effets === undefined || scope.effets.length === 0) {
            error("Il faut un effet avant l'option --valeur", optArgs);
            return;
          }
          scope.effets[0].valeur = cmd[1];
          if (cmd.length > 2) {
            scope.effets[0].valeurMax = cmd[2];
            if (scope.effets[0].effet && scope.effets[0].effet.startsWith('dotGen(')) {
              scope.effets[0].typeDmg = cmd[2];
            }
          }
          return;
        case 'accumuleDuree':
          if (cmd.length < 2) {
            error("Il manque la valeur en argument de l'option --accumuleDuree", cmd);
            return;
          }
          let accumuleDuree = parseInt(cmd[1]);
          if (isNaN(accumuleDuree) || accumuleDuree < 1) {
            error("On ne peut accumuler qu'on nombre strictement positif d'effets", cmd);
            return;
          }
          if (scope.effets === undefined || scope.effets.length === 0) {
            error("Il faut un effet avant l'option --accumuleValeur", optArgs);
            return;
          }
          scope.effets[0].accumuleDuree = accumuleDuree;
          return;
        case 'optionEffet':
          if (cmd.length < 2) {
            error("Il manque l'option en argument de --optionEffet", cmd);
            return;
          }
          if (scope.effets === undefined || scope.effets.length === 0) {
            error("Il faut un effet avant l'option --optionEffet", optArgs);
            return;
          }
          scope.effets[0].options = scope.effets[0].options || '';
          scope.effets[0].options = ' --' + cmd.slice(1).join(' ') + scope.effets[0].options;
          return;
        case 'etatSi':
        case 'etat':
          if (cmd.length < 3 && cmd[0] == 'etatSi') {
            error("Il manque un argument \xE0 l'option --etatSi de !cof-attack", cmd);
            return;
          } else if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --etat de !cof-attack", cmd);
            return;
          }
          let etat = cmd[1];
          if (!_.has(cof_states, etat)) {
            error("Etat non reconnu", cmd);
            return;
          }
          let condition = 'toujoursVrai';
          if (cmd[0] == 'etatSi') {
            condition = parseCondition(cmd.slice(2));
            if (condition === undefined) return;
          }
          scope.etats = scope.etats || [];
          lastEtat = {
            etat: etat,
            condition: condition,
            typeDmg: lastType
          };
          if (cmd[0] == 'etat' && cmd.length > 3) {
            if (!isCarac(cmd[2]) && (cmd[2].length != 6 ||
                !isCarac(cmd[2].substring(0, 3)) || !isCarac(cmd[2].substring(3, 6)))) {
              error("Caract\xE9ristique du jet de sauvegarde incorrecte", cmd);
              return;
            }
            lastEtat.saveCarac = cmd[2];
            let opposition = persoOfId(cmd[3]);
            if (opposition) {
              lastEtat.saveDifficulte = cmd[3] + ' ' + nomPerso(opposition);
            } else {
              lastEtat.saveDifficulte = parseInt(cmd[3]);
              if (isNaN(lastEtat.saveDifficulte)) {
                error("Difficult\xE9 du jet de sauvegarde incorrecte", cmd);
                delete lastEtat.saveCarac;
                delete lastEtat.saveDifficulte;
              }
            }
          }
          scope.etats.push(lastEtat);
          return;
        case 'peur':
          if (cmd.length < 3) {
            error("Il manque un argument \xE0 l'option --peur de !cof-attack", cmd);
            return;
          }
          scope.peur = {
            seuil: parseInt(cmd[1]),
            duree: parseInt(cmd[2])
          };
          if (isNaN(scope.peur.seuil)) {
            error("Le premier argument de --peur doit \xEAtre un nombre (le seuil)", cmd);
          }
          if (isNaN(scope.peur.duree) || scope.peur.duree <= 0) {
            error("Le deuxi\xE8me argument de --peur doit \xEAtre un nombre positif (la dur\xE9e)", cmd);
          }
          return;
        case 'feu':
        case 'froid':
        case 'acide':
        case 'electrique':
        case 'sonique':
        case 'poison':
        case 'maladie':
        case 'argent':
        case 'drain':
        case 'energie':
          lastType = cmd[0];
          let l = 0;
          if (scope.additionalDmg) l = scope.additionalDmg.length;
          if (l > 0) {
            scope.additionalDmg[l - 1].type = cmd[0];
          } else {
            scope.type = cmd[0];
          }
          return;
        case 'nature':
        case 'naturel':
          scope.nature = true;
          return;
        case 'vampirise':
          let vampirise = 100;
          if (cmd.length > 1) {
            vampirise = parseInt(cmd[1]);
            if (isNaN(vampirise)) {
              error("Il faut un pourcentage entier comme argument \xE0 --vampirise", cmd);
              vampirise = 100;
            }
          }
          scope.vampirise = vampirise;
          return;
        case 'sournoise':
          if (scope.sournoise === undefined) scope.sournoise = 0;
          if (cmd.length < 2) {
            scope.sournoise += predicateAsInt(attaquant, 'attaqueSournoise', 1);
            return;
          }
          scope.sournoise += parseInt(cmd[1]);
          if (isNaN(scope.sournoise) || scope.sournoise < 0) {
            error("L'option --sournoise de !cof-attack attend un argument entier positif", cmd);
            return;
          }
          break;
        case 'attaqueAcrobatique':
          if (cmd.length < 2) {
            options.attaqueAcrobatique = predicateAsInt(attaquant, 'attaqueSournoise', 1);
            return;
          }
          options.attaqueAcrobatique = parseInt(cmd[1]);
          if (isNaN(options.attaqueAcrobatique) || options.attaqueAcrobatique < 0) {
            error("L'option --attaqueAcrobatique de !cof-attack attend un argument entier positif", cmd);
            return;
          }
          break;
        case 'disparition':
          if (cmd.length < 2) {
            error("Il manque un argument \xE0 l'option --disparition de !cof-attack", cmd);
            return;
          }
          let disparition = parseInt(cmd[1]);
          if (isNaN(disparition) || disparition < 0) {
            error("L'option --disparition de !cof-attack attend un argument entier positif", cmd);
            return;
          }
          if (options.disparition === undefined) options.disparition = 0;
          options.disparition += disparition;
          return;
        case 'fx':
          getFx(cmd, 'fx', scope, '!cof-attack');
          return;
        case 'targetFx':
          getFx(cmd, 'targetFx', scope, '!cof-attack');
          return;
        case 'psave':
          let psaveopt = scope;
          let psaveParams = parseSave(cmd);
          if (psaveParams) {
            if (psaveParams.local) {
              let psavel = 0;
              if (scope.additionalDmg) psavel = scope.additionalDmg.length;
              if (psavel > 0) {
                psaveopt = scope.additionalDmg[psavel - 1];
              }
            }
            psaveopt.partialSave = psaveParams;
            psaveopt.attaquant = {...attaquant
            };
          }
          return;
        case 'saveDM':
          let saveDMopt = scope;
          let saveDMParams = parseSave(cmd);
          if (saveDMParams) {
            if (saveDMParams.local) {
              let psavel = 0;
              if (scope.additionalDmg) psavel = scope.additionalDmg.length;
              if (psavel > 0) {
                saveDMopt = scope.additionalDmg[psavel - 1];
              }
            }
            saveDMopt.totalSave = saveDMParams;
            saveDMopt.attaquant = {...attaquant
            };
          }
          return;
        case 'save':
          if (lastEtat) {
            if (lastEtat.save) {
              error("Red\xE9finition de la condition de save pour un effet", optArgs);
            }
            let saveParams = parseSave(cmd);
            if (saveParams) {
              lastEtat.save = saveParams;
              lastEtat.save.entrave =
                lastEtat.etat == 'paralyse' || lastEtat.etat == 'immobilise' || lastEtat.etat == 'ralenti' || (lastEtat.message && lastEtat.message.entrave);
              return;
            }
            return;
          }
          error("Pas d'effet auquel appliquer le save", optArgs);
          return;
        case 'saveParTour':
        case 'saveActifParTour':
        case 'saveParJour':
          if (lastEtat) {
            if (lastEtat[cmd[0]]) {
              error("Red\xE9finition de la condition de save pour un effet", optArgs);
            }
            let saveParTourParams = parseSave(cmd);
            if (saveParTourParams) {
              lastEtat[cmd[0]] = saveParTourParams;
              return;
            }
            return;
          }
          error("Pas d'effet auquel appliquer le save", optArgs);
          return;
        case 'retourneEnMain':
          scope.retourneEnMain = {};
          if (cmd.length > 2) {
            let conditionRetour = parseSave(cmd);
            if (conditionRetour) scope.retourneEnMain = conditionRetour;
          }
          return;
        case 'mana':
          {
            if (cmd.length < 2) {
              error("Usage : --mana co\xFBt", cmd);
              return;
            }
            let mana = parseInt(cmd[1]);
            if (isNaN(mana) || mana < 0) {
              error("Le co\xFBt en mana doit \xEAtre un nombre positif");
              return;
            }
            if (scope.mana === undefined) scope.mana = 0;
            scope.mana += mana;
            return;
          }
        case 'magieRapide':
          if (options.magieRapide) return;
          if (options.mana === undefined) options.mana = 0;
          if (reglesOptionelles.mana.val.mana_totale.val) options.mana += 3;
          else options.mana++;
          options.magieRapide = true;
          return;
        case 'tempeteDeMana':
          parseTempeteDeMana(cmd, options);
          return;
        case 'magieEnArmure':
          if (cmd.length > 1) {
            if (cmd[1] == 'mana') {
              options.magieEnArmureMana = true;
            } else {
              let base = parseInt(cmd[1]);
              if (isNaN(base)) {
                error("L'argument de --magieEnArmure doit \xEAtre un nombre ou mana", cmd);
                return;
              }
              options.magieEnArmure = {
                base
              };
            }
          } else {
            options.magieEnArmure = {};
          }
          return;
        case 'rang':
          if (cmd.length < 2) {
            error("Usage : --rang r", cmd);
            return;
          }
          let rang = parseInt(cmd[1]);
          if (isNaN(rang) || rang < 1) {
            error("Le rang doit \xEAtre un nombre positif");
            return;
          }
          scope.rang = rang;
          break;
        case 'bonusAttaque':
        case 'bonusContreBouclier':
        case 'bonusContreArmure':
          if (cmd.length < 2) {
            error("Usage : --" + cmd[0] + " b", cmd);
            return;
          }
          let bAtt = parseInt(cmd[1]);
          if (isNaN(bAtt)) {
            error("Le bonus (" + cmd[0] + ") doit \xEAtre un nombre");
            return;
          }
          if (scope[cmd[0]] === undefined) scope[cmd[0]] = 0;
          scope[cmd[0]] += bAtt;
          return;
        case 'bonusCritique':
        case 'attaqueDeGroupe':
          if (cmd.length < 2) {
            error("Usage : --" + cmd[0] + " b", cmd);
            return;
          }
          let b2Att = parseInt(cmd[1]);
          if (isNaN(b2Att)) {
            error("Le bonus (" + cmd[0] + ") doit \xEAtre un nombre");
            return;
          }
          if (options[cmd[0]] === undefined) options[cmd[0]] = 0;
          options[cmd[0]] += b2Att;
          return;
        case 'puissant':
          if (cmd.length < 2) {
            scope.puissant = true;
            return;
          }
          switch (cmd[1]) {
            case 'oui':
            case 'Oui':
              scope.puissant = true;
              return;
            case 'non':
            case 'Non':
              scope.puissant = false;
              return;
            case 'duree':
              scope.puissantDuree = true;
              return;
            case 'portee':
              scope.puissantPortee = true;
              return;
            default:
              scope.puissant = attributeAsBool(attaquant, cmd[1] + "Puissant");
          }
          return;
        case 'rate':
        case 'touche':
        case 'critique':
        case 'echecCritique':
        case 'pasDEchecCritique':
          if (!playerIsGM(playerId)) {
            sendChat('COF', "Pas le droit d'utiliser l'option --" + cmd[0]);
            return;
          }
          if (options.triche === undefined) {
            options.triche = cmd[0];
          } else {
            error("Option incompatible", optArgs);
          }
          return;
        case 'munition':
          if (options.munition) { //on \xE9vite la r\xE9cursion
            error("Plusieurs options --munition. Seule la premi\xE8re est prise en compte", cmd);
            return;
          }
          if (cmd.length < 2) {
            error("Pour les munitions, il faut pr\xE9ciser le label de la munition", cmd);
            return;
          }
          let labelMunition = cmd[1];
          let munitions = listAllMunitions(attaquant);
          if (munitions[labelMunition]) {
            options.munition = munitions[labelMunition];
            let effetMunition = fieldAsString(options.munition, 'effetmunition', '');
            let optionsMunition = fieldAsString(options.munition, 'optionsmunition', '');
            optionsMunition = (' ' + optionsMunition).split(' --');
            if (optionsMunition.length > 0) optionsMunition.shift();
            if (effetMunition) {
              effetMunition.split(',').reverse().forEach(function(e) {
                e = e.trim();
                if (e === '') return;
                e.split(' ').reverse().forEach(function(e) {
                  e = e.trim();
                  if (e === '') return;
                  optionsMunition.unshift(e);
                });
              });
            }
            if (optionsMunition.length > 0) {
              let r = parseAttackOptions(attaquant, optionsMunition, lastEtat, lastType, scope, playerId, msg, targetToken, attackLabel, weaponStats, options);
              lastEtat = r.lastEtat;
              lastType = r.lastType;
              scope = r.scope;
            }
            return;
          }
          sendPlayer(msg, "Utilisez plut\xF4t les munitions d\xE9finies sur la fiche", playerId);
          //Compatibilit\xE9 avec ancienne version:
          let tauxPertes = 100; //Par d\xE9faut, les munitions sont perdues
          if (cmd.length > 2)
            tauxPertes = parseInt(cmd[2]);
          if (isNaN(tauxPertes) || tauxPertes < 0 || tauxPertes > 100) {
            error("Le taux de pertes des munitions doit \xEAtre un nombre entre 0 et 100");
            tauxPertes = 100;
          }
          options.munition = {
            nom: cmd[1],
            taux: tauxPertes
          };
          return;
        case "ligne":
          if (options.aoe) {
            error("Deux options pour d\xE9finir une aoe", optArgs);
            return;
          }
          options.aoe = {
            type: 'ligne'
          };
          return;
        case 'disque':
          if (options.aoe) {
            error("Deux options pour d\xE9finir une aoe", optArgs);
            return;
          }
          if (cmd.length < 2) {
            error("Il manque le rayon du disque", cmd);
            return;
          }
          options.aoe = {
            type: 'disque',
            rayon: parseInt(cmd[1])
          };
          if (isNaN(options.aoe.rayon) || options.aoe.disque < 0) {
            error("le rayon du disque n'est pas un nombre positif", cmd);
            delete options.aoe;
          }
          if (cmd.length > 2 && cmd[2] == 'souffleDeMort') {
            options.aoe.souffleDeMort = {};
          }
          return;
        case 'cone':
          if (options.aoe) {
            error("Deux options pour d\xE9finir une aoe", optArgs);
            return;
          }
          var angle = 90;
          if (cmd.length > 1) {
            angle = parseInt(cmd[1]);
            if (isNaN(angle) || angle < 0 || angle > 360) {
              error("Param\xE8tre d'angle du cone incorrect", cmd);
              angle = 90;
            }
          }
          options.aoe = {
            type: 'cone',
            angle: angle
          };
          return;
        case 'target':
          if (cmd.length < 2) {
            error("Il manque l'id de la cible", cmd);
            return;
          }
          let targetS = persoOfId(cmd[1]);
          if (targetS === undefined) {
            error("Cible suppl\xE9mentaire invalide", cmd);
            return;
          }
          if (targetToken.id == targetS.token.id) return;
          options.ciblesSupplementaires = options.ciblesSupplementaires || [];
          options.ciblesSupplementaires.push(targetS);
          return;
        case 'canaliseParFamilier':
          {
            let origine = compagnonPresent(attaquant, 'familier');
            if (origine === undefined) {
              sendPlayer(msg, "Pas de familier actif, impossible de canaliser par le familier");
              log("Pas de familier");
              return;
            }
            options.origineDeLAttaque = origine;
            return;
          }
        case 'ricochets':
          {
            if (cmd.length < 2) {
              error("Il manque le nombre de ricochets", cmd);
              return;
            }
            let restants = parseInt(cmd[1]);
            if (isNaN(restants) || restants < 0) return;
            options.ricochets = {
              restants
            };
            cmd.shift();
            cmd.shift();
            options.ricochets.cibles = [];
            let last;
            cmd.forEach(function(cid) {
              let cible = persoOfId(cid);
              if (cible) {
                last = cible;
                options.ricochets.cibles.push(cible);
              }
            });
            if (last) options.origineDeLAttaque = last;
            return;
          }
        case 'ciblesDansDisque':
          if (cmd.length < 2) {
            error("Il manque le rayon du disque dans lequel les cibles doivent tnir", cmd);
            return;
          }
          options.ciblesDansDisque = parseInt(cmd[1]);
          if (isNaN(options.ciblesDansDisque) || options.ciblesDansDisque < 1) {
            error("le rayon du disque n'est pas un nombre positif", cmd);
            delete options.ciblesDansDisque;
          }
          return;
        case 'limiteParJour':
          if (cmd.length < 2) {
            error("Il manque la limite journali\xE8re", cmd);
            return;
          }
          let limiteParJour = parseInt(cmd[1]);
          if (isNaN(limiteParJour) || limiteParJour < 1) {
            error("La limite journali\xE8re doit \xEAtre un nombre positif", cmd);
            return;
          }
          scope.limiteParJour = limiteParJour;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            scope.limiteParJourRessource = cmd.join('_');
          }
          return;
        case 'limiteParCombat':
          if (cmd.length < 2) {
            scope.limiteParCombat = 1;
            return;
          }
          let limiteParCombat = parseInt(cmd[1]);
          if (isNaN(limiteParCombat) || limiteParCombat < 1) {
            error("La limite par combat doit \xEAtre un nombre positif", cmd);
            return;
          }
          scope.limiteParCombat = limiteParCombat;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            scope.limiteParCombatRessource = cmd.join('_');
          }
          return;
        case 'decrAttribute':
          if (cmd.length < 2) {
            error("Erreur interne d'une commande g\xE9n\xE9r\xE9e par bouton", cmd);
            return;
          }
          let attr = getObj('attribute', cmd[1]);
          if (attr === undefined) {
            attr = tokenAttribute(attaquant, cmd[1]);
            if (attr.length === 0) {
              log("Attribut \xE0 changer perdu");
              log(cmd);
              return;
            }
            attr = attr[0];
          }
          scope.decrAttribute = attr.id; //Seulement l'id pour pouvoir cloner
          return;
        case 'decrLimitePredicatParTour':
          if (cmd.length < 2) {
            error("Erreur interne d'une commande g\xE9n\xE9r\xE9e par bouton", cmd);
            return;
          }
          scope.decrLimitePredicatParTour = cmd[1];
          return;
        case 'forceMinimum':
          if (cmd.length < 2) {
            error("Il faut indiquer le minimum de force", cmd);
            return;
          }
          let forceMin = parseInt(cmd[1]);
          if (isNaN(forceMin)) {
            error("La force minimum doit \xEAtre un nombre", cmd);
            return;
          }
          scope.forceMinimum = forceMin;
          return;
        case 'arcComposite':
          if (cmd.length < 2) {
            error("Il faut indiquer le bonus de l'arc composite", cmd);
            return;
          }
          let arcComposite = parseInt(cmd[1]);
          if (isNaN(arcComposite)) {
            error("Le bonus d'arc composite doit \xEAtre un nombre", cmd);
            return;
          }
          scope.arcComposite = arcComposite;
          return;
        case 'incrDmgCoef':
          scope.dmgCoef = (scope.dmgCoef || 1);
          if (cmd.length > 1) {
            var incrDmgCoef = parseInt(cmd[1]);
            if (isNaN(incrDmgCoef)) {
              error("L'option --incrDmgCoef attend un entier", cmd);
              return;
            }
            scope.dmgCoef += incrDmgCoef;
            return;
          }
          scope.dmgCoef++; //Par d\xE9faut, incr\xE9mente de 1
          return;
        case 'diviseDmg':
          scope.diviseDmg = (scope.diviseDmg || 1);
          if (cmd.length > 1) {
            let divise = parseInt(cmd[1]);
            if (isNaN(divise)) {
              error("L'option --diviseDmg attend un entier", cmd);
              return;
            }
            scope.diviseDmg *= divise;
            return;
          }
          scope.diviseDmg *= 2; //Par d\xE9faut, divise par 2
          return;
        case 'divisePortee':
          scope.divisePortee = (scope.divisePortee || 1);
          if (cmd.length > 1) {
            let divise = parseInt(cmd[1]);
            if (isNaN(divise)) {
              error("L'option --divisePortee attend un entier", cmd);
              return;
            }
            scope.divisePortee *= divise;
            return;
          }
          scope.divisePortee *= 2; //Par d\xE9faut, divise par 2
          return;
        case 'incrCritCoef':
          scope.critCoef = (scope.critCoef || 1);
          if (cmd.length > 1) {
            let incrCritCoef = parseInt(cmd[1]);
            if (isNaN(incrCritCoef)) {
              error("L'option --incrCritCoef attend un entier", cmd);
              return;
            }
            scope.critCoef += incrCritCoef;
            return;
          }
          scope.critCoef++; //Par d\xE9faut, incr\xE9mente de 1
          return;
        case 'if':
          let ifCond = parseCondition(cmd.slice(1));
          if (ifCond === undefined) return;
          let ifThen = {
            parentScope: scope
          };
          scope.ite = scope.ite || [];
          scope.ite.push({
            condition: ifCond,
            then: ifThen
          });
          scope = ifThen;
          return;
        case 'ifSaveFails':
          let save = parseSave(cmd);
          if (save === undefined) return;
          let ifSaveThen = {
            parentScope: scope
          };
          scope.ite = scope.ite || [];
          let ifSaveCond = {
            type: 'save',
            saveCond: save,
            typeDmg: lastType
          };
          scope.ite.push({
            condition: ifSaveCond,
            then: ifSaveThen
          });
          scope = ifSaveThen;
          return;
        case "endif":
          let psEndif = scope.parentScope;
          if (psEndif === undefined) {
            error("--endIf sans --if correspondant", cmd);
            return;
          }
          delete scope.parentScope; //To remove circular dependencies in options
          scope = psEndif;
          return;
        case "else":
          {
            let psElse = scope.parentScope;
            if (psElse === undefined) {
              error("--else sans --if correspondant", cmd);
              return;
            }
            let iteL = psElse.ite[psElse.ite.length - 1];
            if (iteL.else) {
              error("Il y a d\xE9j\xE0 un --else pour ce --if", cmd);
              return;
            }
            delete scope.parentScope;
            let ifElse = {
              parentScope: psElse
            };
            iteL.else = ifElse;
            scope = ifElse;
            return;
          }
        case 'message':
          if (cmd.length < 2) {
            error("Il manque le message apr\xE8s --message", cmd);
            return;
          }
          scope.messages = scope.messages || [];
          scope.messages.push(cmd.slice(1).join(' '));
          return;
        case 'allonge':
          if (cmd.length < 2) {
            error("Il manque le message apr\xE8s --allonge", cmd);
            return;
          }
          if (options.allonge !== undefined) {
            log("Red\xE9finition de l'allong");
          }
          options.allonge = parseFloat(cmd[1]);
          if (isNaN(options.allonge)) {
            error("L'argument de --allonge n'est pas un nombre", cmd);
          }
          return;
        case 'enveloppe':
          scope.enveloppe = {
            difficulte: 15,
            type: 'label',
            expression: attackLabel
          };
          if (cmd.length > 1) {
            scope.enveloppe.difficulte = parseInt(cmd[1]);
            if (isNaN(scope.enveloppe.difficulte))
              scope.enveloppe.difficulte = 15;
          }
          if (cmd.length > 3) {
            scope.enveloppe.type = cmd[2];
            scope.enveloppe.expression = cmd[3];
          }
          if (scope.enveloppe.expression === undefined) {
            error("Il n'est pas encore possible d'utiliser l'option --enveloppe sans expression si le label de l'attaque n'est pas d\xE9fini", cmd);
            scope.enveloppe = undefined;
          }
          return;
        case 'etreinte':
          scope.enveloppe = {
            difficulte: 15,
            type: 'etreinte',
            expression: '1d6',
          };
          if (cmd.length > 1) {
            scope.enveloppe.difficulte = parseInt(cmd[1]);
            if (isNaN(scope.enveloppe.difficulte))
              scope.enveloppe.difficulte = 15;
          }
          if (cmd.length > 2) {
            scope.enveloppe.expression = cmd[2];
          }
          return;
        case 'imgAttack':
        case 'imgAttackEchec':
        case 'imgAttackEchecCritique':
        case 'imgAttackEchecClignotement':
        case 'imgAttackSucces':
        case 'imgAttackSuccesChampion':
        case 'imgAttackSuccesCritique':
          if (cmd.length < 1) {
            error("Il manque une image apr\xE8s --" + cmd[0], cmd);
            return;
          }
          options[cmd[0]] = cmd[1];
          return;
        case 'soundAttack':
        case 'soundAttackEchec':
        case 'soundAttackEchecCritique':
        case 'soundAttackEchecClignotement':
        case 'soundAttackSucces':
        case 'soundAttackSuccesChampion':
        case 'soundAttackSuccesCritique':
          if (cmd.length < 1) {
            error("Il manque le son apr\xE8s --" + cmd[0], cmd);
            return;
          }
          options[cmd[0]] = cmd.slice(1).join(' ');
          return;
          //Anciennes variantes, gard\xE9es pour la compatibilit\xE9
        case 'img-attack-echec-critique':
        case 'img-attack-echec':
        case 'img-attack-echec-clignotement':
        case 'img-attack-normal-touch':
        case 'img-attack-succes':
        case 'img-attack-champion-succes':
        case 'img-attack-succes-champion':
        case 'img-attack-succes-critique':
          if (cmd.length < 1) {
            error("Il manque une image apr\xE8s --" + cmd[0], cmd);
            return;
          }
          var imgCmd = cmd[0].replace('-a', 'A').replace('-e', 'E').replace('-c', 'C').replace('-n', 'N').replace('-s', 'S').replace('-t', 'T');
          if (imgCmd == 'imgAttackNormalTouch') imgCmd = 'imgAttackSucces';
          if (imgCmd == 'imgAttackChampionSucces') imgCmd = 'imgAttackSuccesChampion';
          options[imgCmd] = cmd[1];
          return;
        case 'sound-attack-echec-critique':
        case 'sound-attack-echec':
        case 'sound-attack-echec-clignotement':
        case 'sound-attack-normal-touch':
        case 'sound-attack-succes':
        case 'sound-attack-champion-succes':
        case 'sound-attack-succes-champion':
        case 'sound-attack-succes-critique':
          if (cmd.length < 2) {
            error("Il manque le son apr\xE8s --" + cmd[0], cmd);
            return;
          }
          let soundCmd = cmd[0].replace('-a', 'A').replace('-e', 'E').replace('-c', 'C').replace('-n', 'N').replace('-s', 'S').replace('-t', 'T');
          if (soundCmd == 'soundAttackNormalTouch') soundCmd = 'soundAttackSucces';
          if (soundCmd == 'soundAttackChampionSucces') soundCmd = 'soundAttackSuccesChampion';
          options[soundCmd] = cmd.slice(1).join(' ');
          return;
        case 'affaiblirCarac':
          if (cmd.length < 3) {
            error("Usage: --affaiblirCarac carac n", cmd);
            return;
          }
          let carac = cmd[1];
          switch (carac) {
            case 'force':
            case 'dexterite':
            case 'constitution':
            case 'sagesse':
            case 'intelligence':
            case 'charisme':
            case 'random':
              break;
            case 'FOR':
              carac = 'force';
              break;
            case 'dext\xE9rit\xE9':
            case 'DEX':
              carac = 'dexterite';
              break;
            case 'CON':
              carac = 'constitution';
              break;
            case 'SAG':
              carac = 'sagesse';
              break;
            case 'INT':
              carac = 'intelligence';
              break;
            case 'CHA':
              carac = 'charisme';
              break;
            case 'rand':
            case 'RAND':
              carac = 'random';
              break;
            default:
              error("Le premier argument de affaiblirCarac n'est pas une caract\xE9ristique", cmd);
              return;
          }
          let valAff = parseInt(cmd[2]);
          if (isNaN(valAff)) {
            error("Le deuxi\xE8me argument de --affaiblirCarac doit \xEAtre un nombre", cmd);
            return;
          }
          if (valAff === 0) return;
          scope.affaiblissementsCarac = scope.affaiblissementsCarac || [];
          scope.affaiblissementsCarac.push({
            carac,
            val: valAff
          });
          return;
        case 'difficulteCarac':
          if (cmd.length < 2) {
            error("Il manque la caract\xE9ristique \xE0 laquelle mesurer le jet d'attaque", cmd);
            return;
          }
          options.difficulteCarac = parseCarac(cmd[1]);
          if (options.difficulteCarac === undefined) {
            error("L'argument de --difficulteCarac n'est pas une caract\xE9ristique", cmd);
          }
          return;
        case 'attackId':
          if (cmd.length < 2) {
            error("Il faut indiquer l'id", cmd);
            return;
          }
          options.attackId = cmd[1];
          return;
        default:
          let armeMagique = cmd[0].match(/^\+([0-9]+)$/);
          if (armeMagique && armeMagique.length > 0) {
            let amp = parseInt(armeMagique[1]);
            //gestion du cumul des bonus
            if (options.armeMagiquePlus) {
              let bmp = amp;
              if (amp > options.armeMagiquePlus) {
                bmp = options.armeMagiquePlus;
                options.armeMagiquePlus = amp;
              }
              if (weaponStats.portee) weaponStats.portee += 10 * bmp;
            } else options.armeMagiquePlus = amp;
            if (options.magique === undefined) {
              options.magique = options.armeMagiquePlus;
            } else if (options.magique !== true) {
              options.magique += options.armeMagiquePlus;
            }
          } else {
            error("Argument de !cof-attack '" + arg + "' non reconnu", cmd);
          }
      }
    });
    closeIte(scope); //pour fermer les endif mal form\xE9s et \xE9viter les boucles
    return {
      lastEtat,
      lastType,
      scope
    };
  }

  //!cof-attack id_attaquant id_cible label_attaque [options]
  function parseAttack(msg) {
    const playerId = getPlayerIdFromMsg(msg);
    if (stateCOF.pause && !playerIsGM(playerId)) {
      sendPlayer(msg, "Le jeu est en pause", playerId);
      return;
    }
    let optArgs = msg.content.split(' --');
    let args = optArgs[0].split(' ');
    args = args.filter(function(a) {
      return a !== '';
    });
    optArgs.shift();
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-attack: " + msg.content, args);
      return;
    }
    const attaquant = persoOfId(args[1]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-attack n'est pas un token valide", args[1]);
      return;
    }
    let pageId = attaquant.token.get('pageid');
    let targetToken = getObj('graphic', args[2]);
    if (targetToken === undefined) { //reste la possibilit\xE9 de trouver un token de ce nom
      let tokens = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        name: args[2]
      });
      if (tokens.length == 0) {
        error("le second argument de !cof-attack doit \xEAtre un token", args[2]);
        return;
      }
      if (tokens.length > 1) {
        error("Ambig\xFCit\xE9 sur le choix d'un token : il y a " +
          tokens.length + " tokens nomm\xE9s " + args[2], tokens);
      }
      targetToken = tokens[0];
    }
    let attackLabel = -1;
    if (args.length > 3) {
      attackLabel = args.slice(3).join(' ').trim();
    }
    let weaponStats;
    let attaqueArray;
    try {
      attaqueArray = JSON.parse(attackLabel); //plus document\xE9 depuis 2020
    } catch (e) {}
    if (Array.isArray(attaqueArray) && attaqueArray.length > 4 &&
      attaqueArray[1].length > 1 && attaqueArray[3].length > 3) {
      weaponStats = {};
      weaponStats.name = attaqueArray[0].replace(/_/g, ' ');
      weaponStats.attSkill = attaqueArray[1][0];
      weaponStats.attSkillDiv = attaqueArray[1][1];
      weaponStats.crit = attaqueArray[2];
      const weaponDmg = attaqueArray[3];
      weaponStats.attNbDices = weaponDmg[0];
      weaponStats.attDice = weaponDmg[1];
      weaponStats.attCarBonus = weaponDmg[2];
      weaponStats.attDMBonusCommun = weaponDmg[3];
      weaponStats.portee = attaqueArray[4];
      if (attaqueArray.length > 5) {
        weaponStats.divers = attaqueArray[5];
      } else {
        weaponStats.divers = '';
      }
      weaponStats.options = '';
    } else {
      //On trouve l'attaque correspondant au label
      if (attackLabel == -1) { //attaque avec l'arme en main
        weaponStats = armesEnMain(attaquant);
        if (attributeAsBool(attaquant, 'paradeCroisee')) {
          let main = randomInteger(2);
          if (main == 2) weaponStats = attaquant.armeGauche;
          if (weaponStats === undefined) weaponStats = attaqueAMainsNues;
          if (main == 1) weaponStats.attaquePaire = true;
          else weaponStats.attaqueImpaire = true;
        }
      } else if (attackLabel == -2) { //attaque avec l'arme en main gauche
        if (attaquant.armesEnMain === undefined) armesEnMain(attaquant);
        weaponStats = attaquant.armeGauche;
      }
      if (weaponStats === undefined) {
        let arme = armesEnMain(attaquant);
        if (arme && arme.label == attackLabel) weaponStats = arme;
        else weaponStats = getWeaponStats(attaquant, attackLabel);
      }
    }
    if (weaponStats === undefined) {
      error("Impossible de trouver l'arme pour l'attaque", attackLabel);
      return;
    }
    if (weaponStats.deuxMains && attributeAsBool(attaquant, 'espaceExigu')) {
      sendPerso(attaquant, "ne peut pas utiliser d'arme \xE0 deux mains dans un espace aussi exigu.");
      return;
    }
    //Si c'est aussi une arme de jet, et que le personnage attaque \xE0 distance, on va utiliser la version arme de jet de l'attaque.
    let msgIndex = msg.content;
    let indexAussiJet = msgIndex.indexOf('--aussiArmeDeJet ');
    if (indexAussiJet == -1 && weaponStats.options) {
      msgIndex = weaponStats.options;
      indexAussiJet = msgIndex.indexOf('--aussiArmeDeJet ');
    }
    if (indexAussiJet > 0) {
      let labelAussiJet = parseInt(msgIndex.substring(indexAussiJet + 17));
      if (isNaN(labelAussiJet)) {
        error("Label --aussiArmeDeJet n'est pas un entier", msgIndex.substring(indexAussiJet + 17));
      } else {
        let armeAssociee = getWeaponStats(attaquant, labelAussiJet);
        if (armeAssociee === undefined) {
          error("Label --aussiArmeDeJet pas une attaque", labelAussiJet);
        } else {
          if (distanceCombat(attaquant.token, targetToken) > 0)
            weaponStats = armeAssociee;
        }
      }
    }
    //Ajout des options de l'arme
    let wo = weaponStats.options.trim();
    //Pour la partie options, il est possible qu'elle soit d\xE9j\xE0 pass\xE9e en ligne de commande
    if (wo !== '' && ((optArgs.length < 1 || !optArgs[0].startsWith('attaqueOptions'))) || indexAussiJet > 0) {
      wo = ' ' + wo;
      wo.split(' --').reverse().forEach(function(o) {
        o = o.trim();
        if (o === '') return;
        optArgs.unshift(o);
      });
    }
    if (weaponStats.modificateurs) {
      weaponStats.modificateurs.split(',').reverse().forEach(function(m) {
        m = m.trim();
        if (m === '') return;
        m.split(' ').reverse().forEach(function(m) {
          m = m.trim();
          if (m === '') return;
          optArgs.unshift(m);
        });
      });
    }
    const options = {
      sortilege: weaponStats.sortilege,
      hache: weaponStats.hache,
      armeNaturelle: weaponStats.armeNaturelle,
      poudre: weaponStats.poudre,
      arme: weaponStats.arme || weaponStats.armeGauche || weaponStats.armeDeJet,
    };
    switch (weaponStats.typeDegats) {
      case 'mental':
        options.attaqueMentale = true;
        /* falls through */
      case 'feu':
      case 'froid':
      case 'acide':
      case 'electrique':
      case 'sonique':
      case 'poison':
      case 'maladie':
      case 'drain':
      case 'energie':
        options.type = weaponStats.typeDegats;
        break;
      case 'magique':
        options.magique = true;
        options.type = 'energie'; //Les d\xE9g\xE2ts magiques sans type associ\xE9 sont suppos\xE9s de type \xE9nergie, l'\xE9quivalent de force dans PF1
        break;
      case 'tranchant':
      case 'percant':
      case 'contondant':
        options[weaponStats.typeDegats] = true;
        break;
    }
    let lastEtat; //dernier de etats et effets
    let lastType = options.type; //dernier type de d\xE9g\xE2ts inflig\xE9s
    let scope = options; //Pour les conditionnelles
    parseAttackOptions(attaquant, optArgs, lastEtat, lastType, scope, playerId, msg, targetToken, attackLabel, weaponStats, options);
    let bene = predicateAsInt(attaquant, 'benedictionSuperieure', 0);
    if (bene) {
      if (!options.armeMagiquePlus || options.armeMagiquePlus < bene) {
        options.armeMagiquePlus = bene;
        if (!options.magique) options.magique = bene;
        else options.magique += bene;
      }
    }
    options.additionalDmg = options.additionalDmg || [];
    if (options.tempeteDeMana) {
      if (options.tempeteDeMana.cout === 0) {
        //On demande de pr\xE9ciser les options
        let optMana = {
          mana: options.mana,
          rang: options.rang,
          portee: true //Pour avoir l'option
        };
        if (!options.pasDeDmg) optMana.dm = true;
        if (options.effets) {
          options.effets.forEach(function(ef) {
            if (ef.effet) {
              if (estEffetTemp(ef.effet)) {
                optMana.dm = optMana.dm || (ef.message && ef.message.dm);
                optMana.soins = optMana.soins || (ef.message && ef.message.soins);
                optMana.duree = true;
              }
            } else if (estEffetCombat(ef.effet)) {
              optMana.dm = optMana.dm || messageEffetCombat[ef.effet].dm;
              optMana.soins = optMana.soins || messageEffetCombat[ef.effet].soins;
            }
          });
        }
        if (options.peur && options.peur.duree) optMana.duree = true;
        setTempeteDeMana(playerId, attaquant, msg.content, optMana);
        return;
      } else {
        if (options.rang && options.tempeteDeMana.cout > options.rang) {
          sendPlayerAndGM(msg, playerId, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
        }
      }
    }
    if (options.tempeteDeManaDuree || options.puissantDuree) {
      if (options.pasDeDmg) {
        if (options.peur && options.peur.duree)
          options.peur.duree = options.peur.duree * 2;
        if (options.effets) {
          options.effets.forEach(function(ef) {
            if (ef.effet && ef.duree && !ef.message.dm && !ef.message.soins) {
              ef.duree = ef.duree * 2;
            }
          });
        }
      } else {
        if (options.tempeteDeManaDuree) {
          sendPlayerAndGM(msg, playerId, "Attention, l'option temp\xEAte de mana pour la dur\xE9e n'est pas prise en compte. Utiliser l'option --pasDeDmg si le sort ne fait pas de DM");
          options.tempeteDeManaDuree = false;
          if (options.tempeteDeMana && options.tempeteDeMana.cout)
            options.tempeteDeMana.cout--;
          if (options.mana) {
            if (reglesOptionelles.mana.val.mana_totale.val) options.mana -= 3;
            else options.mana--;
          }
        }
      }
    }
    let playerName = msg.who;
    if (playerIsGM(playerId)) playerName = 'GM';
    attack(playerName, playerId, attaquant, targetToken, weaponStats, options);
  }

  function attackCallback(options, evt) {
    if (!options.attackId) return;
    let combat = stateCOF.combat;
    if (!combat || !combat.attackCallbacks) return;
    let f = combat.attackCallbacks[options.attackId];
    if (!evt) {
      evt = {
        type: "Suite d'attaque"
      };
      addEvent(evt);
    }
    if (f) f(evt);
  }

  // Fait d\xE9penser de la mana, dep doit contenir une d\xE9pense possible
  function depenseMana(perso, dep, msg, evt) {
    if (!dep || dep.cout_null) return;
    updateCurrentBar(perso, 2, dep.pm, evt);
    msg = msg || '';
    if (dep.depense_pv) {
      let source = reglesOptionelles.mana.val.brulure_de_magie.val ? "de la Br\xFBlure de Magie" : "du Contrecoup";
      updateCurrentBar(perso, 1, dep.pv, evt);
      let pre = 'p';
      if (stateCOF.options.affichage.val.depense_mana.val && dep.depense_pm > 0)
        pre = "d\xE9pense " + dep.depense_pm + " PM et p";
      sendPerso(perso, pre + "erd " + dep.depense_pv + " PV \xE0 cause " + source + " pour " + msg);
    } else {
      if (stateCOF.options.affichage.val.depense_mana.val)
        sendPerso(perso, "d\xE9pense " + dep.depense_pm + " PM pour " + msg);
    }
    let niveau = ficheAttributeAsInt(perso, 'niveau', 1);
    if (reglesOptionelles.mana.val.mana_totale.val) {
      if (dep.depense_pm > niveau * 3) {
        sendPerso(perso, "Attention, la d\xE9pense totale de mana est sup\xE9rieure au niveau * 3");
      }
    } else {
      if (dep.depense_pm > niveau) {
        sendPerso(perso, "Attention, la d\xE9pense totale de mana est sup\xE9rieure au niveau");
      }
    }
    return;
  }

  //renvoie un objet avec le champ carac (+carac2 possible), et undefined si erreur
  function parseCarac(arg) {
    if (arg.length == 3) {
      if (!isCarac(arg)) return;
      return {
        carac: arg
      };
    } else if (arg.length == 6) { //Choix parmis 2 caracs
      let carac = arg.substr(0, 3);
      let carac2 = arg.substr(3, 3);
      if (!isCarac(carac) || !isCarac(carac2)) return;
      return {
        carac,
        carac2
      };
    }
  }

  function persoEstDeCategorie(perso, categorie) {
    switch (categorie) {
      case 'animal':
        return estAnimal(perso);
      case 'demon':
      case 'd\xE9mon':
        return estDemon(perso);
      case 'dragon':
        return estDraconique(perso);
      case 'drow':
      case 'elfe-noir':
        return estElfeNoir(perso);
      case 'fee':
      case 'f\xE9e':
        return estFee(perso);
      case 'g\xE9ant':
      case 'geant':
        return estGeant(perso);
      case 'gobelin':
        return estGobelin(perso);
      case 'insecte':
        return estInsecte(perso);
      case 'mauvais':
        return estMauvais(perso);
      case 'mort-vivant':
        return estMortVivant(perso);
      default:
        return raceIs(perso, categorie) || predicateAsBool(perso, categorie);
    }
  }

  //Si l'attribut est un mod. de caract\xE9ristique, va chercher le
  //bon attribut, selon que perso est un PNJ ou nom
  function valAttribute(perso, originalAttr, caracAttr) {
    if (caracAttr) {
      if (persoEstPNJ(perso)) {
        return 10 + ficheAttributeAsInt(perso, PNJCaracOfMod(originalAttr), 0) * 2;
      }
      return ficheAttributeAsInt(perso, caracAttr, 0);
    }
    return charAttributeAsInt(perso, originalAttr, 0);
  }

  //test si l'attribut est pr\xE9sent et si sa valeur est bonne
  // options peut contenir
  // fiche : si on cherche un attribut de fiche, et dans ce cas, le champ def donne la valeur par d\xE9faut
  // local : si c'est un attribut diff\xE9rent selon le mook
  function testAttribut(perso, attrName, valeur, options) {
    let attr;
    if (options.fiche) {
      attr = ficheAttribute(perso, attrName, options.fiche.def);
      if (attr === undefined) return false;
      return (attr + '').toLowerCase() == valeur;
    }
    if (options.local) attr = tokenAttribute(perso, attrName);
    else attr = charAttribute(perso.charId, attrName);
    if (attr.length === 0) return false;
    return (attr[0].get('current') + '').toLowerCase() == valeur;
  }

  function testCondition(cond, attaquant, cibles, deAttaque, options) {
    if (cond == 'toujoursVrai') return true;
    switch (cond.type) {
      case 'moins':
        // Au cas o\xF9 on utilise les MOD au lieu de l'attribut de base:
        let caracAttr = caracOfMod(cond.attribute);
        let attackerAttr = valAttribute(attaquant, cond.attribute, caracAttr);
        let resMoins = true;
        cibles.forEach(function(target) {
          if (resMoins) {
            let targetAttr = valAttribute(target, cond.attribute, caracAttr);
            if (targetAttr >= attackerAttr) resMoins = false;
          }
        });
        return resMoins;
      case 'etat':
        return (getState(attaquant, cond.etat));
      case 'etatCible':
        let resEtatCible = true;
        cibles.forEach(function(target) {
          if (resEtatCible && !getState(target, cond.etat))
            resEtatCible = false;
        });
        return resEtatCible;
      case 'attribut':
        {
          if (cond.valeur === undefined) {
            if (attributeAsBool(attaquant, cond.attribute)) return true;
            if (cond.attribute == 'armeDArgent') {
              return attributeAsBool(attaquant, 'formeDAnge') && predicateAsInt(attaquant, 'voieDeLArchange', 1) > 2;
            }
            return false;
          }
          return testAttribut(attaquant, cond.attrbute, cond.valeur, cond);
        }
      case 'attributCible':
        {
          if (cond.valeur === undefined) {
            let res = cibles.every(function(target) {
              return attributeAsBool(target, cond.attribute);
            });
            return res;
          }
          let res = cibles.every(function(target) {
            return testAttribut(target, cond.attrbute, cond.valeur, cond);
          });
          return res;
        }
      case 'predicatCible':
        let resp = cibles.every(function(target) {
          if (cond.valeur === undefined) return predicateAsBool(target, cond.predicat);
          return predicateAsBool(target, cond.predicat) == cond.valeur;
        });
        return resp;
      case 'typeCible':
        let rest = cibles.every(function(target) {
          return persoEstDeCategorie(target, cond.race);
        });
        return rest;
      case 'deAttaque':
        if (options && options.auto) return false;
        if (deAttaque === undefined) {
          error("Condition de d\xE9 d'attaque non support\xE9e ici", cond);
          return true;
        }
        return deAttaque >= cond.seuil;
      case 'echecCritique':
        if (deAttaque === undefined) {
          error("Condition de d\xE9 d'attaque non support\xE9e ici", cond);
          return true;
        }
        return deAttaque == 1;
      case 'touche':
        return cibles.every(function(target) {
          return target.touche;
        });
      case 'critique':
        return cibles.every(function(target) {
          return target.critique;
        });
      default:
        error("Condition non reconnue", cond);
    }
    return false;
  }

  function estNecromancie(options) {
    return options.necromancie || options.malediction ||
      (options.vampirise && options.sortilege) || options.peur ||
      options.type == 'drain';
  }

  //On copie les champs de scope dans options ou dans target
  function copyBranchOptions(attaquant, branch, options, target, evt, explications, condInTarget) {
    let opt = options;
    if (condInTarget) opt = target;
    for (let field in branch) {
      switch (field) {
        case 'ite':
          break;
        case 'additionalDmg':
        case 'additionalCritDmg':
        case 'effets':
        case 'etats':
        case 'affaiblissementsCarac': //Listes
          opt[field] = opt[field] || [];
          opt[field] = opt[field].concat(branch[field]);
          break;
        case 'sournoise':
        case 'mana':
        case 'bonusAttaque':
        case 'bonusContreArmure':
        case 'bonusContreBouclier': //num\xE9riques additives
          opt[field] = opt[field] || 0;
          opt[field] += branch[field];
          break;
        case 'dmgCoef':
        case 'critCoef':
          if (opt[field] === undefined) {
            if (condInTarget) opt[field] = 0;
            else opt[field] = 1;
          }
          opt[field] += branch[field] - 1;
          break;
        case 'diviseDmg':
          if (opt[field] === undefined) {
            opt[field] = 1;
          }
          opt[field] *= branch[field];
          break;
        case 'messages':
          if (condInTarget)
            target.messages = target.messages.concat(branch.messages);
          else { /*jshint loopfunc: true */
            branch.messages.forEach(function(m) {
              explications.push(m);
            });
          }
          break;
        case 'decrAttribute':
          let attr = getObj('attribute', branch.decrAttribute);
          if (attr === undefined) {
            error("Attribut introuvable", branch.decrAttribute);
            break;
          }
          let oldval = parseInt(attr.get('current'));
          if (isNaN(oldval) || oldval < 1) {
            sendChar(attr.get('characterid'), "ne peut plus faire cela", true);
            break;
          }
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attr,
            current: oldval,
            max: attr.get('max')
          });
          attr.set('current', oldval - 1);
          break;
        case 'decrLimitePredicatParTour':
          //Ne fait que diminuer l'attribut, n'emp\xEAche pas l'attaque
          let pred = branch.decrLimitePredicatParTour;
          let test = testLimiteUtilisationsCapa(attaquant, pred, 'tour',
            "ne peut plus utiliser " + pred + " ce tour",
            "Attaque impossible, pas de pr\xE9dicat " + pred);
          if (test === undefined) break;
          utiliseCapacite(attaquant, test, evt);
          break;
        default:
          opt[field] = branch[field];
      }
    }
  }

  function callIfAllDone(etat, callback) {
    etat.aTraiter--;
    while (etat.aTraiter === 0 && etat.parent) {
      etat = etat.parent;
      etat.aTraiter--;
    }
    if (etat.aTraiter === 0) callback();
  }

  //Evaluation r\xE9cursive des if-then-else
  function evalITE(attaquant, target, deAttaque, options, phase, evt, explications, scope, callback, inTarget, etatParent) {
    etatParent = etatParent || {};
    if (scope.ite === undefined || scope.ite.length < 1) {
      etatParent.aTraiter = 1;
      callIfAllDone(etatParent, callback);
      return;
    }
    etatParent.aTraiter = scope.ite.length;
    scope.ite = scope.ite.filter(function(ite) {
      let condInTarget = inTarget;
      let resCondition;
      if (ite.condition == 'toujoursVrai') resCondition = true;
      switch (ite.condition.type) {
        case 'etat':
        case 'attribut':
          resCondition = testCondition(ite.condition, attaquant, [], deAttaque);
          break;
        case 'deAttaque':
          if (options.auto) {
            resCondition = false;
            break;
          }
          if (deAttaque === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          resCondition = testCondition(ite.condition, attaquant, [], deAttaque);
          break;
        case 'moins':
        case 'etatCible':
        case 'attributCible':
        case 'predicatCible':
        case 'typeCible':
          if (target === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          condInTarget = true;
          resCondition = testCondition(ite.condition, attaquant, [target], deAttaque);
          break;
        case 'critique':
        case 'touche':
          if (phase === 1 && target === undefined) {
            resCondition = false;
            phase = 0;
            break;
          }
          if (target === undefined || target.attaqueCalculee === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          condInTarget = true;
          phase = 0;
          resCondition = testCondition(ite.condition, attaquant, [target], deAttaque);
          break;
        case 'echecCritique':
          if (target === undefined || deAttaque === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          condInTarget = true;
          resCondition = testCondition(ite.condition, attaquant, [target], deAttaque);
          break;
        case 'save':
          if (target === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          let msgPour = " pour r\xE9sister \xE0 un effet";
          let msgRate = ", " + nomPerso(target) + " rate son jet de sauvegarde";
          let saveOpts = {
            msgPour: msgPour,
            msgRate: msgRate,
            attaquant: attaquant,
            rolls: options.rolls,
            sortilege: options.sortilege,
            chanceRollId: options.chanceRollId,
            type: ite.condition.typeDmg,
            necromancie: estNecromancie(options)
          };
          const saveId = condInTarget ? 'ifSave_' + etatParent.aTraiter + '_' + target.token.id :
            'ifSave_' + etatParent.aTraiter + '_' + attaquant.token.id;
          if (phase > 0) { //le save a d\xE9j\xE0 \xE9t\xE9 r\xE9solu
            condInTarget = true;
            resCondition = target.saveResults && target.saveResults[saveId];
            break;
          }
          let expliquer = function(msg) {
            target.messages.push(msg);
          };
          save(ite.condition.saveCond, target, saveId, expliquer, saveOpts, evt,
            function(reussite, rolltext) {
              let branch;
              target.saveResults = target.saveResults || {};
              if (reussite) {
                branch = ite.else;
                target.saveResults[saveId] = true;
              } else {
                branch = ite.then; //on teste si le save est rat\xE9
                target.saveResults[saveId] = false;
              }
              if (branch === undefined) {
                callIfAllDone(etatParent, callback);
                return;
              }
              copyBranchOptions(attaquant, branch, options, target, evt, explications, true);
              let etat = {
                parent: etatParent
              };
              evalITE(attaquant, target, deAttaque, options, 0, evt, explications, branch, callback, condInTarget, etat);
            });
          return true; //on ne fait pas la suite, mais on garde l'ite
        default:
          error("Condition non reconnue", ite.condition);
          resCondition = true;
      }
      let branch;
      if (resCondition) branch = ite.then;
      else branch = ite.else;
      if (branch === undefined) {
        callIfAllDone(etatParent, callback);
        return condInTarget; //On garde l'ite si on d\xE9pend de la cible
      }
      //On copie les champs de scope dans options ou dans target
      if (phase === 0)
        copyBranchOptions(attaquant, branch, options, target, evt, explications, condInTarget);
      let etat = {
        parent: etatParent
      };
      evalITE(attaquant, target, deAttaque, options, phase, evt, explications, branch, callback, condInTarget, etat);
      return condInTarget;
    });
  }

  // Retourne tous les attributs dans attrs, de nom name ou commen\xE7ant par name_
  function allAttributesNamed(attrs, name) {
    let reg = new RegExp("^" + name + "($|_|\\()");
    return attrs.filter(function(obj) {
      let attrName = obj.get('name');
      return reg.test(attrName);
    });
  }

  function removeAllAttributes(name, evt, attrs) {
    if (attrs === undefined) {
      attrs = findObjs({
        _type: 'attribute'
      });
    }
    let attrsNamed = allAttributesNamed(attrs, name);
    if (attrsNamed.length === 0) return attrs;
    if (evt.deletedAttributes === undefined) evt.deletedAttributes = [];
    attrsNamed.forEach(function(attr) {
      evt.deletedAttributes.push(attr);
      attr.remove();
    });
    attrs = attrs.filter(function(attr) {
      let ind = attrsNamed.findIndex(function(nattr) {
        return nattr.id == attr.id;
      });
      return (ind == -1);
    });
    return attrs;
  }

  // perso peut ne pas avoir de token
  function onGenre(perso, male, female) {
    let sexe = ficheAttribute(perso, 'sexe', '');
    if (sexe.startsWith('F')) return female;
    return male;
  }

  // perso peut ne pas avoir de token
  function messageActivation(perso, message) {
    if (message.activationF) return onGenre(perso, message.activation, message.activationF);
    return message.activation;
  }

  // perso peut ne pas avoir de token
  function messageActif(perso, message) {
    if (message.actifF) return onGenre(perso, message.actif, message.actifF);
    return message.actif;
  }

  // perso peut ne pas avoir de token
  function messageFin(perso, message) {
    if (message.finF) return onGenre(perso, message.fin, message.finF);
    return message.fin;
  }

  /* Function non utilis\xE9e
  function getValeurStringOfEffet(perso, effet, def, attrDef) {
    let attrsVal = tokenAttribute(perso, effet + 'Valeur');
    if (attrsVal.length === 0) {
      if (attrDef) {
        let attr = charAttribute(perso, attrDef);
        if (attr.length === 0) return def;
        return attr[0].get('current');
      }
      return def;
    }
    return attrsVal[0].get('current');
  }
  */

  // renvoie la valeur du bonus si il y a un capitaine (ou commandant)
  //evt est optionnel
  function aUnCapitaine(cible, evt, pageId) {
    let charId = cible.charId;
    let attrs = findObjs({
      _type: 'attribute',
      _characterid: charId,
    });
    let attrCapitaine = attrs.find(function(a) {
      return (a.get('name') == 'capitaine');
    });
    if (attrCapitaine === undefined) return false;
    if (pageId === undefined) {
      pageId = cible.token.get('pageid');
    }
    let capitaine = persoOfIdName(attrCapitaine.get('current'), pageId);
    if (evt && capitaine === undefined) {
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attrCapitaine);
      attrCapitaine.remove();
    }
    let capitaineActif = attrs.find(function(a) {
      return (a.get('name') == 'capitaineActif');
    });
    if (capitaine && isActive(capitaine)) {
      if (capitaineActif || !evt) return attrCapitaine.get('max');
      setTokenAttr(cible, 'capitaineActif', true, evt, {
        charAttr: true
      });
      iterSelected(tokensEnCombat(), function(perso) {
        if (perso.charId == charId) updateInit(perso.token, evt);
      });
      return attrCapitaine.get('max');
    }
    if (capitaineActif && evt) {
      removeCharAttr(cible.charId, 'capitaineActif', evt);
      iterSelected(tokensEnCombat(), function(perso) {
        if (perso.charId == charId) updateInit(perso.token, evt);
      });
    }
    return false;
  }

  function initDeriveeRec(perso, already) {
    already = already || new Set();
    let pid = [perso.charId, perso.token.id];
    if (already.has(pid)) {
      error("Il y a un cycle d'initiatives d\xE9riv\xE9es les unes des autres impliquant " + nomPerso(perso), already);
      return perso;
    }
    let persoD = initDerivee(perso, already);
    if (persoD) return persoD;
    return perso;
  }

  function initDerivee(perso, already) {
    let initDerivee = predicateAsBool(perso, 'initiativeDeriveeDe');
    if (initDerivee) {
      let charDerive = findObjs({
        _type: 'character',
        name: initDerivee
      });
      if (charDerive.length > 0) {
        let persoD = {
          charId: charDerive[0].id,
          token: perso.token
        };
        return initDeriveeRec(persoD, already);
      }
    }
    let persoMonte = tokenAttribute(perso, 'estMontePar');
    if (persoMonte.length > 0) {
      let cavalier = persoOfIdName(persoMonte[0].get('current'), perso.token.get('pageid'));
      if (cavalier !== undefined) return initDeriveeRec(cavalier, already);
    }
    // retourne undefined sinon
  }

  //ne rajoute pas evt \xE0 l'historique
  function persoInit(perso, evt, already) {
    let persoD = initDerivee(perso);
    if (persoD) perso = persoD;
    let init;
    if (persoEstPNJ(perso)) {
      init = ficheAttributeAsInt(perso, 'pnj_init', 10);
    } else {
      init = ficheAttributeAsInt(perso, 'dexterite', 10);
      init += ficheAttributeAsInt(perso, 'INIT_DIV', 0);
      if (stateCOF.setting_arran || stateCOF.setting_mixte)
        init += ficheAttributeAsInt(perso, 'mod_initiative', 0);
    }
    if (attributeAsBool(perso, 'formeDArbre')) init = 7;
    //R\xE8gle optionelle : +1d6, \xE0 lancer en entrant en combat
    if (reglesOptionelles.initiative.val.initiative_variable.val) {
      let bonusVariable;
      let jetPartage;
      if (reglesOptionelles.initiative.val.initiative_variable_individuelle.val) { // Un jet par perso mook
        bonusVariable = attributeAsInt(perso, 'bonusInitVariable', 0);
      } else { //Un seul pour tous les mook du m\xEAme personnage
        bonusVariable = charAttributeAsInt(perso, 'bonusInitVariable', 0);
        jetPartage = true;
      }
      if (bonusVariable === 0) {
        let rollD6 = rollDePlus(6, {
          deExplosif: true
        });
        bonusVariable = rollD6.val;
        let msg = "entre en combat. ";
        let jetCache = ficheAttributeAsBool(perso, 'jets_caches', false);
        let msgSecret = perso.token.get('layer') == 'gmlayer';
        if (!jetCache) {
          msg += onGenre(perso, 'Il', 'Elle') + " fait " + rollD6.roll;
          msg += " \xE0 son jet d'initiative";
        }
        setTokenAttr(perso, 'bonusInitVariable', bonusVariable, evt, {
          msg: msg,
          secret: msgSecret,
          charAttr: jetPartage
        });
      }
      init += bonusVariable;
    }
    if (getState(perso, 'aveugle')) init -= 5;
    // Voie du compagnon animal rang 2 (surveillance)
    init += attributeAsInt(perso, 'bonusInitEmbuscade', 0);
    // Familier
    if (compagnonPresent(perso, 'familier')) init += 2;
    // Sixi\xE8me sens en sort
    if (attributeAsBool(perso, 'sixiemeSens')) init += 2;
    // Voie du chef d'arm\xE9e rangs 2 et 3 (Capitaine)
    let bonusCapitaine = aUnCapitaine(perso, evt);
    if (bonusCapitaine) init += parseInt(bonusCapitaine);
    if (predicateAsBool(perso, 'graceFeline')) {
      init += modCarac(perso, 'charisme');
    }
    if (predicateAsBool(perso, 'sensAffutes')) {
      init += modCarac(perso, 'sagesse');
    }
    if (attributeAsBool(perso, 'masqueDuPredateur')) {
      init += getValeurOfEffet(perso, 'masqueDuPredateur', modCarac(perso, 'sagesse'));
    }
    if (attributeAsBool(perso, 'masqueDuPredateurAmeLiee')) {
      init += getValeurOfEffet(perso, 'masqueDuPredateurAmeLiee', 1);
    }
    if (predicateAsBool(perso, 'controleDuMetabolisme')) {
      init += getValeurOfEffet(perso, 'controleDuMetabolisme', modCarac(perso, 'charisme'));
    }
    if (attributeAsBool(perso, 'cadavreAnime')) {
      init -= 2;
    }
    // Voie du pistolero rang 1 (plus vite que son ombre)
    let armeEnMain = armesEnMain(perso);
    if (armeEnMain) init += bonusPlusViteQueSonOmbre(perso, armeEnMain);
    //Intelligence du combat
    if (predicateAsBool(perso, 'intelligenceDuCombat')) {
      init += modCarac(perso, 'intelligence');
    }
    // R\xE9flexes felins de la Voie du pourfendeur
    init += predicateAsInt(perso, 'reflexesFelins', 0);
    // \xC2me f\xE9line (f\xE9lis)
    init += predicateAsInt(perso, 'ameFeline', 0);
    init += predicateAsInt(perso, 'vitesseDuFelin', 0);
    init += predicateAsInt(perso, 'espritVide', 0, 3);
    init += predicateAsInt(perso, 'pasDuVent', 0, 1);
    //Prescience de l'ensorceleur
    if (attributeAsBool(perso, 'prescienceUtilisee')) init += 10;
    //For\xEAt vivante
    if (attributeAsBool(perso, 'foretVivanteEnnemie')) {
      init -= 5;
    }
    return init;
  }

  function addAura(perso, aura, aurasCreees, combat, evt) {
    if (evt.combat === undefined) evt.combat = {...combat
    };
    combat.auras = combat.auras || [];
    if (evt.combat) evt.combat.auras = {...combat.auras
    };
    combat.auraCounts = combat.auraCounts || 0;
    aura.id = combat.auraCounts;
    combat.auras.push(aura);
    combat.auraCounts++;
    aurasCreees.push({
      perso,
      aura,
      cibles: []
    });
  }

  //ne rajoute pas evt \xE0 l'historique
  //options: recompute : si pas encore agi, on remet \xE0 sa place dans le turn order
  //already est l\xE0 pour \xE9viter les r\xE9cursions infinies
  //boutonRoll: vient de l'utilisation d'un bouton de roll
  function initiative(selected, evt, recompute, already, boutonRoll) { //set initiative for selected tokens
    // Toujours appel\xE9 quand on entre en combat
    // Initialise le compteur de tour, si besoin
    // Assumption: all tokens that have not acted yet are those before the turn
    // counter.
    // When initiative for token not present, assumes it has not acted
    // When present, stays in same group, but update position according to
    // current initiative.
    // Tokens appearing before the turn are sorted
    if (!Campaign().get('initiativepage')) evt.initiativepage = false;
    let debutCombat = false;
    if (!stateCOF.combat) { //actions de d\xE9but de combat
      evt.combat = false;
      stateCOF.combat = {
        tour: 1,
        init: 1000
      };
      Campaign().set({
        turnorder: JSON.stringify([{
          id: "-1",
          pr: 1,
          custom: "Tour",
          formula: "+1"
        }]),
        initiativepage: true
      });
      removeAllAttributes('transeDeGu\xE9rison', evt);
      debutCombat = true;
    }
    const combat = stateCOF.combat;
    if (!Campaign().get('initiativepage')) {
      Campaign().set('initiativepage', true);
    }
    let to = getTurnOrder(combat, evt);
    if (to.pasAgi.length === 0) { // Fin de tour, on met le tour \xE0 la fin et on retrie
      to.pasAgi = to.dejaAgi;
      to.dejaAgi = [];
    }
    let tokens;
    let aAjouter = [];
    let aurasCreees = [];
    iterSelected(selected, function(perso) {
      let pageId = perso.token.get('pageid');
      combat.pageId = pageId;
      //Si besoin, on stoque les PVs de d\xE9but de combat
      if (!attributeAsBool(perso, 'PVsDebutCombat')) {
        setTokenAttr(perso, 'PVsDebutCombat', perso.token.get('bar1_value'), evt);
      }
      if (!isActive(perso)) return;
      if (predicateAsBool(perso, 'aucuneActionCombat')) return;
      if (!boutonRoll && !recompute &&
        reglesOptionelles.initiative.val.joueurs_lancent_init.val &&
        reglesOptionelles.initiative.val.initiative_variable.val) {
        let persoRoll = perso;
        let persoD = initDerivee(perso);
        if (persoD) persoRoll = persoD;
        if (!attributeAsBool(persoRoll, 'bonusInitVariable')) {
          let pl = getPlayerIds(persoRoll);
          let controlleParJoueur = pl.find(function(pid) {
            return !playerIsGM(pid);
          });
          if (controlleParJoueur) {
            let commande = "!cof-init --boutonRoll --target " + persoRoll.token.id;
            sendPerso(persoRoll, "Cliquez sur " + boutonSimple(commande, "&#127922;") + " pour lancer l'initiative", true);
            return;
          }
        }
      }
      let init = persoInit(perso, evt);
      // On place le token \xE0 sa place dans la liste du tour
      let dejaIndex =
        to.dejaAgi.findIndex(function(elt) {
          return (elt.id == perso.token.id);
        });
      if (dejaIndex == -1) { //Le personnage doit encore agir
        let push = true;
        to.pasAgi =
          to.pasAgi.filter(function(elt) {
            if (elt.id == perso.token.id) {
              if (recompute && elt.pr != init) {
                if (elt.pr == combat.init && init > elt.pr) {
                  //Pour l'instant, on ne peut pas remonter l'init, on le fera au prochain tour
                  push = false;
                  updateNextInit(perso);
                  return true;
                } else {
                  return false; //On enl\xE8ve le perso des pasAgi
                }
              }
              push = false; //Sinon, comme on ne recalcule pas, on le laisse
              return true;
            }
            return true;
          });
        if (push) {
          if (init >= combat.init) { //On ne peut pas remonter le temps.
            init = combat.init - 1;
            updateNextInit(perso);
          }
          to.pasAgi.push({
            id: perso.token.id,
            _pageid: pageId,
            pr: init,
            custom: ''
          });
          if (!recompute) { //Alors on vient d'ajouter le perso au combat
            //Les effets quand on entre en combat
            if (predicateAsBool(perso, 'auraDrainDeForce')) {
              let aura = {
                origineId: perso.token.id,
                origineName: perso.token.get('name'),
                portee: 5,
                effet: 'drainDeForce',
                seulementVivant: true,
              };
              addAura(perso, aura, aurasCreees, combat, evt);
            }
            let auraPerso = charAttribute(perso.charId, 'aura');
            auraPerso.forEach(function(a) {
              let portee = parseInt(a.get('current'));
              if (isNaN(portee) || portee < 0) return;
              let effetCmd = a.get('max').replace(/\$TOKEN/g, nomPerso(perso));
              let seulementVivant = effetCmd.includes(' --seulementVivant');
              effetCmd += " --silencieuxSiPasAffecte --lanceur " + perso.token.id;
              let aura = {
                origineId: perso.token.id,
                origineName: perso.token.get('name'),
                portee,
                effet: 'auraGenerique',
                effetCmd,
                seulementVivant,
              };
              addAura(perso, aura, aurasCreees, combat, evt);
            });
            //Les autres persos qui entrent en combat en m\xEAme temps
            let ajouterEnCombat = predicatesNamed(perso, 'entrerEnCombatAvec');
            if (ajouterEnCombat.length > 0) {
              let aec = new Set(ajouterEnCombat);
              tokens = tokens || findObjs({
                _type: 'graphic',
                _pageid: pageId,
                layer: 'objects'
              });
              if (!already) {
                already = new Set();
                selected.forEach(function(sel) {
                  already.add(sel._id);
                });
              }
              tokens.forEach(function(tok) {
                let ci = tok.get('represents');
                if (!ci) return;
                if (!aec.has(tok.get('name'))) return;
                if (already.has(tok.id)) return;
                aAjouter.push({
                  _id: tok.id
                });
                already.add(tok.id);
              });
            }
          }
        }
      } else {
        to.dejaAgi[dejaIndex].pr = init;
      }
    });
    if (debutCombat) { //On cherche si un des personnages de la carte a la capacit\xE9 Prescience
      let allToks =
        findObjs({
          _type: 'graphic',
          _pageid: combat.pageId,
          _subtype: 'token',
        });
      let prescience = allToks.find(function(tok) {
        let ci = tok.get('represents');
        if (ci === undefined) return false;
        let perso = {
          token: tok,
          charId: ci
        };
        return capaciteDisponible(perso, 'prescience', 'combat');
      });
      if (prescience) { //Il faut stoquer les positions de tous les token pour le retour en arri\xE8re.
        stateCOF.prescience = {
          evt: evt,
          dernieresPositions: []
        };
        allToks.forEach(function(tok) {
          let ci = tok.get('represents');
          if (ci == undefined) return;
          stateCOF.prescience.dernieresPositions.push({
            token: tok,
            left: tok.get('left'),
            top: tok.get('top')
          });
        });
      }
    }
    setTurnOrder(to, evt);
    if (aAjouter.length > 0) initiative(aAjouter, evt, false, already);
    if (aurasCreees.length > 0) {
      tokens = tokens || findObjs({
        _type: 'graphic',
        _pageid: combat.pageId,
        layer: 'objects'
      });
      tokens.forEach(function(tok) {
        let ci = tok.get('represents');
        if (ci === '') return;
        let p = {
          charId: ci,
          token: tok,
        };
        aurasCreees.forEach(function(ac) {
          if (tok.id == ac.perso.token.id) return;
          ac.cibles.push(p);
        });
      });
      aurasCreees.forEach(function(ac) {
        if (ac.cibles.length > 0)
          appliquerAura(ac.perso, ac.cibles, combat.pageId, ac.aura, evt);
      });
    }
    return combat;
  }

  function initiativeInterface(msg) {
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        error("Dans !cof-init : rien \xE0 faire, pas de token selectionn\xE9", msg);
        return;
      }
      aura_token_on_turn = msg.content.indexOf('--aura') !== -1;
      let evt = {
        type: 'initiative'
      };
      let boutonRoll = msg.content.includes(" --boutonRoll");
      if (boutonRoll) {
        let interdit;
        iterSelected(selected, function(perso) {
          interdit = interdit || !peutController(msg, perso);
        });
        if (interdit) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton");
          return;
        }
      } else if (reglesOptionelles.initiative.val.joueurs_lancent_init.val) {
        let playerId = getPlayerIdFromMsg(msg);
        boutonRoll = playerId && !playerIsGM(playerId);
      }
      initiative(selected, evt, undefined, undefined, boutonRoll);
      addEvent(evt);
    });
  }

  // triggers sheet workers
  // options peut avoir un champ msg et un champ maxVal
  // si options a un champ default, supprime la fiche si la valeur est default
  // renvoie l'attribut, sauf si on a ledefault
  function setFicheAttr(personnage, attribute, value, evt, options) {
    let charId = personnage.charId;
    if (options && options.msg !== undefined) {
      sendPerso(personnage, options.msg);
    }
    let attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: attribute
    }, {
      caseInsensitive: true
    });
    if (attr.length === 0) {
      if (options && options.maxVal === undefined && options.default === value) return;
      evt.attributes = evt.attributes || [];
      let maxval = '';
      if (options && options.maxVal !== undefined) maxval = options.maxVal;
      attr = createObj('attribute', {
        characterid: charId,
        name: attribute,
        current: value,
        max: maxval
      });
      attr.setWithWorker({
        current: value
      });
      evt.attributes.push({
        attribute: attr,
      });
      return attr;
    }
    attr = attr[0];
    if (options && options.maxVal === undefined && options.default === value) {
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attr);
      attr.remove();
      return;
    }
    evt.attributes = evt.attributes || [];
    evt.attributes.push({
      attribute: attr,
      current: attr.get('current'),
      max: attr.get('max'),
      withWorker: true
    });
    let nv = {
      current: value
    };
    if (options && options.maxVal !== undefined) nv.max = options.maxVal;
    attr.setWithWorker(nv);
    return attr;
  }

  function marcheSylvestreActive(perso) {
    if (attributeAsBool(perso, 'marcheSylvestre')) return true;
    if (predicateAsBool(perso, 'marcheSylvestre')) {
      let conditions = attributeAsInt(perso, 'conditionsHostiles', 0, 2);
      if (conditions > 0 && conditions < 5) return true;
      let x = perso.token.get('left');
      let y = perso.token.get('top');
      let tokens = findObjs({
        _type: 'graphic',
        _pageid: perso.token.get('pageid'),
        layer: 'map'
      });
      let res = tokens.find(function(token) {
        let xt = token.get('left');
        let yt = token.get('top');
        let w = token.get('width');
        let h = token.get('height');
        if (xt - w / 2 <= x && x <= xt + w / 2 && yt - h / 2 <= y && y <= yt + h / 2) {
          let gmNotes = token.get('gmnotes');
          if (gmNotes === '') return false;
          try {
            gmNotes = _.unescape(decodeURIComponent(gmNotes)).replace('&nbsp;', ' ');
            gmNotes = linesOfNote(gmNotes);
            let r = gmNotes.find(function(l) {
              if (l.startsWith('terrainDifficile')) {
                let index = l.indexOf(':');
                if (index < 1) return true;
                l = l.substring(index + 1).trim().split(' ');
                if (l.length > 1 && l[0] == 'disque') {
                  let rayon = parseInt(l[1]) / 2;
                  if (isNaN(rayon) || rayon < 0) {
                    error("Rayon de terrain difficile non reconnu", l);
                    return true;
                  }
                  return Math.sqrt((x - xt) * (x - xt) + (y - yt) * (y - yt)) <= rayon;
                }
                error("Zone de terrain difficile non reconnue", l);
                return true;
              }
              return false;
            });
            return r !== undefined;
          } catch (uriError) {
            log("Erreur de d\xE9codage URI dans la note GM de " + token.get('name') + " : " + gmNotes);
          }
        }
        return false;
      });
      return res !== undefined;
    }
    return false;
  }

  // bonus d'attaque d'un token, ind\xE9pendament des options
  // Mise en commun pour attack et attaque-magique
  // options n'est utilis\xE9 que pour modifier \xE9ventuellement l'affichage si pas de DM
  function bonusDAttaque(personnage, explications, evt, options) {
    explications = explications || [];
    let tempAttkMod; // Utilise la barre 3 de l'attaquant
    tempAttkMod = parseInt(personnage.token.get('bar3_value'));
    if (tempAttkMod === undefined || isNaN(tempAttkMod) || tempAttkMod === "") {
      tempAttkMod = 0;
    }
    let attBonus = tempAttkMod;
    let fortifie = attributeAsInt(personnage, 'fortifie', 0);
    if (fortifie > 0) {
      attBonus += 3;
      fortifie--;
      explications.push("Effet du fortifiant => +3 en Attaque. Il sera encore actif pour " + fortifie + " tests");
      if (fortifie === 0) {
        removeTokenAttr(personnage, 'fortifie', evt);
      } else {
        setTokenAttr(personnage, 'fortifie', fortifie, evt);
      }
    }
    attBonus += charAttributeAsInt(personnage, 'actionConcertee', 0);
    if (attributeAsBool(personnage, 'chantDesHeros')) {
      let bonusChantDesHeros = getValeurOfEffet(personnage, 'chantDesHeros', 1);
      let chantDesHerosIntense =
        attributeAsInt(personnage, 'chantDesHerosTempeteDeManaIntense', 0);
      bonusChantDesHeros += chantDesHerosIntense;
      attBonus += bonusChantDesHeros;
      explications.push("Chant des h\xE9ros => +" + bonusChantDesHeros + " en Attaque");
      if (chantDesHerosIntense)
        removeTokenAttr(personnage, 'chantDesHerosTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'benediction')) {
      let bonusBenediction = getValeurOfEffet(personnage, 'benediction', 1);
      let benedictionIntense = attributeAsInt(personnage, 'benedictionTempeteDeManaIntense', 0);
      bonusBenediction += benedictionIntense;
      attBonus += bonusBenediction;
      explications.push("B\xE9n\xE9diction => +" + bonusBenediction + " en Attaque");
      if (benedictionIntense)
        removeTokenAttr(personnage, 'benedictionTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'inspiration')) {
      let b = getValeurOfEffet(personnage, 'inspiration', 1);
      let intense = attributeAsInt(personnage, 'inspirationTempeteDeManaIntense', 0);
      b += intense;
      attBonus += b;
      explications.push("Inspiratuon => +" + b + " en Attaque");
      if (intense)
        removeTokenAttr(personnage, 'inspirationTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'lameDeLigneePerdue')) {
      attBonus -= 1;
      explications.push("Lame de lign\xE9e perdue => -1 en Attaque");
    }
    if (attributeAsBool(personnage, 'strangulation')) {
      let malusStrangulation =
        1 + attributeAsInt(personnage, 'dureeStrangulation', 0);
      attBonus -= malusStrangulation;
      explications.push("L'attaquant est \xE9trangl\xE9 => -" + malusStrangulation + " en Attaque");
    }
    if (getState(personnage, 'renverse')) {
      attBonus -= 5;
      explications.push("Attaquant \xE0 terre => -5 en Attaque");
    }
    let attrPosture = tokenAttribute(personnage, 'postureDeCombat');
    if (attrPosture.length > 0) {
      attrPosture = attrPosture[0];
      let posture = attrPosture.get('max');
      let postureVal;
      if (posture.startsWith('ATT')) {
        postureVal = parseInt(attrPosture.get('current'));
        attBonus -= postureVal;
        explications.push("Posture de combat => -" + postureVal + " en Attaque");
      } else if (posture.endsWith('ATT')) {
        postureVal = parseInt(attrPosture.get('current'));
        attBonus += postureVal;
        explications.push("Posture de combat => +" + postureVal + " en Attaque");
      }
    }
    if (attributeAsBool(personnage, 'danseIrresistible')) {
      attBonus -= 4;
      explications.push("En train de danser => -4 en Attaque");
    }
    if (attributeAsBool(personnage, 'cadavreAnime')) {
      attBonus -= 4;
      explications.push("Cadavre anim\xE9 => -2 en Attaque");
    }
    let bonusCapitaine = aUnCapitaine(personnage, evt);
    if (bonusCapitaine) {
      attBonus += parseInt(bonusCapitaine);
      let msgCapitaine = "Un ";
      if (bonusCapitaine > 2) msgCapitaine += "commandant";
      else msgCapitaine += "capitaine";
      msgCapitaine += " donne des ordres => +" + bonusCapitaine + " en Attaque et aux DMs";
      personnage.bonusCapitaine = bonusCapitaine;
      explications.push(msgCapitaine);
    }
    if (attributeAsBool(personnage, 'forceDeGeant')) {
      let bonusForceDeGeant = getValeurOfEffet(personnage, 'forceDeGeant', 2);
      attBonus += bonusForceDeGeant;
      explications.push("Force de g\xE9ant => +" + bonusForceDeGeant + " en Attaque");
    }
    if (attributeAsBool(personnage, 'nueeDInsectes')) {
      let malusNuee =
        2 + attributeAsInt(personnage, 'nueeDInsectesTempeteDeManaIntense', 0);
      attBonus -= malusNuee;
      explications.push("Nu\xE9e d\'insectes => -" + malusNuee + " en Attaque");
      if (malusNuee > 2)
        removeTokenAttr(personnage, 'nueeDInsectesTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'nueeDeCriquets')) {
      let malusNueeCriquets =
        3 + attributeAsInt(personnage, 'nueeDeCriquetsTempeteDeManaIntense', 0);
      attBonus -= malusNueeCriquets;
      explications.push("Nu\xE9e de criquets => -" + malusNueeCriquets + " en Attaque");
      if (malusNueeCriquets > 3)
        removeTokenAttr(personnage, 'nueeDeCriquetsTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'nueeDeScorpions')) {
      attBonus -= 3;
      explications.push("Nu\xE9e de scorpions => -3 en Attaque");
    }
    if (attributeAsBool(personnage, 'etatExsangue')) {
      attBonus -= 2;
      explications.push("Exsangue => -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'armeBrulante')) {
      attBonus -= 2;
      explications.push("Arme br\xFBlante => -2 en Attaque");
    }
    if (marcheSylvestreActive(personnage)) {
      attBonus += 2;
      explications.push("Marche sylvestre : +2 en Attaque");
    }
    if (attributeAsBool(personnage, 'prisonVegetale')) {
      attBonus -= getValeurOfEffet(personnage, 'prisonVegetale', 2);
      explications.push("Prison v\xE9g\xE9tale : -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'toiles')) {
      attBonus -= getValeurOfEffet(personnage, 'toiles', 2);
      explications.push("Entrav\xE9 : -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'masqueDuPredateur')) {
      let bonusMasque = getValeurOfEffet(personnage, 'masqueDuPredateur', modCarac(personnage, 'sagesse'));
      let masqueIntense = attributeAsInt(personnage, 'masqueDuPredateurTempeteDeManaIntense', 0);
      bonusMasque += masqueIntense;
      if (options) options.masqueIntense = masqueIntense;
      attBonus += bonusMasque;
      if (options && options.pasDeDmg) {
        explications.push("Masque du pr\xE9dateur : +" + bonusMasque + " en Attaque");
      } else {
        explications.push("Masque du pr\xE9dateur : +" + bonusMasque + " en Attaque et DM");
      }
      if (masqueIntense)
        removeTokenAttr(personnage, 'masqueDuPredateurTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'masqueDuPredateurAmeLiee')) {
      let bonusMasque =
        getValeurOfEffet(personnage, 'masqueDuPredateurAmeLiee', 1);
      attBonus += bonusMasque;
      if (options && options.pasDeDmg) {
        explications.push("Masque du pr\xE9dateur li\xE9 : +" + bonusMasque + " en Attaque");
      } else {
        explications.push("Masque du pr\xE9dateur li\xE9 : +" + bonusMasque + " en Attaque et DM");
      }
    }
    if (attributeAsBool(personnage, 'armeSecreteBarde')) {
      attBonus -= 10;
      explications.push("D\xE9stabilis\xE9 par une action de charme => -10 en Attaque");
    }
    if (attributeAsBool(personnage, 'espaceExigu')) {
      let bonusForce = modCarac(personnage, 'force');
      if (bonusForce < 1) bonusForce = 1;
      explications.push("Espace exigu : -" + bonusForce + " en Attaque");
      attBonus -= bonusForce;
    } else if (attributeAsBool(personnage, 'constructionTailleHumaine')) {
      explications.push("Construction de taille humaine : -1 en Attaque");
      attBonus -= 1;
    }
    if (attributeAsBool(personnage, 'agrippeParUnDemon')) {
      explications.push("agripp\xE9 : -3 en Attaque");
      attBonus -= 3;
    }
    if (attributeAsBool(personnage, 'ondesCorruptrices') &&
      !attributeAsBool(personnage, 'sangDeLArbreCoeur') &&
      !predicateAsBool(personnage, 'porteurDuBouclierDeGrabuge')) {
      let malus = attributeAsInt(personnage, 'ondesCorruptrices', 2);
      explications.push("naus\xE9eux : -" + malus + " aux tests");
      attBonus -= malus;
    }
    if (attributeAsBool(personnage, 'inconfort')) {
      let inconfortValeur = attributeAsInt(personnage, 'inconfortValeur', 0);
      attBonus -= inconfortValeur;
      explications.push("G\xEAne due \xE0 l'armure : -" + inconfortValeur);
    }
    if (attributeAsBool(personnage, 'putrefactionOutreTombe')) {
      attBonus -= 2;
      explications.push("Putr\xE9faction => -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'secoue')) {
      attBonus -= 2;
      let msg = "Secou\xE9" + eForFemale(personnage) + " => -2 en Attaque";
      explications.push(msg);
    }
    if (attributeAsBool(personnage, 'bonusAttaqueTemp')) {
      let bonusTemp = getValeurOfEffet(personnage, 'bonusAttaqueTemp', 5);
      attBonus += bonusTemp;
      explications.push("Bonus d'attaque temporaire de " + bonusTemp);
    }
    return attBonus;
  }

  function rollNumber(s) {
    return parseInt(s.substring(3, s.indexOf(']')));
  }

  function tailleNormale(perso, def) {
    if (attributeAsBool(perso, 'grandeTaille')) return 4;
    switch (ficheAttribute(perso, 'taille', '').trim().toLowerCase()) {
      case "minuscule":
        return 1;
      case "tr\xE8s petit":
      case "tr\xE8s petite":
      case "tres petit":
        return 2;
      case "petit":
      case "petite":
        return 3;
      case "moyen":
      case "moyenne":
      case "normal":
      case "normale":
        return 4;
      case "grand":
      case "grande":
        return 5;
      case "\xE9norme":
      case "enorme":
        return 6;
      case "colossal":
      case "colossale":
        return 7;
      default: //On passe \xE0 la m\xE9thode suivante
    }
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.trim().toLowerCase();
    }
    switch (perso.race) {
      case 'lutin':
      case 'fee':
        return 2;
      case 'halfelin':
      case 'gobelin':
      case 'kobold':
        return 3;
      case 'humain':
      case 'elfe':
      case 'nain':
      case 'demi-elfe':
      case 'demi-orque':
      case 'orque':
      case 'gnome':
      case '\xE2me-forg\xE9e':
        return 4;
      case 'centaure':
      case 'demi-ogre':
      case 'ogre':
      case 'minotaure':
        return 5;
    }
    return def;
  }

  //Retourne un encodage des tailes :
  // 1 : minuscule
  // 2 : tr\xE8s petit
  // 3 : petit
  // 4 : moyen
  // 5 : grand
  // 6 : \xE9norme
  // 7 : colossal
  function taillePersonnage(perso, def) {
    if (perso.taille) return perso.taille;
    let taille = tailleNormale(perso, def);
    if (attributeAsBool(perso, 'agrandissement')) taille++;
    perso.taille = taille;
    return taille;
  }

  //tm doit \xEAtre stateCOF.tenebresMagiques, et bien d\xE9fini.
  function eclaireParFioleDeLumiere(perso, tm) {
    let fio = tm.fioleDeLumiere;
    if (fio === undefined || fio.porteur === undefined) return false;
    return distanceCombat(fio.porteur.token, perso.token) < fio.distance;
  }

  function defenseArmure(perso) {
    let defense = 0;
    if (ficheAttributeAsInt(perso, 'defarmureon', 0) > 0)
      defense = ficheAttributeAsInt(perso, 'defarmure', 0);
    if (ficheAttributeAsInt(perso, 'defbouclieron', 0) > 0)
      defense += ficheAttributeAsInt(perso, 'defbouclier', 0);
    return defense;
  }

  //evt est optionnel
  function defenseOfPerso(attaquant, target, pageId, evt, options) {
    options = options || {};
    if (options.difficultePVmax) {
      let pvmax = parseInt(target.token.get('bar1_max'));
      if (isNaN(pvmax)) {
        error("Points de vie de " + nomPerso(target) + " mal form\xE9s",
          target.token.get('bar1_max'));
        return 0;
      }
      return pvmax;
    } else if (options.difficultePV) {
      let pv = parseInt(target.token.get('bar1_value'));
      if (isNaN(pv)) {
        error("Points de vie de " + nomPerso(target) + " mal form\xE9s",
          target.token.get('bar1_value'));
        return 0;
      }
      return pv;
    } else if (options.difficulteCarac) {
      let carac = caracOfMod(options.difficulteCarac.carac);
      target.messages = target.messages || [];
      let diff = caracCourante(target, carac);
      if (options.difficulteCarac.carac2) {
        let carac2 = caracOfMod(options.difficulteCarac.carac2);
        let diff2 = caracCourante(target, carac2);
        if (diff2 > diff) {
          diff = diff2;
          target.messages.push("Attaque contre " + stringOfCarac(options.difficulteCarac.carac2));
        } else {
          target.messages.push("Attaque contre " + stringOfCarac(options.difficulteCarac.carac));
        }
      } else {
        target.messages.push("Attaque contre " + stringOfCarac(options.difficulteCarac.carac));
      }
      return diff;
    }
    let defDerivee = predicateAsBool(target, 'defDeriveeDe');
    if (defDerivee) {
      let charDerive = findObjs({
        _type: 'character',
        name: defDerivee
      });
      if (charDerive.length > 0) {
        target = {
          charId: charDerive[0].id,
          token: target.token,
          tokName: nomPerso(target),
          messages: target.messages,
          defautCuirasse: target.defautCuirasse,
        };
      }
    }
    let tokenName = nomPerso(target);
    let explications = target.messages || [];
    let defense = 10;
    if (persoEstPNJ(target)) {
      defense = ficheAttributeAsInt(target, 'pnj_def', 10);
    } else {
      if (target.defautCuirasse === undefined && (!attaquant || !predicateAsBool(attaquant, 'creatureIntangible'))) {
        if (!attaquant || !predicateAsBool(attaquant, 'creatureIntangible')) {
          defense += defenseArmure(target);
          if (attributeAsBool(target, 'armureDEau')) {
            let bonusArmureDEau = getValeurOfEffet(target, 'armureDEau', 2);
            defense += bonusArmureDEau;
            explications.push("Armure d'eau : +" + bonusArmureDEau + " en DEF");
          }
        }
        if (attributeAsBool(target, 'armureDuMage')) {
          let bonusArmureDuMage = getValeurOfEffet(target, 'armureDuMage', 4);
          if (defense > 12) defense += bonusArmureDuMage / 2; // On a d\xE9j\xE0 une armure physique, \xE7a ne se cumule pas.
          else defense += bonusArmureDuMage;
        }
        defense += ficheAttributeAsInt(target, 'DEFDIV', 0);
      } // Dans le cas contraire, on n'utilise pas ces bonus
      defense += modCarac(target, 'dexterite');
    }
    if (attributeAsBool(target, 'inconfort')) {
      let inconfortValeur = attributeAsInt(target, "inconfortValeur", 0);
      defense -= inconfortValeur;
      explications.push("L'adversaire est g\xEAn\xE9 par son armure : -" + inconfortValeur + " en DEF");
    }
    let formeDarbre;
    if (attributeAsBool(target, 'formeDArbre')) {
      formeDarbre = true;
      defense = 13;
    }
    if (attributeAsBool(target, 'statueDeBois')) defense = 10;
    // Malus de d\xE9fense global pour les longs combats
    let combat = stateCOF.combat;
    if (combat && reglesOptionelles.haute_DEF.val.usure_DEF.val &&
      !combat.usureOff && combat.tour > 1)
      defense -= (Math.floor((combat.tour - 1) / reglesOptionelles.haute_DEF.val.usure_DEF.val) * 2);
    // Autres modificateurs de d\xE9fense
    defense += attributeAsInt(target, 'defenseTotale', 0);
    let pacifisme = predicateAsInt(target, 'pacifisme', 0, 5);
    if (pacifisme > 0 && !attributeAsBool(target, 'attributDeCombat_pacifismeAnnule'))
      defense += pacifisme;
    if (attributeAsBool(target, 'aspectDuDemon')) {
      defense += getValeurOfEffet(target, 'aspectDuDemon', 2);
    }
    if (attributeAsBool(target, 'peauDEcorce')) {
      let bonusPeau = getValeurOfEffet(target, 'peauDEcorce', 1, 'voieDesVegetaux');
      if (bonusPeau == 1 && persoArran(target)) {
        let v = predicateAsInt(target, 'voieDesForets', 0);
        if (v < 4) bonusPeau = 2;
        else bonusPeau = 4;
      }
      let peauIntense = attributeAsInt(target, 'peauDEcorceTempeteDeManaIntense', 0);
      bonusPeau += peauIntense;
      if (reglesOptionelles.divers.val.forme_d_arbre_amelioree.val && formeDarbre) {
        bonusPeau = Math.ceil(bonusPeau * 1.5);
      }
      defense += bonusPeau;
      explications.push("Peau d'\xE9corce : +" + bonusPeau + " en DEF");
      if (peauIntense && evt && !options.test)
        removeTokenAttr(target, 'peauDEcorceTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(target, 'peauDEcorceAmeLiee')) {
      let bonus = getValeurOfEffet(target, 'peauDEcorceAmeLiee', 1);
      defense += bonus;
      explications.push("Peau d'\xE9corce li\xE9e : +" + bonus + " en DEF");
    }
    if (attributeAsBool(target, 'champDeProtection')) {
      let bonusChamp =
        getValeurOfEffet(target, 'champDeProtection', 2, 'voieDeLaTelekinesie');
      let champIntense = attributeAsInt(target, 'champDeProtectionTempeteDeManaIntense', 0);
      bonusChamp += champIntense;
      defense += bonusChamp;
      explications.push("Champ de protection : +" + bonusChamp + " en DEF");
      if (champIntense && evt && !options.test)
        removeTokenAttr(target, 'champDeProtectionTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(target, 'mutationCuirasse')) {
      let bonusMutation =
        getValeurOfEffet(target, 'mutationCuirasse', 2, 'voieDesMutations');
      defense += bonusMutation;
      explications.push("Cuirasse : +" + bonusMutation + " en DEF");
    }
    if (attributeAsBool(target, 'sixiemeSens')) {
      defense += 2;
      explications.push("Sixi\xE8me sens : +2 DEF");
    }
    if (getState(target, 'surpris')) defense -= 5;
    if (getState(target, 'renverse')) defense -= 5;
    if (getState(target, 'aveugle') || attributeAsBool(target, 'aveugleManoeuvre')) {
      if (options.contact && predicateAsBool(target, 'radarMental') && attaquant && !estNonVivant(attaquant)) {
        explications.push(tokenName + " est aveugle, mais b\xE9n\xE9ficie de son radar mental");
      } else {
        defense -= 5;
      }
    }
    if (getState(target, 'etourdi') || attributeAsBool(target, 'peurEtourdi'))
      defense -= 5;
    if (getState(target, 'invisible') && attaquant && !attributeAsBool(attaquant, 'detectionDeLInvisible')) {
      if (options.distance) {
        if (options.tirAveugle) {
          explications.push("Cible invisible, mais " + nomPerso(attaquant) + " sait tirer \xE0 l'aveugle");
        } else {
          defense += 10;
          explications.push("Invisible : +10 en DEF");
        }
      } else {
        if (attaquant && predicateAsBool(attaquant, 'radarMental') && !estNonVivant(target)) {
          explications.push("Cible invisible, mais " + nomPerso(attaquant) + " utilise son radar mental");
        } else {
          defense += 5;
          explications.push("Invisible : +5 en DEF");
        }
      }
    }
    defense += attributeAsInt(target, 'bufDEF', 0);
    defense += attributeAsInt(target, 'actionConcertee', 0);
    if (ficheAttributeAsInt(target, 'defarmureon', 0) === 0) {
      defense += predicateAsInt(target, 'vetementsSacres', 0);
      defense += predicateAsInt(target, 'armureDeVent', 0);
      if (!options.distance)
        defense += predicateAsInt(target, 'dentellesEtRapiere', 0);
    }
    defense += predicateAsInt(target, 'esquiveVoleur', 0);
    if (predicateAsBool(target, 'graceFeline')) {
      defense += modCarac(target, 'charisme');
    }
    if (predicateAsBool(target, 'peauDePierre')) {
      defense += modCarac(target, 'constitution');
    }
    if (predicateAsBool(target, 'defenseIntuitive')) {
      defense += modCarac(target, 'sagesse');
    }
    if (predicateAsBool(target, 'intelligenceDuCombat')) {
      defense += modCarac(target, 'intelligence');
    }
    if (attributeAsBool(target, 'armeSecreteBarde')) {
      explications.push(tokenName + " est d\xE9stabilis\xE9 par une action de charme => -10 en DEF");
      defense -= 10;
    }
    if (options.metal && attributeAsBool(target, 'magnetisme')) {
      let magnetisme = getValeurOfEffet(target, 'magnetisme', 5);
      defense += magnetisme;
      explications.push(tokenName + " contr\xF4le le magn\xE9tisme (+" + magnetisme + " DEF)");
    }
    if (attributeAsBool(target, 'diversionManoeuvre')) {
      let diversion = getValeurOfEffet(target, 'diversionManoeuvre', -5);
      defense += diversion;
      explications.push(tokenName + " est victime d'une diversion => " + diversion + " DEF");
    }
    if (options.attaqueMentale && predicateAsBool(target, 'bouclierPsi')) {
      defense += 5;
      explications.push(tokenName + " b\xE9n\xE9ficie d'un bouclier psi => +5 DEF");
    }
    if (attributeAsBool(target, 'monteSur')) {
      if (predicateAsBool(target, 'montureLoyale')) {
        defense += 1;
        explications.push(tokenName + " est sur une monture => +1 DEF");
      }
      if (options.contact && predicateAsBool(target, "horsDePortee")) {
        defense += 5;
        explications.push(tokenName + " est hors de port\xE9e sur sa monture => +5 DEF");
      }
    }
    let attrsProtegePar = findObjs({
      _type: 'attribute',
      _characterid: target.charId,
    });
    attrsProtegePar.forEach(function(attr) {
      let attrName = attr.get('name');
      if (attrName.startsWith('protegePar_')) {
        let protecteur = persoOfIdName(attr.get('current'), pageId);
        if (protecteur === undefined) {
          if (evt) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(attr);
            attr.remove();
            sendPerso(target, "n'est plus prot\xE9g\xE9 : son protecteur n'est pas sur la page");
          }
          return;
        }
        let nameProtecteur = nomPerso(protecteur);
        if (!isActive(protecteur)) {
          explications.push(nameProtecteur + " n'est pas en \xE9tat de prot\xE9ger " +
            tokenName);
          return;
        }
        let distTargetProtecteur = distanceCombat(target.token, protecteur.token, pageId);
        if (distTargetProtecteur > 0) {
          explications.push(nameProtecteur + " est trop loin de " +
            tokenName + " pour le prot\xE9ger");
          return;
        }
        if (ficheAttributeAsInt(protecteur, 'defbouclieron', 0) === 0) {
          let sujet = onGenre(protecteur, 'il', 'elle');
          explications.push(nameProtecteur +
            " ne porte pas son bouclier, " + sujet + " ne peut pas proteger " +
            tokenName);
          return;
        }
        let defBouclierProtecteur;
        if (persoEstPNJ(protecteur)) defBouclierProtecteur = 2;
        else defBouclierProtecteur = ficheAttributeAsInt(protecteur, 'defbouclier', 0);
        defense += defBouclierProtecteur;
        explications.push(nameProtecteur + " prot\xE8ge " +
          tokenName + " de son bouclier (+" + defBouclierProtecteur + " DEF)");
      }
    });
    let attrPosture = tokenAttribute(target, 'postureDeCombat');
    if (attrPosture.length > 0) {
      attrPosture = attrPosture[0];
      let posture = attrPosture.get('max');
      let postureVal;
      if (posture.startsWith('DEF')) {
        postureVal = parseInt(attrPosture.get('current'));
        defense -= postureVal;
        explications.push("Posture de combat => -" + postureVal + " DEF");
      } else if (posture.endsWith('DEF')) {
        postureVal = parseInt(attrPosture.get('current'));
        defense += postureVal;
        explications.push("Posture de combat => +" + postureVal + " DEF");
      }
    }
    let attaqueAOutrance = attributeAsInt(target, 'attaqueAOutrance', 0);
    if (attaqueAOutrance) {
      defense -= attaqueAOutrance;
      explications.push("Attaque \xE0 outrance => -" + attaqueAOutrance + " DEF");
    }
    let niveau = ficheAttributeAsInt(target, 'niveau', 1);
    let instinctSurvie = predicateAsInt(target, 'instinctDeSurvie', 0, niveau * 5);
    if (instinctSurvie > 0 && target.token.get('bar1_value') <= instinctSurvie)
      defense += 5;
    if (attributeAsBool(target, 'danseIrresistible')) {
      defense -= 4;
      explications.push("En train de danser => -4 DEF");
    }
    if (options.sortilege) {
      defense += predicateAsInt(target, 'DEF_magie', 0);
      if (predicateAsBool(target, 'chasseurDeSorciere')) {
        defense += 2;
        explications.push("Chasseur de sorci\xE8re => +2 DEF");
      }
    }
    if (marcheSylvestreActive(target)) {
      defense += 2;
      explications.push("Marche sylvestre => +2 DEF");
    }
    if (attributeAsBool(target, 'prisonVegetale')) {
      defense -= getValeurOfEffet(target, 'prisonVegetale', 2);
      explications.push("Prison v\xE9g\xE9tale => -2 DEF");
    }
    if (attributeAsBool(target, 'toiles')) {
      defense -= getValeurOfEffet(target, 'toiles', 2);
      explications.push("Entrav\xE9 => -2 DEF");
    }
    if (attributeAsBool(target, 'protectionContreLeMal') &&
      (attaquant && estMauvais(attaquant))) {
      let bonusProtectionContreLeMal = getValeurOfEffet(target, 'protectionContreLeMal', 2);
      defense += bonusProtectionContreLeMal;
      explications.push("Protection contre le mal => +" + bonusProtectionContreLeMal + " DEF");
    }
    let rageBerserk = tokenAttribute(target, 'rageDuBerserk');
    if (rageBerserk.length > 0) {
      rageBerserk = rageBerserk[0].get('current');
      let modRage;
      let msgRage;
      if (rageBerserk == 'furie') {
        modRage = -6;
        msgRage = "Furie";
      } else {
        modRage = -4;
        msgRage = "Rage";
      }
      if (predicateAsBool(target, 'rageDuBerserkAmelioree')) {
        modRage /= 2;
      }
      explications.push(msgRage + " du berserk => " + modRage + " DEF");
      defense += modRage;
    } else if (attributeAsBool(target, 'frenesieMinotaure')) {
      explications.push("Fren\xE9sie => -2 en DEF");
      defense -= 2;
    }
    let combatEnPhalange = predicateAsBool(target, 'combatEnPhalange');
    if (combatEnPhalange || capaciteDisponible(target, 'esquiveFatale', 'combat')) {
      let tokensContact = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        layer: 'objects'
      });
      tokensContact = tokensContact.filter(function(tok) {
        if (tok.id == target.token.id) return false;
        return distanceCombat(target.token, tok, pageId) === 0;
      });
      let tokensAllies = [];
      let tokensEnnemis = [];
      let allies = alliesParPerso[target.charId] || new Set();
      tokensContact.forEach(function(tok) {
        let ci = tok.get('represents');
        if (ci === '') return; //next token au contact
        if (!isActive({
            token: tok,
            charId: ci
          })) return;
        if (allies.has(ci)) tokensAllies.push(tok);
        else tokensEnnemis.push(tok);
      });
      target.ennemisAuContact = tokensEnnemis;
      target.alliesAuContact = tokensAllies;
      if (combatEnPhalange) {
        let defensePhalange = 0;
        tokensEnnemis.forEach(function(tokE) {
          let alliesAuContact = tokensAllies.filter(function(tokA) {
            return distanceCombat(tokE, tokA, pageId) === 0;
          });
          if (alliesAuContact.length > defensePhalange)
            defensePhalange = alliesAuContact.length;
        });
        if (defensePhalange > 0) {
          defense += defensePhalange;
          explications.push("Combat en phalange => +" + defensePhalange + " DEF");
        }
      }
    }
    if (attributeAsBool(target, 'espaceExigu')) {
      let bonusForce = modCarac(target, 'force');
      if (bonusForce < 1) bonusForce = 1;
      explications.push("Espace exigu : -" + bonusForce + " en DEF");
      defense -= bonusForce;
    } else if (attributeAsBool(target, 'constructionTailleHumaine')) {
      explications.push("Construction de taille humaine : -1 en DEF");
      defense -= 1;
    }
    defense += predicateAsInt(target, 'voieDesRunes', 0, 1);
    if (attributeAsBool(target, 'attaqueRisquee')) {
      defense -= 4;
      explications.push("Suite \xE0 une attaque risqu\xE9e, -4 en DEF");
    }
    let armeTarget = armesEnMain(target); //peuple target.arme et armeGauche
    //gestion de l'\xE9pieu
    if (attaquant) {
      if (armeTarget && armeTarget.epieu && !armesEnMain(attaquant)) {
        defense += 2;
        explications.push("\xC9pieu contre une attaque sans arme => +2 DEF");
      }
    }
    if (options.distance) {
      let bonusCouvert = attributeAsInt(target, 'bonusCouvert');
      if (bonusCouvert) {
        if (attaquant && predicateAsBool(attaquant, 'joliCoup')) {
          explications.push("Cible \xE0 couvert, mais " + nomPerso(attaquant) + " sait bien viser");
        } else {
          defense += bonusCouvert;
          explications.push("Cible \xE0 couvert => +" + bonusCouvert + " DEF");
        }
      }
      if (attributeAsBool(target, 'progresserACouvert')) {
        if (attaquant && predicateAsBool(attaquant, 'joliCoup')) {
          explications.push("Cible \xE0 couvert de bouclier, mais " + nomPerso(attaquant) + " sait bien viser");
        } else {
          defense += 5;
          explications.push("Cible \xE0 couvert de bouclier => +5 DEF");
        }
      }
    }
    //Chair \xE0 canon
    if (capaciteDisponible(target, 'chairACanon', 'tour')) {
      let tokensChairACanon = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        layer: 'objects'
      });
      target.chairACanon = tokensChairACanon.filter(function(tok) {
        if (tok.id == target.token.id) return false;
        let tokCharId = tok.get('represents');
        if (tokCharId === '') return false;
        if (distanceCombat(target.token, tok, pageId) > 3) return false;
        let pChair = {
          token: tok,
          charId: tokCharId,
        };
        if (getState(pChair, 'mort')) return;
        let tokPreds = predicatesNamed(pChair, 'chairACanonDe');
        let estChair = tokPreds.find(function(a) {
          let chairACanonDe = a.split(',');
          return chairACanonDe.find(function(b) {
            let trimmed = b.trim();
            return trimmed == nomPerso(target) || trimmed == target.name;
          });
        });
        return estChair;
      });
      if (target.chairACanon.length > 0) {
        defense += 5;
        explications.push(target.chairACanon[0].get('name') + " aide " + nomPerso(target) + " ! => +5 DEF");
      }
    }
    let bonusCapitaine = aUnCapitaine(target, evt, pageId);
    if (bonusCapitaine && bonusCapitaine > 2) {
      defense += parseInt(bonusCapitaine);
      explications.push(tokenName + " suit les ordres de son commandant => +" + bonusCapitaine + " en DEF");
    }
    if (attaquant && predicateAsBool(target, 'reduireLaDistance')) {
      switch (taillePersonnage(attaquant, 4)) {
        case 5:
          defense += 2;
          explications.push(nomPerso(target) + " r\xE9duit la distance => +2 en DEF");
          break;
        case 6:
          defense += 3;
          explications.push(nomPerso(target) + " r\xE9duit la distance => +3 en DEF");
          break;
        case 7:
          defense += 4;
          explications.push(nomPerso(target) + " r\xE9duit la distance => +4 en DEF");
      }
    }
    if (attaquant && predicateAsBool(target, 'insignifiant')) {
      switch (taillePersonnage(attaquant, 4)) {
        case 5:
          defense += 2;
          explications.push(nomPerso(target) + " insignifiant => +2 en DEF");
          break;
        case 6:
        case 7:
          defense += 4;
          explications.push(nomPerso(target) + " insignifiant => +4 en DEF");
      }
    }
    if (attributeAsBool(target, 'etreinteImmole')) {
      defense -= 5;
      explications.push(nomPerso(target) + " \xE9treint quelqu'un => -5 en DEF");
    }
    if (attributeAsBool(target, 'etreinteScorpionRatee')) {
      defense -= 5;
      explications.push(nomPerso(target) + " est \xE9treint par un scorpion => -5 DEF");
    }
    if (attaquant && predicateAsBool(target, 'langageSombreHetre') && estElfeNoir(attaquant)) {
      defense += 1;
      explications.push(nomPerso(target) + " comprend le langage sombre => +1 en DEF");
    }
    if (attributeAsBool(target, 'presenceGlaciale')) {
      let defenseGlaciale = getValeurOfEffet(target, 'presenceGlaciale', 4);
      explications.push("Pr\xE9sence glaciale => +" + defenseGlaciale + " en DEF");
      defense += defenseGlaciale;
    }
    if (attributeAsBool(target, 'cyclone')) {
      explications.push("Cyclone => +5 en DEF");
      defense += 5;
    }
    if (options.pacteSanglantDef && options.pacteSanglantDef[target.token.id]) {
      explications.push("Pacte Sanglant => +" + options.pacteSanglantDef[target.token.id] + " en DEF");
      defense += options.pacteSanglantDef[target.token.id];
    }
    if (options.expertDuCombatDEF && options.expertDuCombatDEF[target.token.id]) {
      explications.push("Expert du combat => +" + options.expertDuCombatDEF[target.token.id].roll + " en DEF");
      defense += options.expertDuCombatDEF[target.token.id].val;
    }
    let defArme = 0;
    if (armeTarget && armeTarget.bonusDef) defArme = armeTarget.bonusDef;
    if (defArme > 0) {
      explications.push("Arme de parade en main => +" + defArme + " en DEF");
      defense += defArme;
    }
    if (target.armeGauche && target.armeGauche.bonusDef)
      defArme = target.armeGauche.bonusDef;
    if (defArme > 0) {
      explications.push("Arme de parade en main gauche => +" + defArme + " en DEF");
      defense += defArme;
    }
    if (attributeAsBool(target, 'prescienceUtilisee')) {
      explications.push("Prescience => +10 en DEF");
      defense += 10;
    }
    if (options.contact && attributeAsBool(target, 'tenirADistance')) {
      explications.push("Tient l'ennemi \xE0 distance => +5 en DEF");
      defense += 5;
    }
    let tm = stateCOF.tenebresMagiques;
    if (tm) {
      if (estDemon(target)) {
        if (eclaireParFioleDeLumiere(target, tm)) {
          explications.push("Aveugl\xE9 par la fiole de lumi\xE8re => -2 en DEF");
          defense -= 2;
        }
      } else if (attaquant &&
        !eclaireParFioleDeLumiere(attaquant, tm)) {
        explications.push("T\xE9n\xE8bres magiques => -5 en DEF");
        defense -= 5;
      }
    }
    if (attributeAsBool(target, 'agrippeParUnDemon')) {
      explications.push("agripp\xE9 => -3 en DEF");
      defense -= 3;
    }
    if (estNecromancie(options) && attributeAsBool(target, 'sangDeLArbreCoeur')) {
      explications.push("Sang de l'Arbre-Coeur => +5 en DEF");
      defense += 5;
    }
    if (predicateAsBool(target, 'liberateurDeDorn') && estGeant(attaquant)) {
      explications.push('Lib\xE9rateur de Dorn => +2 en DEF');
      defense += 2;
    }
    let pirouettes = predicateAsInt(target, 'pirouettes', 0);
    if (pirouettes > 0) {
      if (malusArmure(target) > 4) {
        explications.push('Armure lourde, pas de pirouette');
      } else {
        explications.push('Pirouettes => +' + pirouettes + ' en DEF');
        defense += pirouettes;
      }
    }
    if (attributeAsBool(target, 'danseDesLames') && malusArmure(target) <= 4) {
      explications.push('Danse des lames => +2 en DEF');
      defense += 2;
    }
    if (attributeAsBool(target, 'paradeCroisee')) {
      let bonus = getValeurOfEffet(target, 'paradeCroisee', 2);
      explications.push("Parade crois\xE9e => +" + bonus + " en DEF");
      defense += bonus;
    }
    let conditions = attributeAsInt(target, 'conditionsHostiles', 0, 2);
    if (conditions > 0 && (!predicateAsBool(target, 'marcheSylvestre') || conditions > 4)) {
      let msgConditions = "Conditions ";
      if (conditions < 5) msgConditions += "hostiles";
      else msgConditions += "extr\xEAmes";
      msgConditions += " : -" + conditions + " en DEF";
      explications.push(msgConditions);
      defense -= conditions;
    }
    if (attributeAsBool(target, 'rage')) {
      explications.push("En rage => -2 en DEF");
      defense -= 2;
    }
    if (predicateAsBool(target, 'toutPetit') && !attributeAsBool(target, 'grandeTaille')) {
      defense += 2;
    }
    defense += predicateAsInt(target, 'DEF', 0);
    return defense;
  }

  // renvoie l'attribut cr\xE9\xE9 ou mis \xE0 jour
  function setAttrDuree(perso, attr, duree, evt, msg, secret) {
    let options = {
      maxVal: getInit(),
      secret: secret
    };
    if (msg) options.msg = msg;
    return setTokenAttr(perso, attr, duree, evt, options);
  }

  //Tous les bonus de DM normalement calcul\xE9s dans bonusAttaqueA
  function bonusDMA(attaquant, weaponName, evt, explications, options) {
    if (options.pasDeDmg) return;
    options.bonusDM = 0;
    if (attributeAsBool(attaquant, 'baroudHonneurActif')) {
      explications.push(nomPerso(attaquant) + " porte une derni\xE8re attaque et s'effondre");
      mort(attaquant, function(m) {
        explications.push(m);
      }, evt);
      removeTokenAttr(attaquant, 'baroudHonneurActif', evt);
    }
    if (attributeAsBool(attaquant, 'reactionViolente')) {
      explications.push("R\xE9action violente => +1d6 DM");
      options.reactionViolente = true;
    }
    if (attributeAsBool(attaquant, 'drainDeForce')) {
      explications.push("Force drain\xE9e => -2 aux DM");
      options.drainDeForce = true;
    }
    if (options.contact) {
      if (attributeAsBool(attaquant, 'rayonAffaiblissant')) {
        options.rayonAffaiblissant = getValeurOfEffet(attaquant, 'rayonAffaiblissant', 2);
        if (options.rayonAffaiblissant < 0) options.rayonAffaiblissant = 1;
        let msg = "Rayon affaiblissant => -" + options.rayonAffaiblissant + " aux DM";
        explications.push(msg);
      }
      if (attributeAsBool(attaquant, 'enrage')) {
        explications.push("Enrag\xE9 => +1d6 DM");
        options.enrage = true;
      }
      if (attributeAsBool(attaquant, 'rage')) {
        explications.push("Enrag\xE9 => +2 DM");
        options.rage = true;
      }
      let rageBerserk = tokenAttribute(attaquant, 'rageDuBerserk');
      if (rageBerserk.length > 0) {
        rageBerserk = rageBerserk[0].get('current');
        if (rageBerserk == 'furie') {
          explications.push("Furie du berserk : +2d6 aux DM");
          options.rageBerserk = 2;
        } else {
          explications.push("Rage du berserk : +1d6 aux DM");
          options.rageBerserk = 1;
        }
      } else if (attributeAsBool(attaquant, 'frenesieMinotaure')) {
        explications.push("Fr\xE9n\xE9sie : +1d6 aux DM");
        options.rageBerserk = 1;
      }
      if (predicateAsBool(attaquant, 'ambidextreDuelliste')) {
        if (attaquant.armesEnMain === undefined) armesEnMain(attaquant);
        if (attaquant.armeGauche && attaquant.armeGauche.portee === 0) {
          let dmArmeGauche = modCarac(attaquant, 'dexterite');
          if (attaquant.armeGauche.bonusDef) {
            dmArmeGauche += attaquant.armeGauche.attDMBonusCommun;
          }
          let typeDMGauche = 'normal';
          switch (attaquant.armeGauche.typeDegats) {
            case 'feu':
            case 'froid':
            case 'acide':
            case 'electrique':
            case 'sonique':
            case 'poison':
            case 'maladie':
            case 'magique':
            case 'drain':
            case 'energie':
              typeDMGauche = attaquant.armeGauche.typeDegats;
          }
          if (typeDMGauche == 'normal' && attaquant.armeGauche.modificateurs &&
            attaquant.armeGauche.modificateurs.includes("magique")) {
            typeDMGauche = 'magique';
          }
          attaquant.additionalDmg = attaquant.additionalDmg || [];
          attaquant.additionalDmg.push({
            type: typeDMGauche,
            value: dmArmeGauche
          });
          let msgAmbidextre = "Attaque ambidextre => +";
          explications.push(msgAmbidextre + dmArmeGauche + " aux DMs");
        }
      }
    }
    let pv, pvMax;
    if (predicateAsBool(attaquant, 'hausserLeTon')) {
      if (pv === undefined)
        pv = parseInt(attaquant.token.get('bar1_value'));
      pvMax = parseInt(attaquant.token.get('bar1_max'));
      if (pv <= pvMax / 2) {
        let msgHausserLeTon = "Hausse le ton => +1d6 DM";
        msgHausserLeTon += " et +1d6 DM";
        attaquant.additionalDmg = attaquant.additionalDmg || [];
        attaquant.additionalDmg.push({
          type: options.type || 'normal',
          value: '1d6'
        });
        explications.push(msgHausserLeTon);
      }
    }
    if (stateCOF.chargeFantastique &&
      stateCOF.chargeFantastique.tokenAttaque == attaquant.token.id) {
      let msgCharge = "Charge fantastique => +1d6 DM";
      msgCharge += " et +1d6 DM";
      attaquant.additionalDmg = attaquant.additionalDmg || [];
      attaquant.additionalDmg.push({
        type: options.type || 'normal',
        value: '1d6'
      });
      explications.push(msgCharge);
    }
    let attrGobe = tokenAttribute(attaquant, 'estGobePar');
    if (attrGobe.length > 0) {
      let gobant =
        persoOfIdName(attrGobe[0].get('current'), attaquant.token.get('pageid'));
      if (gobant === undefined) {
        error("Attribut estGobePar mal form\xE9", attrGobe[0].get('current'));
        attrGobe[0].remove();
        unlockToken(attaquant, evt);
      } else {
        explications.push("Attaquant dans le ventre de " + nomPerso(gobant) + " => DM/2");
        options.attaqueEnEtantGobe = true;
      }
    }
    if (attributeAsBool(attaquant, 'noyade')) {
      options.noyade = true;
      explications.push("L'attaquant se noie => -3 DMs");
    }
    if ((options.marteau || options.hache) && predicateAsBool(attaquant, 'hachesEtMarteaux')) {
      options.bonusDM += 1;
      explications.push("Haches et marteaux => +1 DM");
    }
    let energieImpie = attributeAsInt(attaquant, 'energieImpie', 0);
    if (energieImpie) {
      options.bonusDM += energieImpie;
      explications.push("\xC9nergie impie => +" + energieImpie + " DM");
    }
    if (options.arcComposite) {
      let force = modCarac(attaquant, 'force');
      if (force > options.arcComposite) force = options.arcComposite;
      let msg = "Arc composite => ";
      if (force < 0) msg += force + " DM";
      else if (force > 0) msg += '+' + force + " DM";
      if (force) {
        options.bonusDM += force;
      }
      explications.push(msg);
    }
    if (attributeAsBool(attaquant, 'fievreux')) {
      options.fievreux = true;
      explications.push("Fi\xE9vreu" + onGenre(attaquant, 'x', 'se') + " => -2 DM");
    }
    if (options.expertDuCombatDM && !options.pasDeDmg) {
      let valDesExpert = options.rolls.expertDuCombatDM || rollDePlus(6);
      evt.action.rolls.expertDuCombatDM = valDesExpert;
      options.expertDuCombatDMSpec = {
        type: "normal",
        value: "1d6",
        total: valDesExpert.val,
        display: valDesExpert.roll
      };
      explications.push("Expert du combat => +" + valDesExpert.roll + " aux DM");
    }
    if (predicateAsBool(attaquant, 'fureurDrakonide')) {
      if (pv === undefined) pv = parseInt(attaquant.token.get('bar1_value'));
      if (pvMax === undefined)
        pvMax = parseInt(attaquant.token.get('bar1_max'));
      if (pv <= pvMax / 2 || attributeAsBool(attaquant, 'fureurDrakonideCritique')) {
        explications.push("Fureur draconide : +1 DM");
        options.fureurDrakonide = 1;
      }
    }
    if (options.attaqueFlamboyante && options.contact) {
      let bonus = modCarac(attaquant, 'charisme');
      options.attaqueFlamboyanteBonus = bonus;
      options.bonusDM += bonus;
      explications.push("Attaque flamboyante => +" + bonus + " DM");
    }
    return;
  }

  //Bonus en Attaque qui ne d\xE9pendent pas du d\xE9fenseur
  //Remplit le champs options.bonusDM (en partant de 0)
  function bonusAttaqueA(attaquant, weaponName, evt, explications, options) {
    let attBonus = 0;
    if (options.bonusAttaque) attBonus += options.bonusAttaque;
    if (options.armeMagiquePlus) attBonus += options.armeMagiquePlus;
    options.bonusDM = 0;
    attBonus += bonusDAttaque(attaquant, explications, evt, options);
    if (options.tirDouble) {
      attBonus += 2;
      if (options.tirDouble.stats && options.tirDouble.stats.name) {
        explications.push(nomPerso(attaquant) + " tire avec " +
          weaponName + " et " + options.tirDouble.stats.name + " \xE0 la fois !");
      } else {
        explications.push(nomPerso(attaquant) + " tire avec 2 " +
          weaponName + "s \xE0 la fois !");
      }
    }
    if (options.chance) {
      attBonus += options.chance;
      let pc = options.chance / 10;
      explications.push(pc + " point" + ((pc > 1) ? "s" : "") + " de chance d\xE9pens\xE9 => +" + options.chance + " en Attaque");
    }
    if (options.semonce) {
      attBonus += 5;
    }
    if (!options.pasDeDmg && !options.feinte) {
      if (ficheAttributeAsBool(attaquant, 'attaque_en_puissance_check')) {
        options.attaqueEnPuissance = ficheAttributeAsInt(attaquant, 'attaque_en_puissance', 1);
      }
      if (!options.auto && options.attaqueEnPuissance) {
        attBonus -= 5 * options.attaqueEnPuissance;
        explications.push("Attaque en puissance => -" + (5 * options.attaqueEnPuissance) + " en Attaque et +" + options.attaqueEnPuissance + options.d6 + " DM");
      }
      if (ficheAttributeAsBool(attaquant, 'attaque_assuree_check')) {
        options.attaqueAssuree = true;
      }
      if (options.attaqueAssuree) {
        attBonus += 5;
        explications.push("Attaque assur\xE9e => +5 en Attaque et DM/2");
      }
      if (ficheAttributeAsBool(attaquant, 'attaque_dm_temp_check')) {
        options.attaqueDmTemp = true;
      }
      if (options.attaqueDmTemp && !options.tempDmg && !options.sortilege && (options.contact || !options.percant)) {
        options.tempDmg = true;
        if (!options.choc) {
          attBonus -= 2;
          explications.push("Attaque pour assommer => -2 en Attaque");
        }
      }
    }
    if (persoEstPNJ(attaquant) && options.attaqueDeGroupe === undefined) {
      options.attaqueDeGroupe = ficheAttributeAsInt(attaquant, 'attaque_de_groupe', 1);
    }
    if (options.attaqueDeGroupe > 1) {
      let bonusTouche =
        reglesOptionelles.haute_DEF.val.bonus_attaque_groupe.val * (options.attaqueDeGroupe - 1);
      attBonus += bonusTouche;
      explications.push("Attaque en groupe => +" + bonusTouche + " en Attaque");
    }
    if (attributeAsBool(attaquant, 'criDuPredateur')) {
      attBonus += 1;
      explications.push("Cri du pr\xE9dateur => +1 en attaque");
    }
    if (attributeAsBool(attaquant, 'baroudHonneurActif')) {
      attBonus += 5;
      explications.push(nomPerso(attaquant) + " porte une derni\xE8re attaque et s'effondre");
      mort(attaquant, function(m) {
        explications.push(m);
      }, evt);
      removeTokenAttr(attaquant, 'baroudHonneurActif', evt);
    }
    if (options.sortilege && attributeAsBool(attaquant, 'zoneDeSilence')) {
      attBonus -= 2;
      explications.push("Zone de silence => -2 en Attaque Magique");
    }
    if (attributeAsBool(attaquant, 'monteSur')) {
      if (!options.distance) {
        let cavalierEm = predicateAsInt(attaquant, 'cavalierEmerite');
        if (cavalierEm) {
          attBonus += cavalierEm;
          let explCavalierEmerite = "avalier \xE9m\xE9rite => +" + cavalierEm + " en Attaque";
          if (options.displayName) {
            explCavalierEmerite = nomPerso(attaquant) + " est un c" + explCavalierEmerite;
          } else {
            explCavalierEmerite = 'C' + explCavalierEmerite;
          }
          explications.push(explCavalierEmerite);
        }
      }
      if (predicateAsBool(attaquant, 'montureLoyale')) {
        attBonus += 1;
        explications.push("Monture loyale => +1 en Attaque");
      }
    }
    if (options.frappeDuVide) {
      attBonus += 2;
      if (options.pasDeDmg)
        explications.push("Frappe du vide => +2 en Attaque");
      else
        explications.push("Frappe du vide => +2 en Attaque et +1d6 DM");
    }
    if (attributeAsBool(attaquant, 'reactionViolente')) {
      attBonus += 2;
      if (options.pasDeDmg)
        explications.push("R\xE9action violente => +2 en Attaque");
      else {
        explications.push("R\xE9action violente => +2 en Attaque et +1d6 DM");
        options.reactionViolente = true;
      }
    }
    if (attributeAsBool(attaquant, 'drainDeForce')) {
      attBonus -= 2;
      let msg = "Force drain\xE9e => -2 en Attaque";
      if (options.pasDeDmg || !options.contact) explications.push(msg);
      else explications.push(msg + " et aux DM");
      options.drainDeForce = true;
    }
    let energieImpie = attributeAsInt(attaquant, 'energieImpie', 0);
    if (energieImpie) {
      attBonus += energieImpie;
      let msg = "\xC9nergie impie => +" + energieImpie + " en Attaque";
      if (!options.pasDeDmg) {
        msg += " et aux DM";
        options.bonusDM += energieImpie;
      }
      explications.push(msg);
    }
    if (options.contact) {
      if (attributeAsBool(attaquant, 'rayonAffaiblissant')) {
        options.rayonAffaiblissant = getValeurOfEffet(attaquant, 'rayonAffaiblissant', 2);
        if (options.rayonAffaiblissant < 0) options.rayonAffaiblissant = 1;
        attBonus -= options.rayonAffaiblissant;
        let msg = "Rayon affaiblissant => -" + options.rayonAffaiblissant + " en Attaque";
        if (options.pasDeDmg) explications.push(msg);
        else explications.push(msg + " et aux DM");
      }
      if (attributeAsBool(attaquant, 'enrage')) {
        attBonus += 5;
        options.enrage = true;
        if (options.pasDeDmg)
          explications.push("Enrag\xE9 => +5 en Attaque");
        else
          explications.push("Enrag\xE9 => +5 en Attaque et +1d6 DM");
      }
      if (attributeAsBool(attaquant, 'rage')) {
        attBonus += 2;
        if (options.pasDeDmg)
          explications.push("Enrag\xE9 => +2 en Attaque");
        else
          explications.push("Enrag\xE9 => +2 en Attaque et +2 DM");
        options.rage = true;
      }
      if (attributeAsBool(attaquant, 'aspectDuDemon')) {
        attBonus += getValeurOfEffet(attaquant, 'aspectDuDemon', 2);
        explications.push("Aspect de d\xE9mon => +2 en Attaque");
      }
      let rageBerserk = tokenAttribute(attaquant, 'rageDuBerserk');
      if (rageBerserk.length > 0) {
        rageBerserk = rageBerserk[0].get('current');
        if (rageBerserk == 'furie') {
          attBonus += 3;
          if (options.pasDeDmg)
            explications.push("Furie du berserk : +3 en Attaque");
          else
            explications.push("Furie du berserk : +3 en Attaque et +2d6 aux DM");
          options.rageBerserk = 2;
        } else {
          attBonus += 2;
          if (options.pasDeDmg)
            explications.push("Rage du berserk : +2 en Attaque");
          else
            explications.push("Rage du berserk : +2 en Attaque et +1d6 aux DM");
          options.rageBerserk = 1;
        }
      } else if (attributeAsBool(attaquant, 'frenesieMinotaure')) {
        attBonus += 2;
        if (options.pasDeDmg)
          explications.push("Fr\xE9n\xE9sie : +2 en Attaque");
        else
          explications.push("Fr\xE9n\xE9sie : +2 en Attaque et +1d6 aux DM");
        options.rageBerserk = 1;
      }
      if (ficheAttributeAsBool(attaquant, 'attaque_risquee_check')) {
        options.attaqueRisquee = true;
      }
      if (options.attaqueRisquee) {
        attBonus += 2;
        explications.push("Attaque risqu\xE9e => +2 en Attaque");
        if (!options.test) {
          setAttrDuree(attaquant, 'attaqueRisquee', 1, evt);
        }
      }
      if (predicateAsBool(attaquant, 'ambidextreDuelliste')) {
        if (attaquant.armesEnMain === undefined) armesEnMain(attaquant);
        if (attaquant.armeGauche && attaquant.armeGauche.portee === 0) {
          let dmArmeGauche = modCarac(attaquant, 'dexterite');
          let bonusArmeGauche = 0;
          if (attaquant.armeGauche.bonusDef) {
            if (attaquant.pnj) {
              bonusArmeGauche = attaquant.armeGauche.attSkill;
            } else {
              bonusArmeGauche = attaquant.armeGauche.attSkillDiv;
            }
            dmArmeGauche += attaquant.armeGauche.attDMBonusCommun;
          }
          let typeDMGauche = 'normal';
          switch (attaquant.armeGauche.typeDegats) {
            case 'feu':
            case 'froid':
            case 'acide':
            case 'electrique':
            case 'sonique':
            case 'poison':
            case 'maladie':
            case 'magique':
            case 'drain':
            case 'energie':
              typeDMGauche = attaquant.armeGauche.typeDegats;
          }
          if (typeDMGauche == 'normal' && attaquant.armeGauche.modificateurs &&
            attaquant.armeGauche.modificateurs.includes("magique")) {
            typeDMGauche = 'magique';
          }
          attaquant.additionalDmg = attaquant.additionalDmg || [];
          attaquant.additionalDmg.push({
            type: typeDMGauche,
            value: dmArmeGauche
          });
          attBonus += bonusArmeGauche;
          let msgAmbidextre = "Attaque ambidextre => +";
          if (bonusArmeGauche) {
            msgAmbidextre += bonusArmeGauche + " en attaque";
            if (options.pasDeDmg) explications.push(msgAmbidextre);
            else msgAmbidextre += " et +";
          }
          if (!options.pasDeDmg)
            explications.push(msgAmbidextre + dmArmeGauche + " aux DMs");
        }
      }
    }
    let frenesie = predicateAsInt(attaquant, 'frenesie', 0);
    let pv, pvMax;
    if (frenesie > 0) {
      pv = parseInt(attaquant.token.get('bar1_value'));
      if (pv <= frenesie) {
        attBonus += 2;
        explications.push("Fr\xE9n\xE9sie => +2 en Attaque");
      }
    }
    if (predicateAsBool(attaquant, 'hausserLeTon')) {
      if (pv === undefined)
        pv = parseInt(attaquant.token.get('bar1_value'));
      pvMax = parseInt(attaquant.token.get('bar1_max'));
      if (pv <= pvMax / 2) {
        attBonus += 5;
        let msgHausserLeTon = "Hausse le ton => +5 en Attaque";
        if (!options.pasDeDmg) {
          msgHausserLeTon += " et +1d6 DM";
          attaquant.additionalDmg = attaquant.additionalDmg || [];
          attaquant.additionalDmg.push({
            type: options.type || 'normal',
            value: '1d6'
          });
        }
        explications.push(msgHausserLeTon);
      }
    }
    if (options.lamesJumelles) {
      let force = modCarac(attaquant, 'force');
      if (force < 2) {
        attBonus += force - 2;
        explications.push("Lames jumelles => " + (force - 2) + " en Attaque");
      }
    }
    if (stateCOF.chargeFantastique &&
      stateCOF.chargeFantastique.tokenAttaque == attaquant.token.id) {
      attBonus += 3;
      let msgCharge = "Charge fantastique => +3 en Attaque";
      if (!options.pasDeDmg) {
        msgCharge += " et +1d6 DM";
        attaquant.additionalDmg = attaquant.additionalDmg || [];
        attaquant.additionalDmg.push({
          type: options.type || 'normal',
          value: '1d6'
        });
      }
      explications.push(msgCharge);
    }
    if (attributeAsBool(attaquant, 'enerve')) {
      attBonus -= 2;
      explications.push("Attaquant \xE9nerv\xE9 => -2 en Attaque");
    }
    if (attributeAsBool(attaquant, 'osBrises')) {
      attBonus -= 2;
      explications.push("Des os sont bris\xE9s => -2 en Attaque");
    }
    let attrGobe = tokenAttribute(attaquant, 'estGobePar');
    if (attrGobe.length > 0) {
      let gobant =
        persoOfIdName(attrGobe[0].get('current'), attaquant.token.get('pageid'));
      if (gobant === undefined) {
        error("Attribut estGobePar mal form\xE9", attrGobe[0].get('current'));
        attrGobe[0].remove();
        unlockToken(attaquant, evt);
      } else {
        attBonus -= 5;
        explications.push("Attaquant dans le ventre de " + nomPerso(gobant) + " => -5 en Att. et DM/2");
        options.attaqueEnEtantGobe = true;
      }
    }
    if (attributeAsBool(attaquant, 'noyade')) {
      attBonus -= 3;
      options.noyade = true;
      explications.push("L'attaquant se noie => -3 en Att. et DMs");
    }
    if ((options.marteau || options.hache) && predicateAsBool(attaquant, 'hachesEtMarteaux')) {
      attBonus += 1;
      options.bonusDM += 1;
      explications.push("Haches et marteaux => +1 en Att. et DM");
    }
    let armeDePredilection = predicateAsBool(attaquant, 'armeDePredilection');
    if (armeDePredilection) {
      let actif = false;
      switch (armeDePredilection) {
        case 'arc':
        case 'arbalete':
        case 'fronde':
        case 'hache':
        case 'epee':
        case 'marteau':
        case 'epieu':
        case 'poudre':
        case 'baton':
        case 'masse':
        case 'rapiere':
          actif = options[armeDePredilection];
          if (!actif) {
            let weaponStats = armesEnMain(attaquant);
            if (weaponStats) actif = weaponStats[armeDePredilection];
          }
      }
      if (actif) {
        attBonus += 1;
        explications.push("Arme de pr\xE9dil\xE9ction => +1 en Attaque");
      }
    }
    if (options.arcComposite) {
      let force = modCarac(attaquant, 'force');
      if (force > options.arcComposite) force = options.arcComposite;
      let msg = "Arc composite => ";
      if (force < 0) msg += force + " DM";
      else if (force > 0) msg += '+' + force + " DM";
      if (force) {
        options.bonusDM += force;
      }
      if (force < options.arcComposite) {
        if (force === 0) msg += "-2 Att.";
        else if (force < 0) msg += " et -2 Att.";
        else msg += "mais -2 Att.";
        attBonus -= 2;
      }
      explications.push(msg);
    }
    if (attributeAsBool(attaquant, 'fievreux')) {
      attBonus -= 2;
      options.fievreux = true;
      explications.push("Fi\xE9vreu" + onGenre(attaquant, 'x', 'se') + " => -2 en Att. et DM");
    }
    if (options.expertDuCombatTouche) {
      let valDesExpert = options.rolls.expertDuCombatTouche || rollDePlus(6);
      evt.action.rolls.expertDuCombatTouche = valDesExpert;
      attBonus += valDesExpert.val;
      explications.push("Expert du combat => +" + valDesExpert.roll + " en Attaque");
    }
    if (options.expertDuCombatDM && !options.pasDeDmg) {
      let valDesExpert = options.rolls.expertDuCombatDM || rollDePlus(6);
      evt.action.rolls.expertDuCombatDM = valDesExpert;
      options.expertDuCombatDMSpec = {
        type: "normal",
        value: "1d6",
        total: valDesExpert.val,
        display: valDesExpert.roll
      };
      explications.push("Expert du combat => +" + valDesExpert.roll + " aux DM");
    }
    if (attributeAsBool(attaquant, 'danseDesLames') && malusArmure(attaquant) <= 4) {
      explications.push('Danse des lames => +2 en attaque');
      attBonus += 2;
    }
    if (options.magieEnArmure) {
      let malus = 1;
      if (options.magieEnArmure.base) {
        malus = options.magieEnArmure.base;
      } else if (options.rang) {
        malus = options.rang;
      }
      let ma = malusArmure(attaquant);
      malus += ma;
      if (malus > 0) {
        let magieEnArmure = predicateAsInt(attaquant, 'magieEnArmure', 0);
        let defa = defenseArmure(attaquant);
        if (2 * magieEnArmure >= defa + ma) { //pas de malus
          malus = 0;
        } else {
          if (magieEnArmure > 0 && predicateAsBool(attaquant, 'magieEnArmureFacilitee')) {
            malus -= magieEnArmure;
            if (malus < 0) malus = 1;
          }
        }
      }
      if (malus > 0) {
        explications.push("Magie en armure => -" + malus + " en attaque");
        attBonus -= malus;
      }
    }
    if (attributeAsBool(attaquant, 'armesNaturelles')) {
      let weaponStats = armesEnMain(attaquant);
      if (weaponStats.arme) {
        explications.push("Utilisation d'une arme avec ses griffes => -1 en attaque");
        attBonus -= 1;
      }
    }
    if (predicateAsBool(attaquant, 'fureurDrakonide')) {
      if (pv === undefined) pv = parseInt(attaquant.token.get('bar1_value'));
      if (pvMax === undefined)
        pvMax = parseInt(attaquant.token.get('bar1_max'));
      if (pv <= pvMax / 2 || attributeAsBool(attaquant, 'fureurDrakonideCritique')) {
        attBonus += 1;
        if (options.pasDeDmg)
          explications.push("Fureur draconide : +1 en Attaque");
        else
          explications.push("Fureur draconide : +1 en Attaque et aux DM");
        options.fureurDrakonide = 1;
      }
    }
    let conditions = attributeAsInt(attaquant, 'conditionsHostiles', 0, 2);
    if (conditions > 0 && (!predicateAsBool(attaquant, 'marcheSylvestre') || conditions > 4)) {
      let msgConditions = "Conditions ";
      if (conditions < 5) msgConditions += "hostiles";
      else msgConditions += "extr\xEAmes";
      msgConditions += " : -" + conditions + " en attaque";
      explications.push(msgConditions);
      attBonus -= conditions;
    }
    if (options.attaqueFlamboyante && options.contact) {
      let bonus = modCarac(attaquant, 'charisme');
      options.attaqueFlamboyanteBonus = bonus;
      if (options.bonusDM !== undefined) options.bonusDM += bonus;
      explications.push("Attaque flamboyante => +" + bonus + " en Attaque et DM");
      attBonus += bonus;
    }
    if (options.frappeDesArcanes && options.contact) {
      attBonus += 5;
      let nbDes = options.frappeDesArcanes;
      explications.push("Frappe des arcanes => +5 en Attaque et +" + nbDes + "d6 DM");
      attaquant.additionalDmg = attaquant.additionalDmg || [];
      attaquant.additionalDmg.push({
        type: options.type || 'normal',
        value: nbDes + 'd6'
      });
    }
    return attBonus;
  }

  //Tous les bonus de DM normalement calcul\xE9s dans bonusAttaqueD
  function bonusDMD(attaquant, target, portee, pageId, evt, explications, options) {
    let chasseurEmerite =
      predicateAsBool(attaquant, 'chasseurEmerite') && estAnimal(target);
    if (chasseurEmerite) {
      let explChasseurEmerite = "hasseur \xE9m\xE9rite => +2 aux DM";
      if (options.displayName) {
        explChasseurEmerite = nomPerso(attaquant) + ' est un c' + explChasseurEmerite;
      } else {
        explChasseurEmerite = 'C' + explChasseurEmerite;
      }
      if (options.aoe) explChasseurEmerite += " contre " + nomPerso(target);
      explications.push(explChasseurEmerite);
      target.chasseurEmerite = true;
    }
    let racesEnnemiJure = predicatesNamed(attaquant, 'ennemiJure');
    let ennemiJure = racesEnnemiJure.some(function(rej) {
      return rej.split(',').some(function(race) {
        race = race.trim();
        if (race === '') return false;
        return persoEstDeCategorie(target, race);
      });
    });
    if (ennemiJure) {
      let explEnnemiJure = "Attaque sur ennemi jur\xE9 => + 1d6 aux DM";
      if (options.aoe) explEnnemiJure += " contre " + nomPerso(target);
      explications.push(explEnnemiJure);
      target.ennemiJure = true;
    }
    if (options.armeDArgent) {
      if (estMortVivant(target) || estDemon(target)) {
        explications.push("Arme en argent => +1d6 aux DM");
        target.armeDArgent = true;
      }
    }
    if (options.tueurDe) {
      options.tueurDe.forEach(function(categorie) {
        if (persoEstDeCategorie(target, categorie)) {
          let msg = "Tueur d";
          if (categorie.startsWith('i') || categorie.startsWith('h')) msg += "'";
          else msg += "e ";
          msg += categorie + " => +2 ";
          explications.push(msg + categorie + " => +2d6 DM");
          target.tueurDe = 2;
        }
      });
    }
    let attrFeinte = tokenAttribute(target, 'feinte_' + nomPerso(attaquant));
    if (attrFeinte.length > 0 && attrFeinte[0].get('current')) {
      let niveauTouche = attrFeinte[0].get('max');
      if (niveauTouche > 0) { //La feinte avait touch\xE9 cette cible
        let msgFeinte = "Feinte => ";
        let faireMouche = predicateAsInt(attaquant, 'faireMouche', 0);
        if (faireMouche > 0) {
          if (options.contact && !options.pasDeDmg) {
            target.faireMouche = faireMouche * niveauTouche;
            msgFeinte += " peut faire mouche";
          }
        } else {
          let desFeinte = predicateAsInt(attaquant, 'nbDesFeinte', 2);
          desFeinte *= niveauTouche;
          target.feinte = desFeinte;
          msgFeinte += " +" + desFeinte + options.d6;
          if (options.attaqueFlamboyanteBonus)
            msgFeinte += "+" + options.attaqueFlamboyanteBonus;
          msgFeinte += " DM";
        }
        explications.push(msgFeinte);
      }
    }
    let attrAgrippe = tokenAttribute(attaquant, 'agrippe');
    attrAgrippe.forEach(function(a) {
      let cibleAgrippee = persoOfIdName(a.get('current'), pageId);
      if (cibleAgrippee && cibleAgrippee.id == target.id &&
        !attributeAsBool(cibleAgrippee, 'agrippeParUnDemon')) {
        explications.push("Cible agripp\xE9e => +1d6 DM");
        target.estAgrippee = true;
      }
    });
    let tm = stateCOF.tenebresMagiques;
    if (tm) {
      if (!estDemon(attaquant) && !eclaireParFioleDeLumiere(target, tm)) {
        let riposte;
        if (tm.attaques && tm.attaques[target.token.id]) {
          riposte = tm.attaques[target.token.id].some(function(cible) {
            return cible.token.id == attaquant.token.id;
          });
        }
        if (riposte) {
          explications.push("Riposte dans le noir => -2 aux DMs");
          target.attaqueDansLeNoir = 2;
        } else {
          explications.push("Attaque dans le noir => -5 aux DMs");
          target.attaqueDansLeNoir = 5;
        }
      }
    }
    if (predicateAsBool(attaquant, 'liberateurDeDorn') && estGeant(target)) {
      explications.push("Lib\xE9rateur de Dorn => +2d6 DM");
      target.cibleLiberateurDeDorn = true;
    }
    if (predicateAsBool(attaquant, 'liberateurDeKerserac') && (estGeant(target) || estInsecte(target) || estElfeNoir(target))) {
      explications.push("Lib\xE9rateur de Kerserac => +1d6 DM");
      target.cibleLiberateurDeKerserac = true;
    }
    if (predicateAsBool(attaquant, 'liberateurDAnathazerin') && (estInsecte(target) || estElfeNoir(target))) {
      explications.push("Lib\xE9rateur d'Anathazer\xEFn => +2d6 DM");
      target.cibleLiberateurDAnathazerin = true;
    }
    let attrMeneurCible = tokenAttribute(target, 'meneurDHommesCible');
    if (attrMeneurCible.length > 0) {
      let meneurTokenId = attrMeneurCible[0].get('current');
      let meneurDHommes = persoOfId(meneurTokenId, meneurTokenId, pageId);
      if (meneurDHommes && alliesParPerso[meneurDHommes.charId] &&
        alliesParPerso[meneurDHommes.charId].has(attaquant.charId)) {
        target.cibleMeneurDHommes = true;
        explications.push(nomPerso(meneurDHommes) + " a d\xE9sign\xE9 " + nomPerso(target) +
          " comme la cible des attaques du groupe : +1d6 DM");
      }
    }
    let combattreLaCorruption =
      predicateAsInt(attaquant, 'combattreLaCorruption', 0, 1);
    if (combattreLaCorruption > 0 &&
      (predicateAsBool(target, 'corrompu') ||
        estDemon(target) ||
        estMortVivant(target))) {
      target.combattreLaCorruption = combattreLaCorruption;
      explications.push("Combattre la corruption => +" + combattreLaCorruption + " DM");
    }
    return;
  }

  //Bonus d'attaque qui d\xE9pendent de la cible
  function bonusAttaqueD(attaquant, target, portee, pageId, evt, explications, options) {
    let attBonus = 0;
    if (target.bonusAttaque) attBonus += target.bonusAttaque;
    if (getState(attaquant, 'aveugle')) {
      if (options.distance) {
        if (options.tirAveugle) {
          explications.push("Attaquant aveugl\xE9, mais il sait tirer \xE0 l'aveugle");
        } else {
          attBonus -= 10;
          explications.push("Attaquant aveugl\xE9 => -10 en Attaque \xE0 distance");
        }
      } else {
        if (!predicateAsBool(attaquant, 'radarMental') || estNonVivant(target)) {
          attBonus -= 5;
          explications.push("Attaquant aveugl\xE9 => -5 en Attaque");
        }
      }
    } else if (attributeAsBool(attaquant, 'aveugleManoeuvre')) {
      if (options.distance || !predicateAsBool(attaquant, 'radarMental') || estNonVivant(target)) {
        attBonus -= 5;
        options.aveugleManoeuvre = true;
        if (options.pasDeDmg)
          explications.push("Attaquant aveugl\xE9 => -5 en Attaque");
        else
          explications.push("Attaquant aveugl\xE9 => -5 en Attaque et aux DM");
      }
    } else if (getState(attaquant, 'invisible') && !attributeAsBool(target, 'detectionDeLInvisible')) {
      attBonus += 5;
      explications.push("Attaque venant d'un personnage invisible => +5 en Attaque");
    } else if (options.distance && getState(attaquant, 'penombre')) {
      if (options.tirAveugle) {
        explications.push("Attaquant dans la p\xE9nombre, mais il sait tirer \xE0 l'aveugle");
      } else {
        attBonus -= 5;
        explications.push("Attaquant dans la p\xE9nombre => -5 en Attaque \xE0 distance");
      }
    }
    if (options.mainsDEnergie) {
      if (options.aoe) error("Mains d'\xE9nergie n'est pas compatible avec les AOE", options.aoe);
      // On v\xE9rifie si la cible porte une armure
      let targetArmorDef = 0;
      if (persoEstPNJ(target)) {
        if (ficheAttributeAsBool(target, 'defarmureon', false)) targetArmorDef = 5;
      } else {
        targetArmorDef = defenseArmure(target);
      }
      if (isNaN(targetArmorDef) || targetArmorDef === 0) {
        attBonus += 2;
        explications.push("Mains d'\xE9nergie => +2 en Attaque (cible sans armure)");
      } else {
        let bonusMain = Math.min(5, 2 + targetArmorDef);
        attBonus += bonusMain;
        explications.push("Mains d'\xE9nergie => +" + bonusMain + " en Attaque");
      }
    }
    if (options.aoe === undefined && options.auto === undefined && portee > 0) {
      attBonus -=
        malusDistance(attaquant, target.token, target.distance, portee, pageId,
          explications, options.ignoreObstacles);
    }
    let chasseurEmerite =
      predicateAsBool(attaquant, 'chasseurEmerite') && estAnimal(target);
    if (chasseurEmerite) {
      attBonus += 2;
      let explChasseurEmerite = "hasseur \xE9m\xE9rite => +2 en Attaque";
      if (options.displayName) {
        explChasseurEmerite = nomPerso(attaquant) + ' est un c' + explChasseurEmerite;
      } else {
        explChasseurEmerite = 'C' + explChasseurEmerite;
      }
      if (!options.pasDeDmg) explChasseurEmerite += " et aux DM";
      if (options.aoe) explChasseurEmerite += " contre " + nomPerso(target);
      explications.push(explChasseurEmerite);
      target.chasseurEmerite = true;
    }
    let racesEnnemiJure = predicatesNamed(attaquant, 'ennemiJure');
    let ennemiJure = racesEnnemiJure.some(function(rej) {
      return rej.split(',').some(function(race) {
        race = race.trim();
        if (race === '') return false;
        return persoEstDeCategorie(target, race);
      });
    });
    if (ennemiJure) {
      let ejSag = modCarac(attaquant, 'sagesse');
      attBonus += ejSag;
      let explEnnemiJure = "Attaque sur ennemi jur\xE9 => +" + ejSag + " en attaque";
      if (!options.pasDeDmg) explEnnemiJure += " et +1d6 aux DM";
      if (options.aoe) explEnnemiJure += " contre " + nomPerso(target);
      explications.push(explEnnemiJure);
      target.ennemiJure = true;
    }
    if (options.armeDArgent) {
      if (estMortVivant(target) || estDemon(target)) {
        attBonus += 2;
        if (options.pasDeDmg)
          explications.push("Arme en argent => +2 en attaque");
        else
          explications.push("Arme en argent => +2 en attaque et +1d6 aux DM");
        target.armeDArgent = true;
      }
    }
    let bonusContreBouclier = options.bonusContreBouclier || 0;
    if (target.bonusContreBouclier) bonusContreBouclier += target.bonusContreBouclier;
    if (bonusContreBouclier) {
      if (ficheAttributeAsBool(target, 'defbouclieron', false)) {
        attBonus += bonusContreBouclier;
        explications.push("L'adversaire porte un bouclier => " + ((bonusContreBouclier > 0) ? '+' : '') + bonusContreBouclier + " en attaque");
      }
    }
    let bonusContreArmure = options.bonusContreArmure || 0;
    if (target.bonusContreArmure) bonusContreArmure += target.bonusContreArmure;
    if (bonusContreArmure) {
      if (ficheAttributeAsBool(target, 'defarmureon', false)) {
        attBonus += bonusContreArmure;
        explications.push("L'adversaire porte une armure => " + ((bonusContreArmure > 0) ? '+' : '') + bonusContreArmure + " en attaque");
      }
    }
    if (options.tueurDeGeants && estGeant(target)) {
      attBonus += 2;
      if (options.pasDeDmg)
        explications.push("Tueur de g\xE9ant => +2 en Attaque");
      else
        explications.push("Tueur de g\xE9ant => +2 att. et 2d6 DM");
      target.tueurDeGeants = true;
    }
    if (options.tueurDe) {
      options.tueurDe.forEach(function(categorie) {
        if (persoEstDeCategorie(target, categorie)) {
          let msg = "Tueur d";
          if (categorie.startsWith('i') || categorie.startsWith('h')) msg += "'";
          else msg += "e ";
          msg += categorie + " => +2 ";
          if (options.pasDeDmg)
            explications.push(msg + "en Attaque");
          else
            explications.push(msg + " att. et 2d6 DM");
          target.tueurDe = 2;
        }
      });
    }
    let attrFeinte = tokenAttribute(target, 'feinte_' + nomPerso(attaquant));
    if (attrFeinte.length > 0 && attrFeinte[0].get('current')) {
      let bonusFeinte = predicateAsInt(attaquant, 'bonusFeinte', 5);
      attBonus += bonusFeinte;
      let msgFeinte = "Feinte => +" + bonusFeinte + " en attaque";
      let niveauTouche = attrFeinte[0].get('max');
      if (niveauTouche > 0) { //La feinte avait touch\xE9 cette cible
        let faireMouche = predicateAsInt(attaquant, 'faireMouche', 0);
        if (faireMouche > 0) {
          if (options.contact && !options.pasDeDmg) {
            target.faireMouche = faireMouche * niveauTouche;
            msgFeinte += " et peut faire mouche";
          }
        } else {
          let desFeinte = predicateAsInt(attaquant, 'nbDesFeinte', 2);
          desFeinte *= niveauTouche;
          target.feinte = desFeinte;
          if (!options.pasDeDmg) {
            msgFeinte += " et +" + desFeinte + options.d6;
            if (options.attaqueFlamboyanteBonus)
              msgFeinte += "+" + options.attaqueFlamboyanteBonus;
            msgFeinte += " DM";

          }
        }
      }
      explications.push(msgFeinte);
    }
    if (attributeAsBool(target, 'expose')) {
      let attrsExposeValeur = tokenAttribute(target, "exposeValeur");
      let expose = false;
      attrsExposeValeur.forEach(function testExpose(attr) {
        if (attr.get("current") == attaquant.token.id) expose = true;
      });
      if (expose) {
        attBonus += 10;
        explications.push("L'adversaire est expos\xE9 : +10");
      }
    }
    if (options.contact) {
      if ((attributeAsBool(target, 'criDeGuerre') ||
          attributeAsBool(target, 'criDuPredateur')) &&
        ficheAttributeAsInt(attaquant, 'force', 10) <= ficheAttributeAsInt(target, 'force', 10) &&
        parseInt(attaquant.token.get("bar1_max")) <= parseInt(target.token.get("bar1_max"))) {
        attBonus -= 2;
        explications.push("Effray\xE9 => -2 en Attaque");
      }
    }
    let attrAgrippe = tokenAttribute(attaquant, 'agrippe');
    attrAgrippe.forEach(function(a) {
      let cibleAgrippee = persoOfIdName(a.get('current'), pageId);
      if (cibleAgrippee && cibleAgrippee.id == target.id &&
        !attributeAsBool(cibleAgrippee, 'agrippeParUnDemon')) {
        attBonus += 5;
        if (options.pasDeDmg)
          explications.push("Cible agripp\xE9e => +5 em Attaque");
        else
          explications.push("Cible agripp\xE9e => +5 att. et 1d6 DM");
        target.estAgrippee = true;
      }
    });
    if (reglesOptionelles.divers.val.interchangeable_attaque.val) {
      if (interchangeable(target.token, attaquant, pageId).result) {
        attBonus += 3;
        explications.push("Attaque en meute => +3 en Attaque et +2 en DEF");
      }
    }
    if (predicateAsBool(attaquant, 'combatEnPhalange')) {
      let tokensContact = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        layer: 'objects'
      });
      //On compte les tokens au contact de l'attaquant et du d\xE9fenseur et alli\xE9s de l'attaquant
      let allies = alliesParPerso[attaquant.charId];
      if (allies) {
        let alliesAuContact = 0;
        tokensContact.forEach(function(tok) {
          if (tok.id == attaquant.token.id) return;
          if (distanceCombat(target.token, tok, pageId) > 0) return;
          if (distanceCombat(attaquant.token, tok, pageId) > 0) return;
          let ci = tok.get('represents');
          if (ci === '') return;
          if (!isActive({
              token: tok,
              charId: ci
            })) return;
          if (allies.has(ci)) alliesAuContact++;
        });
        if (alliesAuContact > 0) {
          attBonus += alliesAuContact;
          explications.push("Combat en phalange => +" + alliesAuContact + " en Attaque");
        }
      }
    }
    if (options.attaqueEnMeute) {
      let attaqueParMeute = tokenAttribute(target, 'attaqueParMeute');
      if (attaqueParMeute.length > 0) {
        attaqueParMeute = attaqueParMeute[0];
        let attaqueParMeuteCur = attaqueParMeute.get('current');
        let contientAttaquant;
        let autreAttaquant;
        attaqueParMeuteCur.split(' ').forEach(function(mi) {
          if (mi == attaquant.token.id) {
            contientAttaquant = true;
            return;
          }
          autreAttaquant = true;
        });
        if (autreAttaquant) {
          attBonus += options.attaqueEnMeute;
          explications.push("Attaque en meute => +" + options.attaqueEnMeute + " pour toucher");
        }
        if (!contientAttaquant) {
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attaqueParMeute,
            current: attaqueParMeuteCur
          });
          if (attaqueParMeuteCur === '') attaqueParMeuteCur = attaquant.token.id;
          else attaqueParMeuteCur += ' ' + attaquant.token.id;
          attaqueParMeute.set('current', attaqueParMeuteCur);
        }
      } else {
        setTokenAttr(target, 'attaqueParMeute', attaquant.token.id, evt);
      }
    }
    let tm = stateCOF.tenebresMagiques;
    if (tm) {
      if (estDemon(attaquant)) {
        if (eclaireParFioleDeLumiere(attaquant, tm)) {
          explications.push("Aveugl\xE9 par la fiole de lumi\xE8re => -2 en Attaque");
          attBonus -= 2;
        }
      } else if (!eclaireParFioleDeLumiere(target, tm)) {
        let riposte;
        if (tm.attaques && tm.attaques[target.token.id]) {
          riposte = tm.attaques[target.token.id].some(function(cible) {
            return cible.token.id == attaquant.token.id;
          });
        }
        if (riposte) {
          explications.push("Riposte dans le noir => -2 en attaque et aux DMs");
          attBonus -= 2;
          target.attaqueDansLeNoir = 2;
        } else {
          explications.push("Attaque dans le noir => -5 en attaque et aux DMs");
          attBonus -= 5;
          target.attaqueDansLeNoir = 5;
        }

      }
    }
    if (predicateAsBool(attaquant, 'liberateurDeDorn') && estGeant(target)) {
      attBonus += 2;
      if (options.pasDeDmg) {
        explications.push("Lib\xE9rateur de Dorn => +2 en attaque");
      } else {
        explications.push("Lib\xE9rateur de Dorn => +2 en attaque et +2d6 DM");
        target.cibleLiberateurDeDorn = true;
      }
    }
    if (predicateAsBool(attaquant, 'liberateurDeKerserac') && (estGeant(target) || estInsecte(target) || estElfeNoir(target))) {
      attBonus += 2;
      if (options.pasDeDmg) {
        explications.push("Lib\xE9rateur de Kerserac => +2 en attaque");
      } else {
        explications.push("Lib\xE9rateur de Kerserac => +2 en attaque et +1d6 DM");
        target.cibleLiberateurDeKerserac = true;
      }
    }
    if (predicateAsBool(attaquant, 'liberateurDAnathazerin') && (estInsecte(target) || estElfeNoir(target))) {
      attBonus += 2;
      if (options.pasDeDmg) {
        explications.push("Lib\xE9rateur d'Anathazer\xEFn => +2 en attaque");
      } else {
        explications.push("Lib\xE9rateur d'Anathazer\xEFn => +2 en attaque et +2d6 DM");
        target.cibleLiberateurDAnathazerin = true;
      }
    }
    if (predicateAsBool(attaquant, 'tenacite')) {
      let bonus = attributeAsInt(target, 'attributDeCombat_tenaciteDe' + nomPerso(attaquant), 0);
      if (bonus > 0) {
        explications.push("T\xE9nacit\xE9 => +" + bonus + " en attaque");
        attBonus += bonus;
      }
    }
    let attrMeneurCible = tokenAttribute(target, 'meneurDHommesCible');
    if (attrMeneurCible.length > 0) {
      let meneurTokenId = attrMeneurCible[0].get('current');
      let meneurDHommes = persoOfId(meneurTokenId, meneurTokenId, pageId);
      if (meneurDHommes && alliesParPerso[meneurDHommes.charId] &&
        alliesParPerso[meneurDHommes.charId].has(attaquant.charId)) {
        attBonus += 2;
        if (!options.pasDeDmg) target.cibleMeneurDHommes = true;
        explications.push(nomPerso(meneurDHommes) + " a d\xE9sign\xE9 " + nomPerso(target) +
          " comme la cible des attaques du groupe : +2 attaque, +1d6 DM");
      }
    }
    let combattreLaCorruption =
      predicateAsInt(attaquant, 'combattreLaCorruption', 0, 1);
    if (combattreLaCorruption > 0 &&
      (predicateAsBool(target, 'corrompu') ||
        estDemon(target) ||
        estMortVivant(target))) {
      attBonus += combattreLaCorruption;
      target.combattreLaCorruption = combattreLaCorruption;
      explications.push("Combattre la corruption => +" + combattreLaCorruption + " attaque et DM");
    }
    return attBonus;
  }

  function diminueMalediction(lanceur, evt, attr) {
    let attrMalediction = attr || tokenAttribute(lanceur, 'malediction');
    if (attrMalediction.length > 0) {
      attrMalediction = attrMalediction[0];
      let nbMaudit = parseInt(attrMalediction.get('current'));
      if (isNaN(nbMaudit) || nbMaudit < 2) {
        evt.deletedAttributes = evt.deletedAttributes || [];
        evt.deletedAttributes.push(attrMalediction);
        attrMalediction.remove();
      } else {
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attrMalediction,
          current: nbMaudit
        });
        attrMalediction.set('current', nbMaudit - 1);
      }
    }
  }

  function attributesOfClass(perso, classeEffet) {
    let attrs = findObjs({
      _type: 'attribute',
      _characterid: perso.charId
    });
    let res = [];
    attrs.forEach(function(attr) {
      let attrName = attr.get('name');
      let ice = attrName.indexOf('ClasseEffet');
      if (ice < 1) return;
      if (attr.get('current') == classeEffet) {
        let baseAttrName = attrName.replace(/ClasseEffet/, '');
        let baseAttr = attrs.find(function(a) {
          return (a.get('name') == baseAttrName);
        });
        if (baseAttr === undefined) {
          error("On a un attribut " + attrName + ", mais pas d'attribut " + baseAttrName + " pour " + nomPerso(perso), classeEffet);
          attr.remove();
          return;
        }
        res.push({
          baseAttribute: baseAttr,
          classAttribute: attr
        });
      }
    });
    if (res.length === 0) {
      var ace = tokenAttribute(perso, classeEffet);
      if (ace.length > 0) {
        error(nomPerso(perso) + " a une classe d'effets " + classeEffet + " mais pas d'effet associ\xE9", ace);
        ace[0].remove();
      }
    }
    return res;
  }

  function depasseLimite(perso, nomAttr, msgImpossible, msg, evt, options) {
    if (options.depasseLimite) {
      options.mana = options.mana || 0;
      let step = options.depasseLimite;
      let cout = attributeAsInt(perso, 'depasse' + nomAttr, 0);
      cout += step;
      options.mana += cout;
      let depMana = depenseManaPossible(perso, options.mana, msg);
      if (!depMana) return true;
      setTokenAttr(perso, 'depasse' + nomAttr, cout, evt);
      return false;
    }
    sendPerso(perso, msgImpossible, options.secret);
    return true;
  }

  //Retourne true si il existe une limite qui emp\xEAche de lancer le sort
  //N'ajoute pas l'\xE9v\xE9nement \xE0 l'historique
  //explications est optionnel
  function limiteRessources(personnage, options, defResource, msg, evt, explications) {
    let depMana = {
      cout_null: true
    };
    if (options.magieEnArmureMana && personnage) {
      options.mana = options.mana || 0;
      let ma = malusArmure(personnage);
      let m = ma;
      if (m > 0) {
        let magieEnArmure = predicateAsInt(personnage, 'magieEnArmure', 0);
        let defa = defenseArmure(personnage);
        if (2 * magieEnArmure >= defa + ma) { //pas de malus
          m = 0;
        } else {
          if (magieEnArmure > 0 && predicateAsBool(personnage, 'magieEnArmureFacilitee')) {
            m -= magieEnArmure;
            if (m < 0) m = 1;
          }
        }
      }
      if (m > 0) {
        if (reglesOptionelles.mana.val.mana_totale.val) options.mana += m;
        //Le plus coh\xE9rent avec la mana totale consiste \xE0 diviser ce malus par 3,
        //arrondi au sup\xE9rieur
        else options.mana += Math.ceil(m / 3);
      }
    }
    if (options.mana) {
      if (personnage) {
        depMana = depenseManaPossible(personnage, options.mana, msg);
        if (!depMana) return true;
      } else {
        error("Impossible de savoir qui doit d\xE9penser de la mana", options);
        return true;
      }
    }
    let ressource = '';
    if (defResource !== undefined) ressource = defResource;
    let utilisations;
    if (options.limiteParJour) {
      if (!personnage) {
        error("Impossible de savoir \xE0 qui appliquer la limite journali\xE8re", options);
        return true;
      }
      if (options.limiteParJourRessource)
        ressource = "limiteParJour_" + options.limiteParJourRessource;
      else
        ressource = "limiteParJour_" + defResource;
      utilisations =
        attributeAsInt(personnage, ressource, options.limiteParJour);
      if (utilisations === 0) {
        if (depasseLimite(personnage, ressource, "ne peut plus faire cette action aujourd'hui", msg, evt, options)) return true;
        utilisations = 1;
      }
      setTokenAttr(personnage, ressource, utilisations - 1, evt);
      if (options.limiteParJourRessource) {
        let msgJour = nomPerso(personnage) + " ";
        if (utilisations < 2) msgJour += "ne pourra plus utiliser ";
        else {
          msgJour += "pourra encore utiliser ";
          if (utilisations == 2) msgJour += "une fois ";
          else msgJour += (utilisations - 1) + " fois ";
        }
        msgJour += options.limiteParJourRessource + " aujourd'hui.";
        if (explications) {
          stateCOF.afterDisplay = stateCOF.afterDisplay || [];
          stateCOF.afterDisplay.push({
            msg: msgJour,
            destinataire: personnage
          });
        } else sendPerso(personnage, msgJour, true);
      }
    }
    if (options.limiteParCombat) {
      if (personnage) {
        if (!stateCOF.combat) {
          sendPerso(personnage, "ne peut pas faire cette action en dehors des combats", options.secret);
          return true;
        }
        if (options.limiteParCombatRessource)
          ressource = "limiteParCombat_" + options.limiteParCombatRessource;
        else
          ressource = "limiteParCombat_" + defResource;
        utilisations =
          attributeAsInt(personnage, ressource, options.limiteParCombat);
        if (utilisations === 0) {
          let msgToSend = "ne peut plus faire cette action pour ce combat";
          sendPerso(personnage, msgToSend, options.secret);
          return true;
        }
        setTokenAttr(personnage, ressource, utilisations - 1, evt);
        if (options.limiteParCombatRessource) {
          let msgCombat = nomPerso(personnage) + " ";
          if (utilisations < 2) msgCombat += "ne pourra plus utiliser ";
          else {
            msgCombat += "pourra encore utiliser ";
            if (utilisations == 2) msgCombat += "une fois ";
            else msgCombat += (utilisations - 1) + " fois ";
          }
          msgCombat += options.limiteParCombatRessource + " durant ce combat.";
          if (explications) {
            stateCOF.afterDisplay = stateCOF.afterDisplay || [];
            stateCOF.afterDisplay.push({
              msg: msgCombat,
              destinataire: personnage
            });
          } else sendPerso(personnage, msgCombat, true);
        }
      } else {
        error("Impossible de savoir \xE0 qui appliquer la limite par combat", options);
        return true;
      }
    }
    if (options.limiteParTour) {
      if (personnage) {
        if (!stateCOF.combat) {
          sendPerso(personnage, "ne peut pas faire cette action en dehors des combats", options.secret);
          return true;
        }
        if (options.limiteParTourRessource)
          ressource = "limiteParTour_" + options.limiteParTourRessource;
        else
          ressource = "limiteParTour_" + defResource;
        utilisations = attributeAsInt(personnage, ressource, options.limiteParTour);
        if (utilisations === 0) {
          let msgToSend = "ne peut plus faire cette action pour ce tour";
          sendPerso(personnage, msgToSend, options.secret);
          return true;
        }
        setTokenAttr(personnage, ressource, utilisations - 1, evt);
        if (options.limiteParTourRessource) {
          let msgCombat = nomPerso(personnage) + " ";
          if (utilisations < 2) msgCombat += "ne pourra plus utiliser ";
          else {
            msgCombat += "pourra encore utiliser ";
            if (utilisations == 2) msgCombat += "une fois ";
            else msgCombat += (utilisations - 1) + " fois ";
          }
          msgCombat += options.limiteParTourRessource + " durant ce tour.";
          if (explications) {
            stateCOF.afterDisplay = stateCOF.afterDisplay || [];
            stateCOF.afterDisplay.push({
              msg: msgCombat,
              destinataire: personnage
            });
          } else sendPerso(personnage, msgCombat, options.secret);
        }
      } else {
        error("Impossible de savoir \xE0 qui appliquer la limite par tour", options);
        return true;
      }
    }
    if (options.tempsRecharge) {
      if (personnage) {
        if (attributeAsBool(personnage, options.tempsRecharge.effet)) {
          sendPerso(personnage, "ne peut pas encore faire cette action", options.secret);
          return true;
        }
        if (options.tempsRecharge.duree > 0) {
          setAttrDuree(personnage, options.tempsRecharge.effet, options.tempsRecharge.duree, evt);
        }
      } else {
        error("Impossible de savoir \xE0 qui s'applique le temps de recharge", options);
        return true;
      }
    }
    if (options.dose) {
      if (personnage) {
        let nomDose = options.dose.replace(/_/g, ' ');
        let doses = attributeAsInt(personnage, 'dose_' + options.dose, 0);
        if (doses === 0) {
          sendPerso(personnage, "n'a plus de " + nomDose, options.secret);
          return true;
        }
        setTokenAttr(personnage, 'dose_' + options.dose, doses - 1, evt);
      } else {
        error("Impossible de savoir qui doit d\xE9penser la dose", options);
        return true;
      }
    }
    if (options.limiteAttribut) {
      if (personnage) {
        let nomAttr = options.limiteAttribut.nom;
        let currentAttr = attributeAsInt(personnage, nomAttr, 0);
        if (currentAttr >= options.limiteAttribut.limite) {
          if (depasseLimite(personnage, nomAttr, options.limiteAttribut.message, msg, evt, options)) return true;
        }
        setTokenAttr(personnage, nomAttr, currentAttr + 1, evt);
      } else {
        error("Impossible de savoir \xE0 qui appliquer la limitation", options);
        return true;
      }
    }
    if (options.decrAttribute) {
      let attr = getObj('attribute', options.decrAttribute);
      if (attr === undefined) {
        error("Attribut introuvable", options.decrAttribute);
        return true;
      }
      let oldval = parseInt(attr.get('current'));
      if (isNaN(oldval) || oldval < 1) {
        let expliquer = sendChar;
        if (options.secret) expliquer = whisperChar;
        expliquer(attr.get('characterid'), "ne peut plus faire cela", true);
        return true;
      }
      evt.attributes = evt.attributes || [];
      evt.attributes.push({
        attribute: attr,
        current: oldval,
        max: attr.get('max')
      });
      attr.set('current', oldval - 1);
    }
    if (options.decrLimitePredicatParTour) {
      let pred = options.decrLimitePredicatParTour;
      if (personnage) {
        let test = testLimiteUtilisationsCapa(personnage, pred, 'tour',
          "ne peut plus utiliser " + pred + " ce tour",
          "Action impossible, pas de pr\xE9dicat " + pred);
        if (test === undefined) return true;
        utiliseCapacite(personnage, test, evt);
      } else {
        error("Impossible de savoir \xE0 qui appliquer la limitation du pr\xE9dicat " + pred, options);
        return true;
      }
    }
    if (personnage) depenseMana(personnage, depMana, msg, evt);
    return false;
  }

  //asynchrone
  //callback(resultat, crit, roll1, roll2):
  // resultat peut \xEAtre 0, 1 ou 2 : 0 = match null, 1 le perso 1 gagne, 2 le perso 2 gagne.
  // crit peut \xEAtre 1 si un des deux perso a fait une r\xE9ussite critique et pas l'autre, -1 si un des personnage a fait un \xE9chec critique et pas l'autre, et 0 sinon
  function testOppose(rollId, perso1, carac1, options1, perso2, carac2, options2, explications, evt, callback) {
    if (carac2 === undefined) carac2 = carac1;
    let nom1 = nomPerso(perso1);
    let nom2 = nomPerso(perso2);
    jetCaracteristique(perso1, carac1, options1, rollId + "_roll1", evt, function(rt1, expl1) {
      jetCaracteristique(perso2, carac2, options2, rollId + "_roll2", evt, function(rt2, expl2) {
        let reussite;
        let crit = 0;
        if (rt1.total > rt2.total) reussite = 1;
        else if (rt2.total > rt1.total) reussite = 2;
        else reussite = 0;
        if (rt1.echecCritique) {
          if (!rt2.echecCritique) {
            reussite = 2;
            crit = -1;
          }
        } else if (rt2.echecCritique) {
          reussite = 1;
          crit = -1;
        } else if (rt1.critique) {
          if (!rt2.critique) {
            reussite = 1;
            crit = 1;
          }
        } else if (rt2.critique) {
          reussite = 2;
          crit = 1;
        }
        switch (reussite) {
          case 1:
            diminueMalediction(perso2, evt);
            break;
          case 2:
            diminueMalediction(perso1, evt);
            break;
        }
        let texte1 = "Jet " + deCarac(carac1) + " de " + nom1 + " : " + rt1.texte;
        if (reussite == 2) {
          if ((carac1 == 'FOR' || carac1 == 'DEX' || carac1 == 'CON') &&
            attributeAsBool(perso1, 'runeForgesort_\xE9nergie') &&
            attributeAsInt(perso1, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0) {
            texte1 += "<br/>" + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + rollId + "_roll1", "Rune d'\xE9nergie");
          }
          if (!rt1.echecCritique && !rt2.critique) {
            let pcPerso1 = pointsDeChance(perso1);
            if (pcPerso1 > 0)
              texte1 += "<br/>" + boutonSimple("!cof-bouton-chance " +
                evt.id + " " + rollId + "_roll1", "Chance") + " (reste " + pcPerso1 + " PC)";
            if (stateCOF.combat && capaciteDisponible(perso1, 'prouesse', 'tour') &&
              (carac1 == 'FOR' || carac1 == 'DEX')) {
              texte1 += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + rollId + "_roll1", "Prouesse");
            }
            if (predicateAsBool(perso1, 'tourDeForce') && carac1 == 'FOR') {
              texte1 += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + rollId + "_roll1", "Tour de force");
            }
            let pacteSanglant = predicateAsInt(perso1, 'pacteSanglant', 0);
            if (pacteSanglant >= 3) {
              texte1 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + rollId + "_roll1", "Pacte sanglant (+3)");
              if (pacteSanglant >= 5) {
                texte1 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + rollId + "_roll1", "Pacte sanglant (+5)");
              }
            }
          }
        }
        explications.push(texte1);
        expl1.forEach(function(m) {
          explications.push(m);
        });
        let texte2 = "Jet " + deCarac(carac2) + " de " + nom2 + " : " + rt2.texte;
        if (reussite == 1) {
          if ((carac2 == 'FOR' || carac2 == 'DEX' || carac2 == 'CON') &&
            attributeAsBool(perso2, 'runeForgesort_\xE9nergie') &&
            attributeAsInt(perso2, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0) {
            texte2 += "<br/>" + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + rollId + "_roll2", "Rune d'\xE9nergie");
          }
          if (!rt2.echecCritique && !rt1.critique) {
            let pcPerso2 = pointsDeChance(perso2);
            if (pcPerso2 > 0)
              texte2 += "<br/>" + boutonSimple("!cof-bouton-chance " +
                evt.id + " " + rollId + "_roll2", "Chance") + " (reste " + pcPerso2 + " PC)";
            if (stateCOF.combat && capaciteDisponible(perso2, 'prouesse', 'tour') &&
              (carac2 == 'FOR' || carac2 == 'DEX')) {
              texte2 += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + rollId + "_roll2", "Prouesse");
            }
            if (predicateAsBool(perso2, 'tourDeForce') && carac2 == 'FOR') {
              texte2 += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + rollId + "_roll2", "Tour de force");
            }
            let pacteSanglant = predicateAsInt(perso2, 'pacteSanglant', 0);
            if (pacteSanglant >= 3) {
              texte2 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + rollId + "_roll2", "Pacte sanglant (+3)");
              if (pacteSanglant >= 5) {
                texte2 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + rollId + "_roll2", "Pacte sanglant (+5)");
              }
            }
          }
        }
        explications.push(texte2);
        expl2.forEach(function(m) {
          explications.push(m);
        });
        callback(reussite, crit, rt1.roll, rt2.roll);
      }); //Fin du jet du deuxi\xE8me perso
    }); //Fin du jet du premier perso
  }

  function bonusPlusViteQueSonOmbre(perso, arme) {
    let p = predicateAsBool(perso, 'plusViteQueSonOmbre');
    if (!p) return 0;
    // L'arme doit \xEAtre charg\xE9e
    if (arme.charge && attributeAsInt(perso, 'charge_' + arme.label, 0) === 0)
      return 0;
    if (p === true) {
      if (arme.poudre) return 10;
      return 0;
    }
    let bonus = 10;
    let type = 'poudre';
    let i = p.search(/\d/);
    if (i > -1) {
      bonus = toInt(p.substring(i), 10);
      p = p.substring(0, i);
    }
    if (p !== '') type = p;
    if (arme[type]) return bonus;
    return 0;
  }

  // prend en compte l'unit\xE9 de mesure utilis\xE9e sur la page
  function ajouteUneLumiere(perso, nomLumiere, radius, dimRadius, evt) {
    radius = scaleDistance(perso, radius);
    if (dimRadius !== '') dimRadius = scaleDistance(perso, dimRadius);
    const ct = perso.token;
    const pageId = ct.get('pageid');
    const page = getObj('page', pageId);
    const udl = page && page.get('dynamic_lighting_enabled');
    let brightLight = radius;
    if (udl) {
      if (isNaN(brightLight) || brightLight < 0) {
        error("Lumi\xE8re avec un rayon n\xE9gatif", radius);
        return;
      }
    }
    let attrName = 'lumiere';
    if (ct.get('bar1_link') === '') attrName += "_" + ct.get('name');
    if (ct.get('bar1_max')) {
      let lumiereSurPerso;
      //Cas particulier o\xF9 le personnage est un vrai personnage qui ne fait pas de lumi\xE8re
      if (!udl && !ct.get('light_radius')) {
        lumiereSurPerso = true;
        setToken(ct, 'light_radius', radius, evt);
        if (dimRadius !== '') setToken(ct, 'light_dimradius', dimRadius, evt);
        setToken(ct, 'light_otherplayers', true, evt);
      } else if (udl && !ct.get('emits_bright_light') && !ct.get('emits_low_light')) {
        lumiereSurPerso = true;
        if (dimRadius !== '') {
          if (dimRadius < 0) dimRadius = 0;
          if (dimRadius < brightLight) {
            setToken(ct, 'emits_low_light', true, evt);
            setToken(ct, 'low_light_distance', brightLight, evt);
            brightLight = dimRadius;
          }
        }
        if (brightLight > 0) {
          setToken(ct, 'emits_bright_light', true, evt);
          setToken(ct, 'bright_light_distance', brightLight, evt);
        }
      }
      if (lumiereSurPerso) {
        let attr1 = createObj('attribute', {
          characterid: perso.charId,
          name: attrName,
          current: nomLumiere,
          max: 'surToken'
        });
        evt.attributes = [{
          attribute: attr1,
        }];
        return;
      }
    }
    let tokLumiere = createObj('graphic', {
      _pageid: pageId,
      imgsrc: "https://s3.amazonaws.com/files.d20.io/images/3233035/xHOXBXoAgOHCHs8omiFAYg/thumb.png?1393406116",
      left: ct.get('left'),
      top: ct.get('top'),
      width: 70,
      height: 70,
      layer: 'walls',
      name: nomLumiere,
    });
    if (tokLumiere === undefined) {
      error("Probl\xE8me lors de la cr\xE9ation du token de lumi\xE8re", perso);
      return;
    }
    evt.tokens = [tokLumiere];
    if (udl) {
      if (dimRadius !== '') {
        if (dimRadius < 0) dimRadius = 0;
        if (dimRadius < brightLight) {
          setToken(tokLumiere, 'emits_low_light', true, evt);
          setToken(tokLumiere, 'low_light_distance', brightLight, evt);
          brightLight = dimRadius;
        }
      }
      if (brightLight > 0) {
        setToken(tokLumiere, 'emits_bright_light', true, evt);
        setToken(tokLumiere, 'bright_light_distance', brightLight, evt);
      }
    } else {
      setToken(tokLumiere, 'light_radius', radius, evt);
      setToken(tokLumiere, 'light_dimradius', dimRadius, evt);
      setToken(tokLumiere, 'light_otherplayers', true, evt);
    }
    if (ct.get('bar1_max')) { //Lumi\xE8re li\xE9e \xE0 un token
      let attr = createObj('attribute', {
        characterid: perso.charId,
        name: attrName,
        current: nomLumiere,
        max: tokLumiere.id
      });
      evt.attributes = [{
        attribute: attr,
      }];
    } else { //cible temporaire, \xE0 effacer
      ct.remove();
    }
  }

  //renvoie le nom de l'arme si l'arme est d\xE9j\xE0 tenue en main
  // options.seulementDroite permet de ne rengainer que l'arme droite
  // options.deuxMains permet de prendre une arme \xE0 2 mains
  function degainerArme(perso, labelArme, evt, options) {
    let pageId = perso.pageId;
    if (pageId === undefined) {
      pageId = perso.token.get('pageid');
      perso.pageId = pageId;
    }
    options = options || {};
    perso.armesEnMain = undefined; //il faut enlever le cache sur l'arme en main
    perso.arme = undefined;
    let nouvelleArme;
    if (options.weaponStats) {
      nouvelleArme = options.weaponStats;
      labelArme = nouvelleArme.label;
    } else if (labelArme && labelArme !== '')
      nouvelleArme = getWeaponStats(perso, labelArme);
    if (nouvelleArme && nouvelleArme.armeGauche) options.gauche = true;
    let nouvelleArmeGauche;
    let labelArmeGauche; //d\xE9finie seulement si on d\xE9gaine l'arme gauche
    // et toujours diff\xE9rent de labelArme
    if (options.armeGaucheLabel) {
      if (options.armeGaucheLabel == labelArme) {
        sendPerso("ne peut d\xE9gainer la m\xEAme arme dans les deux mains");
        return;
      }
      if (options.gauche) {
        nouvelleArmeGauche = nouvelleArme;
        labelArmeGauche = labelArme;
        labelArme = options.armeGaucheLabel;
        options.gauche = false; //vrai seulement si on ne sort que l'arme gauche
        nouvelleArme = getWeaponStats(perso, options.armeGaucheLabel);
        if (nouvelleArme && nouvelleArme.armeGauche) {
          sendPerso("ne peut d\xE9gainer 2 armes gauches \xE0 la fois");
          return;
        }
      } else {
        labelArmeGauche = options.armeGaucheLabel;
        nouvelleArmeGauche = getWeaponStats(perso, labelArmeGauche);
      }
    }
    //D'abord, on rengaine l'arme en main, si besoin.
    let armeActuelle = tokenAttribute(perso, 'armeEnMain');
    let labelArmeActuelle;
    let labelArmeActuelleGauche = '';
    let ancienneArme;
    let message = nomPerso(perso) + " ";
    let envoieMessage = function(m) {
      if (options.messages) message += m;
      else sendPerso(perso, m, options.secret);
    };
    let changementDePrise;
    if (armeActuelle.length > 0) {
      armeActuelle = armeActuelle[0];
      if (options.gauche) labelArmeActuelleGauche = armeActuelle.get('max');
      else {
        labelArmeActuelle = armeActuelle.get('current');
        labelArmeActuelleGauche = armeActuelle.get('max');
      }
      let rienAFaire;
      if (options.deuxMains) {
        if (labelArmeActuelle == labelArme) {
          if (labelArmeActuelleGauche == labelArme) rienAFaire = true;
          else {
            changementDePrise = true;
            message += "prend son arme \xE0 deux mains";
            armeActuelle.set('max', labelArme);
          }
        }
      } else if (options.gauche) {
        rienAFaire = labelArmeActuelleGauche == labelArmeGauche;
      } else {
        if (labelArmeActuelle == labelArme) {
          if (labelArmeActuelleGauche == labelArme) {
            changementDePrise = true;
            message += "prend son arme \xE0 une main";
            if (!labelArmeGauche) {
              armeActuelle.set('max', '');
            }
          } else {
            if (labelArmeGauche) //on d\xE9gaine 2 armes
              rienAFaire = labelArmeActuelleGauche == labelArmeGauche;
            else rienAFaire = true;
          }
        }
      }
      if (rienAFaire) {
        //Pas besoin de d\xE9gainer.
        if (options.weaponStats) return options.weaponStats.name;
        if (nouvelleArme) return nouvelleArme.name;
        return;
      }
      //On d\xE9gaine une nouvelle arme, il faut rengainer l'ancienne
      if (labelArmeActuelle) { //dans ce cas, pas options.gauche
        ancienneArme = getWeaponStats(perso, labelArmeActuelle);
        if (ancienneArme === undefined) {
          error("Impossible de trouver l'arme en main", labelArmeActuelle);
          return;
        }
        if (!changementDePrise) {
          if (attributeAsBool(perso, 'forgeron(' + labelArmeActuelle + ')')) {
            finDEffetDeNom(perso, 'forgeron(' + labelArmeActuelle + ')', evt);
          }
          envoieMessage("rengaine " + ancienneArme.name + " et ");
          if (bonusPlusViteQueSonOmbre(perso, ancienneArme))
            updateNextInit(perso);
          if (ancienneArme.eclaire) {
            eteindreUneLumiere(perso, pageId, undefined, 'eclaire_' + labelArmeActuelle, evt);
          }
        }
      }
      if (
        (!nouvelleArme || nouvelleArme.deuxMains || options.deuxMains ||
          options.gauche ||
          (nouvelleArmeGauche && labelArmeGauche != labelArmeActuelleGauche)) &&
        labelArmeActuelleGauche
      ) {
        let ancienneArmeGauche = getWeaponStats(perso, labelArmeActuelleGauche);
        if (ancienneArmeGauche === undefined) {
          error("Impossible de trouver l'arme en main gauche", labelArmeActuelleGauche);
          return;
        }
        if (attributeAsBool(perso, 'forgeron(' + labelArmeActuelleGauche + ')')) {
          finDEffetDeNom(perso, 'forgeron(' + labelArmeActuelleGauche + ')', evt);
        }
        if (options.messages) {
          if (ancienneArme) message += ancienneArmeGauche.name + ", et ";
          else message += "rengaine " + ancienneArmeGauche.name + " et ";
        } else sendPerso(perso, "rengaine " + ancienneArmeGauche.name, options.secret);
        if (ancienneArmeGauche.eclaire) {
          eteindreUneLumiere(perso, pageId, undefined, 'eclaire_' + labelArmeActuelleGauche, evt);
        }
      }
    } else armeActuelle = undefined;
    const estMook = perso.token && perso.token.get('bar1_link') === '';
    //Puis on d\xE9gaine
    //mais on v\xE9rifie que l'arme existe, sinon c'est juste un ordre de rengainer
    if (nouvelleArme === undefined) {
      if (armeActuelle) {
        if (options.seulementDroite && labelArmeActuelleGauche) {
          setTokenAttr(perso, 'armeEnMain', '', evt);
        } else if (options.gauche && labelArmeActuelle) {
          setTokenAttr(perso, 'armeEnMain', labelArmeActuelle, evt, {
            maxVal: ''
          });
        } else {
          removeTokenAttr(perso, 'armeEnMain', evt);
        }
      }
      if (!estMook) stateCOF.predicats[perso.charId] = undefined;
      perso.predicates = undefined;
      return;
    }
    if (nouvelleArmeGauche) {
      if (ficheAttributeAsInt(perso, 'defbouclieron', 0)) {
        sendPerso(perso, "enl\xE8ve son bouclier", options.secret);
        setFicheAttr(perso, 'defbouclieron', 0, evt, {
          default: 0
        });
      }
    }
    if (nouvelleArme.deuxMains || options.deuxMains) {
      if (ficheAttributeAsInt(perso, 'defbouclieron', 0)) {
        sendPerso(perso, "enl\xE8ve son bouclier", options.secret);
        setFicheAttr(perso, 'defbouclieron', 0, evt, {
          default: 0
        });
      }
    } else if (ancienneArme && (ancienneArme.deuxMains || options.gauche || changementDePrise)) {
      if (ficheAttributeAsBool(perso, 'defbouclier', false) &&
        !ficheAttributeAsInt(perso, 'defbouclieron', 0)) {
        sendPerso(perso, "remet son bouclier", options.secret);
        setFicheAttr(perso, 'defbouclieron', 1, evt);
      }
    }
    if (armeActuelle) { //On avait une arme en main
      evt.attributes = evt.attributes || [];
      let evtAttr = {
        attribute: armeActuelle,
        max: labelArmeActuelleGauche,
      };
      if (options.gauche) {
        evtAttr.current = armeActuelle.get('current');
        evt.attributes.push(evtAttr);
        armeActuelle.set('max', labelArme);
      } else {
        evtAttr.current = labelArmeActuelle;
        evt.attributes.push(evtAttr);
        armeActuelle.set('current', labelArme);
        if (labelArmeGauche) armeActuelle.set('max', labelArmeGauche);
        else if (nouvelleArme.deuxMains || options.deuxMains)
          armeActuelle.set('max', labelArme);
        else if (changementDePrise || (ancienneArme && ancienneArme.deuxMains))
          armeActuelle.set('max', '');
      }
    } else { //On n'avait pas d'arme en main
      if (stateCOF.combat && nouvelleArme && nouvelleArme.portee === 0 &&
        predicateAsBool(perso, 'frappeDuVide') &&
        !attributeAsBool(perso, 'limiteParCombat_dejaFrappeContact')) {
        setTokenAttr(perso, 'limiteParTour_frappeDuVidePossible', true, evt);
      }
      if (options.gauche) {
        setTokenAttr(perso, 'armeEnMain', '', evt, {
          maxVal: labelArme
        });
      } else {
        let opt = {};
        if (labelArmeGauche) opt.maxVal = labelArmeGauche;
        else if (options.deuxMains || nouvelleArme.deuxMains)
          opt.maxVal = labelArme;
        setTokenAttr(perso, 'armeEnMain', labelArme, evt, opt);
      }
    }
    if (options.messages) {
      if (changementDePrise) {
        if (nouvelleArmeGauche) message += ", et d\xE9gaine " + nouvelleArmeGauche.name;
      } else {
        message += "d\xE9gaine " + nouvelleArme.name;
        if (nouvelleArmeGauche) message += " et " + nouvelleArmeGauche.name;
      }
      options.messages.push(message);
    } else {
      if (changementDePrise) {
        if (nouvelleArmeGauche) message += ", et d\xE9gaine " + nouvelleArmeGauche.name;
      } else {
        message = "d\xE9gaine " + nouvelleArme.name;
        if (nouvelleArmeGauche) message += " et " + nouvelleArmeGauche.name;
      }
      sendPerso(perso, message, options.secret);
    }
    if (nouvelleArme && !changementDePrise) {
      let radius = nouvelleArme.eclaire;
      if (radius && radius > 0) {
        let dimRadius = nouvelleArme.eclaireFaible;
        if (dimRadius === undefined || dimRadius >= radius) dimRadius = '';
        ajouteUneLumiere(perso, 'eclaire_' + labelArme, radius, dimRadius, evt);
      }
      if (bonusPlusViteQueSonOmbre(perso, nouvelleArme)) updateNextInit(perso);
    }
    if (nouvelleArmeGauche) {
      let radius = nouvelleArmeGauche.eclaire;
      if (radius && radius > 0) {
        let dimRadius = nouvelleArmeGauche.eclaireFaible;
        if (dimRadius === undefined || dimRadius >= radius) dimRadius = '';
        ajouteUneLumiere(perso, 'eclaire_' + labelArmeGauche, radius, dimRadius, evt);
      }
    }
    if (!estMook) stateCOF.predicats[perso.charId] = undefined;
    perso.predicates = undefined;
  }

  function nePeutPlusPrendreDM(cible, options) {
    if (!getState(cible, 'mort')) return false;
    if (!options.type) return false;
    let regenPossible =
      predicatesNamed(cible, 'vitaliteSurnaturelle').some(function(a) {
        let indexType = a.indexOf('/');
        if (indexType < 0 || indexType == a.length) return false;
        a = a.substring(indexType + 1);
        let typeVitalite = a.split(',');
        let typeMatch = typeVitalite.some(function(tv) {
          return tv == options.type;
        });
        if (!typeMatch) return false;
        let pvmax = parseInt(cible.token.get("bar1_max"));
        if (isNaN(pvmax)) return false;
        let dmSuivis = attributeAsInt(cible, 'DMSuivis' + options.type, 0);
        return dmSuivis < pvmax;
      });
    return !regenPossible;
  }
  //On enl\xE8ve les doublons de cibles qui partagent leurs PVs;
  function enleveDoublonsPartagePV(cibles) {
    let ciblesAvecPVsPartages = new Set();
    //va aussi peupler le champ name des cibles
    cibles = cibles.filter(function(target, index) {
      if (target.name === undefined) {
        let targetChar = getObj('character', target.charId);
        if (targetChar === undefined) return false;
        target.name = targetChar.get('name');
      }
      if (ciblesAvecPVsPartages.has(target.name)) return false;
      let ciblePartagee = predicatesNamed(target, 'PVPartagesAvec');
      if (ciblePartagee.length > 0) {
        if (predicateAsBool(target, 'familier') || predicateAsBool(target, 'guetteur')) {
          //c'est le personnage qui a un familier, on le garde en cible prioritaire
          ciblePartagee.forEach(function(cp) {
            ciblesAvecPVsPartages.add(cp);
          });
        } else if (persoEstPNJ(target)) {
          //cible la moins prioritaire, on l'enl\xE8ve si on trouve un autre repr\xE9sentant
          let representantPresent = cibles.find(function(target2, index2) {
            if (index2 <= index) return false; //d\xE9j\xE0 trait\xE9
            if (target2.name === undefined) {
              let target2Char = getObj('character', target2.charId);
              if (target2Char === undefined) return false;
              target2.name = target2Char.get('name');
            }
            return ciblePartagee.find(function(cp) {
              return cp == target2.name;
            });
          });
          if (representantPresent) return false;
        } else {
          //N'a pas de familier mais n'est pas un PNJ
          //On cherche si il existe un autre perso plus prioritaire.
          let representantFamilier = cibles.find(function(target2, index2) {
            if (index2 < index) return false; //d\xE9j\xE0 trait\xE9
            if (target2.name === undefined) {
              let target2Char = getObj('character', target2.charId);
              if (target2Char === undefined) return false;
              target2.name = target2Char.get('name');
            }
            let estPartagee = ciblePartagee.find(function(cn) {
              return cn == target2.name;
            });
            if (!estPartagee) return false;
            return predicateAsBool(target2, 'familier') ||
              predicateAsBool(target2, 'guetteur');
          });
          if (representantFamilier) return false;
          ciblePartagee.forEach(function(attr) {
            ciblesAvecPVsPartages.add(attr.get('current'));
          });
        }
      }
      return true;
    });
    return cibles;
  }

  //targetToken est soit un token, soit une structure avec un champs cibles qui contient toutes les cibles
  function attack(playerName, playerId, attaquant, targetToken, weaponStats, options) {
    // Attacker and target infos
    let attackingToken = attaquant.token;
    let attackingCharId = attaquant.charId;
    let tokenOrigine = attackingToken;
    if (options.origineDeLAttaque)
      tokenOrigine = options.origineDeLAttaque.token;
    let attacker = getObj("character", attackingCharId);
    if (attacker === undefined) {
      error("Unexpected undefined 1", attacker);
      return;
    }
    attaquant.name = attaquant.name || attacker.get("name");
    let pageId = attackingToken.get('pageid');
    let weaponName = options.nom || weaponStats.name;
    //Options automatically set by some attributes
    if (attributeAsBool(attaquant, 'paralysieRoublard')) {
      if (attributeAsBool(attaquant, 'enrage')) {
        sendPerso(attaquant, "est trop enrag\xE9 pour sentir la douleur");
      } else if (predicateAsBool(attaquant, 'proprioception')) {
        sendPerso(attaquant, "est immunis\xE9 \xE0 la douleur");
      } else {
        sendPerso(attaquant, "ne peut pas attaquer car il est paralys\xE9 de douleur");
        attackCallback(options);
        return;
      }
    }
    let deFauchage = predicateAsInt(attaquant, 'fauchage', 0, 15);
    if (!options.redo && deFauchage > 0) {
      let tailleFauchage = predicateAsInt(attaquant, 'tailleFauchage', 0);
      if (tailleFauchage < 1)
        tailleFauchage = taillePersonnage(attaquant, 4);
      let seuilFauchage = 10 + modCarac(attaquant, 'force');
      options.etats = options.etats || [];
      options.etats.push({
        etat: 'renverse',
        condition: {
          type: 'deAttaque',
          seuil: deFauchage
        },
        save: {
          carac: 'FOR',
          carac2: 'DEX',
          seuil: seuilFauchage,
          fauchage: tailleFauchage
        }
      });
    }
    if (options.toucher !== undefined) {
      weaponStats.attSkill = options.toucher;
      weaponStats.attSkillDiv = 0;
    }
    if (options.crit !== undefined) {
      weaponStats.crit = options.crit;
    }
    if (options.dm) {
      weaponStats.attNbDices = options.dm.nbDe;
      weaponStats.attDice = options.dm.dice;
      weaponStats.attDMBonusCommun = options.dm.bonus;
    } else if (weaponStats.batarde && weaponStats.deuxMains) {
      let dm = parseDice(weaponStats.batarde, 'd\xE9g\xE2ts');
      if (dm) {
        weaponStats.attNbDices = dm.nbDe;
        weaponStats.attDice = dm.dice;
      }
    }
    if (options.portee !== undefined) {
      weaponStats.portee = options.portee;
    }
    if (options.divisePortee) {
      weaponStats.portee /= options.divisePortee;
    }
    if (options.modifiePortee) {
      weaponStats.portee += options.modifiePortee;
    }
    if (weaponStats.epieu) {
      options.epieu = true;
    }
    weaponStats.attSkillDiv = parseInt(weaponStats.attSkillDiv);
    weaponStats.attNbDices = parseInt(weaponStats.attNbDices);
    weaponStats.attDice = parseInt(weaponStats.attDice);
    options.d6 = 'd6';
    if (predicateAsBool(attaquant, 'tropPetit') && !attributeAsBool(attaquant, 'grandeTaille')) {
      options.d6 = 'd4';
      if (weaponStats.divers && weaponStats.divers.includes('d3')) {
        weaponStats.attDice = 3;
      }
    }
    weaponStats.attDMBonusCommun = parseInt(weaponStats.attDMBonusCommun);
    weaponStats.crit = parseInt(weaponStats.crit);
    let portee = weaponStats.portee;
    if (options.tirDouble && options.tirDouble.label) {
      let stats2 = getWeaponStats(attaquant, options.tirDouble.label);
      if (stats2 === undefined) {
        error("Pas d'arme de label " + options.tirDouble.label + " pour le tir double", attaquant);
        attackCallback(options);
        return;
      }
      let tdSkillDiv = parseInt(stats2.attSkillDiv);
      if (!isNaN(tdSkillDiv) && tdSkillDiv < weaponStats.attSkillDiv)
        weaponStats.attSkillDiv = tdSkillDiv;
      stats2.attDMBonusCommun = parseInt(stats2.attDMBonusCommun);
      stats2.attNbDices = parseInt(stats2.attNbDices);
      stats2.attDice = parseInt(stats2.attDice);
      if (stats2.divers && stats2.divers.includes('d3')) stats2.attDice = 3;
      options.tirDouble.stats = stats2;
    }
    //Pour les explosions, la port\xE9e est 0 mais avec un disque
    if (options.explosion) {
      if (options.aoe === undefined) {
        options.aoe = {
          type: 'disque',
          rayon: portee
        };
      } else if (options.aoe.type != 'disque') {
        error("Option explosion ignor\xE9e, car l'attaque est une aoe qui n'est pas un disque", options);
      }
    }
    if (portee > 0) {
      options.distance = true;
      if (attributeAsBool(attaquant, 'rageDuBerserk')) {
        sendPerso(attaquant, "est en rage du berserk, il ne veut attaquer qu'au contact");
        attackCallback(options);
        return;
      }
      if (options.seulementContact) {
        sendPerso(attaquant, "ne peut utiliser cette attaque qu'au contact");
        attackCallback(options);
        return;
      }
      if (options.puissantPortee || options.tempeteDeManaPortee) {
        portee = portee * 2;
        weaponStats.portee = portee;
      }
    } else {
      if (options.ricochets) {
        sendPerso(attaquant, "ne peut pas faire de ricochets au contact.");
        attackCallback(options);
        return;
      }
      options.contact = true;
    }
    //Ce qui peut emp\xEAcher l'attaque quelles que soient les cibles
    if (options.avecd12 && ((estAffaibli(attaquant) && !predicateAsBool(attaquant, 'insensibleAffaibli')) || getState(attaquant, 'immobilise'))) {
      sendPerso(attaquant, "ne peut pas utiliser cette capacit\xE9 quand il est affaibli.");
      attackCallback(options);
      return;
    }
    if (options.forceMinimum &&
      caracCourante(attaquant, 'force') < options.forceMinimum) {
      sendPerso("n'est pas assez fort pour utiliser cette attaque (force minimum " + options.forceMinimum + ")");
      attackCallback(options);
      return;
    }
    if ((options.sortilege || options.frappeDesArcanes) && attributeAsBool(attaquant, 'frappeDesArcanes')) {
      sendPerso("ne peut pas encore lancer de sorts");
      attackCallback(options);
      return;
    }
    //Pour l'option grenaille implicite, il faut v\xE9rifier que toutes les charge de l'arme sont des charges de grenaille
    let chargesArme = [];
    let attackLabel = weaponStats.label;
    if (attackLabel) {
      chargesArme = findObjs({
        _type: 'attribute',
        _characterid: attackingCharId,
        name: 'charge_' + attackLabel
      });
      if (!options.grenaille && chargesArme.length > 0) {
        let chargesGrenaille = findObjs({
          _type: 'attribute',
          _characterid: attackingCharId,
          name: 'chargeGrenaille_' + attackLabel
        });
        if (chargesGrenaille.length > 0) {
          let chargesTotales = parseInt(chargesArme[0].get('current'));
          if (!isNaN(chargesTotales)) {
            let grenailles = parseInt(chargesGrenaille[0].get('current'));
            if (!isNaN(grenailles) && grenailles >= chargesTotales)
              options.grenaille = true;
          }
        }
      }
    }
    if (options.grenaille) {
      portee = portee / 10;
      options.aoe = options.aoe || {
        type: 'cone',
        angle: 90
      };
      weaponStats.attDice -= 2;
      weaponStats.attDMBonusCommun = Math.ceil(weaponStats.attDMBonusCommun / 2);
      if (weaponStats.attDice < 0) weaponStats.attDice = 0;
      if (options.tirDouble && options.tirDouble.stats) {
        options.tirDouble.stats.attDice -= 2;
        if (options.tirDouble.stats.attDice < 0) options.tirDouble.stats.attDice = 0;
      }
      options.auto = true;
      let effet = findObjs({
        _type: 'custfx',
        name: 'grenaille ' + portee
      });
      if (effet.length === 0) {
        effet = createObj('custfx', {
          name: 'grenaille ' + portee,
          definition: {
            "angle": -1,
            "angleRandom": 45,
            "duration": 8,
            "emissionRate": 40,
            "endColour": [130, 130, 130, 0],
            "endColourRandom": [10, 10, 10, 0],
            "lifeSpan": portee * 5,
            "lifeSpanRandom": portee / 2,
            "maxParticles": 200,
            "size": 10,
            "sizeRandom": 3,
            "speed": 12,
            "speedRandom": 3,
            "startColour": [25, 25, 25, 1],
            "startColourRandom": [7, 7, 7, 0.5]
          }
        });
      } else effet = effet[0];
      options.fx = options.fx || effet.id;
    }
    //D\xE9termination de la (ou des) cible(s)
    let nomCiblePrincipale; //Utilise pour le cas mono-cible
    let cibles = [];
    if (options.redo) { //Dans ce cas les cibles sont pr\xE9cis\xE9es dans targetToken
      cibles = targetToken;
      if (cibles.length === 0) {
        error("Attaque sans cible", targetToken);
        attackCallback(options);
        return;
      } else if (cibles.length == 1) targetToken = cibles[0].token;
      nomCiblePrincipale = nomPerso(cibles[0]);
    } else {
      let murs;
      let pc;
      let page;
      nomCiblePrincipale = targetToken.get('name');
      if (options.aoe) {
        //cas de la boule de feu qui fait un \xE9chec critique : on d\xE9place la cible si elle est artificielle
        if (!options.redo && options.demiAuto &&
          (!options.triche || options.triche == 'echecCritique') &&
          targetToken.get('bar1_max') == 0) { // jshint ignore:line
          let dice = 20;
          if (options.avecd12 ||
            (estAffaibli(attaquant) && !predicateAsBool(attaquant, 'insensibleAffaibli')) ||
            getState(attaquant, 'immobilise') ||
            attributeAsBool(attaquant, 'mortMaisNAbandonnePas') ||
            attributeAsInt(attaquant, 'niveauEbriete', 0) > 0
          ) {
            dice = 12;
          }
          if (randomInteger(dice) == 1 ||
            (options.triche && options.triche == 'echecCritique')) {
            options.triche = 'echecCritique';
            let left = targetToken.get('left');
            let top = targetToken.get('top');
            pc = {
              x: left,
              y: top,
            };
            let angle = Math.random() * 2 * Math.PI;
            let distance = Math.random() * reglesOptionelles.divers.val.echec_critique_boule_de_feu.val * PIX_PER_UNIT / computeScale(pageId);
            pc.x = Math.round(left + Math.cos(angle) * distance);
            pc.y = Math.round(top + Math.sin(angle) * distance);
            page = page || getObj("page", pageId);
            let width = page.get('width') * PIX_PER_UNIT;
            let height = page.get('height') * PIX_PER_UNIT;
            if (pc.x < 0) pc.x = 0;
            if (pc.y < 0) pc.y = 0;
            if (pc.x > width) pc.y = width;
            if (pc.y > height) pc.y = height;
            murs = getWalls(page, pageId, murs);
            if (murs) {
              if (obstaclePresent(left, top, pc, murs)) {
                angle = Math.random() * 2 * Math.PI;
                distance = (Math.random() * reglesOptionelles.divers.val.echec_critique_boule_de_feu.val * PIX_PER_UNIT / computeScale(pageId)) / 2;
                pc.x = Math.round(left + Math.cos(angle) * distance);
                pc.y = Math.round(top + Math.sin(angle) * distance);
                if (pc.x < 0) pc.x = 0;
                if (pc.y < 0) pc.y = 0;
                if (pc.x > width) pc.y = width;
                if (pc.y > height) pc.y = height;
                if (obstaclePresent(left, top, pc, murs)) {
                  pc.x = left;
                  pc.y = top;
                }
              }
            }
            targetToken.set('left', pc.x);
            targetToken.set('top', pc.y);
          } else {
            if (options.triche === undefined) options.triche = 'pasDEchecCritique';
          }
        }
        if (options.targetFx) {
          spawnFx(targetToken.get('left'), targetToken.get('top'), options.targetFx, pageId);
        }
        if (options.dmCible) {
          options.dmCible.target = targetToken;
        }
        let distanceTarget =
          distanceCombat(targetToken, tokenOrigine, pageId, {
            strict1: true,
            strict2: true
          });
        let pta = pointOfToken(tokenOrigine);
        let ptt = pointOfToken(targetToken);
        switch (options.aoe.type) {
          case 'ligne':
            {
              if (distanceTarget < portee) { //la ligne va plus loin que la cible
                let scale = portee * 1.0 / distanceTarget;
                ptt = {
                  x: Math.round((ptt.x - pta.x) * scale) + pta.x,
                  y: Math.round((ptt.y - pta.y) * scale) + pta.y
                };
              }
              if (targetToken.get('bar1_max') == 0) { // jshint ignore:line
                //C'est juste un token utilis\xE9 pour d\xE9finir la ligne
                if (options.fx) {
                  spawnFxBetweenPoints(pta, ptt, options.fx, pageId);
                }
                cibles = [];
                targetToken.remove(); //On l'enl\xE8ve, normalement plus besoin
              }
              let allToks =
                findObjs({
                  _type: 'graphic',
                  _pageid: pageId,
                  _subtype: 'token',
                  layer: 'objects'
                });
              allToks.forEach(function(obj) {
                if (obj.id == tokenOrigine.id) return; //on ne se cible pas
                let objCharId = obj.get('represents');
                if (objCharId === '') return;
                let cible = {
                  token: obj,
                  charId: objCharId
                };
                if (nePeutPlusPrendreDM(cible, options)) return; //pas de d\xE9g\xE2ts aux morts
                let distToTrajectory = distancePixTokenSegment(obj, pta, ptt);
                if (distToTrajectory > (obj.get('width') + obj.get('height')) / 4 + PIX_PER_UNIT / 4)
                  return;
                cible.tokName = obj.get('name');
                let objChar = getObj('character', objCharId);
                if (objChar === undefined) return;
                cible.name = objChar.get('name');
                cibles.push(cible);
              });
              break;
            }
          case 'disque':
            {
              if (distanceTarget > portee) {
                sendPlayer(playerName,
                  "Le centre du disque vis\xE9 est trop loin pour " + weaponName +
                  " (distance " + distanceTarget + ", port\xE9e " + portee + ")",
                  playerId);
                attackCallback(options);
                return;
              }
              if (options.aoe.souffleDeMort) {
                let combat = stateCOF.combat;
                if (!combat) {
                  sendPlayer(playerName, "Le souffle de mort n'est utilisable qu'en combat", playerId);
                  return;
                }
                let charId = targetToken.get('represents');
                if (!charId) {
                  sendPlayer(playerName, "Le centre du disque n'est pas un cadavre", playerId);
                  attackCallback(options);
                  return;
                }
                let cadavre = {
                  charId,
                  token: targetToken
                };
                if (!getState(cadavre, 'mort')) {
                  sendPlayer(playerName, nomPerso(cadavre) + " n'est pas mort" + eForFemale(cadavre), playerId);
                  attackCallback(options);
                  return;
                }
                let t = attributeAsInt(cadavre, 'a0PVDepuis', 0);
                if (t < combat.tour - 1) {
                  sendPlayer(playerName, "La mort de " + nomPerso(cadavre) + " n'est pas assez r\xE9cente", playerId);
                  attackCallback(options);
                  return;
                }
                options.aoe.souffleDeMort.allies = alliesParPerso[charId] || new Set();
                options.aoe.souffleDeMort.allies.add(charId);
                options.aoe.souffleDeMort.niveau =
                  ficheAttributeAsInt(cadavre, 'niveau', 0);
              }
              page = page || getObj("page", pageId);
              murs = getWalls(page, pageId, murs);
              let allToksDisque =
                findObjs({
                  _type: "graphic",
                  _pageid: pageId,
                  _subtype: "token",
                  layer: "objects"
                });
              allToksDisque.forEach(function(obj) {
                if ((options.explosion || portee === 0) &&
                  obj.id == tokenOrigine.id) return; //on ne se cible pas si le centre de l'aoe est soi-m\xEAme
                if (obj.get('bar1_max') == 0) return; // jshint ignore:line
                let objCharId = obj.get('represents');
                if (objCharId === '') return;
                let cible = {
                  token: obj,
                  charId: objCharId
                };
                if (nePeutPlusPrendreDM(cible, options)) return; //pas de d\xE9g\xE2ts aux morts
                let distanceCentre =
                  distanceCombat(targetToken, obj, pageId, {
                    strict1: true
                  });
                if (distanceCentre > options.aoe.rayon) return;
                let objChar = getObj('character', objCharId);
                if (objChar === undefined) return;
                if (murs) {
                  if (obstaclePresent(obj.get('left'), obj.get('top'), ptt, murs)) return;
                }
                if (options.aoe.souffleDeMort) {
                  if (!options.aoe.souffleDeMort.allies.has(objCharId)) return;
                  if (estMortVivant(cible)) return;
                  if (ficheAttributeAsInt(cible, 'niveau', 0) > options.aoe.souffleDeMort.niveau) return;
                }
                cible.name = objChar.get('name');
                cible.tokName = obj.get('name');
                cibles.push(cible);
              });
              if (targetToken.get('bar1_max') == 0) { // jshint ignore:line
                //C'est juste un token utilis\xE9 pour d\xE9finir le disque
                targetToken.remove(); //On l'enl\xE8ve, normalement plus besoin
              }
              // La nouvelle port\xE9e (pour ne rien \xE9liminer \xE0 l'\xE9tape suivante
              portee += options.aoe.rayon;
              break;
            }
          case 'cone':
            {
              if (options.fx) {
                spawnFxBetweenPoints(pta, ptt, options.fx, pageId);
              }
              let vecCentre = vecteurUnitaire(pta, ptt);
              let cosAngle = Math.cos(options.aoe.angle * Math.PI / 360.0);
              //Pour \xE9viter des artfacts d'arrondi:
              cosAngle = (Math.floor(cosAngle * 1000000)) / 1000000;
              if (targetToken.get('bar1_max') == 0) { // jshint ignore:line
                //C'est juste un token utilis\xE9 pour d\xE9finir le cone
                cibles = [];
                targetToken.remove(); //On l'enl\xE8ve, normalement plus besoin
              }
              page = page || getObj("page", pageId);
              murs = getWalls(page, pageId, murs);
              let allToksCone =
                findObjs({
                  _type: "graphic",
                  _pageid: pageId,
                  _subtype: "token",
                  layer: "objects"
                });
              allToksCone.forEach(function(obj) {
                if (obj.id == tokenOrigine.id) return; //on ne se cible pas
                let objCharId = obj.get('represents');
                if (objCharId === '') return;
                let cible = {
                  token: obj,
                  charId: objCharId
                };
                if (nePeutPlusPrendreDM(cible, options)) return; //pas de d\xE9g\xE2ts aux morts
                let pt = pointOfToken(obj);
                let vecObj = vecteurUnitaire(pta, pt);
                if (vecCentre.x * vecObj.x + vecCentre.y * vecObj.y < cosAngle)
                  return;
                // La distance sera compar\xE9e \xE0 la port\xE9e plus loin
                let objChar = getObj('character', objCharId);
                if (objChar === undefined) return;
                if (murs) {
                  if (obstaclePresent(pt.x, pt.y, pta, murs)) return;
                }
                cible.name = objChar.get('name');
                cible.tokName = obj.get('name');
                cibles.push(cible);
              });
              break;
            }
          default:
            error("aoe inconnue", options.aoe);
            attackCallback(options);
            return;
        }
      } else {
        if (tokenOrigine.id == targetToken.id && !options.echecTotal) { //m\xEAme token pour attaquant et cible
          sendPerso(attaquant,
            "s'attaque " + onGenre(attaquant, "lui", "elle") +
            "-m\xEAme ? Probablement une erreur \xE0 la s\xE9lection de la cible. On annule");
          attackCallback(options);
          return;
        }
        let targetCharId = targetToken.get("represents");
        if (targetCharId === "") {
          error("Le token cibl\xE9 (" + nomCiblePrincipale + ") doit repr\xE9senter un personnage ", targetToken);
          attackCallback(options);
          return;
        }
        let targetChar = getObj("character", targetCharId);
        if (targetChar === undefined) {
          error("Unexpected undefined 2", targetChar);
          attackCallback(options);
          return;
        }
        cibles = [{
          token: targetToken,
          charId: targetCharId,
          name: targetChar.get('name'),
          tokName: nomCiblePrincipale
        }];
      }
      if (options.ciblesSupplementaires) {
        options.ciblesSupplementaires.forEach(function(c) {
          let i = cibles.some(function(t) {
            return (t.token.id == c.token.id);
          });
          if (!i) cibles.push(c);
        });
      }
    }
    //Les conditions qui peuvent emp\xEAcher l'attaque
    if (options.conditionAttaquant !== undefined) {
      if (!testCondition(options.conditionAttaquant, attaquant, cibles)) {
        sendPerso(attaquant, "ne peut pas utiliser " + weaponName);
        attackCallback(options);
        return;
      }
    }
    //dernieresCiblesAttaquees contient en current les cibles attaqu\xE9es, et en max les cibles sur lesquelles on a fait des ripostes
    let attrCiblesAttaquees = tokenAttribute(attaquant, 'dernieresCiblesAttaquees');
    let ripostesDuTour = new Set();
    if (attrCiblesAttaquees.length > 0) {
      ripostesDuTour = new Set(attrCiblesAttaquees[0].get('max').split(' '));
    }
    let tm = stateCOF.tenebresMagiques;
    if (tm && estDemon(attaquant)) {
      tm.attaques = tm.attaques || {};
      tm.attaques[attackingToken.id] = cibles;
    }
    cibles = cibles.filter(function(target) {
      if (getState(target, 'enseveli')) {
        sendPlayer(playerName, "impossible d'attaquer un personnage enseveli", playerId);
        return false;
      }
      if (attributeAsBool(target, 'ombreMortelle')) {
        sendPlayer(playerName, "impossible d'attaquer une ombre", playerId);
        return false;
      }
      if (options.seulementVivant && estNonVivant(target)) {
        sendPlayer(playerName, "cette attaque n'affecte que les cr\xE9atures vivantes", playerId);
        return false;
      }
      if (options.attaqueMentale) {
        if (predicateAsBool(target, 'sansEsprit')) {
          sendPlayer(playerName, "cette attaque n'affecte que les cr\xE9atures pensantes", playerId);
          return false;
        }
        if (predicateAsBool(target, 'vegetatif')) {
          sendPlayer(playerName, "cette attaque n'affecte pas les cr\xE9atures v\xE9g etatives", playerId);
          return false;
        }
      }
      if (options.pointsVitaux && estNonVivant(target)) {
        sendPlayer(playerName, "La cible n'est pas vraiment vivante : " + attaquant.name + " ne trouve pas de points vitaux", playerId);
        return false;
      }
      if (attributeAsBool(attaquant, 'tenuADistanceManoeuvre(' + target.token.id + ')')) {
        sendPerso(attaquant, "est tenu \xE0 distance de " + nomPerso(target) + ", " + onGenre(attaquant, "il", "elle") + " ne peut pas l'attaquer ce tour.");
        return false;
      }
      if (charAttributeAsBool(target, 'armeeConjuree')) {
        return options.attaqueArmeeConjuree;
      }
      if (ripostesDuTour.has(target.token.id)) {
        sendPerso(attaquant, "a d\xE9j\xE0 fait une riposte contre " + nomPerso(target));
        return false;
      }
      if (options.ricochets) {
        let dejaTouche = options.ricochets.cibles.some(function(c) {
          return c.token.id == target.token.id;
        });
        if (dejaTouche) {
          sendPerso(attaquant, nomPerso(target) + " a d\xE9j\xE0 \xE9t\xE9 touch\xE9 par un pr\xE9c\xE9dent ricochet de cette attaque");
          return false;
        }
      }
      return true;
    });
    if (cibles.length === 0) {
      if (options.aoe) {
        sendPlayer(playerName, "aucune cible dans l'aire d'effet de " + weaponName + ", action annul\xE9e",
          playerId);
      }
      attackCallback(options);
      return;
    }
    if (!options.redo) {
      //Prise en compte de la distance
      let optDistance = {};
      options.portee = portee;
      if (options.contact) optDistance.allonge = options.allonge;
      // Si l'attaquant est mont\xE9, distance mesur\xE9e \xE0 partir de sa monture
      if (tokenOrigine.id == attackingToken.id) {
        let attrMonture = tokenAttribute(attaquant, 'monteSur');
        if (attrMonture.length > 0) {
          let pseudoAttacker =
            persoOfIdName(attrMonture[0].get('current'), pageId);
          if (pseudoAttacker) tokenOrigine = pseudoAttacker.token;
        }
      }
      cibles = cibles.filter(function(target) {
        // Si la cible est mont\xE9e, distance mesur\xE9e vers sa monture
        let pseudoTargetToken = target.token;
        let attrMonture = tokenAttribute(target, 'monteSur');
        if (attrMonture.length > 0) {
          let pseudoTarget =
            persoOfIdName(attrMonture[0].get('current'), pageId);
          if (pseudoTarget) pseudoTargetToken = pseudoTarget.token;
        }
        target.distance =
          distanceCombat(tokenOrigine, pseudoTargetToken, pageId, optDistance);
        if (options.intercepter || options.interposer) return true;
        if (target.distance > portee && target.msgEsquiveFatale === undefined && !(target.chairACanon || target.intercepter)) {
          if (options.aoe || options.auto) return false; //distance stricte
          if (target.distance > (predicateAsBool(attaquant, 'tirParabolique') ? 3 : 2) * portee) return false;
          // On peut aller jusqu'\xE0 2x portee si unique cible et jet d'attaque, 3x si le personnage a Tir Parabolique
          return true;
        }
        if (target.distance === 0 && options.seulementDistance) {
          sendPerso(attaquant, "est trop proche de " + nomPerso(target) + " pour cette attaque");
          return false;
        }
        return true;
      });
    }
    //On enl\xE8ve les alli\xE9s si l'option saufAllies est active
    if (options.saufAllies) {
      let allies = new Set();
      allies = alliesParPerso[attaquant.charId] || allies;
      allies = (new Set(allies)).add(attaquant.charId);
      cibles = cibles.filter(function(target) {
        return !(allies.has(target.charId));
      });
    }
    //On v\xE9rifie que les cibles sont assez proches les unes des autres
    if (options.ciblesDansDisque && cibles.length > 1) {
      let l1, l2, t1, t2;
      cibles.forEach(function(target) {
        let l = target.token.get('left');
        let t = target.token.get('top');
        if (l1 === undefined || l1 > l) l1 = l;
        if (l2 === undefined || l2 < l) l2 = l;
        if (t1 === undefined || t1 > t) t1 = t;
        if (t2 === undefined || t2 < t) t2 = t;
      });
      let maxpix = options.ciblesDansDisque * PIX_PER_UNIT / computeScale(pageId);
      if ((l2 - l1) > 2 * maxpix || (t2 - t1) > 2 * maxpix) {
        sendPlayer(playerName, "Cibles trop \xE9loign\xE9es les unes des autres");
        attackCallback(options);
        return;
      }
      //On calcule la longueur des diagonales du rectangle minimal
      let diag = Math.sqrt((l2 - l1) * (l2 - l1) + (t2 - t1) * (t2 - t1));
      if (diag > maxpix) {
        let centre = {
          x: (l1 + l2) / 2,
          y: (t1 + t2) / 2
        };
        //C'est approch\xE9, mais s\xFBrement assez bon pour ce qui nous occupe
        let tropLoin = cibles.some(function(target) {
          let pt = pointOfToken(target.token);
          attackCallback(options);
          return (distancePoints(centre, pt) > maxpix + 1);
        });
        if (tropLoin) {
          sendPlayer(playerName, "Cibles trop \xE9loign\xE9es les unes des autres");
          attackCallback(options);
          return;
        }
      }
    }
    if (cibles.length === 0) {
      if (options.aoe) {
        sendPlayer(playerName, "aucune cible dans l'aire d'effet de " + weaponName + ", action annul\xE9e",
          playerId);
        return;
      }
      if (!options.seulementDistance) {
        sendPerso(attaquant, "est hors de port\xE9e de " + nomCiblePrincipale + " pour une attaque utilisant " + weaponName + ", action annul\xE9e");
      }
      return;
    }
    //On enl\xE8ve les doublons de cibles qui partagent leurs PVs;
    cibles = enleveDoublonsPartagePV(cibles);
    let evt = options.evt || {
      type: "Attaque",
      action: {
        playerName: playerName,
        playerId: playerId,
        attaquant: attaquant,
        cibles: cibles,
        weaponStats: weaponStats,
        options: options
      }
    };
    if (options.attaqueArmeeConjuree) {
      setAttrDuree(attaquant, 'attaqueArmeeConjuree', 1, evt);
    }
    evt.action = evt.action || {
      options: JSON.parse(JSON.stringify(options)) //pour la chance etc.
    };
    //On met \xE0 jour l'arme en main, si n\xE9cessaire
    if (weaponStats.arme || weaponStats.armeGauche || (weaponStats.divers && weaponStats.divers.toLowerCase().includes('arme'))) {
      options.weaponStats = weaponStats;
      options.messages = options.messages || [];
      let arme = armesEnMain(attaquant);
      if ((!arme || arme.label != attackLabel) && (!attaquant.armeGauche || attaquant.armeGauche.label != attackLabel))
        degainerArme(attaquant, attackLabel, evt, options);
    }
    if (options.contact && weaponStats.arme && predicateAsBool(attaquant, 'frappeDuVide')) {
      if (attributeAsBool(attaquant, 'limiteParTour_frappeDuVidePossible'))
        options.frappeDuVide = true;
      //Il faut noter la premi\xE8re attaque au contact
      setTokenAttr(attaquant, 'limiteParCombat_dejaFrappeContact', true, evt);
    }
    let riposte = predicateAsBool(attaquant, 'riposte');
    let attaqueEnMeute = predicateAsInt(attaquant, 'attaqueEnMeute', 0);
    if (attaqueEnMeute > 0) options.attaqueEnMeute = attaqueEnMeute;
    options.lienEpique = predicateAsBool(attaquant, 'lienEpique');
    if (riposte || options.attaqueEnMeute || options.lienEpique) {
      //Dans ce cas, il faut stoquer les cibles attaqu\xE9es
      //(dans le cas de riposte, pour ne pas les re-proposer en riposte
      let listeCibles =
        cibles.map(function(target) {
          return target.token.id;
        }).join(' ');
      if (attrCiblesAttaquees.length === 0) {
        if (options.riposte) {
          setTokenAttr(attaquant, 'dernieresCiblesAttaquees', '', evt, {
            maxVal: listeCibles
          });
        } else {
          setTokenAttr(attaquant, 'dernieresCiblesAttaquees', listeCibles, evt);
        }
      } else { //L'attribut existe d\xE9j\xE0
        attrCiblesAttaquees = attrCiblesAttaquees[0];
        evt.attributes = evt.attributes || [];
        let attaquesDuTour = attrCiblesAttaquees.get('current');
        ripostesDuTour = attrCiblesAttaquees.get('max');
        evt.attributes.push({
          attribute: attrCiblesAttaquees,
          current: attaquesDuTour,
          max: ripostesDuTour,
        });
        if (options.riposte) {
          if (ripostesDuTour === '') ripostesDuTour = listeCibles;
          else ripostesDuTour += ' ' + listeCibles;
          attrCiblesAttaquees.set('max', ripostesDuTour);
        } else {
          if (attaquesDuTour === '') attaquesDuTour = listeCibles;
          else attaquesDuTour += ' ' + listeCibles;
          attrCiblesAttaquees.set('current', attaquesDuTour);
        }
      }
    }
    addEvent(evt);
    let explications = [];
    if (options.messages) explications = [...options.messages];
    if (options.magieRapide) explications.push("Magie rapide");
    //On fait les tests pour les cibles qui b\xE9n\xE9ficieraient d'un sanctuaire
    let ciblesATraiter = cibles.length;
    let cibleTraitee = function() {
      ciblesATraiter--;
      if (ciblesATraiter === 0) {
        evalITE(attaquant, undefined, undefined, options, 0, evt, explications, options, function() {
          resoudreAttaque(attaquant, cibles, attackLabel, weaponName, weaponStats, playerId, pageId, evt, explications, options, chargesArme);
        });
      }
    };
    let attaqueImpossible = false;
    if (predicateAsBool(attaquant, 'chatimentDuMale')) options.chatimentDuMale = true;
    cibles.forEach(function(cible) {
      if (attaqueImpossible) return;
      cible.messages = [];
      if (options.chatimentDuMale && onGenre(cible, true, false))
        cible.chatimentDuMale = true;
      let evalSanctuaire = function() {
        if (attributeAsBool(cible, 'sanctuaire')) {
          let testId = 'sanctuaire_' + cible.token.id;
          testCaracteristique(attaquant, 'SAG', 15, testId, options, evt, function(tr) {
            if (tr.reussite) {
              cible.messages.push(nomPerso(attaquant) + " r\xE9ussit \xE0 passer outre le sanctuaire de " + nomPerso(cible) + " (jet de SAG " + tr.texte + "&ge;15)" + tr.modifiers);
              cibleTraitee();
            } else {
              let msgRate = "ne peut se r\xE9soudre \xE0 attaquer " + nomPerso(cible) + " (sanctuaire, jet de SAG " + tr.texte + "< 15)" + tr.rerolls + tr.modifiers;
              sendPerso(attaquant, msgRate);
              attaqueImpossible = true;
            }
          });
        } else {
          cibleTraitee();
        }
      };
      // Attaque de Disparition avec jet oppos\xE9
      if (options.disparition) {
        //L'immunit\xE9 aux attaques sournoise est test\xE9e plus loin et ne devrait
        //pas emp\xEAcher le bonus de +5 \xE0 l'attaque.
        let rollId = 'disparition_' + cible.token.id;
        let options1 = {...options
        };
        options1.competence = 'discr\xE9tion';
        let options2 = {...options
        };
        options2.competence = 'perception';
        testOppose(rollId, attaquant, "DEX", options1, cible, "SAG", options2,
          cible.messages, evt,
          function(resultat, crit, rt1, rt2) {
            if (resultat != 2) {
              cible.messages.push(nomPerso(attaquant) + " r\xE9apparait \xE0 c\xF4t\xE9 de " + nomPerso(cible) + " et lui porte une attaque mortelle !");
              // rajout des bonus de sournoise
              options.bonusAttaque = (options.bonusAttaque || 0) + 5;
              options.sournoise = options.sournoise || 0;
              options.sournoise += options.disparition;
            } else {
              cible.messages.push(nomPerso(cible) + " rep\xE8re " + nomPerso(attaquant) + " \xE0 temps pour r\xE9agir.");
            }
            evalSanctuaire();
          }); //fin de testOppose (asynchrone)
      } else if (cibles.length == 1 && options.contact && options.attaqueAcrobatique) {
        let rollId = 'attaqueAcrobatique_' + attackingToken.id;
        let rollOptions = {
          competence: 'acrobatie'
        };
        explications.push("Tentative d'acrobatie pour surprendre " + nomPerso(cible));
        testCaracteristique(attaquant, 'DEX', 15, rollId, rollOptions, evt,
          function(tr, expl) {
            explications.push("<b>R\xE9sultat :</b> " + tr.texte + tr.modifiers);
            expl.forEach(function(m) {
              explications.push(m);
            });
            if (tr.reussite) {
              explications.push("R\xE9ussite : " + nomPerso(attaquant) + " peut faire une attaque sournoise");
              options.sournoise = options.sournoise || 0;
              options.sournoise += options.attaqueAcrobatique;
            } else {
              explications.push("Rat\xE9, " + nomPerso(attaquant) + " r\xE9alise une attaque normale" + tr.rerolls);
            }
            evalSanctuaire();
          });
      } else evalSanctuaire();
    });
  }

  // On affiche les options d'attaque \xE0 droite
  function afficherOptionsAttaque(perso, opt_display) {
    let action_opts = '!cof-options-d-attaque --target ' + perso.token.id;
    let text_opts = '';
    if (persoEstPNJ(perso) && ficheAttributeAsInt(perso, 'attaque_de_groupe', 1) > 1) {
      text_opts = "Groupe de " + ficheAttributeAsInt(perso, 'attaque_de_groupe', 1);
    }
    if (ficheAttributeAsInt(perso, 'attaque_en_puissance_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "En puissance " + ficheAttributeAsInt(perso, 'attaque_en_puissance', 1);
    }
    if (ficheAttributeAsInt(perso, 'attaque_risquee_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "Risqu\xE9e";
    }
    if (ficheAttributeAsInt(perso, 'attaque_assuree_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "Assur\xE9e";
    }
    if (ficheAttributeAsInt(perso, 'attaque_dm_temp_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "Pour assommer";
    }
    if (text_opts === '') text_opts = 'Options';
    opt_display.action_right =
      boutonSimple(action_opts, text_opts,
        'style="color: #a94442; background-color: #f2dede;"');
  }

  //perso peut ne pas avoir de token
  function extractRepeating(perso, repeatingSection) {
    const reg = new RegExp("^(repeating_" + repeatingSection + "_[^_]*_)(.*)$");
    const attributes = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    let rawList = {};
    attributes.forEach(function(a) {
      const m = reg.exec(a.get('name'));
      if (!m) return;
      rawList[m[1]] = rawList[m[1]] || {};
      rawList[m[1]][m[2]] = a.get('current');
      let max = a.get('max');
      if (max) rawList[m[1]][m[2] + '_max'] = max;
    });
    return rawList;
  }

  //perso peut ne pas avoir de token
  function listAllAttacks(perso) {
    if (perso.toutesLesAttaques) return perso.toutesLesAttaques;
    let rawList;
    if (persoEstPNJ(perso)) rawList = extractRepeating(perso, 'pnjatk');
    else rawList = extractRepeating(perso, 'armes');
    let liste = {}; //liste tri\xE9e par label d'attaque
    for (let pref in rawList) {
      let ra = rawList[pref];
      if (ra.armelabel === undefined) ra.armelabel = 0;
      if (liste[ra.armelabel]) {
        error("Plusieurs attaques de label " + ra.armelabel, ra);
        continue;
      }
      ra.prefixe = pref;
      liste[ra.armelabel] = ra;
    }
    perso.toutesLesAttaques = liste;
    return liste;
  }

  function sortedActionList(perso, listNumber) {
    let actions = [];
    let rawActions = extractRepeating(perso, 'actions' + listNumber);
    for (let pref in rawActions) {
      let ra = rawActions[pref];
      if (ra.actiontitre === undefined) ra.actiontitre = ' ';
      if (ra.actionmontree === undefined || parseInt(ra.actionmontree) === 1) {
        let rang = parseInt(ra.actionrang);
        if (isNaN(rang) || rang < 0) rang = 0;
        if (actions[rang]) {
          error("Plusieurs actions de m\xEAme rang " + rang + " dans la liste d'actions du tour", ra);
          continue;
        }
        actions[rang] = ra;
      }
    }
    return actions;
  }

  // on r\xE9cup\xE8re la valeur de l'action dont chaque Macro #/Ability % est mis dans un tableau 'action'
  //Pour chaque action, on a une commande, un texte et des options.
  //On appelle f(commande, texte, macros, attackStats)
  // le dernier argument est optionnel, et n'est l\xE0 que pour \xE9viter d'avoir \xE0 recalculer attackStats
  //actionsDuTour peut \xEAtre un nombre entre 0 et 4 (listes sur la fiche), ou
  //  une ability
  function treatActions(perso, actionsDuTour, abilities, f) {
    let actions; // La liste des actions
    let options = '';
    switch (actionsDuTour) {
      case 0:
        actions = sortedActionList(perso, '');
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        actions = sortedActionList(perso, actionsDuTour);
        options = ficheAttribute(perso, 'optionslisteactions' + actionsDuTour, '');
        if (options.startsWith('-')) options = ' ' + options;
        break;
      default:
        actions = actionsDuTour.get('action')
          .replace(/\n/gm, '').replace(/\r/gm, '')
          .replace(/%#([^#]*)#/g, '\n!cof-liste-actions $1')
          .replace(/\/\/%/g, '\n\/\/')
          .replace(/\/\/#/g, '\n\/\/')
          .replace(/\/\/!/g, '\n\/\/')
          .replace(/%/g, '\n%').replace(/#/g, '\n#').replace(/!/g, '\n!')
          .split('\n');
    }
    let actionsAAfficher;
    if (actions.length > 0) {
      // Toutes les Macros
      const macros = findObjs({
        _type: 'macro'
      });
      let found;
      let command;
      actions.forEach(function(action) {
        if (!action) return;
        let actionCode;
        let actionTextFinal;
        if (action.actiontitre !== undefined) {
          switch (action.actiontype) {
            case 'action':
            case undefined:
              if (action.actioncode) {
                actionCode = action.actioncode;
                actionTextFinal = action.actiontitre;
              } else {
                actionCode = action.actiontitre;
              }
              break;
            case 'liste':
              f('!cof-liste-actions ' + action.actiontitre, action.actiontitre, macros);
              found = true;
              return;
            default:
              error("Type d'action non reconnu " + action.actiontype, action);
              return;
          }
        } else {
          actionCode = action.trim();
          if (actionCode === '') return;
          if (actionCode.startsWith('//')) return; //Ligne comment\xE9e
        }
        let actionCommands = actionCode.split(' ');
        actionCommands = actionCommands.filter(function(c) {
          return c !== '';
        });
        if (actionCommands.length === 0) return;
        let actionCmd = actionCommands[0];
        let actionText = actionTextFinal || actionCmd.replace(/-/g, ' ').replace(/_/g, ' ');
        found = false;
        switch (actionCmd.charAt(0)) {
          case '%':
            // Ability
            actionCmd = actionCmd.substr(1);
            if (!actionTextFinal) actionText = actionText.substr(1);
            abilities.forEach(function(abilitie, index) {
              if (found) return;
              if (abilitie.get('name') === actionCmd) {
                // l'ability existe
                found = true;
                command = abilitie.get('action').trim();
                if (actionCommands.length > 1) {
                  //On rajoute les options de l'ability
                  command += actionCode.substr(actionCode.indexOf(' '));
                }
                command += options;
                f(command, actionText, macros);
              }
            });
            break;
          case '#':
            // Macro
            //D'abord le cas de #Attaque
            if (actionCmd == '#Attaque' && actionCommands.length > 1) {
              found = true;
              let attackLabel = actionCommands[1].trim();
              let attackStats;
              if (attackLabel == -1) { //attaque avec l'arme en main
                attackStats = armesEnMain(perso);
                if (attackStats === undefined) attackStats = attaqueAMainsNues;
              } else if (attackLabel == -2) { //attaque avec l'arme en main gauche
                if (perso.armesEnMain === undefined) armesEnMain(perso);
                attackStats = perso.armeGauche;
                if (!attackStats) return;
              } else {
                attackStats = getWeaponStats(perso, attackLabel);
                if (!attackStats) {
                  error("Impossible de trouver l'arme de label " + attackLabel, actionCommands);
                  return;
                }
              }
              if (!actionTextFinal) actionText = attackStats.name;
              actionCode += options;
              f(actionCode, actionText, macros, attackStats);
            } else {
              actionCmd = actionCmd.substr(1);
              if (!actionTextFinal) actionText = actionText.substr(1);
              macros.forEach(function(macro, index) {
                if (found) return;
                if (macro.get('name') === actionCmd) {
                  found = true;
                  command = macro.get('action').trim();
                  if (actionCommands.length > 1) {
                    //On rajoute les options de la macro
                    command += actionCode.substr(actionCode.indexOf(' '));
                  }
                  command += options;
                  f(command, actionText, macros);
                }
              });
            }
            break;
          case '!':
            switch (actionCmd.toLowerCase()) {
              case '!options':
                found = true;
                if (actionCommands.length > 1) {
                  options = actionCode.substring(8); //d\xE9marre par ' '
                }
                break;
              case '!attaques':
                found = true;
                f('liste des attaques', '', macros, options);
                break;
              case '!arme-en-main':
                found = true;
                let attOptions = '';
                if (actionCommands.length > 1)
                  attOptions = ' ' + actionCommands.slice(1).join(' ');
                attOptions += options;
                let attackStats = armesEnMain(perso);
                if (attackStats === undefined) {
                  let {
                    attaqueNaturelleNonVisible
                  } = listeDesArmes(perso);
                  if (attaqueNaturelleNonVisible) attackStats = getWeaponStats(perso, attaqueNaturelleNonVisible.armelabel);
                }
                command = '!cof-attack ' + perso.token.id + ' @{target|token_id} ';
                if (attackStats) {
                  command += attackStats.label + attOptions;
                  if (!actionTextFinal) actionText = attackStats.name;
                  f(command, actionText, macros, attackStats);
                } else {
                  command += argsAttaqueAMainsNues(perso) + attOptions;
                  if (!actionTextFinal) actionText = 'Mains nues';
                  f(command, actionText, macros);
                }
                break;
              default:
                // commande API
                if (!actionTextFinal && actionCommands.length > 1) {
                  actionText = actionCommands[1].replace(/-/g, ' ').replace(/_/g, ' ');
                }
                command = actionCode + options;
                f(command, actionText, macros);
                found = true;
            }
            break;
          default: //On affiche juste le titre
            f('', actionCode, macros);
            found = true;
        }
        if (found) {
          actionsAAfficher = true;
        } else {
          // Si on n'a toujours rien trouv\xE9, on ajoute un petit log
          log('Ability et macro non trouv\xE9 : ' + actionCode);
        }
      });
    }
    return actionsAAfficher;
  }

  function displayAttaqueOpportunite(vid, cibles, type, action, ligneOptions) {
    let attaquant = persoOfId(vid);
    if (attaquant === undefined) {
      error("Impossible de retrouver le personnage qui pouvait faire une attaque " + type, vid);
      return;
    }
    if (!isActive(attaquant)) return;
    let abilities = findObjs({
      _type: 'ability',
      _characterid: attaquant.charId,
    });
    let actions = findListeActions(attaquant, action, abilities);
    if (actions === undefined) {
      if (action == 'Ripostes') {
        actions = findListeActions(attaquant, 'ActionsRiposte', abilities);
      } else if (action == 'Attaques en traitre') {
        actions = findListeActions(attaquant, 'AttaqueEnTraitre', abilities);
        if (actions === undefined)
          actions = findListeActions(attaquant, 'Attaques en tra\xEEtre', abilities);
      }
    }
    let actionsOpportunite = [];
    if (actions) {
      treatActions(attaquant, actions, abilities, function(command, text, macros, attackStats) {
        if (command == 'liste des attaques') {
          actionsOpportunite.push({
            listeActions: true,
            attackStats
          });
        } else {
          command = replaceAction(command, attaquant, macros, abilities);
          if (command.startsWith('!cof-attack')) {
            actionsOpportunite.push({
              command: command,
              text: text,
              attackStats
            });
          }
        }
      });
      actionsOpportunite.reverse();
    } else {
      //On affiche l'attaque avec l'arme en main + les attaques naturelles coch\xE9es
      let listeAttaques = listAllAttacks(attaquant);
      for (let label in listeAttaques) {
        let arme = listeAttaques[label];
        if (parseInt(arme.armeactionvisible) === 0) continue;
        if (arme.armetypeattaque == 'Naturel' || arme.armetypeattaque === 'undefined') {
          actionsOpportunite.push({
            command: '!cof-attack @{selected|token_id} @{target|token_id} ' + label,
            text: arme.armenom,
          });
        }
      }
      actionsOpportunite.push({
        command: '!cof-attack @{selected|token_id} @{target|token_id} -1',
        text: "Attaque avec l'arme en main"
      });
    }
    let opt_display = {
      chuchote: true,
      retarde: true,
    };
    afficherOptionsAttaque(attaquant, opt_display);
    //On cr\xE9e un display sans le header
    let display =
      startFramedDisplay(undefined, "Attaque " + type + " possible", attaquant, opt_display);
    cibles.forEach(function(target) {
      if (target.name === undefined) { //TODO v\xE9rifier que c'est utile
        let targetChar = getObj('character', target.charId);
        if (targetChar === undefined) {
          error('Impossible de trouver le personnage repr\xE9sentant ' + nomPerso(target), target);
          return;
        }
        target.name = targetChar.get('name');
      }
      addLineToFramedDisplay(display, "contre " + nomPerso(target), 100, true);
      actionsOpportunite.forEach(function(action) {
        if (action.listeActions) {
          let l = listeAttaquesVisibles(attaquant, {
            ligneOptions,
            target: target.token.id
          });
          addLineToFramedDisplay(display, l);
          return;
        }
        let cmd = action.command.replace(/@\{target\|token_id\}/g, target.token.id);
        cmd = cmd.replace(/@\{target\|token_name\}/g, nomPerso(target));
        cmd = cmd.replace(/@\{target\|/g, '@{' + target.name + '|');
        if (ligneOptions) cmd += ' ' + ligneOptions;
        addLineToFramedDisplay(display, bouton(cmd, action.text, attaquant));
      });
    });
    // on envoie la liste aux joueurs qui g\xE8rent l'attaquant
    let playerIds = getPlayerIds(attaquant);
    playerIds.forEach(function(playerid) {
      addFramedHeader(display, playerid, true);
      sendChat('', endFramedDisplay(display));
    });
    if (playerIds.length === 0) {
      addFramedHeader(display, undefined, 'gm');
      sendChat('', endFramedDisplay(display));
    }
  }

  function ajouteDe6Crit(x, first, max) {
    let bonusCrit = rollDePlus(6, {
      maxResult: max
    });
    if (first) x.dmgDisplay = "(" + x.dmgDisplay + ")";
    x.dmgDisplay += '+' + bonusCrit.roll;
    x.dmgTotal += bonusCrit.val;
  }

  function immuniseAuType(target, dmgType, attaquant) {
    if (predicateAsBool(target, 'immunite_' + dmgType)) return true;
    switch (dmgType) {
      case 'poison':
        if (estNonVivant(target)) return true;
        if (predicateAsBool(target, 'vegetatif')) return true;
        if (attributeAsBool(target, 'sangDeLArbreCoeur')) return true;
        if (predicateOrAttributeAsBool(target, 'controleSanguin')) return true;
        if (attaquant && predicateAsBool(target, 'sangDeFerIf')) {
          return estElfeNoir(attaquant) || estInsecte(attaquant);
        }
        return false;
      case 'froid':
        return attributeAsBool(target, 'presenceGlaciale');
      case 'maladie':
        if (estNonVivant(target)) return true;
        if (predicateAsBool(target, 'vegetatif')) return true;
        return attributeAsBool(target, 'sangDeLArbreCoeur');
      case 'drain':
        return predicateAsInt(target, 'voieDeLArchange', 1) > 2 && attributeAsBool(target, 'formeDAnge');
    }
    return false;
  }

  function immuniseAsphyxie(target, expliquer) {
    if (predicateAsBool(target, 'creatureArtificielle') ||
      estNonVivant(target)) {
      if (expliquer) expliquer("L'asphyxie est sans effet sur une cr\xE9ature non-vivante");
      return true;
    }
    if (estDemon(target)) {
      if (expliquer) expliquer("L'asphyxie est sans effet sur un d\xE9mon");
      return true;
    }
    if (predicateAsBool(target, 'vegetatif')) {
      if (expliquer) expliquer("L'asphyxie est sans effet sur une cr\xE9ature v\xE9g\xE9tative");
      return true;
    }
    return false;
  }

  function addToDmgTotal(dmgTotal, dm, d, expliquer, evt) {
    if (d.drainDeSang) {
      let soins = Math.floor(dm / 2);
      if (soins > 0) {
        soigneToken(d.drainDeSang, soins, evt, function(soins) {
          expliquer("Le saignement soigne " + nomPerso(d.drainDeSang) + " de " + soins + " PV");
        });
      }
      if (predicateAsBool(d.drainDeSang, 'energieImpie')) {
        addToAttributeAsInt(d.drainDeSang, 'energieImpie', 0, 1, evt);
      }
    }
    return dmgTotal + dm;
  }

  // Fonction asynchrone
  // displayRes est optionnel, et peut avoir 2 arguments
  // - un texte affichant le jet de d\xE9g\xE2ts
  // - la valeur finale des d\xE9g\xE2ts inflig\xE9s
  // crit est un bool\xE9en, il augmente de 1 (ou options.critCoef) le coefficient (option.dmgCoef) et active certains effets
  function dealDamage(target, dmg, otherDmg, evt, crit, options, explications, displayRes) {
    if (options === undefined) options = {};
    let expliquer = function(msg) {
      if (explications) explications.push(msg);
      else sendPerso(target, msg);
    };
    if (options.interposer) {
      return dealDamageAfterOthers(target, crit, {}, evt, expliquer, displayRes, options.interposer, dmg.display, false);
    }
    if ((!options.spectral && attributeAsBool(target, 'intangible') && attributeAsInt(target, 'intangibleValeur', 1)) ||
      (!options.spectral && attributeAsBool(target, 'intangibleInvisible') && attributeAsInt(target, 'intangibleInvisibleValeur', 1)) ||
      attributeAsBool(target, 'ombreMortelle') ||
      (options.aoe === undefined &&
        attributeAsBool(target, 'formeGazeuse')) ||
      (predicateAsBool(target, 'apparition') && !options.energiePositive)) {
      expliquer("L'attaque passe \xE0 travers de " + nomPerso(target));
      if (displayRes) displayRes('0', 0, 0);
      return 0;
    }
    if (options.asphyxie) {
      if (immuniseAsphyxie(target, expliquer)) {
        if (displayRes) displayRes('0', 0, 0);
        return 0;
      }
    }
    if (!options.magique && !options.sortilege && dmg.type != 'magique' &&
      (predicateOrAttributeAsBool(target, 'immunite_nonMagique') || predicateAsBool(target, 'creatureIntangible'))) {
      expliquer("L'attaque ne semble pas affecter " + nomPerso(target));
      if (displayRes) displayRes('0', 0, 0);
      return 0;
    }
    let dmgCoef = options.dmgCoef || 1;
    if (target.dmgCoef) dmgCoef += target.dmgCoef;
    if (options.ferFroid && (estDemon(target) || estFee(target))) dmgCoef += 1;
    let diviseDmg = options.diviseDmg || 1;
    if (target.diviseDmg) diviseDmg *= target.diviseDmg;
    if (options.attaqueEnEtantGobe) diviseDmg *= 2;
    if (options.sortilege && predicateAsBool(target, 'esquiveDeLaMagie'))
      diviseDmg *= 2;
    if (options.attaqueDeGroupeDmgCoef) {
      dmgCoef++;
      expliquer("Attaque en groupe > DEF +" + reglesOptionelles.haute_DEF.val.crit_attaque_groupe.val + " => DMGx" + (crit ? "3" : "2"));
    }
    let critCoef = 1;
    if (crit) {
      if (attributeAsBool(target, 'danseDesLames')) {
        removeTokenAttr(target, 'danseDesLames', evt);
        expliquer("Le coup critique fait sortir de la transe de danse des lames");
      }
      if (predicateAsBool(target, 'armureLourdeGuerrier') &&
        ficheAttributeAsBool(target, 'defarmureon', false) &&
        ficheAttributeAsInt(target, 'defarmure', 0) >= 7) {
        expliquer("L'armure lourde de " + nomPerso(target) + " lui permet d'ignorer les d\xE9g\xE2ts critiques");
      } else if (predicateAsBool(target, 'immuniteAuxCritiques')) {
        expliquer("Le succ\xE8s critique est sans effet");
      } else {
        if (options.critCoef) critCoef = options.critCoef;
        if (target.critCoef) critCoef += target.critCoef;
        dmgCoef += critCoef;
        if (predicateAsBool(target, 'armureProtection') && ficheAttributeAsBool(target, 'defarmureon', false)) {
          expliquer("L'armure de protection de " + nomPerso(target) + " le prot\xE8ge du critique");
          diviseDmg++;
        } else if (predicateAsBool(target, 'bouclierProtection') && ficheAttributeAsInt(target, 'defbouclieron', 0)) {
          expliquer("Le bouclier de protection de " + nomPerso(target) + " le prot\xE8ge du critique");
          diviseDmg++;
        } else if (predicateAsBool(target, 'anneauProtection')) {
          expliquer("L'anneau de protection de " + nomPerso(target) + " le prot\xE8ge du critique");
          diviseDmg++;
        }
        if (predicateAsBool(target, 'bouclierProtection') && ficheAttributeAsBool(target, 'defbouclieron', false)) {
          expliquer("Le bouclier de protection de " + nomPerso(target) + " le prot\xE8ge du critique");
          diviseDmg++;
        }
      }
    }
    otherDmg = otherDmg || [];
    let dmgDisplay = dmg.display;
    let dmgTotal = dmg.total;
    if (dmgTotal < 1 && !(dmg.value && dmg.value.startsWith('0'))) {
      dmgDisplay += ' -> 1';
      dmgTotal = 1;
    }
    let showTotal = false;
    if (dmgCoef > 1) {
      dmgDisplay += " X " + dmgCoef;
      dmgTotal = dmgTotal * dmgCoef;
      showTotal = true;
    }
    if (diviseDmg > 1) {
      if (showTotal) dmgDisplay = '(' + dmgDisplay + ')';
      dmgDisplay += " / " + diviseDmg;
      dmgTotal = Math.ceil(dmgTotal / diviseDmg);
      showTotal = true;
    }
    if (crit) {
      let messageCrit = predicateAsBool(target, 'messageSiCritique');
      if (messageCrit) expliquer(messageCrit);
      if (predicateAsBool(target, 'fureurDrakonide')) {
        expliquer("le coup critique rend " + nomPerso(target) + " furieu" + onGenre(target, 'x', 'se'));
        setTokenAttr(target, 'fureurDrakonideCritique', true, evt);
      }
      if (predicateAsBool(target, 'memePasMal')) {
        options.memePasMal = (dmgTotal / dmgCoef) * critCoef;
      }
      let firstBonusCritique = true;
      let x = {
        dmgDisplay,
        dmgTotal
      };
      if (options.affute) {
        ajouteDe6Crit(x, firstBonusCritique, options.kiai);
        firstBonusCritique = false;
      }
      if (options.tirFatal) {
        ajouteDe6Crit(x, firstBonusCritique, options.kiai);
        if (options.tirFatal > 1) {
          ajouteDe6Crit(x, false, options.kiai);
        }
      }
      if (target.additionalCritDmg) {
        target.additionalCritDmg.forEach(function(dmSpec) {
          if (firstBonusCritique) {
            x.dmgDisplay = "(" + x.dmgDisplay + ")";
            firstBonusCritique = false;
          }
          x.dmgDisplay += '+' + dmSpec.display;
          x.dmgTotal += dmSpec.total;
        });
      }
      if (options.memePasMal !== undefined) {
        options.memePasMal += x.dmgTotal - dmgTotal;
      }
      dmgDisplay = x.dmgDisplay;
      dmgTotal = x.dmgTotal;
    }
    addToDmgTotal(0, dmgTotal, dmg, expliquer, evt);
    //On trie les DM suppl\xE9mentaires selon leur type
    let dmgParType = {};
    otherDmg.forEach(function(d) {
      if (_.has(dmgParType, d.type)) dmgParType[d.type].push(d);
      else dmgParType[d.type] = [d];
    });
    // Dommages de m\xEAme type que le principal, mais \xE0 part, donc non affect\xE9s par les critiques
    let mainDmgType = dmg.type;
    let dmgExtra = dmgParType[mainDmgType];
    if (dmgExtra && dmgExtra.length > 0 && !immuniseAuType(target, mainDmgType, options.attaquant)) {
      if (dmgCoef > 1) dmgDisplay = "(" + dmgDisplay + ")";
      showTotal = true;
      let count = dmgExtra.length;
      dmgExtra.forEach(function(d) {
        count--;
        if (d.totalSave && d.totalSave.tempete && options.tempeteDeManaIntense) {
          d.totalSave.seuil += d.totalSave.tempete * options.tempeteDeManaIntense;
        }
        if (d.partialSave && d.partialSave.tempete && options.tempeteDeManaIntense) {
          d.partialSave.seuil += d.partialSave.tempete * options.tempeteDeManaIntense;
        }
        partialSave(d, target, false, d.display, d.total, expliquer, evt,
          function(res) {
            if (res) {
              dmgTotal = addToDmgTotal(dmgTotal, res.total, d, expliquer, evt);
              dmgDisplay += "+" + res.dmgDisplay;
            } else {
              dmgTotal = addToDmgTotal(dmgTotal, d.total, d, expliquer, evt);
              dmgDisplay += "+" + d.display;
            }
            if (count === 0) dealDamageAfterDmgExtra(target, mainDmgType, dmgTotal, dmgDisplay, showTotal, dmgParType, dmgExtra, crit, options, evt, expliquer, displayRes);
          });
      });
    } else {
      return dealDamageAfterDmgExtra(target, mainDmgType, dmgTotal, dmgDisplay, showTotal, dmgParType, dmgExtra, crit, options, evt, expliquer, displayRes);
    }
  }

  // Effets quand on rentre en combat
  // attaquant est optionnel
  // exlications doit \xEAtre d\xE9fini
  // ne rajoute pas evt \xE0 l'historique
  // revoie stateCOF.combat, garanti non false
  function entrerEnCombat(attaquant, cibles, explications, evt) {
    let selected = [];
    if (attaquant) {
      selected.push({
        _id: attaquant.token.id
      });
      let attrAttInvisible = tokenAttribute(attaquant, 'tokenInvisible');
      if (attrAttInvisible.length > 0 && attaquant.token.id == attrAttInvisible[0].get('max')) {
        let tokenAttInvisible = getObj('graphic', attrAttInvisible[0].get('current'));
        if (tokenAttInvisible) selected = [{
          _id: tokenAttInvisible.id
        }];
      }
      if (getState(attaquant, 'invisible') && !predicateAsBool(attaquant, 'invisibleEnCombat')) {
        explications.push(nomPerso(attaquant) + " redevient visible");
        setState(attaquant, 'invisible', false, evt);
      }
      if (predicateAsBool(attaquant, 'pacifisme') &&
        !attributeAsBool(attaquant, 'attributDeCombat_pacifismeAnnule')) {
        setTokenAttr(attaquant, 'attributDeCombat_pacifismeAnnule', true, evt);
        sendPerso(attaquant, "perd son pacifisme");
      }
      if (attributeAsBool(attaquant, 'sanctuaire')) {
        explications.push(nomPerso(attaquant) + " met fin aux conditions du sanctuaire");
        removeTokenAttr(attaquant, 'sanctuaire', evt);
      }
    }
    cibles.forEach(function(target) {
      let token = target.token;
      let attrInvisible = tokenAttribute(target, 'tokenInvisible');
      if (attrInvisible.length > 0 && target.token.id == attrInvisible[0].get('max')) {
        let tokenInvisible = getObj('graphic', attrInvisible[0].get('current'));
        if (tokenInvisible) token = tokenInvisible;
      }
      selected.push({
        _id: token.id
      });
    });
    return initiative(selected, evt); //ne recalcule pas l'init
  }

  //capa est le nom d'un pr\xE9dicat. Si le pr\xE9dicat est num\xE9rique, cela donne
  //la limite, sinon la limite est 1
  // retourne
  // - utilisations: les nombre d'utilisations restantes,
  // - nomLimite: le nom de l'attribut qui stoque l'utilisation
  // - attribut: si il y a un attribut, l'attribut en question.
  function testLimiteUtilisationsCapa(perso, capa, unite, msgPlusDispo, msgPasCapa) {
    let limite = predicateAsInt(perso, capa, 0, 1);
    if (limite === 0) {
      if (msgPasCapa) sendPerso(perso, msgPasCapa);
      return;
    }
    let nomLimite = nomLimiteCapa(capa, unite);
    if (nomLimite === undefined) return;
    let utilisations = limite;
    let attribut = tokenAttribute(perso, nomLimite);
    if (attribut.length === 0) {
      attribut = undefined;
    } else {
      attribut = attribut[0];
      utilisations = parseInt(attribut.get('current'));
      if (isNaN(utilisations)) {
        error("Resource pour " + capa + " mal form\xE9e", attribut);
        return;
      }
    }
    if (utilisations < 1) {
      if (msgPlusDispo) {
        sendPerso(perso, msgPlusDispo);
      }
      return;
    }
    return {
      utilisations,
      attribut,
      nomLimite
    };
  }

  function utiliseCapacite(perso, t, evt) {
    evt.attributes = evt.attributes || [];
    if (t.attribut) {
      evt.attributes.push({
        attribute: t.attribut,
        current: t.utilisations
      });
      t.attribut.set('current', t.utilisations - 1);
    } else {
      setTokenAttr(perso, t.nomLimite, t.utilisations - 1, evt);
    }
  }

  //L'argument weaponStats est optionnel
  function critEnAttaque(attaquant, weaponStats, options) {
    let crit = 20;
    if (weaponStats) crit = weaponStats.crit;
    if (isNaN(crit) || crit < 1 || crit > 20) {
      error("Le critique n'est pas un nombre entre 1 et 20", crit);
      crit = 20;
    }
    if (predicateAsBool(attaquant, 'scienceDuCritique') ||
      (!options.distance && !options.sortilege &&
        (predicateAsBool(attaquant, 'morsureDuSerpent') || predicateAsBool(attaquant, 'briseurDOs'))) ||
      (crit == 20 && predicateAsBool(attaquant, 'ecuyer'))) crit -= 1;
    if (options.bonusCritique) crit -= options.bonusCritique;
    if (options.affute) crit -= 1;
    if (options.contact && !weaponStats.armeGauche && predicateAsBool(attaquant, 'frappeChirurgicale'))
      crit -= modCarac(attaquant, 'intelligence');
    let armeTirFatal = predicateAsBool(attaquant, 'tirFatal');
    if (armeTirFatal) {
      if (armeTirFatal === true) armeTirFatal = 'arc';
      if (options[armeTirFatal] || weaponStats[armeTirFatal]) {
        crit -= modCarac(attaquant, 'sagesse');
        options.tirFatal = 1;
        if (predicateAsInt(attaquant, 'voieDeLArcEtDuCheval', 3) > 4)
          options.tirFatal = 2;
      }
    }
    if (options.sortilege) {
      crit -= predicateAsInt(attaquant, 'magieDeCombat', 0, 1);
    }
    if (crit < 2) crit = 2;
    return crit;
  }

  //attaquant peut ne pas avoir de token
  function computeArmeAtkPNJ(attaquant, x) {
    let atk;
    let listeAttaquesPNJ;
    let oatk;
    switch (x) {
      case '@{ATKCAC}':
        let atkcac;
        listeAttaquesPNJ = listAllAttacks(attaquant);
        for (let label in listeAttaquesPNJ) {
          let att = listeAttaquesPNJ[label];
          if (atk === undefined) {
            atk = fieldAsInt(att, 'armeatk', 0);
            oatk = atk;
          }
          let portee = fieldAsInt(att, 'armeportee', 0);
          if (portee > 0) continue;
          let typeat = fieldAsString(att, 'armetypeattaque', 'Naturel');
          switch (typeat) {
            case 'Sortilege':
            case 'Arme de jet':
              break;
            default:
              if (oatk === undefined) oatk = fieldAsInt(att, 'armeatk', 0);
              if (atkcac === undefined) atkcac = oatk;
              if (oatk > atkcac) atkcac = oatk;
          }
        }
        if (atkcac === undefined) {
          if (atk === undefined)
            atkcac = ficheAttributeAsInt(attaquant, 'niveau', 0) + 1 + modCarac(attaquant, 'force');
          else atkcac = atk;
        }
        return atkcac;
      case '@{ATKTIR}':
        let atktir;
        listeAttaquesPNJ = listAllAttacks(attaquant);
        for (let label in listeAttaquesPNJ) {
          let att = listeAttaquesPNJ[label];
          if (atk === undefined) {
            atk = fieldAsInt(att, 'armeatk', 0);
            oatk = atk;
          }
          let portee = fieldAsInt(att, 'armeportee', 0);
          if (portee === 0) continue;
          let typeat = fieldAsString(att, 'armetypeattaque', 'Naturel');
          if (typeat == 'Sortilege') continue;
          if (oatk === undefined) oatk = fieldAsInt(att, 'armeatk', 0);
          if (atktir === undefined) atktir = oatk;
          if (oatk > atktir) atktir = oatk;
        }
        if (atktir === undefined) {
          if (atk === undefined)
            atktir = ficheAttributeAsInt(attaquant, 'niveau', 0) + 1 + modCarac(attaquant, 'dexterite');
          else atktir = atk;
        }
        return atktir;
      case '@{ATKMAG}':
        let atkmag;
        listeAttaquesPNJ = listAllAttacks(attaquant);
        for (let label in listeAttaquesPNJ) {
          let att = listeAttaquesPNJ[label];
          if (atk === undefined) {
            atk = fieldAsInt(att, 'armeatk', 0);
            oatk = atk;
          }
          let typeat = fieldAsString(att, 'armetypeattaque', 'Naturel');
          if (typeat != 'Sortilege') continue;
          if (oatk === undefined) oatk = fieldAsInt(att, 'armeatk', 0);
          if (atkmag === undefined) atkmag = oatk;
          if (oatk > atkmag) atkmag = oatk;
        }
        if (atkmag === undefined) {
          if (atk === undefined)
            atkmag = ficheAttributeAsInt(attaquant, 'niveau', 0) + 1 + modCarac(attaquant, 'sagesse');
          else atkmag = atk;
        }
        atkmag += predicateAsInt(attaquant, 'bonusAttaqueMagique', 0);
        return atkmag;
      default:
        return x;
    }
  }

  //attaquant peut ne pas avoir de token
  function computeArmeAtk(attaquant, x) {
    if (x === undefined) return '';
    if (persoEstPNJ(attaquant)) return computeArmeAtkPNJ(attaquant, x);
    let attDiv;
    let attCar;
    switch (x) {
      case '@{ATKCAC}':
        attDiv = ficheAttributeAsInt(attaquant, 'ATKCAC_DIV', 0);
        if (persoArran(attaquant)) {
          attDiv += ficheAttributeAsInt(attaquant, 'mod_atkcac', 0);
          attCar = '@{FOR}';
        } else {
          attCar = getAttrByName(attaquant.charId, 'ATKCAC_CARAC');
        }
        break;
      case '@{ATKTIR}':
        attDiv = ficheAttributeAsInt(attaquant, 'ATKTIR_DIV', 0);
        if (persoArran(attaquant)) {
          attDiv += ficheAttributeAsInt(attaquant, 'mod_atktir', 0);
          attCar = '@{DEX}';
        } else {
          attCar = getAttrByName(attaquant.charId, 'ATKTIR_CARAC');
        }
        break;
      case '@{ATKMAG}':
        attDiv = ficheAttributeAsInt(attaquant, 'ATKMAG_DIV', 0);
        if (persoArran(attaquant)) {
          attDiv += ficheAttributeAsInt(attaquant, 'mod_atkmag', 0);
          attCar = '@{INT}';
        } else {
          attCar = getAttrByName(attaquant.charId, 'ATKMAG_CARAC');
        }
        attDiv += predicateAsInt(attaquant, 'bonusAttaqueMagique', 0);
        break;
      default:
        return x;
    }
    attCar = computeCarValue(attaquant, attCar);
    if (attCar === undefined) return x;
    return attCar + ficheAttributeAsInt(attaquant, 'niveau', 1) + attDiv;
  }

  //Retourne le label de l'attaque \xE0 l'arme de jet.
  function estAussiArmeDeJet(options) {
    if (options.startsWith('-')) options = ' ' + options;
    options = options.split(' --');
    for (let opt of options) {
      opt = opt.trim();
      if (opt === '') continue;
      opt = opt.split(' ');
      if (opt.length < 2) continue;
      if (opt[0] == 'aussiArmeDeJet') return opt[1];
    }
    return;
  }

  function degainerArmeLancee(attaquant, attackLabel, evt) {
    let arme = armesEnMain(attaquant);
    if (arme && arme.options && estAussiArmeDeJet(arme.options) == attackLabel) {
      degainerArme(attaquant, '', evt, {
        seulementDroite: true
      });
    } else if (attaquant.armeGauche && attaquant.armeGauche.options && estAussiArmeDeJet(attaquant.armeGauche.options) == attackLabel) {
      degainerArme(attaquant, '', evt, {
        gauche: true
      });
    }
  }

  function increaseTenacite(attaquant, target, evt) {
    if (!predicateAsBool(attaquant, 'tenacite')) return;
    let attr = 'attributDeCombat_tenaciteDe' + nomPerso(attaquant);
    let bonus = attributeAsInt(target, attr, 0);
    if (bonus > 2) return;
    if (bonus === 0) bonus = 2;
    else bonus = 5;
    setTokenAttr(target, attr, bonus, evt);
  }

  function resetTenacite(attaquant, target, evt) {
    if (!predicateAsBool(attaquant, 'tenacite')) return;
    let attr = tokenAttribute(target, 'attributDeCombat_tenaciteDe' + nomPerso(attaquant));
    if (attr.length === 0) return;
    evt.deletedAttributes = evt.deletedAttributes || [];
    deleteAttribute(attr[0], evt);
  }

  //attaquant doit avoir un champ name
  function attackExpression(attaquant, nbDe, dice, crit, plusFort, weaponStats) {
    let de = computeDice(attaquant, {
      nbDe: nbDe,
      dice: dice,
      plusFort: plusFort
    });
    let attackRollExpr = "[[" + de + "cs>" + crit + "cf1]]";
    let attSkillDiv = weaponStats.attSkillDiv;
    if (isNaN(attSkillDiv)) attSkillDiv = 0;
    let attSkillDivTxt = "";
    if (attSkillDiv > 0) attSkillDivTxt = " + " + attSkillDiv;
    else if (attSkillDiv < 0) attSkillDivTxt += attSkillDiv;
    let attackSkillExpr = addOrigin(attaquant.name, "[[" + computeArmeAtk(attaquant, weaponStats.attSkill) + attSkillDivTxt + "]]");
    return attackRollExpr + " " + attackSkillExpr;
  }

  function effetPoison(poisonAttr, seuil, attaquant, explications, options) {
    let defPoison = poisonAttr.get('current');
    let index = defPoison.indexOf(' ');
    let value = 0;
    let typePoison = 'rapide';
    if (index < 0) {
      value = defPoison;
    } else {
      typePoison = defPoison.substring(0, index);
      value = defPoison.substring(index + 1);
    }
    if (typePoison == 'rapide') {
      attaquant.additionalDmg.push({
        type: 'poison',
        value,
        partialSave: {
          carac: 'CON',
          seuil
        }
      });
    } else if (typePoison == 'affaiblissant') {
      options.effets = options.effets || [];
      if (value == 0) {
        options.effets.push({
          effet: 'poisonAffaiblissant',
          typeDmg: 'poison',
          message: messageEffetCombat.poisonAffaiblissant,
          save: {
            carac: 'CON',
            seuil
          },
        });
      } else {
        let exprDuree = parseDice(value, 'dur\xE9e');
        let duree = randomInteger(6);
        if (exprDuree) {
          if (exprDuree.nbDe <= 0) {
            if (exprDuree.bonus > 0) duree = exprDuree.bonus;
          } else {
            duree = rollDePlus(exprDuree.dice, {
              nbDes: exprDuree.nbDes,
              bonus: exprDuree.bonus
            }).val;
          }
        }

        options.effets.push({
          effet: 'poisonAffaiblissantLatent',
          typeDmg: 'poison',
          duree,
          message: messageOfEffetTemp('poisonAffaiblissantLatent'),
          save: {
            carac: 'CON',
            seuil
          },
        });
      }
    } else {
      error("Type de poison " + typePoison + " non reconnu.", poisonAttr);
    }
    explications.push("L'arme est empoisonn\xE9e");
    return defPoison;
  }

  function effetPoisonSurMunitions(poisonAttr, attaquant, explications, options, evt) {
    if (poisonAttr.length > 0) {
      poisonAttr = poisonAttr[0];
      let infosPoisonMunitions = poisonAttr.get('max');
      let index = infosPoisonMunitions.indexOf(' ');
      let seuil = parseInt(infosPoisonMunitions.substring(0, index));
      let nombreMunitionsEmpoisonnees = parseInt(infosPoisonMunitions.substring(index + 1));
      if (!isNaN(seuil) && !isNaN(nombreMunitionsEmpoisonnees) && nombreMunitionsEmpoisonnees > 0) {
        let defPoison = effetPoison(poisonAttr, seuil, attaquant, explications, options);
        explications.push("L'arme est empoisonn\xE9e");
        if (nombreMunitionsEmpoisonnees == 1) {
          evt.deletedAttributes = evt.deletedAttributes || [];
          evt.deletedAttributes.push(poisonAttr);
          poisonAttr.remove();
        } else {
          evt.attributes.push({
            attribute: poisonAttr,
            current: defPoison,
            max: infosPoisonMunitions
          });
          poisonAttr.set('max', seuil + ' ' + (nombreMunitionsEmpoisonnees - 1));
        }
      }
    }
  }

  //N'ajoute pas evt \xE0 l'historique
  function resoudreAttaque(attaquant, cibles, attackLabel, weaponName, weaponStats, playerId, pageId, evt, explications, options, chargesArme) {
    let attackingCharId = attaquant.charId;
    let attackingToken = attaquant.token;
    let attackerTokName = nomPerso(attaquant);
    attaquant.additionalDmg = [...options.additionalDmg]; // Reset du calcul des dommages additionnels li\xE9s \xE0 l'attaquant
    let sujetAttaquant = onGenre(attaquant, 'il', 'elle');
    if (options.contact) {
      //Prise en compte du corps \xE9l\xE9mentaire
      let typeCorpsElem = predicateAsBool(attaquant, 'corpsElementaire');
      if (typeCorpsElem && typeCorpsElem !== true) {
        let nbDes = predicateAsInt(attaquant, 'nbCorpsElementaire', 1);
        attaquant.additionalDmg.push({
          type: typeCorpsElem,
          value: nbDes + 'd6',
        });
        explications.push("Corps de " + typeCorpsElem + " => +" + nbDes + "d6 DM");
      }
    }
    const estMook = attackingToken.get('bar1_link') === '';
    // Les armes de jet
    if (weaponStats.armeDeJet && !estMook && !(options.ricochets && options.ricochets.cibles.length > 0)) {
      if (weaponStats.nbArmesDeJet < 1) {
        sendPerso(attaquant, "plus de " + weaponName + " \xE0 lancer.");
        return;
      }
      let attrName = weaponStats.prefixe + 'armejetqte';
      let attr = findObjs({
        _type: 'attribute',
        _characterid: attackingCharId,
        name: attrName
      }, {
        caseInsensitive: true
      });
      evt.attributes = evt.attributes || [];
      let max = 1;
      if (attr.length > 0) {
        attr = attr[0];
        if (attr.length > 1) {
          error("Plus d'un attribut pour la quantit\xE9 d'armes de jet", attr);
          attr[1].remove();
        }
        max = parseInt(attr.get('max'));
        if (isNaN(max) || max < 1) {
          error("Maximum de " + weaponName + " mal form\xE9, v\xE9rifier sur la fiche", attr);
          max = 1;
        }
        evt.attributes.push({
          attribute: attr,
          current: weaponStats.nbArmesDeJet,
          max: max
        });
      } else {
        attr = createObj('attribute', {
          characterid: attackingCharId,
          name: attrName,
          current: 1,
          max: 1
        });
        evt.attributes.push({
          attribute: attr,
        });
      }
      //On cherche si l'arme de jet est empoison\xE9e
      let poisonAttr = tokenAttribute(attaquant, 'enduitDePoison_' + attackLabel);
      effetPoisonSurMunitions(poisonAttr, attaquant, explications, options, evt);
      let restant = weaponStats.nbArmesDeJet;
      if (randomInteger(100) < weaponStats.tauxDePerte) {
        if (weaponStats.tauxDePerte < 100)
          explications.push(weaponName + " n'est pas r\xE9cup\xE9rable");
        attr.set('max', max - 1);
        options.armeDeJetPerdue = true;
      }
      restant--;
      attr.set('current', restant);
      if (!options.armeDeJetPerdue) { //pr\xE9pare pour un \xE9ventuel retour en main
        options.attrArmeDeJet = {
          attribute: attr,
          restant: restant
        };
      } else {
        if (restant === 0) {
          degainerArmeLancee(attaquant, attackLabel, evt);
        }
        explications.push("Il reste " + restant + " " + weaponName + " \xE0 " + attackerTokName);
      }
    }
    if (options.aussiArmeDeJet && !estMook) {
      let armeAssociee = getWeaponStats(attaquant, options.aussiArmeDeJet);
      if (armeAssociee && armeAssociee.armeDeJet) {
        if (armeAssociee.nbArmesDeJet < 1) {
          sendPerso(attaquant, "a d\xE9j\xE0 lanc\xE9 tous ses " + weaponName);
          return;
        }
      } else {
        error("L'arme de label " + options.aussiArmeDeJet + " n'est pas une arme de jet, option ignor\xE9e", armeAssociee);
      }
    }
    // Munitions
    if (options.munition) {
      if (estMook) {
        error("Les munitions ne sont pas support\xE9es pour les tokens qui ne sont pas li\xE9es \xE0 un personnage", attackingToken);
      }
      if (options.munition.nom) { //Ancienne variante, obsol\xE8te depuis mars 2023
        let munitionsAttr = findObjs({
          _type: 'attribute',
          _characterid: attackingCharId,
          name: 'munition_' + options.munition.nom
        });
        if (munitionsAttr.length === 0) {
          sendPerso(attaquant, ": Pas de munition nomm\xE9e " + options.munition.nom);
          return;
        }
        munitionsAttr = munitionsAttr[0];
        let munitions = munitionsAttr.get('current');
        if (munitions < 1 || (options.tirDouble && munitions < 2)) {
          sendPerso(attaquant,
            "ne peut pas utiliser cette attaque, car " + sujetAttaquant +
            " n'a plus de " + options.munition.nom.replace(/_/g, ' '));
          return;
        }
        let munitionsMax = parseInt(munitionsAttr.get('max'));
        if (isNaN(munitionsMax)) {
          error("Attribut de munitions mal form\xE9", munitionsMax);
          return;
        }
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: munitionsAttr,
          current: munitions,
          max: munitionsMax
        });
        //On cherche si la munition est empoisonn\xE9e
        let poisonAttr = tokenAttribute(attaquant, 'enduitDePoison_munition_' + options.munition.nom);
        effetPoisonSurMunitions(poisonAttr, attaquant, explications, options, evt);
        munitions--;
        if (randomInteger(100) < options.munition.taux) munitionsMax--;
        if (options.tirDouble) {
          munitions--;
          if (randomInteger(100) < options.munition.taux) munitionsMax--;
        }
        explications.push("Il reste " + munitions + " " +
          options.munition.nom.replace(/_/g, ' ') + " \xE0 " + attackerTokName);
        munitionsAttr.set('current', munitions);
        munitionsAttr.set('max', munitionsMax);
      } else { //Utilisation d'une munition de la fiche
        let m = options.munition;
        let typeMunition = fieldAsString(m, 'typemunition', 'Fl\xE8che');
        let nom = fieldAsString(m, 'nommunition', typeMunition);
        let munitions = fieldAsInt(m, 'qtemunition', 1);
        if (munitions < 1 || (options.tirDouble && munitions < 2)) {
          sendPerso(attaquant,
            "ne peut pas utiliser cette attaque, car " + sujetAttaquant +
            " n'a plus de " + nom);
          return;
        }
        let label = fieldAsString(m, 'labelmunition', '0');
        //On cherche si la munition est empoisonn\xE9e
        let poisonAttr = tokenAttribute(attaquant, 'enduitDePoison_munition_' + label);
        effetPoisonSurMunitions(poisonAttr, attaquant, explications, options, evt);
        let munitionsMax = fieldAsInt(m, 'qtemunition_max', munitions);
        munitions--;
        let perte = 0;
        let taux = fieldAsInt(m, 'tauxmunition', 100);
        if (randomInteger(100) < taux) {
          munitionsMax--;
          perte++;
        }
        if (options.tirDouble) {
          munitions--;
          if (randomInteger(100) < taux) {
            munitionsMax--;
            perte++;
          }
        }
        let msgm = "Il ";
        if (munitions === 0) {
          msgm += "ne reste plus de ";
        } else {
          msgm += "reste " + munitions + " ";
        }
        msgm += nom + " \xE0 " + attackerTokName;
        if (taux < 100 && perte > 0) msgm += ", et la munition utilis\xE9e n'est pas r\xE9cup\xE9rable";
        explications.push(msgm);
        evt.attributes = evt.attributes || [];
        let name = m.prefixe + 'qtemunition';
        let attrQte = findObjs({
          _type: 'attribute',
          _characterid: attackingCharId,
          name
        }, {
          caseInsensitive: true
        });
        if (attrQte.length > 0) {
          attrQte = attrQte[0];
          evt.attributes.push({
            attribute: attrQte,
            current: munitions,
            max: munitionsMax
          });
          attrQte.set('current', munitions);
          attrQte.set('max', munitionsMax);
        } else {
          attrQte = createObj('attribute', {
            characterid: attackingCharId,
            name,
            current: munitions,
            max: munitionsMax
          });
          evt.attributes.push({
            attribute: attrQte,
          });
        }
      }
    }
    // Armes charg\xE9es
    if (options.semonce === undefined && options.tirDeBarrage === undefined) {
      if (attackLabel && weaponStats && weaponStats.charge) {
        let currentCharge = 0;
        if (chargesArme.length > 0) {
          currentCharge = parseInt(chargesArme[0].get('current'));
        }
        if (isNaN(currentCharge) || currentCharge < 1) {
          sendPerso(attaquant, "ne peut pas attaquer avec " + weaponName + " car elle n'est pas charg\xE9e");
          return;
        }
        if (options.tirDouble &&
          (!options.tirDouble.stats || options.tirDouble.label == attackLabel) &&
          currentCharge < 2) {
          sendPerso(attaquant,
            "ne peut pas faire de tir double avec ses" + weaponName + "s car " +
            sujetAttaquant + " n'en a pas au moins 2 charg\xE9es");
          return;
        }
        evt.attributes = evt.attributes || [];
        if (attackLabel && options.grenaille) {
          let chargesGrenaille = tokenAttribute(attaquant, 'chargeGrenaille_' + attackLabel);
          if (chargesGrenaille.length > 0) {
            let currentChargeGrenaille = parseInt(chargesGrenaille[0].get('current'));
            if (isNaN(currentChargeGrenaille) || currentChargeGrenaille < 1) {
              sendPerso(attaquant, "ne peut pas attaquer avec " + weaponName + " car elle n'est pas charg\xE9e en grenaille");
              return;
            }
            if (options.tirDouble &&
              (!options.tirDouble.stats || options.tirDouble.label == attackLabel) &&
              currentChargeGrenaille < 2) {
              sendPerso(attaquant,
                "ne peut pas faire de tir double de grenaille avec ses" + weaponName + "s car " +
                sujetAttaquant + " n'en a pas au moins 2 charg\xE9es de grenaille");
              return;
            }
            evt.attributes.push({
              attribute: chargesGrenaille[0],
              current: currentChargeGrenaille
            });
            if (options.tirDouble &&
              (!options.tirDouble.stats || options.tirDouble.label == attackLabel)
            ) currentChargeGrenaille -= 2;
            else currentChargeGrenaille -= 1;
            chargesGrenaille[0].set('current', currentChargeGrenaille);
          }
        }
        evt.attributes.push({
          attribute: chargesArme[0],
          current: currentCharge
        });
        if (options.tirDouble &&
          (!options.tirDouble.stats || options.tirDouble.label == attackLabel)) currentCharge -= 2;
        else currentCharge -= 1;
        //Si l'arme n'est plus charg\xE9e, on peut perdre le bonus d'initiative
        if (currentCharge === 0 &&
          bonusPlusViteQueSonOmbre(attaquant, weaponStats)) {
          updateNextInit(attaquant);
        }
        chargesArme[0].set('current', currentCharge);
      }
      if (options.tirDouble && options.tirDouble.label && options.tirDouble.label != attackLabel) {
        let secondLabel = options.tirDouble.label;
        let secondNom = options.tirDouble.stats.name;
        let chargesSecondeArme = findObjs({
          _type: 'attribute',
          _characterid: attackingCharId,
          name: "charge_" + secondLabel
        });
        if (chargesSecondeArme.length > 0) {
          let currentCharge2 = parseInt(chargesSecondeArme[0].get('current'));
          if (isNaN(currentCharge2) || currentCharge2 < 1) {
            sendPerso(attaquant, "ne peut pas faire de tir double avec " + secondNom + " car ce n'est pas charg\xE9");
            return;
          }
          evt.attributes = evt.attributes || [];
          if (options.grenaille) {
            let chargesGrenaille2 = tokenAttribute(attaquant, 'chargeGrenaille_' + secondLabel);
            if (chargesGrenaille2.length > 0) {
              let currentChargeGrenaille2 = parseInt(chargesGrenaille2[0].get('current'));
              if (isNaN(currentChargeGrenaille2) || currentChargeGrenaille2 < 1) {
                sendPerso(attaquant, "ne peut pas faire de tir double avec " + secondNom + " car ce n'est pas charg\xE9 en grenaille");
                return;
              }
              evt.attributes.push({
                attribute: chargesGrenaille2[0],
                current: currentChargeGrenaille2
              });
              currentChargeGrenaille2 -= 1;
              chargesGrenaille2[0].set('current', currentChargeGrenaille2);
            }
          }
          evt.attributes.push({
            attribute: chargesSecondeArme[0],
            current: currentCharge2
          });
          chargesArme[0].set('current', currentCharge2 - 1);
        }
      }
    }
    if (limiteRessources(attaquant, options, attackLabel, weaponName, evt, explications)) {
      return;
    }
    // Effets quand on rentre en combat
    entrerEnCombat(attaquant, cibles, explications, evt);
    // On commence par le jet d'attaque de base : juste le ou les d\xE9s d'attaque
    // et le modificateur d'arme et de caract\xE9ritiques qui apparaissent dans
    // la description de l'attaque. Il faut quand m\xEAme tenir compte des
    // chances de critique
    let crit = critEnAttaque(attaquant, weaponStats, options);
    let dice = 20;
    let malusAttaque = 0;
    if (!options.auto) {
      if (estAffaibli(attaquant)) {
        if (predicateAsBool(attaquant, 'insensibleAffaibli')) {
          malusAttaque = -2;
          explications.push("Attaquant affaibli, mais insensible => -2 en Attaque");
        } else {
          dice = 12;
          explications.push("Attaquant affaibli => D12 au lieu de D20 en Attaque");
        }
      } else if (getState(attaquant, 'immobilise')) {
        dice = 12;
        explications.push("Attaquant immobilis\xE9 => D12 au lieu de D20 en Attaque");
      } else if (attributeAsBool(attaquant, 'mortMaisNAbandonnePas')) {
        dice = 12;
        explications.push("Attaquant mort mais n'abandonne pas => D12 au lieu de D20 en Attaque");
      } else {
        let ebriete = attributeAsInt(attaquant, 'niveauEbriete', 0);
        if (ebriete > 0) {
          if (options.distance || options.sortilege || ebriete > 1) {
            dice = 12;
            if (ebriete > 3) ebriete = 3;
            explications.push("Attaquant " + niveauxEbriete[ebriete] + " => D12 au lieu de D20 en Attaque");
          }
        }
      }
    }
    if (options.avecd12) {
      dice = 12;
      if (options.avecd12.crit) crit = Math.floor(crit / 2) + 3;
    }
    let nbDe = 1;
    let plusFort = true;
    if (options.avantage !== undefined) {
      if (options.avantage > 0) nbDe = options.avantage;
      else {
        nbDe = 2 - options.avantage; //d\xE9savantage
        plusFort = false;
      }
    }
    if (options.sortilege && (options.rituelAssure || attributeAsBool(attaquant, 'rituelAssure'))) {
      options.rituelAssure = true;
      finDEffetDeNom(attaquant, 'rituelAssure', evt);
      if (plusFort) nbDe++;
      else if (nbDe > 1) nbDe--;
      else {
        plusFort = true;
        nbDe = 2;
      }
    }
    // toEvaluateAttack inlines
    // 0: attack roll
    // 1: attack skill expression
    // 2: d\xE9 de poudre
    let toEvaluateAttack =
      attackExpression(attaquant, nbDe, dice, crit, plusFort, weaponStats);
    if (options.poudre) toEvaluateAttack += " [[1d20]]";
    try {
      sendChat('', toEvaluateAttack, function(resAttack) {
        let rollsAttack = resAttack[0];
        if (options.rolls && options.rolls.attack)
          rollsAttack = options.rolls.attack;
        let afterEvaluateAttack = rollsAttack.content.split(' ');
        let attRollNumber = rollNumber(afterEvaluateAttack[0]);
        let attSkillNumber = rollNumber(afterEvaluateAttack[1]);
        let d20roll = rollsAttack.inlinerolls[attRollNumber].results.total;
        if (stateCOF.foudreDuTemps) foudreDuTemps(attaquant, d20roll);
        let attSkill = rollsAttack.inlinerolls[attSkillNumber].results.total;
        evt.type = 'Attaque';
        evt.succes = true;
        evt.action.playerId = playerId;
        evt.action.attaquant = attaquant;
        evt.action.cibles = cibles;
        evt.action.weaponStats = weaponStats;
        evt.action.rolls = evt.action.rolls || {};
        evt.action.rolls.attack = rollsAttack;
        // debut de la partie affichage
        let action = "<b>Arme</b> : ";
        if (options.sortilege) action = "<b>Sort</b> : ";
        let label_type = BS_LABEL_INFO;
        let target = cibles[0];
        if (options.aoe || cibles.length > 1) {
          target = undefined;
          label_type = BS_LABEL_WARNING;
        }
        action += "<span style='" + BS_LABEL + " " + label_type + "; text-transform: none; font-size: 100%;'>" + weaponName + "</span>";
        let display = startFramedDisplay(playerId, action, attaquant, {
          perso2: target,
          chuchote: options.secret,
          retarde: options.secret,
          auto: options.auto || options.ouvertureMortelle
        });
        // Cas des armes \xE0 poudre
        if (options.poudre && !predicateAsBool(attaquant, 'chimiste')) {
          let poudreNumber = rollNumber(afterEvaluateAttack[2]);
          let dePoudre = rollsAttack.inlinerolls[poudreNumber].results.total;
          explications.push(
            "D\xE9 de poudre : " + buildinline(rollsAttack.inlinerolls[poudreNumber]));
          if (dePoudre === 1) {
            evt.succes = false;
            if (d20roll === 1) {
              explications.push(
                weaponName + " explose ! L'arme est compl\xE8tement d\xE9truite");
              sendChat("", "[[2d6]]", function(res) {
                let rolls = res[0];
                let explRoll = rolls.inlinerolls[0];
                let r = {
                  total: explRoll.results.total,
                  type: 'normal',
                  display: buildinline(explRoll, 'normal')
                };
                dealDamage(attaquant, r, [], evt, false, options, explications,
                  function(dmgDisplay, dmg, dmDrains) {
                    let dmgMsg =
                      "<b>Dommages pour " + attackerTokName + " :</b> " +
                      dmgDisplay;
                    addLineToFramedDisplay(display, dmgMsg);
                    finaliseDisplay(display, explications, evt, attaquant, cibles, options);
                  });
              });
            } else {
              explications.push(
                "La poudre explose dans " + weaponName +
                ". L'arme est inutilisable jusqu'\xE0 la fin du combat");
              sendChat("", "[[1d6]]", function(res) {
                let rolls = res[0];
                let explRoll = rolls.inlinerolls[0];
                let r = {
                  total: explRoll.results.total,
                  type: 'normal',
                  display: buildinline(explRoll, 'normal')
                };
                dealDamage(attaquant, r, [], evt, false, options, explications,
                  function(dmgDisplay, dmg, dmDrains) {
                    let dmgMsg =
                      "<b>Dommages pour " + attackerTokName + " :</b> " +
                      dmgDisplay;
                    addLineToFramedDisplay(display, dmgMsg);
                    finaliseDisplay(display, explications, evt, attaquant, cibles, options);
                  });
              });
            }
            return;
          } else if (d20roll == dePoudre) {
            evt.succes = false;
            addLineToFramedDisplay(display,
              "<b>Attaque :</b> " +
              buildinline(rollsAttack.inlinerolls[attRollNumber]));
            explications.push(weaponName + " fait long feu, le coup ne part pas");
            finaliseDisplay(display, explications, evt, attaquant, cibles, options);
            return;
          }
        }
        if (!options.auto && d20roll > 14) {
          if (predicateAsBool(attaquant, 'saisirEtBroyer')) {
            options.saisirEtBroyer = true;
          } else if (predicateAsBool(attaquant, 'projection') && !options.sortilege) {
            options.projection = true;
          }
        }
        //Modificateurs en Attaque qui ne d\xE9pendent pas de la cible
        let attBonusCommun = 0;
        if (!options.auto) {
          attBonusCommun =
            bonusAttaqueA(attaquant, weaponName, evt, explications, options);
          attBonusCommun += malusAttaque;
        } else { //calcul des options affectant les DM
          bonusDMA(attaquant, weaponName, evt, explications, options);
        }
        if (options.traquenard) {
          if (attributeAsBool(attaquant, 'traquenardImpossible')) {
            sendPerso(attaquant, "ne peut pas faire de traquenard, car ce n'est pas sa premi\xE8re attaque du combat");
            return;
          }
          options.traquenard = persoInit(attaquant, evt);
        }
        if (predicateAsBool(attaquant, 'traquenard') && !attributeAsBool(attaquant, 'traquenardImpossible')) {
          setTokenAttr(attaquant, 'traquenardImpossible', true, evt);
        }
        if (options.feinte) explications.push("Mais c'\xE9tait une feinte...");
        let mainDmgType = options.type || 'normal';
        if (options.sortilege) options.ignoreObstacles = true;
        let echecCritique;
        //Calcul des cibles touch\xE9es
        //(et on ajuste le jet pour la triche)
        let ciblesTouchees = [];
        let count = cibles.length;
        cibles.forEach(function(target) {
          // reset les champs de target qui vont \xEAtre recalcul\xE9s
          target.additionalDmg = [];
          target.effets = [];
          target.dmgCoef = 0;
          target.critCoef = 0;
          target.diviseDmg = 1;
          if (attributeAsBool(attaquant, 'menaceManoeuvre(' + target.token.id + ')')) {
            explications.push(nomPerso(attaquant) + " attaque " + nomPerso(target) + " malgr\xE9 la menace. " + nomPerso(target) + " a droit \xE0 une attaque au contact gratuite.");
            removeTokenAttr(attaquant, 'menaceManoeuvre(' + target.token.id + ')', evt);
            setTokenAttr(attaquant, 'attaqueMalgreMenace(' + target.token.id + ')', 1, evt);
          } else if (attributeAsBool(attaquant, 'menaceManoeuvre(' + target.token.id + ',crit)')) {
            explications.push(nomPerso(attaquant) + " attaque " + nomPerso(target) + " malgr\xE9 la menace. " + nomPerso(target) + " a droit \xE0 une attaque au contact gratuite (DM x 2 !).");
            removeTokenAttr(attaquant, 'menaceManoeuvre(' + target.token.id + ',crit)', evt);
            setTokenAttr(attaquant, 'attaqueMalgreMenace(' + target.token.id + ')', 2, evt);
          }
          if (predicateAsBool(attaquant, 'dragonInvincible')) {
            let perteDeSubstance = predicateAsInt(target, 'perteDeSubstance', 0);
            if (perteDeSubstance > 0) target.perteDeSubstance = perteDeSubstance;
          }
          evalITE(attaquant, target, d20roll, options, 0, evt, explications, options, function() {
            target.ignoreTouteRD = target.ignoreTouteRD || options.ignoreTouteRD;
            target.ignoreRD = target.ignoreRD || options.ignoreRD;
            target.ignoreMoitieRD = target.ignoreMoitieRD || options.ignoreMoitieRD;
            target.tempDmg = target.tempDmg || options.tempDmg;
            target.enflamme = target.enflamme || options.enflamme;
            target.malediction = target.malediction || options.malediction;
            target.pietine = target.pietine || options.pietine;
            target.percute = target.percute || options.percute;
            target.maxDmg = target.maxDmg || options.maxDmg;
            target.kiai = target.kiai || options.kiai;
            //Les bonus d'attaque qui d\xE9pendent de la cible
            let bad = 0;
            if (!options.auto)
              bad = bonusAttaqueD(attaquant, target, weaponStats.portee, pageId, evt, target.messages, options);
            else if (!options.pasDeDmg)
              bonusDMD(attaquant, target, weaponStats.portee, pageId, evt, target.messages, options);
            let amm = 'attaqueMalgreMenace(' + attaquant.token.id + ')';
            if (options.contact && cibles.length == 1) {
              if (attributeAsBool(target, amm)) {
                target.messages.push('Attaque automatique suite \xE0 une menace ignor\xE9e');
                options.auto = true;
                if (attributeAsInt(target, amm, 1) > 1) options.dmFoisDeux = true;
                target.additionalDmg.push({
                  type: mainDmgType,
                  value: '1d6'
                });
                removeTokenAttr(target, amm, evt);
              }
            }
            let attBonus = attBonusCommun + bad;
            if (options.traquenard) {
              let initTarg = persoInit(target, evt);
              if (options.traquenard >= initTarg) {
                attBonus += 2;
                target.additionalDmg.push({
                  type: mainDmgType,
                  value: '2' + options.d6
                });
                target.messages.push(attackerTokName + " fait un traquenard \xE0 " + nomPerso(target));
              } else {
                target.messages.push(attackerTokName + " n'est pas assez rapide pour faire un traquenard \xE0 " + nomPerso(target));
              }
            }
            let defautCuirasse =
              tokenAttribute(target, 'defautDansLaCuirasse_' + attackerTokName);
            target.crit = crit;
            if (defautCuirasse.length > 0) {
              target.defautCuirasse = true;
              if (target.crit > 2) target.crit -= 1;
            }
            //Defense de la cible
            let defense = 0;
            if (!options.auto) defense = defenseOfPerso(attaquant, target, pageId, evt, options);
            let interchange;
            if (options.aoe === undefined) {
              interchange = interchangeable(attackingToken, target, pageId);
              if (interchange.result) {
                if (reglesOptionelles.divers.val.interchangeable_attaque.val) {
                  defense += 2;
                } else {
                  defense += 5;
                }
              }
            }
            if (target.msgEsquiveFatale) {
              target.messages.push(target.msgEsquiveFatale);
            }
            if (options.etreinteImmole && attributeAsBool(target, 'etreinteImmolePar')) {
              options.auto = true;
              target.etreinteImmole = true;
            }
            let touche = true;
            let critique = false;
            // Calcule si touch\xE9, et les messages de d\xE9gats et attaque
            if (options.auto) {
              addAttackSound("soundAttackSucces", weaponStats.divers, options);
            } else if (!options.interposer) {
              let triche = options.triche || options.interventionDivine ||
                weaponStats.attaquePaire || weaponStats.attaqueImpaire;
              if (triche) {
                switch (triche) {
                  case "rate":
                    if (d20roll >= target.crit) {
                      if (target.crit < 2) d20roll = 1;
                      else d20roll = randomInteger(target.crit - 1);
                    }
                    if ((d20roll + attSkill + attBonus) >= defense) {
                      let maxd20roll = defense - attSkill - attBonus - 1;
                      if (maxd20roll >= target.crit) maxd20roll = target.crit - 1;
                      if (maxd20roll < 2) d20roll = 1;
                      else d20roll = randomInteger(maxd20roll);
                    }
                    break;
                  case "touche":
                    if (d20roll == 1) d20roll = randomInteger(dice - 1) + 1;
                    if ((d20roll + attSkill + attBonus) < defense) {
                      let mind20roll = defense - attSkill - attBonus - 1;
                      if (mind20roll < 1) mind20roll = 1;
                      if (mind20roll >= dice) d20roll = dice;
                      else d20roll = randomInteger(dice - mind20roll) + mind20roll;
                    }
                    break;
                  case "critique":
                    if (d20roll < target.crit) {
                      if (target.crit <= dice) d20roll = randomInteger(dice - target.crit + 1) + target.crit - 1;
                      else d20roll = dice;
                    }
                    break;
                  case "echecCritique":
                    if (d20roll > 1) d20roll = 1;
                    break;
                  case 'pasDEchecCritique':
                    if (d20roll == 1) d20roll = randomInteger(dice - 1) + 1;
                    break;
                  default:
                    if (triche !== true) error("Option inconnue", triche);
                }
                if (d20roll % 2 == 0) {
                  if (weaponStats.attaqueImpaire) {
                    d20roll -= 1;
                  }
                } else if (weaponStats.attaquePaire) {
                  d20roll += 1;
                }
                // now adjust the roll
                let attackInlineRoll = rollsAttack.inlinerolls[attRollNumber];
                attackInlineRoll.results.total = d20roll;
                attackInlineRoll.results.rolls.forEach(function(roll) {
                  if (roll.type == 'R' && roll.results.length == 1) {
                    roll.results[0].v = d20roll;
                  }
                });
              }
              let targetd20roll = d20roll;
              if (target.chatimentDuMale) {
                target.chatimentDuMaleRoll = target.chatimentDuMaleRoll || randomInteger(dice);
                target.chatimentDuMaleLowRoll = target.chatimentDuMaleRoll;
                target.messages.push("B\xE9n\xE9diction de Ma\xEBdra => relance \xE0 " + target.chatimentDuMaleRoll + " du jet d'attaque contre un m\xE2le");
                if (target.chatimentDuMaleRoll > targetd20roll) {
                  targetd20roll = target.chatimentDuMaleRoll;
                  target.chatimentDuMaleLowRoll = target.d20roll;
                }
              }
              let attackRoll = targetd20roll + attSkill + attBonus;
              target.attackRoll = attackRoll;
              let attackResult = '';
              let paralyse = false;
              if (getState(target, 'paralyse')) {
                paralyse = true;
                if (!options.attaqueAssuree)
                  target.messages.push("Cible paralys\xE9e => r\xE9ussite critique automatique");
              } else if (getState(target, 'mort')) {
                paralyse = true;
                if (!options.attaqueAssuree)
                  target.messages.push("Cible inconsciente => r\xE9ussite critique automatique");
              }
              if (targetd20roll >= 15) {
                if (predicateAsBool(attaquant, 'champion'))
                  options.champion = true;
                if (options.contact) {
                  if (predicateAsBool(attaquant, 'agripper') || options.peutAgripper)
                    options.agripper = true;
                  if (predicateAsBool(attaquant, 'devorer'))
                    options.devorer = true;
                  if (predicateAsBool(attaquant, 'gober'))
                    options.gober = true;
                  if (predicateAsBool(attaquant, 'attaqueViolente'))
                    options.attaqueViolente = true;
                }
                if (options.etreinteImmole) {
                  setTokenAttr(attaquant, 'etreinteImmole', idName(target), evt);
                  setTokenAttr(target, 'etreinteImmolePar', idName(attaquant), evt);
                  setState(target, 'immobilise', true, evt);
                  target.messages.push(nomPerso(attaquant) + " \xE9treint " + nomPerso(target) + " et s'immole !");
                  target.etreinteImmole = true;
                }
                if (options.etreinteScorpion) {
                  setTokenAttr(attaquant, 'etreinteScorpionSur', idName(target), evt);
                  setTokenAttr(target, 'etreinteScorpionPar', idName(attaquant), evt);
                  target.messages.push(nomPerso(attaquant) + " \xE9treint " + nomPerso(target) + " !");
                }
                if (targetd20roll >= 16 && options.contact) {
                  let ecraser = predicateAsBool(attaquant, 'ecraser');
                  if (ecraser) options.ecraser = ecraser;
                }
              }
              if (targetd20roll >= 17 && options.contact &&
                predicateAsBool(attaquant, 'crocEnJambe')) {
                if (targetd20roll >= 19 || !estQuadrupede(target)) {
                  setState(target, 'renverse', true, evt);
                  target.messages.push("tombe par terre");
                }
              }
              if (options.attaqueDeGroupe > 1 &&
                reglesOptionelles.haute_DEF.val.crit_attaque_groupe.val > 0 &&
                attackRoll >= (defense + reglesOptionelles.haute_DEF.val.crit_attaque_groupe.val)) {
                options.attaqueDeGroupeDmgCoef = true;
              }
              let faireMouche;
              if (targetd20roll == 1 && options.chance === undefined) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_DANGER + "'><b>\xE9chec&nbsp;critique</b></span>";
                attackResult += addAttackImg("imgAttackEchecCritique", weaponStats.divers, options);
                addAttackSound('soundAttackEchecCritique', weaponStats.divers, options);
                if (options.demiAuto) {
                  target.partialSaveAuto = true;
                  evt.succes = false;
                } else if (options.dmSiRate) {
                  target.dmRate = true;
                  evt.succes = false;
                } else touche = false;
                echecCritique = true;
                increaseTenacite(attaquant, target, evt);
              } else if ((paralyse || options.ouvertureMortelle || targetd20roll == 20 ||
                  (targetd20roll >= target.crit && attackRoll >= defense) ||
                  (reglesOptionelles.divers.val.coups_critiques_etendus.val && attackRoll > defense + 9)) && !options.attaqueAssuree) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>r\xE9ussite critique</b></span>";
                attackResult += addAttackImg("imgAttackSuccesCritique", weaponStats.divers, options);
                addAttackSound('soundAttackSuccesCritique', weaponStats.divers, options);
                touche = true;
                critique = true;
                if (options.contact) {
                  if (attributeAsBool(target, 'enerve')) {
                    if (faireMouche === undefined)
                      faireMouche = predicateAsInt(attaquant, 'faireMouche', 0);
                    if (faireMouche > 0) target.faireMouche = (target.faireMouche || 0) + faireMouche;
                  }
                  if (predicateAsBool(attaquant, 'briseurDOs')) {
                    target.osBrises = true;
                  }
                }
                resetTenacite(attaquant, target, evt);
              } else if (options.champion || targetd20roll == 20 || paralyse) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succ\xE8s</b></span>";
                attackResult += addAttackImg("imgAttackSuccesChampion", weaponStats.divers, options);
                addAttackSound("soundAttackSuccesChampion", weaponStats.divers, options);
                resetTenacite(attaquant, target, evt);
              } else if (attackRoll < defense && targetd20roll < target.crit) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>\xE9chec</b></span>";
                attackResult += addAttackImg("imgAttackEchec", weaponStats.divers, options);
                addAttackSound('soundAttackEchec', weaponStats.divers, options);
                evt.succes = false;
                if (options.demiAuto) {
                  target.partialSaveAuto = true;
                } else if (options.dmSiRate) {
                  target.dmRate = true;
                  evt.succes = false;
                } else touche = false;
                increaseTenacite(attaquant, target, evt);
              } else if (targetd20roll % 2 && attributeAsBool(target, 'clignotement')) {
                target.messages.push(nomPerso(target) + " dispara\xEEt au moment o\xF9 l'attaque aurait du l" + onGenre(target, 'e', 'a') + " toucher");
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>\xE9chec</b></span>";
                attackResult += addAttackImg("imgAttackEchecClignotement", weaponStats.divers, options);
                addAttackSound('soundAttackEchecClignotement', weaponStats.divers, options);
                target.clignotement = true;
                if (options.demiAuto) {
                  target.partialSaveAuto = true;
                } else if (options.dmSiRate) {
                  target.dmRate = true;
                  evt.succes = false;
                } else touche = false;
              } else { // Touch\xE9 normal
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succ\xE8s</b></span>";
                attackResult += addAttackImg("imgAttackSucces", weaponStats.divers, options);
                addAttackSound("soundAttackSucces", weaponStats.divers, options);
                resetTenacite(attaquant, target, evt);
              }
              let attRollValue;
              let bonusTexte = '';
              if (attSkill > 0) bonusTexte += "+" + attSkill;
              else if (attSkill < 0) bonusTexte += attSkill;
              if (attBonus > 0) bonusTexte += "+" + attBonus;
              else if (attBonus < 0) bonusTexte += attBonus;
              if (ficheAttributeAsBool(attaquant, 'jets_caches', false)) {
                attRollValue = attackRoll;
                sendChat('COF', "/w GM Jet cach\xE9 d'attaque : " + buildinline(rollsAttack.inlinerolls[attRollNumber]) + bonusTexte);
              } else {
                attRollValue = buildinline(rollsAttack.inlinerolls[attRollNumber]) + bonusTexte;
              }
              let line = "<b>Attaque</b> ";
              if (options.aoe || cibles.length > 1) {
                line += "contre <b>" + nomPerso(target) + "</b> ";
              }
              line += ":<br>";
              line += attRollValue + ' ';
              if (stateCOF.options.affichage.val.montre_def.val) {
                line += "vs <b>" + defense + "</b> ";
              }
              line += attackResult;
              if (options.test) line += " (" + attackRoll + ")";
              target.attackMessage = line;
              if (touche) {
                if (options.asDeLaGachette && attackRoll > 24) {
                  target.messages.push("As de la gachette => + 1" + options.d6 + " aux DM");
                  target.additionalDmg.push({
                    type: mainDmgType,
                    value: '1' + options.d6
                  });
                }
                //Botte mortelle (barde et duelliste)
                if (options.contact && !options.feinte && !options.attaqueAssuree && !options.pasDeDmg && attackRoll > defense + 4 &&
                  predicateAsBool(attaquant, 'botteMortelle')) {
                  if (faireMouche === undefined)
                    faireMouche = predicateAsInt(attaquant, 'faireMouche', 0);
                  if (faireMouche > 0) { //botte mortelle du duelliste
                    if (target.faireMouche) {
                      let bonusBotteMortelle =
                        Math.floor((attackRoll - defense) / 5) + options.d6;
                      target.messages.push("Botte mortelle => + " + bonusBotteMortelle + " aux DM");
                      target.additionalDmg.push({
                        type: mainDmgType,
                        value: bonusBotteMortelle
                      });
                    } else if (attackRoll > defense + 9) {
                      target.messages.push("Botte mortelle => l'attaque fait mouche");
                      target.faireMouche = faireMouche;
                    }
                  } else if (attackRoll > defense + 9) { //botte mortelle du barde
                    target.messages.push("Botte mortelle => + 2" + options.d6 + " aux DM");
                    target.additionalDmg.push({
                      type: mainDmgType,
                      value: '2' + options.d6
                    });
                  }
                }
                if (target.chatimentDuMale) {
                  if (target.chatimentDuMaleLowRoll + attSkill + attBonus >= defense) {
                    target.additionalDmg.push({
                      type: mainDmgType,
                      value: '2' + options.d6
                    });
                    target.messages.push("Ch\xE2timent du m\xE2le => +2d6 DM");
                  }
                }
                if (attributeAsBool(target, 'momentDePerfection')) {
                  target.messages.push("Gr\xE2ce \xE0 son instant de perfection, " + nomPerso(target) + " \xE9vite le coup !");
                  touche = false;
                  evt.succes = false;
                }
                if (options.frappeDesArcanes) {
                  if (options.contact) {
                    setAttrDuree(attaquant, 'frappeDesArcanes', 1 + randomInteger(6), evt);
                  } else {
                    sendPerso(attaquant, "Frappe des arcanes seulement possible au contact");
                  }
                }
              } else { //Effet si on ne touche pas
                if (attributeAsBool(attaquant, 'momentDePerfection')) {
                  target.messages.push("Gr\xE2ce \xE0 son instant de perfection, " + nomPerso(attaquant) + " touche !");
                  touche = true;
                  evt.succes = true;
                } else {
                  // Draw failed effect
                  if (options.fx && options.distance) {
                    let tokenOrigine = attackingToken;
                    if (options.origineDeLAttaque)
                      tokenOrigine = options.origineDeLAttaque.token;
                    let p1 = {
                      x: tokenOrigine.get('left'),
                      y: tokenOrigine.get('top')
                    };
                    let p2 = {
                      x: target.token.get('left'),
                      y: target.token.get('top')
                    };
                    // Compute some gaussian deviation in [0, 1]
                    let dev =
                      (Math.random() + Math.random() + Math.random() + Math.random() +
                        Math.random() + 1) / 6;
                    // take into account by how far we miss
                    dev = dev * (targetd20roll == 1) ? 2 : ((attackRoll - defense) / 20);
                    if (Math.random() > 0.5) dev = -dev;
                    p2.x += dev * (p2.y - p1.y);
                    p2.y += dev * (p2.x - p1.x);
                    spawnFxBetweenPoints(p1, p2, options.fx, pageId);
                  }
                  if (target.clignotement === undefined) {
                    evt.succes = false;
                    diminueMalediction(attaquant, evt);
                  }
                }
              }
            }
            target.touche = touche;
            target.critique = critique;
            target.attaqueCalculee = true;
            if (options.aoe === undefined && interchange.targets.length > 1) { //any target can be affected
              let n = randomInteger(interchange.targets.length);
              target.token = interchange.targets[n - 1];
            }
            if (target.touche) {
              if (attributeAsBool(target, 'imageDecalee') &&
                (!options.aoe || !persoArran(target) || predicateAsBool(target, 'imageDecaleeAvancee'))
              ) {
                if (target.rollImageDecalee === undefined) {
                  target.rollImageDecalee = rollDePlus(6);
                }
                let id = target.rollImageDecalee;
                if (id.val > 4) {
                  target.touche = false;
                  target.messages.push(id.roll + ": l'attaque passe \xE0 travers l'image de " + nomPerso(target));
                } else {
                  target.messages.push(id.roll + ": malgr\xE9 l'image l\xE9g\xE8rement d\xE9cal\xE9e de " + nomPerso(target) + " l'attaque touche");
                }
              } else if (predicateAsBool(target, 'estUneIllusion')) {
                target.touche = false;
                target.messages.push(nomPerso(target) + " disparait et se mat\xE9rialise un peu plus loin");
              }
            }
            if (target.touche) {
              ciblesTouchees.push(target);
              //Possibilit\xE9s d'annuler l'attaque
              if (!options.pasDeDmg && isActive(target) &&
                attributeAsBool(target, 'runeForgesort_protection') &&
                attributeAsInt(target, 'limiteParCombat_runeForgesort_protection', 1) > 0) {
                options.preDmg = options.preDmg || {};
                options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                options.preDmg[target.token.id].runeForgesort_protection = true;
              }
              if (!options.auto) {
                //Seulement si elle n'est pas automatiquement r\xE9ussie
                if (isActive(target)) {
                  if (!options.pasDeDmg && options.contact &&
                    !options.ignoreTouteRD) {
                    if (attributeAsBool(target, 'encaisserUnCoup')) {
                      options.preDmg = options.preDmg || {};
                      options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                      options.preDmg[target.token.id].encaisserUnCoup = true;
                    }
                    if (ficheAttributeAsInt(target, 'defbouclieron', 0) > 0) {
                      let test = testLimiteUtilisationsCapa(target, 'devierLesCoups', 'tour');
                      if (test) {
                        options.preDmg = options.preDmg || {};
                        options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                        options.preDmg[target.token.id].devierLesCoups = test;
                      }
                    }
                  }
                  if (options.distance && !options.sortilege && !options.poudre && cibles.length == 1 && !target.critique) {
                    let test = testLimiteUtilisationsCapa(target, 'paradeDeProjectiles', 'tour');
                    if (test) {
                      options.preDmg = options.preDmg || {};
                      options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                      options.preDmg[target.token.id].paradeDeProjectiles = test;
                    }
                  }
                  if (options.contact &&
                    capaciteDisponible(target, 'paradeAuBouclier', 'tour') &&
                    ficheAttributeAsInt(target, 'defbouclieron', 0) > 0) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].paradeAuBouclier = true;
                  }
                  if (capaciteDisponible(target, 'esquiveAcrobatique', 'tour')) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].esquiveAcrobatique = true;
                  }
                  if (predicateAsBool(target, 'expertDuCombat') &&
                    attributeAsInt(target, 'limiteParCombat_expertDuCombat', 1) > 0 &&
                    attributeAsInt(target, 'limiteParTour_expertDuCombat', 1) > 0 &&
                    (!options.expertDuCombatDEF || !options.expertDuCombatDEF[target.token.id])) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].expertDuCombatDEF = true;
                  }
                  if (!options.sortilege && !options.aoe &&
                    capaciteDisponible(target, 'paradeMagistrale', 'tour')) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].paradeMagistrale = true;
                  }
                  if (options.sortilege && predicateAsBool(target, 'esquiveDeLaMagie')) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].esquiveDeLaMagie = true;
                  }
                  if (!options.aoe && capaciteDisponible(target, 'esquiveFatale', 'combat')) {
                    if (target.ennemisAuContact === undefined) {
                      error(nomPerso(target) + " a la possibilit\xE9 d'une esquive fatale, mais les ennemis au contact ne sont pas calcul\xE9s", target);
                    } else {
                      let ciblesEsquiveFatale = target.ennemisAuContact.filter(function(tok) {
                        return (tok.id != attaquant.token.id);
                      });
                      if (ciblesEsquiveFatale.length > 0) {
                        options.preDmg = options.preDmg || {};
                        options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                        options.preDmg[target.token.id].esquiveFatale = ciblesEsquiveFatale;
                      }
                    }
                  }
                  if (options.sortilege) {
                    if (attributeAsBool(target, 'absorberUnSort') &&
                      ficheAttributeAsInt(target, 'defbouclieron', 0) == 1) {
                      options.preDmg = options.preDmg || {};
                      options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                      options.preDmg[target.token.id].absorberUnSort = true;
                    }
                  } else {
                    if (attributeAsBool(target, 'absorberUnCoup') &&
                      ficheAttributeAsInt(target, 'defbouclieron', 0) == 1) {
                      options.preDmg = options.preDmg || {};
                      options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                      options.preDmg[target.token.id].absorberUnCoup = true;
                    }
                  }
                }
                if (options.sortilege) {
                  if (capaciteDisponible(target, 'resistanceALaMagieBarbare', 'tour')) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].resistanceALaMagieBarbare = true;
                  }
                  if (attributeAsBool(target, 'cercleDeProtection')) {
                    var attrs = tokenAttribute(target, 'cercleDeProtectionValeur');
                    if (attrs.length > 0) {
                      var protecteur = persoOfId(attrs[0].get('current'));
                      if (protecteur) {
                        if (attributeAsInt(protecteur, "cercleDeProtectionActif", 0) > 0) {
                          options.preDmg = options.preDmg || {};
                          options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                          options.preDmg[target.token.id].cercleDeProtection = true;
                          options.preDmg[target.token.id].cercleDeProtectionDe = protecteur.token.get("name");
                        }
                      }
                    }
                  }
                }
              }
              if (capaciteDisponible(target, 'chairACanon', 'tour') &&
                target.chairACanon && target.chairACanon.length > 0) {
                options.preDmg = options.preDmg || {};
                options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                options.preDmg[target.token.id].chairACanon = target.chairACanon;
              }
              //Interception par un alli\xE9
              let alliesAvecInterception = [];
              if (target.alliesAuContact === undefined) {
                let allies = alliesParPerso[target.charId] || new Set();
                let tokensContact;
                allies.forEach(function(ci) {
                  if (ci == attaquant.charId) return;
                  if (charPredicateAsBool(ci, 'intercepter')) {
                    if (tokensContact === undefined) {
                      tokensContact = findObjs({
                        _type: 'graphic',
                        _subtype: 'token',
                        _pageid: pageId,
                        layer: 'objects'
                      });
                      tokensContact = tokensContact.filter(function(tok) {
                        if (tok.id == target.token.id) return false;
                        return distanceCombat(target.token, tok, pageId) === 0;
                      });
                    }
                    tokensContact.forEach(function(tok) {
                      if (tok.get('represents') != ci) return;
                      let perso = {
                        token: tok,
                        charId: ci
                      };
                      if (!isActive(perso)) return;
                      if (persoImmobilise(perso) &&
                        distanceCombat(tok, attaquant.token, pageId) > 0)
                        return;
                      if (!capaciteDisponible(perso, 'intercepter', 'tour')) return;
                      alliesAvecInterception.push(perso);
                    });
                  }
                });
              } else {
                target.alliesAuContact.forEach(function(tok) {
                  let perso = {
                    token: tok,
                    charId: tok.get('represents')
                  };
                  if (!isActive(perso)) return;
                  if (persoImmobilise(perso) &&
                    distanceCombat(tok, attaquant.token, pageId) > 0)
                    return;
                  if (!capaciteDisponible(perso, 'intercepter', 'tour')) return;
                  alliesAvecInterception.push(perso);
                });
              }
              //On enl\xE8ve les alli\xE9s qui sont cibles de l'attaque
              alliesAvecInterception = alliesAvecInterception.filter(function(p) {
                return cibles.every(function(c) {
                  return c.token.id != p.token.id;
                });
              });
              if (alliesAvecInterception.length > 0) {
                options.preDmg = options.preDmg || {};
                options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                options.preDmg[target.token.id].alliesAvecInterception = alliesAvecInterception;
              }
            }
            if (options.feinte) {
              let niveauTouche = 0;
              if (target.touche) niveauTouche = 1;
              if (target.critique) niveauTouche = 2;
              setTokenAttr(target, 'feinte_' + nomPerso(attaquant), 0, evt, {
                maxVal: niveauTouche
              });
            }
            count--;
            if (count === 0) {
              if (ciblesTouchees.length > 0 && !options.maxDmg && evt.action.weaponStats) {
                let al = evt.action.weaponStats.label;
                if ((options.runeDePuissance &&
                    attributeAsInt(attaquant, 'limiteParCombat_runeDePuissance' + al, 1)) ||
                  (attributeAsBool(attaquant, 'runeForgesort_puissance(' + al + ')') &&
                    attributeAsInt(attaquant, 'limiteParCombat_runeForgesort_puissance(' + al + ')', 1))) {
                  options.preDmg = options.preDmg || {};
                  options.preDmg.runeDePuissance = al;
                }
              }
              resolvePreDmgOptions(attaquant, ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles);
            }
          }, true); //comme on est dans une boucle qui d\xE9pend de la cible, inTarget doit \xEAtre vrai
        }); //fin de d\xE9termination de toucher des cibles
      }); // fin du jet d'attaque asynchrone
    } catch (e) {
      error("Erreur pendant l'\xE9valuation de " + toEvaluateAttack + " du test d'attaque", weaponStats);
      log(e.name + ": " + e.message);
    }
  }

  function eForFemale(perso) {
    return onGenre(perso, '', 'e');
  }

  function stringOfEtat(etat, perso) {
    if (etat == 'invisible') return etat;
    else if (etat == 'penombre') return "dans la p\xE9nombre";
    else if (etat == 'chef') return "est un leader";
    let etext = etat;
    if (etat.endsWith('e')) {
      etext = etat.substring(0, etat.length - 1) + '\xE9';
    }
    if (perso === undefined) return etext;
    return etext + eForFemale(perso);
  }

  function findAttackParam(attackParam, divers, options) {
    let param = options[attackParam];
    if (param) return param;
    let subParam = attackParam;
    let subParamIndex = subParam.indexOf('C');
    if (subParamIndex > 0) {
      subParam = subParam.substring(0, subParamIndex);
      param = options[subParam];
      if (param) return param;
    }
    subParamIndex = subParam.indexOf('E');
    if (subParamIndex > 0) {
      subParam = subParam.substring(0, subParamIndex);
      param = options[subParam];
      if (param) return param;
    }
    subParamIndex = subParam.indexOf('S');
    if (subParamIndex > 0) {
      subParam = subParam.substring(0, subParamIndex);
      param = options[subParam];
      if (param) return param;
    }
    let tag = attackParam.replace(/[A-Z]/g, function(c) {
      return '-' + c.toLowerCase();
    });
    tag = '[' + tag + ']';
    if (divers.includes(tag)) {
      let soundAttack = divers.split(tag);
      if (soundAttack.length > 2) {
        param = soundAttack[1];
      }
    }
    return param;
  }

  function playSound(sound) {
    let AMdeclared;
    try {
      AMdeclared = Roll20AM;
    } catch (e) {
      if (e.name != "ReferenceError") throw (e);
    }
    if (AMdeclared) {
      //With Roll20 Audio Master
      sendChat("GM", "!roll20AM --audio,play,nomenu|" + sound);
    } else {
      let jukebox = findObjs({
        type: 'jukeboxtrack',
        title: sound
      });
      jukebox.forEach(function(track) {
        track.set({
          playing: true,
          softstop: false
        });
      });
    }
  }

  function addAttackSound(attackParam, divers, options) {
    let sound = findAttackParam(attackParam, divers, options);
    if (!sound) {
      switch (attackParam) {
        case 'soundAttackEchecCritique':
          sound = stateCOF.options.sons.val.attaque_echec_critique.val;
          break;
        case 'soundAttackSuccesCritique':
          sound = stateCOF.options.sons.val.attaque_reussite_critique.val;
          break;
      }
    }
    if (sound) playSound(sound);
  }

  function addAttackImg(attackParam, divers, options) {
    let img = findAttackParam(attackParam, divers, options);
    if (img !== '' && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
      let newLineimg = '<span style="padding: 4px 0;" >  ';
      newLineimg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
      newLineimg += '</span>';
      return newLineimg;
    }
    return '';
  }

  function computeAttackDice(d, maxDmg, options) {
    if (isNaN(d) || d < 0) {
      error("D\xE9 d'attaque incorrect", d);
      return 0;
    }
    let attDice = d;
    if (options.puissant) {
      attDice += 2;
    }
    if (maxDmg) return attDice; //Dans ce cas, pas de reroll ni d'explosion
    if (options.reroll2) {
      if (attDice > 3 && options.rituelAssure) attDice += 'r3';
      else attDice += 'r2';
    } else if (options.reroll1) {
      if (attDice > 2 && options.rituelAssure) attDice += 'r2';
      else attDice += 'r1';
    } else if (options.rituelAssure) attDice += 'r1';
    if (options.explodeMax || reglesOptionelles.dommages.val.dm_explosifs.val) attDice += '!';
    else if (options.poudre && reglesOptionelles.divers.val.poudre_explosif.val) attDice += '!p';
    return attDice;
  }

  function computeMainDmgRollExpr(attaquant, target, weaponStats, attNbDices, attDMBonus, options) {
    let attDMArme = weaponStats.attDMBonusCommun;
    if (isNaN(attDMArme) || attDMArme === 0) attDMArme = '';
    else if (attDMArme > 0) attDMArme = '+' + attDMArme;
    attDMBonus = attDMArme + attDMBonus;
    let attNbDicesCible = attNbDices;
    let attDiceCible = computeAttackDice(weaponStats.attDice, target.maxDmg, options);
    let attCarBonus = '';
    if (weaponStats.attCarBonus) {
      if (weaponStats.sabre && predicateAsBool(attaquant, 'techniqueDuSabre') && weaponStats.attCarBonus == '@{FOR}' && !(options.lamesJumelles && weaponStats.armeGauche)) {
        let modForce = modCarac(attaquant, 'force');
        let bonus = predicateAsInt(attaquant, 'techniqueDuSabre', 0, 1);
        if (bonus > 2 * modForce) attCarBonus = bonus;
        else attCarBonus = modForce + Math.floor(bonus / 2);
      } else {
        attCarBonus = computeCarValue(attaquant, weaponStats.attCarBonus);
        if (attCarBonus === undefined) {
          attCarBonus = parseInt(weaponStats.attCarBonus);
        }
      }
      if (attCarBonus === 0) attCarBonus = '';
      else if (attCarBonus > 0) attCarBonus = '+' + attCarBonus;
    }
    if (options.epieu && !ficheAttributeAsBool(target, 'defarmureon', false)) {
      attNbDicesCible++;
    }
    if (target.pressionMortelle) {
      attNbDicesCible = 1;
      attDiceCible = 6; //TODO : have an option for that
      attCarBonus = '';
    }
    if (!options.sortilege && predicateAsBool(target, 'immuniteAuxArmes')) {
      if (options.magique) {
        attNbDicesCible = options.magique;
        attDiceCible = '6';
        attCarBonus = modCarac(attaquant, 'sagesse');
        if (attCarBonus < 1) attCarBonus = '';
        else attCarBonus = " +" + attCarBonus;
      } else {
        target.messages.push(nomPerso(target) + " semble immunis\xE9 aux armes ordinaires");
        attNbDicesCible = 0;
        attCarBonus = '';
        attDMBonus = '';
      }
    }
    let symbde = 'd';
    if (target.maxDmg) symbde = '*';
    return addOrigin(attaquant.name, attNbDicesCible + symbde + attDiceCible + attCarBonus + attDMBonus);
  }

  //retourne le mod de la caract\xE9ristique x, undefined si ce n'en est pas une
  function computeCarValue(perso, x) {
    switch (x) {
      case '@{FOR}':
        return modCarac(perso, 'force');
      case '@{DEX}':
        return modCarac(perso, 'dexterite');
      case '@{CON}':
        return modCarac(perso, 'constitution');
      case '@{INT}':
        return modCarac(perso, 'intelligence');
      case '@{SAG}':
        return modCarac(perso, 'sagesse');
      case '@{CHA}':
        return modCarac(perso, 'charisme');
      default:
        return;
    }
  }

  function addEffetTemporaireLie(perso, attr, evt) {
    let etlAttr = tokenAttribute(perso, 'effetsTemporairesLies');
    if (etlAttr.length === 0) {
      etlAttr = createObj('attribute', {
        characterid: perso.charId,
        name: 'effetsTemporairesLies',
        current: attr.id,
      });
      evt.attributes.push({
        attribute: etlAttr,
      });
      return;
    }
    etlAttr = etlAttr[0];
    let etl = etlAttr.get('current');
    evt.attributes.push({
      attribute: etlAttr,
      current: etl
    });
    if (etl === '') etl = attr.id;
    else etl += ',' + attr.id;
    etlAttr.set('current', etl);
  }

  function estImmuniseAEffet(target, effet) {
    if (predicateAsBool(target, 'immunite_' + effet)) return true;
    if (effet == 'statueDeBois' && predicateAsBool(target, 'immunite_petrification')) return true;
    return false;
  }

  //Met un effet temporaire sur target. L'effet temporaire est sp\xE9cifi\xE9 dans ef
  // - effet : le nom de l'effet
  // - whisper : true si on doit chuchoter l'effet, undefined si on n'affiche pas
  // - duree : true si c'est un effet \xE0 dur\xE9e en tours
  // - effetIndetermine : true si l'effet a une dur\xE9e ind\xE9termin\xE9e (pas combat)
  // - accumuleDuree : si la dur\xE9e peut s'accumuler
  // - typeDmg : le type de d\xE9g\xE2ts associ\xE9 \xE0 l'effet, si pertinent
  // - message : la structure de messages (venant de messageEffetTemp ou autre)
  //   - dm : l'effet fait des d\xE9g\xE2ts
  //   - visible : l'effet est visible
  //   - prejudiciable : l'effet est pr\xE9judiciable (et donc cible de d\xE9livrance)
  //   - statusMarker : marker associ\xE9 \xE0 l'effet
  // - pasDeMessageDActivation : pour ne pas afficher le message d'activation
  // - image : lien d'une image \xE0 afficher
  // - valeur : valeur associ\xE9e \xE0 l'effet
  // - valeurMax : champ max de l'attribut valeur associ\xE9 \xE0 l'effet
  // - saveParTour : caract\xE9ristiques du save par tour, si besoin.
  // - saveActifParTour : caract\xE9ristiques du save actif par tour, si besoin.
  // - attaquant : la personne \xE0 l'origine de l'effet
  // - options : des options \xE0 mettre dans l'attribut d'options
  function setEffetTemporaire(target, ef, duree, evt, options) {
    if (ef.effet == 'dedoublement') {
      if (attributeAsBool(target, 'dedouble') ||
        attributeAsBool(target, 'dedoublement')) {
        if (ef.whisper !== undefined) {
          whisperChar(target.charId, "a d\xE9j\xE0 \xE9t\xE9 d\xE9doubl\xE9 pendant ce combat");
        } else {
          target.messages.push(nomPerso(target) + " a d\xE9j\xE0 \xE9t\xE9 d\xE9doubl\xE9 pendant ce combat");
        }
        return;
      }
      let dedoubleMsg =
        "Un double translucide de " + nomPerso(target) + " appara\xEEt.";
      if (ef.attaquant) {
        dedoubleMsg += " Il est aux ordres de " + nomPerso(ef.attaquant);
      }
      if (stateCOF.options.affichage.val.duree_effets.val) dedoubleMsg += " (" + duree + " tours)";
      if (ef.whisper !== undefined) {
        if (ef.whisper === true) {
          whisperChar(target.charId, dedoubleMsg);
        } else {
          sendChar(target.charId, ef.whisper + dedoubleMsg);
        }
      } else {
        target.messages.push(dedoubleMsg);
      }
      setTokenAttr(target, 'dedouble', true, evt);
      let attrEffet =
        copieToken(target, undefined, stateCOF.options.images.val.image_double.val,
          "Double de " + nomPerso(target), 'dedoublement', duree,
          target.token.get('pageid'), evt);
      if (ef.attaquant && options.mana !== undefined) {
        addEffetTemporaireLie(ef.attaquant, attrEffet, evt);
      }
      return;
    }
    if (estImmuniseAEffet(target, ef.effet)) {
      if (ef.whisper !== undefined) {
        if (ef.whisper === true) {
          whisperChar(target.charId, "ne peut pas \xEAtre affect\xE9 par l'effet de " + ef.effet);
        } else {
          sendChar(target.charId, ef.whisper + "ne peut pas \xEAtre affect\xE9 par l'effet de " + ef.effet);
        }
      } else {
        target.messages.push(nomPerso(target) + " ne peut pas \xEAtre affect\xE9 par l'effet de " + ef.effet);
      }
      return;
    }
    if (ef.effet == 'saignementsSang' && predicateAsBool(target, 'immuniteSaignement')) {
      if (ef.whisper !== undefined) {
        if (ef.whisper === true) {
          whisperChar(target.charId, "ne peut pas saigner");
        } else {
          sendChar(target.charId, ef.whisper + "ne peut pas saigner");
        }
      } else {
        target.messages.push(nomPerso(target) + " ne peut pas saigner");
      }
      return;
    }
    if (ef.effet === 'lienDeSang') {
      if (ef.attaquant === undefined) {
        error("Effet de lien de sans sans attaquant", ef);
        return;
      }
      setTokenAttr(ef.attaquant, 'lienDeSangVers', target.token.id, evt);
      setTokenAttr(target, 'lienDeSangDe', ef.attaquant.token.id, evt);
    }
    if (ef.duree) {
      if (ef.typeDmg && (!ef.message || !ef.message.dm) &&
        (predicateAsBool(target, 'diviseEffet_' + ef.typeDmg) ||
          (estElementaire(ef.typeDmg) && predicateAsBool(target, 'diviseEffet_elementaire')))
      ) {
        duree = Math.ceil(duree / 2);
      }
      if (ef.accumuleDuree) {
        if (ef.accumuleDuree > 1 && attributeAsBool(target, ef.effet)) {
          let accumuleAttr = tokenAttribute(target, ef.effet + 'DureeAccumulee');
          if (accumuleAttr.length === 0) {
            setTokenAttr(target, ef.effet + 'DureeAccumulee', duree, evt);
          } else {
            accumuleAttr = accumuleAttr[0];
            let dureeAccumulee = accumuleAttr.get('current') + '';
            if (dureeAccumulee.split(',').length < ef.accumuleDuree - 1) {
              evt.attributes = evt.attributes || [];
              evt.attributes.push({
                attribute: accumuleAttr,
                current: dureeAccumulee
              });
              accumuleAttr.set('current', duree + ',' + dureeAccumulee);
            }
          }
          return; //Pas besoin de r\xE9appliquer, effet toujours en cours
        }
      }
      let targetMsg = '';
      if (ef.message && !ef.pasDeMessageDActivation) {
        let msgAct = messageActivation(target, ef.message);
        if (ef.whisper === undefined) {
          targetMsg = nomPerso(target) + " " + msgAct;
        } else if (ef.whisper !== true) {
          targetMsg = ef.whisper + msgAct;
        }
        if (stateCOF.options.affichage.val.duree_effets.val) targetMsg += " (" + duree + " tours)";
        let img = ef.image;
        if (img !== "" && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
          let newLineimg = '<span style="padding: 4px 0;" >  ';
          newLineimg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
          newLineimg += '</span>';
          targetMsg += newLineimg;
        }
        if (ef.whisper === undefined) {
          target.messages.push(targetMsg);
          targetMsg = undefined;
        }
      }
      let secret = !(ef.message && ef.message.visible);
      let attrEffet = setAttrDuree(target, ef.effet, duree, evt, targetMsg, secret);
      if (ef.attaquant && options.mana !== undefined && ef.message && ef.message.prejudiciable) {
        addEffetTemporaireLie(ef.attaquant, attrEffet, evt);
      }
      switch (ef.effet) {
        case 'apeureTemp':
          setState(target, 'apeure', true, evt);
          break;
        case 'aveugleTemp':
          setState(target, 'aveugle', true, evt);
          break;
        case 'penombreTemp':
          setState(target, 'penombre', true, evt);
          break;
        case 'ralentiTemp':
          setState(target, 'ralenti', true, evt);
          break;
        case 'paralyseTemp':
        case 'paralyseGoule':
          setState(target, 'paralyse', true, evt);
          break;
        case 'immobiliseTemp':
          setState(target, 'immobilise', true, evt);
          break;
        case 'etourdiTemp':
          setState(target, 'etourdi', true, evt);
          break;
        case 'affaibliTemp':
          setState(target, 'affaibli', true, evt);
          break;
        case 'assommeTemp':
          setState(target, 'assomme', true, evt);
          break;
        case 'invisibleTemp':
        case 'intangibleInvisible':
          setState(target, 'invisible', true, evt);
          break;
        case 'aspectDuDemon':
          //On retire l'autre aspect du N\xE9cromancien si il est pr\xE9sent
          finDEffetDeNom(target, "aspectDeLaSuccube", evt);
          break;
        case 'aspectDeLaSuccube':
          finDEffetDeNom(target, "aspectDuDemon", evt);
          break;
        case 'peauDePierreMag':
          if (ef.valeur === undefined) {
            let lanceur = target;
            if (ef.attaquant) lanceur = ef.attaquant;
            let rd = 5 + modCarac(lanceur, 'intelligence');
            let absorbe = 40;
            if (options.tempeteDeManaIntense) {
              rd += options.tempeteDeManaIntense;
              absorbe += options.tempeteDeManaIntense * 5;
            }
            setTokenAttr(target, 'peauDePierreMagValeur', rd, evt, {
              maxVal: absorbe
            });
          }
          break;
        case 'hemorragie':
        case 'blessureSanglante':
        case 'saignementsSang':
          if (ef.attaquant && predicateAsBool(ef.attaquant, 'drainDeSang')) {
            let attAttr = ef.attaquant.token.id + ':' + attrEffet.id;
            let attrDrain = tokenAttribute(target, 'attributDeCombat_drainDeSang');
            if (attrDrain.length > 0) {
              attrDrain = attrDrain[0];
              let drains = attrDrain.get('current');
              if (!drains.includes(attAttr)) {
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: attrDrain,
                  current: drains
                });
                attrDrain.set('current', drains + ' ' + attAttr);
              }
            } else {
              setTokenAttr(target, 'attributDeCombat_drainDeSang', attAttr, evt);
            }
          }
      }
      if (ef.message && ef.message.statusMarker) {
        affectToken(target.token, 'statusmarkers', target.token.get('statusmarkers'), evt);
        target.token.set('status_' + ef.message.statusMarker, true);
      }
    } else if (ef.effetIndetermine) {
      target.messages.push(nomPerso(target) + " " + messageActivation(target, messageEffetIndetermine[ef.effet]));
      setTokenAttr(target, ef.effet, true, evt);
    } else { //On a un effet de combat
      let effetC = messageEffetCombat[ef.effet];
      target.messages.push(nomPerso(target) + " " + messageActivation(target, effetC));
      let attrEffetCombat = setTokenAttr(target, ef.effet, true, evt);
      if (ef.attaquant && options.mana !== undefined && effetC.prejudiciable) {
        addEffetTemporaireLie(ef.attaquant, attrEffetCombat, evt);
      }
    }
    if (ef.valeur !== undefined) {
      setTokenAttr(target, ef.effet + 'Valeur', ef.valeur, evt, {
        maxVal: ef.valeurMax
      });
    }
    if (ef.options !== undefined) {
      setTokenAttr(target, ef.effet + 'Options', ef.options, evt);
    }
    if (options.tempeteDeManaIntense)
      setTokenAttr(target, ef.effet + 'TempeteDeManaIntense', options.tempeteDeManaIntense, evt);
    if (ef.saveParTour) {
      setTokenAttr(target, ef.effet + 'SaveParTour',
        ef.saveParTour.carac, evt, {
          maxVal: ef.saveParTour.seuil
        });
      if (ef.typeDmg)
        setTokenAttr(target, ef.effet + 'SaveParTourType', ef.typeDmg, evt);
    }
    if (ef.saveActifParTour) {
      setTokenAttr(target, ef.effet + 'SaveActifParTour',
        ef.saveActifParTour.carac, evt, {
          maxVal: ef.saveActifParTour.seuil
        });
      if (ef.typeDmg)
        setTokenAttr(target, ef.effet + 'SaveParTourType', ef.typeDmg, evt);
    }
  }

  // Applique toutes les options de preDmg d\xE9j\xE0 s\xE9lectionn\xE9es
  // Retourne vrai si l'option "continuer" a d\xE9j\xE0 \xE9t\xE9 choisie
  function resolvePreDmgOptions(attaquant, ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles) {
    //Sauvegarde de l'\xE9tat pour pouvoir relancer au niveau de cette fonction
    evt.action.currentOptions = options;
    evt.action.echecCritique = echecCritique;
    evt.action.attackLabel = attackLabel;
    evt.action.attackd20roll = d20roll;
    evt.action.display = JSON.parse(JSON.stringify(display));
    evt.action.display.perso1 = display.perso1;
    evt.action.display.perso2 = display.perso2;
    evt.action.explications = JSON.parse(JSON.stringify(explications));
    evt.action.pageId = pageId;
    evt.action.ciblesTouchees = ciblesTouchees;
    evt.action.choices = options.choices;
    if (ciblesTouchees.length === 0) {
      attackDealDmg(attaquant, evt.action.ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles);
      return;
    }
    if (evt.action.choices === undefined) {
      if (options.preDmg) {
        addLineToFramedDisplay(display, "<b>Attaque :</b> Touche !");
        finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique);
        return;
      } else {
        attackDealDmg(attaquant, evt.action.ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles);
        return;
      }
    }
    let continuer = evt.action.choices.Continuer;
    let nbCibles = ciblesTouchees.length;
    ciblesTouchees.forEach(function(cible) {
      let finaliseTarget = function() {
        nbCibles--;
        if (nbCibles === 0) {
          if (continuer) {
            delete options.preDmg;
          }
          if (options.preDmg || options.preDmgAnnule) {
            addLineToFramedDisplay(display, "<b>Attaque :</b> Touche !");
            finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique);
            return;
          } else {
            attackDealDmg(attaquant, evt.action.ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles);
          }
        }
      };
      let preDmgToken = evt.action.choices[cible.token.id];
      if (preDmgToken !== undefined) {
        let termineCible = false;
        if (preDmgToken.encaisserUnCoup) {
          appliquerEncaisserUnCoup(cible, options, evt);
        }
        if (preDmgToken.devierLesCoups) {
          appliquerDevierLesCoups(cible, preDmgToken.devierLesCoups, options, evt);
        }
        if (preDmgToken.paradeDeProjectiles) {
          appliquerParadeProjectiles(cible, preDmgToken.paradeDeProjectiles, options, evt);
          explications.push(cible.token.get("name") + " pare le projectile !");
          finaliseTarget();
        }
        if (preDmgToken.runeForgesort_protection) {
          appliquerRuneDeProtection(cible, options, evt);
          finaliseTarget();
        }
        if (preDmgToken.evitementGenerique && preDmgToken.evitementGenerique.length > 0) {
          let nbEvitementsGenerique = preDmgToken.evitementGenerique.length;
          let finaliseTargetPreDmg = function(msg, generalMsg) {
            if (generalMsg !== '' && !continuer && !termineCible) { // rerolls uniquement si pas termin\xE9
              explications.push(msg + generalMsg);
            } else {
              cible.messages.push(msg);
            }
            nbEvitementsGenerique--;
            if (nbEvitementsGenerique === 0) {
              finaliseTarget();
            }
          };
          preDmgToken.evitementGenerique.forEach(function(evitementGenerique) {
            appliquerEvitementGenerique(cible, evitementGenerique, pageId,
              options, evt, finaliseTargetPreDmg);
          });
        } else {
          finaliseTarget();
        }
      } else {
        finaliseTarget();
      }
    });
  }

  function attaqueNeTouchePas(attaquant, echecCritique, weaponStats, display, options, evt, explications, pageId, cibles) {
    finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique);
    if (echecCritique) {
      if (stateCOF.options.affichage.val.table_crit.val)
        sendChat('COF', "[[1t[Echec-Critique-Contact]]]");
      else sendChat('COF', "/w GM " + suggererEchecCritique(attaquant, weaponStats, cibles, options, evt));
    }
  }

  function moveTokenWithUndo(token, left, top, evt) {
    if (evt) {
      evt.movedTokens = evt.movedTokens || [];
      evt.movedTokens.push({
        token,
        oldPosition: {
          left: token.get('left'),
          top: token.get('top'),
        },
        newPosition: {
          left,
          top
        }
      });
    }
    token.set('left', left);
    token.set('top', top);
    let combat = stateCOF.combat;
    if (stateCOF.options.affichage.val.init_dynamique.val && roundMarker &&
      combat) {
      if ((!stateCOF.chargeFantastique && combat.activeTokenId == token.id) ||
        (stateCOF.chargeFantastique && stateCOF.chargeFantastique.activeTokenId == token.id)) {
        roundMarker.set('left', left);
        roundMarker.set('top', top);
      }
    }
  }

  //pageId est optionnel
  function saignementAvecDrain(cible, nomAttr, pageId) {
    let drainAttr = tokenAttribute(cible, 'attributDeCombat_drainDeSang');
    if (drainAttr.length === 0) return;
    let attr = tokenAttribute(cible, nomAttr);
    if (attr.length === 0) {
      log("Attribut absent dans saignementAvecDrain " + nomAttr + " de " + nomPerso(cible));
      return;
    }
    let drains = drainAttr[0].get('current').split(' ');
    let source = drains.find(function(d) {
      let sa = d.split(':');
      if (sa.length != 2) {
        log("Drain de sang mal form\xE9 : " + drains);
        return false;
      }
      return attr.some(function(a) {
        return a.id == sa[1];
      });
    });
    if (!source) return;
    let id = source.split(':')[0];
    let perso = persoOfId(id);
    if (!perso) return;
    if (distanceCombat(perso.token, cible.token, pageId) > 10) return;
    return perso;
  }

  function attackDealDmg(attaquant, ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles) {
    cibles.forEach(function(target) {
      if (options.test || options.feinte || !target.touche) {
        //On a fini avec cette cible, on imprime ce qui la concerne
        if (target.attackMessage)
          addLineToFramedDisplay(display, target.attackMessage);
        target.messages.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
      }
    });
    let attackerTokName = nomPerso(attaquant);
    if (ciblesTouchees.length === 0 || options.test || options.feinte) {
      //\xC9valuation finale pour le cas o\xF9 l'attaque a rat\xE9
      evalITE(attaquant, undefined, d20roll, options, 1, evt, explications, options, function() {
        if (options.attrArmeDeJet) {
          if (options.retourneEnMain) {
            if (options.retourneEnMain.carac) {
              explications.push(weaponStats.name + " retourne vers son lanceur");
              let optAttrape = {
                msgPour: " pour rattraper son arme"
              };
              let sid = 'retourEnMain_' + attaquant.charId;
              let expliquer = function(msg) {
                explications.push(msg);
              };
              save(options.retourneEnMain, attaquant, sid, expliquer, optAttrape, evt, function(reussite, rolltext) {
                if (reussite) {
                  options.attrArmeDeJet.attribute.set('current', options.attrArmeDeJet.restant + 1);
                  explications.push(attackerTokName + " rattrape " + weaponStats.name);
                } else {
                  explications.push("Rat\xE9 ! Il reste " + options.attrArmeDeJet.restant + " " + weaponStats.name + " \xE0 " + attackerTokName);
                  if (options.attrArmeDeJet.restant === 0) {
                    degainerArmeLancee(attaquant, attackLabel, evt);
                  }
                }
                attaqueNeTouchePas(attaquant, echecCritique, weaponStats, display, options, evt, explications, pageId, cibles);
              });
              return;
            }
            options.attrArmeDeJet.attribute.set('current', options.attrArmeDeJet.restant + 1);
            explications.push(weaponStats.name + " retourne dans la main de son lanceur");
          } else {
            explications.push("Il reste " + options.attrArmeDeJet.restant + " " + weaponStats.name + " \xE0 " + attackerTokName);
            if (options.attrArmeDeJet.restant === 0) {
              degainerArmeLancee(attaquant, attackLabel, evt);
            }
          }
        }
        attaqueNeTouchePas(attaquant, echecCritique, weaponStats, display, options, evt, explications, pageId, cibles);
      });
      return;
    }
    const attackingCharId = attaquant.charId;
    const attackingToken = attaquant.token;
    options.attaquant = attaquant;
    //Les d\xE9g\xE2ts
    //D\xE9g\xE2ts insrits sur la ligne de l'arme
    let mainDmgType = options.type || 'normal';
    let attNbDices = weaponStats.attNbDices;
    if (isNaN(attNbDices) || attNbDices < 0) {
      error("D\xE9s de l'attaque incorrect", attNbDices);
      return;
    }
    if (attNbDices) {
      if (options.tempeteDeManaIntense) {
        attNbDices += options.tempeteDeManaIntense;
      } else if (options.conditionAttaquant &&
        options.conditionAttaquant.type == 'attribut') {
        let attrtdmi =
          options.conditionAttaquant.attribute + 'TempeteDeManaIntense';
        let tdmCond = attributeAsInt(attaquant, attrtdmi, 0);
        if (tdmCond) {
          attNbDices += tdmCond;
          removeTokenAttr(attaquant, attrtdmi, evt);
        }
      }
    }
    // Les autres modifications aux d\xE9g\xE2ts qui ne d\xE9pendent pas de la cible
    let attDMBonusCommun = '';
    if (options.armeMagiquePlus) {
      attDMBonusCommun += " + " + options.armeMagiquePlus;
    }
    if (options.rayonAffaiblissant) {
      attDMBonusCommun += " - " + options.rayonAffaiblissant;
    }
    if (options.contact && options.drainDeForce) {
      attDMBonusCommun += " -2";
    }
    if (options.noyade && weaponStats.arme) {
      attDMBonusCommun += " - 3";
    }
    if (options.fievreux && weaponStats.arme) {
      attDMBonusCommun += " - 2";
    }
    if (options.reactionViolente) {
      attDMBonusCommun += " + 2";
    }
    if (weaponStats.arc && predicateAsBool(attaquant, 'sensAffutes')) {
      let bonus = modCarac(attaquant, 'sagesse');
      if (bonus > 0) {
        attDMBonusCommun += ' + ' + bonus;
      }
    }
    if (attributeAsBool(attaquant, 'masqueDuPredateur')) {
      let bonusMasque = getValeurOfEffet(attaquant, 'masqueDuPredateur', modCarac(attaquant, 'sagesse'));
      if (options.masqueIntense) bonusMasque += options.masqueIntense;
      if (bonusMasque > 0) {
        attDMBonusCommun += " +" + bonusMasque;
        if (options.auto)
          explications.push("Masque du pr\xE9dateur : +" + bonusMasque + " aux DM");
      }
    }
    if (attributeAsBool(attaquant, 'masqueDuPredateurAmeLiee')) {
      let bonusMasque =
        getValeurOfEffet(attaquant, 'masqueDuPredateurAmeLiee', 1);
      if (bonusMasque > 0) {
        attDMBonusCommun += " +" + bonusMasque;
        if (options.auto) {
          explications.push("Masque du pr\xE9dateur li\xE9 : +" + bonusMasque + " aux DM");
        }
      }
    }
    if (options.bonusDM) {
      attDMBonusCommun += " + " + options.bonusDM;
    }
    let perteDeSubstance = predicateAsInt(attaquant, 'perteDeSubstance', 0);
    if (perteDeSubstance && !predicateAsBool(attaquant, 'ancreInvincible')) {
      if (perteDeSubstance > 10) perteDeSubstance = 10;
      attDMBonusCommun += ' -' + perteDeSubstance;
      explications.push("Perte de substance => -" + perteDeSubstance + " DM");
    }
    if (options.rageBerserk) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: options.rageBerserk + options.d6
      });
    }
    if (options.fureurDrakonide) {
      attDMBonusCommun += " +" + options.fureurDrakonide;
    }
    if (options.rage) {
      attDMBonusCommun += " +2";
    }
    if (weaponStats.arc && attributeAsBool(attaquant, 'carquoisMagique')) {
      let type = getValeurOfEffet(attaquant, 'carquoisMagique', 'feu');
      let niveau = ficheAttributeAsInt(attaquant, 'niveau', 1);
      let value = '1';
      if (niveau > 12) value = '2';
      value += options.d6;
      attaquant.additionalDmg.push({
        type,
        value,
      });
      explications.push("Carquois magique => +" + value + " DM de " + type);
    }
    if (options.enrage) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: '1' + options.d6
      });
    }
    if (options.contact && attributeAsBool(attaquant, 'memePasMalBonus')) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: '1' + options.d6,
      });
      explications.push("M\xEAme pas mal => +1" + options.d6 + " DM");
    }
    if (!options.auto && options.attaqueEnPuissance) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: options.attaqueEnPuissance + options.d6
      });
    }
    let attrPosture = tokenAttribute(attaquant, 'postureDeCombat');
    if (attrPosture.length > 0) {
      attrPosture = attrPosture[0];
      let posture = attrPosture.get('max');
      let postureVal;
      if (posture.startsWith('DM')) {
        postureVal = parseInt(attrPosture.get('current'));
        attDMBonusCommun += " -" + postureVal;
        explications.push("Posture de combat => -" + postureVal + " DM");
      } else if (posture.endsWith('DM')) {
        postureVal = parseInt(attrPosture.get('current'));
        attDMBonusCommun += " +" + postureVal;
        explications.push("Posture de combat => +" + postureVal + " DM");
      }
    }
    let attaqueAOutrance = attributeAsInt(attaquant, 'attaqueAOutrance', 0);
    if (attaqueAOutrance > 1) {
      if (attaqueAOutrance < 5) {
        attaquant.additionalDmg.push({
          type: mainDmgType,
          value: '1' + options.d6
        });
        explications.push("Attaque \xE0 outrance => +1d6 DM");
      } else {
        attaquant.additionalDmg.push({
          type: mainDmgType,
          value: '2' + options.d6
        });
        explications.push("Attaque \xE0 outrance => +2d6 DM");
      }
    }
    if (attaquant.bonusCapitaine)
      attDMBonusCommun += " +" + attaquant.bonusCapitaine;
    // Les autres sources de d\xE9g\xE2ts
    if (options.distance) {
      if (options.semonce) {
        attaquant.additionalDmg.push({
          type: mainDmgType,
          value: '1' + options.d6
        });
        explications.push("Tir de semonce => +5 en Attaque et +1" + options.d6 + " aux DM");
      }
    } else { //bonus aux attaques de contact
      if (attributeAsBool(attaquant, 'agrandissement')) {
        attDMBonusCommun += "+2";
        explications.push("Agrandissement => +2 aux DM");
      }
      if (attributeAsBool(attaquant, 'forceDeGeant')) {
        let bonusForceDeGeant = getValeurOfEffet(attaquant, 'forceDeGeant', 2);
        attDMBonusCommun += "+" + bonusForceDeGeant;
        explications.push("Force de g\xE9ant => +" + bonusForceDeGeant + " aux DM");
      }
      if (options.frappeDuVide) {
        attaquant.additionalDmg.push({
          type: mainDmgType,
          value: (options.kiai) ? '0d1+6' : ('1' + options.d6)
        });
      }
    }
    let nAEF = 0;
    if (attackLabel) {
      let attrForgeron = 'forgeron(' + attackLabel + ')';
      if (attributeAsBool(attaquant, attrForgeron)) {
        let feuForgeron =
          getValeurOfEffet(attaquant, attrForgeron, 1, 'voieDuMetal');
        if (predicateAsBool(attaquant, 'boutefeu')) feuForgeron *= 2;
        let feuForgeronIntense = attributeAsInt(attaquant, attrForgeron + 'TempeteDeManaIntense', 0);
        if (feuForgeronIntense) {
          feuForgeron = feuForgeron * (1 + feuForgeronIntense);
          removeTokenAttr(attaquant, attrForgeron + 'TempeteDeManaIntense', evt);
        }
        attaquant.additionalDmg.push({
          type: 'feu',
          value: feuForgeron
        });
      }
      let attrAEF = 'armeEnflammee(' + attackLabel + ')';
      if (attributeAsBool(attaquant, attrAEF)) {
        nAEF = 1;
        let AEFIntense = attributeAsInt(attaquant, attrAEF + 'TempeteDeManaIntense', 0);
        if (AEFIntense) {
          nAEF += AEFIntense;
          removeTokenAttr(attaquant, attrAEF + 'TempeteDeManaIntense', evt);
        }
      }
    }
    if (nAEF === 0 && attributeAsBool(attaquant, 'armesEnflammees')) {
      nAEF = 1;
      let AsEFIntense = attributeAsInt(attaquant, 'armesEnflammeesTempeteDeManaIntense', 0);
      if (AsEFIntense) {
        nAEF += AsEFIntense;
        removeTokenAttr(attaquant, 'armesEnflammeesTempeteDeManaIntense', evt);
      }
    }
    if (nAEF > 0) {
      attaquant.additionalDmg.push({
        type: 'feu',
        value: nAEF + 'd6'
      });
    }
    if (attackLabel && (attackingToken.get('bar1_link') === '' || !weaponStats.armeDeJet)) {
      let poisonAttr = tokenAttribute(attaquant, 'enduitDePoison_' + attackLabel);
      if (poisonAttr.length > 0) {
        poisonAttr = poisonAttr[0];
        effetPoison(poisonAttr, poisonAttr.get('max'), attaquant, explications, options);
        evt.deletedAttributes = evt.deletedAttributes || [];
        evt.deletedAttributes.push(poisonAttr);
        poisonAttr.remove();
      }
      let attrDmgArme = 'dmgArme(' + attackLabel + ')';
      if (attributeAsBool(attaquant, attrDmgArme)) {
        let dmgArme = {
          type: mainDmgType,
          value: '1' + options.d6
        };
        let valDmgArme = tokenAttribute(attaquant, attrDmgArme + 'Valeur');
        if (valDmgArme.length > 0) {
          dmgArme.value = valDmgArme[0].get('current');
          let dmgArmeType = valDmgArme[0].get('max');
          if (dmgArmeType !== '') dmgArme.type = dmgArmeType;
        }
        attaquant.additionalDmg.push(dmgArme);
        explications.push("Arme enduite => +" + dmgArme.value + " aux DM");
      }
    }
    if (options.champion) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: '1' + options.d6
      });
      let msgChampion =
        nomPerso(attaquant) + " est un" + eForFemale(attaquant) + " champion" +
        onGenre(attaquant, '', 'ne') + ", son attaque porte !";
      explications.push(msgChampion);
    }
    /////////////////////////////////////////////////////////////////
    //Tout ce qui d\xE9pend de la cible
    let ciblesCount = ciblesTouchees.length; //Pour l'asynchronie
    let attaquesEnTraitrePossibles = {};
    let finCibles = function() {
      ciblesCount--;
      if (ciblesCount === 0) {
        ciblesTouchees.forEach(function(target) {
          if (target.attackMessage) {
            addLineToFramedDisplay(display, target.attackMessage);
          } else if (options.aoe) { //par exemple si attaque automatique
            addLineToFramedDisplay(display, "<b>" + nomPerso(target) + "</b> :");
          }
          if (target.dmgMessage) addLineToFramedDisplay(display, target.dmgMessage, 100, false);
          target.messages.forEach(function(expl) {
            addLineToFramedDisplay(display, expl, 80);
          });
          if (target.osBrises) {
            addLineToFramedDisplay(display, nomPerso(target) + " a des os bris\xE9s ");
            setTokenAttr(target, 'osBrises', true, evt);
          }
        });
        finaliseDisplay(display, explications, evt, attaquant, cibles, options);
        for (let vid in attaquesEnTraitrePossibles) {
          let voleur = persoOfId(vid);
          if (voleur === undefined) continue;
          if (capaciteDisponible(voleur, 'attaqueEnTraitre')) {
            displayAttaqueOpportunite(vid, attaquesEnTraitrePossibles[vid], "en tra\xEEtre", 'Attaques en traitre', '--decrLimitePredicatParTour attaqueEnTraitre');
          }
        }
      }
    };
    //Le lien \xE9pique (+1d6 DM si les 2 attaquent la m\xEAme cible
    let attaqueParLienEpique = new Set();
    if (options.lienEpique) {
      //On cherche les autres personnages avec le m\xEAme lien \xE9pique
      let allChars = findObjs({
        type: 'character'
      });
      allChars.forEach(function(ch) {
        if (ch.id == attackingCharId) return;
        if (charPredicateAsBool(ch.id, 'lienEpique') != options.lienEpique) return;
        let attrCibles = charAttribute(ch.id, 'dernieresCiblesAttaquees');
        if (attrCibles.length === 0) return;
        let ciblesAttaquees = attrCibles[0].get('current');
        if (ciblesAttaquees === '') return;
        ciblesAttaquees.split(' ').forEach(function(ci) {
          attaqueParLienEpique.add(ci);
        });
      });
    }
    ciblesTouchees.forEach(function(target) {
      //l'\xE9valuation finale des conditions quand on sait si l'attaque a touch\xE9.
      evalITE(attaquant, target, d20roll, options, 1, evt, explications, options, function() {
        target.attaquant = attaquant;
        if (options.attrArmeDeJet) {
          if (options.retourneEnMain) {
            options.attrArmeDeJet.attribute.set('current', options.attrArmeDeJet.restant + 1);
            explications.push(weaponStats.name + " retourne dans la main de son lanceur");
          } else {
            explications.push("Il reste " + options.attrArmeDeJet.restant + " " + weaponStats.name + " \xE0 " + attackerTokName);
            if (options.attrArmeDeJet.restant === 0) {
              degainerArmeLancee(attaquant, attackLabel, evt);
            }
          }
          options.attrArmeDeJet = undefined;
        }
        if (options.enveloppe !== undefined) {
          if (options.enveloppe.type == 'etreinte' && attributeAsBool(target, 'armureDEau')) {
            target.messages.push("L'armure d'eau emp\xEAche " + nomPerso(target) + " d'\xEAtre \xE9treint");
          } else {
            let ligneEnveloppe = nomPerso(attaquant) + " peut ";
            let commandeEnvelopper =
              '!cof-enveloppement ' + attaquant.token.id + ' ' + target.token.id + ' ' +
              options.enveloppe.difficulte + ' ' +
              options.enveloppe.type + ' ' + options.enveloppe.expression;
            let verbeEnv = 'envelopper';
            if (options.enveloppe.type == 'etreinte') verbeEnv = '\xE9treindre';
            ligneEnveloppe += boutonSimple(commandeEnvelopper, verbeEnv);
            ligneEnveloppe += nomPerso(target);
            target.messages.push(ligneEnveloppe);
          }
        }
        if (options.agripper) {
          if (attributeAsBool(target, 'armureDEau')) {
            target.messages.push("L'armure d'eau emp\xEAche " + nomPerso(target) + " d'\xEAtre aggrip\xE9");
          } else {
            let immobilise = estAussiGrandQue(attaquant, target);
            setTokenAttr(attaquant, 'agrippe', idName(target), evt);
            setTokenAttr(target, 'estAgrippePar', idName(attaquant), evt, {
              maxVal: immobilise
            });
            if (immobilise) setState(target, 'immobilise', true, evt);
            target.messages.push("est agripp\xE9");
          }
        }
        if (options.devorer) {
          target.messages.push(nomPerso(attaquant) + " saisit " + nomPerso(target) + " entre ses crocs et ses griffes");
          if (attackLabel) {
            let cmdAttaqueGratuite = '!cof-attack ' + attaquant.token.id + ' ' + target.token.id + ' ' + attackLabel;
            target.messages.push(boutonSimple(cmdAttaqueGratuite, 'Attaque gratuite'));
          } else {
            target.messages.push(nomPerso(attaquant) + " a droit \xE0 une attaque gratuite contre " + nomPerso(target));
          }
          let attackerForce = valAttribute(attaquant, 'FOR', 'force');
          let targetForce = valAttribute(target, 'FOR', 'force');
          if (targetForce <= attackerForce) {
            if (attributeAsBool(target, 'armureDEau')) {
              target.messages.push("L'armure d'eau emp\xEAche " + nomPerso(target) + " d'\xEAtre saisi");
            } else {
              setState(target, 'renverse', true, evt);
              setState(target, 'immobilise', true, evt);
              setTokenAttr(attaquant, 'devore', idName(target), evt);
              setTokenAttr(target, 'estDevorePar', idName(attaquant), evt);
            }
          }
        }
        if (options.attaqueViolente) {
          target.messages.push(nomPerso(attaquant) + " fait une attaque violente. Jet de force oppos\xE9 pour voir si " + nomPerso(target) + " se fait projeter");
          target.effets.push({
            attaqueViolente: true,
            save: true
          });
        }
        if (options.ecraser) {
          target.messages.push(nomPerso(attaquant) + " saisit " + nomPerso(target) + " entre ses bras puissants");
          if (options.ecraser === true) {
            error("Il faudrait pr\xE9ciser un label pour \xE9craser", options.ecraser);
          } else {
            let cmdEcraser = '!cof-attack ' + attaquant.token.id + ' ' + target.token.id + ' ' + options.ecraser;
            target.messages.push("et l'" + boutonSimple(cmdEcraser, '\xE9crase') + ".");
          }
          if (attributeAsBool(target, 'armureDEau')) {
            target.messages.push("L'armure d'eau emp\xEAche " + nomPerso(target) + " d'\xEAtre saisi");
          } else {
            setTokenAttr(attaquant, 'ecrase', idName(target), evt);
            setTokenAttr(target, 'estEcrasePar', idName(attaquant), evt);
          }
        }
        if (options.saisirEtBroyer) {
          target.messages.push(nomPerso(attaquant) + " soul\xE8ve " + nomPerso(target) + " gesticulant" + eForFemale(target));
          if (attackLabel) {
            let cmdAttaqueGratuiteSaisi = '!cof-attack ' + attaquant.token.id + ' ' + target.token.id + ' ' + attackLabel + ' --bonusAttaque 5';
            target.messages.push(boutonSimple(cmdAttaqueGratuiteSaisi, 'Attaque gratuite'));
          } else {
            target.messages.push(nomPerso(attaquant) + " a droit \xE0 une attaque gratuite contre " + nomPerso(target));
          }
          if (valAttribute(target, 'FOR', 'force') < valAttribute(attaquant, 'FOR', 'force')) {
            options.rolls = options.rolls || [];
            let distanceSaisiProjete = options.rolls['distanceSaisiProjection_' + target.token.id] ||
              rollDePlus(6, {
                nbDes: 2
              });
            evt.action.rolls['distanceSaisiProjection_' + target.token.id] = distanceSaisiProjete;
            if (predicateAsBool(target, 'inderacinable')) {
              distanceSaisiProjete.val /= 2;
              distanceSaisiProjete.roll = '(' + distanceSaisiProjete.roll + ')/2 = ' + distanceSaisiProjete.val;
            }
            target.additionalDmg.push({
              type: 'normal',
              value: Math.floor(distanceSaisiProjete.val)
            });
            target.messages.push(nomPerso(target) + " est projet\xE9" + eForFemale(target) + " sur " + distanceSaisiProjete.roll + " m\xE8tres");
          }
        }
        if (options.projection && taillePersonnage(attaquant, 4) > taillePersonnage(target, 4)) {
          let bonusProjection = 5 - taillePersonnage(target, 4);
          options.rolls = options.rolls || [];
          let distanceProjetee =
            options.rolls['distanceProjection_' + target.token.id] ||
            rollDePlus(6, {
              bonus: bonusProjection
            }).val;
          evt.action.rolls['distanceProjection_' + target.token.id] = distanceProjetee;
          let dmgProjection = "3d6";
          if (predicateAsBool(target, 'inderacinable')) {
            distanceProjetee /= 2;
            dmgProjection = "floor(" + dmgProjection + "/2)";
          }
          target.effets.push({
            effet: 'etourdiTemp',
            duree: 100,
            message: messageOfEffetTemp('etourdiTemp'),
            save: {
              carac: 'CON',
              seuil: 15
            },
            saveParTour: {
              carac: 'CON',
              seuil: 15
            }
          });
          target.additionalDmg.push({
            type: 'normal',
            value: dmgProjection
          });
          target.messages.push(nomPerso(target) + " est projet\xE9 sur " + distanceProjetee + " m\xE8tres");
        }
        if (options.gober && taillePersonnage(attaquant, 4) > taillePersonnage(target, 4)) {
          //On utilise la liste d'effets pour pouvoir g\xE9rer les jets asynchrones
          target.effets.push({
            gober: true,
            save: true
          });
        }
        let attDMBonus = attDMBonusCommun;
        //Les modificateurs de d\xE9g\xE2ts qui d\xE9pendent de la cible
        if (target.tempDmg) {
          let forceTarg = modCarac(target, 'force');
          if (forceTarg < 0) {
            attDMBonus += " +" + (-forceTarg);
          } else {
            attDMBonus += " -" + forceTarg;
          }
        }
        if (options.pressionMortelle || target.pressionMortelle) {
          let pMortelle = tokenAttribute(target, 'pressionMortelle');
          if (pMortelle.length === 0) {
            sendPerso(attaquant, "essaie une pression mortelle, mais aucun point vital de " + nomPerso(target) + " n'a encore \xE9t\xE9 affect\xE9");
            ciblesCount--;
            return;
          }
          target.pressionMortelle = pMortelle;
          attDMBonus = "+ " + pMortelle[0].get('current');
        }
        if (options.distance && !options.grenaille) {
          let tirPrecis = predicateAsInt(attaquant, 'tirPrecis', 0);
          if (tirPrecis > 0) {
            let modDex = modCarac(attaquant, 'dexterite');
            if (target.distance <= 5 * modDex) {
              attDMBonus += " + " + tirPrecis;
              target.messages.push("Tir pr\xE9cis : +" + tirPrecis + " DM");
            }
          }
        }
        let sournoise = options.sournoise || 0;
        if (target.sournoise) sournoise += target.sournoise;
        if (target.critique && sournoise === 0 && predicateAsBool(attaquant, 'botteSecrete')) {
          sournoise = predicateAsInt(attaquant, 'attaqueSournoise', 1);
          target.messages.push("Botte secr\xE8te !");
        }
        if (sournoise) {
          let limiteSournoisesParTour = predicateAsInt(attaquant, 'sournoisesParTour', 1);
          let nbSournoises = attributeAsInt(attaquant, 'limiteParTour_sournoises', limiteSournoisesParTour);
          if (nbSournoises < 1) {
            explications.push("Plus d'attaque sournoise possible ce tour");
          } else {
            setTokenAttr(attaquant, 'limiteParTour_sournoises', nbSournoises - 1, evt);
            if (predicateAsBool(target, 'immuniteAuxSournoises')) {
              target.messages.push(nomPerso(target) + " est immunis\xE9" + eForFemale(target) + " aux attaques sournoises");
            } else {
              if (options.ouvertureMortelle) {
                target.messages.push("Ouverture mortelle => + 2 x " + sournoise + options.d6 + " DM");
                sournoise = sournoise * 2;
              } else {
                target.messages.push("Attaque sournoise => +" + sournoise + options.d6 + " DM");
              }
              let valueSournoise = sournoise + options.d6;
              if (predicateAsBool(target, 'armureProtection') && ficheAttributeAsBool(target, 'defarmureon', false)) {
                target.messages.push("L'armure de protection de " + nomPerso(target) + " r\xE9duit l'attaque sournoise");
                valueSournoise = "ceil(" + valueSournoise + "/2)";
              } else if (predicateAsBool(target, 'bouclierProtection') && ficheAttributeAsInt(target, 'defbouclieron', 0)) {
                target.messages.push("Le bouclier de protection de " + nomPerso(target) + " r\xE9duit l'attaque sournoise");
                valueSournoise = "ceil(" + valueSournoise + "/2)";
              } else if (predicateAsBool(target, 'anneauProtection')) {
                target.messages.push("L'anneau de protection de " + nomPerso(target) + " r\xE9duit l'attaque sournoise");
                valueSournoise = "ceil(" + valueSournoise + "/2)";
              }
              target.additionalDmg.push({
                type: mainDmgType,
                value: valueSournoise
              });
            }
          }
        }
        if (target.faireMouche) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: target.faireMouche + options.d6
          });
          target.messages.push(nomPerso(attaquant) + " profite de l'ouverture et son attaque fait mouche !");
        }
        if (target.chasseurEmerite) {
          attDMBonus += "+2";
        }
        if (target.combattreLaCorruption) {
          attDMBonus += "+" + target.combattreLaCorruption;
        }
        if (target.attaqueDansLeNoir) {
          attDMBonus += '-' + target.attaqueDansLeNoir;
        }
        if (predicateAsBool(attaquant, 'chasseurDeSorciere') && predicateAsBool(target, 'necromancien')) {
          attDMBonus += "+2";
          target.messages.push("Chasseur de sorci\xE8re => +2 en DM");
        }
        if (target.ennemiJure) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1' + options.d6
          });
        }
        if (target.cibleLiberateurDeDorn) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '2' + options.d6
          });
        }
        if (target.cibleLiberateurDeKerserac) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1' + options.d6
          });
        }
        if (target.cibleLiberateurDAnathazerin) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '2' + options.d6
          });
        }
        if (target.tueurDeGeants || target.tueurDe) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '2' + options.d6
          });
        }
        if (target.cibleMeneurDHommes) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1' + options.d6
          });
        }
        if (target.armeDArgent) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1d6'
          });
        }
        if (target.estAgrippee) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1d6'
          });
        }
        if (options.lienEpique && attaqueParLienEpique.has(target.token.id)) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1' + options.d6
          });
          target.messages.push("Lien \xE9pique => + 1" + options.d6 + " DM");
        }
        if (target.feinte) {
          let value = target.feinte + options.d6;
          if (options.attaqueFlamboyanteBonus)
            value += "+" + options.attaqueFlamboyanteBonus;
          target.additionalDmg.push({
            type: mainDmgType,
            value
          });
        }
        let targetTaille = taillePersonnage(target, 4);
        if (options.tueurDeGrands) {
          if (targetTaille == 5) {
            target.additionalDmg.push({
              type: mainDmgType,
              value: '1d6'
            });
            target.messages.push("Cible grande => +1d6 DM");
          } else if (targetTaille > 5) {
            target.additionalDmg.push({
              type: mainDmgType,
              value: '2d6'
            });
            target.messages.push("Cible \xE9norme => +2d6 DM");
          }
        }
        if (options.contact && weaponStats.deuxMains && targetTaille > 4) {
          if (predicateAsBool(attaquant, 'bucheron')) {
            if (targetTaille == 5) {
              target.additionalDmg.push({
                type: mainDmgType,
                value: '1d6'
              });
              target.messages.push("Arme tenue \xE0 2 mains => +1d6 DM");
            } else if (targetTaille > 5) {
              target.additionalDmg.push({
                type: mainDmgType,
                value: '2d6'
              });
              target.messages.push("Arme tenue \xE0 2 mains et cible \xE9norme => +2d6 DM");
            }
          }
          if (predicateAsBool(attaquant, 'grosMonstreGrosseArme')) {
            options.puissant = true;
            target.messages.push("Gros Monstre, grosse arme => d\xE9g\xE2ts de base augment\xE9s");
          }
        }
        if (attributeAsBool(target, 'hemorragie') && !options.sortilege && !options.armeNaturelle) {
          let sourceDrain = saignementAvecDrain(target, 'hemorragie', pageId);
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1d6',
            drainDeSang: sourceDrain
          });
          target.messages.push("H\xE9morragie => +1d6 DM");
        }
        if (!options.pasDeDmg) {
          let loupParmiLesLoups = predicateAsInt(attaquant, 'loupParmiLesLoups', 0);
          if (loupParmiLesLoups > 0 && estHumanoide(target)) {
            attDMBonus += "+" + loupParmiLesLoups;
            target.messages.push("Loup parmi les loups : +" + loupParmiLesLoups + " DM");
          }
          if (predicateAsBool(attaquant, 'langageSombreHetre') && estElfeNoir(target)) {
            attDMBonus += "+1";
            target.messages.push("Langage sombre : +1 DM");
          }
        }
        if (predicateAsBool(attaquant, 'laissezLeMoi') &&
          getState(target, 'chef')) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1d6'
          });
          target.messages.push("Laissez-le moi ! => +1d6 DM");
        }
        //Bonus aux DMs dus au d\xE9fi samoura\xEF
        let defiSamouraiAttr = tokenAttribute(attaquant, 'defiSamourai');
        if (defiSamouraiAttr.length > 0) {
          defiSamouraiAttr = defiSamouraiAttr[0];
          let cibleDefi = defiSamouraiAttr.get('max');
          if (cibleDefi.startsWith(target.token.id)) cibleDefi = true;
          else {
            let cibleDefiSep = cibleDefi.indexOf(' ');
            let cibleDefiName = cibleDefi.substring(cibleDefiSep + 1);
            if (cibleDefiName == nomPerso(target)) {
              let cibleDefiId = cibleDefi.substring(0, cibleDefiSep);
              cibleDefi = persoOfId(cibleDefiId, cibleDefiName, pageId);
              cibleDefi = cibleDefi === undefined || cibleDefi.id == target.id;
            } else cibleDefi = false;
          }
          if (cibleDefi) {
            let bonusDefi = parseInt(defiSamouraiAttr.get('current'));
            target.additionalDmg.push({
              type: mainDmgType,
              value: bonusDefi
            });
            target.messages.push(attackerTokName + " b\xE9n\xE9ficie d'un bonus de +" + bonusDefi + " aux DMs contre " + nomPerso(target));
          }
        }
        if (options.vicieux) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '2d6'
          });
          target.messages.push("Arme vicieuse => +2d6 DM");
        }
        if (attributeAsBool(attaquant, 'ombreMortelle') ||
          attributeAsBool(attaquant, 'dedoublement') ||
          (charAttributeAsBool(attaquant, 'armeeConjuree') && attributeAsBool(target, 'attaqueArmeeConjuree'))) {
          if (options.divise) options.divise *= 2;
          else options.divise = 2;
        }
        if (options.attaqueAssuree || options.echecTotal) {
          if (options.divise) options.divise *= 2;
          else options.divise = 2;
        }
        let mainDmgRollExpr;
        if (target.dmRate) {
          mainDmgRollExpr = options.dmSiRate.value;
          mainDmgType = options.dmSiRate.type;
        } else if (options.dmCible && options.dmCible.target && options.dmCible.target.id === target.token.id) {
          mainDmgRollExpr = options.dmCible.value;
          mainDmgType = options.dmCible.type;
        } else {
          mainDmgRollExpr = computeMainDmgRollExpr(attaquant, target, weaponStats, attNbDices,
            attDMBonus, options);
        }
        //Additional damage
        let additionalDmg = attaquant.additionalDmg.concat(target.additionalDmg);
        //On enl\xE8ve les DM qui ne passent pas les conditions
        additionalDmg = additionalDmg.filter(function(dmSpec) {
          if (dmSpec.conditions === undefined) return true;
          return dmSpec.conditions.every(function(cond) {
            return testCondition(cond, attaquant, [target], d20roll, options);
          });
        });
        if (!options.sortilege && !options.magique &&
          predicateAsBool(target, 'immuniteAuxArmes')) {
          additionalDmg = additionalDmg.filter(function(dmSpec) {
            switch (dmSpec.type) {
              case undefined:
              case 'normal':
              case 'poison':
              case 'maladie':
                return false;
              default:
                return true;
            }
          });
        }
        if (options.tirDouble || options.tirDeBarrage || options.dmFoisDeux) {
          if (options.tirDouble && options.tirDouble.stats) {
            let stats2 = options.tirDouble.stats;
            mainDmgRollExpr += " +" +
              computeMainDmgRollExpr(attaquant, target, stats2, stats2.attNbDices,
                attDMBonus, options);
          } else {
            mainDmgRollExpr += " +" + mainDmgRollExpr;
          }
          additionalDmg.forEach(function(dmSpec) {
            dmSpec.value += " +" + dmSpec.Value;
          });
        }
        if (target.etreinteImmole) {
          additionalDmg.push({
            value: mainDmgRollExpr,
            type: 'feu'
          });
        }
        let extraDmgRollExpr = "";
        additionalDmg = additionalDmg.filter(function(dmSpec) {
          dmSpec.type = dmSpec.type || 'normal';
          if (dmSpec.type != mainDmgType || isNaN(dmSpec.value)) {
            extraDmgRollExpr += " [[" + dmSpec.value + "]]";
            return true;
          }
          // We have the same type and a constant -> should be multiplied by crit
          mainDmgRollExpr += " + " + dmSpec.value;
          return false;
        });
        // On ajoute le jet pour les d\xE9g\xE2ts de critiques suppl\xE9mentaires
        if (target.critique && options.additionalCritDmg) {
          options.additionalCritDmg.forEach(function(dmSpec) {
            extraDmgRollExpr += " [[" + dmSpec.value + "]]";
          });
        }
        if (options.maxDmg && options.runeDePuissance) {
          extraDmgRollExpr = extraDmgRollExpr.replace(/\[\[(\d+)d([\d\+\-]+)\]\]/g, '[[$1*$2]]');
        }
        if (options.aveugleManoeuvre) {
          mainDmgRollExpr += " -5";
        }
        let mainDmgRoll = {
          type: mainDmgType,
          value: mainDmgRollExpr
        };
        // toEvaluateDmg inlines
        // 0 : roll de d\xE9g\xE2ts principaux
        // 1+ : les rolls de d\xE9g\xE2ts suppl\xE9mentaires
        // 1+nb d\xE9g\xE2ts suppl\xE9mentaires + : rolls de d\xE9g\xE2ts critiques
        let toEvaluateDmg = "[[" + mainDmgRollExpr + "]]" + extraDmgRollExpr;
        sendChat('', toEvaluateDmg, function(resDmg) {
          let rollsDmg = target.rollsDmg || resDmg[0];
          let afterEvaluateDmg = rollsDmg.content.split(' ');
          let mainDmgRollNumber = rollNumber(afterEvaluateDmg[0]);
          mainDmgRoll.total = rollsDmg.inlinerolls[mainDmgRollNumber].results.total;
          mainDmgRoll.display = buildinline(rollsDmg.inlinerolls[mainDmgRollNumber], mainDmgType, options.magique);
          if (target.critique && options.additionalCritDmg) {
            let firstCritRoll = 1 + additionalDmg.length;
            target.additionalCritDmg = [];
            let rollsCrit = resDmg[0];
            if (target.rollsDmg && target.rollsDmg.length >= firstCritRoll + options.additinalCritDmg.length)
              rollsCrit = target.rollsDmg;
            options.additionalCritDmg.forEach(function(dmSpec, i) {
              var rRoll = rollsCrit.inlinerolls[rollNumber(afterEvaluateDmg[i + firstCritRoll])];
              if (rRoll) {
                target.additionalCritDmg.push(dmSpec);
                dmSpec.total = dmSpec.total || rRoll.results.total;
                let addDmType = dmSpec.type || 'normal';
                dmSpec.display = dmSpec.display || buildinline(rRoll, addDmType, options.magique);
              } else { //l'expression de DM additionel est mal form\xE9e
                error("Expression de d\xE9g\xE2ts de critiques mal form\xE9e : " + options.additionalCritDmg[i].value, options.additionalCritDmg[i]);
              }
            });
            if (target.additionalCritDmg.length === 0) delete target.additionalCritDmg;
          }
          let correctAdditionalDmg = [];
          additionalDmg.forEach(function(dmSpec, i) {
            let rRoll = rollsDmg.inlinerolls[rollNumber(afterEvaluateDmg[i + 1])];
            if (rRoll) {
              correctAdditionalDmg.push(dmSpec);
              dmSpec.total = dmSpec.total || rRoll.results.total;
              let addDmType = dmSpec.type;
              dmSpec.display = dmSpec.display || buildinline(rRoll, addDmType, options.magique);
            } else { //l'expression de DM additionel est mal form\xE9e
              error("Expression de d\xE9g\xE2ts suppl\xE9mentaires mal form\xE9e : " + additionalDmg[i].value, additionalDmg[i]);
            }
          });
          if (options.expertDuCombatDMSpec) {
            correctAdditionalDmg.push(options.expertDuCombatDMSpec);
          }
          additionalDmg = correctAdditionalDmg;
          if (target.touche) { //Devrait \xEAtre inutile ?
            if (options.tirDeBarrage)
              target.messages.push("Tir de barrage : undo si la cible d\xE9cide de ne pas bouger");
            if (options.pointsVitaux)
              target.messages.push(attackerTokName + " vise des points vitaux mais ne semble pas faire de d\xE9g\xE2ts");
            if (options.pressionMortelle || target.pressionMortelle) {
              removeTokenAttr(target, 'pressionMortelle', evt);
              target.messages.push(attackerTokName + " lib\xE8re la pression des points vitaux, l'effet est d\xE9vastateur !");
              spawnFx(target.token.get('left'), target.token.get('top'), 'bomb-death', pageId);
            }
            if (options.pasDeDmg === undefined) { //si l'attaque fait des DM, possibilit\xE9 d'attaque en tra\xEEtre
              if (attaquant.alliesAvecAttaqueEnTraitre === undefined) {
                attaquant.alliesAvecAttaqueEnTraitre = [];
                //On cherche tous les alli\xE9s ayant l'attaque en traitre
                const allies = alliesParPerso[attaquant.charId] || new Set();
                allies.forEach(function(ci) {
                  if (!charPredicateAsBool(ci, 'attaqueEnTraitre')) return;
                  let tokens = findObjs({
                    _type: 'graphic',
                    _subtype: 'token',
                    _pageid: pageId,
                    represents: ci
                  });
                  tokens.forEach(function(tok) {
                    let perso = {
                      charId: ci,
                      token: tok
                    };
                    if (capaciteDisponibleSachantPred(perso, 'attaqueEnTraitre', 'tour')) {
                      attaquant.alliesAvecAttaqueEnTraitre.push(tok);
                    }
                  });
                });
              }
              attaquant.alliesAvecAttaqueEnTraitre.forEach(function(tok) {
                if (tok.id == target.id) return;
                if (distanceCombat(target.token, tok, pageId) === 0) {
                  let aetp = attaquesEnTraitrePossibles[tok.id];
                  if (aetp === undefined) {
                    aetp = [];
                    attaquesEnTraitrePossibles[tok.id] = aetp;
                  }
                  aetp.push(target);
                }
              });
            }
            // change l'\xE9tat de la cible, si sp\xE9cifi\xE9
            if (target.enflamme) {
              let enflammePuissance = 1;
              if (options.puissant) enflammePuissance = 2;
              setTokenAttr(target, 'enflamme', enflammePuissance, evt);
              let ms = messageEffetCombat.enflamme.statusMarker;
              if (ms) {
                affectToken(target.token, 'statusmarkers', target.token.get('statusmarkers'), evt);
                target.token.set('status_' + ms, true);
              }
              target.messages.push(nomPerso(target) + " prend feu !");
            }
            if (target.malediction) {
              setTokenAttr(target, 'malediction', 3, evt);
              target.messages.push(nomPerso(target) + " est maudit" + eForFemale(target) + "...");
            }
            if (options.attaqueBouclierRenverse && weaponStats.attDice == 4 &&
              rollsDmg.inlinerolls[mainDmgRollNumber].results.rolls[0].results[0].v >= 4) {
              target.etats = target.etats || [];
              target.etats.push({
                etat: 'renverse',
                condition: {
                  type: "moins",
                  attribute: "FOR",
                  text: 'force'
                }
              });
            }
            // Draw effect, if any
            if (options.fx) {
              //Pour les cones, on fait un seul effet, car c'est bien g\xE9r\xE9.
              if (!options.aoe || options.aoe.type != 'cone') {
                let tokenOrigine = attackingToken;
                if (options.origineDeLAttaque)
                  tokenOrigine = options.origineDeLAttaque.token;
                let p1e = {
                  x: tokenOrigine.get('left'),
                  y: tokenOrigine.get('top'),
                };
                let p2e = {
                  x: target.token.get('left'),
                  y: target.token.get('top'),
                };
                spawnFxBetweenPoints(p1e, p2e, options.fx, pageId);
              }
            }
            if (options.targetFx && !options.aoe) {
              spawnFx(target.token.get('left'), target.token.get('top'), options.targetFx, pageId);
            }
            target.rollsDmg = rollsDmg;
            let affaiblissements = options.affaiblissementsCarac;
            if (target.affaiblissementsCarac) {
              if (affaiblissements)
                affaiblissements = affaiblissements.concat(target.affaiblissementsCarac);
              else affaiblissements = target.affaiblissementsCarac;
            }
            if (affaiblissements) {
              let expliquer = function(s) {
                target.messages.push(s);
              };
              affaiblissements.forEach(function(aff) {
                let carac = aff.carac;
                if (carac == 'random') {
                  let id = 'affaiblissement' + aff.val + '_' + target.token.id;
                  carac = randomCaracForId(id, options);
                }
                affaiblirCaracPerso(target, carac, aff.val, expliquer, evt);
              });
            }
            // Compte le nombre de saves pour la synchronisation
            // (On ne compte pas les psave, g\xE9r\xE9s dans dealDamage)
            let saves = 0;
            //ajoute les \xE9tats sans save \xE0 la cible
            let etats = options.etats;
            if (target.etats) {
              if (etats) etats = etats.concat(target.etats);
              else etats = target.etats;
            }
            if (etats) {
              etats.forEach(function(ce) {
                if (options.sortilege &&
                  ((predicateAsBool(target, 'liberteDAction') && (
                      ce.etat == 'apeure' ||
                      ce.etat == 'endormi' ||
                      ce.etat == 'etourdi' ||
                      ce.etat == 'immobilise' ||
                      ce.etat == 'paralyse' ||
                      ce.etat == 'ralenti'
                    )) ||
                    (predicateAsBool(target, 'actionLibre') && (ce.etat == 'ralenti' || ce.etat == 'immobilise' || ce.etat == 'paralyse')) ||
                    (predicateAsInt(target, 'voieDeLArchange', 1) > 1 && (ce.etat == 'ralenti' || ce.etat == 'immobilise') && attributeAsBool(target, 'formeDAnge'))
                  )) {
                  target.messages.push(nomPerso(target) + " reste libre de ses mouvements !");
                  return;
                }
                if (ce.save) {
                  saves++;
                  return; //on le fera plus tard
                }
                if (ce.typeDmg && immuniseAuType(target, ce.typeDmg, attaquant)) {
                  if (!target['msgImmunite_' + ce.typeDmg]) {
                    target.messages.push(nomPerso(target) + " ne semble pas affect\xE9" + eForFemale(target) + " par " + stringOfType(ce.typeDmg));
                    target['msgImmunite_' + ce.typeDmg] = true;
                  }
                  return;
                }
                if (testCondition(ce.condition, attaquant, [target], d20roll, options)) {
                  setState(target, ce.etat, true, evt);
                  let msgEtat;
                  if (ce.etat == 'mort')
                    msgEtat = 'tu\xE9' + eForFemale(target);
                  else
                    msgEtat = stringOfEtat(ce.etat, target);
                  target.messages.push(nomPerso(target) + " est " + msgEtat + " par l'attaque");
                  if (ce.saveCarac) {
                    setTokenAttr(target, ce.etat + 'Save', ce.saveCarac, evt, {
                      maxVal: ce.saveDifficulte
                    });
                  }
                  if (ce.saveParTour) {
                    setTokenAttr(target, ce.etat + 'SaveParTour', ce.saveParTour.carac, evt, {
                      maxVal: ce.saveParTour.seuil
                    });
                  }
                } else {
                  if (ce.condition.type == "moins") {
                    target.messages.push(
                      "Gr\xE2ce \xE0 sa " + ce.condition.text + ", " + nomPerso(target) +
                      " n'est pas " + stringOfEtat(ce.etat, target));
                  }
                }
              });
            }
            let savesEffets = 0;
            // Ajoute les effets sans save \xE0 la cible
            let effets = options.effets;
            if (target.effets) {
              if (effets) effets = effets.concat(target.effets);
              else effets = target.effets;
            }
            if (effets) {
              effets.forEach(function(ef) {
                if (((options.sortilege || options.mana !== undefined) &&
                    (predicateAsBool(target, 'liberteDAction') && (
                      ef.effet == 'apeureTemp' ||
                      ef.effet == 'endormiTemp' ||
                      ef.effet == 'etourdiTemp' ||
                      ef.effet == 'immobiliseTemp' ||
                      ef.effet == 'paralyseTemp' ||
                      ef.effet == 'ralentiTemp' ||
                      ef.entrave
                    ))) ||
                  (ef.effet == 'paralyseGoule' &&
                    (predicateAsBool(target, 'liberteDAction') || predicateAsBool(target, 'actionLibre'))
                  ) ||
                  (predicateAsBool(target, 'actionLibre') && (
                    ef.effet == 'ralentiTemp' ||
                    ef.effet == 'immobiliseTemp' ||
                    ef.effet == 'paralyseTemp')) ||
                  (ef.entrave && ef.effet != 'paralyseTemp' && ef.effet != 'paralyseGoule' && predicateAsInt(target, 'voieDeLArchange', 1) > 1 && attributeAsBool(target, 'formeDAnge'))
                ) {
                  target.messages.push(nomPerso(target) + " reste libre de ses mouvements !");
                  return;
                }
                if (ef.effet == 'paralyseGoule' &&
                  (estElfe(target) ||
                    (predicateAsInt(target, 'voieDeLArchange', 1) > 2 && attributeAsBool(target, 'formeDAnge')))
                ) {
                  target.messages.push(nomPerso(target) + " est immunis\xE9 \xE0 la paralysie des goules");
                  return;
                }
                if (ef.effet == 'affaibliTemp' && estMortVivant(attaquant) && predicateAsInt(target, 'voieDeLArchange', 1) > 2 && attributeAsBool(target, 'formeDAnge')) {
                  target.messages.push(nomPerso(target) + " est insensible aux affaiblissements des morts-vivants.");
                  return;
                }
                if (ef.save) {
                  saves++;
                  savesEffets++;
                  return; //on le fera plus tard
                }
                if (ef.typeDmg && immuniseAuType(target, ef.typeDmg, attaquant)) {
                  if (!target['msgImmunite_' + ef.typeDmg]) {
                    target.messages.push(nomPerso(target) + " ne semble pas affect\xE9 par " + stringOfType(ef.typeDmg));
                    target['msgImmunite_' + ef.typeDmg] = true;
                  }
                  return;
                }
                ef.attaquant = attaquant;
                setEffetTemporaire(target, ef, ef.duree, evt, options);
              });
            }
            // Tout ce qui se passe apr\xE8s les saves (autres que saves de diminution des dmg
            let afterSaves = function() {
              if (saves > 0) return; //On n'a pas encore fait tous les saves
              if (target.utiliseRuneProtection) {
                target.messages.push(nomPerso(target) + " utilise sa Rune de Protection pour annuler les dommages");
                addToAttributeAsInt(target, 'limiteParCombat_runeForgesort_protection', 1, -1, evt);
                // Pas de d\xE9g\xE2ts, donc pas d'appel \xE0 dealDamage
                finCibles();
              } else if (options.pasDeDmg ||
                (additionalDmg.length === 0 && mainDmgRoll.total === 0 && attNbDices === 0)) {
                // Pas de d\xE9g\xE2ts, donc pas d'appel \xE0 dealDamage
                finCibles();
              } else {
                dealDamage(target, mainDmgRoll, additionalDmg, evt, target.critique,
                  options, target.messages,
                  function(dmgDisplay, dmg, dmgDrain) {
                    if (options.strigeSuce) {
                      let suce = attributeAsInt(attaquant, 'strigeSuce', 0);
                      if (suce === 0) {
                        setTokenAttr(attaquant, 'bufDEF', -3, evt);
                        target.messages.push(
                          attackerTokName + " s'agrippe \xE0 " + nomPerso(target) +
                          " et commence \xE0 lui sucer le sang");
                      }
                      if (suce + dmg >= 6) {
                        target.messages.push(
                          "Repus, " + attackerTokName + " se d\xE9tache et s'envole");
                        target.messages.push(nomPerso(target) + " se sent un peu faible...");
                        setState(target, 'affaibli', true, evt);
                        let defbuf = attributeAsInt(attaquant, 'bufDEF', 0);
                        if (defbuf === -3) {
                          removeTokenAttr(attaquant, 'bufDEF', evt);
                        } else if (defbuf !== 0) {
                          setTokenAttr(attaquant, 'bufDEF', defbuf + 3, evt);
                        }
                      } else {
                        setTokenAttr(attaquant, 'strigeSuce', suce + dmg, evt);
                        if (suce > 0)
                          target.messages.push(
                            attackerTokName + " continue \xE0 sucer le sang de " + nomPerso(target));
                      }
                    }
                    if (dmgDrain || (dmg > 0 && (options.vampirise || target.vampirise))) {
                      let pcVampirise = target.vampirise || options.vampirise;
                      let soinsVamp = dmgDrain || 0;
                      if (pcVampirise) soinsVamp += Math.ceil(dmg * pcVampirise / 100);
                      let lie = personnageAmeLiee(attaquant);
                      soigneToken(attaquant, soinsVamp, evt, function(soins) {
                        target.messages.push(
                          "L'attaque soigne " + attackerTokName + " de " + soins + " PV");
                        if (lie && (soins > 4 || soins < soinsVamp)) {
                          let soin2 = soinsVamp - soins + Math.floor(soins / 5);
                          soigneToken(lie, soin2, evt, function(s) {
                            target.messages.push("L'attaque soigne aussi " + nomPerso(lie) + " de " + s + " PV");
                          });
                        }
                      }, function() {
                        if (lie) {
                          soigneToken(lie, soinsVamp, evt, function(soins) {
                            target.messages.push("L'attaque soigne " + nomPerso(lie) + " de " + soins + " PV");
                          });
                        }
                      });
                    }
                    let absorptionEnergie = predicateAsInt(attaquant, 'absorptionEnergie', 0, 5);
                    if (absorptionEnergie > 0) {
                      if ((estMortVivant(attaquant) && predicateAsInt(target, 'voieDeLArchange', 1) > 2 && attributeAsBool(target, 'formeDAnge')) ||
                        (predicateAsBool(attaquant, 'vampire') && predicateAsBool(target, 'immuniteAbsorptionVampire'))
                      ) {
                        target.messages.push(nomPerso(target) + "n'est pas affect\xE9" + eForFemale(target) + " par l'absorption d'\xE9nergie");
                      } else {
                        soigneToken(attaquant, absorptionEnergie, evt, function(soins) {
                          target.messages.push(
                            "L'attaque soigne " + attackerTokName + " de " + soins + " PV");
                        });
                        if (predicateAsBool(attaquant, 'vampire')) {
                          let pointsDeSang = attributeAsInt(target, 'pointsDeSang', 0);
                          pointsDeSang++;
                          if (pointsDeSang > ficheAttributeAsInt(target, 'niveau', 1)) {
                            target.messages.push(
                              "tombe inconscient" + eForFemale(target) + ". " +
                              onGenre(target, "Il", "Elle") +
                              " a trop de points de sang..."
                            );
                            setState(target, 'endormi', evt);
                          }
                          setTokenAttr(target, 'pointsDeSang', pointsDeSang, evt);
                        }
                      }
                    }
                    target.dmgMessage = "<b>DM :</b> ";
                    if (ficheAttributeAsBool(attaquant, 'jets_caches', false)) {
                      target.dmgMessage += dmg;
                      sendChat('COF', "/w GM Jet cach\xE9 de dommages : " + dmgDisplay);
                    } else {
                      target.dmgMessage += dmgDisplay;
                    }
                    if (options.vicieux) {
                      ciblesCount++;
                      let dm = rollDePlus(6, {
                        type: mainDmgType,
                        nbDes: 1,
                      });
                      let r = {
                        type: mainDmgType,
                        display: dm.roll,
                        total: dm.val
                      };
                      dealDamage(attaquant, r, [], evt, false, options,
                        target.messages,
                        function(dmgDisplay, dmg, dmgDrain) {
                          let dmgMsg =
                            "<b>" + attackerTokName + " subit :</b> " +
                            dmgDisplay + " DM de l'arme vicieuse";
                          target.messages.push(dmgMsg);
                          finCibles();
                        });
                    }
                    if (options.contact) {
                      //Les DMs automatiques en cas de toucher une cible
                      if (attributeAsBool(target, 'sousTension')) {
                        ciblesCount++;
                        let dm = '1d6';
                        let attrsVal = tokenAttribute(target, 'sousTensionValeur');
                        if (attrsVal.length === 0) {
                          if (predicateAsInt(target, 'voieDeLaMagieElementaliste', 0) > 3)
                            dm = '2d6';
                        } else
                          dm = attrsVal[0].get('current');
                        let exprSousTension = '[[' + dm + ']]';
                        sendChat('', exprSousTension, function(res) {
                          let rolls = res[0];
                          let explRoll = rolls.inlinerolls[0];
                          let r = {
                            total: explRoll.results.total,
                            type: 'electrique',
                            display: buildinline(explRoll, 'electrique', true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg, dmgDrain) {
                              let dmgMsg =
                                "<b>D\xE9charge \xE9lectrique sur " + attackerTokName + " :</b> " +
                                dmgDisplay;
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      }
                      if (attributeAsBool(target, 'sangMordant')) {
                        ciblesCount++;
                        sendChat("", "[[1d6]]", function(res) {
                          let rolls = res[0];
                          let explRoll = rolls.inlinerolls[0];
                          let r = {
                            total: explRoll.results.total,
                            type: 'acide',
                            display: buildinline(explRoll, 'acide', true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg, dmgDrain) {
                              let dmgMsg =
                                "<b>Le sang acide gicle sur " + attackerTokName + " :</b> " +
                                dmgDisplay + " DM";
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      }
                      if (options.armeNaturelle && attributeAsBool(target, 'presenceGlaciale')) {
                        ciblesCount++;
                        let exprPresenceGlaciale = '[[';
                        let attrsPGValeur = tokenAttribute(target, 'presenceGlacialeValeur');
                        if (attrsPGValeur.length === 0) exprPresenceGlaciale += '1d6';
                        else exprPresenceGlaciale += attrsPGValeur[0].get('max');
                        exprPresenceGlaciale += ']]';
                        sendChat("", exprPresenceGlaciale, function(res) {
                          let rolls = res[0];
                          let explRoll = rolls.inlinerolls[0];
                          let r = {
                            total: explRoll.results.total,
                            type: 'froid',
                            display: buildinline(explRoll, 'froid', true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg, dmgDrain) {
                              let dmgMsg =
                                "<b>" + attackerTokName + " est glac\xE9 :</b> " +
                                dmgDisplay + " DM";
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      }
                      let tcs = predicatesNamed(target, 'dmSiToucheContact');
                      tcs.forEach(function(dstc) {
                        dstc = dstc.split(' --');
                        if (dstc.length < 1) return;
                        ciblesCount++;
                        sendChat("", "[[" + dstc[0] + "]]", function(res) {
                          let rolls = res[0];
                          let explRoll = rolls.inlinerolls[0];
                          let type = 'normal';
                          if (dstc.length > 1) type = dstc[1];
                          let r = {
                            total: explRoll.results.total,
                            type: type,
                            display: buildinline(explRoll, type, true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg, dmgDrain) {
                              let dmgMsg =
                                "<b>" + attackerTokName + " subit :</b> " +
                                dmgDisplay + " DM en touchant " + nomPerso(target);
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      });
                      let typeCorpsElem = predicateAsBool(target, 'corpsElementaire');
                      if (typeCorpsElem && typeCorpsElem !== true) {
                        ciblesCount++;
                        let nbDes = predicateAsInt(target, 'nbCorpsElementaire', 1);
                        let dm = rollDePlus(6, {
                          type: typeCorpsElem,
                          nbDes
                        });
                        let r = {
                          type: typeCorpsElem,
                          display: dm.roll,
                          total: dm.val
                        };
                        dealDamage(attaquant, r, [], evt, false, options,
                          target.messages,
                          function(dmgDisplay, dmg, dmgDrain) {
                            let dmgMsg =
                              "<b>" + attackerTokName + " subit :</b> " +
                              dmgDisplay + " DM en touchant " + nomPerso(target);
                            target.messages.push(dmgMsg);
                            finCibles();
                          });
                      }
                    }
                    finCibles();
                  });
              }
            };
            let expliquer = function(msg) {
              target.messages.push(msg);
            };
            //Ajoute les \xE9tats avec save \xE0 la cible
            let etatsAvecSave = function() {
              if (savesEffets > 0) return; //On n'a pas encore fini avec les effets
              if (etats && saves > 0) {
                etats.forEach(function(ce, index) {
                  if (ce.save) {
                    if (testCondition(ce.condition, attaquant, [target], d20roll, options)) {
                      let msgPour = " pour r\xE9sister \xE0 un effet";
                      let msgEtat;
                      if (ce.etat == 'mort')
                        msgEtat = 'tu\xE9' + eForFemale(target);
                      else
                        msgEtat = stringOfEtat(ce.etat, target);
                      let msgRate = ", " + nomPerso(target) + " est " + msgEtat + " par l'attaque";
                      let saveOpts = {
                        msgPour: msgPour,
                        msgRate: msgRate,
                        attaquant: attaquant,
                        sortilege: options.sortilege,
                        rolls: options.rolls,
                        chanceRollId: options.chanceRollId,
                        type: ce.typeDmg,
                        necromancie: estNecromancie(options)
                      };
                      let rollId = 'etat_' + ce.etat + index + '_' + target.token.id;
                      save(ce.save, target, rollId, expliquer, saveOpts, evt,
                        function(reussite, rolltext) {
                          if (!reussite) {
                            setState(target, ce.etat, true, evt);
                            if (ce.saveCarac) {
                              setTokenAttr(target, ce.etat + 'Save', ce.saveCarac, evt, {
                                maxVal: ce.saveDifficulte
                              });
                            }
                          }
                          saves--;
                          afterSaves();
                        });
                    } else {
                      if (ce.condition.type == "moins") {
                        target.messages.push(
                          "Gr\xE2ce \xE0 sa " + ce.condition.text + ", " + nomPerso(target) +
                          " n'est pas " + stringOfEtat(ce.etat, target));
                      }
                      saves--;
                      afterSaves();
                    }
                  }
                });
              } else afterSaves();
            };
            // Ajoute les effets avec save \xE0 la cible
            let effetsAvecSave = function() {
              if (effets && savesEffets > 0) {
                effets.forEach(function(ef, index) {
                  if (ef.save) {
                    if (ef.gober) {
                      let rollIdGober = 'gober_' + target.token.id;
                      testOppose(rollIdGober, target, 'FOR', options, attaquant, 'FOR',
                        options, target.messages, evt,
                        function(resultat, crit, rt1, rt2) {
                          if (resultat == 2) {
                            target.messages.push(nomPerso(target) + " est enti\xE8rement aval\xE9 par " + attackerTokName);
                            setTokenAttr(attaquant, 'aGobe', idName(target), evt);
                            setTokenAttr(target, 'estGobePar', idName(attaquant), evt);
                            moveTokenWithUndo(target.token, attaquant.token.get('left'), attaquant.token.get('top'), evt);
                          } else {
                            if (resultat === 0) diminueMalediction(attaquant, evt);
                            target.messages.push(nomPerso(target) + " n'est pas aval\xE9.");
                          }
                          saves--;
                          savesEffets--;
                          etatsAvecSave();
                        });
                    } else if (ef.attaqueViolente) {
                      let rollIdAtt = 'attaqueViolente_' + target.token.id;
                      testOppose(rollIdAtt, target, 'FOR', options, attaquant, 'FOR',
                        options, target.messages, evt,
                        function(resultat, crit, rt1, rt2) {
                          if (resultat == 2) {
                            let distance = rollDePlus(6);
                            target.messages.push(nomPerso(target) + " est projet\xE9" + eForFemale(target) + " \xE0 " +
                              distance.roll + " m\xE8tres et tombe au sol");
                            setState(target, 'renverse', true, evt);
                            if (attackLabel) {
                              let cmdAttaqueGratuite = '!cof-attack ' + attaquant.token.id + ' ' + target.token.id + ' ' + attackLabel;
                              target.messages.push(boutonSimple(cmdAttaqueGratuite, 'Attaque gratuite'));
                            } else {
                              target.messages.push(nomPerso(attaquant) + " a droit \xE0 une attaque gratuite contre " + nomPerso(target));
                            }
                          } else {
                            if (resultat === 0) diminueMalediction(attaquant, evt);
                            target.messages.push(nomPerso(target) + " tient bon et ne recule pas");
                          }
                          saves--;
                          savesEffets--;
                          etatsAvecSave();
                        });
                    } else {
                      if (ef.typeDmg && immuniseAuType(target, ef.typeDmg, attaquant)) {
                        if (!target['msgImmunite_' + ef.typeDmg]) {
                          target.messages.push(nomPerso(target) + " ne semble pas affect\xE9 par " + stringOfType(ef.typeDmg));
                          target['msgImmunite_' + ef.typeDmg] = true;
                        }
                        saves--;
                        savesEffets--;
                        etatsAvecSave();
                        return;
                      }
                      let msgPour = " pour ";
                      if (ef.msgSave) msgPour += ef.msgSave;
                      else msgPour += "r\xE9sister \xE0 un effet";
                      let msgRate = ", " + nomPerso(target) + " ";
                      if (ef.duree && ef.message) {
                        msgRate += messageActivation(target, ef.message);
                        if (stateCOF.options.affichage.val.duree_effets.val) msgRate += " (" + ef.duree + " tours)";
                      } else if (ef.effetIndetermine)
                        msgRate += messageActivation(target, messageEffetIndetermine[ef.effet]);
                      else
                        msgRate += messageActivation(target, messageEffetCombat[ef.effet]);
                      ef.pasDeMessageDActivation = true;
                      let saveOpts = {
                        msgPour: msgPour,
                        msgRate: msgRate,
                        attaquant: attaquant,
                        rolls: options.rolls,
                        sortilege: options.sortilege,
                        chanceRollId: options.chanceRollId,
                        type: ef.typeDmg,
                        necromancie: estNecromancie(options)
                      };
                      let rollId = 'effet_' + ef.effet + index + '_' + target.token.id;
                      let duree = ef.duree;
                      save(ef.save, target, rollId, expliquer, saveOpts, evt,
                        function(reussite, rollText) {
                          if (reussite && duree && ef.save.demiDuree) {
                            reussite = false;
                            duree = Math.ceil(duree / 2);
                            if (stateCOF.options.affichage.val.duree_effets.val) expliquer("La dur\xE9e est r\xE9duite \xE0 " + duree + " tours");
                          }
                          if (!reussite) {
                            ef.attaquant = attaquant;
                            setEffetTemporaire(target, ef, duree, evt, options);
                          }
                          saves--;
                          savesEffets--;
                          etatsAvecSave();
                        });
                    }
                  }
                });
              } else etatsAvecSave();
            };
            let effetPietinement = function() {
              if ((target.pietine || target.percute) && estAussiGrandQue(attaquant, target)) {
                let rollId = 'pietinement' + target.token.id;
                testOppose(rollId, target, 'FOR', options, attaquant, 'FOR',
                  options, target.messages, evt,
                  function(resultat, crit, rt1, rt2) {
                    if (resultat == 2) {
                      target.messages.push(nomPerso(target) + " est pi\xE9tin\xE9 par " + attackerTokName + ", dommages doubl\xE9s");
                      setState(target, 'renverse', true, evt);
                      target.dmgCoef = (target.dmgCoef || 0) + 1;
                      target.touche++;
                      if (target.percute) {
                        target.messages.push(nomPerso(target) + " est projet\xE9 \xE0 " +
                          rollDePlus(6, {
                            bonus: 1
                          }).roll + " m\xE8tres");
                        effets = effets || [];
                        effets.push({
                          effet: 'etourdiTemp',
                          duree: 100,
                          message: messageOfEffetTemp('etourdiTemp'),
                          save: {
                            carac: 'CON',
                            seuil: 15
                          },
                          saveParTour: {
                            carac: 'CON',
                            seuil: 15
                          }
                        });
                        savesEffets++;
                      }
                    } else {
                      if (resultat === 0) diminueMalediction(attaquant, evt);
                      target.messages.push(nomPerso(target) + " n'est pas pi\xE9tin\xE9.");
                    }
                    effetsAvecSave();
                  });
              } else effetsAvecSave();
            };
            // Peut faire peur \xE0 la cible
            if (options.peur) {
              peurOneToken(target, options.peur.seuil,
                options.peur.duree, {
                  resisteAvecForce: true
                }, target.messages, evt, effetPietinement);
            } else effetPietinement();
          } else {
            evt.succes = false;
            finCibles();
          }
        });
      });
    }); //Fin de la boucle pour toutes cibles
  }

  function suggererEchecCritique(attaquant, weaponStats, cibles, options, evt) {
    let d12roll = randomInteger(12);
    let estMag = options.sortilege;
    let avecArme = weaponStats.arme;
    let estCac = options.contact;
    let boutonCritique = function(action) {
      let b = boutonSimple(action + " --target " + attaquant.token.id,
        "Appliquer", 'background-color:#cc0000');
      return b;
    };
    let msg;
    switch (d12roll) {
      case 1:
        msg = "\xC9chec total : ";
        if (estMag) {
          msg += "le lanceur de sort perd le contr\xF4le de la magie qu'il canalise et subit 1d4 dommages en retour par rang du sort lanc\xE9. ";
          msg += boutonCritique("!cof-dmg ?{Rang du sort}d4 --ignoreRD");
        } else {
          msg += "l'attaquant se blesse lui-m\xEAme et s'inflige la moiti\xE9 des d\xE9g\xE2ts de son attaque. L'attaquant ne peut plus attaquer ce tour. ";
          msg += boutonCritique("!cof-bouton-echec-total " + evt.id);
        }
        return msg;
      case 2:
        let difficulte = 0;
        if (estCac) {
          let tailleAttaquant = taillePersonnage(attaquant, 4);
          cibles.forEach(function(cible) {
            difficulte = Math.max(difficulte, 12 - ((tailleAttaquant - taillePersonnage(cible, 4)) * 2));
          });
        } else {
          difficulte = 12;
        }
        msg = "Bouscul\xE9 (FOR) : l'attaquant est d\xE9s\xE9quilibr\xE9 par son attaque ";
        msg += boutonCritique("!cof-set-state renverse true --save FOR " + difficulte);
        return msg;
      case 3:
        if (avecArme) {
          msg = "Maladresse (DEX) : l'attaquant laisse \xE9chapper son arme qui tombe hors de port\xE9e imm\xE9diate.";
          msg += boutonCritique("!cof-degainer --save DEX 12");
          return msg;
        }
        msg = "D\xE9s\xE9quilibr\xE9 (DEX) : l'attaquant est Ralenti pendant 3 tours.";
        msg += boutonCritique("!cof-effet-temp ralentiTemp 3 --save DEX 12");
        return msg;
      case 4:
        msg = "Coup de mou (CON) : l'attaquant est affaibli pendant 3 tours, ou jusqu'\xE0 ce qu'il consacre un tour ou 1 PR pour se r\xE9tablir.";
        msg += boutonCritique("!cof-effet-temp affaibliTemp 3 --save CON 12");
        return msg;
      case 5:
        if (estCac) {
          msg = "Erreur tactique (INT) : le personnage provoque une attaque (gratuite) d\x2019un adversaire \xE0 son contact.";
          msg += boutonCritique("!cof-jet INT 12");
        } else if (estMag) {
          msg = "Aveugl\xE9 (INT) : le personnage ne contr\xF4le pas sa puissance et une partie de celle-ci \xE9met un flash qui l'aveugle temporairement.";
          msg += boutonCritique("!cof-effet-temp aveugleTemp 3 --save INT 12 --saveParTour CON 12");
        } else {
          //TODO : Impl\xE9menter un bouton "mauvais calcul" r\xE9alisant une attaque automatique sur un des Obstacle
          msg = "Mauvais calcul (INT) : le personnage a une chance de toucher une autre cible sur la trajectoire de son tir. D\xE9terminer la cible au hasard et relancer une attaque sur cette nouvelle cible.";
          msg += boutonCritique("!cof-jet INT 12");
        }
        return msg;
      case 6:
        if (estCac) {
          msg = "Expos\xE9 (SAG) : l'adversaire dispose d'un bonus de +10 \xE0 la touche pendant un round.";
          cibles.forEach(function(cible) {
            msg += boutonCritique("!cof-effet-temp expose 1 --valeur " + cible.token.id + " --save SAG 12");
          });
        } else {
          msg = "Distrait (SAG) : le personnage est Ralenti pendant 3 tours ";
          msg += boutonCritique("!cof-effet-temp ralentiTemp 3 --save SAG 12");
        }
        return msg;
      case 7:
        msg = "Ridicule (CHA) : le personnage fait un faux mouvement \xE0 la fois douloureux et ridicule, il subit l\x2019\xE9tat \xE9tourdi pendant un round pour reprendre contenance. ";
        msg += boutonCritique("!cof-effet-temp etourdiTemp 1 --save CHA 12");
        return msg;
      case 8:
        msg = "Inconfort : Une pi\xE8ce d\x2019armure bouge et elle devient plus g\xEAnante que protectrice. Malus en DEF et en attaque pour le reste du combat => Cuir : -1, Maille : -2, Plaque -3. ";
        msg += boutonCritique("!cof-effet-combat inconfort --valeur ?{Malus ?|-1,1|-2,2|-3,3} --save CHA 12");
        return msg;
      default:
        return "L'attaquant s'en tire bien cette fois-ci, pas d'effet particulier";
    }
  }

  function montrerResultatsAttaque(msg) {
    if (stateCOF.currentAttackDisplay) {
      sendChat('', endFramedDisplay(stateCOF.currentAttackDisplay));
      stateCOF.currentAttackDisplay = undefined;
      if (stateCOF.afterDisplay) {
        stateCOF.afterDisplay.forEach(function(d) {
          sendPerso(d.destinataire, d.msg, true);
        });
        stateCOF.afterDisplay = undefined;
      }
    } else {
      sendPlayer(msg, "Pas de r\xE9sultat d'attaque \xE0 montrer");
    }
  }

  function sendDisplay(display, perso, autres, options) {
    if (stateCOF.options.affichage.val.MJ_valide_affichage_attaques.val) {
      let players = findObjs({
        _type: 'player'
      });
      let joueur;
      let gm;
      players.forEach(function(p) {
        if (!p.get('online')) return;
        if (playerIsGM(p.id)) gm = true;
        else joueur = true;
      });
      if (gm && joueur) {
        stateCOF.currentAttackDisplay = {...display
        };
        addLineToFramedDisplay(display, boutonSimple('!cof-montrer-resultats-attaque', "Montrer aux joueurs"));
        addFramedHeader(display, undefined, 'gm');
        sendChat('', endFramedDisplay(display));
        return;
      }
    }
    if (options === undefined || !options.secret) {
      sendChat('', endFramedDisplay(display));
    } else {
      let playerIds = getPlayerIds(perso);
      playerIds.forEach(function(playerid) {
        addFramedHeader(display, playerid, true);
        sendChat('', endFramedDisplay(display));
      });
      addFramedHeader(display, undefined, 'gm');
      sendChat('', endFramedDisplay(display));
      autres.forEach(function(target) {
        let addPlayers = getPlayerIds(target);
        addPlayers.forEach(function(nid) {
          if (!playerIds.includes(nid)) {
            playerIds.push(nid);
            addFramedHeader(display, nid, true);
            sendChat('', endFramedDisplay(display));
          }
        });
      });
    }
    if (stateCOF.afterDisplay) {
      stateCOF.afterDisplay.forEach(function(d) {
        sendPerso(d.destinataire, d.msg, true);
      });
      stateCOF.afterDisplay = undefined;
    }
  }

  //Affichage final d'une attaque
  // attaquant est optionnel, mais si il est pr\xE9sent, cibles doit \xEAtre un tableau et options un objet
  function finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique) {
    echecCritique = echecCritique || false;
    explications.forEach(function(expl) {
      addLineToFramedDisplay(display, expl, 80);
    });
    if (evt.action) {
      let perso = evt.action.attaquant;
      evt.personnage = perso;
      if (options.preDmg) {
        let cerclesDeProtection = [];
        cibles.forEach(function(target) {
          let preDmgToken = options.preDmg[target.token.id];
          let action;
          if (preDmgToken !== undefined) {
            let nbBoutons = 0;
            let line = nomPerso(target) + " peut :";
            if (preDmgToken.encaisserUnCoup) {
              line += "<br/>" +
                boutonSimple(
                  "!cof-encaisser-un-coup " + evt.id + ' --target ' + target.token.id,
                  "encaisser le coup");
              nbBoutons++;
            }
            if (preDmgToken.devierLesCoups) {
              line += "<br/>" +
                boutonSimple(
                  "!cof-devier-les-coups " + evt.id + ' --target ' + target.token.id,
                  "d\xE9vier les coups");
              nbBoutons++;
            }
            if (preDmgToken.paradeDeProjectiles) {
              line += "<br/>" +
                boutonSimple(
                  "!cof-parade-projectiles " + evt.id + ' --target ' + target.token.id,
                  "parer le projectile");
              nbBoutons++;
            }
            if (preDmgToken.paradeAuBouclier && preDmgToken.paradeAuBouclier !== 'reroll') {
              action = "!cof-parade-au-bouclier " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "tenter une parade au bouclier");
              nbBoutons++;
            }
            if (preDmgToken.esquiveAcrobatique && preDmgToken.esquiveAcrobatique !== 'reroll') {
              action = "!cof-esquive-acrobatique " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "tenter une esquive acrobatique");
              nbBoutons++;
            }
            if (preDmgToken.esquiveDeLaMagie && preDmgToken.esquiveDeLaMagie !== 'reroll') {
              action = "!cof-esquive-de-la-magie " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "Esquiver la magie");
              nbBoutons++;
            }
            if (preDmgToken.expertDuCombatDEF) {
              action = "!cof-expert-combat-def " + evt.id + " " + target.token.id;
              line += "<br/>" + boutonSimple(action, "utiliser expert du combat");
              nbBoutons++;
            }
            if (preDmgToken.esquiveFatale) {
              preDmgToken.esquiveFatale.forEach(function(tok) {
                line += "<br/>" +
                  boutonSimple(
                    "!cof-esquive-fatale " + evt.id + ' ' + tok.id,
                    "effectuer une esquive fatale vers " + tok.get('name'));
                nbBoutons++;
              });
            }
            if (preDmgToken.resistanceALaMagieBarbare && preDmgToken.resistanceALaMagieBarbare !== 'reroll') {
              action = "!cof-resister-a-la-magie " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "tenter de r\xE9sister \xE0 la magie");
              nbBoutons++;
            }
            if (preDmgToken.cercleDeProtection && preDmgToken.cercleDeProtectionDe &&
              preDmgToken.cercleDeProtection !== 'reroll') {
              cerclesDeProtection.push({
                nom: preDmgToken.cercleDeProtectionDe,
                target: target
              });
            }
            if (preDmgToken.runeForgesort_protection) {
              line += "<br/>" +
                boutonSimple(
                  "!cof-rune-protection " + evt.id + ' --target ' + target.token.id,
                  "utiliser sa Rune de Protection");
              nbBoutons++;
            }
            if (preDmgToken.chairACanon) {
              preDmgToken.chairACanon.forEach(function(tok) {
                line += "<br/>" + boutonSimple("!cof-chair-a-canon " + target.token.id + ' ' + tok.id + ' ' + evt.id, "utiliser " + tok.get('name') + " comme chair \xE0 canon");
                nbBoutons++;
              });
            }
            if (preDmgToken.alliesAvecInterception) {
              //On affiche les messages de la cible, car on pourrait ne pas les afficher du tout si on change de sible
              target.messages.forEach(function(expl) {
                addLineToFramedDisplay(display, expl, 80);
              });
              target.messages = [];
              preDmgToken.alliesAvecInterception.forEach(function(perso) {
                let line = "<br/>" + nomPerso(perso) + " peut" +
                  boutonSimple("!cof-intercepter " + evt.id + ' ' + target.token.id + " --target " + perso.token.id, 'intercepter') + "l'attaque sur " + nomPerso(target);
                addLineToFramedDisplay(display, line);
              });
            }
            if (preDmgToken.paradeMagistrale && preDmgToken.paradeMagistrale !== 'reroll') {
              action = "!cof-esquive-magistrale ";
              let actionParade = "esquive acrobatique";
              if (options.contact) {
                if (target.armesEnMain === undefined) armesEnMain(target);
                if (target.arme && !target.arme.portee) {
                  action = "!cof-parade-magistrale ";
                  actionParade = "parade magistrale";
                }
              }
              action += target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "tenter une " + actionParade);
              nbBoutons++;
            }
            if (preDmgToken.absorberUnSort && preDmgToken.absorberUnSort !== 'reroll') {
              action = "!cof-absorber-sort-au-bouclier " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "absorber le sort");
              nbBoutons++;
            }
            if (preDmgToken.absorberUnCoup && preDmgToken.absorberUnCoup !== 'reroll') {
              action = "!cof-absorber-coup-au-bouclier " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "absorber le coup");
              nbBoutons++;
            }
            if (nbBoutons > 0) addLineToFramedDisplay(display, line);
          }
        });
        if (cerclesDeProtection.length > 0) {
          cerclesDeProtection.forEach(function(cercle) {
            addLineToFramedDisplay(display,
              cercle.nom + " peut " + boutonSimple("!cof-cercle-protection " + cercle.target.token.id + ' ' + evt.id,
                "activer le Cercle de Protection"));
          });
        }
        if (options.preDmg.runeDePuissance) {
          let al = options.preDmg.runeDePuissance;
          let permanent = options.runeDePuissance ? ' permanent' : '';
          addLineToFramedDisplay(display,
            boutonSimple("!cof-bouton-rune-puissance " + al + ' ' + evt.id + permanent,
              "Rune de puissance"));
        }
        addLineToFramedDisplay(display, boutonSimple("!cof-confirmer-attaque " + evt.id, "Continuer"));
      } else {
        if (evt.succes === false) {
          let pc = pointsDeChance(perso);
          if (pc > 0 && !echecCritique) {
            addLineToFramedDisplay(display, boutonSimple("!cof-bouton-chance " + evt.id, "Chance") + " (reste " + pc + " PC)");
          }
          if (attributeAsBool(perso, 'runeForgesort_\xE9nergie') &&
            attributeAsInt(perso, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0) {
            addLineToFramedDisplay(display, boutonSimple("!cof-bouton-rune-energie " + evt.id, "Rune d'\xE9nergie"));
          }
          if (capaciteDisponible(perso, 'petitVeinard', 'combat')) {
            addLineToFramedDisplay(display, boutonSimple("!cof-bouton-petit-veinard " + evt.id, "Petit veinard"));
          }
          let pacteSanglant = predicateAsInt(perso, 'pacteSanglant', 0);
          if (pacteSanglant >= 3) {
            addLineToFramedDisplay(display, boutonSimple("!cof-pacte-sanglant " + evt.id + " 3", "Pacte sanglant (+3)"));
            if (pacteSanglant >= 5) {
              addLineToFramedDisplay(display, boutonSimple("!cof-pacte-sanglant " + evt.id + " 5", "Pacte sanglant (+5)"));
            }
          }
          if (predicateAsInt(perso, 'expertDuCombat', 0) > 0 &&
            attributeAsInt(perso, 'limiteParCombat_expertDuCombat', 1) > 0 &&
            attributeAsInt(perso, 'limiteParTour_expertDuCombat', 1) > 0 &&
            !options.expertDuCombatTouche) {
            addLineToFramedDisplay(display, boutonSimple("!cof-expert-combat-touche " + evt.id, "Expert du Combat (Att. +1D6)"));
          }
        } else {
          if (predicateAsInt(perso, 'expertDuCombat', 0) > 2 &&
            attributeAsInt(perso, 'limiteParCombat_expertDuCombat', 1) > 0 &&
            attributeAsInt(perso, 'limiteParTour_expertDuCombat', 1) > 0 &&
            !options.expertDuCombatDM) {
            addLineToFramedDisplay(display, boutonSimple("!cof-expert-combat-dm " + evt.id, "Expert du Combat (DM +1D6)"));
          }
          if (capaciteDisponible(perso, 'kiai', 'combat') &&
            !attributeAsBool(perso, 'rechargeDuKiai')) {
            addLineToFramedDisplay(display,
              boutonSimple("!cof-bouton-pousser-kiai " + evt.id, "Kiai"));
          }
          if (capaciteDisponible(perso, 'petitVeinard', 'combat')) {
            addLineToFramedDisplay(display, boutonSimple("!cof-bouton-petit-veinard " + evt.id, "Petit veinard") + " pour relancer un d\xE9");
          }
        }
        if (options && options.contact && cibles && attaquant &&
          predicateAsBool(attaquant, 'enchainement')) {
          let cibleMorte = cibles.find(function(target) {
            return target.token.get('bar1_value') == 0;
          });
          if (cibleMorte) {
            if (attaquant.ennemisAuContact === undefined) {
              let tokensContact = findObjs({
                _type: 'graphic',
                _subtype: "token",
                _pageid: evt.action.pageId,
                layer: 'objects'
              });
              tokensContact = tokensContact.filter(function(tok) {
                if (tok.id == attaquant.token.id) return false;
                return distanceCombat(attaquant.token, tok, evt.action.pageId) === 0;
              });
              let tokensEnnemis = [];
              let allies = alliesParPerso[attaquant.charId] || new Set();
              tokensContact.forEach(function(tok) {
                let ci = tok.get('represents');
                if (ci === '') return; //next token au contact
                if (!isActive({
                    token: tok,
                    charId: ci
                  })) return;
                if (!allies.has(ci)) tokensEnnemis.push(tok);
              });
              attaquant.ennemisAuContact = tokensEnnemis;
            }
            if (attaquant.ennemisAuContact.length > 0) {
              let msgEnchainement = nomPerso(attaquant) + " a droit \xE0 une attaque au contact gratuite contre ";
              let sep = "";
              let armeEnMain = tokenAttribute(attaquant, 'armeEnMain');
              let act;
              if (armeEnMain.length === 0) {
                armeEnMain = false;
              } else {
                armeEnMain = armeEnMain[0].get('current');
                act = '!cof-attack ' + attaquant.token.id + ' ';
              }
              msgEnchainement += sep;
              attaquant.ennemisAuContact.forEach(function(tok) {
                if (armeEnMain) {
                  msgEnchainement += boutonSimple(act + tok.id + ' ' + armeEnMain, tok.get('name'));
                } else {
                  msgEnchainement += tok.get('name');
                }
                sep = ", ou ";
              });
              addLineToFramedDisplay(display, msgEnchainement);
            }
          }
        }
        if (evt.action.options && !evt.action.options.auto && evt.action.cibles) {
          evt.action.cibles.forEach(function(target) {
            if (!options.pasDeDmg && target.touche &&
              predicateAsBool(target, 'ignorerLaDouleur') &&
              attributeAsInt(target, 'douleurIgnoree', 0) === 0) {
              addLineToFramedDisplay(display, nomPerso(target) + " peut " +
                boutonSimple("!cof-ignorer-la-douleur " + evt.id + ' --target ' + target.token.id, "ignorer la douleur")
              );
            }
            let pacteSanglant = predicateAsInt(target, 'pacteSanglant', 0);
            if (pacteSanglant >= 3) {
              let msg = nomPerso(target) + " fait un Pacte sanglant" + boutonSimple("!cof-pacte-sanglant-def " + evt.id + ' 3 ' + target.token.id, "(+3 DEF)");
              if (pacteSanglant >= 5) {
                msg += boutonSimple("!cof-pacte-sanglant-def " + evt.id + ' 5 ' + target.token.id, "(+5 DEF)");
              }
              addLineToFramedDisplay(display, msg);
            }
          });
        }
      }
    }
    sendDisplay(display, attaquant, cibles, options);
    if (attaquant) {
      cibles.forEach(function(target) {
        if (evt.succes == false && options.contact && capaciteDisponible(target, 'riposteGuerrier', 'tour')) {
          displayAttaqueOpportunite(target.token.id, [attaquant], "de riposte", 'Ripostes', '--decrLimitePredicatParTour riposteGuerrier');
        } else if (attributeAsBool(target, 'seulContreTous')) {
          displayAttaqueOpportunite(target.token.id, [attaquant], "de riposte", 'Ripostes');
        } else if (predicateAsBool(target, 'riposte')) {
          let attrCiblesDeLaCible = tokenAttribute(target, 'dernieresCiblesAttaquees');
          if (attrCiblesDeLaCible.length > 0) {
            let ripostesDuTour =
              attrCiblesDeLaCible[0].get('max').split(' ');
            ripostesDuTour = new Set(ripostesDuTour);
            if (ripostesDuTour.has(attaquant.token.id)) return;
            ripostesDuTour = attrCiblesDeLaCible[0].get('current').split(' ');
            ripostesDuTour = new Set(ripostesDuTour);
            if (ripostesDuTour.has(attaquant.token.id)) return;
          }
          displayAttaqueOpportunite(target.token.id, [attaquant], "de riposte", 'Ripostes', '--riposte');
        }
      });
      if (options.ricochets) {
        if (options.ricochets.restants > 0 &&
          evt.action && cibles.length == 1) {
          let cible = cibles[0];
          if (cible.touche) {
            //On regarde s'il y a encore des cibles possibles
            let tokens = findObjs({
              _type: 'graphic',
              _subtype: 'token',
              _pageid: evt.action.pageId,
              layer: 'objects'
            });
            let allies = alliesParPerso[attaquant.charId] || new Set();
            tokens = tokens.filter(function(tok) {
              if (tok.id == attaquant.token.id) return false;
              if (tok.id == cible.token.id) return false;
              let ci = tok.get('represents');
              if (ci === '') return false;
              if (allies.has(ci)) return false;
              let dejaTouche = options.ricochets.cibles.some(function(c) {
                return c.token.id == tok.id;
              });
              if (dejaTouche) return false;
              if (distanceCombat(cible.token, tok, evt.action.pageId) > options.portee) return false;
              return true;
            });
            let distance = distanceCombat(cible.token, attaquant.token, evt.action.pageId);
            if (tokens.length > 0) {
              if (stateCOF.options.affichage.val.init_dynamique.val) {
                threadSync++;
                activateRoundMarker(threadSync, cible.token);
              }
              let restants = options.ricochets.restants - 1;
              let action = "!cof-attack " + attaquant.token.id + " @{target|token_id} " + evt.action.attackLabel + " --ricochets " + restants;
              options.ricochets.cibles.forEach(function(c) {
                action += ' ' + c.token.id;
              });
              action += ' ' + cible.token.id;
              let msg = "Faire un ";
              if (restants < 1) msg += "dernier ";
              msg += boutonSimple(action, 'ricochet');
              if (distance > options.portee) {
                if (restants < 1) msg += " (trop loin pour un retour en main)";
              } else {
                let retour = "!cof-retour-boomerang " + attaquant.token.id + " " + evt.action.attackLabel;
                msg += " ou " + boutonSimple(retour, "retour en main");
              }
              sendPerso(attaquant, msg, true);
            } else if (distance < options.portee) {
              doRetourBoomerang(attaquant, evt.action.attackLabel, evt);
            } else {
              if (stateCOF.options.affichage.val.init_dynamique.val) {
                threadSync++;
                activateRoundMarker(threadSync, attaquant.token);
              }
              sendPerso(attaquant, "Plus de cible sur laquelle ricocher et trop loin pour un retour en main", true);
            }
          } else { //on a rat\xE9, il faut remettre le rounMarker \xE0 sa place
            if (stateCOF.options.affichage.val.init_dynamique.val) {
              threadSync++;
              activateRoundMarker(threadSync, attaquant.token);
            }
          }
        } else {
          if (stateCOF.options.affichage.val.init_dynamique.val) {
            threadSync++;
            activateRoundMarker(threadSync, attaquant.token);
          }
        }
      }
    }
    if (!evt.action || !options.preDmg) {
      attackCallback(options, evt);
    }
  }

  // RD sp\xE9cifique au type
  function typeRD(rd, dmgType) {
    if (dmgType === undefined || dmgType == 'normal') return 0;
    return (rd[dmgType] || 0);
  }

  function probaSucces(de, seuil, nbreDe) {
    if (nbreDe == 2) {
      let proba1 = probaSucces(de, seuil, 1);
      return 1 - (1 - proba1) * (1 - proba1);
    }
    if (seuil < 2) seuil = 2; // 1 est toujours un \xE9chec
    else if (seuil > 20) seuil = 20;
    return ((de - seuil) + 1) / de;
  }

  function nbreDeTestCarac(carac, perso) {
    let typeJet = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
      name: carac + '_SUP'
    }, {
      caseInsensitive: true
    });
    if (typeJet.length === 0) return 1;
    typeJet = typeJet[0].get('current');
    switch (typeJet) {
      case '@{JETNORMAL}':
      case '@{jetnormal}':
        return 1;
      case '@{JETSUP}':
      case '@{jetsup}':
      case '@{JETSUPHERO}':
      case '@{jetsuphero}':
        return 2;
      default:
        if (typeJet.startsWith('1d')) return 1;
        if (typeJet.startsWith('2d')) return 2;
        error("Jet inconnu", typeJet);
    }
    return 1;
  }

  // Meilleure carac parmis 2 pour un save.
  function meilleureCarac(carac1, carac2, personnage, seuil) {
    let sansEsprit;
    if (carac1 == 'SAG' || carac1 == 'INT' || carac1 == 'CHA') {
      sansEsprit = predicateAsBool(personnage, 'sansEsprit') ||
        predicateAsBool(personnage, 'vegetatif');
      if (sansEsprit) return carac1;
    }
    if (sansEsprit === undefined &&
      (carac2 == 'SAG' || carac2 == 'INT' || carac2 == 'CHA')) {
      sansEsprit = predicateAsBool(personnage, 'sansEsprit') ||
        predicateAsBool(personnage, 'vegetatif');
      if (sansEsprit) return carac2;
    }
    const options = {
      cacheBonusToutesCaracs: {}
    };
    let bonus1 = bonusTestCarac(carac1, personnage, options);
    if (carac1 == 'DEX') {
      bonus1 += predicateAsInt(personnage, 'reflexesFelins', 0);
      bonus1 += predicateAsInt(personnage, 'esquiveVoleur', 0);
    }
    let bonus2 = bonusTestCarac(carac2, personnage, options);
    if (carac2 == 'DEX') {
      bonus2 += predicateAsInt(personnage, 'reflexesFelins', 0);
      bonus2 += predicateAsInt(personnage, 'esquiveVoleur', 0);
    }
    let nbrDe1 = nbreDeTestCarac(carac1, personnage);
    let nbrDe2 = nbreDeTestCarac(carac2, personnage);
    if (estAffaibli(personnage) && predicateAsBool(personnage, 'insensibleAffaibli')) seuil += 2;
    let de1 = deTest(personnage, carac1);
    let proba1 = probaSucces(de1, seuil - bonus1, nbrDe1);
    let de2 = deTest(personnage, carac2);
    let proba2 = probaSucces(de2, seuil - bonus2, nbrDe2);
    if (proba2 > proba1) return carac2;
    return carac1;
  }

  //s repr\xE9sente le save, avec une carac, une carac2 optionnelle et un seuil
  //expliquer est une fonction qui prend en argument un string et le publie
  // options peut contenir les champs :
  //   - msgPour : message d'explication \xE0 afficher avant le jet
  //   - msgReussite : message \xE0 afficher en cas de r\xE9ussite
  //   - msgRate : message \xE0 afficher si l'action rate
  //   - silencieuxSiPasAffecte: ne rien afficher pour les cibles immunis\xE9es
  //   - attaquant : le {charId, token} de l'attaquant contre lequel le save se fait (si il y en a un)
  //   - type : le type de d\xE9g\xE2ts contre lequel on fait le save
  //   - hideSaveTitle : cache le titre du save
  //   - bonus : bonus au jet de save
  // s peut contenir:
  //   - carac : la caract\xE9ristique \xE0 utiliser pour le save
  //   - carac2 : caract\xE9ristique alternative
  //   - seuil : la difficult\xE9 du jet de sauvegarde
  //   - contact : la difficult\xE9 si la cible est au contact de options.attaquant
  //   - fauchage
  //   - entrave (pour les action qui immobilisent, ralentissent ou paralysent)
  //   - necromancie
  //   - sortilege
  function save(s, target, saveId, expliquer, options, evt, afterSave) {
    if (options.type && immuniseAuType(target, options.type, options.attaquant)) {
      if (!target['msgImmunite_' + options.type] && !options.silencieuxSiPasAffecte) {
        expliquer(nomPerso(target) + " ne semble pas affect\xE9 par " + stringOfType(options.type));
        target['msgImmunite_' + options.type] = true;
      }
      afterSave(true, '');
      return;
    }
    if (s.carac == 'SAG' || s.carac == 'INT' || s.carac == 'CHA' ||
      s.carac2 == 'SAG' || s.carac2 == 'INT' || s.carac2 == 'CHA') {
      if (predicateAsBool(target, 'sansEsprit')) {
        if (!options.silencieuxSiPasAffecte)
          expliquer(nomPerso(target) + " est sans esprit.");
        afterSave(true, '');
        return;
      }
      if (predicateAsBool(target, 'vegetatif')) {
        if (!options.silencieuxSiPasAffecte)
          expliquer(nomPerso(target) + " est une cr\xE9ature v\xE9g\xE9tative.");
        afterSave(true, '');
        return;
      }
    }
    if (s.carac == 'CON' || s.carac2 == 'CON') {
      if (estNonVivant(target)) {
        if (!options.silencieuxSiPasAffecte)
          expliquer(nomPerso(target) + " n'est pas vraiment vivant.");
        afterSave(true, '');
        return;
      }
    }
    if (s.fauchage) {
      if (s.fauchage <= taillePersonnage(target, 4)) {
        expliquer(nomPerso(target) + " est trop grand pour \xEAtre fauch\xE9.");
        afterSave(true, '');
        return;
      }
      if (predicateAsBool(target, 'inderacinable')) {
        expliquer(nomPerso(target) + " est ind\xE9racinable.");
        afterSave(true, '');
        return;
      }
    }
    if (s.carac == 'DEX' || s.carac2 == 'DEX') {
      if (getState(target, 'mort') || getState(target, 'assomme') ||
        getState(target, 'paralyse') || getState(target, 'endormi')) {
        if (!options.silencieuxSiPasAffecte)
          expliquer(nomPerso(target) + " n'est pas en \xE9tat d'\xE9viter l'effet.");
        afterSave(false, '');
      }
    }
    let bonus = options.bonus || 0;
    if (options.attaquant &&
      attributeAsBool(target, 'protectionContreLeMal') &&
      estMauvais(options.attaquant)) {
      let bonusProtectionContreLeMal = getValeurOfEffet(target, 'protectionContreLeMal', 2);
      bonus += bonusProtectionContreLeMal;
      expliquer("Protection contre le mal => +" + bonusProtectionContreLeMal + " au jet de sauvegarde");
    }
    if (s.entrave && predicateAsBool(target, 'actionLibre')) {
      bonus += 5;
      expliquer("Action libre => +5 pour r\xE9sister aux entraves");
    }
    if (options.necromancie && attributeAsBool(target, 'sangDeLArbreCoeur')) {
      bonus += 5;
      expliquer("Sang de l'Arbre-Coeur => +5 pour r\xE9sister \xE0 la n\xE9cromancie");
    }
    if (options.type == 'poison') {
      if (predicateAsBool(target, 'liberateurDAnathazerin')) {
        bonus += 2;
        expliquer("Lib\xE9rateur d'Anathazer\xEFn => +2 pour r\xE9sister au poison");
      }
      if (predicateAsBool(target, 'peauDEcorceAvancee') && attributeAsBool(target, 'peauDEcorce')) {
        let bonusPeau = getValeurOfEffet(target, 'peauDEcorce', 2);
        if (bonusPeau == 2 && predicateAsInt(target, 'voieDesForets', 0) > 3)
          bonusPeau = 4;
        bonus += bonusPeau;
        expliquer("Peau d'\xE9corce am\xE9lior\xE9e => +" + bonusPeau + " pour r\xE9sister au poison");
      }
    }
    let bonusAttrs = [];
    let bonusPreds = [];
    let seuil = s.seuil;
    if (s.contact && options.attaquant && distanceCombat(options.attaquant.token, target.token) === 0) {
      seuil = s.contact;
    }
    let carac = s.carac;
    //Cas o\xF9 le save peut se faire au choix parmis 2 caracs
    if (s.carac2) {
      carac = meilleureCarac(carac, s.carac2, target, seuil);
    }
    if (carac == 'DEX') {
      bonusPreds.push('reflexesFelins');
      bonusPreds.push('esquiveVoleur');
    }
    if (options.sortilege) {
      bonusPreds.push('resistanceALaMagie');
      if (carac == 'SAG') bonusAttrs.push('bonusSagesseMagie');
    }
    if (options.type) {
      bonusPreds.push('bonusSaveContre_' + options.type);
    }
    if (options.energiePositive) {
      bonusPreds.push('bonusSaveContre_positif');
    }
    if (!options.hideSaveTitle) {
      let title = " Jet " + deCarac(carac) + " " + seuil;
      if (options.msgPour) title += options.msgPour;
      expliquer(title);
    }
    let optionsTest = {...options
    };
    optionsTest.bonusAttrs = bonusAttrs;
    optionsTest.bonusPreds = bonusPreds;
    optionsTest.bonus = bonus;
    testCaracteristique(target, carac, seuil, saveId, optionsTest, evt,
      function(tr, explications) {
        let smsg = nomPerso(target) + " fait ";
        if (explications.length === 0) {
          smsg += tr.texte;
        } else {
          smsg += '<span title="';
          explications.forEach(function(e, i) {
            if (i > 0) smsg += "&#13;";
            smsg += e;
          });
          smsg += '">' + tr.texte + '</span>';
        }
        if (tr.reussite) {
          smsg += " => r\xE9ussite";
          if (options.msgReussite) smsg += options.msgReussite;
          smsg += tr.modifiers;
        } else {
          smsg += " => \xE9chec";
          if (options.msgRate) smsg += options.msgRate;
          smsg += tr.rerolls + tr.modifiers;
        }
        expliquer(smsg);
        afterSave(tr.reussite, tr.texte);
      });
  }

  function partialSave(ps, target, showTotal, dmgDisplay, total, expliquer, evt, afterSave) {
    let sav = ps.totalSave;
    let totalSave = true;
    if (sav === undefined) {
      sav = ps.partialSave;
      totalSave = false;
    }
    if (sav === undefined) {
      if (target.partialSaveAuto) {
        if (showTotal) dmgDisplay = '(' + dmgDisplay + ')';
        afterSave({
          succes: true,
          dmgDisplay: dmgDisplay + '/2',
          total: Math.ceil(total / 2),
          showTotal: true
        });
        return;
      }
      afterSave();
      return;
    }
    if ((sav.carac == 'CON' || sav.carac2 == 'CON') && estNonVivant(target)) {
      expliquer("Les cr\xE9atures non-vivantes sont immnunis\xE9es aux attaques qui demandent un test de constitution");
      afterSave({
        succes: true,
        dmgDisplay: '0',
        total: 0,
        showTotal: false
      });
      return;
    }
    if (!totalSave && target.partialSaveAuto) {
      if (showTotal) dmgDisplay = '(' + dmgDisplay + ')';
      afterSave({
        succes: true,
        dmgDisplay: dmgDisplay + '/2',
        total: Math.ceil(total / 2),
        showTotal: true
      });
      return;
    }
    let saveOpts = {
      msgPour: " pour r\xE9duire les d\xE9g\xE2ts",
      msgReussite: ", d\xE9g\xE2ts divis\xE9s par 2",
      attaquant: ps.attaquant,
      rolls: ps.rolls,
      chanceRollId: ps.chanceRollId,
      type: ps.type,
      energiePositive: ps.energiePositive
    };
    if (totalSave) {
      saveOpts.msgPour = " pour \xE9viter les d\xE9g\xE2ts";
      saveOpts.msgReussite = ", d\xE9g\xE2ts \xE9vit\xE9s";
    }
    let saveId = 'parseSave_' + target.token.id;
    save(sav, target, saveId, expliquer, saveOpts, evt,
      function(succes, rollText) {
        if (succes) {
          if (totalSave) {
            dmgDisplay = '0';
            total = 0;
          } else {
            if (showTotal) dmgDisplay = "(" + dmgDisplay + ")";
            dmgDisplay = dmgDisplay + " / 2";
            showTotal = true;
            total = Math.ceil(total / 2);
          }
        }
        afterSave({
          succes: succes,
          dmgDisplay: dmgDisplay,
          total: total,
          showTotal: showTotal
        });
      });
  }

  function getRDS(perso) {
    if (perso.rd) return perso.rd;
    let res = {
      rdt: 0,
      sauf: {}
    };
    if (attributeAsBool(perso, 'formeDArbre')) {
      res.sauf.feu_hache = res.sauf.feu_hache || 0;
      res.sauf.feu_hache += 10;
    }
    if (predicateAsBool(perso, 'fievreChene')) res.feu = (res.feu || 0) + 5;
    if (attributeAsBool(perso, 'armureDEau')) {
      res.acide = (res.acide || 0) + 5;
      res.feu = (res.feu || 0) + 5;
    }
    if (attributeAsBool(perso, 'protectionContreLesProjectiles')) {
      let protection =
        getValeurOfEffet(perso, 'protectionContreLesProjectiles', 5, 'protectionContreLesProjectiles');
      res.projectiles = (res.projectiles || 0) + protection;
    }
    if (perso.perteDeSubstance) res.rdt += perso.perteDeSubstance;
    let rd = ficheAttribute(perso, 'RDS', '');
    rd = (rd + '').trim();
    if (rd === '') {
      perso.rd = res;
      return res;
    }
    rd = rd.split(',');
    rd.forEach(function(r) {
      r = r.trim();
      if (r === '') return;
      let rds;
      let index = r.indexOf(':');
      if (index > 0) { //RD \xE0 un type particulier
        let type = r.substring(0, index);
        if (type == 'rdt' || type == 'sauf') return;
        if (type == 'magie') type = 'magique';
        rds = parseInt(r.substring(index + 1));
        if (isNaN(rds) || rds === 0) return;
        res[type] = res[type] || 0;
        res[type] += rds;
        return;
      }
      index = r.indexOf('/');
      if (index > 0) { //RD sauf \xE0 des types
        rds = parseInt(r.substring(0, index));
        if (isNaN(rds) || rds === 0) return;
        let sauf = r.substring(index + 1);
        if (sauf == 'magie') sauf = 'magique';
        res.sauf[sauf] = res.sauf[sauf] || 0;
        res.sauf[sauf] += rds;
        return;
      }
      //finalement, RD totale
      rds = parseInt(r);
      if (isNaN(rds) || rds === 0) return;
      res.rdt += rds;
    });
    perso.rd = res;
    return res;
  }

  function applyRDSauf(rds, dmgType, total, display, options, target, showTotal, remainingRD) {
    options = options || {};
    let typeTrouve = function(t) {
      if (t == dmgType) return true;
      if (options[t]) return true;
      switch (t) {
        case 'tranchant':
        case 'contondant':
        case 'percant':
          return options.sortilege || dmgType != 'normal';
        default:
          return false;
      }
    };
    if (total) {
      for (let saufType in rds) {
        if (saufType == '1') break;
        let rd = rds[saufType];
        if (rd === 0) break;
        let types = saufType.split('_');
        if (types.find(typeTrouve)) break;
        if (target.ignoreMoitieRD) rd = parseInt(rd / 2);
        if (target.ignoreRD && rd > 0) {
          if (target.ignoreRD > rd) {
            target.ignoreRD -= rd;
            break;
          } else {
            rd -= target.ignoreRD;
            target.ignoreRD = 0;
          }
        }
        if (remainingRD) rd += remainingRD;
        if (total < rd) {
          display += " - " + total;
          rds[saufType] -= total;
          total = 0;
          showTotal = true;
        } else {
          display += " - " + rd;
          total -= rd;
          rds[saufType] = 0;
          showTotal = true;
        }
      }
    }
    return {
      total: total,
      display: display,
      showTotal: showTotal
    };
  }

  function stringOfType(t) {
    switch (t) {
      case 'acide':
        return "l'acide";
      case 'electrique':
        return "l'\xE9lectricit\xE9";
      case 'soniqe':
        return "le son";
      case 'maladie':
        return "les maladies";
      case 'argent':
        return "l'argent";
      default:
        return 'le ' + t;
    }
  }

  function stringOfCarac(c) {
    switch (c) {
      case 'FOR':
        return "la force";
      case 'DEX':
        return "la dext\xE9rit\xE9";
      case 'CON':
        return "la constitution";
      case 'INT':
        return "l'intelligence";
      case 'SAG':
        return "la sagesse";
      case 'CHA':
        return "le charisme";
    }
  }

  function mitigate(target, dmgType, divide, zero, multiply, expliquer, options) {
    if (!options.sortilege && attributeAsBool(target, 'flou')) {
      divide();
    }
    if (!options.energiePositive && dmgType != 'energie' && !options.spectral && predicateAsBool(target, 'creatureIntangible')) {
      divide();
    }
    if (options.attaqueMentale && predicateAsBool(target, 'bouclierPsi')) {
      divide();
    }
    if (options.aoe &&
      (predicateAsBool(target, 'protectionDMZone') ||
        predicateAsBool(target, 'protectionDMZone_' + dmgType))) {
      divide();
      expliquer(nomPerso(target) + " est prot\xE9g\xE9 contre les d\xE9g\xE2ts de zone");
    }
    if (predicateOrAttributeAsBool(target, 'resistanceA_' + dmgType) || predicateAsBool(target, 'diviseEffet_' + dmgType)) {
      divide();
    }
    if (predicateOrAttributeAsBool(target, 'vulnerableA_' + dmgType)) {
      multiply();
    }
    if (predicateOrAttributeAsBool(target, 'resistanceA_nonMagique') && !options.magique && !options.sortilege) {
      divide();
    }
    if (estElementaire(dmgType)) {
      if (predicateAsBool(target, 'invulnerable') || predicateAsBool(target, 'diviseEffet_elementaire')) {
        divide();
      }
      switch (dmgType) {
        case 'froid':
          if (attributeAsBool(target, 'masqueMortuaire')) divide();
          if (attributeAsBool(target, 'mutationFourrureViolette')) divide();
          break;
        case 'feu':
          if (attributeAsBool(target, 'presenceGlaciale')) divide();
          if (attributeAsBool(target, 'mutationEcaillesRouges')) divide();
          break;
        case 'acide':
          if (attributeAsBool(target, 'mutationEcaillesRouges')) divide();
          break;
        case 'electrique':
          if (attributeAsBool(target, 'mutationFourrureViolette')) divide();
          break;
      }
    } else if (dmgType == 'poison' || dmgType == 'maladie') {
      if (predicateAsBool(target, 'invulnerable') ||
        predicateAsBool(target, 'creatureArtificielle') ||
        predicateAsBool(target, 'vegetatif') ||
        estNonVivant(target)) {
        zero();
      } else if (attributeAsBool(target, 'mutationSangNoir')) {
        divide();
      }
    } else {
      if (options.tranchant && predicateOrAttributeAsBool(target, 'resistanceA_tranchant')) {
        divide();
      } else if (options.percant && predicateOrAttributeAsBool(target, 'resistanceA_percant')) {
        divide();
      } else if (options.contondant && predicateOrAttributeAsBool(target, 'resistanceA_contondant')) {
        divide();
      }
      if (attributeAsBool(target, 'armureMagique')) {
        divide();
      }
      if (options.vampirise && predicateOrAttributeAsBool(target, 'controleSanguin')) {
        expliquer(nomPerso(target) + " contr\xF4le parfaitement son sang");
        divide();
      }
    }
  }
  //On a d\xE9termin\xE9 les DM du type principal(possiblement apr\xE8s save des dmgExtra, maintenant on applique les r\xE9sistances, puis on ajoute les DM d'autres types
  function dealDamageAfterDmgExtra(target, mainDmgType, dmgTotal, dmgDisplay, showTotal, dmgParType, dmgExtra, crit, options, evt, expliquer, displayRes) {
    if (options.pointsVitaux && dmgTotal > 0) { //d\xE9g\xE2ts retard\xE9s pour une pression mortelle
      let pMortelle = tokenAttribute(target, 'pressionMortelle');
      let dmgPMort = dmgTotal;
      let numberPMort = 1;
      if (pMortelle.length > 0) {
        dmgPMort += pMortelle[0].get('current');
        numberPMort += pMortelle[0].get('max');
      }
      setTokenAttr(target, 'pressionMortelle', dmgPMort, evt, {
        maxVal: numberPMort
      });
      dmgTotal = 0;
    }
    let rd;
    let rdElems = 0;
    if (attributeAsBool(target, 'protectionContreLesElements')) {
      rdElems =
        getValeurOfEffet(target, 'protectionContreLesElements', 1, 'voieDeLaMagieElementaire') * 2;
      if (rdElems == 2) {
        let v = predicateAsInt(target, 'voieDeLaMagieElementaliste');
        if (v > 1) rdElems = 2 * v;
      }
    }
    if (dmgTotal > 0 && immuniseAuType(target, mainDmgType, options.attaquant)) {
      if (expliquer && !target['msgImmunite_' + mainDmgType]) {
        expliquer(nomPerso(target) + " ne semble pas affect\xE9 par " + stringOfType(mainDmgType));
        target['msgImmunite_' + mainDmgType] = true;
      }
      dmgTotal = 0;
      dmgDisplay = '0';
      showTotal = false;
    } else if (!target.ignoreTouteRD) {
      rd = getRDS(target);
      let rdMain = typeRD(rd, mainDmgType);
      if (mainDmgType == 'normal') {
        if (options.tranchant && rd.tranchant) rdMain += rd.tranchant;
        if (options.percant && rd.percant) rdMain += rd.percant;
        if (options.contondant && rd.contondant) rdMain += rd.contondant;
      }
      if (options.asphyxie) rdMain += rd.asphyxie;
      if (rd.drain && (options.vampirise || target.vampirise) && mainDmgType != 'drain') {
        rdMain += rd.drain;
      }
      if (options.hache && rd.hache) {
        rdMain += rd.hache;
      }
      if (target.ignoreMoitieRD) rdMain = parseInt(rdMain / 2);
      if (target.ignoreRD) {
        if (target.ignoreRD > rdMain) {
          target.ignoreRD -= rdMain;
          rdMain = 0;
        } else {
          rdMain -= target.ignoreRD;
          target.ignoreRD = 0;
        }
      }
      if (rdMain > 0 && dmgTotal > 0) {
        dmgTotal -= rdMain;
        if (dmgTotal < 0) {
          rdMain += dmgTotal;
          dmgTotal = 0;
        }
        dmgDisplay += " - " + rdMain;
        showTotal = true;
      }
      if (rd.elementaire) rdElems += rd.elementaire;
      if (target.ignoreMoitieRD) rdElems = parseInt(rdElems / 2);
      if (rdElems > 0 && dmgTotal > 0 && estElementaire(mainDmgType)) {
        if (dmgTotal > rdElems) {
          dmgDisplay += ' - ' + rdElems;
          dmgTotal -= rdElems;
          rdElems = 0;
        } else {
          dmgDisplay += ' - ' + dmgTotal;
          rdElems -= dmgTotal;
          dmgTotal = 0;
        }
      }
      let additionalType = {
        magique: options.magique,
        tranchant: options.tranchant,
        percant: options.percant,
        contondant: options.contondant,
        sortilege: options.sortilege,
        hache: options.hache,
        ferFroid: options.ferFroid,
        adamantium: options.adamantium,
      };
      let remainingRD = 0;
      if (rdMain < 0) remainingRD = rdMain;
      let resSauf = applyRDSauf(rd.sauf, mainDmgType, dmgTotal, dmgDisplay, additionalType, target, showTotal, remainingRD);
      dmgTotal = resSauf.total;
      dmgDisplay = resSauf.display;
      showTotal = resSauf.showTotal;
      // Damage mitigaters for main damage
      mitigate(target, mainDmgType,
        function() {
          dmgTotal = Math.ceil(dmgTotal / 2);
          if (dmgExtra) dmgDisplay = "(" + dmgDisplay + ")";
          dmgDisplay += " / 2";
          showTotal = true;
        },
        function() {
          if (dmgTotal > 0) {
            dmgDisplay += '-' + dmgTotal;
            dmgTotal = 0;
          }
        },
        function() {
          dmgTotal = Math.floor(dmgTotal * 1.5);
          if (dmgExtra) dmgDisplay = "(" + dmgDisplay + ")";
          dmgDisplay += " x 1.5";
          showTotal = true;
        },
        expliquer, options);
    }
    let dmSuivis = {
      drain: 0
    }; //si il faut noter les DMs d'un type particulier
    if (mainDmgType == 'drain') dmSuivis.drain = dmgTotal;
    predicatesNamed(target, 'vitaliteSurnaturelle').forEach(function(a) {
      let indexType = a.indexOf('/');
      if (indexType < 0 || indexType == a.length) return;
      a = a.substring(indexType + 1);
      let typeVitalite = a.split(',');
      typeVitalite.forEach(function(tv) {
        if (tv == mainDmgType) dmSuivis[tv] = dmgTotal;
        else dmSuivis[tv] = 0;
      });
    });
    // Autres sources de d\xE9g\xE2ts
    // On compte d'abord les autres sources, pour la synchronisation
    let count = 0;
    for (let dt in dmgParType) {
      if (immuniseAuType(target, dt, options.attaquant)) {
        if (expliquer && !target['msgImmunite_' + dt]) {
          expliquer(nomPerso(target) + " ne semble pas affect\xE9 par " + stringOfType(dt));
          target['msgImmunite_' + dt] = true;
        }
        delete dmgParType[dt];
      } else
        count += dmgParType[dt].length;
    }
    let critOther = crit && reglesOptionelles.dommages.val.crit_elementaire.val;
    let dealOneType = function(dmgType) {
      if (dmgType == mainDmgType) {
        count -= dmgParType[dmgType].length;
        if (count === 0) dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis);
        return; //type principal d\xE9j\xE0 g\xE9r\xE9
      }
      showTotal = true;
      let dm = 0;
      let typeDisplay = "";
      let typeCount = dmgParType[dmgType].length;
      dmgParType[dmgType].forEach(function(d) {
        if (d.totalSave && d.totalSave.tempete && options.tempeteDeManaIntense) {
          d.totalSave.seuil += d.totalSave.tempete * options.tempeteDeManaIntense;
        }
        if (d.partialSave && d.partialSave.tempete && options.tempeteDeManaIntense) {
          d.partialSave.seuil += d.partialSave.tempete * options.tempeteDeManaIntense;
        }
        partialSave(d, target, false, d.display, d.total, expliquer, evt,
          function(res) {
            let addTypeDisplay = d.display;
            if (res) {
              dm += res.total;
              if (critOther) {
                dm += res.total;
                if (options.memePasMal) options.memePasMal += res.total;
              }
              addTypeDisplay = res.dmgDisplay;
            } else {
              dm += d.total;
              if (critOther) {
                dm += d.total;
                if (options.memePasMal) options.memePasMal += d.total;
              }
            }
            if (critOther) addTypeDisplay = '(' + addTypeDisplay + ') x2';
            if (typeDisplay === '') typeDisplay = addTypeDisplay;
            else typeDisplay += "+" + addTypeDisplay;
            typeCount--;
            if (typeCount === 0) {
              if (!target.ignoreTouteRD) {
                rd = rd || getRDS(target);
                let rdl = typeRD(rd, dmgType);
                if (dmgType == 'normal') {
                  if (options.tranchant && rd.tranchant) rdl += rd.tranchant;
                  if (options.percant && rd.percant) rdl += rd.percant;
                  if (options.contondant && rd.contondant) rdl += rd.contondant;
                }
                if (target.ignoreMoitieRD) rdl = parseInt(rdl / 2);
                if (target.ignoreRD) {
                  if (target.ignoreRD > rdl) {
                    target.ignoreRD -= rdl;
                    rdl = 0;
                  } else {
                    rdl -= target.ignoreRD;
                    target.ignoreRD = 0;
                  }
                }
                if (rdl > 0 && dm > 0) {
                  dm -= rdl;
                  if (dm < 0) {
                    rdl += dm;
                    dm = 0;
                  }
                  typeDisplay += "-" + rdl;
                }
                if (rdElems > 0 && dm > 0 && estElementaire(dmgType)) {
                  if (dm > rdElems) {
                    typeDisplay += ' - ' + rdElems;
                    dm -= rdElems;
                    rdElems = 0;
                  } else {
                    typeDisplay += ' - ' + dm;
                    rdElems -= dm;
                    dm = 0;
                  }
                }
                let additionalType = {
                  sortilege: options.sortilege,
                  magique: options.magique
                };
                let resSauf = applyRDSauf(rd.sauf, dmgType, dm, typeDisplay, additionalType, target);
                dm = resSauf.total;
                typeDisplay = resSauf.display;
                mitigate(target, dmgType,
                  function() {
                    dm = Math.ceil(dm / 2);
                    if (dmgParType[dmgType].length > 1) typeDisplay = "(" + typeDisplay + ")";
                    typeDisplay += " / 2";
                  },
                  function() {
                    if (dm > 0) {
                      typeDisplay += "-" + dm;
                      dm = 0;
                    }
                  },
                  function() {
                    dm = Math.floor(dm * 1.5);
                    if (dmgParType[dmgType].length > 1) typeDisplay = "(" + typeDisplay + ")";
                    typeDisplay += " x 1.5";
                  },
                  expliquer, options);
                dmgTotal = addToDmgTotal(dmgTotal, dm, d, expliquer, evt);
                dmgDisplay += "+" + typeDisplay;
                if (_.has(dmSuivis, dmgType)) {
                  dmSuivis[dmgType] = dm;
                }
              }
            }
            count--;
            if (count === 0) dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis);
          });
      });
    };
    if (count > 0) {
      for (let dmgType in dmgParType) {
        dealOneType(dmgType);
      }
    } else {
      return dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis);
    }
  }

  //Appel\xE9 quand on met \xE0 0 PV
  function mort(personnage, expliquer, evt) {
    if (getState(personnage, 'mort')) return; //d\xE9j\xE0 mort
    if (predicateAsBool(personnage, 'energieDeLaMort')) {
      let duree = rollDePlus(6, {
        bonus: 5
      });
      sendChat('', '/w GM ' + nomPerso(personnage) + ' r\xE9appara\xEEtra dans ' + duree.roll + ' tours.');
      let effet = 'messageRetarde(r\xE9apparition)';
      setAttrDuree(personnage, effet, duree.val - 1, evt);
      setToken(personnage.token, 'layer', 'gmlayer', evt);
      if (personnage.attaquant) {
        let dm = rollDePlus(6);
        let dmg = {
          type: 'magique',
          display: dm.roll,
          total: dm.val
        };
        let pvMax = parseInt(personnage.token.get('bar1_max'));
        pvMax += dm.val;
        updateCurrentBar(personnage, 1, pvMax, evt, pvMax);
        let explications = [];
        dealDamage(personnage.attaquant, dmg, [], evt, false, {}, explications,
          function(dmgDisplay, dmgFinal, dmgDrain) {
            setTokenAttr(personnage, effet + 'Valeur', nomPerso(personnage) + " r\xE9apparait avec " + dmgFinal + " PV en plus.", evt);
            let attName = nomPerso(personnage);
            let msg = "se transforme en brume noire qui traverse " + attName + " de part en part avant de dispara\xEEtre dans une paroi en poussant un hululement inhumain. le froid de la mort inflige " + dmgDisplay + " DM \xE0 " + attName;
            if (expliquer) {
              expliquer(nomPerso(personnage) + ' ' + msg);
            } else {
              sendPerso(personnage, msg);
            }
          });
      }
      return;
    }
    // Suppression Zombies
    let attrsDegradationZombie = tokenAttribute(personnage, 'degradationZombie');
    if (attrsDegradationZombie.length > 0) {
      finDEffet(attrsDegradationZombie[0], 'degradationZombie', attrsDegradationZombie[0].get("name"), personnage.charId, evt);
      return;
    }
    setState(personnage, 'mort', true, evt);
    let targetPos = {
      x: personnage.token.get('left'),
      y: personnage.token.get('top')
    };
    spawnFxBetweenPoints(targetPos, {
      x: 400,
      y: 400
    }, 'splatter-blood');

  }

  function dmgNaturel(options) {
    if (options.nature) return true;
    if (options.artificiel) return false;
    let attaquant = options.attaquant;
    if (attaquant === undefined) return false;
    if (estAnimal(attaquant)) return true;
    if (predicateAsBool(attaquant, 'insecte')) return true;
    let attr = findObjs({
      _type: 'attribute',
      _characterid: attaquant.charId,
    });
    let attrProfile = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'PROFIL';
    });
    if (attrProfile.length > 0) {
      if (attrProfile[0].get('current').trim().toLowerCase() == 'insecte') {
        return true;
      }
    }
    let attrRace = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'RACE';
    });
    if (attrRace.length === 0) return false;
    let charRace = attrRace[0].get('current').trim().toLowerCase();
    switch (charRace) {
      case 'insecte':
      case 'ankheg':
      case 'araign\xE9e':
      case 'araignee':
      case 'gu\xEApe':
      case 'libellule':
      case 'scarab\xE9e':
      case 'scorpion':
      case 'strige':
        return true;
      default:
        return false;
    }
  }

  // retourne les nombre de PR restant, undefined si les PR ne sont pas d\xE9finis
  // current, max, et si d\xE9fini, attribut
  function pointsDeRecuperation(perso) {
    if (!ficheAttributeAsBool(perso, 'option_pr', true)) return;
    let attrPR = charAttribute(perso.charId, 'pr', {
      caseInsensitive: true
    });
    if (attrPR.length === 0) {
      return {
        current: 5,
        max: 5
      };
    }
    attrPR = attrPR[0];
    let prm = attrPR.get('max');
    if (prm === '') prm = 5;
    else {
      prm = parseInt(prm);
      if (isNaN(prm) || prm < 0) prm = 5;
    }
    let prc = attrPR.get('current');
    if (prc === '') prc = 5;
    else {
      prc = parseInt(prc);
      if (isNaN(prc)) prc = prm;
      else if (prc < 0) prc = 0;
      else if (prc > prm) prc = prm;
    }
    return {
      current: prc,
      max: prm,
      attribut: attrPR
    };
  }

  // pr doit \xEAtre d\xE9fini, et pr.current > 0
  function enleverPointDeRecuperation(perso, pr, evt) {
    evt.attributes = evt.attributes || [];
    let attrPR;
    if (pr.attribut) {
      attrPR = pr.attribut;
    } else {
      attrPR = charAttribute(perso.charId, 'pr', {
        caseInsensitive: true
      });
      if (attrPR.length === 0) {
        attrPR = createObj("attribute", {
          characterid: perso.charId,
          name: 'pr',
          current: 4,
          max: 5
        });
        evt.attributes.push({
          attribute: attrPR,
        });
        return;
      }
      attrPR = attrPR[0];
    }
    evt.attributes.push({
      attribute: attrPR,
      current: pr.current
    });
    pr.current--;
    attrPR.set('current', pr.current);
  }

  function defaultIntVal(opt, def) {
    if (opt.val === true) return def;
    return opt.val;
  }

  function testBlessureGrave(target, dmgTotal, pvMax, expliquer, evt) {
    let reglesDM = reglesOptionelles.dommages.val;
    if (estPJ(target) && ((dmgTotal == 'mort' && reglesDM.blessures_graves.val) ||
        (reglesDM.degats_importants.val &&
          dmgTotal > pvMax / (defaultIntVal(reglesDM.degats_importants, 3)) &&
          dmgTotal >
          (ficheAttributeAsInt(target, 'niveau', 1) +
            ficheAttributeAsInt(target, 'constitution', 10))))) {
      let pr = pointsDeRecuperation(target);
      if (!pr) return;
      if (pr.current > 0) {
        expliquer("Les d\xE9g\xE2ts sont si importants que " + nomPerso(target) + " perd 1 PR");
        enleverPointDeRecuperation(target, pr, evt);
      } else if (getState(target, 'blesse')) {
        if (getState(target, 'mort')) {
          expliquer("Avec la blessure grave, c'est vraiment la fin, " + nomPerso(target) + " ne se rel\xE8vera plus...");
        } else {
          expliquer("Les d\xE9g\xE2ts sont trop importants, et " + nomPerso(target) + " s'effondre");
          mort(target, expliquer, evt);
        }
      } else {
        setState(target, 'blesse', true, evt);
        expliquer("Les d\xE9g\xE2ts occasionnent une blessure grave !");
      }
    }
  }

  function enlevePVStatueDeBois(perso, pvPerdus, evt) {
    if (pvPerdus <= 0) return;
    let attrs = tokenAttribute(perso, 'statueDeBoisValeur');
    if (attrs.length === 0) return;
    let cur = parseInt(attrs[0].get('current'));
    let attrsB = tokenAttribute(perso, 'statueDeBois');
    if (attrsB.length === 0) {
      error("Attribut pour l'effet status de bois introuvable", cur);
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attrs[0]);
      attrs[0].remove();
    }
    if (isNaN(cur)) {
      finDEffet(attrsB[0], 'statueDeBois', attrsB[0].get('name'), perso.charId, evt);
      return;
    }
    let newCur = cur - pvPerdus;
    if (newCur <= 0) {
      finDEffet(attrsB[0], 'statueDeBois', attrsB[0].get('name'), perso.charId, evt);
      return;
    }
    evt.attributes = evt.attributes || [];
    evt.attributes.push({
      attribute: attrs[0],
      current: cur,
      max: attrs[0].get('max')
    });
    attrs[0].set('current', newCur);
  }

  function finDEffetDeNom(perso, effet, evt, options) { //Supprime l'effet si pr\xE9sent
    let attrs = tokenAttribute(perso, effet);
    if (attrs.length === 0) return;
    attrs = attrs[0];
    options = options || {};
    options.pageId = options.pageId || perso.token.get('pageid');
    finDEffet(attrs, effetTempOfAttribute(attrs), attrs.get('name'), perso.charId, evt, options);
  }

  function interfaceMettreAZeroPV(msg) {
    let args = msg.content.split(' ');
    if (args.length !== 3) {
      error("Il faut 3 arguments pour !cof-mettre-a-zero-pv", args);
      return;
    }
    let target = persoOfId(args[1]);
    if (target === undefined) {
      error("Impossible de trouver le token du personnage qui doit mourrir", args);
      return;
    }
    let evt = findEvent(args[2]);
    if (evt === undefined) {
      error("Impossible de trouver l'\xE9v\xE9nement qui a caus\xE9 la mort", args);
      evt = {
        type: "Mettre \xE0 0 PV"
      };
      addEvent(evt);
    }
    let expliquer = function(m) {
      sendPerso(target, m);
    };
    let pvMax = parseInt(target.token.get('bar1_max'));
    mettreAZeroPV(target, pvMax, evt, expliquer, true);
  }

  function mettreAZeroPV(target, pvMax, evt, expliquer, really) {
    if (!really && predicateAsBool(target, 'mortDemandeConfirmation')) {
      let command = "!cof-mettre-a-zero-pv " + target.token.id + ' ' + evt.id;
      let msg = "/w GM " + nomPerso(target) + " a pris un coup mortel." + boutonSimple(command, "Confirmer");
      setTimeout(_.bind(sendChat, undefined, '', msg), 2000);
      return;
    }
    updateCurrentBar(target, 1, 0, evt);
    if (predicateAsBool(target, 'baroudHonneur')) {
      let msgBarroud = nomPerso(target) + " devrait \xEAtre mort";
      msgBarroud += eForFemale(target) + ", mais ";
      msgBarroud += onGenre(target, 'il', 'elle') + " continue \xE0 se battre !";
      expliquer(msgBarroud);
      setTokenAttr(target, 'baroudHonneurActif', true, evt);
    } else if (predicateAsBool(target, 'increvable') && attributeAsInt(target, 'limiteParCombat__increvable', predicateAsInt(target, 'increvable', 1)) > 0) {
      let msgIncrevable = nomPerso(target) + " devrait \xEAtre mort";
      msgIncrevable += eForFemale(target) + ", mais ";
      msgIncrevable += onGenre(target, 'il', 'elle') + " est increvable !";
      expliquer(msgIncrevable);
      let restants = attributeAsInt(target, 'limiteParCombat__increvable', predicateAsInt(target, 'increvable', 1));
      setTokenAttr(target, 'limiteParCombat__increvable', restants - 1, evt);
      setTokenAttr(target, 'increvableActif', true, evt);
    } else if ((attributeAsBool(target, 'enrage') || predicateAsBool(target, 'durACuire')) &&
      !attributeAsBool(target, 'aAgiAZeroPV')) {
      let msgAgitZ = nomPerso(target) + " devrait \xEAtre mort";
      msgAgitZ += eForFemale(target) + ", mais ";
      msgAgitZ += onGenre(target, 'il', 'elle') + " continue \xE0 se battre !";
      expliquer(msgAgitZ);
      if (!attributeAsBool(target, 'agitAZeroPV'))
        setAttrDuree(target, 'agitAZeroPV', 1, evt);
    } else if (predicateAsBool(target, 'nAbandonneJamais')) {
      if (attributeAsBool(target, 'mortMaisNAbandonnePas')) {
        expliquer(nomPerso(target) + " est dans un \xE9tat lamentable, mais continue \xE0 bouger. Il faudrait une action limit\xE9e pour le r\xE9duire en miettes.");
      } else {
        expliquer(nomPerso(target) + " est pratiquement d\xE9truit, mais continue \xE0 bouger !");
        setTokenAttr(target, 'mortMaisNAbandonnePas', true, evt);
        setState(target, 'ralenti', true, evt);
      }
    } else if (predicateAsBool(target, 'exsangue') && !attributeAsBool(target, 'etatExsangue')) {
      let msg;
      if (expliquer) {
        expliquer(nomPerso(target) + " continue \xE0 agir malgr\xE9 son \xE9tat");
      } else msg = "continue \xE0 agir malgr\xE9 son \xE9tat";
      setTokenAttr(target, 'etatExsangue', true, evt, {
        msg
      });
    } else {
      mort(target, expliquer, evt);
      testBlessureGrave(target, 'mort', pvMax, expliquer, evt);
    }
  }

  //target prend un coup qui lui fait perdre tous ses PVs
  // Asynchrone
  function prendreUnCoupMortel(target, dmgTotal, pvPerdus, bar1, pvMax, tempDmg, dmgDisplay, showTotal, dmDrains, displayRes, options, evt, expliquer) {
    pvPerdus += bar1;
    testBlessureGrave(target, dmgTotal, pvMax, expliquer, evt);
    if (predicateAsBool(target, 'defierLaMort')) {
      let defierLaMort = charAttributeAsInt(target, 'defierLaMort', 10);
      let rollId = 'defierLaMort_' + target.token.id;
      let saveOpts = {
        msgPour: " pour d\xE9fier la mort",
        msgReussite: ", conserve 1 PV",
        rolls: options.rolls,
        chanceRollId: options.chanceRollId
      };
      if (attributeAsBool(target, 'rageDuBerserk')) saveOpts.bonus = 10;
      save({
          carac: 'CON',
          seuil: defierLaMort
        }, target, rollId, expliquer, saveOpts, evt,
        function(reussite, rollText) {
          if (reussite) {
            bar1 = 1;
            pvPerdus--;
            setTokenAttr(target, 'defierLaMort', defierLaMort + 10, evt);
            updateCurrentBar(target, 1, 1, evt);
            enlevePVStatueDeBois(target, pvPerdus, evt);
          } else {
            mettreAZeroPV(target, pvMax, evt, expliquer);
          }
          postBarUpdateForDealDamage(target, dmgTotal, pvPerdus, bar1, tempDmg, dmgDisplay, showTotal, dmDrains, displayRes, evt, expliquer);
        });
      //On arr\xEAte l\xE0, car tout le reste est fait dans la continuation du save.
      return;
    }
    mettreAZeroPV(target, pvMax, evt, expliquer);
    postBarUpdateForDealDamage(target, dmgTotal, pvPerdus, bar1, tempDmg, dmgDisplay, showTotal, dmDrains, displayRes, evt, expliquer);
  }

  function dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis) {
    const charId = target.charId;
    let token = target.token;
    // Now do some dmg mitigation rolls, if necessary
    if ((options.distance || options.aoe) &&
      attributeAsBool(target, 'aCouvert')) {
      if (showTotal) dmgDisplay = "(" + dmgDisplay + ")";
      dmgDisplay += " / 2";
      dmgTotal = Math.ceil(dmgTotal / 2);
      dmSuivis = _.map(dmSuivis, function(d) {
        return Math.ceil(d / 2);
      });
      showTotal = true;
    }
    if (options.totalSave && options.totalSave.tempete && options.tempeteDeManaIntense) {
      options.totalSave.seuil += options.totalSave.tempete * options.tempeteDeManaIntense;
    }
    if (options.partialSave && options.partialSave.tempete && options.tempeteDeManaIntense) {
      options.partialSave.seuil += options.partialSave.tempete * options.tempeteDeManaIntense;
    }
    partialSave(options, target, showTotal, dmgDisplay, dmgTotal,
      expliquer, evt,
      function(saveResult) {
        if (saveResult) {
          if (saveResult.total < dmgTotal) {
            dmgTotal = saveResult.total;
            dmSuivis = _.map(dmSuivis, function(d) {
              return Math.ceil(d / 2);
            });
          }
          dmgDisplay = saveResult.dmgDisplay;
          showTotal = saveResult.showTotal;
        }
        let rdTarget = getRDS(target);
        let rd = rdTarget.rdt || 0;
        if (rd > 0 && !options.aoe && options.attaquant && predicateAsBool(options.attaquant, 'ventreMou')) {
          let taille = taillePersonnage(target, 4);
          if (taille > 4) {
            if (target.messages) target.messages.push("Ventre mou => L'attaque ignore la RD d\xFBe \xE0 la taille");
            rd -= 3 * (taille - 4);
            if (taille > 6) rd--;
            if (rd < 0) rd = 0;
          }
        }
        if (predicateAsBool(target, 'hausserLeTon')) {
          if (parseInt(target.token.get('bar1_value')) <= target.token.get('bar1_max') / 2) {
            rd += 5;
          }
        }
        if (target.attaquant && predicateAsBool(target, 'combatKinetique') &&
          !getState(target, 'endormi') && !getState(target, 'assomme') &&
          !getState(target, 'mort') && !getState(target, 'surpris') &&
          !getState(target, 'etourdi')) {
          rd += 3;
        }
        if (attributeAsBool(target, 'statueDeBois')) rd += 10;
        if (attributeAsBool(target, 'mutationSilhouetteMassive')) rd += 3;
        if (crit) {
          let rdCrit = predicateAsInt(target, 'RD_critique', 0); //pour la compatibilit\xE9
          if (ficheAttributeAsBool(target, 'casque_on', false))
            rdCrit += ficheAttributeAsInt(target, 'casque_rd', 0);
          rd += rdCrit;
          if (options.memePasMal) options.memePasMal -= rdCrit;
        }
        if (options.distance) {
          if (rdTarget.distance) rd += rdTarget.distance;
          let piqures = predicateAsInt(target, 'piquresDInsectes', 0);
          if (piqures > 0) {
            if (persoEstPNJ(target) || (ficheAttributeAsBool(target, 'defarmureon', false) && ficheAttributeAsInt(target, 'defarmure', 0) > 5)) {
              rd += piqures;
            }
          }
          if (!options.sortilege && rdTarget.projectiles)
            rd += rdTarget.projectiles;
        }
        if (attributeAsBool(target, 'masqueMortuaire')) rd += 2;
        if (attributeAsBool(target, 'masqueMortuaireAmeLiee')) rd += 1;
        if (rdTarget.nature > 0 && dmgNaturel(options)) rd += rdTarget.nature;
        if (dmgTotal > rd && rdTarget.sauf[1]) {
          if (dmgTotal > rd + rdTarget.sauf[1]) rd += rdTarget.sauf[1];
          else rd = dmgTotal - 1;
        }
        if (target.defautCuirasse) rd = 0;
        if (options.intercepter) rd += options.intercepter;
        if (target.intercepter) rd += target.intercepter;
        if (target.extraRD) {
          rd += target.extraRD;
          expliquer(nomPerso(target) + " encaisse le coup avec son armure");
        }
        if (target.extraRDBouclier) {
          rd += target.extraRDBouclier;
          expliquer(nomPerso(target) + " d\xE9vie le coup avec son bouclier");
        }
        if (target.ignoreTouteRD) rd = 0;
        else if (target.ignoreMoitieRD) rd = parseInt(rd / 2);
        if (target.ignoreRD) {
          if (target.ignoreRD > rd) {
            target.ignoreRD -= rd;
            rd = 0;
          } else {
            rd -= target.ignoreRD;
            target.ignoreRD = 0;
          }
        }
        //Option Max Rune de Protection
        if (target.utiliseRuneProtectionMax) {
          target.messages.push(nomPerso(target) + " utilise sa Rune de Protection");
          addToAttributeAsInt(target, 'limiteParCombat_runeForgesort_protection', 1, -1, evt);
          rd += target.utiliseRuneProtectionMax;
          if (dmgTotal <= rd) expliquer("La rune de protection absorbe tous les dommages");
          else expliquer("La rune de protection encaisse " + target.utiliseRuneProtectionMax + " dommages");
        }
        //RD PeauDePierre \xE0 prendre en compte en dernier
        if (!target.defautCuirasse && !target.ignoreTouteRD && rd < dmgTotal && attributeAsBool(target, 'peauDePierreMag')) {
          let peauDePierreMagValeur = tokenAttribute(target, 'peauDePierreMagValeur');
          if (peauDePierreMagValeur.length === 0) {
            error("compteur de Peau de Pierre non trouv\xE9", target);
          } else {
            peauDePierreMagValeur = peauDePierreMagValeur[0];
            let rdPeauDePierreMax = parseInt(peauDePierreMagValeur.get('current'));
            let peauDePierreAbsorbe = parseInt(peauDePierreMagValeur.get('max'));
            if (isNaN(rdPeauDePierreMax) || isNaN(peauDePierreAbsorbe) || rdPeauDePierreMax < 1 || peauDePierreAbsorbe < 1) {
              error("compteur de Peau de Pierre mal form\xE9", peauDePierreMagValeur);
              finDEffetDeNom(target, "peauDePierreMag", evt);
            } else {
              let rdPeauDePierreMag = rdPeauDePierreMax;
              if (target.ignoreMoitieRD) rdPeauDePierreMag = parseInt(rdPeauDePierreMag / 2);
              if (rd + rdPeauDePierreMag > dmgTotal) {
                rdPeauDePierreMag = dmgTotal - rd;
              }
              if (rdPeauDePierreMag >= peauDePierreAbsorbe) {
                rdPeauDePierreMag = peauDePierreAbsorbe;
                finDEffetDeNom(target, "peauDePierreMag", evt);
              } else {
                peauDePierreAbsorbe -= rdPeauDePierreMag;
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: peauDePierreMagValeur,
                  current: rdPeauDePierreMax,
                  max: peauDePierreAbsorbe
                });
                peauDePierreMagValeur.set('max', peauDePierreAbsorbe);
              }
              rd += rdPeauDePierreMag;
            }
          }
        }
        if (rd > 0) {
          if (showTotal) dmgDisplay = "(" + dmgDisplay + ") - " + rd;
          else {
            dmgDisplay += " - " + rd;
            showTotal = true;
          }
        }
        dmgTotal -= rd;
        for (const dmSuiviType in dmSuivis) {
          if (rd === 0) break;
          dmSuivis[dmSuiviType] -= rd;
          if (dmSuivis[dmSuiviType] < 0) {
            rd = -dmSuivis[dmSuiviType];
            dmSuivis[dmSuiviType] = 0;
          } else rd = 0;
        }
        if (options.metal && attributeAsBool(target, 'magnetisme')) {
          if (showTotal) dmgDisplay = "(" + dmgDisplay + ") / 2";
          else dmgDisplay += " / 2";
          showTotal = true;
          dmgTotal = Math.ceil(dmgTotal / 2);
          if (options.memePasMal)
            options.memePasMal = Math.ceil(options.memePasMal / 2);
          dmSuivis = _.map(dmSuivis, function(d) {
            return Math.ceil(d / 2);
          });
        }
        if (predicateAsBool(target, 'commandant')) {
          //On cherche si il y a au moins 4 cr\xE9atures sous ses ordres \xE0 moins de 10 m
          let pageId = target.token.get('pageid');
          let tokens =
            findObjs({
              _type: 'graphic',
              _subtype: 'token',
              layer: 'objects',
              _pageid: pageId
            });
          let nbCreatures = 0;
          tokens.forEach(function(tok) {
            if (tok.id === target.token.id) return;
            let ci = tok.get('represents');
            if (ci === '') return;
            if (distanceCombat(tok, target.token, pageId) > 10) return;
            let attrCom = charAttribute(ci, 'capitaine');
            if (attrCom.length === 0) return;
            let capitaine = persoOfIdName(attrCom[0].get('current'), pageId);
            if (!capitaine || capitaine.token.id != target.token.id) return;
            let perso = {
              token: tok,
              charId: ci
            };
            if (isActive(perso)) nbCreatures++;
          });
          if (nbCreatures > 3) {
            if (showTotal) dmgDisplay = "(" + dmgDisplay + ") / 2";
            else dmgDisplay += " / 2";
            showTotal = true;
            dmgTotal = Math.ceil(dmgTotal / 2);
            if (options.memePasMal)
              options.memePasMal = Math.ceil(options.memePasMal / 2);
            dmSuivis = _.map(dmSuivis, function(d) {
              return Math.ceil(d / 2);
            });
          }
        }
        if (dmgTotal < reglesOptionelles.dommages.val.dm_minimum.val) {
          dmgTotal = reglesOptionelles.dommages.val.dm_minimum.val;
          dmgDisplay += "-> " + reglesOptionelles.dommages.val.dm_minimum.val;
        }
        if (options.divise) {
          dmgTotal = Math.ceil(dmgTotal / options.divise);
          if (options.memePasMal)
            options.memePasMal = Math.ceil(options.memePasMal / options.divise);
          dmSuivis = _.map(dmSuivis, function(d) {
            return Math.ceil(d / options.divise);
          });
          dmgDisplay = "(" + dmgDisplay + ")/" + options.divise;
          showTotal = true;
        }
        if (crit && options.memePasMal && options.memePasMal > 0) {
          dmgTotal -= options.memePasMal;
          if (dmgTotal < 0) {
            options.memePasMal += dmgTotal;
            dmgTotal = 0;
          }
          expliquer("M\xEAme pas mal : ignore " + options.memePasMal + " PVs et peut enrager");
          let mpm = attributeAsInt(target, 'memePasMalIgnore', 0);
          setTokenAttr(target, 'memePasMalIgnore', mpm + options.memePasMal, evt);
          setAttrDuree(target, 'memePasMalBonus', 3, evt);
        }
        // calcul de l'effet sur la cible
        let bar1 = parseInt(token.get('bar1_value'));
        let pvmax = parseInt(token.get('bar1_max'));
        if (isNaN(bar1)) {
          error("Pas de points de vie chez la cible", token);
          bar1 = 0;
          pvmax = 0;
        } else if (isNaN(pvmax)) {
          pvmax = bar1;
          token.set('bar1_max', bar1);
        }
        let hasMana = (ficheAttributeAsInt(target, 'PM', 0) > 0);
        let tempDmg = 0;
        const estMook = token.get("bar1_link") === '';
        if (hasMana) {
          if (estMook) tempDmg = attributeAsInt(target, 'DMTEMP', 0);
          else tempDmg = ficheAttributeAsInt(target, 'DMTEMP', 0);
        } else {
          tempDmg = parseInt(token.get("bar2_value"));
          if (isNaN(tempDmg)) {
            if (target.tempDmg) { //then try to set bar2 correctly
              if (estMook) {
                token.set("bar2_max", pvmax);
              } else {
                let tmpHitAttr =
                  findObjs({
                    _type: "attribute",
                    _characterid: charId,
                    name: 'DMTEMP'
                  }, {
                    caseInsensitive: true
                  });
                let dmTemp;
                if (tmpHitAttr.length === 0) {
                  dmTemp =
                    createObj("attribute", {
                      characterid: charId,
                      name: 'DMTEMP',
                      current: 0,
                      max: pvmax
                    });
                } else {
                  dmTemp = tmpHitAttr[0];
                }
                token.set("bar2_max", pvmax);
                token.set("bar2_link", dmTemp.id);
              }
            }
            tempDmg = 0;
          }
        }
        if (!options.aoe && dmgTotal > 1 && predicateAsBool(target, 'ciblesMultiples')) {
          showTotal = true;
          dmgTotal = 1;
          if (dmSuivis.drain && dmSuivis.drain > 0) dmSuivis.drain = 1;
          expliquer("La nu\xE9e est constitu\xE9e de tr\xE8s nombreuses cibles, l'attaque ne lui fait qu'1 DM");
        }
        if (options.attaquant && options.arme && dmgTotal > 0 &&
          predicateAsBool(options.attaquant, 'blessureSanglante') &&
          !estMortVivant(target)) {
          let ef = {
            effet: 'blessureSanglante',
            duree: true,
            message: messageEffetTemp.blessureSanglante,
            attaquant: options.attaquant,
          };
          setEffetTemporaire(target, ef, predicateAsInt(options.attaquant, 'blessureSanglante', 0, 1), evt, {});
        }
        let pvPerdus = dmgTotal;
        if (target.tempDmg) {
          tempDmg += dmgTotal;
          if (tempDmg > pvmax) {
            pvPerdus -= tempDmg - pvmax;
            tempDmg = pvmax;
          }
          if (hasMana) {
            setTokenAttr(target, 'DMTEMP', tempDmg, evt);
          } else {
            updateCurrentBar(target, 2, tempDmg, evt);
          }
          enlevePVStatueDeBois(target, pvPerdus, evt);
        } else {
          //On enl\xE8ve les points de vie
          let pvTemporaires = attributeAsInt(target, 'PVTemporaires', 0);
          if (bar1 > 0 && bar1 + pvTemporaires <= dmgTotal &&
            predicateAsBool(target, 'instinctDeSurvieHumain')) {
            dmgTotal = Math.floor(dmgTotal / 2);
            dmSuivis = _.map(dmSuivis, function(d) {
              return Math.ceil(d / 2);
            });
            if (dmgTotal < 1) dmgTotal = 1;
            if (showTotal) {
              dmgDisplay = "(" + dmgDisplay + ") / 2";
            } else {
              dmgDisplay += " / 2";
              showTotal = true;
            }
            expliquer("L'instinct de survie aide \xE0 r\xE9duire une attaque fatale");
          }
          pvPerdus = dmgTotal;
          if (pvTemporaires > 0) {
            if (pvTemporaires <= dmgTotal) {
              removeTokenAttr(target, 'PVTemporaires', evt);
              expliquer(nomPerso(target) + " perd tous ses PVs temporaires");
              bar1 = bar1 - dmgTotal + pvTemporaires;
            } else {
              setTokenAttr(target, 'PVTemporaires', pvTemporaires - dmgTotal, evt);
              expliquer(nomPerso(target) + " perd " + dmgTotal + " PVs temporaires");
            }
          } else {
            bar1 = bar1 - dmgTotal;
          }
          if (crit) { //Vuln\xE9rabilit\xE9 aux critiues
            let vulnerableCritique = predicateAsInt(target, 'vulnerableCritique', 0);
            if (vulnerableCritique > 0) {
              if (randomInteger(100) <= vulnerableCritique) {
                expliquer("Le coup critique le fait voler en \xE9clats");
                if (bar1 > 0) {
                  dmgTotal += bar1;
                  pvPerdus += bar1;
                  bar1 = 0;
                }
              } else {
                expliquer("Le coup critique fait vibrer l'adversaire, mais il r\xE9siste.");
              }
            }
          }
          if ((crit || bar1 < pvmax / 2) &&
            predicateAsBool(target, 'peutEnrager') &&
            !attributeAsBool(target, 'enrage')) {
            setTokenAttr(target, 'enrage', true, evt);
            expliquer(nomPerso(target) + " devient enrag\xE9" + eForFemale(target) + ".");
            finDEffetDeNom(target, 'apeureTemp', evt);
            finDEffetDeNom(target, 'peurEtourdi', evt);
            setState(target, 'apeure', false, evt);
          }
          if (bar1 <= 0) {
            let attrFDA = tokenAttribute(target, 'formeDArbre');
            if (attrFDA.length > 0) {
              let effetFDA = finDEffet(attrFDA[0], 'formeDArbre', attrFDA[0].get('name'), charId, evt, {
                pageId: token.get('pageid')
              });
              if (effetFDA && effetFDA.newToken) {
                token = effetFDA.newToken;
                target.token = token;
              }
              let newBar1 = parseInt(token.get('bar1_value'));
              if (isNaN(newBar1) || newBar1 < 0) {
                error("Points de vie de l'ancien token incorrects", newBar1);
              } else {
                bar1 += newBar1;
              }
            }
          }
          //On enregistre les dm suivis
          for (let dmType in dmSuivis) {
            let d = dmSuivis[dmType];
            if (d && dmType != 'drain') {
              let attrDmSuivi = tokenAttribute(target, 'DMSuivis' + dmType);
              if (attrDmSuivi.length > 0) {
                let cd = parseInt(attrDmSuivi[0].get('current'));
                if (cd > 0) d += cd;
                attrDmSuivi[0].set('current', d);
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: attrDmSuivi[0],
                  current: cd
                });
              } else {
                setTokenAttr(target, 'DMSuivis' + dmType, d, evt);
              }
            }
          }
          if (bar1 <= 0) {
            if (predicateAsBool(target, 'sergent') &&
              !attributeAsBool(target, 'attributDeCombat_sergentUtilise')) {
              expliquer(nomPerso(target) + " \xE9vite l'attaque in-extremis");
              setTokenAttr(target, 'attributDeCombat_sergentUtilise', true, evt);
              pvPerdus = 0;
            } else if (target.attackRoll &&
              predicateAsBool(target, 'increvableHumain') &&
              !attributeAsBool(target, 'increvableHumainUtilise')) {
              setTokenAttr(target, 'increvableHumainUtilise', true, evt);
              let weaponStatsIncrevable = {
                attSkillDiv: 0,
                crit: 20,
                parDefaut: true,
              };
              if (options.sortilege) {
                weaponStatsIncrevable.name = "Attaque magique";
                weaponStatsIncrevable.attSkill = '@{ATKMAG}';
              } else if (options.contact) {
                let enMain = armesEnMain(target);
                if (!enMain || enMain.sortilege || enMain.portee > 0) {
                  weaponStatsIncrevable.name = "Attaque au contact";
                  weaponStatsIncrevable.attSkill = '@{ATKCAC}';
                } else {
                  weaponStatsIncrevable = enMain;
                }
              } else { //attaque \xE0 distance
                weaponStatsIncrevable.name = "Attaque \xE0 distance";
                weaponStatsIncrevable.attSkill = '@{ATKTIR}';
              }
              let optionsIncrevable = {...options
              };
              optionsIncrevable.pasDeDmg = true;
              let critIncrevable = critEnAttaque(target, weaponStatsIncrevable, optionsIncrevable);
              let dice = 20;
              let malusAttaque = 0;
              if (estAffaibli(target)) {
                if (predicateAsBool(target, 'insensibleAffaibli')) {
                  malusAttaque = -2;
                  expliquer(nomPerso(target) + " affaibli, mais insensible => -2 en Attaque");
                } else {
                  dice = 12;
                  expliquer(nomPerso(target) + " affaibli => D12 au lieu de D20 en Attaque");
                }
              } else if (getState(target, 'immobilise')) {
                dice = 12;
                expliquer(nomPerso(target) + " immobilis\xE9 => D12 au lieu de D20 en Attaque");
              } else if (attributeAsBool(target, 'mortMaisNAbandonnePas')) {
                dice = 12;
                expliquer(nomPerso(target) + " mort mais n'abandonne pas => D12 au lieu de D20 en Attaque");
              } else {
                let ebriete = attributeAsInt(target, 'niveauEbriete', 0);
                if (ebriete > 0) {
                  if (options.distance || options.sortilege || ebriete > 1) {
                    dice = 12;
                    if (ebriete > 3) ebriete = 3;
                    expliquer(nomPerso(target) + ' ' + niveauxEbriete[ebriete] + " => D12 au lieu de D20 en Attaque");
                  }
                }
              }
              let toEvaluateAttackIncrevable =
                attackExpression(target, 1, dice, critIncrevable, true, weaponStatsIncrevable);
              sendChat('', toEvaluateAttackIncrevable, function(resAttackIncrevable) {
                let rollsAttack = resAttackIncrevable[0];
                let afterEvaluateAttack = rollsAttack.content.split(' ');
                let attRollNumber = rollNumber(afterEvaluateAttack[0]);
                let attSkillNumber = rollNumber(afterEvaluateAttack[1]);
                let d20rollAttaquant = rollsAttack.inlinerolls[attRollNumber].results.total;
                if (stateCOF.foudreDuTemps) foudreDuTemps(target, d20rollAttaquant);
                let attSkill = rollsAttack.inlinerolls[attSkillNumber].results.total;
                let explications = [];
                let attBonus =
                  bonusAttaqueA(target, weaponStatsIncrevable.name, evt, explications, optionsIncrevable);
                attBonus += malusAttaque;
                let pageId = options.pageId || token.get('pageid');
                attBonus +=
                  bonusAttaqueD(target, target.attaquant, 0, pageId, evt, explications, optionsIncrevable);
                let attackRollAttaquant = d20rollAttaquant + attSkill + attBonus;
                let attRollValue = buildinline(rollsAttack.inlinerolls[attRollNumber]);
                attRollValue += (attSkill > 0) ? "+" + attSkill : (attSkill < 0) ? attSkill : "";
                attRollValue += (attBonus > 0) ? "+" + attBonus : (attBonus < 0) ? attBonus : "";
                let msgIncrevable = "Increvable : " + nomPerso(target) + " fait " + attRollValue;
                //TODO: afficher les explications de calcul des bonus d'attaque ?
                if (attackRollAttaquant < target.attackRoll) {
                  expliquer(msgIncrevable + " < " + target.attackRoll + " => \xE9chec ");
                  prendreUnCoupMortel(target, dmgTotal, pvPerdus, bar1, pvmax, tempDmg, dmgDisplay, showTotal, dmSuivis.drain, displayRes, options, evt, expliquer);
                  return;
                }
                //L'attaque est \xE9vit\xE9e
                expliquer(msgIncrevable + " > " + target.attackRoll + " => l'attaque est \xE9vit\xE9e ! ");

                postBarUpdateForDealDamage(target, dmgTotal, 0, bar1, tempDmg, dmgDisplay, showTotal, dmSuivis.drain, displayRes, evt, expliquer);
              });
              return;
            } else { //la cible prend le coup
              prendreUnCoupMortel(target, dmgTotal, pvPerdus, bar1, pvmax, tempDmg, dmgDisplay, showTotal, dmSuivis.drain, displayRes, options, evt, expliquer);
              //La suite est fait en continuation car la fonction est asynchrone
              return;
            }
          } else { // bar1>0
            testBlessureGrave(target, dmgTotal, pvmax, expliquer, evt);
            updateCurrentBar(target, 1, bar1, evt);
            enlevePVStatueDeBois(target, pvPerdus, evt);
          }
        }
        postBarUpdateForDealDamage(target, dmgTotal, pvPerdus, bar1, tempDmg, dmgDisplay, showTotal, dmSuivis.drain, displayRes, evt, expliquer);
      });
    return dmgDisplay;
  }

  function postBarUpdateForDealDamage(target, dmgTotal, pvPerdus, bar1, tempDmg, dmgDisplay, showTotal, dmDrains, displayRes, evt, expliquer) {
    if (bar1 > 0 && tempDmg >= bar1) { //assomm\xE9
      setState(target, 'assomme', true, evt);
    }
    let attrsLienDeSang = tokenAttribute(target, "lienDeSangVers");
    if (attrsLienDeSang.length > 0) {
      let lienDuSangDmg = Math.floor(dmgTotal / 2);
      if (lienDuSangDmg > 0) {
        let r = {
          total: lienDuSangDmg,
          type: 'normal',
          display: lienDuSangDmg
        };
        let personnageLie = persoOfId(attrsLienDeSang[0].get("current"));
        if (personnageLie) {
          expliquer("Le lien de sang inflige " + lienDuSangDmg + " d\xE9g\xE2ts \xE0 " + personnageLie.token.get("name"));
          dealDamage(personnageLie, r, [], evt, false);
        }
      }
    }
    if (showTotal) dmgDisplay += " = " + dmgTotal;
    if (displayRes === undefined) return;
    displayRes(dmgDisplay, pvPerdus, dmDrains);
  }

  function buildinline(inlineroll, dmgType, magique) {
    let InlineColorOverride = "";
    let values = [];
    let critRoll = false;
    let failRoll = false;
    let critCheck = false;
    let failCheck = false;
    let highRoll = false;
    let lowRoll = false;
    let noHighlight = false;

    inlineroll.results.rolls.forEach(function(roll) {
      let result = processRoll(roll, critRoll, failRoll, highRoll, lowRoll, noHighlight);
      if (result.value.toString().indexOf("critsuccess") != -1) critCheck = true;
      if (result.value.toString().indexOf("critfail") != -1) failCheck = true;
      values.push(result.value);
      critRoll = result.critRoll;
      failRoll = result.failRoll;
      highRoll = result.highRoll;
      lowRoll = result.lowRoll;
      noHighlight = result.noHighlight;
    });

    // Overrides the default coloring of the inline rolls...
    let tc = dmgType;
    if (magique && (tc == 'normal' || tc == 'maladie')) tc = 'magique';
    let couleurs = couleurType[tc];
    if (couleurs) {
      InlineColorOverride = ' background-color: ' + couleurs.background + '; color: ' + couleurs.color + ';';
    } else {
      if (critCheck && failCheck) {
        InlineColorOverride = ' background-color: #8FA4D4; color: #061539;';
      } else if (critCheck && !failCheck) {
        InlineColorOverride = ' background-color: #88CC88; color: #004400;';
      } else if (!critCheck && failCheck) {
        InlineColorOverride = ' background-color: #FFAAAA; color: #660000;';
      } else {
        InlineColorOverride = ' background-color: #FFFEA2; color: #000;';
      }
    }
    let expression =
      inlineroll.expression.replace(/=>|>=/, '&amp;ge;').replace(/>/, '&amp;gt;').replace(/<=|=</, '&amp;le;').replace(/</, '&amp;lt;');
    let rollOut =
      '<span style="display: inline-block; border-radius: 5px; padding: 0 4px; ' + InlineColorOverride + '" title="' + expression + ' = ' + values.join("");
    rollOut += '" class="a inlinerollresult showtip tipsy-n';
    rollOut += (critCheck && failCheck) ? ' importantroll' : (critCheck ? ' fullcrit' : (failCheck ? ' fullfail' : ''));
    rollOut += '">' + inlineroll.results.total + '</span>';
    return rollOut;
  }

  function processRoll(roll, critRoll, failRoll, highRoll, lowRoll, noHighlight) {
    switch (roll.type) {
      case 'C':
        return {
          value: " " + roll.text + " "
        };
      case 'L':
        if (roll.text.indexOf("HR") != -1) highRoll = parseInt(roll.text.substring(2));
        else highRoll = false;
        if (roll.text.indexOf("LR") != -1) lowRoll = parseInt(roll.text.substring(2));
        else lowRoll = false;
        if (roll.text.indexOf("NH") != -1) {
          // Blocks highlight on an individual roll...
          noHighlight = true;
        }
        // Remove inline tags to reduce clutter...
        roll.text = roll.text.replace(/HR(\d+)/g, "");
        roll.text = roll.text.replace(/LR(\d+)/g, "");
        roll.text = roll.text.replace(/NH/g, "");
        if (roll.text !== "") roll.text = " [" + roll.text + "] ";
        return {
          value: roll.text,
          highRoll: highRoll,
          lowRoll: lowRoll,
          noHighlight: noHighlight
        };
      case 'M':
        roll.expr = roll.expr.toString().replace(/\+/g, " + ");
        return {
          value: roll.expr
        };
      case 'R':
        let rollValues = [];
        roll.results.forEach(function(result) {
          if (result.tableItem !== undefined) {
            rollValues.push(result.tableItem.name);
          } else {
            // Turn off highlighting if true...
            if (noHighlight) {
              critRoll = false;
              failRoll = false;
            } else {
              if (roll.mods) {
                if (roll.mods.customCrit && roll.mods.customCrit.length > 0) {
                  switch (roll.mods.customCrit[0].comp) {
                    case '=':
                    case '==':
                      critRoll = (result.v == roll.mods.customCrit[0].point);
                      break;
                    case '>=':
                    case '=>':
                    case '>':
                      critRoll = (result.v >= roll.mods.customCrit[0].point);
                      break;
                    default:
                      critRoll =
                        (highRoll !== false && result.v >= highRoll ||
                          result.v === roll.sides);
                  }
                }
                if (!critRoll && roll.mods.customFumble && roll.mods.customFumble.length > 0) {
                  switch (roll.mods.customFumble[0].comp) {
                    case '=':
                    case '==':
                      failRoll = (result.v == roll.mods.customFumble[0].point);
                      break;
                    case '<=':
                    case '=<':
                    case '<':
                      failRoll = (result.v <= roll.mods.customFumble[0].point);
                      break;
                    default:
                      failRoll =
                        (lowRoll !== false && result.v <= lowRoll || result.v === 1);
                  }
                }
              } else {
                critRoll =
                  (highRoll !== false && result.v >= highRoll ||
                    result.v === roll.sides);
                failRoll =
                  (!critRoll &&
                    (lowRoll !== false && result.v <= lowRoll || result.v === 1));
              }
            }
            var rv = "<span class='basicdiceroll" + (critRoll ? ' critsuccess' : (failRoll ? ' critfail' : '')) + "'>" + result.v + "</span>";
            rollValues.push(rv);
          }
        });
        var separator = ' + ';
        if (roll.mods && roll.mods.keep) separator = ' , ';
        return {
          value: "(" + rollValues.join(separator) + ")",
          critRoll: critRoll,
          failRoll: failRoll,
          highRoll: highRoll,
          lowRoll: lowRoll,
          noHighlight: noHighlight
        };
      case 'G':
        var grollVal = [];
        roll.rolls.forEach(function(groll) {
          groll.forEach(function(groll2) {
            var result = processRoll(groll2, highRoll, lowRoll, noHighlight);
            grollVal.push(result.value);
            critRoll = critRoll || result.critRoll;
            failRoll = failRoll || result.failRoll;
            highRoll = highRoll || result.highRoll;
            lowRoll = lowRoll || result.lowRoll;
            noHighlight = noHighlight || result.noHighlight;
          });
        });
        return {
          value: "{" + grollVal.join(" ") + "}",
          critRoll: critRoll,
          failRoll: failRoll,
          highRoll: highRoll,
          lowRoll: lowRoll,
          noHighlight: noHighlight
        };
    }
  }

  function getBrightness(hex) {
    hex = hex.replace('#', '');
    var c_r = hexDec(hex.substr(0, 2));
    var c_g = hexDec(hex.substr(2, 2));
    var c_b = hexDec(hex.substr(4, 2));
    return ((c_r * 299) + (c_g * 587) + (c_b * 114)) / 1000;
  }

  function hexDec(hex_string) {
    hex_string = (hex_string + '').replace(/[^a-f0-9]/gi, '');
    return parseInt(hex_string, 16);
  }

  function addOrigin(name, toEvaluate) {
    return toEvaluate.replace(/@{/g, "@{" + name + "|");
  }

  // Retourne le diam\xE8tre d'un disque inscrit dans un carr\xE9 de surface
  // \xE9quivalente \xE0 celle du token
  function tokenSizeAsCircle(token) {
    var surface = token.get('width') * token.get('height');
    return Math.sqrt(surface);
  }

  function malusDistance(perso1, tok2, distanceDeBase, portee, pageId, explications, ignoreObstacles) {
    // Extension de distance pour tir parabolique
    let tirParabolique = predicateAsBool(perso1, 'tirParabolique');
    let distance = tirParabolique ? Math.max(0, distanceDeBase - portee) : distanceDeBase;

    if (distance === 0) return 0;
    let tok1 = perso1.token;
    let mPortee =
      (distance <= portee) ? 0 : (Math.ceil(5 * (distance - portee) / portee));
    if (mPortee > 0) {
      explications.push("Distance > " + ((tirParabolique) ? portee * 2 : portee) + " m => -" + mPortee + " en Attaque");
    }
    if (ignoreObstacles || predicateAsBool(perso1, 'joliCoup'))
      return mPortee;
    // Now determine if any token is between tok1 and tok2
    var allToks =
      findObjs({
        _type: 'graphic',
        _pageid: pageId,
        _subtype: 'token',
        layer: 'objects'
      });
    let mObstacle = 0;
    let dp = distancePixToken(tok1, tok2);
    let liste_obstacles = [];
    allToks.forEach(function(obj) {
      if (obj.id == tok1.id || obj.id == tok2.id) return;
      let objCharId = obj.get('represents');
      let perso = {
        token: obj,
        charId: objCharId
      };
      if (objCharId !== '' &&
        (getState(perso, 'mort') ||
          getState(perso, 'assomme') || getState(perso, 'endormi') ||
          (attributeAsBool(perso, 'intangible') && attributeAsInt(perso, 'intangibleValeur', 1)) ||
          (attributeAsBool(perso, 'intangibleInvisible') && attributeAsInt(perso, 'intangibleInvisibleValeur', 1))
        )
      )
        return;
      //On regarde si le token est une monture d'un des personnages
      let attrMonte = tokenAttribute(perso, 'estMontePar');
      let estMonture = attrMonte.find(function(a) {
        let sp = splitIdName(a.get('current'));
        if (sp === undefined) return false;
        return sp.id == tok1.id || sp.id == tok2.id;
      });
      if (estMonture) return;
      let obj_dist = distancePixToken(tok1, obj);
      if (obj_dist > dp) return;
      obj_dist = distancePixToken(tok2, obj);
      if (obj_dist > dp) return;
      let pt1 = pointOfToken(tok1);
      let pt2 = pointOfToken(tok2);
      let distToTrajectory = distancePixTokenSegment(obj, pt1, pt2);
      // On mod\xE9lise le token comme un disque
      let rayonObj = tokenSizeAsCircle(obj) / 2;
      if (distToTrajectory > rayonObj) return;
      liste_obstacles.push(obj.get("name"));
      // On calcule un malus proportionnel \xE0 l'arc \xE0 traverser
      // Pour l'instant, malus = 1 si distance = PIX_PER_UNIT
      let longueurArc = 2 * Math.sqrt(rayonObj * rayonObj - distToTrajectory * distToTrajectory);
      let mToken = longueurArc / PIX_PER_UNIT;
      //malus plus important si l'obstacle est au contact de la cible
      if (distanceCombat(tok2, obj, pageId) === 0) mToken *= 5;
      else mToken *= 3;
      mObstacle += mToken;
    });
    // On ajuste aussi en fonction de la taille de la cible
    mObstacle = mObstacle / (tokenSizeAsCircle(tok2) / PIX_PER_UNIT);
    if (mObstacle > 5) mObstacle = 5;
    else mObstacle = Math.round(mObstacle);
    let res = mPortee + mObstacle;
    if (mObstacle > 0) {
      log("Obstacle" + ((liste_obstacles.length > 1) ? "s" : "") + " trouv\xE9 : " + liste_obstacles.join(', '));
      let msgObstacles = 'Obstacle' + ((liste_obstacles.length > 1) ? 's' : '') + ' sur le trajet => -' + mObstacle + ' en Attaque<br />';
      if (liste_obstacles.length > 0)
        msgObstacles += '<span style="font-size: 0.8em; color: #666;">' + liste_obstacles.join(', ') + '</span>';
      explications.push(msgObstacles);
    }
    return res;
  }

  //Met tous les attributs avec le nom au max
  function resetAttr(attrs, attrName, evt, msg) {
    allAttributesNamed(attrs, attrName).forEach(function(att) {
      var vm = parseInt(att.get("max"));
      if (!isNaN(vm)) {
        var vc = parseInt(att.get("current"));
        if (vc != vm) {
          evt.attributes.push({
            attribute: att,
            current: vc
          });
          att.set("current", vm);
          if (msg) {
            const charId = att.get('characterid');
            whisperChar(charId, msg);
          }
        }
      }
    });
  }

  // Fait foo sur tous les tokens repr\xE9sentant charId, ayant l'effet donn\xE9, et correspondant au nom d'attribut. Pour le cas o\xF9 le token doit \xEAtre li\xE9 au personnage, on ne prend qu'un seul token, sauf si les options indiquent autrement (soit option.tousLesTokens, soit une fonction options.filterAffected)
  // Ne fonctionne correctement que pour les attributs sans _
  function iterTokensOfAttribute(charId, pageId, attrName, attrNameComplet, foo, options) {
    options = options || {};
    let total = 1; //Nombre de tokens affect\xE9s, pour g\xE9rer l'asynchronie si besoin
    if (attrNameComplet == attrName) { //token li\xE9 au character
      let tokens;
      if (pageId) {
        tokens =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            _pageid: pageId,
            represents: charId
          });
      }
      if (tokens === undefined ||
        (tokens.length === 0 && !options.onlyOnPage)) {
        tokens =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            represents: charId
          });
        tokens = tokens.filter(function(tok) {
          if (tok.get('bar1_link') === '') return false;
          let pid = tok.get('pageid');
          let page = getObj('page', pid);
          if (page) {
            return !(page.get('archived'));
          }
          return false;
        });
      }
      if (tokens.length === 0) {
        log("Pas de token pour un personnage");
        log(charId);
        log(attrNameComplet);
        return;
      }
      if (options.tousLesTokens) {
        tokens.forEach(function(tok) {
          foo(tok, tokens.length);
        });
      } else if (options.filterAffected) {
        total = tokens.length;
        tokens.forEach(function(tok) {
          if (options.filterAffected(tok)) foo(tok, total);
        });
      } else foo(tokens[0], 1);
    } else { //token non li\xE9 au character
      let tokenName = attrNameComplet.substring(attrNameComplet.indexOf('_') + 1);
      let tNames;
      if (pageId) {
        tNames =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            _pageid: pageId,
            represents: charId,
            name: tokenName,
            bar1_link: ''
          });
      }
      if (tNames === undefined || (tNames.length === 0 && !options.onlyOnPage)) {
        tNames =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            represents: charId,
            name: tokenName,
            bar1_link: ''
          });
        tNames = tNames.filter(function(tok) {
          let pid = tok.get('pageid');
          let page = getObj('page', pid);
          if (page) {
            return !(page.get('archived'));
          }
          return false;
        });
      }
      total = tNames.length;
      if (total > 1) {
        //On regarde combien il y en a dans le layer objects.
        let tObjects = tNames.filter(function(tok) {
          return tok.get('layer') == 'objects';
        });
        let totalObjects = tObjects.length;
        if (totalObjects > 0) {
          tNames = tObjects;
          total = totalObjects;
        }
        if (total > 1) {
          let character = getObj('character', charId);
          let charName = "d'id " + charId;
          if (character) charName = character.get('name');
          error("Attention, il y a plusieurs tokens nomm\xE9s " + tokenName, total);
          log("  tokens instances du personnage " + charName, total);
        }
      }
      tNames.forEach(function(tok) {
        foo(tok, total);
      });
    }
  }

  let aura_token_on_turn = false;

  function setTokenInitAura(perso) {
    let token = perso.token;
    if (stateCOF.options.affichage.val.init_dynamique.val) {
      threadSync++;
      activateRoundMarker(threadSync, token);
      return;
    }
    if (aura_token_on_turn) {
      // ennemi => rouge
      var aura2_color = '#CC0000';
      if (estAllieJoueur(perso)) {
        // equipe => vert
        aura2_color = '#59E594';
      }
      token.set('aura2_radius', '0.1');
      token.set('aura2_color', aura2_color);
      token.set('showplayers_aura2', true);
    } else {
      var status = '';
      // Cas des tokens personnalis\xE9s
      if (statusForInitEnemy && statusForInitAlly) {
        // ennemi => rouge
        status = statusForInitEnemy;
        if (estAllieJoueur(perso)) {
          // equipe => vert
          status = statusForInitAlly;
        }
      } else status = 'status_flying-flag';
      token.set(status, true);
    }
  }

  //Ne rajoute pas evt \xE0 l'historique
  function setActiveToken(combat, tokenId, evt) {
    let pageId;
    if (combat) pageId = combat.pageId;
    let activeTokenId = combat.activeTokenId;
    if (activeTokenId) {
      if (tokenId == activeTokenId) return;
      if (!evt.combat) evt.combat = {...stateCOF.combat
      };
      let prevToken = getObj('graphic', activeTokenId);
      if (prevToken) {
        affectToken(prevToken, 'statusmarkers', prevToken.get('statusmarkers'), evt);
        affectToken(prevToken, 'aura2_radius', prevToken.get('aura2_radius'), evt);
        affectToken(prevToken, 'aura2_color', prevToken.get('aura2_color'), evt);
        affectToken(prevToken, 'showplayers_aura2', prevToken.get('showplayers_aura2'), evt);
        removeTokenFlagAura(prevToken);
        let perso = persoOfToken(prevToken);
        if (perso) removeTokenAttr(perso, 'energieImpie', evt);
      } else {
        if (pageId) {
          prevToken = findObjs({
            _type: 'graphic',
            _subtype: 'token',
            _pageid: pageId,
            name: combat.activeTokenName
          });
        } else {
          prevToken = findObjs({
            _type: 'graphic',
            _subtype: 'token',
            name: combat.activeTokenName
          });
        }
        prevToken.forEach(function(o) {
          affectToken(o, 'statusmarkers', o.get('statusmarkers'), evt);
          affectToken(o, 'aura2_radius', o.get('aura2_radius'), evt);
          affectToken(o, 'aura2_color', o.get('aura2_color'), evt);
          affectToken(o, 'showplayers_aura2', o.get('showplayers_aura2'), evt);
          removeTokenFlagAura(o);
        });
      }
    }
    if (tokenId) {
      let perso = persoOfId(tokenId, tokenId);
      if (perso) {
        //On remet \xE0 0 la liste des cibles attaqu\xE9es par le personnage
        removeDernieresCiblesAttaquees(perso, evt);
        let token = perso.token;
        // personnage li\xE9 au Token
        affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
        affectToken(token, 'aura2_radius', token.get('aura2_radius'), evt);
        affectToken(token, 'aura2_color', token.get('aura2_color'), evt);
        affectToken(token, 'showplayers_aura2', token.get('showplayers_aura2'), evt);
        setTokenInitAura(perso);
        combat.activeTokenId = tokenId;
        combat.activeTokenName = token.get('name');
        turnAction(perso);
        // Gestion de la confusion
        if (attributeAsBool(perso, "confusion")) {
          //Une chance sur deux de ne pas agir
          if (randomInteger(2) < 2) {
            sendPerso(perso, "est en pleine confusion. " +
              onGenre(perso, 'Il', 'Elle') + " ne fait rien ce tour");
            removeTokenFlagAura(token);
          } else {
            //Trouver la cr\xE9ature la plus proche
            let closestToken;
            pageId = token.get('pageid');
            let toksOnPage = findObjs({
              _type: 'graphic',
              _subtype: 'token',
              _pageid: pageId,
              layer: 'objects'
            });
            toksOnPage.forEach(function(tok) {
              if (tok.id == tokenId) return;
              let perso = {
                token: tok
              };
              perso.charId = tok.get('represents');
              if (perso.charId === '') return;
              if (getState(perso, 'mort')) return;
              let dist = distanceCombat(token, tok, pageId);
              if (closestToken) {
                if (dist > closestToken.distance) return;
                if (dist < closestToken.distance) {
                  closestToken = {
                    distance: dist,
                    names: [tok.get('name')]
                  };
                  return;
                }
                closestToken.names.push(tok.get('name'));
                return;
              }
              closestToken = {
                distance: dist,
                names: [tok.get('name')]
              };
            });
            if (closestToken) {
              let r = randomInteger(closestToken.names.length) - 1;
              sendPerso(perso,
                "est en pleine confusion. " + onGenre(perso, 'Il', 'Elle') +
                " attaque " + closestToken.names[r] + ".");
            } else {
              sendPerso(perso, "est seul" + onGenre(perso, '', 'e') + " et en plein confusion");
            }
          }
        }
        //On enl\xE8ve aussi les \xE9tats qui ne durent qu'un tour
        let defenseTotale = tokenAttribute(perso, 'defenseTotale');
        if (defenseTotale.length > 0) {
          defenseTotale = defenseTotale[0];
          let tourDefTotale = defenseTotale.get('max');
          if (tourDefTotale < combat.tour) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(defenseTotale);
            defenseTotale.remove();
          }
        }
      } else {
        error("Impossible de trouver le token dont c'est le tour", tokenId);
        combat.activeTokenId = undefined;
      }
    } else combat.activeTokenId = undefined;
  }

  const armeDeJetRegExpr = new RegExp(/^repeating_(armes|pnjatk)_[^_]*_armejetqte$/);

  function recupererArmesDeJet(attrs, evt) {
    let msgAffiche = new Set();
    attrs.forEach(function(a) {
      const nom = a.get('name');
      if (!armeDeJetRegExpr.test(nom)) return;
      const charId = a.get('characterid');
      let m = parseInt(a.get('max'));
      if (isNaN(m) || m < 0) {
        error("Erreur dans les quantit\xE9s d'arme de jet", a);
        a.remove();
        return;
      }
      let n = parseInt(a.get('current'));
      if (isNaN(n) || n < m) {
        evt.attributes.push({
          attribute: a,
          current: n,
          max: m
        });
        if (!msgAffiche.has(charId)) {
          msgAffiche.add(charId);
          whisperChar(charId, "r\xE9cup\xE8re ses armes de jet");
        }
        a.set('current', m);
      }
    });
  }

  const munitionRegExpr = new RegExp(/^repeating_munitions_[^_]*_qtemunition$/);

  function recupererMunitions(attrs, evt) {
    let msgAffiche = new Set();
    attrs.forEach(function(a) {
      const nom = a.get('name');
      if (!munitionRegExpr.test(nom)) return;
      const charId = a.get('characterid');
      let m = parseInt(a.get('max'));
      if (isNaN(m) || m < 0) {
        error("Erreur dans les quantit\xE9s de munitions", a);
        a.remove();
        return;
      }
      let n = parseInt(a.get('current'));
      if (isNaN(n) || n < m) {
        evt.attributes.push({
          attribute: a,
          current: n,
          max: m
        });
        if (!msgAffiche.has(charId)) {
          msgAffiche.add(charId);
          whisperChar(charId, "r\xE9cup\xE8re ses munitions");
        }
        a.set('current', m);
      }
    });
  }

  function sortirDuCombat() {
    stateCOF.prescience = undefined;
    stateCOF.nextPrescience = undefined;
    let combat = stateCOF.combat;
    if (!combat) {
      log("Pas en combat");
      sendChat("GM", "/w GM Le combat est d\xE9j\xE0 termin\xE9");
      return;
    }
    sendChat("GM", "Le combat est termin\xE9");
    let evt = {
      type: 'fin_combat',
      initiativepage: Campaign().get('initiativepage'),
      turnorder: Campaign().get('turnorder'),
      attributes: [],
      combat,
      deletedAttributes: [],
      chargeFantastique: stateCOF.chargeFantastique,
    };
    stateCOF.combat = false;
    stateCOF.chargeFantastique = undefined;
    setActiveToken(combat, undefined, evt);
    Campaign().set('initiativepage', false);
    let attrs = findObjs({
      _type: 'attribute'
    });
    // Fin des effets qui durent pour le combat
    attrs = removeAllAttributes('attributDeCombat', evt, attrs);
    attrs = removeAllAttributes('protegerUnAllie', evt, attrs);
    attrs = removeAllAttributes('protegePar', evt, attrs);
    attrs = removeAllAttributes('interposer', evt, attrs);
    attrs = removeAllAttributes('defenseTotale', evt, attrs);
    attrs = removeAllAttributes('dureeStrangulation', evt, attrs);
    attrs = removeAllAttributes('defautDansLaCuirasse', evt, attrs);
    attrs = removeAllAttributes('postureDeCombat', evt, attrs);
    attrs = removeAllAttributes('dedouble', evt, attrs);
    attrs = removeAllAttributes('limiteParCombat', evt, attrs);
    attrs = removeAllAttributes('limiteParTour', evt, attrs);
    attrs = removeAllAttributes('armeSecreteBardeUtilisee', evt, attrs);
    attrs = removeAllAttributes('attaqueMalgreMenace', evt, attrs);
    attrs = removeAllAttributes('limiteApplicationManoeuvre', evt, attrs);
    attrs = removeAllAttributes('attaqueParMeute', evt, attrs);
    attrs = removeAllAttributes('dernieresCiblesAttaquees', evt, attrs);
    attrs = removeAllAttributes('testsRatesDuTour', evt, attrs);
    attrs = removeAllAttributes('effetsTemporairesLies', evt, attrs);
    attrs = removeAllAttributes('aAgiAZeroPV', evt, attrs);
    attrs = removeAllAttributes('injonctionMortelle', evt, attrs);
    attrs = removeAllAttributes('cercleDeProtectionActif', evt, attrs);
    attrs = removeAllAttributes('feinte', evt, attrs);
    attrs = removeAllAttributes('lienDeSangVers', evt, attrs);
    attrs = removeAllAttributes('lienDeSangDe', evt, attrs);
    attrs = removeAllAttributes('prescienceUtilisee', evt, attrs);
    attrs = removeAllAttributes('increvableHumainUtilise', evt, attrs);
    attrs = removeAllAttributes('resistanceRaillerie', evt, attrs);
    attrs = removeAllAttributes('defierLaMort', evt, attrs);
    attrs = removeAllAttributes('traquenardImpossible', evt, attrs);
    attrs = removeAllAttributes('niveauDesObjetsAnimes', evt, attrs);
    attrs = removeAllAttributes('meneurDHommesCible', evt, attrs);
    attrs = removeAllAttributes('energieImpie', evt, attrs);
    // Autres attributs
    // On r\xE9cup\xE8re les munitions r\xE9cup\xE9rables
    resetAttr(attrs, 'munition', evt, "r\xE9cup\xE8re ses munitions"); //obsol\xE8te depuis mars 2023.
    recupererMunitions(attrs, evt);
    recupererArmesDeJet(attrs, evt);
    //Utilisation automatique de second souffle, si pas utilis\xE9
    let tokens = findObjs({ // Les tokens sur la page du combat
      _type: 'graphic',
      _subtype: 'token',
      _pageid: combat.pageId,
    });
    let persosDuCombat = []; //peupl\xE9 la premi\xE8re fois qu'on regarde les tokens
    let persoParCharId = {}; //Pour ne garder qu'un jeu de pr\xE9dicat par charId
    tokens.forEach(function(token) {
      let charId = token.get('represents');
      if (charId === '' || charId === undefined) return;
      let perso = {
        token: token,
        charId: charId
      };
      persosDuCombat.push(perso);
      let persoTest = persoParCharId[charId];
      if (persoTest === undefined) {
        persoParCharId[charId] = perso;
        persoTest = perso;
      }
      if (!predicateAsBool(perso, 'secondSouffle')) return;
      if (!isActive(perso)) return;
      if (attributeAsBool(perso, 'secondSouffleUtilise')) return;
      let pvDebut = attributeAsInt(perso, 'PVsDebutCombat', 0);
      if (pvDebut === 0) return; //personnage pas en combat.
      let pv = parseInt(token.get('bar1_value'));
      if (isNaN(pv)) return;
      if (pvDebut <= pv) return;
      let bonus = ficheAttributeAsInt(perso, 'niveau', 1);
      bonus += modCarac(perso, 'constitution');
      let jetSoins = rollDePlus(10, {
        bonus: bonus
      });
      let msg = ' reprend son souffle et r\xE9cup\xE8re ';
      let soins = jetSoins.val;
      if (pv + soins > pvDebut) {
        soins = pvDebut - pv;
        msg += soins + " PV (le jet \xE9tait " + jetSoins.roll + ")";
      } else {
        msg += jetSoins.roll + " PVs";
      }
      sendPerso(perso, msg);
      soigneToken(perso, soins, evt, undefined, undefined, {
        recuperation: true
      });
    });
    attrs = removeAllAttributes('secondSouffleUtilise', evt, attrs);
    attrs = removeAllAttributes('PVsDebutCombat', evt, attrs);
    // On diminue l'\xE9bri\xE9t\xE9 des personnages sous vapeurs \xE9thyliques
    allAttributesNamed(attrs, 'vapeursEthyliques').forEach(function(attr) {
      var veCharId = attr.get('characterid');
      if (veCharId === undefined || veCharId === '') {
        error("Attribut sans personnage associ\xE9", attr);
        return;
      }
      iterTokensOfAttribute(veCharId, combat.pageId,
        'vapeursEthyliques', attr.get('name'),
        function(tok) {
          var perso = {
            charId: veCharId,
            token: tok
          };
          removeTokenAttr(perso, 'niveauEbriete', evt, {
            msg: "d\xE9sao\xFBle"
          });
        });
    });
    attrs = removeAllAttributes('vapeursEthyliques', evt, attrs);
    // Pour frappe du vide, on rengaine l'arme, cela remet aussi l'attribut
    persosDuCombat.forEach(function(perso) {
      let persoTest = persoParCharId[perso.charId];
      if (predicateAsBool(persoTest, 'frappeDuVide')) {
        degainerArme(perso, '', evt);
      }
    });
    // On remet en main l'arme par d\xE9faut si elle est pr\xE9cis\xE9e
    persosDuCombat.forEach(function(perso) {
      if (!isActive(perso)) return;
      let persoTest = persoParCharId[perso.charId];
      let arme = predicateAsBool(persoTest, 'armeParDefaut');
      if (arme === undefined) return;
      if (arme === true) degainerArme(perso, '', evt);
      else degainerArme(perso, arme, evt);
    });
    // On recharge les armes
    let charges = {};
    persosDuCombat.forEach(function(perso) {
      let persoTest = persoParCharId[perso.charId];
      if (charges[persoTest.charId] === undefined) {
        charges[persoTest.charId] = {};
        let attaques = listAllAttacks(perso);
        for (let label in attaques) {
          let att = attaques[label];
          if (att.armespec) {
            let predicats = predicateOfRaw(att.armespec);
            if (predicats.charge) {
              let chargeMax = predicats.charge;
              if (chargeMax === true) chargeMax = 1;
              charges[persoTest.charId][label] = chargeMax;
            }
          }
        }
      }
      for (let label in charges[persoTest.charId]) {
        setTokenAttr(perso, 'charge_' + label, charges[persoTest.charId][label], evt);
      }
    });
    //Effet de ignorerLaDouleur
    let ilds = allAttributesNamed(attrs, 'douleurIgnoree');
    ilds = ilds.concat(allAttributesNamed(attrs, 'memePasMalIgnore'));
    ilds.forEach(function(ild) {
      let douleur = parseInt(ild.get('current'));
      if (isNaN(douleur)) {
        error("La douleur ignor\xE9e n'est pas un nombre", douleur);
        return;
      }
      let charId = ild.get('characterid');
      if (charId === undefined || charId === '') {
        error("Attribut sans personnage", ild);
        return;
      }
      let ildName = ild.get('name');
      if (ildName == 'douleurIgnoree' || ildName == 'memePasMalIgnore') {
        let pvAttr = findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: 'PV'
        }, {
          caseInsensitive: true
        });
        if (pvAttr.length === 0) {
          error("Personnage sans PV ", charId);
          return;
        }
        pvAttr = pvAttr[0];
        let pv = parseInt(pvAttr.get('current'));
        if (isNaN(pv)) {
          error("PV mal form\xE9s ", pvAttr);
          return;
        }
        evt.attributes.push({
          attribute: pvAttr,
          current: pv
        });
        let newPv = pv - douleur;
        if (newPv < 0) newPv = 0;
        pvAttr.set('current', newPv);
        if (pv > 0 && newPv === 0) {
          sendChar(charId, "s'\xE9croule. Il semble sans vie. La douleur qu'il avait ignor\xE9e l'a finalement rattrap\xE9...", true);
        } else {
          let tempDmg = ficheAttributeAsInt(charId, 'DMTEMP', 0);
          if (pv > tempDmg && newPv <= tempDmg) {
            sendChar(charId, "s'\xE9croule, assomm\xE9. La douleur qu'il avait ignor\xE9e l'a finalement rattrap\xE9...", true);
          } else {
            sendChar(charId, "subit le contrecoup de la douleur qu'il avait ignor\xE9e", true);
          }
        }
      } else { // ignorer la douleur d'un token
        let tokName = ildName.substring(ildName.indexOf('_') + 1);
        let tokensIld = findObjs({
          _type: 'graphic',
          _subtype: 'token',
          represents: charId,
          name: tokName
        });
        if (tokensIld.length === 0) {
          error("Pas de token nomm\xE9 " + tokName + " qui aurait ignor\xE9 la douleur", ild);
          return;
        }
        if (tokensIld.length > 1) {
          sendChar(charId, "a plusieurs tokens nomm\xE9s " + tokName + ". Un seul d'entre eux subira l'effet d'ignorer la douleur", true);
        }
        let tokPv = parseInt(tokensIld[0].get('bar1_value'));
        let tokNewPv = tokPv - douleur;
        if (tokNewPv < 0) tokNewPv = 0;
        let perso = {
          charId: charId,
          token: tokensIld[0]
        };
        updateCurrentBar(perso, 1, tokNewPv, evt);
        //TODO: faire mourrir, assommer
      }
    }); // end forEach on all attributes ignorerLaDouleur
    ilds.forEach(function(ild) {
      evt.deletedAttributes.push(ild);
      ild.remove();
    });
    if (ilds.length > 0) {
      attrs = attrs.filter(function(attr) {
        let ind = ilds.findIndex(function(nattr) {
          return nattr.id == attr.id;
        });
        return (ind == -1);
      });
    }
    // fin des effets temporaires (dur\xE9e en tours, ou dur\xE9e = combat)
    attrs.forEach(function(obj) {
      let attrName = obj.get('name');
      let charId = obj.get('characterid');
      if (estEffetTemp(attrName)) {
        finDEffet(obj, effetTempOfAttribute(obj), attrName, charId, evt, {
          pageId: combat.pageId
        });
      } else if (estAttributEffetTemp(attrName)) {
        evt.deletedAttributes.push(obj);
        obj.remove();
      } else if (estEffetCombat(attrName)) {
        let effet = effetCombatOfAttribute(obj);
        if (effet == 'armeDArgent') {
          //Alors on va rengainer l'arme en main si c'est l'arme d'argent
          iterTokensOfAttribute(charId, combat.pageId, effet, attrName, function(token) {
            let perso = {
              token: token,
              charId: charId
            };
            let arme = armesEnMain(perso);
            if (!arme) return;
            let options = arme.options;
            if (options === '') return;
            if (!options.startsWith(' ')) options = ' ' + options;
            options = options.split(' --');
            options.find(function(o) {
              if (o.startsWith('si ')) {
                o = o.split(' ');
                if (o.includes('armeDArgent')) {
                  degainerArme(perso, '', evt);
                  return true;
                }
              }
              return false;
            });
          });
        }
        let mEffet = messageEffetCombat[effet];
        let mc = messageFin({
          charId
        }, mEffet);
        if (mc && mc !== '') sendChar(charId, mc, true);
        evt.deletedAttributes.push(obj);
        obj.remove();
        let ms = mEffet.statusMarker;
        if (ms) {
          iterTokensOfAttribute(charId, combat.pageId, effet, attrName, function(token) {
            affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
            token.set('status_' + ms, false);
          });
        }
        if (effet == 'estGobePar') {
          iterTokensOfAttribute(charId, combat.pageId, effet, attrName, function(token) {
            let perso = {
              token: token,
              charId: charId
            };
            unlockToken(perso, evt);
          });
        }
      } else if (estAttributEffetCombat(attrName)) {
        evt.deletedAttributes.push(obj);
        obj.remove();
      }
    });
    if (stateCOF.tokensTemps) {
      evt.deletedTokensTemps = [];
      stateCOF.tokensTemps.forEach(function(tt) {
        let token = getObj('graphic', tt.tid);
        if (token) {
          let ett = {...tt
          };
          ett.deletedToken = getTokenFields(token);
          evt.deletedTokensTemps.push(ett);
          token.remove();
        }
      });
      delete stateCOF.tokensTemps;
    }
    addEvent(evt);
  }

  //pr est optionnel
  function rajouterPointDeRecuperation(perso, evt, pr) {
    evt.attributes = evt.attributes || [];
    pr = pr || pointsDeRecuperation(perso);
    if (!pr.attribut) return false;
    if (pr.current >= pr.max) return false;
    evt.attributes.push({
      attribute: pr.attribut,
      current: pr.current,
    });
    pr.current++;
    pr.attribut.set('current', pr.current);
    return true;
  }

  //Asynchrone
  // ne rajoute pas evt \xE0 l'historique
  function soinsEcuyers(ecuyers, manquePV, playerId, evt) {
    ecuyers.forEach(function(ec) {
      const ecuyer = ec.perso;
      let ecuyerDe = ec.ecuyerDe;
      let charChevalier = findObjs({
        _type: 'character',
        name: ecuyerDe
      });
      if (charChevalier.length === 0) {
        error("Pas de chevalier " + ecuyerDe + " pour l'\xE9cuyer " + nomPerso(ecuyer), ec);
        return;
      }
      if (charChevalier.length > 1) {
        error("Plusieurs personnages nomm\xE9s " + ecuyerDe + ". Attention aux ambiguit\xE9s.");
      }
      charChevalier = charChevalier[0].id;
      let maxASoigner = modCarac(charChevalier, 'charisme') + 1;
      let allies = alliesParPerso[ecuyer.charId] || new Set();
      let alliesASoigner = [];
      let nbCibles = 0;
      let chevalier;
      let monture;
      manquePV.forEach(function(cible) {
        if (cible.charId == charChevalier) {
          chevalier = cible;
          nbCibles++;
          return;
        }
        if (allies.has(cible.charId)) {
          let montureDe = predicateAsBool(cible, 'montureDe');
          if (montureDe == ecuyerDe) {
            monture = cible;
            nbCibles++;
            return;
          }
          alliesASoigner.push(cible);
        }
      }); //fin de d\xE9termination des cibles
      if (chevalier === undefined && monture === undefined &&
        (maxASoigner < 1 || alliesASoigner.length === 0)) { //Personne \xE0 soigner
        return;
      }
      //TODO: utiliser l'id d'un player qui contr\xF4le le chevalier
      let display = startFramedDisplay(playerId, "Services d'\xE9cuyer", ecuyer);
      let finSoin = function() {
        nbCibles--;
        if (nbCibles === 0) {
          if (display) sendChat("", endFramedDisplay(display));
        }
      };
      let soigneUneCible = function(c) {
        sendChat('', "[[2d6]]", function(res) {
          let soins = res[0].inlinerolls[0].results.total;
          let soinTxt = buildinline(res[0].inlinerolls[0], 'normal', true);
          let printTrue = function(s) {
            let msgSoin = nomPerso(ecuyer) + ' ';
            if (c.token.id == ecuyer.token.id) {
              msgSoin = 'se soigne de ';
            } else {
              msgSoin = nomPerso(c) + " r\xE9cup\xE8re ";
            }
            if (s < soins)
              msgSoin += s + " PV. (Le r\xE9sultat du jet \xE9tait " + soinTxt + ")";
            else msgSoin += soinTxt + " PV.";
            addLineToFramedDisplay(display, msgSoin);
          };
          soigneToken(c, soins, evt, printTrue);
          finSoin();
        }); //fin du sendChat
      }; // fin de d\xE9finition de soigneCible
      let peutToutSoigner = (alliesASoigner.length <= maxASoigner);
      if (peutToutSoigner) nbCibles += alliesASoigner.length;
      else if (maxASoigner > 0) nbCibles++; //pour ne pas finir avant d'imprimer les boutons
      if (chevalier) soigneUneCible(chevalier);
      if (monture) soigneUneCible(monture);
      if (peutToutSoigner) {
        alliesASoigner.forEach(soigneUneCible);
      } else if (maxASoigner > 0) {
        addLineToFramedDisplay(display, "Peut prendre soin de (max " + maxASoigner + ") :");
        let attr = setTokenAttr(ecuyer, 'SoinsdEcuyer', maxASoigner, evt);
        let action = "!cof-soin " + ecuyer.token.id + " ";
        alliesASoigner.forEach(function(c) {
          let nom = nomPerso(c);
          addLineToFramedDisplay(display, bouton(action + c.token.id + " 2d6", nom, ecuyer, {
            ressource: attr
          }));
        });
        finSoin();
      }
    }); //fin iteration sur les \xE9cuyers
  }

  function parseOptions(msg) {
    let pageId, playerId;
    if (msg.selected && msg.selected.length > 0) {
      let firstSelected = getObj('graphic', msg.selected[0]._id);
      if (firstSelected === undefined) {
        error("Un token s\xE9lectionn\xE9 n'est pas trouv\xE9 en interne", msg.selected);
        return;
      }
      pageId = firstSelected.get('pageid');
    } else {
      playerId = getPlayerIdFromMsg(msg);
      pageId = getPageId(playerId);
    }
    let opts = msg.content.split(' --');
    let cmd = opts.shift().split(' ');
    cmd = cmd.filter(function(c) {
      return c !== '';
    });
    let options = {
      pageId: pageId,
      playerId: playerId,
      cmd: cmd
    };
    opts.forEach(function(arg) {
      cmd = arg.trim().split(' ');
      switch (cmd[0]) {
        case 'attaqueMentale':
        case 'seulementVivant':
        case 'repos':
        case 'secret':
        case 'magique':
        case 'montreActions':
        case 'brumes':
        case 'silencieuxSiPasAffecte':
          options[cmd[0]] = true;
          break;
        case 'lanceur':
          if (cmd.length < 2) {
            error("Il faut pr\xE9ciser l'id ou le nom du lanceur", arg);
            return;
          }
          options.lanceur = persoOfId(cmd[1], cmd[1], pageId);
          if (options.lanceur === undefined) {
            error("Argument de --lanceur non valide", cmd);
          }
          return;
        case 'puissant':
          if (cmd.length < 2) {
            options.puissant = "on";
            return;
          }
          switch (cmd[1]) {
            case "oui":
              options.puissant = "on";
              return;
            case "non":
              options.puissant = "off";
              return;
            case "duree":
              options.puissantDuree = true;
              return;
            case 'portee':
              options.puissantPortee = true;
              return;
            default:
              error("Option puissant non reconnue", cmd);
          }
          return;
        case 'mana':
          if (cmd.length < 2) {
            error("Pas assez d'argument pour --mana", cmd);
            return;
          }
          let cout;
          if (cmd.length > 2 && cmd[1] !== '' && cmd[2] !== '') {
            options.lanceur = options.lanceur || persoOfId(cmd[1], cmd[1], pageId);
            if (options.lanceur === undefined) {
              error("Premier argument de --mana non valide", cmd);
              return;
            }
            cout = parseInt(cmd[2]);
          } else {
            cout = parseInt(cmd[1]);
          }
          if (isNaN(cout) || cout < 0) {
            error("Co\xFBt en mana incorrect", cmd);
            return;
          }
          options.mana = options.mana || 0;
          options.mana += cout;
          return;
        case 'magieRapide':
          if (options.magieRapide) return;
          if (options.mana === undefined) options.mana = 0;
          if (reglesOptionelles.mana.val.mana_totale.val) options.mana += 3;
          else options.mana++;
          options.magieRapide = true;
          return;
        case 'tempeteDeMana':
          parseTempeteDeMana(cmd, options);
          return;
        case 'rang':
          if (cmd.length < 2) {
            error("Usage : --rang r", cmd);
            return;
          }
          var rang = parseInt(cmd[1]);
          if (isNaN(rang) || rang < 1) {
            error("Le rang doit \xEAtre un nombre positif");
            return;
          }
          options.rang = rang;
          break;
        case 'limiteParJour':
          if (cmd.length < 2) {
            error("Il manque la limite journali\xE8re", cmd);
            return;
          }
          let limiteParJour = parseInt(cmd[1]);
          if (isNaN(limiteParJour) || limiteParJour < 1) {
            error("La limite journali\xE8re doit \xEAtre un nombre positif", cmd);
            return;
          }
          options.limiteParJour = limiteParJour;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            options.limiteParJourRessource = cmd.join('_');
          }
          return;
        case 'depasseLimite':
          if (cmd.length < 2) {
            error("Il manque le co\xFBt en mana pour depasser la limite", cmd);
            return;
          }
          let depasse = parseInt(cmd[1]);
          if (isNaN(depasse) || depasse < 1) {
            error("Le co\xFBt de d\xE9passement doit \xEAtre un nombre positif", cmd);
            return;
          }
          options.depasseLimite = depasse;
          return;
        case 'limiteSoinsParJour':
          if (cmd.length < 2) {
            error("Il manque la limite de soins journali\xE8re", cmd);
            return;
          }
          var limiteSoinsParJour = parseInt(cmd[1]);
          if (isNaN(limiteSoinsParJour) || limiteSoinsParJour < 1) {
            error("La limite de soins journali\xE8re doit \xEAtre un nombre positif", cmd);
            return;
          }
          options.limiteSoinsParJour = limiteSoinsParJour;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            options.limiteSoinsParJourRessource = cmd.join('_');
          }
          return;
        case 'limiteCibleParJour':
          if (cmd.length < 2) {
            error("Il manque la limite journali\xE8re", cmd);
            return;
          }
          let limiteCibleParJour = parseInt(cmd[1]);
          if (isNaN(limiteCibleParJour) || limiteCibleParJour < 1) {
            error("La limite journali\xE8re doit \xEAtre un nombre positif", cmd);
            return;
          }
          options.limiteCibleParJour = limiteCibleParJour;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            options.limiteCibleParJourRessource = cmd.join('_');
          }
          return;
        case 'limiteParCombat':
          if (cmd.length < 2) {
            options.limiteParCombat = 1;
            return;
          }
          let limiteParCombat = parseInt(cmd[1]);
          if (isNaN(limiteParCombat) || limiteParCombat < 1) {
            error("La limite par combat doit \xEAtre un nombre positif", cmd);
            return;
          }
          options.limiteParCombat = limiteParCombat;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            options.limiteParCombatRessource = cmd.join('_');
          }
          return;
        case 'tempsRecharge':
          if (cmd.length < 3) {
            error("Il manque un argument \xE0 l'option --tempsRecharge", cmd);
            return;
          }
          if (!estEffetTemp(cmd[1])) {
            error("Le premier argument de l'option --tempsRecharge doit \xEAtre un effet temporaire r\xE9pertori\xE9", cmd);
            return;
          }
          let tr = parseInt(cmd[2]);
          if (isNaN(tr)) {
            error("Le deuxi\xE8me argument de l'option --tempsRecharge doit \xEAtre un nombre", cmd);
            return;
          }
          options.tempsRecharge = {
            effet: cmd[1],
            duree: tr
          };
          return;
        case 'portee':
          if (cmd.length < 2) {
            error("Pas assez d'argument pour --portee n", cmd);
            return;
          }
          let portee;
          if (cmd.length > 2) {
            let tokPortee = persoOfId(cmd[1], cmd[1], pageId);
            if (tokPortee === undefined) {
              error("Premier argument de --portee non valide", cmd);
              return;
            }
            portee = parseInt(cmd[2]);
          } else {
            portee = parseInt(cmd[1]);
          }
          if (isNaN(portee) || portee < 0) {
            error("Port\xE9e incorrecte", cmd);
            return;
          }
          options.portee = portee;
          return;
        case 'saveParTour':
          options.saveParTour = parseSave(cmd);
          return;
        case 'saveActifParTour':
          options.saveActifParTour = parseSave(cmd);
          return;
        case 'save':
          options.save = parseSave(cmd);
          return;
        case 'dose':
          if (cmd.length < 2) {
            error("Il faut le nom de la dose", cmd);
            return;
          }
          options.dose = cmd[1];
          return;
        case 'decrAttribute':
          if (cmd.length < 2) {
            error("Erreur interne d'une commande g\xE9n\xE9r\xE9e par bouton", opts);
            return;
          }
          let attr = getObj('attribute', cmd[1]);
          if (attr === undefined && options.lanceur) {
            attr = tokenAttribute(options.lanceur, cmd[1]);
            if (attr.length === 0) {
              log("Attribut \xE0 changer perdu");
              log(cmd);
              return;
            }
            attr = attr[0];
          }
          if (attr === undefined) {
            log("Attribut \xE0 changer perdu");
            log(cmd);
            return;
          }
          options.decrAttribute = attr.id;
          return;
        case 'valeur':
          if (cmd.length < 2) {
            error("Il manque la valeur en argument de l'option --valeur", opts);
            return;
          }
          options.valeur = cmd[1];
          if (cmd.length > 2) options.valeurMax = cmd[2];
          return;
        case 'accumuleDuree':
          if (cmd.length < 2) {
            error("Il manque la valeur en argument de l'option --accumuleDuree", opts);
            return;
          }
          var accumuleDuree = parseInt(cmd[1]);
          if (isNaN(accumuleDuree) || accumuleDuree < 1) {
            error("On ne peut accumuler qu'on nombre strictement positif d'effets", opts);
            return;
          }
          options.accumuleDuree = accumuleDuree;
          return;
        case 'optionEffet':
          if (cmd.length < 2) {
            error("Il manque l'option en argument de --optionEffet", cmd);
            return;
          }
          options.optionsEffet = options.optionsEffet || '';
          options.optionsEffet = ' --' + cmd.slice(1).join(' ') + options.optionsEffet;
          return;
        case "nonVivant":
          options.nonVivant = true;
          if (cmd.length > 1) {
            let nonVivantPerso = persoOfId(cmd[1], cmd[1], pageId);
            if (nonVivantPerso) {
              options.nonVivant = predicateAsBool(nonVivantPerso, 'nonVivant');
            }
          }
          return;
        case "fx":
          getFx(cmd, 'fx', options);
          return;
        case "targetFx":
          getFx(cmd, 'targetFx', options);
          break;
        case "classeEffet":
          if (cmd.length < 2) {
            sendChat("COF", "Il manque un argument \xE0 l'option --classeEffet");
            return;
          }
          options.classeEffet = cmd[1];
          return;
        case 'message':
          if (cmd.length < 2) {
            error("Il manque le message apr\xE8s --message", cmd);
            return;
          }
          options.messages = options.messages || [];
          options.messages.push(cmd.slice(1).join(' '));
          return;
        case 'messageMJ':
          if (cmd.length < 2) {
            error("Il manque le message apr\xE8s --messageMJ", cmd);
            return;
          }
          options.messagesMJ = options.messagesMJ || [];
          options.messagesMJ.push(cmd.slice(1).join(' '));
          return;
        case 'image':
          if (cmd.length < 2) {
            error("Il manque le nom de l'imageapr\xE8s --image", cmd);
            return;
          }
          options.image = cmd[1].replace('&#58;', ':');
          return;
        case 'son':
          if (cmd.length < 2) {
            error("Il manque le nom du son apr\xE8s --son", cmd);
            return;
          }
          options.son = cmd.slice(1).join(' ');
          return;
        case 'feu':
        case 'froid':
        case 'acide':
        case 'electrique':
        case 'sonique':
        case 'poison':
        case 'maladie':
        case 'energie':
          options.type = cmd[0];
          return;
        case 'bonus':
        case 'rayon':
          if (cmd.length >= 2) {
            let value = parseInt(cmd[1]);
            if (!isNaN(value)) {
              options[cmd[0]] = value;
            }
          }
          return;
        case 'etat':
          if (cmd.length < 2) {
            error("Il manque le nom de l'\xE9tat et sa valeur apr\xE8s --etat", cmd);
            return;
          }
          options.etats = options.etats || {};
          if (cmd.length < 3) {
            options.etats[cmd[1]] = true;
            return;
          }
          if (cmd[2] == 'false' || cmd[2] == 'non') options.etats[cmd[1]] = false;
          else if (cmd[2] == 'true' || cmd[2] == 'oui') options.etats[cmd[1]] = true;
          else options.etats[cmd[1]] = cmd[2];
          return;
        case 'degainer':
          if (cmd.length > 1) options.degainer = cmd[1];
          else options.degainer = '';
          return;
        case 'soin':
        case 'dm':
          let t = cmd[0];
          if (options[t]) {
            error(t + " d\xE9j\xE0 d\xE9fini", opts);
            return;
          }
          if (cmd.length < 2) {
            error("Il manque l'expression pour les " + t + "s", opts);
          }
          options[t] = cmd.slice(1).join(' ');
          return;
        case 'malusRepetition':
          let malusRepetition = 1;
          if (cmd.length > 1) {
            malusRepetition = parseInt(cmd[1]);
            if (isNaN(malusRepetition)) malusRepetition = 1;
          }
          options.malusRepetition = malusRepetition;
          return;
        case 'magieEnArmure':
          if (cmd.length > 1) {
            if (cmd[1] == 'mana') {
              options.magieEnArmureMana = true;
            } else {
              let base = parseInt(cmd[1]);
              if (isNaN(base)) {
                error("L'argument de --magieEnArmure doit \xEAtre un nombre ou mana", cmd);
                return;
              }
              options.magieEnArmure = {
                base
              };
            }
          } else {
            options.magieEnArmure = {};
          }
          return;
        default:
          return;
      }
    });
    return options;
  }

  //Si il y a des effets \xE0 dur\xE9e ind\xE9termin\xE9es, les rappeler au MJ, avec un bouton pour facilement y mettre fin si n\xE9cessaire
  function proposerFinEffetsIndetermines() {
    //On commence par les \xE9tats globaux
    if (stateCOF.tenebresMagiques) {
      sendPlayer('GM', boutonSimple("!cof-tenebres-magiques fin", "Mettre fin") + "aux t\xE9n\xE8bres magiques ?");
    }
    if (stateCOF.foudreDuTemps) {
      sendPlayer('GM', boutonSimple("!cof-foudre-du-temps fin", "Mettre fin") + "aux foudres du temps ?");
    }
    let attrs = findObjs({
      _type: 'attribute'
    });
    attrs = attrs.filter(function(a) {
      let name = a.get('name');
      return name == 'PVTemporaires' || name.startsWith('PVTemporaires_') ||
        estEffetIndetermine(name);
    });
    if (attrs.length === 0) return;
    const display = startFramedDisplay(undefined, "<b>Effets \xE0 dur\xE9e ind\xE9termin\xE9e actifs</b>", undefined, {
      chuchote: 'gm'
    });
    let attrsParPerso = {};
    attrs.forEach(function(a) {
      const charId = a.get('characterid');
      const attrName = a.get('name');
      let ef = {
        nom: attrName
      };
      let attrLie;
      if (attrName == 'PVTemporaires') {
        let pt = parseInt(a.get('current'));
        if (isNaN(pt) || pt < 1) {
          a.remove();
          return;
        }
        attrLie = true;
        ef.pvTemporaires = pt;
      } else if (attrName.startsWith('PVTemporaires_')) {
        let pt = parseInt(a.get('current'));
        if (isNaN(pt) || pt < 1) {
          a.remove();
          return;
        }
        ef.pvTemporaires = pt;
      } else {
        let mes = messageEffetIndetermine[attrName];
        if (mes) {
          ef.actif = mes.actif;
          ef.actifF = mes.actifF;
          attrLie = true;
        }
      }
      if (attrLie) {
        if (attrsParPerso[charId] === undefined) {
          let resLinked = {
            effets: [ef],
            charId
          };
          let linkedTokens = findObjs({
            _type: 'graphic',
            represents: charId
          });
          linkedTokens = linkedTokens.filter(function(t) {
            return t.get('bar1_link') !== '';
          });
          if (linkedTokens.length === 0) {
            let character = getObj('character', charId);
            if (character === undefined) {
              error("Attribut sans personnage", a);
              a.remove();
              return;
            }
            resLinked.nomPerso = character.get('name');
          } else {
            resLinked.nomPerso = linkedTokens[0].get('name');
            resLinked.tokenId = linkedTokens[0].id;
          }
          attrsParPerso[charId] = resLinked;
          return;
        }
        attrsParPerso[charId].effets.push(ef);
        return;
      } // on a un attribut de token non li\xE9
      let pn = attrName.indexOf('_');
      if (pn < 1) return;
      ef.nom = attrName.substring(0, pn - 1);
      if (!ef.pvTemporaires) {
        let mes = messageEffetIndetermine[ef.nom];
        if (mes === undefined) return;
        ef.actif = mes.actif;
        ef.actifF = mes.actifF;
      }
      let nomPerso = attrName.substring(pn + 1);
      if (attrsParPerso[nomPerso] === undefined) {
        let tokens = findObjs({
          _type: 'graphic',
          represents: charId
        });
        tokens = tokens.filter(function(t) {
          return t.get('bar1_link') === '' && t.get('name') == nomPerso;
        });
        if (tokens.length === 0) {
          error("Attribut de mook sans personnage", a);
          a.remove();
          return;
        }
        attrsParPerso[nomPerso] = {
          nomPerso: nomPerso,
          tokenId: tokens[0].id,
          effets: [ef],
          charId
        };
        return;
      }
      attrsParPerso[nomPerso].effets.push(ef);
    });
    _.each(attrsParPerso, function(a) {
      let line = '<b>' + a.nomPerso + "</b> : ";
      a.effets.forEach(function(e) {
        if (e.pvTemporaires) {
          line += "PV temporaires " + e.pvTemporaires + ' ';
        } else {
          line += messageActif({
            charId: a.charId
          }, e) + ' ';
        }
        if (a.tokenId) {
          if (e.pvTemporaires) {
            line += boutonSimple('!cof-set-attribute PVTemporaires 0 --message Disparition des PVs temporaires --target ' + a.tokenId, 'X');
          } else {
            line += boutonSimple('!cof-effet ' + e.nom + ' false --target ' + a.tokenId, 'X');
          }
        } else line += "supprimer l'attribut " + e.nom;
      });
      addLineToFramedDisplay(display, line);
    });
    sendChat('', endFramedDisplay(display));
  }

  // Remise \xE0 z\xE9ro de toutes les limites journali\xE8res
  // N'ajoute pas evt \xE0 l'historique
  function jour(evt, options) {
    let attrs;
    attrs = removeAllAttributes('pressionMortelle', evt);
    attrs = removeAllAttributes('soinsLegers', evt, attrs);
    attrs = removeAllAttributes('depassesoinsLegers', evt, attrs);
    attrs = removeAllAttributes('soinsModeres', evt, attrs);
    attrs = removeAllAttributes('depassesoinsModeres', evt, attrs);
    attrs = removeAllAttributes('fortifie', evt, attrs);
    attrs = removeAllAttributes('limiteParJour', evt, attrs);
    attrs = removeAllAttributes('depasselimiteParJour', evt, attrs);
    attrs = removeAllAttributes('tueurFantasmagorique', evt, attrs);
    attrs = removeAllAttributes('immunise24HA', evt, attrs);
    attrs = removeAllAttributes('testsRatesDuTour', evt, attrs);
    attrs = removeAllAttributes('pointsDeViolence', evt, attrs);
    //Les \xE9lixirs
    attrs = removeAllAttributes('elixirsACreer', evt, attrs);
    attrs = proposerRenouveauElixirs(evt, attrs, options);
    //Les runes
    attrs = proposerRenouveauRunes(evt, attrs, options);
    //Les plantes m\xE9dicinales
    attrs = removeAllAttributes('dose_Plante m\xE9dicinale', evt, attrs);
    attrs = removeConsommables('Plante m\xE9dicinale', evt, attrs);
    //On pourrait diviser par 2 le nombre de baies
    //let attrsBaie = allAttributesNamed(attrs, 'dose_Baie_magique');
    //Saves journaliers
    let attrsSave = attrs.filter(function(attr) {
      let attrName = attr.get('name');
      let indexSave = attrName.indexOf('SaveParJour');
      if (indexSave <= 0) return false;
      indexSave = attrName.indexOf('SaveParJourType');
      return indexSave <= 0;
    });
    //Les saves sont asynchrones
    let count = attrsSave.length;
    if (count === 0) {
      proposerFinEffetsIndetermines();
      return;
    }
    const finalize = function() {
      count--;
      if (count > 0) return;
      proposerFinEffetsIndetermines();
    };
    attrsSave.forEach(function(attr) {
      let attrName = attr.get('name');
      let carac = attr.get('current');
      if (!isCarac(carac)) {
        error("Save par jour " + attrName + " mal form\xE9", carac);
        finalize();
        return;
      }
      let seuil = parseInt(attr.get('max'));
      if (isNaN(seuil)) {
        error("Save par jour " + attrName + " mal form\xE9", seuil);
        finalize();
        return;
      }
      let charId = attr.get('characterid');
      let indexSave = attrName.indexOf('SaveParJour');
      let effetC = attrName.substring(0, indexSave);
      attrName = effetC + attrName.substr(indexSave + 11);
      let token;
      iterTokensOfAttribute(charId, undefined, effetC, attrName, function(tok) {
        if (token === undefined) token = tok;
      });
      if (token === undefined) {
        log("Pas de token pour le save " + attrName);
        finalize();
        return;
      }
      var pageId = token.get('pageid');
      var perso = {
        token: token,
        charId: charId
      };
      if (getState(perso, 'mort')) {
        finalize();
        return;
      }
      var attrEffet = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attrName
      });
      if (attrEffet === undefined || attrEffet.length === 0) {
        error("Save sans effet associ\xE9 " + attrName, attr);
        findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: attr.get('name').replace('SaveParJour', 'SaveParJourType')
        }).forEach(function(a) {
          a.remove();
        });
        attr.remove();
        finalize();
        return;
      }
      attrEffet = attrEffet[0];
      let expliquer = function(msg) {
        sendPerso(perso, msg);
      };
      let sujet = onGenre(perso, 'il', 'elle');
      let met = messageEffetIndetermine[effetC];
      if (met === undefined) met = {
        fin: "r\xE9siste \xE0 l'effet",
        actf: "reste sous l'emprise de l'effet"
      };
      let saveOpts = {
        msgPour: " pour ne plus \xEAtre sous l'effet " + effetC,
        msgReussite: ", " + sujet + ' ' + messageFin(perso, met),
        msgRate: ", " + sujet + ' ' + messageActif(perso, met),
        rolls: options.rolls,
        chanceRollId: options.chanceRollId
      };
      let attrType = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attr.get('name').replace('SaveParJour', 'SaveParJourType')
      });
      if (attrType.length > 0) {
        saveOpts.type = attrType[0].get('current');
      }
      let saveId = 'saveParJour_' + effetC + "_" + perso.token.id;
      save({
          carac,
          seuil
        }, perso, saveId, expliquer, saveOpts, evt,
        function(reussite, texte) { //asynchrone
          if (reussite) {
            finDEffet(attrEffet, effetC, attrName, charId, evt, {
              attrSave: attr,
              pageId: pageId
            });
          }
          count--;
        });
    }); //fin boucle attrSave
  }

  //La caract\xE9ristique sans affaiblissement
  function caracNormale(perso, carac) {
    let res = ficheAttributeAsInt(perso, carac, 10);
    if (!persoEstPNJ(perso)) return res;
    let mod;
    switch (carac) {
      case 'force':
        mod = ficheAttributeAsInt(perso, 'pnj_for', 0);
        break;
      case 'dexterite':
        mod = ficheAttributeAsInt(perso, 'pnj_dex', 0);
        break;
      case 'constitution':
        mod = ficheAttributeAsInt(perso, 'pnj_con', 0);
        break;
      case 'intelligence':
        mod = ficheAttributeAsInt(perso, 'pnj_int', 0);
        break;
      case 'sagesse':
        mod = ficheAttributeAsInt(perso, 'pnj_sag', 0);
        break;
      case 'charisme':
        mod = ficheAttributeAsInt(perso, 'pnj_cha', 0);
        break;
    }
    if (mod == Math.floor((caracNormale - 10) / 2)) {
      return res;
    }
    return mod * 2 + 10;
  }

  function caracCourante(perso, carac) {
    return caracNormale(perso, carac) -
      attributeAsInt(perso, 'affaiblissementde' + carac, 0);
  }

  //N'ajoute pas evt \xE0 l'historique
  function diminueAffaiblissement(perso, carac, valeur, evt, malus) {
    if (valeur < 1) return;
    let nomAttr = 'affaiblissementde' + carac;
    malus = malus || attributeAsInt(perso, nomAttr, 0);
    if (valeur < malus) {
      setTokenAttr(perso, nomAttr, malus - valeur, evt);
    } else {
      valeur = malus;
      removeTokenAttr(perso, nomAttr, evt);
    }
    if (carac == 'constitution') {
      let gainMod = Math.floor((valeur) / 2);
      let constitution;
      if (valeur % 2 == 1) {
        constitution = caracNormale(perso, 'constitution');
        if ((constitution - malus) % 2 == 1) gainMod += 1;
      }
      if (gainMod > 0) {
        //On recalcule les pvmax en fonction de la perte courante
        let bar1 = parseInt(perso.token.get("bar1_value"));
        let pvmax = parseInt(perso.token.get("bar1_max"));
        if (isNaN(bar1) || isNaN(pvmax)) {
          error("Affaiblissement de constitution sur un token sans points de vie", perso);
          return;
        }
        let pvMaxNormaux = attributeAsInt(perso, 'pvMaxNormaux', 0);
        if (pvMaxNormaux < pvmax) {
          error("Les PV max sont inf\xE9rieurs \xE0 la valeur normale", pvMaxNormaux);
          return;
        }
        if (valeur == malus || (valeur == malus - 1 && caracNormale(perso, 'consititution') % 2 == 1)) {
          removeTokenAttr(perso, 'pvMaxNormaux', evt);
          let pvGagnes = pvMaxNormaux - pvmax;
          if (pvGagnes > 0) {
            updateCurrentBar(perso, 1, bar1 + pvGagnes, evt, pvMaxNormaux);
          }
        } else {
          let nouveauMalus = malus - valeur;
          let perteMod = Math.floor(nouveauMalus / 2);
          if (nouveauMalus % 2 == 1) {
            if (constitution === undefined)
              constitution = caracNormale(perso, 'constitution');
            if (constitution % 2 == 0) perteMod++;
          }
          let niveau = ficheAttributeAsInt(perso, 'niveau', 1);
          let pvPerdus = niveau * perteMod;
          let nouveauPVMax = pvMaxNormaux - pvPerdus;
          if (nouveauPVMax > pvmax) {
            bar1 += nouveauPVMax - pvmax;
            pvmax = nouveauPVMax;
            updateCurrentBar(perso, 1, bar1, evt, pvmax);
          }
        }
      } else if (valeur == malus) {
        //Au cas o\xF9, on v\xE9rifie le pv max
        let pvMaxNormaux = attributeAsInt(perso, 'pvMaxNormaux', 0);
        if (pvMaxNormaux > 0) {
          let pvmax = parseInt(perso.token.get("bar1_max"));
          if (pvmax < pvMaxNormaux) {
            let bar1 = parseInt(perso.token.get("bar1_value"));
            updateCurrentBar(perso, 1, bar1 + pvMaxNormaux - pvmax, evt, pvMaxNormaux);
          }
          removeTokenAttr(perso, 'pvMaxNormaux', evt);
        }
      }
    }
  }

  function parseNouveauJour(msg) {
    let options = parseOptions(msg);
    getSelected(msg, function(selection, playerId) {
      options.playerId = playerId;
      if (selection.length === 0) {
        let pageId = options.pageId;
        let tokens =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            layer: 'objects',
            _pageid: pageId
          });
        tokens.forEach(function(tok) {
          if (tok.get('represents') === '') return;
          selection.push({
            _id: tok.id
          });
        });
      }
      let persos = [];
      iterSelected(selection, function(perso) {
        persos.push(perso);
      });
      doNouveauJour(persos, options);
    }, options);
  }

  function doNouveauJour(persos, options) {
    let evt = {
      type: "nouveauJour",
      attributes: [],
      action: {
        persos: persos,
        options: options
      }
    };
    addEvent(evt);
    let fromMsg = 'player|' + options.playerId;
    let player = getObj('player', options.playerId);
    if (player) {
      let speaksAs = player.get('speakingas');
      if (speaksAs !== '') fromMsg = speaksAs;
    }
    sendChat(fromMsg, "Un nouveau jour se l\xE8ve");
    if (stateCOF.combat) sortirDuCombat();
    jour(evt, options);
    if (options.repos) {
      recuperation(persos, true, options.playerId, evt, options);
    }
  }

  function parseRecuperer(msg) {
    if (stateCOF.combat) {
      sendPlayer(msg, "impossible de se reposer en combat");
      return;
    }
    let reposLong = false;
    if (msg.content.includes(' --reposLong')) reposLong = true;
    getSelected(msg, function(selection, playerId) {
      if (selection.length === 0) {
        sendPlayer(msg, "!cof-recuperer sans s\xE9lection de tokens", playerId);
        log("!cof-recuperer requiert des tokens s\xE9lectionn\xE9s");
        return;
      }
      var persos = [];
      iterSelected(selection, function(perso) {
        persos.push(perso);
      });
      doRecuperation(persos, reposLong, playerId);
    });
  }

  function doRecuperation(persos, reposLong, playerId, options) {
    const evt = {
      type: "recuperation",
      attributes: [],
      action: {
        persos: persos,
        reposLong: reposLong,
        playerId: playerId,
        options: options
      }
    };
    addEvent(evt);
    recuperation(persos, reposLong, playerId, evt, options);
  }

  let allCaracs = ['force', 'dexterite', 'constitution', 'intelligence', 'sagesse', 'charisme'];

  //Asynchrone (jets de d\xE9s)
  // ne rajoute pas evt \xE0 l'historique
  function recuperation(persos, reposLong, playerId, evt, options) {
    options = options || {};
    let manquePV = [];
    let ecuyers = [];
    let count = persos.length;
    let finalize = function() {
      count--;
      if (count === 0) {
        if (ecuyers.length > 0 && manquePV.length > 0) {
          soinsEcuyers(ecuyers, manquePV, playerId, evt);
        }
      }
    };
    persos.forEach(function(perso) {
      if (getState(perso, 'mort')) {
        finalize();
        return;
      }
      if (reposLong) {
        let ecuyerDe = predicateAsBool(perso, 'ecuyerDe');
        if (ecuyerDe) {
          ecuyers.push({
            perso,
            ecuyerDe
          });
        }
      }
      let token = perso.token;
      let charId = perso.charId;
      let character = getObj("character", charId);
      if (character === undefined) {
        finalize();
        return;
      }
      let pr = pointsDeRecuperation(perso);
      let bar2 = parseInt(token.get("bar2_value"));
      let manaAttr = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'PM'
      }, {
        caseInsensitive: true
      });
      let hasMana = false;
      let dmTemp = bar2;
      let estMook = token.get('bar1_link') === '';
      if (manaAttr.length > 0) { // R\xE9cup\xE9ration des points de mana
        let manaMax = parseInt(manaAttr[0].get('max'));
        hasMana = !isNaN(manaMax) && manaMax > 0;
        if (hasMana) {
          if (estMook) dmTemp = attributeAsInt(perso, 'DMTEMP', 0);
          else dmTemp = ficheAttributeAsInt(perso, 'DMTEMP', 0);
          if (reposLong && (isNaN(bar2) || bar2 < manaMax)) {
            updateCurrentBar(perso, 2, manaMax, evt);
          }
        }
      }
      if (!isNaN(dmTemp) && dmTemp > 0) { // r\xE9cup\xE9ration de DM temp
        if (reposLong) dmTemp = 0;
        else dmTemp = Math.max(0, dmTemp - 10);
        if (hasMana) {
          setTokenAttr(perso, 'DMTEMP', dmTemp, evt);
        } else {
          updateCurrentBar(perso, 2, dmTemp, evt);
        }
      }
      let bar1 = parseInt(token.get("bar1_value"));
      let pvmax = parseInt(token.get("bar1_max"));
      if (isNaN(bar1) || isNaN(pvmax)) {
        finalize();
        return;
      }
      if (bar1 >= pvmax && !reposLong) {
        //Plus rien \xE0 faire si pas un repos long
        sendPerso(perso, "n'a pas besoin de repos");
        finalize();
        return;
      }
      if (reposLong) {
        //R\xE9cup\xE9ration des affaiblissements de carac si repos long
        allCaracs.forEach(function(carac) {
          let malus = attributeAsInt(perso, 'affaiblissementde' + carac, 0);
          if (malus > 0) {
            diminueAffaiblissement(perso, carac, 1, evt, malus);
            sendPerso(perso, "r\xE9cup\xE8re un point " + deCarac(carac));
          }
        });
        if (bar1 >= pvmax && (!pr || pr.current == pr.max)) {
          finalize();
          return;
        }
        if (bar1 < pvmax && predicateAsBool(perso, 'montureMagique')) {
          //La monture magique r\xE9cup\xE8re tous ses PV durant la nuit
          updateCurrentBar(perso, 1, pvmax, evt);
          sendPerso(perso, "r\xE9cup\xE8re tous ses PV");
          finalize();
          return;
        }
      }
      //La r\xE9cup\xE9ration de PV ou de PR
      let dVie = ficheAttributeAsInt(perso, "DV", 0);
      if (dVie < 4) {
        if (bar1 < pvmax) manquePV.push(perso);
        finalize();
        return; //Si pas de d\xE9 de vie, alors pas de PR.
      }
      if (limiteRessources(perso, options, 'repos', 'repos', evt)) {
        if (bar1 < pvmax) manquePV.push(perso);
        finalize();
        return;
      }
      let message;
      if (reposLong && pr && pr.current < pr.max) { // on r\xE9cup\xE8re un PR
        //Sauf si on a une blessure gave
        if (getState(perso, 'blesse')) {
          let testId = 'gu\xE9rir_blessure_' + perso.token.id;
          testCaracteristique(perso, 'CON', 8, testId, options, evt, function(tr) {
            sendPerso(perso, "fait un jet de CON pour gu\xE9rir de sa blessure");
            let m = "/direct " + onGenre(perso, 'Il', 'Elle') + " fait " + tr.texte;
            if (tr.reussite) {
              sendChar(charId, m + "&ge; 8, son \xE9tat s'am\xE9liore nettement." + tr.modifiers, true);
              setState(perso, 'blesse', false, evt);
            } else {
              let msgRate = m + "< 8, son \xE9tat reste pr\xE9occupant." + tr.rerolls + tr.modifiers;
              sendChar(charId, msgRate, true);
            }
            finalize();
          });
          return;
        }
        let affAttr = rajouterPointDeRecuperation(perso, evt, pr);
        if (affAttr === undefined) {
          error("Pas de point de r\xE9cup\xE9rartion \xE0 rajouter et pourtant pas au max", token);
          finalize();
          return;
        }
        message =
          "Au cours de la nuit, les points de r\xE9cup\xE9ration de " + nomPerso(perso) +
          " passent de " + pr.current + " \xE0 " + (pr.current + 1);
        sendChar(charId, message, true);
        if (bar1 < pvmax) manquePV.push(perso);
        finalize();
        return;
      }
      if (!reposLong && pr) {
        if (pr.current === 0) { //pas possible de r\xE9cup\xE9rer
          message = " a besoin d'une nuit compl\xE8te pour r\xE9cup\xE9rer";
          sendPerso(perso, message);
          finalize();
          return;
        } else { //d\xE9pense d'un PR
          enleverPointDeRecuperation(perso, pr, evt);
          pr.current--;
        }
      }
      let conMod = modCarac(perso, 'constitution');
      let niveau = ficheAttributeAsInt(perso, 'niveau', 1);
      let characterName = character.get("name");
      let rollExpr = addOrigin(characterName, "[[1d" + dVie + "]]");
      sendChat("COF", rollExpr, function(res) {
        let rollRecupID = "rollRecup_" + perso.token.id;
        options.rolls = options.rolls || {};
        let roll =
          options.rolls[rollRecupID] ? options.rolls[rollRecupID] : res[0].inlinerolls[0];
        evt.action = evt.action || {};
        evt.action.rolls = evt.action.rolls || {};
        evt.action.rolls[rollRecupID] = roll;
        let dVieRoll = roll.results.total;
        let bonus = conMod + niveau;
        let total = dVieRoll + bonus;
        if (total < 0) total = 0;
        if (bar1 === 0) {
          if (attributeAsBool(perso, 'etatExsangue')) {
            removeTokenAttr(perso, 'etatExsangue', evt, {
              msg: "retrouve des couleurs"
            });
          }
        }
        bar1 += total;
        if (bar1 < pvmax) manquePV.push(perso);
        else bar1 = pvmax;
        updateCurrentBar(perso, 1, bar1, evt);
        if (reposLong) {
          message = "Au cours de la nuit, ";
        } else {
          message = "Apr\xE8s 5 minutes de repos, ";
        }
        message += "r\xE9cup\xE8re " + buildinline(roll) + "+" + bonus + " PV.";
        if (pr) message += " Il lui reste " + pr.current + " points de r\xE9cup\xE9ration";
        sendPerso(perso, message);
        finalize();
      });
    });
  }

  function recharger(msg) {
    let cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("La fonction !cof-recharger attend au moins un argument", msg);
      return;
    }
    let attackLabel = cmd[1];
    let evt = {
      type: 'recharger',
      attributes: []
    };
    let grenaille = false;
    if (msg.content.includes(' --grenaille')) grenaille = true;
    let options = {};
    if (msg.content.includes(' --son')) {
      options = parseOptions(msg);
      options = options || {};
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined) {
        sendPlayer(msg, "!cof-recharger sans s\xE9lection de tokens", playerId);
        log("!cof-recharger requiert des tokens s\xE9lectionn\xE9s");
        return;
      }
      iterSelected(selected, function(perso) {
        let arme = getWeaponStats(perso, attackLabel);
        if (arme === undefined) {
          error("Arme " + attackLabel + " n'existe pas pour " + nomPerso(perso), perso);
          return;
        }
        let maxCharge = arme.charge;
        let currentCharge = 0;
        let attrs =
          findObjs({
            _type: 'attribute',
            _characterid: perso.charId,
            name: "charge_" + attackLabel
          });
        if (attrs.length < 1) {
          attrs = createObj('attribute', {
            characterid: perso.charId,
            name: 'charge_' + attackLabel,
            current: 0
          });
        } else {
          attrs = attrs[0];
          currentCharge = parseInt(attrs.get('current'));
          if (isNaN(currentCharge)) {
            error("charge mal form\xE9e", attrs);
            currentCharge = 0;
          }
        }
        let attrGrenaille =
          findObjs({
            _type: 'attribute',
            _characterid: perso.charId,
            name: "chargeGrenaille_" + attackLabel
          });
        let currentChargeGrenaille;
        if (currentCharge < maxCharge) {
          if (grenaille) {
            if (attrGrenaille.length < 1) {
              attrGrenaille = createObj('attribute', {
                characterid: perso.charId,
                name: 'chargeGrenaille_' + attackLabel,
                current: 0
              });
            } else attrGrenaille = attrGrenaille[0];
            currentChargeGrenaille = parseInt(attrGrenaille.get('current'));
            if (isNaN(currentChargeGrenaille)) {
              error("charge de grenaille mal form\xE9e", attrGrenaille);
              return;
            }
            if (currentChargeGrenaille > currentCharge) currentChargeGrenaille = currentCharge;
            evt.attributes.push({
              attribute: attrGrenaille,
              current: currentChargeGrenaille
            });
            attrGrenaille.set('current', currentChargeGrenaille + 1);
          }
          evt.attributes.push({
            attribute: attrs,
            current: currentCharge
          });
          attrs.set('current', currentCharge + 1);
          updateNextInit(perso);
          if (options.son) playSound(options.son);
          if (grenaille)
            sendPerso(perso, "charge " + arme.name + " de grenaille.");
          else
            sendPerso(perso, "recharge " + arme.name);
          return;
        } else {
          if (grenaille) { //On peut vouloir changer des charges normales en grenaille
            if (attrGrenaille.length < 1) {
              attrGrenaille = createObj('attribute', {
                characterid: perso.charId,
                name: 'chargeGrenaille_' + attackLabel,
                current: 0
              });
            } else attrGrenaille = attrGrenaille[0];
            currentChargeGrenaille = parseInt(attrGrenaille.get('current'));
            if (isNaN(currentChargeGrenaille)) {
              error("charge de grenaille mal form\xE9e", attrGrenaille);
              return;
            }
            if (currentChargeGrenaille < currentCharge) {
              evt.attributes.push({
                attribute: attrGrenaille,
                current: currentChargeGrenaille
              });
              attrGrenaille.set('current', currentChargeGrenaille + 1);
              sendPerso(perso, "remplace une charge de " + arme.name + " par de la grenaille.");
              return;
            }
          } else if (attrGrenaille.length > 0) {
            attrGrenaille = attrGrenaille[0];
            currentChargeGrenaille = parseInt(attrGrenaille.get('current'));
            if (isNaN(currentChargeGrenaille)) {
              error("charge de grenaille mal form\xE9e", attrGrenaille);
              return;
            }
            if (currentChargeGrenaille > 0) {
              evt.attributes.push({
                attribute: attrGrenaille,
                current: currentChargeGrenaille
              });
              attrGrenaille.set('current', currentChargeGrenaille - 1);
              sendPerso(perso, "remplace une charge de grenaille  de " + arme.name + " par une charge normale.");
              return;
            }
          }
        }
        if (maxCharge == 1) {
          sendPerso(perso, arme.name + " est d\xE9j\xE0 charg\xE9");
        } else {
          sendPerso(perso, "a d\xE9j\xE0 tous ses " + arme.name + " charg\xE9s");
        }
      });
    });
    addEvent(evt);
  }

  //!cof-bouton-chance [evt.id] [rollId]
  function boutonChance(msg) {
    let args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-bouton-chance n'a pas assez d'arguments", args);
      return;
    }
    let evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    let action = evt.action;
    if (!action) {
      error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
      return;
    }
    let perso = evt.personnage;
    let rollId;
    if (args.length > 2) {
      var roll = action.rolls[args[2]];
      if (roll === undefined) {
        error("Erreur interne du bouton de chance : roll non identifi\xE9", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de chance : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[2];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de chance : l'\xE9venement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let chance = pointsDeChance(perso);
    if (chance <= 0) {
      sendPerso(perso, "n'a plus de point de chance \xE0 d\xE9penser...");
      return;
    }
    let evtChance = {
      type: 'chance',
      rollId: rollId
    };
    chance--;
    undoEvent(evt);
    setFicheAttr(perso, 'pc', chance, evtChance, {
      msg: " a d\xE9pens\xE9 un point de chance. Il lui en reste " + chance
    });
    action.options = action.options || {};
    if (rollId) {
      action.options.chanceRollId = action.options.chanceRollId || {};
      action.options.chanceRollId[rollId] = (action.options.chanceRollId[rollId] + 10) || 10;
    } else {
      action.options.chance = (action.options.chance + 10) || 10;
    }
    if (!redoEvent(evt, action, perso))
      error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
    addEvent(evtChance);
  }

  //!cof-prouesse [evt.id] [rollId]
  function boutonProuesse(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-prouesse n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    var perso = evt.personnage;
    var rollId;
    if (args.length > 2) {
      if (!evt.action) {
        error("Le dernier \xE9v\xE8nement n'est pas une action", args);
        return;
      }
      var roll = evt.action.rolls[args[2]];
      if (roll === undefined) {
        error("Erreur interne du bouton de chance : roll non identifi\xE9", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de prouesse : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[2];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de prouesse : l'\xE9venement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let testProuesse = testLimiteUtilisationsCapa(perso, 'prouesse', 'tour', "ne peut plus utiliser sa prouesse");
    if (testProuesse === undefined) {
      return;
    }
    var action = evt.action;
    if (action) { //alors on peut faire le undo
      var options = evt.action.options || {};
      options.rolls = action.rolls || {};
      undoEvent(evt);
      var d4 = rollDePlus(4);
      var r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      var evtProuesse = {
        type: 'prouesse',
        rollId: rollId,
        action: {
          rolls: {
            "prouesseDmg": d4
          }
        }
      };
      addEvent(evtProuesse);
      let explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtProuesse, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendPerso(perso, "r\xE9alise une prouesse et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendPerso(perso, expl);
          });
        });
      utiliseCapacite(perso, testProuesse, evt);
      if (rollId) {
        options.chanceRollId = options.chanceRollId || {};
        options.chanceRollId[rollId] = (options.chanceRollId[rollId] + 5) || 5;
      } else {
        options.chance = (options.chance + 10) || 10;
      }
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
  }

  //!cof-pacte-sanglant [evt.id] [3|5] [rollId]
  function boutonPacteSanglant(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("La fonction !cof-pacte-sanglant n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    var bonus = parseInt(args[2]);
    if (isNaN(bonus)) {
      error("Il manque un choix de bonus au Pacte sanglant", args);
      return;
    }
    var perso = evt.personnage;
    var rollId;
    if (args.length > 3) {
      if (!evt.action) {
        error("Le dernier \xE9v\xE8nement n'est pas une action", args);
        return;
      }
      var roll = evt.action.rolls[args[3]];
      if (roll === undefined) {
        error("Erreur interne du bouton de pacte sanglant : roll non identifi\xE9", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de pacte sanglant : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[3];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de pacte sanglant : l'\xE9venement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let valPacteSanglant = predicateAsInt(perso, 'pacteSanglant', 0);
    if (valPacteSanglant < bonus) {
      sendPerso(perso, "ne peut pas faire \xE7a !");
      return;
    }
    let action = evt.action;
    if (action) { //alors on peut faire le undo
      let options = action.options || {};
      undoEvent(evt);
      let d4 = (bonus < 5) ? rollDePlus(4) : rollDePlus(4, {
        nbDes: 2
      });
      let r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      let evtPacteSanglant = {
        type: 'pacteSanglant',
        rollId: rollId,
        action: {
          rolls: {
            "pacteSanglantDmg": d4
          }
        }
      };
      addEvent(evtPacteSanglant);
      let explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtPacteSanglant, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendPerso(perso, "r\xE9alise un Pacte sanglant et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendPerso(perso, expl);
          });
        });
      if (rollId) {
        options.chanceRollId = options.chanceRollId || {};
        options.chanceRollId[rollId] = (options.chanceRollId[rollId] + bonus) || bonus;
      } else {
        options.chance = (options.chance + bonus) || bonus;
      }
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
  }

  //!cof-pacte-sanglant [evt.id] [3|5] [targetId]
  function boutonPacteSanglantDef(msg) {
    const args = msg.content.split(' ');
    if (args.length < 4) {
      error("La fonction !cof-pacte-sanglant-def n'a pas assez d'arguments", args);
      return;
    }
    let evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    if (!evt.action) {
      error("Le dernier \xE9v\xE8nement n'est pas une action", args);
      return;
    }
    let bonus = parseInt(args[2]);
    if (isNaN(bonus)) {
      error("Il manque un choix de bonus au Pacte sanglant", args);
      return;
    }
    let perso = persoOfId([args[3]]);
    if (perso === undefined) {
      error("Erreur interne du bouton de pacte sanglant (DEF) : pas de cible trouv\xE9e", args);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let valPacteSanglant = predicateAsInt(perso, 'pacteSanglant', 0);
    if (valPacteSanglant < bonus) {
      sendPerso(perso, "ne peut pas faire \xE7a !");
      return;
    }
    let action = evt.action;
    if (action) { //alors on peut faire le undo
      let options = action.options || {};
      undoEvent(evt);
      let d4 = (bonus < 5) ? rollDePlus(4) : rollDePlus(4, {
        nbDes: 2
      });
      let r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      let evtPacteSanglant = {
        type: 'pacteSanglantDEF',
        action: {
          rolls: {
            "pacteSanglantDmg": d4
          }
        }
      };
      addEvent(evtPacteSanglant);
      let explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtPacteSanglant, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendPerso(perso, "r\xE9alise un Pacte sanglant et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendPerso(perso, expl);
          });
        });
      options.pacteSanglantDef = options.pacteSanglantDef || {};
      options.pacteSanglantDef[perso.token.id] = (options.pacteSanglantDef[perso.token.id] + bonus) || bonus;
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
  }

  //!cof-tour-force [evt.id] [rollId]
  function boutonTourDeForce(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-tour-force n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    var perso = evt.personnage;
    var rollId;
    if (args.length > 2) {
      if (!evt.action) {
        error("Le dernier \xE9v\xE8nement n'est pas une action", args);
        return;
      }
      var roll = evt.action.rolls[args[2]];
      if (roll === undefined) {
        error("Erreur interne du bouton de tour de force : roll non identifi\xE9", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de tour de force : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[2];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de tour de force : l'\xE9venement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var attrTourDeForce = predicateAsBool(perso, 'tourDeForce');
    if (!attrTourDeForce) {
      sendPerso(perso, "ne peut pas faire \xE7a !");
      return;
    }
    var action = evt.action;
    if (action) { //alors on peut faire le undo
      var options = action.options || {};
      undoEvent(evt);
      var d4 = rollDePlus(4);
      var r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      var evtTourDeForce = {
        type: 'tourDeForce',
        rollId: rollId,
        action: {
          rolls: {
            "tourDeForceDmg": d4
          }
        }
      };
      addEvent(evtTourDeForce);
      let explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtTourDeForce, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendPerso(perso, "r\xE9alise un Tour de force et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendPerso(perso, expl);
          });
        });
      if (rollId) {
        options.chanceRollId = options.chanceRollId || {};
        options.chanceRollId[rollId] = (options.chanceRollId[rollId] + 10) || 10;
      } else {
        options.chance = (options.chance + 10) || 10;
      }
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'\xE9v\xE8nement pas encore g\xE9r\xE9 pour la chance", evt);
  }

  //Renvoie true si redo possible, false sinon
  function redoEvent(evt, action, perso) {
    let options = action.options || {};
    options.rolls = action.rolls;
    options.choices = action.choices;
    switch (evt.type) {
      case 'Attaque':
        options.redo = true;
        if (action.cibles) {
          action.cibles.forEach(function(target) {
            delete target.partialSaveAuto;
            delete target.dmRate;
          });
        }
        attack(action.playerName, action.playerId, action.attaquant, action.cibles, action.weaponStats, options);
        return true;
      case 'attaqueMagique':
        attaqueMagiqueOpposee(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'armeSecrete':
        doArmeSecrete(action.perso, action.cible, options);
        return true;
      case 'boireAlcool':
        doBoireAlcool(action.playerId, action.persos, options);
        return true;
      case 'dmgDirects':
        dmgDirects(action.playerId, action.playerName, action.cibles, action.dmg, options);
        return true;
      case 'degainer':
        doDegainer(action.persos, action.armeLabel, options);
        return true;
      case 'destructionMortsVivants':
        doDestructionDesMortsVivants(action.lanceur, action.playerName, action.dm, options);
        return true;
      case 'echapperEtreinte':
      case 'echapperEnveloppement':
        doEchapperEnveloppement(action.perso, action.etreinte, action.cube, action.difficulte, options);
        return true;
      case 'effetTemp':
        effetTemporaire(action.playerId, action.cibles, action.effet, action.mEffet, action.duree, options);
        return true;
      case 'Effet':
        effetIndetermine(action.playerId, action.cibles, action.effet, action.activer, action.valeur, options);
        return true;
      case 'auraDrainDeForce':
        if (!action.cibles) return;
        action.cibles.forEach(function(perso) {
          delete perso.messages;
        });
        doAuraDrainDeForce(action.playerId, action.origine, action.cibles, action.mEffet, options);
        return true;
      case 'enduireDePoison':
        doEnduireDePoison(action.perso, action.armeEnduite, action.savePoison, action.forcePoison, action.attribut,
          action.testINT, action.infosAdditionelles, options);
        return true;
      case 'enveloppement':
      case '\xE9treinte':
        doEnveloppement(action.attaquant, action.cible, action.difficulte, action.type, action.exprDM, options);
        return true;
      case 'injonction':
        injonction(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'injonctionMortelle':
        injonctionMortelle(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'jetPerso':
        jetPerso(perso, action.caracteristique, action.difficulte, action.titre, action.playerId, options);
        return true;
      case 'libererAgrippe':
        doLibererAgrippe(action.perso, action.agrippant, action.attrName, options);
        return true;
      case 'libererEcrase':
        doLibererEcrase(action.perso, action.agrippant, action.titre, action.carac, action.difficulte, action.explications, options);
        return true;
      case 'natureNourriciere':
        doNatureNourriciere(action.perso, options);
        return true;
      case 'nextTurn':
        let turnOrder = Campaign().get('turnorder');
        if (turnOrder === '') return false; // nothing in the turn order
        turnOrder = JSON.parse(turnOrder);
        if (turnOrder.length < 1) return false; // Juste le compteur de tour
        let lastTurn = turnOrder.shift();
        turnOrder.push(lastTurn);
        Campaign().set('turnorder', JSON.stringify(turnOrder));
        nextTurn(Campaign(), options);
        return true;
      case 'nouveauJour':
        doNouveauJour(action.persos, options);
        return true;
      case 'peur':
        doPeur(action.cibles, action.difficulte, options);
        return true;
      case 'provocation':
        doProvocation(action.voleur, action.cible, options);
        return true;
      case 'rage':
        doRageDuBerserk(action.persos, action.typeRage, options);
        return true;
      case 'recuperation':
        doRecuperation(action.persos, action.reposLong, action.playerId, options);
        return true;
      case 'save_state':
        doSaveState(action.playerId, action.perso, action.etat, action.carac, options, action.opposant, action.seuil);
        return true;
      case 'save_effet':
        doSaveEffet(action.playerId, action.perso, action.effetC, action.attr, action.attrEffet, action.attrName, action.met, action.carac, action.seuil, action.options);
        return true;
      case 'set_state':
        doSetState(action.cibles, action.etat, action.valeur, options);
        return true;
      case 'sommeil':
        doSommeil(action.lanceur, action.cibles, options, action.ciblesSansSave, action.ciblesAvecSave);
        return true;
      case 'surprise':
        doSurprise(action.cibles, action.testSurprise, action.selected, options);
        return true;
      case 'tourDeForce': //Deprecated
        doTourDeForce(action.perso, action.seuil, options);
        return true;
      case 'tueurFantasmagorique':
        tueurFantasmagorique(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'vapeursEthyliques':
        doVapeursEthyliques(action.playerId, action.persos, options);
        return true;
      case 'ombre_mouvante':
        doOmbreMouvante(action.perso, action.playerId, options);
        return true;
      case "Sentir la corruption":
        sentirLaCorruption(action.playerId, action.chasseur, action.cible, options);
        return true;
      default:
        return false;
    }
  }

  function echecTotal(msg) {
    let args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-bouton-echec-total n'a pas assez d'arguments", args);
      return;
    }
    let evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    let perso = evt.personnage;
    if (perso === undefined) {
      error("Erreur interne du bouton d'\xE9chec total: l'\xE9venement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let action = evt.action;
    if (!action || evt.type != "Attaque") {
      error("Erreur interne du bouton d'\xE9chec total: l'\xE9v\xE8nement n'est pas une attaque", evt);
      return;
    }
    let evtEchecTotal = {
      type: 'echecTotal'
    };
    addEvent(evtEchecTotal);
    // Attaquer avec les m\xEAmes options, vider redo et preDmg \xE9ventuels
    let options = action.options;
    options.auto = true;
    options.echecTotal = true;
    delete options.redo;
    delete options.preDmg;
    attack(action.playerName, action.playerId, perso, perso.token, action.weaponStats, options);
  }

  function persoUtiliseDeExpertDuCombat(perso, evt) {
    let rangExpertDuCombat = predicateAsInt(perso, 'expertDuCombat', 0);
    if (rangExpertDuCombat < 1) {
      sendPerso(perso, "n'est pas un expert du combat");
      return false;
    }
    let limiteParTour;
    if (rangExpertDuCombat > 4) limiteParTour = 3;
    else if (rangExpertDuCombat > 2) limiteParTour = 2;
    else limiteParTour = 1;
    if (limiteRessources(perso, {
        limiteParCombat: rangExpertDuCombat * 2,
        limiteParTour: limiteParTour
      }, "expertDuCombat", "a atteint sa limite de d\xE9 d'expert du combat", evt)) {
      addEvent(evt);
      return false;
    }
    sendPerso(perso, "utilise un d\xE9 d'expert du combat");
    return true;
  }

  //!cof-expert-combat
  //!cof-expert-combat-touche
  //!cof-expert-combat-dm
  function expertDuCombat(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser les d\xE9s d'expert du combat qu'en combat");
      return;
    }
    var cmd = msg.content.split(' ');
    var evtARefaire;
    var evt = {
      type: "D\xE9 d'expert du combat (touche)",
      attributes: []
    };
    if (cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[1]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
      var perso = evtARefaire.personnage;
      var action = evtARefaire.action;
      if (action === undefined) {
        error("Impossible de relancer l'action", evtARefaire);
        return;
      }
      if (perso === undefined) {
        error("Erreur interne du bouton expert de combat : l'\xE9venement n'a pas de personnage", evtARefaire);
        return;
      }
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "pas le droit d'utiliser ce bouton");
        return;
      }
      if (!persoUtiliseDeExpertDuCombat(perso, evt)) return;
      undoEvent(evtARefaire);
      addEvent(evt);
      action.options = action.options || {};
      if (cmd[0].includes("-touche"))
        action.options.expertDuCombatTouche = action.options.expertDuCombatTouche + 1 || 1;
      else if (cmd[0].includes("-dm"))
        action.options.expertDuCombatDM = action.options.expertDuCombatDM + 1 || 1;
      if (!redoEvent(evtARefaire, action, perso))
        error("Type d'\xE9v\xE8nement pas support\xE9 par le bouton Rune d'Energie", evt);
    } else { //Juste pour v\xE9rifier l'attribut et le diminuer
      getSelected(msg, function(selection) {
        if (selection.length === 0) {
          sendPlayer(msg, 'Pas de token s\xE9lectionn\xE9 pour !cof-bouton-expert-combat-touche');
          return;
        }
        iterSelected(selection, function(perso) {
          persoUtiliseDeExpertDuCombat(perso, evt);
        }); //fin iterSelected
        addEvent(evt);
      }); //fin getSelected
    }
  }

  //!cof-expert-combat-def [evt.id] [targetId]
  function expertDuCombatDEF(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("La fonction !cof-expert-combat-def n'a pas assez d'arguments", args);
      return;
    }
    var evtARefaire = findEvent(args[1]);
    if (evtARefaire === undefined) {
      error("L'action est trop ancienne ou \xE9te annul\xE9e", args);
      return;
    }
    var action = evtARefaire.action;
    if (action === undefined) {
      error("Le dernier \xE9v\xE8nement n'est pas une action", args);
      return;
    }
    var perso = persoOfId([args[2]]);
    if (perso === undefined) {
      error("Erreur interne du bouton d'expert du combat (DEF) : pas de cible trouv\xE9e", args);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var evt = {
      type: 'expertDuCombatDEF',
    };
    if (!persoUtiliseDeExpertDuCombat(perso, evt)) return;
    undoEvent(evtARefaire);
    addEvent(evt);
    action.options = action.options || {};
    action.options.expertDuCombatDEF = action.options.expertDuCombatDEF || {};
    action.options.expertDuCombatDEF[perso.token.id] = rollDePlus(6);
    removePreDmg(action.options, perso, 'expertDuCombatDEF');
    redoEvent(evtARefaire, action);
  }

  function persoUtiliseRuneEnergie(perso, evt) {
    var attr = tokenAttribute(perso, 'runeForgesort_\xE9nergie');
    if (attr.length < 1 || attr[0].get('current') < 1) {
      sendPerso(perso, "n'a pas de rune d'\xE9nergie");
      return false;
    }
    if (limiteRessources(perso, {
        limiteParCombat: 1
      }, "runeForgesort_\xE9nergie", "a d\xE9j\xE0 utilis\xE9 sa rune d'\xE9nergie durant ce combat", evt)) {
      addEvent(evt);
      return false;
    }
    sendPerso(perso, "utilise sa rune d'\xE9nergie pour relancer un d20 sur un test d'attaque, de FOR, DEX ou CON");
    return true;
  }

  //!cof-bouton-rune-energie
  function runeEnergie(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser les runes d'\xE9nergie qu'en combat");
      return;
    }
    let cmd = msg.content.split(' ');
    let evtARefaire;
    const evt = {
      type: "Rune d'\xE9nergie",
      attributes: []
    };
    if (cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[1]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
      let perso = evtARefaire.personnage;
      let action = evtARefaire.action;
      if (action === undefined) {
        error("Impossible de relancer l'action", evtARefaire);
        return;
      }
      let rollId;
      if (cmd.length > 2) {
        let roll = action.rolls[cmd[2]];
        if (roll === undefined) {
          error("Erreur interne du bouton de chance : roll non identifi\xE9", cmd);
          return;
        }
        if (roll.token === undefined) {
          error("Erreur interne du bouton de chance : roll sans token", cmd);
          return;
        }
        perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
        rollId = cmd[2];
        evt.rollId = rollId;
      }
      if (perso === undefined) {
        error("Erreur interne du bouton de rune d'\xE9nergie : l'\xE9venement n'a pas de personnage", evtARefaire);
        return;
      }
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "pas le droit d'utiliser ce bouton");
        return;
      }
      let carac = action.caracteristque;
      if (carac == 'SAG' || carac == 'INT' || carac == 'CHA') {
        sendPerso(perso, "ne peut pas utiliser la rune d'\xE9nergie pour un test " + deCarac(carac));
        return;
      }
      if (!persoUtiliseRuneEnergie(perso, evt)) return;
      undoEvent(evtARefaire);
      addEvent(evt);
      if (rollId) delete action.rolls[rollId];
      else if (action.rolls && action.rolls.attack) delete action.rolls.attack;
      if (!redoEvent(evtARefaire, action, perso))
        error("Type d'\xE9v\xE8nement pas support\xE9 par le bouton Rune d'Energie", evt);
    } else { //Juste pour v\xE9rifier l'attribut et le diminuer
      getSelected(msg, function(selection) {
        if (selection.length === 0) {
          sendPlayer(msg, 'Pas de token s\xE9lectionn\xE9 pour !cof-rune-energie');
          return;
        }
        iterSelected(selection, function(perso) {
          persoUtiliseRuneEnergie(perso, evt);
        }); //fin iterSelected
        addEvent(evt);
      }); //fin getSelected
    }
  }

  function persoUtiliseRunePuissance(perso, labelArme, evt, permanent) {
    var attrName = permanent ? 'runeDePuissance' + labelArme : "runeForgesort_puissance(" + labelArme + ")";
    var arme = getAttackName(labelArme, perso);
    if (arme === undefined) {
      error(perso.tokNname + " n'a pas d'arme associ\xE9e au label " + labelArme, perso);
      return false;
    }
    if (!permanent && tokenAttribute(perso, attrName).length === 0) {
      sendPerso(perso, "n'a pas de rune de puissance sur " + arme);
      return false;
    }
    if (limiteRessources(perso, {
        limiteParCombat: 1
      }, attrName, "a d\xE9j\xE0 utilis\xE9 sa rune de puissance durant ce combat", evt)) {
      addEvent(evt);
      return false;
    }
    sendPerso(perso, "utilise sa rune de puissance pour obtenir les DM maximum de son arme");
    return true;
  }

  //!cof-rune-puissance label
  //!cof-bouton-rune-puissance label evt.id [permanent]
  function runePuissance(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser les runes de puissance qu'en combat");
      return;
    }
    let cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il faut sp\xE9cifier le label de l'arme sur laquelle la rune de puissance est inscrite", cmd);
      return;
    }
    let labelArme = cmd[1];
    let evtARefaire;
    let evt = {
      type: "Rune de puissance",
      attributes: []
    };
    if (cmd.length > 2) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[2]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
      let perso = evtARefaire.personnage;
      if (perso === undefined) {
        error("Erreur interne du bouton de rune de puissance : l'\xE9venement n'a pas de personnage", evtARefaire);
        return;
      }
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "pas le droit d'utiliser ce bouton");
        return;
      }
      let action = evtARefaire.action;
      if (action === undefined) {
        error("Impossible de relancer l'action", evtARefaire);
        return;
      }
      let permanent = (cmd.length > 3 && cmd[3] == 'permanent');
      if (!persoUtiliseRunePuissance(perso, labelArme, evt, permanent)) return;
      let options = action.options || {};
      options.redo = true;
      options.maxDmg = true;
      options.runeDePuissance = true;
      options.rolls = action.rolls;
      action.cibles.forEach(function(target) {
        delete target.rollsDmg;
      });
      delete options.preDmg.runeDePuissance;
      if (_.isEmpty(options.preDmg)) delete options.preDmg;
      addEvent(evt);
      switch (evtARefaire.type) {
        case 'Attaque':
          undoEvent(evtARefaire);
          attack(action.playerName, action.playerId, perso, action.cibles, action.weaponStats, options);
          return;
        default:
          return;
      }
    } else { //Juste pour v\xE9rifier l'attribut et le diminuer
      getSelected(msg, function(selection, playerId) {
        if (selection.length === 0) {
          sendPlayer(msg, 'Pas de token s\xE9lectionn\xE9 pour !cof-rune-puissance', playerId);
          return;
        }
        iterSelected(selection, function(perso) {
          persoUtiliseRunePuissance(perso, labelArme, evt);
        }); //fin iterSelected
        addEvent(evt);
      }); //fin getSelected
    }
  }

  //!cof-bouton-pousser-kiai evt.id
  function kiai(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut pousser un kiai qu'en combat");
      return;
    }
    let cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il manque l'id de l'attaque sur laquelle pousser le kiai", cmd);
      return;
    }
    let evtARefaire = findEvent(cmd[1]);
    if (evtARefaire === undefined) {
      error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
      return;
    }
    let perso = evtARefaire.personnage;
    if (perso === undefined) {
      error("Erreur interne du bouton de kiai : l'\xE9venement n'a pas de personnage", evtARefaire);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let action = evtARefaire.action;
    if (action === undefined) {
      error("Impossible de relancer l'action", evtARefaire);
      return;
    }
    let testKiai = testLimiteUtilisationsCapa(perso, 'kiai', 'combat', "ne peut plus pousser de kiai pendant ce combat", "ne sait pas pousser de kiai");
    if (testKiai === undefined) {
      return;
    }
    const evt = {
      type: "Kiai",
    };
    utiliseCapacite(perso, testKiai, evt);
    if (testKiai.utilisations > 1) {
      setAttrDuree(perso, 'rechargeDuKiai', randomInteger(6), evt);
    }
    let options = action.options || {};
    options.redo = true;
    options.maxDmg = true;
    options.kiai = true;
    options.rolls = action.rolls;
    action.cibles.forEach(function(target) {
      delete target.rollsDmg;
    });
    addEvent(evt);
    switch (evtARefaire.type) {
      case 'Attaque':
        undoEvent(evtARefaire);
        attack(action.playerName, action.playerId, perso, action.cibles, action.weaponStats, options);
        return;
      default:
        return;
    }
  }

  //Devrait \xEAtre appel\xE9 seulement depuis un bouton
  //!cof-esquive-fatale evtid target_id
  function doEsquiveFatale(msg) {
    var cmd = msg.content.split(' ');
    var evtARefaire;
    var evt = {
      type: "Esquive fatale",
      attributes: []
    };
    if (cmd.length < 3) {
      error("Il manque des arguments \xE0 !cof-esquive-fatale", cmd);
      return;
    }
    evtARefaire = findEvent(cmd[1]);
    if (evtARefaire === undefined) {
      error("L'attaque est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
      return;
    }
    var action = evtARefaire.action;
    if (action === undefined) {
      error("Impossible d'esquiver l'attaque", evtARefaire);
      return;
    }
    var perso = action.cibles[0];
    if (perso === undefined) {
      error("Erreur interne du bouton de 'esquive fatale : l'\xE9venement n'a pas de personnage", evtARefaire);
      return;
    }
    var adversaire = persoOfId(cmd[2]);
    if (adversaire === undefined) {
      sendPlayer(msg, "Il faut cibler un token valide");
      return;
    }
    var attaquant = action.attaquant;
    if (attaquant.token.id == adversaire.token.id) {
      sendPlayer(msg, "Il faut cibler un autre adversaire que l'attaquant");
      return;
    }
    if (distanceCombat(perso.token, adversaire.token) > 0) {
      sendPerso(perso, "doit choisir un adversaire au contact pour l'esquive fatale");
      return;
    }
    var ennemisAuContact = perso.ennemisAuContact;
    if (ennemisAuContact === undefined) {
      error("Ennemis au contact non d\xE9finis", perso);
    } else {
      var i = ennemisAuContact.find(function(tok) {
        return (tok.id == adversaire.token.id);
      });
      if (i === undefined) {
        sendPlayer(msg, "Il faut cibler un adversaire au contact pour l'esquive fatale");
        return;
      }
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let testEsquiveFatale = testLimiteUtilisationsCapa(perso, 'esquiveFatale', 'combat', "a d\xE9j\xE0 fait une esquive fatale durant ce combat", "ne sait pas faire d'esquive fatale");
    if (testEsquiveFatale === undefined) {
      return;
    }
    utiliseCapacite(perso, testEsquiveFatale, evt);
    //On va refaire compl\xE8tement l'attaque
    undoEvent(evtARefaire);
    addEvent(evt);
    adversaire.msgEsquiveFatale = nomPerso(perso) + " esquive l'attaque qui touche " + nomPerso(adversaire);
    action.cibles = action.cibles.filter(cible => cible.token.id !== perso.token.id);
    action.cibles.push(adversaire);
    removePreDmg(action.options, perso);
    redoEvent(evtARefaire, action);
  }

  //Soit juste !cof-intercepter (en s\xE9lectionnant le chevalier)
  //Soit depuis un bouton !cof-intercepter evtid cibleid
  function intercepter(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    let fromEvtId;
    if (cmd.length > 1) {
      fromEvtId = cmd[1]; //Appel depuis le bouton
      if (cmd.length < 3) {
        error("Bouton d'interception mal form\xE9", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(chevalier) {
        let character = getObj('character', chevalier.charId);
        if (character === undefined) {
          error("L'argument de !cof-intercepter n'est pas une id de token valide (personnage non d\xE9fini)", msg.content);
          return;
        }
        let test = testLimiteUtilisationsCapa(chevalier, 'intercepter', 'tour', "a d\xE9j\xE0 intercept\xE9 une attaque ce tour", "ne sait pas utiliser intercepter les attaques");
        if (test === undefined) {
          return;
        }
        let voieMeneur = predicateAsInt(chevalier, 'voieDuMeneurDHomme', 2);
        let attaque;
        let originalTarget;
        let evtARefaire;
        if (fromEvtId) { //On a utilis\xE9 un bouton
          if (!peutController(msg, chevalier)) {
            sendPlayer(msg, "pas le droit d'utiliser ce bouton");
            return;
          }
          evtARefaire = findEvent(fromEvtId);
          if (evtARefaire !== undefined) {
            attaque = evtARefaire.action;
          }
          if (attaque === undefined) {
            sendPlayer(msg, "Plus possible d'utiliser ce bouton");
            return;
          }
          attaque.cibles = attaque.cibles.filter(function(c) {
            if (originalTarget) return true;
            if (c.token.id != cmd[2]) return true;
            originalTarget = c;
            return false;
          });
          if (originalTarget === undefined) {
            if (attaque.cibles.length === 1) {
              originalTarget = attaque.cibles[0];
              attaque.cibles = [];
            } else {
              error("Impossible de retrouver la cible de l'attaque", attaque);
              return;
            }
          }
        } else {
          evtARefaire = lastEvent();
          if (evtARefaire !== undefined) {
            attaque = evtARefaire.action;
          }
          if (attaque === undefined) {
            sendPlayer(msg, "La derni\xE8re action trouv\xE9e n'est pas une attaque, impossible d'intercepter");
            return;
          }
          if (attaque.cibles.length === 0) {
            sendPlayer(msg, "la derni\xE8re attaque n'a touch\xE9 aucune cible, impossible d'intercepter");
            return;
          }
          if (attaque.cibles.length > 1) {
            sendPlayer(msg, "la derni\xE8re attaque a touch\xE9 plus d'une cible, impossible d'intercepter");
            return;
          }
          originalTarget = attaque.cibles[0];
          attaque.cibles = [];
          if (distanceCombat(chevalier.token, originalTarget.token) > 0) {
            sendPerso(chevalier, " est trop loin de " + nomPerso(originalTarget) + " pour intercepter l'attaque");
            return;
          }
        }
        let evt = {
          type: 'interception'
        };
        utiliseCapacite(chevalier, test, evt);
        attaque.cibles.push(chevalier);
        chevalier.rollDmg = chevalier.rollDmg;
        chevalier.intercepter = voieMeneur;
        let optionsRedo = attaque.options;
        optionsRedo.rolls = attaque.rolls;
        undoEvent(evtARefaire);
        addEvent(evt);
        removePreDmg(attaque.options, originalTarget);
        redoEvent(evtARefaire, attaque);
      });
    });
  }

  //simplement prendre les DM \xE0 la place d'un autre
  function interposer(msg) {
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(cible) {
        let charId = cible.charId;
        let character = getObj('character', charId);
        if (character === undefined) {
          error("L'argument de !cof-interposer n'est pas une id de token valide (personnage non d\xE9fini)", msg.content);
          return;
        }
        cible.name = character.get('name'); //TODO: utile ?
        if (attributeAsBool(cible, 'interposer')) {
          sendPerso(cible, " a d\xE9j\xE0 intercept\xE9 une attaque ce tour");
          return;
        }
        let attaque;
        var lastAct = lastEvent();
        if (lastAct !== undefined) {
          attaque = lastAct.action;
        }
        if (attaque === undefined) {
          sendPlayer(msg, "la derni\xE8re action trouv\xE9e n'est pas une attaque, impossible d'intercepter");
          return;
        }
        if (attaque.cibles.length === 0) {
          sendPlayer(msg, "la derni\xE8re attaque n'a touch\xE9 aucune cible, impossible de s'interposer");
          return;
        }
        if (attaque.cibles.length > 1) {
          sendPlayer(msg, "la derni\xE8re attaque a touch\xE9 plus d'une cible, impossible de s'interposer en utilisant le script");
          return;
        }
        let target = attaque.cibles[0];
        if (target === undefined) {
          error("Le token de la derni\xE8re attaque est ind\xE9fini", attaque);
          return;
        }
        let targetName = nomPerso(target);
        if (distanceCombat(cible.token, target.token) > 0) {
          sendPerso(cible, " est trop loin de " + targetName + " pour s'interposer");
          return;
        }
        var evt = {
          type: 'interposer'
        };
        setTokenAttr(cible, 'interposer', true, evt, {
          msg: "se met devant " + targetName + " pour intercepter l'attaque !"
        });
        var pvApres = target.token.get('bar1_value');
        // On annule l'ancienne action
        undoEvent();
        // On calcule ensuite les pv perdus, et on les applique au d\xE9fenseur
        var pvPerdus = target.token.get('bar1_value') - pvApres;
        // Puis on refait en changeant la cible
        var options = attaque.options;
        options.interposer = pvPerdus;
        options.rolls = attaque.rolls;
        options.evt = evt;
        options.redo = true;
        cible.rollsDmg = target.rollsDmg;
        attack(attaque.playerName, attaque.playerId, attaque.attaquant, [cible], attaque.weaponStats, options);
      });
    });
  }

  function exemplaire(msg) {
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(cible) {
        if (attributeAsBool(cible, 'exemplaire')) {
          sendPerso(cible, " a d\xE9j\xE0 montr\xE9 l'exemple \xE0 ce tour");
          return;
        }
        let attaque;
        let lastAct = lastEvent();
        if (lastAct !== undefined) {
          if (lastAct.type == 'Attaque' && lastAct.succes === false) {
            attaque = lastAct.action;
          }
        }
        if (attaque === undefined) {
          sendPlayer(msg, "la derni\xE8re action trouv\xE9e n'est pas une attaque rat\xE9e, impossible de montrer l'exemple",
            playerId);
          return;
        }
        let attackerName = nomPerso(attaque.attaquant);
        if (attackerName === undefined) {
          error("Le token de la derni\xE8re attaque est ind\xE9fini", attaque);
          return;
        }
        const evt = {
          type: "Montrer l'exemple"
        };
        setTokenAttr(cible, 'exemplaire', true, evt, {
          msg: "montre l'exemple \xE0 " + attackerName
        });
        // On annule l'ancienne action
        undoEvent();
        // Puis on refait
        let options = attaque.options;
        options.evt = evt;
        options.redo = true;
        if (options.rolls && options.rolls.attack) delete options.rolls.attack;
        attack(attaque.playerName, attaque.playerId, attaque.attaquant, attaque.cibles, attaque.weaponStats, options);
      });
    });
  }

  function interventionDivine(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser intervention divine qu'en combat");
      return;
    }
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 2 || (cmd[1] != "rate" && cmd[1] != "touche")) {
      error("Il manque l'option rate ou touche \xE0 Intervention Divine", msg);
      return;
    }
    getSelected(msg, function(selected) {
      iterSelected(selected, function(pretre) {
        let testIntervention = testLimiteUtilisationsCapa(pretre, 'interventionDivine', 'combat', "a d\xE9j\xE0 fait une intervention divine ce combat", "ne sait pas faire d'intervention divine");
        if (testIntervention === undefined) {
          return;
        }
        let evtARefaire = lastEvent();
        let action = evtARefaire.action;
        if (action === undefined) {
          error("Impossible de relancer l'action", evtARefaire);
          return;
        }
        let optionsRedo = action.options || {};
        optionsRedo.redo = true;
        const evt = {
          type: "Intervention divine",
          attributes: []
        };
        if (limiteRessources(pretre, options, 'intervention divine', ' faire une intervention divine', evt)) return;
        utiliseCapacite(pretre, testIntervention, evt);
        addEvent(evt);
        if (evtARefaire.type != 'Attaque') {
          //TODO : Implementer triche sur jetPerso() et echapperEnveloppement()
          error("Intervention Divine ne supporte que les attaques", evtARefaire);
          return;
        }
        undoEvent(evtARefaire);
        if (action.cibles) {
          action.cibles.forEach(function(target) {
            delete target.partialSaveAuto;
            delete target.dmRate;
          });
        }
        optionsRedo.interventionDivine = cmd[1];
        attack(action.playerName, action.playerId, action.attaquant, action.cibles, action.weaponStats, optionsRedo);
        return;
      });
    });
  }

  //!cof-petit-veinard (avec un token s\xE9lectionn\xE9)
  //!cof-bouton-petit-veinard evtid
  //sans argument, diminue juste l'attribut, sinon relance l'\xE9v\xE9nement
  function petitVeinard(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser petit veinard qu'en combat");
      return;
    }
    var msgOptions = parseOptions(msg);
    if (msgOptions === undefined) return;
    var cmd = msgOptions.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    var evtARefaire;
    var evt = {
      type: "Petit veinard",
      attributes: []
    };
    if (cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[1]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
      var perso = evtARefaire.personnage;
      var rollId;
      if (cmd.length > 2) {
        if (!evtARefaire.action) {
          error("Le dernier \xE9v\xE8nement n'est pas une action", msg.content);
          return;
        }
        var roll = evtARefaire.action.rolls[cmd[2]];
        if (roll === undefined) {
          error("Erreur interne du bouton de chance : roll non identifi\xE9", msg.content);
          return;
        }
        if (roll.token === undefined) {
          error("Erreur interne du bouton de chance : roll sans token", msg.content);
          return;
        }
        perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
        rollId = cmd[2];
      }
      if (perso === undefined) {
        error("Erreur interne du bouton petit veinard : l'\xE9venement n'a pas de personnage", evtARefaire);
        return;
      }
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "pas le droit d'utiliser ce bouton");
        return;
      }
      var action = evtARefaire.action;
      if (action === undefined) {
        error("Impossible de relancer l'action", evtARefaire);
        return;
      }
      let testPetitVeinard = testLimiteUtilisationsCapa(perso, 'petitVeinard', 'combat', "a d\xE9j\xE0 tent\xE9 sa chance pour ce combat", "n'est pas un petit veinard");
      if (testPetitVeinard === undefined) {
        return;
      }
      utiliseCapacite(perso, testPetitVeinard, evt);
      undoEvent(evtARefaire);
      addEvent(evt);
      if (rollId) delete action.rolls[rollId];
      else if (action.rolls && action.rolls.attack) delete action.rolls.attack;
      if (!redoEvent(evtARefaire, action, perso))
        error("Type d'\xE9v\xE8nement pas support\xE9 par le bouton Petit Veinard", evt);
    } else { //Juste pour v\xE9rifier l'attribut et le diminuer
      getSelected(msg, function(selection, playerId) {
        if (selection.length === 0) {
          sendPlayer(msg, 'Pas de token s\xE9lectionn\xE9 pour !cof-petit-veinard', playerId);
          return;
        }
        iterSelected(selection, function(perso) {
          let testPetitVeinard = testLimiteUtilisationsCapa(perso, 'petitVeinard', 'combat', "a d\xE9j\xE0 tent\xE9 sa chance pour ce combat", "n'est pas un petit veinard");
          if (testPetitVeinard === undefined) {
            return;
          }
          sendPerso(perso, "peut relancer un d\xE9");
          utiliseCapacite(perso, testPetitVeinard, evt);
        }); //fin iterSelected
        addEvent(evt);
      }); //fin getSelected
    }
  }

  function parseSurprise(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    var testSurprise;
    if (cmd.length > 1) {
      testSurprise = parseInt(cmd[1]);
      if (isNaN(testSurprise)) testSurprise = undefined;
    }
    var cibles = [];
    var ciblesSelectionnees;
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "!cof-surprise sans s\xE9lection de token", playerId);
        log("!cof-surprise requiert de s\xE9lectionner des tokens");
        return;
      }
      ciblesSelectionnees = selected;
      iterSelected(selected, function(perso) {
        if (!isActive(perso)) {
          return;
        }
        cibles.push(perso);
      });
    });
    if (cibles.length > 0) {
      doSurprise(cibles, testSurprise, ciblesSelectionnees, options);
    } else {
      error("Pas de cible valable s\xE9lectionn\xE9e pour la surprise", msg.content);
    }
  }

  function doSurprise(cibles, testSurprise, selected, options) {
    var evt = {
      type: 'surprise',
      action: {
        cibles: cibles,
        testSurprise: testSurprise,
        selected: selected,
        options: options
      }
    };
    addEvent(evt);
    initiative(selected, evt);
    let bonusAttrs = [];
    let bonusPreds = [];
    if (!options.nonVivant) bonusPreds.push('radarMental');
    let display;
    if (testSurprise === undefined) {
      display = startFramedDisplay(options.playerId, "<b>Surprise !</b>");
    } else {
      display = startFramedDisplay(options.playerId, "Test de surprise difficult\xE9 " + testSurprise);
    }
    let tokensToProcess = cibles.length;
    let sendEvent = function() {
      if (tokensToProcess == 1) {
        sendChat("", endFramedDisplay(display));
      }
      tokensToProcess--;
    };
    cibles.forEach(function(perso) {
      const name = nomPerso(perso);
      if (predicateAsBool(perso, 'immunite_surpris')) {
        addLineToFramedDisplay(display, name + " n'est pas surpris" + eForFemale(perso));
        sendEvent();
        return;
      }
      let bonusSurprise = 0;
      let bonusMessages = [];
      if (compagnonPresent(perso, 'surveillance')) {
        bonusSurprise += 5;
        setTokenAttr(perso, 'bonusInitEmbuscade', 5, evt);
        bonusMessages.push(name + " garde un temps d'avance gr\xE2ce \xE0 son compagnon animal : +5");
        initPerso(perso, evt, true);
      }
      if (attributeAsBool(perso, 'sixiemeSens')) {
        bonusSurprise += 5;
        bonusMessages.push(name + " a un sixi\xE8me sens : +5");
      }
      if (testSurprise !== undefined) {
        let testId = 'surprise_' + perso.token.id;
        let optionsTest = {...options
        };
        optionsTest.bonus = bonusSurprise;
        optionsTest.bonusAttrs = bonusAttrs;
        optionsTest.bonusPreds = bonusPreds;
        optionsTest.competence = 'vigilance';
        testCaracteristique(perso, 'SAG', testSurprise, testId, optionsTest, evt,
          function(tr, explications) {
            let result;
            if (tr.reussite) result = "r\xE9ussi." + tr.modifiers;
            else {
              result = "rat\xE9, " + name + " est surpris";
              result += eForFemale(perso);
              result += tr.rerolls + tr.modifiers;
              setState(perso, 'surpris', true, evt);
            }
            let message = name + " fait " + tr.texte + " : " + result;
            addLineToFramedDisplay(display, message);
            explications.forEach(function(m) {
              addLineToFramedDisplay(display, m, 80);
            });
            bonusMessages.forEach(function(m) {
              addLineToFramedDisplay(display, m, 80);
            });
            sendEvent();
          });
      } else { //no test
        setState(perso, 'surpris', true, evt);
        addLineToFramedDisplay(display, name + " est surpris." + eForFemale(perso));
        sendEvent();
      }
    });
  }

  function interchangeable(attackingToken, target, pageId) { //d\xE9termine si il y a assez de tokens
    let token = target.token;
    let res = {
      result: false,
      targets: []
    };
    if (!isActive(target)) return res;
    let limite = predicateAsInt(target, 'interchangeable', 0);
    if (limite < 1) return res;
    let tokens = findObjs({
      _type: 'graphic',
      _subtype: 'token',
      represents: target.charId,
      _pageid: pageId
    });
    tokens = tokens.filter(function(tok) {
      return isActive({
        token: tok
      });
    });
    res.result = (tokens.length > limite);
    // Now select the tokens which could be valid targets
    var p = distanceCombat(attackingToken, token);
    if (p === 0) { //cible au contact, on garde toutes celles au contact
      res.targets = tokens.filter(function(tok) {
        var d = distanceCombat(attackingToken, tok);
        return (d === 0);
      });
    } else { // cible \xE0 distance, on garde celles au contact de la cible
      res.targets = tokens.filter(function(tok) {
        var d = distanceCombat(token, tok);
        return (d === 0);
      });
    }
    return res;
  }

  let alliesParPerso = {};
  let listeCompetences = {
    FOR: {
      list: [],
      elts: new Set()
    },
    DEX: {
      list: [],
      elts: new Set()
    },
    CON: {
      list: [],
      elts: new Set()
    },
    SAG: {
      list: [],
      elts: new Set()
    },
    INT: {
      list: [],
      elts: new Set()
    },
    CHA: {
      list: [],
      elts: new Set()
    },
    nombre: 0
  };
  // Appel\xE9 uniquement apr\xE8s le "ready" et lorsqu'on modifie un handout (fonctionne apr\xE8s l'ajout et la destruction d'un handout)
  // Du coup, alliesParPerso est toujours \xE0 jour
  function changeHandout(hand, prev) {
    if (prev && prev.name && prev.name.startsWith("Equipe ")) {
      const handouts = findObjs({
        _type: 'handout'
      });
      alliesParPerso = {};
      handouts.forEach(parseHandout);
    } else if (hand) {
      parseHandout(hand);
    }
  }

  //pour se d\xE9barasser des balises html
  // et avoir un tableau de lignes
  function linesOfNote(note) {
    note = note.trim();
    if (note.startsWith('<p>')) note = note.substring(3);
    note = note.trim().replace(/<span[^>]*>|<\/span>/g, '');
    note = note.replace(/<p>/g, '<br>');
    note = note.replace(/<\/p>/g, '');
    return note.trim().split('<br>');
  }

  function charactersInHandout(note, nomEquipe) {
    let names = linesOfNote(note);
    let persos = new Set();
    let characters = findObjs({
      _type: 'character',
    });
    names.forEach(function(name) {
      name = name.replace(/<(?:.|\s)*?>/g, ''); //Pour enlever les <h2>, etc
      name = name.trim();
      if (name.length === 0) return;
      let charsWithName = characters.filter(function(c) {
        return c.get('name').trim() == name;
      });
      if (charsWithName.length === 0) {
        log(name + " dans l'\xE9quipe " + nomEquipe + " est inconnu");
        return;
      }
      if (charsWithName.length > 1) {
        let nonArch = charsWithName.filter(function(c) {
          return !(c.get('archived'));
        });
        if (nonArch.length > 0) charsWithName = nonArch;
        if (charsWithName.length > 1) {
          log(name + " dans l'\xE9quipe " + nomEquipe + " est en double");
        }
      }
      charsWithName.forEach(function(character) {
        persos.add(character.id);
      });
    });
    return persos;
  }

  function parseHandout(hand) {
    const handName = hand.get('name').trim();
    if (handName.startsWith("Equipe ")) {
      hand.get('notes', function(note) { // asynchronous
        const persos = charactersInHandout(note, handName);
        persos.forEach(function(charId) {
          let ancien = alliesParPerso[charId];
          if (ancien === undefined) {
            ancien = new Set();
            alliesParPerso[charId] = ancien;
          }
          persos.forEach(function(aci) {
            if (aci == charId) return;
            ancien.add(aci);
          });
          //On ajoute les familiers
        });
      }); //end hand.get('notes')
    } else if (handName == 'Comp\xE9tences' || handName == 'Competences') {
      listeCompetences = {
        FOR: {
          list: [],
          elts: new Set()
        },
        DEX: {
          list: [],
          elts: new Set()
        },
        CON: {
          list: [],
          elts: new Set()
        },
        SAG: {
          list: [],
          elts: new Set()
        },
        INT: {
          list: [],
          elts: new Set()
        },
        CHA: {
          list: [],
          elts: new Set()
        },
        nombre: 0
      };
      hand.get('notes', function(note) { // asynchronous
        var carac; //La carac dont on sp\xE9cifie les comp\xE9tences actuellement
        var lignes = linesOfNote(note);
        lignes.forEach(function(ligne) {
          ligne = ligne.trim();
          var header = ligne.split(':');
          if (header.length > 1) {
            var c = header.shift().trim().toUpperCase();
            if (!isCarac(c)) return;
            carac = c;
            ligne = header.join(':').trim();
          }
          if (ligne.length === 0) return;
          if (carac === undefined) {
            error("Comp\xE9tences sans caract\xE9ristique associ\xE9e", note);
            return;
          }
          var comps = ligne.split(/, |\/| /);
          comps.forEach(function(comp) {
            if (comp.length === 0) return;
            comp = comp.replace(/_/g, ' ');
            listeCompetences[carac].list.push(comp);
            listeCompetences.nombre++;
            listeCompetences[carac].elts.add(comp.toLowerCase());
          });
        });
      }); //end hand.get(notes)
    }
  }

  function estAllieJoueur(perso) {
    if (estControlleParJoueur(perso.charId)) return true;
    let allies = alliesParPerso[perso.charId];
    if (allies === undefined) return false;
    let res = false;
    allies.forEach(function(p) {
      res = res || estControlleParJoueur(p);
    });
    return res;
  }

  function estArme(attaque) {
    let t = fieldAsString(attaque, 'armetypeattaque', 'Naturel');
    if (t.startsWith('Arme')) {
      return t != 'Arme de jet';
    }
    return false;
  }

  //options peut contenir:
  // - ligneOptions : une cha\xEEne de caract\xE8res \xE0 ajouter aux attaques
  // - target : l'id de la cible des attaques
  // - nePasAfficherArmes : quand on affiche plus tard l'arme en main
  function listeAttaquesVisibles(perso, options) {
    options = options || {};
    let ligneOptions = options.ligneOptions || '';
    let target = options.target || '@{target|token_id}';
    let ligne = '';
    //Cherche toutes les attaques \xE0 afficher
    let attaques = listAllAttacks(perso);
    let attaquesTriees = [];
    let attaquesNonTriees = {};
    for (let attLabel in attaques) {
      let att = attaques[attLabel];
      if (fieldAsInt(att, 'armeactionvisible', 1) === 0) continue;
      if (options.nePasAfficherArmes && estArme(att)) continue;
      //V\xE9rification que des options n'emp\xEAchent pas l'utilisation de l'attaque
      let attackOptions = ' ' + fieldAsString(att, 'armeoptions', '');
      if (actionImpossible(perso, attackOptions.split(' --'), attLabel)) continue;
      //On regarde aussi si c'est une arme de jet
      if (att.armetypeattaque == 'Arme de jet' && fieldAsInt(att, 'armejetqte', 1) === 0) continue;
      let command = "!cof-attack @{selected|token_id} " + target + " " + attLabel + " " + ligneOptions;
      let index = +attLabel;
      if (isNaN(index) || parseInt(index) != index || index < 0)
        attaquesNonTriees[attLabel] = bouton(command, att.armenom, perso);
      else
        attaquesTriees[attLabel] = bouton(command, att.armenom, perso);
    }
    attaquesTriees.forEach(function(b) {
      if (b === undefined) return;
      ligne += b + '<br />';
    });
    for (let label in attaquesNonTriees) {
      ligne += attaquesNonTriees[label] + '<br />';
    }
    //On ajoute aussi les lancers de feu gr\xE9geois, si il y en a
    let attrFeuxGregeois = tokenAttribute(perso, 'elixir_feu_gr\xE9geois');
    if (attrFeuxGregeois.length > 0) {
      attrFeuxGregeois = attrFeuxGregeois[0];
      let feuxGregeois = parseInt(attrFeuxGregeois.get('current'));
      if (feuxGregeois > 0) {
        let command = attrFeuxGregeois.get('max').trim();
        ligne += bouton(command, 'Feu gr\xE9geois', perso, {
          ressource: attrFeuxGregeois
        });
        ligne += " (reste " + feuxGregeois + ")<br />";
      }
    }
    return ligne;
  }

  function argsAttaqueAMainsNues(perso) {
    let bonusAtk = computeArmeAtk(perso, '@{ATKCAC}');
    return "Mains nues --toucher " + bonusAtk + " --dm 1d4 + [[@{selected|FOR}]] --tempDmg";
  }

  function listeDesArmes(perso) {
    const listeAttaques = listAllAttacks(perso);
    let attaqueNaturelleNonVisible;
    let armes = {};
    let armeVisible = 0;
    let possedeAttaqueNaturelle;
    for (let label in listeAttaques) {
      const arme = listeAttaques[label];
      const t = fieldAsString(arme, 'armetypeattaque', 'Naturel');
      if (fieldAsInt(arme, 'armeactionvisible', 1) === 1) {
        let options = ' ' + fieldAsString(arme, 'armeoptions', '');
        if (actionImpossible(perso, options.split(' --'), label)) continue;
        switch (t) {
          case 'Naturel':
            possedeAttaqueNaturelle = true;
            break;
          case 'Arme 1 main':
          case 'Arme 2 mains':
          case 'Arme gauche':
            armes[label] = arme;
            armeVisible = true;
            break;
        }
      } else if (!attaqueNaturelleNonVisible && t == 'Naturel') {
        attaqueNaturelleNonVisible = arme;
      }
    }
    return {
      listeAttaques,
      armes,
      armeVisible,
      possedeAttaqueNaturelle,
      attaqueNaturelleNonVisible
    };
  }
  //retourne soit une ability, soit un nombre entre 1 et 4, soit undefined si
  // la liste n'existe pas
  function findListeActions(perso, listActions, abilities) {
    if (listActions == ficheAttribute(perso, 'nomlisteaction1', 'Liste 1')) return 1;
    if (listActions == ficheAttribute(perso, 'nomlisteaction2', 'Liste 2')) return 2;
    if (listActions == ficheAttribute(perso, 'nomlisteaction3', 'Liste 3')) return 3;
    if (listActions == ficheAttribute(perso, 'nomlisteaction4', 'Liste 4')) return 4;
    let fullListActions = '#' + listActions + '#';
    let res = abilities.find(function(a) {
      return a.get('name') == fullListActions;
    });
    return res;
  }

  //Si listActions est fourni, \xE7a peut faire r\xE9f\xE9rence \xE0 une ability
  //dont le nom commence et termine par #, contenant une liste d'actions
  //\xE0 afficher
  //sinon, fait r\xE9f\xE9rence \xE0 une des listes d'action de la fiche
  function turnAction(perso, playerId, listActions) {
    const pageId = perso.token.get('pageid');
    // Toutes les Abilities du personnage li\xE9 au Token
    const abilities = findObjs({
      _type: 'ability',
      _characterid: perso.charId,
    });
    let title = 'Actions possibles :';
    if (stateCOF.chargeFantastique) title = "Charge fantastique: action d'attaque";
    let opt_display = {
      chuchote: true
    };
    let actionsDuTour;
    let actionsParDefaut;
    if (listActions) {
      title = listActions;
      actionsDuTour = findListeActions(perso, listActions, abilities);
      if (actionsDuTour === undefined) {
        return;
      }
    } else {
      afficherOptionsAttaque(perso, opt_display);
      actionsDuTour = 0;
      actionsParDefaut = true;
    }
    let formeDarbre = false;
    if (actionsDuTour === 0) {
      if (!isActive(perso)) {
        if (!getState(perso, 'surpris') || !compagnonPresent(perso, 'surveillance')) {
          sendPerso(perso, "ne peut pas agir \xE0 ce tour");
          return true;
        }
      }
      formeDarbre = attributeAsBool(perso, 'formeDArbre');
      if (formeDarbre) {
        actionsDuTour = findListeActions(perso, "Forme d'arbre", abilities);
        if (actionsDuTour === undefined) actionsDuTour = findListeActions(perso, 'FormeArbre', abilities);
        if (actionsDuTour) {
          actionsParDefaut = true;
        } else {
          actionsDuTour = 0;
          formeDarbre = false;
        }
      }
    }
    //actionDuTour peut \xEAtre undefined, pour la liste par d\xE9faut
    let actionsAAfficher;
    let ligne = '';
    let command = '';
    if (actionsParDefaut && !stateCOF.chargeFantastique && attributeAsBool(perso, 'hate')) {
      ligne += "Effet de h\xE2te : une action d'attaque ou de mouvement en plus <br />";
    }
    if (actionsParDefaut && !stateCOF.chargeFantastique && attributeAsBool(perso, 'reactionViolente')) {
      ligne += "Crise de folie : doit attaquer la personne qui l'a provoqu\xE9 et ceux qui l'en emp\xEAchent.<br />";
      ligne += boutonSimple('!cof-fin-reaction-violente ' + perso.token.id, "Prendre sur soi");
    }
    //Les d\xE9g\xE2ts aux personnages envelopp\xE9s par perso
    let attrs_enveloppe = tokenAttribute(perso, 'enveloppe');
    attrs_enveloppe.forEach(function(a) {
      let cible = persoOfIdName(a.get('current'), pageId);
      if (cible === undefined) {
        error("Attribut d'enveloppe mal form\xE9 ou obsol\xE8te", a.get('current'));
        return;
      }
      let enveloppeDM = a.get('max');
      if (enveloppeDM.startsWith('ability ')) {
        enveloppeDM = enveloppeDM.substring(8);
        let abEnveloppe = abilities.find(function(abilitie) {
          return (abilitie.get('name') === enveloppeDM);
        });
        if (abEnveloppe) {
          command = abEnveloppe.get('action').trim();
          command = replaceAction(command, perso);
          command = command.replace(new RegExp(escapeRegExp('@{target|token_id}'), 'g'), cible.token.id);
          ligne += bouton(command, "Infliger DMS \xE0 " + nomPerso(cible), perso) + '<br />';
        }
      } else if (enveloppeDM.startsWith('label ')) {
        actionsAAfficher = true;
        command = '!cof-attack ' + perso.token.id + ' ' + cible.token.id + ' ' + enveloppeDM.substring(6) + ' --auto --acide --effet paralyseTemp [[2d6]] --save CON 15';
        ligne += bouton(command, "Infliger DMs \xE0 " + nomPerso(cible), perso) + '<br />';
      } else if (enveloppeDM.startsWith('etreinte ')) {
        actionsAAfficher = true;
        enveloppeDM = enveloppeDM.substring(9);
        command = '!cof-attack ' + perso.token.id + ' ' + cible.token.id + ' --dm ' + enveloppeDM + ' --auto --nom \xE9treinte ';
        ligne += bouton(command, "Infliger DMs \xE0 " + nomPerso(cible), perso) + '<br />';
      } //else pas reconnu
      //On ajoute aussi un bouton pour lib\xE9rer
      command = '!cof-echapper-enveloppement libere --target ' + cible.token.id;
      ligne += boutonSimple(command, "Lib\xE9rer " + nomPerso(cible)) + '<br />';
    });
    let gobePar;
    let attrGobePar = tokenAttribute(perso, 'estGobePar');
    if (attrGobePar.length > 0) {
      gobePar = persoOfIdName(attrGobePar[0].get('current', pageId));
      command = '!cof-jet FOR 15 --target ' + perso.token.id;
      ligne += boutonSimple(command, "Jet de force") + "pour pouvoir attaquer avec une dague <br />";
      toFront(gobePar.token);
    }
    if (!gobePar && attributeAsBool(perso, 'enveloppePar')) {
      actionsAAfficher = true;
      command = '!cof-echapper-enveloppement --target ' + perso.token.id;
      ligne += boutonSimple(command, 'Se lib\xE9rer') + '<br />';
    } else if (getState(perso, 'enseveli')) {
      actionsAAfficher = true;
      ligne += boutonSaveState(perso, 'enseveli') + '<br />';
    } else if (!gobePar && attributeAsBool(perso, 'etreinteScorpionPar')) {
      actionsAAfficher = true;
      command = '!cof-liberer-agrippe ' + perso.token.id;
      ligne += boutonSimple(command, 'Se lib\xE9rer') + "de l'\xE9treinte du scorpion <br />";
    } else if (!gobePar && attributeAsBool(perso, 'estEcrasePar')) {
      actionsAAfficher = true;
      command = '!cof-liberer-ecrase ' + perso.token.id;
      ligne += boutonSimple(command, 'Se lib\xE9rer') + "de l'\xE9treinte<br />";
    } else { //On affiche les actions normales
      if (stateCOF.combat && stateCOF.combat.armeesDesMorts && !gobePar) {
        let combattreArmee = false;
        for (let aid in stateCOF.combat.armeesDesMorts) {
          if (aid == perso.token.id) continue;
          let persoArmee = stateCOF.combat.armeesDesMorts[aid];
          if (!persoArmee || !persoArmee.token) {
            error("Erreur dans l'arm\xE9e des morts", stateCOF.combat.armeesDesMorts);
            delete stateCOF.combat.armeesDesMorts[aid];
            continue;
          }
          let boost = 0;
          if (charAttributeAsBool(persoArmee, "armeeDesMortsPuissant")) boost = 1;
          else boost = charAttributeAsInt(persoArmee, "armeeDesMortsTempeteDeManaIntense", 0);
          let rayon = Math.floor(20 * Math.sqrt(1 + boost));
          if (distanceCombat(perso.token, persoArmee.token, pageId) <= rayon &&
            (!alliesParPerso[persoArmee.charId] || !alliesParPerso[persoArmee.charId].has(perso.charId))) {
            actionsAAfficher = true;
            combattreArmee = true;
          }
        }
        if (combattreArmee) {
          command = '!cof-defense-armee-des-morts ' + perso.token.id;
          ligne += bouton(command, 'Combattre les Morts-Vivants', perso) + '<br />';
        }
      }
      if (!gobePar && (attributeAsBool(perso, 'estAgrippePar') || attributeAsBool(perso, 'estDevorePar'))) {
        actionsAAfficher = true;
        command = '!cof-liberer-agrippe ' + perso.token.id;
        ligne += bouton(command, 'Se lib\xE9rer', perso) + '(action de mvt)<br />';
      }
      if (!gobePar && attributeAsBool(perso, 'etreinteImmolePar')) {
        actionsAAfficher = true;
        command = '!cof-liberer-agrippe ' + perso.token.id;
        ligne += bouton(command, 'Se lib\xE9rer', perso) + ' (action limit\xE9e)<br />';
      }
      //Actions pour les saves actifs
      let attrs = findObjs({
        _type: 'attribute',
        _characterid: perso.charId,
      });
      const estMook = perso.token.get('bar1_link') === '';
      let suffixe = '';
      if (estMook) suffixe = '_' + perso.token.get('name');
      attrs.forEach(function(attr) {
        let attrName = attr.get('name');
        if (estMook && !attrName.endsWith(suffixe)) return;
        let indexSave = attrName.indexOf('SaveActifParTour');
        if (indexSave < 0) return;
        let effetC = attrName.substring(0, indexSave);
        let effetTemp = estEffetTemp(effetC);
        if (!effetTemp && !estEffetCombat(effetC)) return;
        attrName = effetC + attrName.substr(indexSave + 11);
        let met;
        if (effetTemp) met = messageOfEffetTemp(effetC);
        else met = messageEffetCombat[effetC];
        let msgPour;
        if (met.msgSave) msgPour = met.msgSave;
        else {
          msgPour += "save contre ";
          if (effetC.startsWith('dotGen('))
            msgPour += effetC.substring(7, effetC.indexOf(')'));
          else msgPour += effetC;
        }
        ligne += boutonSimple("!cof-save-effet " + perso.token.id + " " + attr.id, msgPour) + '<br/>';
      });
      let ecraser = predicateAsBool(perso, 'ecraser');
      if (ecraser) {
        let attrEcrase = tokenAttribute(perso, 'ecrase');
        attrEcrase.forEach(function(a) {
          let cible = persoOfIdName(a.get('current'));
          if (cible) {
            let commande = "!cof-attack " + perso.token.id + ' ' + cible.token.id + ' ' + ecraser;
            ligne += boutonSimple(commande, '\xC9craser') + ' ' + nomPerso(cible) + '<br/>';
          } else {
            a.remove();
          }
        });
      }
      if (formeDarbre) {
        actionsAAfficher = true;
        command = '!cof-attack @{selected|token_id} ';
        if (gobePar) command += gobePar.token.id;
        else command += '@{target|token_id}';
        command += ' ["Branches",["@{selected|niveau}",0],20,[1,6,3,0],0]';
        ligne += bouton(command, 'Attaque', perso) + '<br />';
      }
      //On cherche si il y a une arm\xE9e conjur\xE9e \xE0 attaquer
      let attrs_armee =
        findObjs({
          _type: 'attribute',
          name: 'armeeConjuree',
        });
      if (attrs_armee.length > 0) {
        let allTokens =
          findObjs({
            _type: "graphic",
            _pageid: pageId,
            _subtype: "token",
            layer: "objects"
          });
        let scale = computeScale(pageId);
        let px = perso.token.get('left');
        let py = perso.token.get('top');
        let pxp = px + 10 * PIX_PER_UNIT / scale;
        let pxm = px - 10 * PIX_PER_UNIT / scale;
        let pyp = py + 10 * PIX_PER_UNIT / scale;
        let pym = py - 10 * PIX_PER_UNIT / scale;
        let ps = tokenSize(perso.token, 0);
        pxp += ps;
        pxm -= ps;
        pyp += ps;
        pym -= ps;
        attrs_armee.forEach(function(aa) {
          let aacid = aa.get('characterid');
          if (aacid == perso.charId) return;
          let invocId = aa.get('current');
          if (invocId == perso.charId) return;
          let allies = alliesParPerso[invocId] || new Set();
          if (allies.has(perso.charId)) return;
          allTokens.forEach(function(t) {
            if (t.get('represents') == aacid) {
              //teste si dans un carr\xE9 de 20 m de cot\xE9 autour de l'arm\xE9e.
              let tx = t.get('left');
              let ty = t.get('top');
              if (tx < pxp && tx > pxm && ty < pyp && ty > pym) {
                command = '!cof-attack ' + perso.token.id + ' ' + t.id +
                  " Attaque de l'arm\xE9e --dm " +
                  (ficheAttributeAsInt(perso, 'niveau', 1) + 1) +
                  " --auto --attaqueArmeeConjuree --allonge 20";
                ligne += bouton(command, "Attaque de l'arm\xE9e", perso) + '<br />';
              }
            }
          });
        });
      }
      //Les soins pour les \xE9l\xE9mentaires
      if (predicateAsBool(perso, 'corpsElementaire')) {
        command = '!cof-soin 5';
        ligne += bouton(command, "R\xE9g\xE9n\xE9ration", perso) + " si source \xE9l\xE9mentaire proche<br />";
      }
      //Violence cibl\xE9e
      if (predicateAsBool(perso, 'violenceCiblee') && !attributeAsBool(perso, 'reactionViolente')) {
        let pointsDeViolence = attributeAsInt(perso, 'pointsDeViolence', 0);
        if (pointsDeViolence > 0) {
          let attr = tokenAttribute(perso, 'pointsDeViolence')[0];
          command = "!cof-effet-temp reactionViolente [[1d4]] --decrAttribute " + attr.id + " --target " + perso.token.id;
          ligne += boutonSimple(command, 'Violence cibl\xE9e') + '<br />';
        }
      }
      //Les attaques de la fiche \xE0 afficher dans la liste d'actions
      const montrerAttaques = ficheAttributeAsInt(perso, 'montrerattaques', 1);
      const afficherAttaquesFiche =
        actionsParDefaut ||
        (actionsDuTour === 0 && montrerAttaques);
      const montrerArmeEnMain = (actionsDuTour === 0 && ficheAttributeAsInt(perso, 'montrerarmeenmain', 1));
      if (afficherAttaquesFiche) {
        let attackOptions = {};
        if (gobePar) attackOptions.target = gobePar.token.id;
        if (montrerArmeEnMain) attackOptions.nePasAfficherArmes = true;
        ligne += listeAttaquesVisibles(perso, attackOptions);
      }
      //L'arme en main et d\xE9gainer, si besoin
      if (montrerArmeEnMain) {
        let {
          listeAttaques,
          armes,
          armeVisible,
          possedeAttaqueNaturelle,
          attaqueNaturelleNonVisible
        } = listeDesArmes(perso);
        let labelArmePrincipale;
        let labelArmeGauche;
        let ligneArmePrincipale;
        let ligneArmeGauche;
        let armePrincipale = armesEnMain(perso);
        if (armePrincipale) {
          labelArmePrincipale = armePrincipale.label;
          if (perso.armeGauche)
            labelArmeGauche = perso.armeGauche.label;
        }
        if ((labelArmeGauche === undefined || labelArmeGauche === '') &&
          predicateAsBool(perso, 'attaqueAuBouclier') && ficheAttributeAsInt(perso, 'defbouclieron', 0)) {
          labelArmeGauche = predicateAsBool(perso, 'attaqueAuBouclier');
        }
        let command = '!cof-attack ' + perso.token.id + ' @{target|token_id} ';
        if (armePrincipale) {
          let nomCommande = armePrincipale.name;
          if (armePrincipale.batarde) {
            if (armePrincipale.deuxMains) nomCommande += ' (2M)';
            else nomCommande += ' (1M)';
          }
          if (attributeAsBool(perso, 'paradeCroisee')) {
            //On conna\xEEtra vraiment l'arme au moment de faire l'attaque
            command += '-1';
            if (labelArmeGauche &&
              listeAttaques[labelArmeGauche]) {
              nomCommande += ' ou ' + listeAttaques[labelArmeGauche].armenom;
              labelArmeGauche = undefined; //Pour ne pas l'afficher
            }
          } else {
            command += labelArmePrincipale;
          }
          ligneArmePrincipale = bouton(command, nomCommande, perso);
        } else if (!possedeAttaqueNaturelle) {
          if (attaqueNaturelleNonVisible) {
            ligneArmePrincipale =
              bouton(command + attaqueNaturelleNonVisible.armelabel, attaqueNaturelleNonVisible.armenom, perso);
          } else {
            ligneArmePrincipale = bouton(command + argsAttaqueAMainsNues(perso), 'Mains nues', perso);
          }
        }
        if (perso.armeGauche) {
          ligneArmeGauche = bouton("!cof-attack @{selected|token_id} @{target|token_id} " + labelArmeGauche, perso.armeGauche.name, perso);
        }
        //Maintenant on propose de d\xE9gainer
        if (armeVisible) {
          let degainer = "!cof-degainer ?{Arme?|";
          let armeADegainer;
          //Prise en compte des pr\xE9dicats pour ce qu'on veut voir en premier
          let i = 1;
          let labelsVus = new Set();
          while (true) {
            let labels = predicateAsBool(perso, 'actionDegainer' + i);
            i++;
            if (!labels) break;
            let mid = labels.indexOf('-');
            if (mid > 0) {
              let label = labels.substring(0, mid);
              let labelGauche = labels.substring(mid + 1);
              if (label == labelArmePrincipale || labelGauche == labelArmeGauche) continue;
              let arme = armes[label];
              if (arme === undefined) {
                error("Impossible de trouver l'arme de label " + label + " mentionn\xE9e dans le pr\xE9dicat actionDegainer" + (i - 1), armes);
                continue;
              }
              let armeGauche = armes[labelGauche];
              if (armeGauche === undefined) {
                error("Impossible de trouver l'arme de label " + labelGauche + " mentionn\xE9e dans le pr\xE9dicat actionDegainer" + (i - 1), armes);
                continue;
              }
              degainer += arme.armenom + " et " + armeGauche.armenom + "," + label + ' ' + labelGauche + "|";
              if (armeADegainer) armeADegainer.unique = undefined;
              else armeADegainer = {
                unique: true,
                nom: arme.armenom + " et " + armeGauche.armenom,
                label: label + ' ' + labelGauche
              };
            } else {
              if (labels == labelArmePrincipale || labels == labelArmeGauche) continue;
              let arme = armes[labels];
              if (arme === undefined) {
                error("Impossible de trouver l'arme de label " + labels + " mentionn\xE9e dans le pr\xE9dicat actionDegainer" + (i - 1), armes);
                continue;
              }
              labelsVus.add(labels);
              degainer += arme.armenom + "," + labels + "|";
              if (armeADegainer) armeADegainer.unique = undefined;
              else armeADegainer = {
                unique: true,
                nom: arme.armenom,
                label: labels
              };
            }
          }
          for (let l in armes) {
            if (l == labelArmePrincipale && armePrincipale.batarde) {
              degainer += armes[l].armenom + ' ';
              if (armePrincipale.deuxMains) {
                degainer += "(1M)," + l + "|";
              } else {
                degainer += "(2M)," + l + " 2mains|";
              }
              if (armeADegainer) armeADegainer.unique = undefined;
              else armeADegainer = {
                unique: true,
                nom: armes[l].armenom,
                label: l
              };
            } else if (l != labelArmePrincipale && l != labelArmeGauche && !labelsVus.has(l)) {
              degainer += armes[l].armenom + "," + l + "|";
              if (armeADegainer) armeADegainer.unique = undefined;
              else armeADegainer = {
                unique: true,
                nom: armes[l].armenom,
                label: l
              };
            }
          }
          // Pictos : https://wiki.roll20.net/CSS_Wizardry#Pictos
          if (armeADegainer) {
            if (labelArmePrincipale || labelArmeGauche) {
              degainer += "Rengainer ";
              if (labelArmePrincipale && labelArmeGauche)
                degainer += "ses armes";
              else degainer += "son arme";
              degainer += ",&amp;#32;}";
            } else if (armeADegainer.unique) {
              //Dans ce cas, pas de choix, juste une arme \xE0 d\xE9gainer
              degainer = '!cof-degainer ' + armeADegainer.label;
            } else {
              degainer = degainer.substr(0, degainer.length - 1) + '}';
            }
            degainer += ' --montreActions';
            if (ligneArmePrincipale)
              ligneArmePrincipale += bouton(degainer, '<span style="font-family:Pictos">;</span>', perso);
            else
              ligneArmePrincipale = bouton(degainer, 'D\xE9gainer', perso);
            if (armeADegainer.unique && !labelArmePrincipale && !labelArmeGauche)
              ligneArmePrincipale += armeADegainer.nom;
          } else {
            ligneArmePrincipale += bouton('!cof-degainer --montreActions', '<span style="font-family:Pictos">}</span>', perso);
          }
        }
        if (ligneArmePrincipale) ligne += ligneArmePrincipale + '<br />';
        if (ligneArmeGauche) ligne += ligneArmeGauche + '<br />';
      }
      //L'action de traverser pour un cyclone
      if (attributeAsBool(perso, 'cyclone')) {
        let labelCyclone = getValeurOfEffet(perso, 'cyclone', 1);
        let diffRenverse = 10 + modCarac(perso, 'force');
        let commandTraverser = "!cof-attack @{selected|token_id} @{target|token_id} " + labelCyclone + " --auto --ifSaveFails DEXFOR " + diffRenverse + " --etat renverse --else --diviseDmg 2 --endif";
        ligne += bouton(commandTraverser, 'Traverser', perso) + '<br />';
      }
      //Affichage du second souffle
      if (actionsParDefaut && predicateAsBool(perso, 'secondSouffle') &&
        !attributeAsBool(perso, 'secondSouffleUtilise')) {
        let pvDebut = attributeAsInt(perso, 'PVsDebutCombat', 0);
        let pv = parseInt(perso.token.get('bar1_value'));
        if (!isNaN(pv) && pv < pvDebut) {
          command = "!cof-soin @{selected|token_id} secondSouffle";
          ligne += bouton(command, 'Second souffle', perso) + '<br/>';
        }
      }
      //Changement de phase pour intangibilit\xE9 avec changement de phase
      if (attributeAsBool(perso, 'intangiblePuissant')) {
        if (attributeAsInt(perso, 'intangibleValeur', 1)) {
          command = "!cof-set-attribute intangibleValeur 0 --target " + perso.token.id + " --message redevient tangible";
          ligne += boutonSimple(command, "Redevenir tangible") + '<br/>';
        } else {
          command = "!cof-set-attribute intangibleValeur 1 --target " + perso.token.id + " --message devient l\xE9g\xE8rement translucide";
          ligne += boutonSimple(command, "Redevenir intangible") + '<br/>';
        }
      }
      if (attributeAsBool(perso, 'intangibleInvisiblePuissant')) {
        if (attributeAsInt(perso, 'intangibleInvisibleValeur', 1)) {
          command = "!cof-set-attribute intangibleInvisibleValeur 0 --etat invisible false --target " + perso.token.id + " --message r\xE9appara\xEEt";
          ligne += boutonSimple(command, "Redevenir tangible") + '<br/>';
        } else {
          command = "!cof-set-attribute intangibleInvisibleValeur 1 --etat invisible true --target " + perso.token.id + " --message dispara\xEEt";
          ligne += boutonSimple(command, "Redevenir intangible") + '<br/>';
        }
      }
      //La liste d'action proprement dite
      actionsAAfficher = treatActions(perso, actionsDuTour, abilities, function(command, text, macros, attackStats) {
        if (command == 'liste des attaques') {
          let attackOptions = {};
          if (gobePar) attackOptions.target = gobePar.token.id;
          ligne += listeAttaquesVisibles(perso, attackOptions);
        } else {
          let options = {
            attackStats
          };
          let b = bouton(command, text, perso, options);
          if (!options.actionImpossible) ligne += b + '<br />';
        }
      });
      if (actionsParDefaut) {
        actionsAAfficher = true;
        command = "!cof-attendre ?{Nouvelle initiative}";
        ligne += bouton(command, 'Attendre', perso) + '<br />';
        if (!gobePar && !charAttributeAsBool(perso, 'armeeConjuree')) {
          command = "!cof-action-defensive ?{Action d\xE9fensive|simple|totale}";
          ligne += bouton(command, 'Se d\xE9fendre', perso) + '<br />';
          let manoeuvreDuelliste = predicateAsBool(perso, 'manoeuvreDuelliste');
          if (manoeuvreDuelliste) {
            command = "!cof-manoeuvre @{selected|token_id} @{target|token_id} ?{Manoeuvre?|bloquer|desarmer|renverser|tenirADistance|repousser}";
            ligne += bouton(command, 'Manoeuvres de duelliste', perso) + '<br />';
          }
          if (stateCOF.options.affichage.val.manoeuvres.val) {
            if (manoeuvreDuelliste) {
              command = "!cof-manoeuvre @{selected|token_id} @{target|token_id} ?{Manoeuvre?|aveugler|faireDiversion|menacer}";
              ligne += bouton(command, 'Autres manoeuvres', perso) + '<br />';
            } else {
              command = "!cof-manoeuvre @{selected|token_id} @{target|token_id} ?{Manoeuvre?|aveugler|bloquer|desarmer|faireDiversion|menacer|renverser|tenirADistance|repousser}";
              ligne += bouton(command, 'Manoeuvres', perso) + '<br />';
            }
          }
        }
      }
      for (let etat in cof_states) {
        let saveEtat = boutonSaveState(perso, etat);
        if (saveEtat) {
          ligne += saveEtat + '<br />';
          actionsAAfficher = true;
        }
      }
    }
    if (actionsAAfficher) {
      // on envoie la liste aux joueurs qui g\xE8rent le personnage dont le token est li\xE9
      let lastPlayerid;
      // on r\xE9cup\xE8re les players_ids qui controllent le Token
      let playerIds;
      if (playerId) playerIds = [playerId];
      else playerIds = getPlayerIds(perso);
      playerIds.forEach(function(playerid) {
        lastPlayerid = playerid;
        let display = startFramedDisplay(playerid, title, perso, opt_display);
        addLineToFramedDisplay(display, ligne);
        sendChat('', endFramedDisplay(display));
      });
      // En prime, on l'envoie au MJ, si besoin
      let envoieAuMJ = playerIds.length === 0;
      if (!envoieAuMJ && stateCOF.options.affichage.val.MJ_voit_actions.val) {
        envoieAuMJ = playerIds.every(function(pid) {
          return !playerIsGM(pid);
        });
      }
      if (envoieAuMJ) {
        opt_display.chuchote = 'gm';
        var display = startFramedDisplay(lastPlayerid, title, perso, opt_display);
        addLineToFramedDisplay(display, ligne);
        sendChat('', endFramedDisplay(display));
      }
    }
    return actionsAAfficher;
  }

  function apiTurnAction(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) return;
    let liste;
    if (cmd.length > 1) {
      liste = cmd.slice(1).join(' ');
    }
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        let actions = turnAction(perso, playerId, liste);
        if (!actions) {
          let l = liste || '';
          sendPerso(perso, "n'a pas de liste d'actions " + l + " d\xE9finie");
        }
      });
    });
  }

  function removeDernieresCiblesAttaquees(perso, evt) {
    let attrDernieresCibles = tokenAttribute(perso, 'dernieresCiblesAttaquees');
    if (attrDernieresCibles.length > 0) {
      attrDernieresCibles = attrDernieresCibles[0];
      if (predicateAsBool(perso, 'attaqueEnMeute')) {
        let dernieresCibles = attrDernieresCibles.get('current');
        let cibles = new Set(dernieresCibles.split(' '));
        cibles.forEach(function(ci) {
          let cible = persoOfId(ci);
          if (cible === undefined) return;
          let attrCibleMeute = tokenAttribute(cible, 'attaqueParMeute');
          if (attrCibleMeute.length > 0) {
            attrCibleMeute = attrCibleMeute[0];
            let cibleMeute = attrCibleMeute.get('current');
            let ensembleCibleMeute = new Set(cibleMeute.split(' '));
            if (ensembleCibleMeute.has(perso.token.id)) {
              ensembleCibleMeute.delete(perso.token.id);
              if (ensembleCibleMeute.size > 0) {
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: attrCibleMeute,
                  current: cibleMeute,
                });
                cibleMeute = '';
                ensembleCibleMeute.forEach(function(ai) {
                  if (cibleMeute === '') cibleMeute = ai;
                  else cibleMeute += ' ' + ai;
                });
                attrCibleMeute.set('current', cibleMeute);
              } else {
                evt.deletedAttributes = evt.deletedAttributes || [];
                evt.deletedAttributes.push(attrCibleMeute);
                attrCibleMeute.remove();
              }
            }
          }
        });
      }
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attrDernieresCibles);
      attrDernieresCibles.remove();
    }
  }

  function getTurnOrder(combat, evt) {
    let turnOrder = Campaign().get('turnorder');
    evt.turnorder = evt.turnorder || turnOrder;
    if (turnOrder === '') {
      turnOrder = [{
        id: "-1",
        pr: 1,
        custom: "Tour",
        formula: "+1"
      }];
      if (!evt.combat) evt.combat = {...combat
      };
      combat.tour = 1;
    } else {
      turnOrder = JSON.parse(turnOrder);
    }
    let indexTour = turnOrder.findIndex(function(elt) {
      return (elt.id == "-1" && elt.custom == "Tour");
    });
    if (indexTour == -1) {
      indexTour = turnOrder.length;
      turnOrder.push({
        id: "-1",
        pr: 1,
        custom: "Tour",
        formula: "+1"
      });
      if (!evt.combat) evt.combat = {...combat
      };
      combat.tour = 1;
    }
    let res = {
      tour: turnOrder[indexTour],
      pasAgi: turnOrder.slice(0, indexTour),
      dejaAgi: turnOrder.slice(indexTour + 1, turnOrder.length)
    };
    return res;
  }

  //ne rajoute pas evt \xE0 l'historique
  function setTurnOrder(to, evt) {
    if (to.pasAgi.length > 0) {
      to.pasAgi.sort(function(a, b) {
        if (a.id == "-1") return 1;
        if (b.id == "-1") return -1;
        if (a.pr < b.pr) return 1;
        if (b.pr < a.pr) return -1;
        // Priorit\xE9 aux joueurs
        // Premier crit\xE8re : la barre de PV des joueurs est li\xE9e
        let tokenA = getObj('graphic', a.id);
        if (tokenA === undefined) return 1;
        let tokenB = getObj('graphic', b.id);
        if (tokenB === undefined) return -1;
        if (tokenA.get('bar1_link') === '') {
          if (tokenB.get('bar1_link') === '') return 0;
          return 1;
        }
        if (tokenB.get('bar1_link') === '') return -1;
        // Deuxi\xE8me crit\xE8re : les joueurs ont un DV
        let charIdA = tokenA.get('represents');
        if (charIdA === '') return 1;
        let charIdB = tokenB.get('represents');
        if (charIdB === '') return -1;
        let persoA = {
          token: tokenA,
          charId: charIdA
        };
        let persoB = {
          token: tokenB,
          charId: charIdB
        };
        let dvA = ficheAttributeAsInt(persoA, "DV", 0);
        let dvB = ficheAttributeAsInt(persoB, "DV", 0);
        if (dvA === 0) {
          if (dvB === 0) return 0;
          return 1;
        }
        if (dvB === 0) return -1;
        //Entre joueurs, priorit\xE9 \xE0 la plus grosse sagesse
        let sagA = caracCourante(persoA, 'sagesse');
        let sagB = caracCourante(persoB, 'sagesse');
        if (sagA < sagB) return 1;
        if (sagA > sagB) return -1;
        return 0;
      });
      setActiveToken(stateCOF.combat, to.pasAgi[0].id, evt);
    }
    to.pasAgi.push(to.tour);
    let turnOrder = to.pasAgi.concat(to.dejaAgi);
    Campaign().set('turnorder', JSON.stringify(turnOrder));
  }

  function attendreInit(msg) {
    let combat = stateCOF.combat;
    if (!combat) {
      error("On ne peut pas attendre en dehors du combat", msg);
      return;
    }
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("La fonction !cof-attendre : rien \xE0 faire, pas de token selectionn\xE9", msg);
        return;
      }
      let cmd = msg.content.split(' ');
      if (cmd.length < 2) {
        error("Attendre jusqu'\xE0 quelle initiative ?", cmd);
        return;
      }
      let newInit = parseInt(cmd[1]);
      if (isNaN(newInit) || newInit < 1) {
        error("On ne peut attendre que jusqu'\xE0 une initiative de 1", cmd);
        newInit = 1;
      }
      let evt = {
        type: "attente"
      };
      let to = getTurnOrder(combat, evt);
      iterSelected(selected, function(perso) {
        let token = perso.token;
        if (!isActive(perso)) return;
        let tokenPos =
          to.pasAgi.findIndex(function(elt) {
            return (elt.id == token.id);
          });
        if (tokenPos == -1) { // token ne peut plus agir
          sendPerso(perso, " a d\xE9j\xE0 agit ce tour");
          return;
        }
        if (newInit < to.pasAgi[tokenPos].pr) {
          to.pasAgi[tokenPos].pr = newInit;
          sendPerso(perso, " attend un peu avant d'agir...");
          updateNextInit(perso);
        } else {
          sendPerso(perso, " a d\xE9j\xE0 une initiative inf\xE9rieure \xE0 " + newInit);
        }
      });
      setTurnOrder(to, evt);
      addEvent(evt);
    });
  }

  // Affiche des informations sur le personnage s\xE9lectionn\xE9
  function statut(msg) {
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Dans !cof-statut : rien \xE0 faire, pas de token selectionn\xE9", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        //Au cas o\xF9
        unlockToken(perso);
        const token = perso.token;
        const charId = perso.charId;
        const name = nomPerso(perso);
        let lie = true;
        if (token.get('bar1_link') === '') lie = false;
        const display = startFramedDisplay(playerId, "\xC9tat de " + name, perso, {
          chuchote: true
        });
        const estPNJ = persoEstPNJ(perso);
        let line;
        let hasMana = false;
        let manaAttr = [];
        if (!estPNJ)
          manaAttr = findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: 'PM'
          }, {
            caseInsensitive: true
          });
        if (manaAttr.length > 0) {
          let manaMax = parseInt(manaAttr[0].get('max'));
          hasMana = !isNaN(manaMax) && manaMax > 0;
        }
        let dmTemp = parseInt(token.get('bar2_value'));
        if (hasMana) { //ne peut pas \xEAtre un PNJ
          if (lie) {
            dmTemp = ficheAttributeAsInt(perso, 'DMTEMP', 0);
          } else {
            dmTemp = attributeAsInt(perso, 'DMTEMP', 0);
          }
        } else if (lie) {
          let nameAttrDMTEMP = 'DMTEMP';
          let versionFiche = parseFloat(ficheAttribute(perso, 'version', 0));
          if (isNaN(versionFiche)) versionFiche = 0;
          if (estPNJ && versionFiche < 3.7) nameAttrDMTEMP = 'pnj_dmtemp';
          dmTemp = ficheAttributeAsInt(perso, nameAttrDMTEMP, 0);
        }
        if (!isNaN(dmTemp) && dmTemp > 0) {
          line = "Dommages temporaires : " + dmTemp;
          addLineToFramedDisplay(display, line);
        }
        let douleurIgnoree = attributeAsInt(perso, 'douleurIgnoree', 0);
        if (douleurIgnoree > 0) {
          line = "a ignor\xE9 " + douleurIgnoree + " pv dans ce combat.";
          addLineToFramedDisplay(display, line);
        }
        let aDV = ficheAttributeAsInt(perso, 'DV', 0);
        if (aDV > 0) { // correspond aux PJs
          let pr = pointsDeRecuperation(perso);
          if (pr) {
            line =
              "Points de r\xE9cup\xE9ration : " + pr.current + " / " + pr.max;
            addLineToFramedDisplay(display, line);
          }
          if (ficheAttributeAsInt(perso, 'option_pc', 1)) {
            let pc = 3;
            let pc_max = 3;
            let attr_pc = charAttribute(perso.charId, 'pc', {
              caseInsensitive: true
            });
            if (attr_pc !== undefined && attr_pc.length > 0) {
              pc = parseInt(attr_pc[0].get('current'));
              if (isNaN(pc)) pc = 0;
              pc_max = parseInt(attr_pc[0].get('max'));
              if (isNaN(pc_max)) pc_max = 3;
            }
            line = "Points de chance : " + pc + " / " + pc_max;
            addLineToFramedDisplay(display, line);
          }
          if (predicateAsBool(perso, 'pacifisme')) {
            if (attributeAsBool(perso, 'attributDeCombat_pacifismeAnnule')) {
              addLineToFramedDisplay(display, "Pacifisme non actif");
            } else {
              addLineToFramedDisplay(display, "Pacifisme actif");
            }
          }
        }
        let attrsChar = findObjs({
          _type: 'attribute',
          _characterid: charId
        });
        let attaques = listAllAttacks(perso);
        let na = fullAttributeName(perso, 'armeEnMain');
        let armeEnMain =
          attrsChar.find(function(a) {
            return a.get('name') == na;
          });
        let armeEnMainGauche;
        if (armeEnMain) {
          armeEnMainGauche = armeEnMain.get('max');
          armeEnMain = armeEnMain.get('current');
        }
        _.forEach(attaques, function(att, armeLabel) {
          let nomArme = att.armenom;
          if (att.armespec && predicateOfRaw(att.armespec).charge) {
            let charge = attributeAsInt(perso, 'charge_' + armeLabel, 0);
            if (charge === 0) {
              line = nomArme + " n'est pas charg\xE9";
            } else {
              let na = fullAttributeName(perso, 'chargeGrenaille_' + armeLabel);
              let grenaille = attrsChar.find(function(a) {
                return a.get('name') == na;
              });
              if (grenaille) {
                grenaille = parseInt(grenaille.get('current'));
                if (isNaN(grenaille) || grenaille < 0) grenaille = 0;
              } else grenaille = 0;
              if (charge == 1) {
                line = nomArme + " est charg\xE9";
                if (grenaille) line += " de grenaille";
              } else if (charge > 1) {
                line = nomArme + " contient encore " + charge + " charges";
                if (grenaille == charge) line += " de grenaille";
                else if (grenaille)
                  line += ", dont " + grenaille + " de grenaille";
              }
            }
            if (armeEnMain == armeLabel) line += " et en main";
            else if (armeEnMainGauche == armeLabel) line += " et en main gauche";
            else line += ", pas en main";
            addLineToFramedDisplay(display, line);
          } else if (armeEnMain == armeLabel) {
            if (armeEnMainGauche == armeLabel) {
              addLineToFramedDisplay(display, "tient " + nomArme + " \xE0 2 mains.");
            } else {
              addLineToFramedDisplay(display, "tient " + nomArme + " en main.");
            }
          } else if (armeEnMainGauche == armeLabel) {
            addLineToFramedDisplay(display, "tient " + nomArme + " en main gauche.");
          } else if (att.armetypeattaque == "Arme de jet") {
            let n = fieldAsInt(att, 'armejetqte', 1);
            addLineToFramedDisplay(display, nomArme + " : " + n);
          }
          if (attributeAsBool(perso, 'enduitDePoison_' + armeLabel)) {
            addLineToFramedDisplay(display, nomArme + " est enduit de poison.");
          }
        });
        let attrEnveloppe = tokenAttribute(perso, 'enveloppePar');
        if (attrEnveloppe.length > 0) {
          let cube = persoOfIdName(attrEnveloppe[0].get('current'));
          if (cube) {
            let actE = "est envelopp\xE9 dans ";
            if ((attrEnveloppe[0].get('max') + '').startsWith('etreinte')) actE = "est prisonnier de l'\xE9treinte de ";
            addLineToFramedDisplay(display, actE + cube.tokName);
          }
        }
        let pageId = perso.token.get('pageid');
        let defense = defenseOfPerso(undefined, perso, pageId, undefined, {
          test: true
        });
        let defenseMontree;
        let bufDef = attributeAsInt(perso, 'bufDEF', 0);
        if (bufDef > 0) {
          addLineToFramedDisplay(display, "D\xE9fense temporairement modifi\xE9e de " + bufDef + " (DEF " + defense + ")");
          defenseMontree = true;
        }
        for (let etat in cof_states) {
          if (getState(perso, etat)) {
            let markerName = cof_states[etat].substring(7).split("::")[0];
            let marker = markerCatalog[markerName];
            let etext = stringOfEtat(etat, perso);
            if (marker) {
              etext = "<img src=" + marker.url + "></img> " + etext;
            }
            let saveEtat = boutonSaveState(perso, etat);
            if (saveEtat) etext += ", " + saveEtat;
            addLineToFramedDisplay(display, etext);
          }
        }
        if (ficheAttributeAsInt(perso, 'defarmureon', 0) === 0) {
          let possedeArmure = ficheAttributeAsInt(perso, 'defarmure', 0) > 0;
          if (possedeArmure) addLineToFramedDisplay(display, "Ne porte pas son armure");
          if (predicateAsInt(perso, 'vetementsSacres', 0) > 0) {
            if (possedeArmure) addLineToFramedDisplay(display, "  mais b\xE9n\xE9ficie de ses v\xEAtements sacr\xE9s (DEF " + defense + ")");
            else addLineToFramedDisplay(display, "porte des v\xEAtements sacr\xE9s (DEF " + defense + ")");
            defenseMontree = true;
          }
          if (predicateAsInt(perso, 'armureDeVent', 0) > 0) {
            if (possedeArmure) addLineToFramedDisplay(display, "  mais b\xE9n\xE9ficie de son armure de vent (DEF " + defense + ")");
            else addLineToFramedDisplay(display, "b\xE9n\xE9ficie de son armure de vent (DEF " + defense + ")");
            defenseMontree = true;
          }
        }
        if (ficheAttributeAsInt(perso, 'defbouclieron', 0) === 0 &&
          ficheAttributeAsInt(perso, 'defbouclier', 0))
          addLineToFramedDisplay(display, "Ne porte pas son bouclier");
        if (ficheAttributeAsInt(perso, 'casque_rd', 0)) {
          if (ficheAttributeAsBool(perso, 'casque_on', false)) {
            let b = boutonSimple('!cof-set-attribute casque_on false --message enl\xE8ve son casque --target ' + perso.token.id, "l'enlever");
            addLineToFramedDisplay(display, "Porte son casque :" + b);
          } else {
            let b = boutonSimple('!cof-set-attribute casque_on true --message met son casque --target ' + perso.token.id, "le mettre");
            addLineToFramedDisplay(display, "Ne porte pas son casque :" + b);
          }
        }
        if (attributeAsBool(perso, 'etatExsangue')) {
          addLineToFramedDisplay(display, "est exsangue");
        }
        if (attributeAsBool(perso, 'malediction')) {
          addLineToFramedDisplay(display, "est maudit" + eForFemale(perso) + "...");
        }
        const allAttrs = findObjs({
          _type: 'attribute',
          _characterid: charId
        });
        allAttrs.forEach(function(attr) {
          const attrName = attr.get('name');
          if (!lie && !attrName.endsWith('_' + name)) return;
          if (estEffetTemp(attrName)) {
            let effet = effetTempOfAttribute(attr);
            let mt = messageEffetTemp[effet];
            if (lie) {
              if (mt.generic) {
                if (attrName.indexOf(')_') > 0) return;
              } else if (effet != attrName) return;
            }
            let explEffetMsg = messageActif(perso, mt);
            if (stateCOF.options.affichage.val.duree_effets.val || playerIsGM(playerId)) {
              let effetVal = attr.get('current');
              if (parseInt(effetVal)) {
                explEffetMsg += " (" + effetVal + " tours)";
              } else {
                explEffetMsg += " (tour final)";
              }
            }
            addLineToFramedDisplay(display, explEffetMsg);
          } else if (estEffetCombat(attrName)) {
            let effetC = effetCombatOfAttribute(attr);
            if (lie && effetC != attrName) return;
            addLineToFramedDisplay(display, messageActif(perso, messageEffetCombat[effetC]));
          } else if (estEffetIndetermine(attrName)) {
            let effetI = effetIndetermineOfAttribute(attr);
            if (lie && effetI != attrName) return;
            let mi = messageActif(perso, messageEffetIndetermine[effetI]);
            if (playerIsGM(playerId)) {
              mi += ' ' + boutonSimple('!cof-effet ' + effetI + ' false --target ' + perso.token.id, 'X');
            }
            addLineToFramedDisplay(display, mi);
          }
        });
        //ancienne version de munitions, obsol\xE8te depuis mars 2023
        allAttributesNamed(attrsChar, 'munition').forEach(function(attr) {
          let attrName = attr.get('name');
          let underscore = attrName.indexOf('_');
          if (underscore < 0 || underscore == attrName.length - 1) return;
          let munitionNom = attrName.substring(underscore + 1).replace(/_/g, ' ');
          addLineToFramedDisplay(display, munitionNom + " : " + attr.get('current') + " / " + attr.get('max'));
        });
        let attrPosture = tokenAttribute(perso, 'postureDeCombat');
        if (attrPosture.length > 0) {
          attrPosture = attrPosture[0];
          let posture = attrPosture.get('max');
          let postureMsg = "a une posture ";
          switch (posture.substr(-3, 3)) {
            case 'DEF':
              postureMsg += "d\xE9fensive";
              break;
            case 'ATT':
              postureMsg += "offensive";
              break;
            case '_DM':
              postureMsg += "puissante";
              break;
            default:
          }
          postureMsg += " mais ";
          switch (posture.substr(0, 3)) {
            case 'DEF':
              postureMsg += "risqu\xE9e";
              break;
            case 'ATT':
              postureMsg += "moins pr\xE9cise";
              break;
            case 'DM_':
              postureMsg += "moins puissante";
              break;
            default:
          }
          addLineToFramedDisplay(display, postureMsg);
        }
        let attaqueAOutrance = attributeAsInt(perso, 'attaqueAOutrance', 0);
        if (attaqueAOutrance) {
          let attaqueAOutranceMsg = "attaque \xE0 outrance ";
          switch (attaqueAOutrance) {
            case 2:
              attaqueAOutranceMsg += "(-2 DEF, +1D6 DM)";
              break;
            case 5:
              attaqueAOutranceMsg += "(-5 DEF, +2D6 DM)";
              break;
            default:
          }
          addLineToFramedDisplay(display, attaqueAOutranceMsg);
        }
        let rangSoin = predicateAsInt(perso, 'voieDesSoins', 0);
        if (rangSoin > 0) {
          let msgSoins;
          let soinsRestants;
          let soins = "";
          let soinsLegers = attributeAsInt(perso, 'soinsLegers', 0);
          if (soinsLegers < rangSoin) {
            soinsRestants = rangSoin - soinsLegers;
            if (soinsRestants > 1) soins = 's';
            msgSoins = "peut encore faire " + soinsRestants + " soin" + soins + " l\xE9ger" + soins;
            addLineToFramedDisplay(display, msgSoins);
          } else {
            addLineToFramedDisplay(display, "ne peut plus faire de soin l\xE9ger aujourd'hui");
          }
          if (rangSoin > 1) {
            let soinsModeres = attributeAsInt(perso, 'soinsModeres', 0);
            if (soinsModeres < rangSoin) {
              soinsRestants = rangSoin - soinsModeres;
              if (soinsRestants > 1) soins = 's';
              else soins = '';
              msgSoins = "peut encore faire " + soinsRestants + " soin" + soins + " mod\xE9r\xE9" + soins;
              addLineToFramedDisplay(display, msgSoins);
            } else {
              addLineToFramedDisplay(display, "ne peut plus faire de soin mod\xE9r\xE9 aujourd'hui");
            }
          }
          if (rangSoin > 3) {
            let soinsGuerison = attributeAsInt(perso, 'limiteParJour_gu\xE9rison', 1);
            if (soinsGuerison > 0) {
              addLineToFramedDisplay(display, "peut encore faire " + soinsGuerison + " gu\xE9rison" + (soinsGuerison > 1 ? 's' : '') + " aujourd'hui");
            } else {
              addLineToFramedDisplay(display, "ne peut plus faire de gu\xE9rison aujourd'hui");
            }
          }
        }
        let ebriete = attributeAsInt(perso, 'niveauEbriete', 0);
        if (ebriete > 0 && ebriete < niveauxEbriete.length) {
          addLineToFramedDisplay(display, "est " + niveauxEbriete[ebriete]);
        }
        let bonusCouvert = attributeAsInt(perso, 'bonusCouvert');
        if (bonusCouvert) {
          addLineToFramedDisplay(display, "est \xE0 couvert (+" + bonusCouvert + " DEF)");
        }
        if (!defenseMontree) {
          let defenseAffichee = 10;
          if (estPNJ) {
            defenseAffichee = ficheAttributeAsInt(perso, 'pnj_def', 10);
          } else {
            defenseAffichee += ficheAttributeAsInt(perso, 'defarmure', 0) * ficheAttributeAsInt(perso, 'defarmureon', 0);
            defenseAffichee += ficheAttributeAsInt(perso, 'defbouclier', 0) * ficheAttributeAsInt(perso, 'defbouclieron', 0);
            defenseAffichee += ficheAttributeAsInt(perso, 'DEFDIV', 0);
            defenseAffichee += modCarac(perso, 'dexterite');
          }
          if (defense != defenseAffichee)
            addLineToFramedDisplay(display, "D\xE9fense actuelle : " + defense);
        }
        let predicatExpertDuCombat = predicateAsInt(perso, "expertDuCombat", 0);
        if (stateCOF.combat && predicatExpertDuCombat > 0) {
          let nbDesExpertDuCombat_combat_max = predicatExpertDuCombat * 2;
          let nbDesExpertDuCombat_combat = attributeAsInt(perso, "limiteParCombat_expertDuCombat", predicatExpertDuCombat * 2);
          let nbDesExpertDuCombat_tour_max;
          if (predicatExpertDuCombat > 4) nbDesExpertDuCombat_tour_max = 3;
          else if (predicatExpertDuCombat > 2) nbDesExpertDuCombat_tour_max = 2;
          else nbDesExpertDuCombat_tour_max = 1;
          let nbDesExpertDuCombat_tour = Math.min(nbDesExpertDuCombat_combat,
            attributeAsInt(perso, "limiteParTour_expertDuCombat", nbDesExpertDuCombat_tour_max));
          addLineToFramedDisplay(display, "D\xE9s d'expertise du combat : <br>" +
            "Tour : " + nbDesExpertDuCombat_tour + "/" + nbDesExpertDuCombat_tour_max + "<br>" +
            "Combat : " + nbDesExpertDuCombat_combat + "/" + nbDesExpertDuCombat_combat_max + "<br>");
        }
        //Affaiblissements de caract\xE9ristiques
        allCaracs.forEach(function(carac) {
          let malus = attributeAsInt(perso, 'affaiblissementde' + carac, 0);
          if (malus > 0) {
            let normal = caracNormale(perso, carac);
            let ligne = carac + " : " + (normal - malus) + " / " + normal;
            addLineToFramedDisplay(display, ligne);
          }
        });
        //Violence cibl\xE9e
        if (predicateAsBool(perso, 'violenceCiblee')) {
          let pointsDeViolence = attributeAsInt(perso, 'pointsDeViolence', 0);
          if (pointsDeViolence > 0) {
            addLineToFramedDisplay(display, "Points de violence : " + pointsDeViolence);
          }
        }
        if (attributeAsBool(perso, 'lumiere')) {
          addLineToFramedDisplay(display, "\xE9claire ou fait de la lumi\xE8re");
        }
        let autresAttributs = predicatesNamed(perso, 'attributsDeStatut');
        autresAttributs.forEach(function(attr) {
          let listeAttrs = attr.split(',');
          listeAttrs.forEach(function(a) {
            a = a.trim();
            if (a === '') return;
            let aDisplay = tokenAttribute(perso, a);
            aDisplay.forEach(function(ad) {
              let line = a + " : " + ad.get('current');
              let admax = ad.get('max');
              if (admax) line += " / " + admax;
              addLineToFramedDisplay(display, line);
            });
          });
        });
        sendChat("", endFramedDisplay(display));
      }); //fin du iterSelected
    });
  }

  //retourne l'id du suivant si le token actuel \xE9tait en t\xEAte de liste
  function removeFromTurnTracker(perso, evt) {
    removeDernieresCiblesAttaquees(perso, evt);
    let tokenId = perso.token.id;
    let turnOrder = Campaign().get('turnorder');
    if (turnOrder === '' || !stateCOF.combat) {
      return;
    }
    evt.turnorder = evt.turnorder || turnOrder;
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length === 0) return;
    let res;
    let change;
    if (turnOrder[0].id == tokenId) {
      change = true;
      if (turnOrder.length > 1) {
        res = {
          nextId: turnOrder[1].id
        };
        turnOrder.shift();
        if (turnOrder[0].id == "-1" && turnOrder[0].custom == "Tour") {
          //Il faut aussi augmenter la valeur du tour
          let tour = parseInt(turnOrder[0].pr);
          if (isNaN(tour)) {
            error("Tour invalide", turnOrder);
            return;
          }
          turnOrder[0].pr = tour + 1;
        }
        let cmp = Campaign();
        cmp.set('turnorder', JSON.stringify(turnOrder));
        nextTurn(cmp, undefined, evt);
        return res;
      } else {
        res = {
          nextId: false
        };
        turnOrder = [];
      }
    } else {
      turnOrder = turnOrder.filter(
        function(elt) {
          let f = elt.id == tokenId;
          change = change || f;
          return !f;
        });
    }
    if (change) Campaign().set('turnorder', JSON.stringify(turnOrder));
    return res;
  }

  function replaceInTurnTracker(tidOld, tidNew, evt) {
    let combat = stateCOF.combat;
    if (!combat) return;
    let turnOrder = Campaign().get('turnorder');
    if (turnOrder === '') return;
    evt.turnorder = evt.turnorder || turnOrder;
    turnOrder = JSON.parse(turnOrder);
    turnOrder.forEach(function(elt) {
      if (elt.id == tidOld) elt.id = tidNew;
    });
    Campaign().set('turnorder', JSON.stringify(turnOrder));
    if (tidOld == combat.activeTokenId)
      combat.activeTokenId = tidNew;
  }

  function armureMagique(msg) {
    msg.content += " armureMagique";
    effetCombat(msg);
  }

  function bufDef(msg) {
    let cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("La fonction !cof-buf-def attend un argument", cmd);
      return;
    }
    let buf = parseInt(cmd[1]);
    if (isNaN(buf)) {
      error("Argument de !cof-buf-def invalide", cmd);
      return;
    }
    if (buf === 0) return;
    let message = "";
    if (buf > 0) message = "voit sa d\xE9fense augmenter";
    else message = "voit sa d\xE9fense baisser";
    let evt = {
      type: 'other'
    };
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour !cof--buf-def", playerId);
      }
      iterSelected(selected, function(perso) {
        setTokenAttr(perso, 'bufDEF', buf, evt, {
          msg: message
        });
        setToken(perso.token, 'status_blue', buf, evt);
      });
      if (evt.attributes.length === 0) {
        error("Pas de cible valide s\xE9lectionn\xE9e pour !cod-buf-def", msg);
        return;
      }
      addEvent(evt);
    });
  }

  function removeBufDef(msg) {
    const evt = {
      type: 'other'
    };
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour !cof-remove-buf-def", playerId);
      }
      iterSelected(selected, function(perso) {
        removeTokenAttr(perso, 'bufDEF', evt, {
          msg: "retrouve sa d\xE9fense normale"
        });
        setToken(perso.token, 'status_blue', false, evt);
      });
      addEvent(evt);
    });
  }

  function parseDmgOptions(text, options) {
    let optArgs = text.split(' --');
    optArgs.forEach(function(opt) {
      opt = opt.trim().split(' ');
      opt = opt.filter(function(c) {
        return c !== '';
      });
      switch (opt[0]) {
        case 'psave':
          let psaveopt = options;
          if (options.additionalDmg && opt.length > 3 && opt[3] == 'local') {
            let psavel = options.additionalDmg.length;
            if (psavel > 0) {
              psaveopt = options.additionalDmg[psavel - 1];
            }
          }
          let psaveParams = parseSave(opt);
          if (psaveParams) {
            psaveopt.partialSave = psaveParams;
          }
          return;
        case 'asphyxie':
        case 'affute':
        case "metal":
        case 'magique':
        case 'artificiel':
        case 'tranchant':
        case 'percant':
        case 'contondant':
        case 'tempDmg':
        case 'mortsVivants':
        case 'ignoreMoitieRD':
        case 'maxDmg':
        case 'sortilege':
          options[opt[0]] = true;
          return;
        case 'feu':
        case 'froid':
        case 'acide':
        case 'electrique':
        case 'sonique':
        case 'poison':
        case 'maladie':
        case 'argent':
        case 'energie':
          if (options.additionalDmg) {
            let l = options.additionalDmg.length;
            if (l > 0) {
              options.additionalDmg[l - 1].type = opt[0];
            } else {
              options.type = opt[0];
            }
          } else options.type = opt[0];
          return;
        case 'nature':
        case 'naturel':
          options.nature = true;
          return;
        case 'vampirise':
          var vampirise = 100;
          if (opt.length > 1) {
            vampirise = parseInt(opt[1]);
            if (isNaN(vampirise)) {
              error("Il faut un pourcentage entier comme argument \xE0 --vampirise", opt);
              vampirise = 100;
            }
          }
          options.vampirise = vampirise;
          return;
        case "ignoreRD":
          if (opt.length < 2) {
            options.ignoreTouteRD = true;
            return;
          }
          options.ignoreRD = parseInt(opt[1]);
          if (isNaN(options.ignoreRD) || options.ignoreRD < 1) {
            log("Pas un nombre positif apr\xE8s --ignoreRD, interpr\xE9t\xE9 comme ignore toute la RD");
            options.ignoreRD = undefined;
            options.ignoreTouteRD = true;
          }
          return;
        case 'attaquant':
          {
            if (opt.length < 2) {
              error("Manque l'id de l'attaquant, option ignor\xE9e", optArgs);
              return;
            }
            const attaquant = persoOfId(opt[1]);
            if (attaquant) {
              options.attaquant = attaquant;
              return;
            }
            error("Attaquant non trouv\xE9", opt);
            return;
          }
        case 'titre':
          if (opt.length < 2) {
            error("Il manque le message apr\xE8s --message", text);
            return;
          }
          options.titre = opt.slice(1).join(' ');
          return;
      }
    });
  }

  // Ne pas remplacer les inline rolls, il faut les afficher correctement
  function parseDmgDirects(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("cof-dmg prend les d\xE9gats en argument, avant les options",
        msg.content);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "pas de cible trouv\xE9e, action annul\xE9e", playerId);
        return;
      }
      options.aoe = true;
      parseDmgOptions(msg.content, options);
      let cibles = [];
      iterSelected(selected, function(perso) {
        cibles.push(perso);
      });
      cibles = enleveDoublonsPartagePV(cibles);
      if (options.return) return;
      //L'expression \xE0 lancer est tout ce qui est entre le premier blanc et le premier --
      let debutDmgRollExpr = msg.content.indexOf(' ') + 1;
      let dmgRollExpr = msg.content.substring(debutDmgRollExpr);
      let finDmgRollExpr = msg.content.indexOf(' --');
      if (finDmgRollExpr > debutDmgRollExpr)
        dmgRollExpr = msg.content.substring(debutDmgRollExpr, finDmgRollExpr);
      else dmgRollExpr = msg.content.substring(debutDmgRollExpr);
      dmgRollExpr = dmgRollExpr.trim();
      let dmgType = options.type || 'normal';
      let dmg = {
        type: dmgType,
        value: dmgRollExpr
      };
      if (options.maxDmg) {
        dmgRollExpr = dmgRollExpr.replace(/d([1-9])/g, "*$1");
      }
      let playerName = msg.who;
      if (playerIsGM(playerId)) playerName = 'GM';
      dmgDirects(playerId, playerName, cibles, dmg, options);
    }, options); //fin du getSelected
  }

  function copyDmgOptionsToTarget(target, options) {
    target.ignoreRD = options.ignoreRD;
    target.ignoreTouteRD = options.ignoreTouteRD;
    target.ignoreMoitieRD = options.ignoreMoitieRD;
    target.tempDmg = options.tempDmg;
    target.attaquant = options.lanceur;
  }


  function dmgDirects(playerId, playerName, cibles, dmg, options) {
    let evt;
    if (options.evt) {
      evt = options.evt;
    } else {
      evt = {
        type: 'dmgDirects'
      };
      addEvent(evt);
    }
    evt.action = {
      titre: "D\xE9g\xE2ts",
      playerId: playerId,
      playerName: playerName,
      cibles: cibles,
      dmg: dmg,
      options: options
    };
    if (options.lanceur && limiteRessources(options.lanceur, options, 'dmg', 'dmg', evt)) return;
    let action = "<b>D\xE9g\xE2ts.</b> ";
    if (options.titre) action += options.titre + "<br/>";
    if (options.partialSave) {
      action +=
        " Jet de " + options.partialSave.carac + " difficult\xE9 " + options.partialSave.seuil +
        " pour r\xE9duire les d\xE9g\xE2ts";
    }
    let display = startFramedDisplay(playerId, action);
    let tokensToProcess = cibles.length;
    let someDmgDone;
    let finalDisplay = function() {
      if (tokensToProcess == 1) {
        if (someDmgDone) {
          sendChat('', endFramedDisplay(display));
        } else {
          sendPlayer(playerName, "Aucune cible valide n'a \xE9t\xE9 s\xE9lection\xE9e");
        }
      }
      tokensToProcess--;
    };
    try {
      sendChat('', '[[' + dmg.value + ']]', function(resDmg) {
        dmg.roll = dmg.roll || resDmg[0];
        let afterEvaluateDmg = dmg.roll.content.split(' ');
        let dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
        dmg.total = dmg.roll.inlinerolls[dmgRollNumber].results.total;
        dmg.display = buildinline(dmg.roll.inlinerolls[dmgRollNumber], dmg.type, options.magique);
        cibles.forEach(function(perso) {
          if (getState(perso, 'mort')) { //pas de d\xE9g\xE2ts aux morts
            finalDisplay();
            return;
          }
          if (options.mortsVivants && !(estMortVivant(perso))) {
            sendPlayer(playerName, nomPerso(perso) + " n'est pas un mort-vivant");
            finalDisplay();
            return;
          }
          let name = nomPerso(perso);
          let explications = [];
          copyDmgOptionsToTarget(perso, options);
          dealDamage(perso, dmg, [], evt, false, options, explications, function(dmgDisplay, dmgFinal) {
            someDmgDone = true;
            addLineToFramedDisplay(display,
              name + " re\xE7oit " + dmgDisplay + " DM");
            explications.forEach(function(e) {
              addLineToFramedDisplay(display, e, 80, false);
            });
            finalDisplay();
          });
        }); //fin forEach
      }); //fin du jet de d\xE9s
    } catch (rollError) {
      error("Jet " + dmg.value + " mal form\xE9", dmg);
    }
  }

  function estElementaire(t) {
    if (t === undefined) return false;
    return (t == "feu" || t == "froid" || t == "acide" || t == "electrique");
  }

  function parseSetState(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-set-state", msg.content);
      return;
    }
    let etat = cmd[1];
    let valeur = cmd[2];
    if (valeur == 'false' || valeur == '0' || valeur == 'non' || valeur == 'no') valeur = false;
    if (valeur == 'true' || valeur == 'oui' || valeur == 'yes') valeur = true;
    if (!_.has(cof_states, etat)) {
      error("Le premier argument de !cof-set-state n'est pas un \xE9tat valide", cmd);
      return;
    }
    if (isCarac(cmd[2])) {
      if (cmd.length < 4) {
        error("Il manque la difficult\xE9 du jet de sauvegarde.", cmd);
        return;
      }
      valeur = true;
      options.saveActifParTour = {
        carac: cmd[2]
      };
      let opposition = persoOfId(cmd[3]);
      if (opposition) {
        options.saveActifParTour.difficulte = cmd[3] + ' ' + nomPerso(opposition);
      } else {
        options.saveActifParTour.difficulte = parseInt(cmd[3]);
        if (isNaN(options.saveActifParTour.difficulte)) {
          error("Difficult\xE9 du jet de sauvegarde incorrecte", cmd);
          return;
        }
      }
    }
    let cibles = [];
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        error("Pas de cible pour le changement d'\xE9tat", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        if (options.seulementVivant && estNonVivant(perso)) {
          sendPlayer(msg, "cet effet n'affecte que les cr\xE9atures vivantes", playerId);
          return;
        }
        switch (etat) {
          case 'apeure':
          case 'endormi':
            if (predicateAsBool(perso, 'liberteDAction')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            break;
          case 'paralyse':
            if (predicateAsBool(perso, 'liberteDAction')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            if ((options.magique || options.mana != undefined) &&
              predicateAsBool(perso, 'actionLibre')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            break;
          case 'immobilise':
          case 'ralenti':
            if (predicateAsBool(perso, 'liberteDAction')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            if ((options.magique || options.mana != undefined) &&
              predicateAsBool(perso, 'actionLibre')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            if (predicateAsInt(perso, 'voieDeLArchange', 1) > 1 && attributeAsBool(perso, 'formeDAnge')) {
              sendPerso(perso, "reste libre de ses mouvements !");
              return;
            }
            break;
          default:
        }
        cibles.push(perso);
      });
    });
    doSetState(cibles, etat, valeur, options);
  }

  function doSetState(cibles, etat, valeur, options) {
    let evt = {
      type: "set_state",
      action: {
        titre: "Interface Set State",
        cibles: cibles,
        etat: etat,
        valeur: valeur,
        options: options
      }
    };
    addEvent(evt);
    let lanceur = options.lanceur;
    if (lanceur === undefined && cibles.length == 1) lanceur = persoOfId(cibles[0].token.id);
    if (limiteRessources(lanceur, options, etat, etat, evt)) return;
    if (options.messages) {
      options.messages.forEach(function(m) {
        if (lanceur) sendPerso(lanceur, m, options.secret);
        else sendChat('', m);
      });
    }
    if (options.messagesMJ) {
      let source = 'COF';
      if (lanceur) source = 'character|' + lanceur.charId;
      options.messagesMJ.forEach(function(m) {
        sendChat(source, '/w gm ' + m);
      });
    }
    cibles.forEach(function(perso) {
      let setEffect = function() {
        setState(perso, etat, valeur, evt);
        if (lanceur && options.fx) {
          let p1e = {
            x: lanceur.token.get('left'),
            y: lanceur.token.get('top'),
          };
          let p2e = {
            x: perso.token.get('left'),
            y: perso.token.get('top'),
          };
          spawnFxBetweenPoints(p1e, p2e, options.fx, options.pageId);
        }
        if (options.son) playSound(options.son);
        if (options.targetFx) {
          spawnFx(perso.token.get('left'), perso.token.get('top'), options.targetFx, options.pageId);
        }
        if (options.saveActifParTour) {
          setTokenAttr(perso, etat + 'Save', options.saveActifParTour.carac, evt, {
            maxVal: options.saveActifParTour.difficulte
          });
        }
      };
      if (options.save) {
        let saveOpts = {
          msgPour: " pour r\xE9sister \xE0 l'effet " + stringOfEtat(etat),
          msgRate: ", rat\xE9.",
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: options.type
        };
        let expliquer = function(s) {
          sendPerso(perso, s);
        };
        let saveId = 'effet_' + etat + '_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt, function(reussite, rollText) {
          if (!reussite) {
            setEffect();
          }
        });
      } else {
        setEffect();
      }
    });
  }

  function textOfSaveState(etat, perso) {
    switch (etat) {
      case 'immobilise':
        return "se lib\xE9rer";
      case 'aveugle':
        return "retrouver la vue";
      case 'etourdi':
        return "reprendre ses esprits";
      case 'assomme':
        return "reprendre conscience";
      case 'renverse':
        return "se relever";
      case 'endormi':
        return "se r\xE9veiller";
      case 'apeure':
        return "retrouver du courage";
      case 'enseveli':
        return "sortir de terre";
      default:
        return "ne plus \xEAtre " + stringOfEtat(etat, perso);
    }
  }

  function parseSaveState(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 4 || !_.has(cof_states, cmd[1])) {
      error("Param\xE8tres de !cof-save-state incorrects", cmd);
      return;
    }
    let etat = cmd[1];
    let carac = cmd[2];
    let carac2;
    if (!isCarac(carac)) {
      if (carac.length == 6) {
        carac2 = carac.substring(3, 6);
        carac = carac.substring(0, 3);
        if (!isCarac(carac) || !isCarac(carac)) {
          error("Param\xE8tres de !cof-save-state incorrects", cmd);
          return;
        }
      } else {
        error("Param\xE8tres de !cof-save-state incorrects", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Pas de token s\xE9lectionn\xE9", msg.content);
        return;
      }
      let pageId = options.pageId;
      if (pageId === undefined) {
        iterSelected(selected, function(perso) {
          if (pageId) return;
          pageId = perso.token.get('pageid');
        });
      }
      let opposant;
      if (cmd.length > 4) opposant = persoOfId(cmd[3], cmd[4], pageId);
      if (opposant) {
        iterSelected(selected, function(perso) {
          if (!getState(perso, etat)) {
            sendPerso(perso, "n'est pas " + stringOfEtat(etat, perso));
            return;
          }
          doSaveState(playerId, perso, etat, carac, options, opposant);
        });
      } else {
        let seuil = parseInt(cmd[3]);
        if (isNaN(seuil)) {
          error("La difficult\xE9 n'est pas un nombre", cmd);
          return;
        }
        iterSelected(selected, function(perso) {
          if (!getState(perso, etat)) {
            sendPerso(perso, "n'est pas " + stringOfEtat(etat, perso));
            return;
          }
          if (carac2) carac = meilleureCarac(carac, carac2, perso, seuil);
          doSaveState(playerId, perso, etat, carac, options, undefined, seuil);
        });
      }
    });
  }

  function doSaveState(playerId, perso, etat, carac, options, opposant, seuil) {
    let evt = {
      type: "save_state",
      action: {
        titre: "Interface Save State",
        perso: perso,
        etat: etat,
        carac: carac,
        options: options,
        opposant: opposant,
        seuil: seuil,
        playerId: playerId
      }
    };
    addEvent(evt);
    let titre = "Jet " + deCarac(carac) + " pour " + textOfSaveState(etat, perso);
    if (opposant) {
      let display = startFramedDisplay(playerId, titre, perso, {
        perso2: opposant
      });
      let explications = [];
      let rollId = 'saveState_' + perso.token.id;
      testOppose(rollId, perso, carac, options, opposant, carac,
        options, explications, evt,
        function(resultat, crit, rt1, rt2) {
          if (resultat == 2) {
            explications.push(nomPerso(perso) + " est toujours " + stringOfEtat(etat, perso));
          } else {
            setState(perso, etat, false, evt);
            explications.push(nomPerso(perso) + " n'est plus " + stringOfEtat(etat, perso));
          }
          explications.forEach(function(e) {
            addLineToFramedDisplay(display, e);
          });
          sendChat("", endFramedDisplay(display));
        });
    } else {
      let testId = 'saveState_' + carac + seuil;
      testCaracteristique(perso, carac, seuil, testId, options, evt, function(res) {
        sendPerso(perso, titre);
        if (res.reussite) {
          setState(perso, etat, false, evt);
          sendPerso(perso, res.texte + " &ge; " + seuil + ", " + nomPerso(perso) + " n'est plus " + stringOfEtat(etat, perso) + res.modifiers);
        } else {
          sendPerso(perso, res.texte + " &lt; " + seuil + ", " + nomPerso(perso) + " est toujours " + stringOfEtat(etat, perso) + res.rerolls + res.modifiers);
        }
      });
    }
  }

  //Renvoie false si le personnage n'a pas d'attribut etatSave
  function boutonSaveState(perso, etat) {
    let attr = tokenAttribute(perso, etat + 'Save');
    if (attr.length === 0) return false;
    attr = attr[0];
    let carac = attr.get('current');
    let action = "!cof-save-state " + etat + ' ' + carac + ' ' + attr.get('max');
    if (etat == 'enseveli') action += " --bonus ?{Bonus au jet}";
    let b = bouton(action, "Jet", perso);
    return b + " pour " + textOfSaveState(etat, perso);
  }

  //!cof-save-effet token_id attr_id
  // o\xF9 attr_id est l'id de l'attribut de save
  function parseSaveEffet(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Param\xE8tres de !cof-save-effet incorrects", cmd);
      return;
    }
    let perso = persoOfId(cmd[1]);
    let attr = getObj('attribute', cmd[2]);
    if (attr === undefined || perso === undefined) {
      error("Impossible de trouver le personnage ou l'attribut", cmd);
      return;
    }
    let attrName = attr.get('name');
    let indexSave = attrName.indexOf('SaveActifParTour');
    if (indexSave < 0) {
      error("L'attribut n'est pas un attribut de save actif", attrName);
      return;
    }
    let effetC = attrName.substring(0, indexSave);
    let effetTemp = estEffetTemp(effetC);
    if (!effetTemp && !estEffetCombat(effetC)) {
      error("Impossible de trouver l'effet correspondant \xE0 " + effetC, attrName);
      return;
    }
    attrName = effetC + attrName.substr(indexSave + 16);
    let met;
    if (effetTemp) met = messageOfEffetTemp(effetC);
    else met = messageEffetCombat[effetC];
    let msgPour = " pour ";
    if (met.msgSave) msgPour += met.msgSave;
    else {
      msgPour += "ne plus \xEAtre sous l'effet de ";
      if (effetC.startsWith('dotGen('))
        msgPour += effetC.substring(7, effetC.indexOf(')'));
      else msgPour += effetC;
    }
    let carac = attr.get('current');
    if (!isCarac(carac)) {
      error("Save par tour " + attrName + " mal form\xE9", carac);
      return;
    }
    let seuil = parseInt(attr.get('max'));
    if (isNaN(seuil)) {
      error("Save par tour " + attrName + " mal form\xE9", seuil);
      return;
    }
    let attrEffet = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
      name: attrName
    });
    if (attrEffet === undefined || attrEffet.length === 0) {
      error("Save sans effet temporaire " + attrName, attr);
      findObjs({
        _type: 'attribute',
        _characterid: perso.charId,
        name: attr.get('name').replace('SaveParTour', 'SaveParTourType')
      }).forEach(function(a) {
        a.remove();
      });
      attr.remove();
      return;
    }
    attrEffet = attrEffet[0];
    let playerId = getPlayerIdFromMsg(msg);
    options.msgPour = msgPour;
    let sujet = onGenre(perso, 'il', 'elle');
    options.msgReussite = ", " + sujet + ' ' + messageFin(perso, met);
    options.msgRate = ", " + sujet + ' ' + messageActif(perso, met);
    let attrType = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
      name: attr.get('name').replace('SaveParTour', 'SaveParTourType')
    });
    if (attrType.length > 0) {
      options.type = attrType[0].get('current');
    }
    doSaveEffet(playerId, perso, effetC, attr, attrEffet, attrName, met, carac, seuil, options);
  }

  function doSaveEffet(playerId, perso, effetC, attr, attrEffet, attrName, met, carac, seuil, options) {
    let evt = {
      type: "save_effet",
      action: {
        titre: "Interface save effet",
        perso,
        effetC,
        attr,
        attrEffet,
        attrName,
        met,
        carac,
        options,
        seuil,
        playerId
      }
    };
    addEvent(evt);
    let titre = "Jet " + deCarac(carac) + options.msgPour;
    let display = startFramedDisplay(playerId, titre, perso);
    let explications = [];
    let expliquer = function(msg) {
      explications.push(msg);
    };
    let saveId = 'saveParTour_' + attrEffet.id + '_' + perso.token.id;
    let s = {
      carac: carac,
      seuil: seuil,
      entrave: met.entrave
    };
    save(s, perso, saveId, expliquer, options, evt,
      function(reussite, texte) { //asynchrone
        explications.forEach(function(e) {
          addLineToFramedDisplay(display, e);
        });
        sendChat("", endFramedDisplay(display));
        if (reussite) {
          let eff = effetC;
          if (estEffetTemp(effetC)) eff = effetTempOfAttribute(attrEffet);
          finDEffet(attrEffet, eff, attrName, perso.charId, evt, {
            attrSave: attr,
            pageId: perso.token.get('pageid')
          });
        }
      });
  }

  function updateInit(token, evt) {
    if (stateCOF.combat &&
      token.get('pageid') == stateCOF.combat.pageId)
      initiative([{
        _id: token.id
      }], evt, true);
  }

  function updateNextInit(perso) {
    updateNextInitSet.add(perso.token.id);
  }

  function parseDegainer(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("commande non form\xE9e", msg.content);
      return;
    }
    let armeLabel = '';
    if (cmd.length > 1) armeLabel = cmd[1];
    if (cmd.length > 2) {
      if (cmd[2] == 'gauche') options.gauche = true;
      else if (cmd[2] == '2mains') options.deuxMains = true;
      else options.armeGaucheLabel = cmd[2];
    }
    let personnages = [];
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("Qui doit d\xE9gainer ?", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        personnages.push(perso);
      });
    });
    doDegainer(personnages, armeLabel, options);
  }

  function doDegainer(persos, labelArme, options) {
    const evt = {
      type: "degainer",
      attributes: [],
      action: {
        persos,
        armeLabel: labelArme,
        options
      }
    };
    addEvent(evt);
    if (options.son) playSound(options.son);
    persos.forEach(function(perso) {
      function afterSave() {
        let nomArme = degainerArme(perso, labelArme, evt, options);
        if (nomArme) sendPerso(perso, "a d\xE9j\xE0 " + nomArme + " en main");
        else if (options.montreActions && persos.length === 1)
          turnAction(perso);
      }
      if (options.save) {
        let saveOpts = {
          msgPour: " pour garder son arme en main",
          msgRate: ", rat\xE9.",
          rolls: options.rolls,
          chanceRollId: options.chanceRollId
        };
        let expliquer = function(s) {
          sendPerso(perso, s);
        };
        const saveId = 'garderArme_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt, function(reussite, rollText) {
          if (!reussite) {
            afterSave();
          }
        });
      } else {
        afterSave();
      }
    });
  }

  function echangeInit(msg) {
    let combat = stateCOF.combat;
    if (!combat) {
      error("\xC9change d'intiative en dehors du combat", msg);
      return;
    }
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-echange-init", msg.content);
      return;
    }
    let perso1 = persoOfId(cmd[1], cmd[1]);
    if (perso1 === undefined) {
      error("le premier argument n'est pas un token valide", cmd[1]);
      return;
    }
    let pageId = perso1.token.get('pageid');
    let perso2 = persoOfId(cmd[2], cmd[2], pageId);
    if (perso2 === undefined) {
      error("le second argument n'est pas un token valide", cmd[2]);
      return;
    }
    let attackBonus = 0;
    if (cmd.length > 3) {
      attackBonus = parseInt(cmd[3]);
      if (isNaN(attackBonus)) {
        error("Le troisi\xE8me argument n'est pas un nombre", cmd[3]);
        return;
      }
    }
    let evt = {
      type: "echange_init"
    };
    let to = getTurnOrder(combat, evt);
    let tourTok1 = to.pasAgi.findIndex(function(t) {
      return (t.id == perso1.token.id);
    });
    let tourTok2 = to.pasAgi.findIndex(function(t) {
      return (t.id == perso2.token.id);
    });
    if (tourTok1 < 0) {
      sendPerso(perso1, "a d\xE9j\xE0 agit, pas moyen d'\xE9changer son initiative");
      return;
    }
    if (tourTok2 < 0) {
      sendPerso(perso2, "a d\xE9j\xE0 agit, pas moyen d'\xE9changer son initiative");
      return;
    }
    let pr1 = to.pasAgi[tourTok1].pr;
    let pr2 = to.pasAgi[tourTok2].pr;
    if (pr1 == pr2) {
      sendPerso(perso1, "a la m\xEAme initiative que " + nomPerso(perso2));
      return;
    }
    if (pr1 > pr2) {
      if (attackBonus) {
        setTokenAttr(perso1, 'actionConcertee', attackBonus, evt, {
          msg: "gagne un bonus de " + attackBonus + " \xE0 ses attaques et en DEF pour ce tour"
        });
      }
      setActiveToken(combat, perso2.token.id, evt);
    } else {
      setActiveToken(combat, perso1.token.id, evt);
    }
    to.pasAgi[tourTok1].pr = pr2;
    to.pasAgi[tourTok2].pr = pr1;
    let t1 = to.pasAgi[tourTok1];
    to.pasAgi[tourTok1] = to.pasAgi[tourTok2];
    to.pasAgi[tourTok2] = t1;
    updateNextInit(perso1);
    updateNextInit(perso2);
    to.pasAgi.push(to.tour);
    let turnOrder = to.pasAgi.concat(to.dejaAgi);
    Campaign().set('turnorder', JSON.stringify(turnOrder));
    addEvent(evt);
  }

  function aCouvert(msg) {
    let args = msg.content.split(" ");
    if (args.length < 2) {
      error("Pas assez d'arguments pour !cof-a-couvert: " + msg.content, args);
      return;
    }
    let perso1 = persoOfId(args[1], args[1]);
    if (perso1 === undefined) {
      error("Le premier argument n'est pas un token valide", args[1]);
      return;
    }
    let evt = {
      type: "aCouvert"
    };
    let init = getInit();
    let secret = args.some(function(arg) {
      return arg == '--secret';
    });
    setTokenAttr(perso1, 'aCouvert', 1, evt, {
      msg: "reste \xE0 couvert",
      maxVal: init,
      secret: secret
    });
    if (args.length > 2) {
      let perso2 = persoOfId(args[2], args[2]);
      if (perso2 === undefined) {
        error("Le second argument n'est pas un token valide", args[2]);
        addEvent(evt);
        return;
      }
      if (perso2.token.id == perso1.token.id) {
        if (secret) {
          whisperChar(perso1.charId, "s'est cibl\xE9 " + onGenre(perso1, 'lui', 'elle') + "-m\xEAme, il est donc le seul \xE0 couvert");
        } else {
          sendPerso(perso1, "s'est cibl\xE9 " + onGenre(perso1, 'lui', 'elle') + "-m\xEAme, il est donc le seul \xE0 couvert");
        }
        addEvent(evt);
        return;
      }
      let d = distanceCombat(perso1.token, perso2.token);
      if (d > 0) {
        if (secret) {
          whisperChar(perso2.charId, "est trop \xE9loign\xE9 de " + nomPerso(perso1) + " pour rester \xE0 couvert avec lui");
        } else {
          sendPerso(perso2, "est trop \xE9loign\xE9 de " + nomPerso(perso1) + " pour rester \xE0 couvert avec lui");
        }
      } else {
        setTokenAttr(perso2, 'aCouvert', 1, evt, {
          msg: "suit " + nomPerso(perso1) + " et reste \xE0 couvert",
          maxVal: init,
          secret: secret
        });
      }
    }
    addEvent(evt);
  }

  function getInit() {
    let combat = stateCOF.combat;
    if (!combat) return 1000;
    return combat.init;
  }

  function parseEffetTemporaire(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-effet-temp", msg.content);
      return;
    }
    let effet = cmd[1];
    let lanceur = options.lanceur;
    let charId;
    if (lanceur) charId = lanceur.charId;
    if (cof_states[effet]) { //remplacer par sa version effet temporaire
      effet += 'Temp';
    }
    if (effet == 'forgeron' || effet == 'armeEnflammee') {
      //Compl\xE9ter description de l'effet
      if (!lanceur) {
        error("Pas de lanceur pour forgeron ou armeEnflammee", msg.content);
        return;
      }
      let armeActuelle = tokenAttribute(lanceur, 'armeEnMain');
      if (armeActuelle.length === 0) {
        whisperChar(charId, "Pas d'arme en main, impossible de savoir quoi enflammer.");
        return;
      }
      let labelArme = armeActuelle[0].get('current');
      effet = effet + '(' + labelArme + ')';
    } else if (!estEffetTemp(effet)) {
      error(effet + " n'est pas un effet temporaire r\xE9pertori\xE9", msg.content);
      return;
    }
    if (lanceur && options.mana !== undefined && attributeAsBool(lanceur, 'frappeDesArcanes')) {
      sendPerso(lanceur, "ne peut pas encore lancer de sort");
      return;
    }
    if (!options.type && options.valeurMax && effet.startsWith('dotGen(')) {
      options.type = options.valeurMax;
    }
    let pp = effet.indexOf('(');
    let mEffet = (pp > 0) ? messageEffetTemp[effet.substring(effet, pp)] : messageEffetTemp[effet];
    if (mEffet === undefined) {
      error("Impossible de trouver l'effet " + effet, cmd);
      return;
    }
    let duree = parseInt(cmd[2]);
    if (isNaN(duree) || duree < 1) duree = 0; //On veut terminer l'effet
    if (options.puissantDuree || options.tempeteDeManaDuree) duree = duree * 2;
    getSelected(msg, function(selected, playerId, aoe) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lection\xE9e pour l'effet", playerId);
        return;
      }
      options.aoe = aoe;
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine de l'effet", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) {
            options.lanceur = lanceur;
            charId = lanceur.charId;
          }
        }
      }
      if (lanceur && options.tempeteDeMana) {
        if (duree > 0 && options.tempeteDeMana.cout === 0) {
          //On demande de pr\xE9ciser les options
          let optMana = {
            mana: options.mana,
            dm: mEffet.dm,
            soins: mEffet.soins,
            portee: options.portee,
            duree: true,
            rang: options.rang,
            altruiste: options.altruiste
          };
          setTempeteDeMana(playerId, lanceur, msg.content, optMana);
          return;
        } else {
          if (options.rang && options.tempeteDeMana.cout > options.rang) {
            sendPlayer(msg, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
          }
          if (selected.length == 1 && options.tempeteDeMana.altruiste) {
            selected[0]._id = options.tempeteDeMana.altruiste.token.id;
            if (options.portee === undefined) options.portee = 0;
          }
        }
      }
      let cibles = [];
      iterSelected(selected, function(perso) {
        if (options.portee !== undefined) {
          if (options.puissantPortee || options.tempeteDeManaPortee) options.portee = options.portee * 2;
          var dist = distanceCombat(lanceur.token, perso.token);
          if (dist > options.portee) {
            sendPerso(perso, " est trop loin de " + nomPerso(perso));
            return;
          }
        }
        if ((mEffet.seulementVivant || options.seulementVivant) &&
          estNonVivant(perso)) {
          sendPlayer(msg, "cet effet n'affecte que les cr\xE9atures vivantes", playerId);
          return;
        }
        if (predicateAsBool(perso, 'liberteDAction') &&
          (effet == 'confusion ' ||
            effet == 'charme ' ||
            effet == 'prisonVegetale' ||
            effet == 'toiles' ||
            effet == 'foretVivanteEnnemie' ||
            ((options.magique || options.mana != undefined) &&
              (effet == 'apeureTemp' ||
                effet == 'endormiTemp' ||
                effet == 'etourdiTemp' ||
                effet == 'immobiliseTemp' ||
                effet == 'paralyseTemp' ||
                effet == 'paralyseGoule' ||
                effet == 'ralentiTemp'))
          )) {
          sendPerso(perso, "reste libre de ses mouvements !");
          return;
        }
        if ((options.magique || options.mana != undefined) &&
          ((predicateAsBool(perso, 'actionLibre') &&
              (effet == 'immobiliseTemp' ||
                effet == 'paralyseTemp' ||
                effet == 'paralyseGoule' ||
                effet == 'ralentiTemp' ||
                effet == 'toiles')) ||
            (mEffet.entrave && effet != 'paralyseTemp' && effet != 'paralyseGoule' && predicateAsInt(perso, 'voieDeLArchange', 1) > 1 && attributeAsBool(perso, 'formeDAnge'))
          )) {
          sendPerso(perso, "reste libre de ses mouvements !");
          return;
        }
        cibles.push(perso);
      });
      if (cibles.length == 0) {
        return;
      }
      effetTemporaire(playerId, cibles, effet, mEffet, duree, options);
    }, options);
  }

  //Si display est d\xE9fini, l'envoie dans le chat \xE0 la fin de l'appel
  function activerEffetTemporaire(lanceur, cibles, effet, mEffet, duree, options, evt, whisper, explications, display) {
    let ef = {
      effet: effet,
      duree: duree,
      acumuleDuree: options.accumuleDuree,
      typeDmg: options.type,
      message: mEffet,
      valeur: options.valeur,
      valeurMax: options.valeurMax,
      saveParTour: options.saveParTour,
      saveActifParTour: options.saveActifParTour,
      whisper: whisper,
      attaquant: options.lanceur,
      options: options.optionsEffet
    };
    if (display) ef.whisper = undefined;
    let nbCibles = cibles.length;
    let finalize = function() {
      nbCibles--;
      if (nbCibles === 0) { //affichage
        if (display) {
          cibles.forEach(function(cible) {
            if (cible.messages.length > 0) {
              if (cibles.length > 1 || (lanceur && cible.token.id != lanceur.token.id))
                addLineToFramedDisplay(display, "<b>" + nomPerso(cible) + "</b> :");
              cible.messages.forEach(function(expl) {
                addLineToFramedDisplay(display, expl, 80);
              });
            }
          });
          explications.forEach(function(e) {
            addLineToFramedDisplay(display, e);
          });
          sendChat('', endFramedDisplay(display));
        } else {
          explications.forEach(function(e) {
            sendChat('', e);
          });
        }
      }
    };
    let setOneEffect = function(perso, d) {
      let expliquer = function(m) {
        if (display) {
          perso.messages.push(m);
        } else sendPerso(perso, m, options.secret);
      };
      if (options.limiteCibleParJour) {
        let ressource = effet;
        if (options.limiteCibleParJourRessource)
          ressource = options.limiteCibleParJourRessource;
        ressource = "limiteParJour_" + ressource;
        let utilisations = attributeAsInt(perso, ressource, options.limiteCibleParJour);
        if (utilisations === 0) {
          expliquer("ne peut plus b\xE9n\xE9ficier de " + effet + " aujourd'hui");
          return;
        }
        setTokenAttr(perso, ressource, utilisations - 1, evt);
      }
      let combat;
      if (mEffet.dm || mEffet.prejudiciable) {
        combat = entrerEnCombat(lanceur, cibles, explications, evt);
      } else { //On met juste dans la liste d'initiative
        let ini = [...cibles];
        if (lanceur) ini.push(lanceur);
        combat = entrerEnCombat(undefined, ini, explications, evt);
      }
      if (options.aoe && options.pageId && effet == 'prisonVegetale' && options.aoe.type == 'disque') {
        if (lanceur) {}
        let diametre = options.aoe.rayon * 2 * PIX_PER_UNIT / computeScale(options.pageId);
        let t = createObj('graphic', {
          _pageid: options.pageId,
          imgsrc: stateCOF.options.images.val.prison_vegetale.val,
          represents: '',
          left: options.aoe.centre.get('left'),
          top: options.aoe.centre.get('top'),
          width: diametre,
          height: diametre,
          layer: 'map',
          isDrawing: true,
          name: 'Prison v\xE9g\xE9tale',
          gmnotes: 'terrainDifficile:disque ' + Math.floor(diametre)
        });
        if (t) {
          toFront(t);
          evt.tokens = evt.tokens || [];
          evt.tokens.push(t);
          stateCOF.tokensTemps = stateCOF.tokensTemps || [];
          stateCOF.tokensTemps.push({
            tid: t.id,
            duree,
            init: getInit()
          });
        }
      }
      setEffetTemporaire(perso, ef, d, evt, options);
      if (effet.startsWith('forgeron(')) {
        //Il faut d\xE9gainer l'arme si elle n'est pas en main, et ajouter une lumi\xE8re
        let labelArmeForgeron = effet.substring(9, effet.indexOf(')'));
        degainerArme(perso, labelArmeForgeron, evt);
        let feu = getValeurOfEffet(perso, effet, 1, 'voieDuMetal');
        ajouteUneLumiere(perso, effet, feu * 3, feu, evt);
      } else if (effet.startsWith('armeEnflammee(')) {
        let labelArmeEnflammee = effet.substring(14, effet.indexOf(')'));
        degainerArme(perso, labelArmeEnflammee, evt);
        ajouteUneLumiere(perso, effet, 9, 3, evt);
      }
      if (effet == 'cercleDeProtection') {
        let protecteur = options.lanceur || perso;
        if (!attributeAsBool(protecteur, 'cercleDeProtectionActif')) {
          setTokenAttr(protecteur, 'cercleDeProtectionActif', 1, evt, {
            maxVal: 1
          });
        }
      }
      if (effet == 'armeeDesMorts') {
        if (!evt.combat) evt.combat = {...combat
        };
        if (combat.armeesDesMorts) {
          evt.combat.armeesDesMorts = {...combat.armeesDesMorts
          };
        } else {
          evt.combat.armeesDesMorts = {};
          combat.armeesDesMorts = {};
        }
        combat.armeesDesMorts[perso.token.id] = perso;
      }
      if (options.puissant) {
        let puissant = (options.puissant != 'off');
        setTokenAttr(perso, effet + 'Puissant', puissant, evt);
      }
      if (lanceur && options.fx) {
        let p1e = {
          x: lanceur.token.get('left'),
          y: lanceur.token.get('top'),
        };
        let p2e = {
          x: perso.token.get('left'),
          y: perso.token.get('top'),
        };
        spawnFxBetweenPoints(p1e, p2e, options.fx, options.pageId);
      }
      if (options.son) playSound(options.son);
      if (options.targetFx) {
        spawnFx(perso.token.get('left'), perso.token.get('top'), options.targetFx, options.pageId);
      }
      finalize();
    };
    cibles.forEach(function(perso) {
      if (display) perso.messages = perso.messages || [];
      let expliquer = function(s) {
        if (display) perso.messages.push(s);
        else sendPerso(perso, s);
      };
      if (options.type && immuniseAuType(perso, options.type, lanceur)) {
        expliquer("ne semble pas affect\xE9 par " + stringOfType(options.type));
        finalize();
        return;
      }
      if (options.save) {
        let saveOpts = {
          msgPour: options.save.msgPour || " pour r\xE9sister \xE0 l'effet " + effet,
          msgRate: ", rat\xE9.",
          attaquant: lanceur,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: options.type
        };
        options.save.entrave = mEffet.entrave;
        let d = duree;
        let saveId = 'effet_' + effet + "_" + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt,
          function(reussite, rollText) {
            if (reussite && options.save.demiDuree) {
              reussite = false;
              d = Math.ceil(d / 2);
            }
            if (reussite) {
              if (effet == 'reactionViolente' && predicateAsBool(perso, 'violenceCiblee')) {
                expliquer("r\xE9siste \xE0 la provocation, mais emmagasine de la violence");
                addToAttributeAsInt(perso, 'pointsDeViolence', 0, 1, evt);
              }
              finalize();
            } else setOneEffect(perso, d);
          });
      } else {
        setOneEffect(perso, duree);
      }
    });
  }

  function porteArmure(perso) {
    if (!ficheAttributeAsBool(perso, 'defarmureon', false) &&
      !ficheAttributeAsBool(perso, 'defbouclieron', false)) return false;
    let magieEnArmure = predicateAsInt(perso, 'magieEnArmure', 0);
    if (magieEnArmure === 0) return true;
    let ma = malusArmure(perso);
    let defa = defenseArmure(perso);
    return (2 * magieEnArmure < defa + ma);
  }

  //options doit \xEAtre d\xE9fini
  function effetTemporaire(playerId, cibles, effet, mEffet, duree, options) {
    const evt = {
      type: 'effetTemp',
      action: {
        titre: "Effet Temporaire",
        playerId: playerId,
        cibles: cibles,
        effet: effet,
        mEffet: mEffet,
        duree: duree,
        options: options
      }
    };
    let lanceur = options.lanceur;
    let explications = options.messages || [];
    if (options.magieRapide) explications.push("Magie rapide");
    let whisper = '';
    if (options.secret && playerId) {
      let player = getObj('player', playerId);
      if (player !== undefined) {
        whisper = '/w "' + player.get('displayname') + '" ';
      }
    }
    addEvent(evt);
    if (limiteRessources(lanceur, options, effet, effet, evt)) return;
    if (duree > 0) {
      if (options.magieEnArmure && lanceur && porteArmure(lanceur)) {
        let difficulte = 10;
        if (options.magieEnArmure.base) difficulte = options.magieEnArmure.base;
        else if (options.rang) difficulte = 10 + options.rang;
        else difficulte = 11;
        difficulte += malusArmure(lanceur);
        if (predicateAsBool(lanceur, 'magieEnArmureFacilitee')) {
          options.bonusPreds = options.bonusPreds || [];
          options.bonusPreds.push('magieEnArmure');
        }
        let display = startFramedDisplay(playerId, "Sort en armure", lanceur, options);
        let testId = 'magieEnArmure_' + lanceur.token.id;
        testCaracteristique(lanceur, 'INT', difficulte, testId, options, evt,
          function(tr) {
            let line = "Jet d'INT : " + tr.texte;
            if (tr.reussite) {
              line += '&ge; ' + difficulte;
              addLineToFramedDisplay(display, line);
              activerEffetTemporaire(lanceur, cibles, effet, mEffet, duree, options, evt, whisper, explications, display);
            } else {
              line += '&lt; ' + difficulte + ", le sort est rat\xE9";
              addLineToFramedDisplay(display, line);
              sendChat('', endFramedDisplay(display));
            }
          });
      } else {
        activerEffetTemporaire(lanceur, cibles, effet, mEffet, duree, options, evt, whisper, explications);
      }
    } else { //On met fin \xE0 l'effet
      explications.forEach(function(e) {
        sendChat('', e);
      });
      let opt = {
        pageId: options.pageId
      };
      cibles.forEach(function(perso) {
        let attr = tokenAttribute(perso, effet);
        if (attr.length === 0) {
          log(nomPerso(perso) + " n'a pas d'attribut " + effet);
          return;
        }
        finDEffet(attr[0], effetTempOfAttribute(attr[0]), attr[0].get('name'), perso.charId, evt, opt);
      });
    }
    if (options.montreActions && cibles.length === 1)
      turnAction(cibles[0], playerId);
  }

  function effetCombat(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-effet-combat", msg.content);
      return;
    }
    let effet = cmd[1];
    if (!estEffetCombat(effet)) {
      error(effet + " n'est pas un effet de combat r\xE9pertori\xE9", msg.content);
      return;
    }
    const evt = {
      type: 'Effet ' + effet
    };
    let lanceur = options.lanceur;
    let charId;
    if (lanceur) charId = lanceur.charId;
    getSelected(msg, function(selected, playerId) {
      let whisper = '';
      if (options.secret) {
        let player;
        if (playerId) player = getObj('player', playerId);
        if (player !== undefined) {
          whisper = '/w "' + player.get('displayname') + '" ';
        }
      }
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lection\xE9e pour l'effet", playerId);
        return;
      }
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine de l'effet", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) charId = lanceur.charId;
        }
      }
      if (lanceur && options.tempeteDeMana) {
        if (options.tempeteDeMana.cout === 0) {
          //On demande de pr\xE9ciser les options
          let optMana = {
            mana: options.mana,
            dm: messageEffetCombat[effet].dm,
            soins: messageEffetCombat[effet].soins,
            portee: options.portee,
            altruiste: options.altruiste,
            rang: options.rang
          };
          setTempeteDeMana(playerId, lanceur, msg.content, optMana);
          return;
        } else {
          if (options.rang && options.tempeteDeMana.cout > options.rang) {
            sendPerso(lanceur, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort", options.secret);
          }
          if (selected.length == 1 && options.tempeteDeMana.altruiste) {
            selected[0]._id = options.tempeteDeMana.altruiste.token.id;
            if (options.portee === undefined) options.portee = 0;
          }
        }
      }
      if (options.portee !== undefined) {
        if (options.puissantPortee || options.tempeteDeManaPortee) options.portee = options.portee * 2;
        selected = selected.filter(function(sel) {
          let token = getObj('graphic', sel._id);
          let dist = distanceCombat(lanceur.token, token);
          if (dist > options.portee) {
            whisperChar(charId, " est trop loin de " + token.get('name'));
            return false;
          }
          return true;
        });
      }
      if (selected.length === 0) return;
      if (limiteRessources(lanceur, options, effet, effet, evt)) {
        addEvent(evt);
        return;
      }
      initiative(selected, evt);
      let mEffet = messageEffetCombat[effet];
      let img = options.image;
      let extraImg = '';
      if (img !== "" && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
        extraImg = '<span style="padding: 4px 0;" >  ';
        extraImg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
        extraImg += '</span>';
      }
      iterSelected(selected, function(perso) {
        if (effet == 'blessureQuiSaigne' && predicateAsBool(perso, 'immuniteSaignement')) {
          sendPerso(perso, "ne saigne pas");
          return;
        }
        let actMsg = messageActivation(perso, mEffet) + extraImg;
        let effetAttr = setTokenAttr(perso, effet, true, evt, {
          msg: whisper + actMsg
        });
        if (options.lanceur && options.mana !== undefined && mEffet.prejudiciable) {
          addEffetTemporaireLie(options.lanceur, effetAttr, evt);
        }
        if (options.puissant) {
          let puissant = (options.puissant != 'off');
          setTokenAttr(perso, effet + 'Puissant', puissant, evt);
        }
        if (options.valeur !== undefined) {
          setTokenAttr(perso, effet + 'Valeur', options.valeur, evt, {
            maxVal: options.valeurMax
          });
        }
        if (options.optionsEffet !== undefined) {
          setTokenAttr(perso, effet + 'Options', options.optionsEffet, evt);
        }
        if (options.saveParTour) {
          setTokenAttr(perso, effet + 'SaveParTour', options.saveParTour.carac, evt, {
            maxVal: options.saveParTour.seuil
          });
        }
        if (options.saveActifParTour) {
          setTokenAttr(perso, effet + 'SaveActifParTour', options.saveActifParTour.carac, evt, {
            maxVal: options.saveActifParTour.seuil
          });
        }
        if (options.tempeteDeManaIntense !== undefined) {
          setTokenAttr(perso, effet + 'TempeteDeManaIntense', options.tempeteDeManaIntense, evt);
        }
      });
      addEvent(evt);
      if (lanceur && options.fx) {
        iterSelected(selected, function(target) {
          let p1e = {
            x: lanceur.token.get('left'),
            y: lanceur.token.get('top'),
          };
          let p2e = {
            x: target.token.get('left'),
            y: target.token.get('top'),
          };
          spawnFxBetweenPoints(p1e, p2e, options.fx, options.pageId);
        });
      }
      if (options.son) playSound(options.son);
      if (options.targetFx) {
        iterSelected(selected, function(target) {
          spawnFx(target.token.get('left'), target.token.get('top'), options.targetFx, options.pageId);
        });
      }
      if (options.degainer !== undefined) {
        if (lanceur) {
          degainerArme(lanceur, options.degainer, evt);
        } else if (selected.length === 1) {
          iterSelected(selected, function(target) {
            degainerArme(target, options.degainer, evt);
          });
        }
      }
      if (options.montreActions) {
        if (lanceur) {
          turnAction(lanceur, playerId);
        } else if (selected.length === 1) {
          iterSelected(selected, function(target) {
            turnAction(target, playerId);
          });
        }
      }
    });
  }

  function parseEffetIndetermine(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-effet", msg.content);
      return;
    }
    let effet = cmd[1];
    if (!estEffetIndetermine(effet)) {
      error(effet + " n'est pas un effet r\xE9pertori\xE9", msg.content);
      return;
    }
    let activer;
    let valeur;
    if (cmd.length > 2) {
      switch (cmd[2]) {
        case 'oui':
        case 'Oui':
        case 'true':
        case 'd\xE9but':
        case 'debut':
          valeur = true;
          activer = true;
          break;
        case 'non':
        case 'Non':
        case 'false':
        case 'fin':
          valeur = false;
          activer = false;
          break;
        default:
          valeur = parseInt(cmd[2]);
          if (isNaN(valeur)) {
            error("Option de !cof-effet inconnue", cmd);
            return;
          }
          activer = valeur !== 0;
          if (cmd[2].startsWith('+') || valeur < 0)
            options.valeurAjoutee = valeur;
      }
    }
    let lanceur = options.lanceur;
    let charId;
    if (lanceur) charId = lanceur.charId;
    getSelected(msg, function(selected, playerId, aoe) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lection\xE9e pour l'effet", playerId);
        return;
      }
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine de l'effet", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) {
            options.lanceur = lanceur;
            charId = lanceur.charId;
          }
        }
      }
      if (lanceur && options.tempeteDeMana) {
        if (options.rang && options.tempeteDeMana.cout > options.rang) {
          sendPlayer(msg, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
        }
        if (selected.length == 1 && options.tempeteDeMana.altruiste) {
          selected[0]._id = options.tempeteDeMana.altruiste.token.id;
          if (options.portee === undefined) options.portee = 0;
        }
      }
      let cibles = [];
      iterSelected(selected, function(perso) {
        if (options.portee !== undefined) {
          if (options.puissantPortee || options.tempeteDeManaPortee) options.portee = options.portee * 2;
          let dist = distanceCombat(lanceur.token, perso.token);
          if (dist > options.portee) {
            sendPerso(perso, " est trop loin de " + nomPerso(perso));
            return;
          }
        }
        if (activer && valeur === true) {
          if (attributeAsBool(perso, effet)) return;
        } else if (!activer && valeur === false) {
          if (!attributeAsBool(perso, effet)) return;
        }
        cibles.push(perso);
      });
      if (cibles.length == 0) {
        return;
      }
      if (activer === undefined) {
        if (cibles.length > 1) {
          sendPlayer(msg, "On ne peut s\xE9lectionner qu'un token si on ne pr\xE9cise pas si il faut activer ou d\xE9sactiver l'effet");
          return;
        }
        let perso = persoOfId(selected[0]._id);
        if (!perso) {
          error("Token s\xE9lectionn\xE9 non valide", selected);
          return;
        }
        activer = !attributeAsBool(perso, effet);
      }
      effetIndetermine(playerId, cibles, effet, activer, valeur, options);
    }, options);
  }

  //L'effet de grandeTaille sur le token
  function grandeTaille(perso, evt) {
    if (attributeAsBool(perso, 'tailleDeTokenNormale')) return;
    let character = getObj('character', perso.charId);
    if (character === undefined) {
      error("Personnage introuvable", perso);
      return;
    }
    perso.taille = undefined;
    let token = perso.token;
    character.get('_defaulttoken', function(normalToken) {
      if (normalToken === '') return;
      normalToken = JSON.parse(normalToken);
      let nw = normalToken.width;
      let nh = normalToken.height;
      //Rien \xE0 faire si le token occupe d\xE9j\xE0 une case
      if (nw >= PIX_PER_UNIT || nh >= PIX_PER_UNIT) return;
      setTokenAttr(perso, 'tailleDeTokenNormale', nw, evt, {
        maxVal: nh
      });
      evt.defaultTokens = evt.defaultTokens || [];
      evt.defaultTokens.push({
        character: character,
        defaultToken: {...normalToken
        }
      });
      //Les facteurs d'agrandissement
      let fw = PIX_PER_UNIT / nw;
      let fh = PIX_PER_UNIT / nh;
      let f = Math.min(fw, fh);
      normalToken.width = f * nw;
      normalToken.height = f * nh;
      let width = token.get('width');
      let height = token.get('height');
      affectToken(token, 'width', width, evt);
      affectToken(token, 'height', height, evt);
      setDefaultTokenFromSpec(character, normalToken, token);
      token.set('width', f * width);
      token.set('height', f * height);
    });
  }

  function finDeGrandeTaille(perso, evt) {
    let attr = tokenAttribute(perso, 'tailleDeTokenNormale');
    if (attr.length === 0) return;
    attr = attr[0];
    let nw = parseInt(attr.get('current'));
    let nh = parseInt(attr.get('max'));
    if (isNaN(nw) || isNaN(nh)) {
      error("La taille de token sauvegard\xE9e n'est pas correcte", attr);
      attr.remove();
    }
    let character = getObj('character', perso.charId);
    if (character === undefined) {
      error("Personnage introuvable", perso);
      return;
    }
    let token = perso.token;
    character.get('_defaulttoken', function(currentToken) {
      if (currentToken === '') return;
      currentToken = JSON.parse(currentToken);
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attr);
      attr.remove();
      evt.defaultTokens = evt.defaultTokens || [];
      evt.defaultTokens.push({
        character: character,
        defaultToken: {...currentToken
        }
      });
      let width = token.get('width');
      let height = token.get('height');
      affectToken(token, 'width', width, evt);
      affectToken(token, 'height', height, evt);
      let ntw = nw;
      let nth = nh;
      if (width != currentToken.width)
        ntw = nw * width / currentToken.width;
      if (height != currentToken.height)
        nth = nh * height / currentToken.height;
      currentToken.width = nw;
      currentToken.height = nh;
      setDefaultTokenFromSpec(character, currentToken, token);
      token.set('width', ntw);
      token.set('height', nth);
    });
  }

  function effetIndetermine(playerId, cibles, effet, activer, valeur, options) {
    const evt = {
      type: 'Effet',
      action: {
        titre: "Effet " + effet,
        playerId,
        cibles,
        effet,
        activer,
        valeur,
        options
      }
    };
    addEvent(evt);
    let lanceur = options.lanceur;
    let whisper = '';
    if (options.secret && playerId) {
      let player = getObj('player', playerId);
      if (player !== undefined) {
        whisper = '/w "' + player.get('displayname') + '" ';
      }
    }
    if (activer) {
      if (limiteRessources(lanceur, options, effet, effet, evt)) {
        return;
      }
      if (options.classeEffet) {
        cibles = cibles.filter(function(perso) {
          if (perso === undefined) return false;
          if (attributeAsBool(perso, options.classeEffet)) {
            let attrDeClasse = attributesOfClass(perso, options.classeEffet);
            let mpc = "Non cumulable avec";
            attrDeClasse.forEach(function(attrClasseEffet) {
              let attr = attrClasseEffet.baseAttribute;
              let attrName = attr.get('name');
              if (estEffetIndetermine(attrName))
                mpc += ' ' + messageActif(perso, messageEffetIndetermine[effetIndetermineOfAttribute(attr)]);
              else mpc += ' ' + attrName;
            });
            sendPerso(perso, mpc, options.secret);
            return false;
          }
          setTokenAttr(perso, options.classeEffet, true, evt);
          setTokenAttr(perso, effet + 'ClasseEffet', options.classeEffet, evt);
          return true;
        });
      }
      cibles.forEach(function(perso) {
        let expliquer = function(s) {
          sendPerso(perso, s);
        };
        let doit = function() {
          if (options.valeurAjoutee) {
            addToAttributeAsInt(perso, effet, 0, options.valeurAjoutee, evt);
            expliquer(effet + " varie de " + options.valeurAjoutee, options.secret);
          } else {
            setTokenAttr(
              perso, effet, valeur, evt, {
                msg: whisper + messageActivation(perso, messageEffetIndetermine[effet])
              });
            switch (effet) {
              case 'foretVivanteEnnemie':
                if (stateCOF.combat) updateNextInit(perso);
                break;
              case 'sangDeLArbreCoeur':
                guerisonPerso(perso, evt);
                break;
              case 'grandeTaille':
                grandeTaille(perso, evt);
                break;
            }
          }
          if (options.puissant) {
            let puissant = (options.puissant != 'off');
            setTokenAttr(perso, effet + 'Puissant', puissant, evt);
          }
          if (options.valeur !== undefined) {
            setTokenAttr(perso, effet + 'Valeur', options.valeur, evt, {
              maxVal: options.valeurMax
            });
          }
          if (options.tempeteDeManaIntense !== undefined) {
            setTokenAttr(perso, effet + 'TempeteDeManaIntense', options.tempeteDeManaIntense, evt);
          }
          if (options.messages) {
            options.messages.forEach(function(m) {
              sendChat('', whisper + m);
            });
          }
          if (options.messagesMJ) {
            options.messagesMJ.forEach(function(m) {
              sendChar(perso.charId, '/w gm ' + m);
            });
          }
        };
        if (options.save) {
          let saveOpts = {
            msgPour: options.save.msgPour || " pour r\xE9sister \xE0 l'effet " + effet,
            msgRate: ", rat\xE9.",
            silencieuxSiPasAffecte: options.silencieuxSiPasAffecte,
            attaquant: lanceur,
            rolls: options.rolls,
            chanceRollId: options.chanceRollId,
            type: options.type
          };
          let saveId = 'effet_' + effet + "_" + perso.token.id;
          save(options.save, perso, saveId, expliquer, saveOpts, evt,
            function(reussite, rollText) {
              if (!reussite) doit();
            });
        } else {
          doit();
        }
      });
    } else {
      cibles.forEach(function(perso) {
        //On commence par enlever les attributs de classe d'effet, si besoin
        let ace = tokenAttribute(perso, effet + 'ClasseEffet');
        if (ace.length > 0) {
          let ce = ace[0].get('current');
          removeTokenAttr(perso, ce, evt);
          evt.deletedAttributes = evt.deletedAttributes || [];
          evt.deletedAttributes.push(ace[0]);
          ace[0].remove();
        }
        removeTokenAttr(perso, effet, evt, {
          msg: messageFin(perso, messageEffetIndetermine[effet])
        });
        removeTokenAttr(perso, effet + 'Puissant', evt);
        removeTokenAttr(perso, effet + 'Valeur', evt);
        removeTokenAttr(perso, effet + 'TempeteDeManaIntense', evt);
        removeTokenAttr(perso, effet + 'Options', evt);
        switch (effet) {
          case 'foretVivanteEnnemie':
            if (stateCOF.combat) updateNextInit(perso);
            break;
          case 'grandeTaille':
            finDeGrandeTaille(perso, evt);
            break;
        }
        if (options.messages) {
          options.messages.forEach(function(m) {
            sendChat('', whisper + m);
          });
        }
        if (options.messagesMJ) {
          options.messagesMJ.forEach(function(m) {
            sendChar(perso.charId, '/w gm ' + m);
          });
        }
      });
    }
  }

  function finClasseDEffet(msg) {
    let cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il manque l'argument de !cof-fin-classe-effet", cmd);
      return;
    }
    let classeEffet = cmd[1];
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("Pas de cible s\xE9lectionn\xE9e pour la fin d'une classe d'effets", msg);
        return;
      }
      const evt = {
        type: "Fin des effets de classe " + classeEffet,
        deletedAttributes: []
      };
      iterSelected(selected, function(perso) {
        if (attributeAsBool(perso, classeEffet)) {
          let attrDeClasse = attributesOfClass(perso, classeEffet);
          attrDeClasse.forEach(function(adc) {
            let attrName = adc.baseAttribute.get('name');
            if (estEffetIndetermine(attrName)) {
              let mf = messageFin(perso, messageEffetIndetermine[effetIndetermineOfAttribute(adc.baseAttribute)]);
              if (mf && mf !== '')
                sendPerso(perso,
                  messageFin(perso, messageEffetIndetermine[effetIndetermineOfAttribute(adc.baseAttribute)]));
            }
            evt.deletedAttributes.push(adc.baseAttribute);
            adc.baseAttribute.remove();
            evt.deletedAttributes.push(adc.classAttribute);
            adc.classAttribute.remove();
          });
          removeTokenAttr(perso, classeEffet, evt);
        }
      });
      addEvent(evt);
    }); //fin de getSelected
  }

  function peurOneToken(target, difficulte, duree, options, messages, evt, callback) {
    const targetName = nomPerso(target);
    if (predicateAsBool(target, 'sansPeur') ||
      predicateAsBool(target, 'immunite_peur') ||
      predicateAsBool(target, 'proprioception') ||
      predicateAsBool(target, 'sansEsprit') ||
      attributeAsBool(target, 'enrage') ||
      predicateAsBool(target, 'liberteDAction')) {
      messages.push(targetName + " est insensible \xE0 la peur !");
      callback();
      return;
    }
    if (options.immuniseSiResiste && attributeAsBool(target, options.immuniseSiResiste)) {
      messages.push(targetName + " a d\xE9j\xE0 r\xE9sist\xE9 \xE0 cet effet, " + onGenre(target, 'il', 'elle') + " n'y est plus sensible");
      callback();
      return;
    }
    let carac = 'SAG'; //carac pour r\xE9sister
    if (options.resisteAvecForce)
      carac = meilleureCarac('SAG', 'FOR', target, difficulte);
    //chercher si un partenaire a sansPeur pour appliquer le bonus
    let allieSansPeur = 0;
    let msgAllieSansPeur;
    let allies = alliesParPerso[target.charId];
    if (allies) {
      const pageId = options.pageId || target.token.get('pageid');
      let allTokens;
      allies.forEach(function(cid) {
        if (charPredicateAsBool(cid, 'sansPeur')) {
          //On cherche si l'alli\xE9 est pr\xE9sent sur la m\xEAme page
          allTokens = allTokens ||
            findObjs({
              _type: "graphic",
              _pageid: pageId,
              _subtype: "token",
              layer: "objects"
            });
          let alliePresent = allTokens.find(function(tok) {
            return tok.get('represents') == cid;
          });
          if (alliePresent) {
            let bonusAllie = 2 + modCarac(cid, 'charisme');
            if (bonusAllie > allieSansPeur) {
              allieSansPeur = bonusAllie;
              let allie = {
                charId: cid,
                token: alliePresent
              };
              msgAllieSansPeur = nomPerso(allie) + " a donn\xE9 +" + bonusAllie + " au jet";
            }
          }
        }
      });
    }
    let optionsPeur = {...options
    };
    optionsPeur.bonus = allieSansPeur;
    optionsPeur.bonus += predicateAsInt(target, 'courage', 0);
    let testId = 'peurOne_' + target.token.id;
    testCaracteristique(target, carac, difficulte, testId, optionsPeur, evt,
      function(tr, explications) {
        let line = targetName + " fait " + tr.texte;
        let sujet = onGenre(target, 'il', 'elle');
        if (tr.reussite) {
          line += ",  " + sujet + " r\xE9siste \xE0 la peur." + tr.modifiers;
          if (options.immuniseSiResiste)
            setTokenAttr(target, options.immuniseSiResiste, true, evt);
        } else {
          line += ", " + sujet + ' ';
          let effet = 'apeureTemp';
          let etat = 'apeure';
          if (options.etourdi) {
            line += "s'enfuit ou reste recroquevill\xE9" + eForFemale(target) + " sur place";
            effet = 'peurEtourdi';
          } else if (options.ralenti) {
            line += "est ralenti" + eForFemale(target);
            effet = 'ralentiTemp';
            etat = 'ralenti';
          } else if (options.secoue && !attributeAsBool(target, 'secoue')) {
            line += "est secou\xE9" + eForFemale(target);
            effet = 'secoue';
            etat = false;
          } else {
            line += "s'enfuit.";
          }
          line += tr.rerolls + tr.modifiers;
          if (etat) setState(target, etat, true, evt);
          setAttrDuree(target, effet, duree, evt);
        }
        messages.push(line);
        if (allieSansPeur) messages.push(msgAllieSansPeur);
        explications.forEach(function(p) {
          messages.push(p);
        });
        callback();
      }); //fin testCaracteristique (asynchrone)
  }

  function parsePeur(msg) {
    let optArgs = msg.content.split(' --');
    let cmd = optArgs[0].split(' ');
    if (cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-peur", msg.content);
      return;
    }
    let playerId = getPlayerIdFromMsg(msg);
    let pageId = getPageId(playerId);
    let difficulte = parseInt(cmd[1]);
    if (isNaN(difficulte)) {
      error("Le premier argument de !cof-peur, la difficult\xE9 du test de r\xE9sistance, n'est pas un nombre", cmd);
      return;
    }
    let duree = parseDice(cmd[2], "dur\xE9e de peur");
    if (!dePositif(duree)) {
      error("Le second argument de !cof-peur, la dur\xE9e, n'est pas un nombre positif", cmd);
      return;
    }
    let options = {};
    options.playerId = playerId;
    options.pageId = pageId;
    optArgs.shift();
    optArgs.forEach(function(opt) {
      let optCmd = opt.split(' ');
      switch (optCmd[0]) {
        case 'resisteAvecForce':
        case 'etourdi':
        case 'ralenti':
        case 'effroi':
        case 'secoue':
          options[optCmd[0]] = true;
          return;
        case 'portee':
          if (optCmd.length < 2) {
            error("Il manque l'argument de port\xE9e", optArgs);
            return;
          }
          options.portee = parseInt(optCmd[1]);
          if (isNaN(options.portee) || options.portee < 0) {
            error("La port\xE9e n'est pas un nombre positif", optCmd);
            delete options.portee;
          }
          return;
        case 'lanceur':
          if (optCmd.length < 2) {
            error("Il manque l'argument de lanceur", optArgs);
            return;
          }
          options.lanceur = persoOfId(optCmd[1], optCmd[1]);
          if (options.lanceur) pageId = options.lanceur.token.get('pageid');
          return;
        case 'titre':
          if (optCmd.length < 2) {
            error("Il manque le titre de l'action", optArgs);
            return;
          }
          options.titre = optCmd.slice(1).join(' ');
          return;
        case 'immuniseSiResiste':
          if (optCmd.length < 2) {
            error("Il manque l'argument de l'effet de peur", optArgs);
            return;
          }
          options.immuniseSiResiste = 'immunise24HA_' + optCmd[1];
          return;
        default:
          return;
      }
    });
    let cibles = [];
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("Pas de cible s\xE9lectionn\xE9e pour la peur", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        if (options.portee !== undefined && options.lanceur) {
          let distance = distanceCombat(options.lanceur.token, perso.token, pageId);
          if (distance > options.portee) {
            return;
          }
        }
        perso.duree = rollDePlus(duree).val;
        cibles.push(perso);
      });
    });
    if (cibles.length > 0) {
      doPeur(cibles, difficulte, options);
    } else {
      error("Aucune cible valable \xE0 port\xE9e de l'effet de Peur", msg);
    }
  }

  function doPeur(cibles, difficulte, options) {
    let evt = {
      type: 'peur',
      action: {
        cibles: cibles,
        difficulte: difficulte,
        options: options
      }
    };
    addEvent(evt);
    let action = "Effet de peur";
    if (options.lanceur) {
      action = "<b>" + nomPerso(options.lanceur) + "</b> ";
      if (options.titre) action += options.titre;
      else if (options.effroi)
        action += "est vraiment effrayant" + eForFemale(options.lanceur);
      else action = "<b>Capacit\xE9</b> : Sort de peur";
    } else if (options.titre) action = options.titre;
    let messages = [];
    entrerEnCombat(options.lanceur, cibles, messages, evt);
    let display = startFramedDisplay(options.playerId, action, options.lanceur);
    let jet = " Jet de SAG ";
    if (options.resisteAvecForce) jet += "ou FOR ";
    jet += "difficult\xE9 " + difficulte;
    addLineToFramedDisplay(display, jet, 80);
    let counter = cibles.length;
    let finalDisplay = function() {
      counter--;
      if (messages.length > 0) {
        let m = messages.shift();
        addLineToFramedDisplay(display, m);
        while (messages.length > 0) {
          m = messages.shift();
          addLineToFramedDisplay(display, m, 80, false);
        }
      }
      if (counter < 1) {
        sendChat('', endFramedDisplay(display));
      }
    };
    cibles.forEach(function(perso) {
      peurOneToken(perso, difficulte, perso.duree, options, messages, evt, finalDisplay);
    });
  }

  function parseAttaqueMagique(msg, type) {
    let options = parseOptions(msg);
    if (options === undefined || options.cmd === undefined) return;
    let cmd = options.cmd;
    if (cmd.length < 3) {
      error("Il faut au moins 2 arguments \xE0 !cof-attaque-magique", cmd);
      return;
    }
    let attaquant = persoOfId(cmd[1], cmd[1]);
    let cible = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined || cible === undefined) {
      error("Arguments de !cof-attaque-magique", cmd);
      return;
    }
    if (options.portee) {
      let distance = distanceCombat(attaquant.token, cible.token, options.pageId);
      if (distance > options.portee) {
        sendPerso(attaquant, "est trop loin de " + nomPerso(cible) +
          " pour l'attaque magique");
        return;
      }
    }
    type = type || '';
    switch (type) {
      case 'tueurFantasmagorique':
        tueurFantasmagorique(getPlayerIdFromMsg(msg), attaquant, cible, options);
        break;
      case 'injonction':
        injonction(getPlayerIdFromMsg(msg), attaquant, cible, options);
        break;
      default:
        attaqueMagiqueOpposee(getPlayerIdFromMsg(msg), attaquant, cible, options);
        break;
    }
  }

  // callback est seulement appel\xE9 si on fait le test
  // evt est facultatif ; si absent, en cr\xE9e un nouveau g\xE9n\xE9rique et l'ajoute \xE0 l'historique
  function attaqueMagiqueOpposee(playerId, attaquant, cible, options, callback, evt) {
    if (options.attaqueMentale) {
      if (predicateAsBool(cible, 'sansEsprit') || predicateAsBool(cible, 'vegetatif')) {
        sendPerso(attaquant, " est sans esprit, " + onGenre(cible, 'il', 'elle') +
          " est immunis\xE9" + onGenre(cible, '', 'e') + " aux attaques mentales.");
        return;
      } else if (predicateAsBool(cible, 'liberteDAction')) {
        sendPerso(cible, "reste libre de ses actions !");
        return;
      }
    }
    let explications = options.messages || [];
    if (!evt) {
      evt = {
        type: 'attaqueMagique',
        action: {
          titre: "Attaque magique",
          attaquant: attaquant,
          cible: cible,
          options: options
        }
      };
      addEvent(evt);
    } else if (!evt.action) {
      evt.action = {
        titre: "Attaque magique",
        attaquant: attaquant,
        cible: cible,
        options: options
      };
    }
    entrerEnCombat(attaquant, [cible], explications, evt);
    if (limiteRessources(attaquant, options, 'attaqueMagique', "l'attaque magique", evt)) {
      return;
    }
    let bonus1 = bonusDAttaque(attaquant, explications, evt);
    if (bonus1 === 0) bonus1 = "";
    else if (bonus1 > 0) bonus1 = " +" + bonus1;
    let attk1 = addOrigin(attaquant.token.get("name"), "[[" + computeArmeAtk(attaquant, '@{ATKMAG}') +
      bonus1 + "]]");
    let bonus2 = bonusDAttaque(cible, explications, evt);
    if (bonus2 === 0) bonus2 = "";
    else if (bonus2 > 0) bonus2 = " +" + bonus2;
    let attk2 = addOrigin(cible.token.get("name"), "[[" + computeArmeAtk(cible, '@{ATKMAG}') +
      bonus1 + "]]");
    let de1 = computeDice(attaquant);
    let de2 = computeDice(cible);
    let toEvaluate = "[[" + de1 + "]] [[" + de2 + "]] " + attk1 + " " + attk2;
    sendChat("", toEvaluate, function(res) {
      let rolls = res[0];
      options.rolls = options.rolls || {};
      // Determine which roll number correspond to which expression
      let afterEvaluate = rolls.content.split(" ");
      let att1RollNumber = rollNumber(afterEvaluate[0]);
      let att2RollNumber = rollNumber(afterEvaluate[1]);
      let attk1SkillNumber = rollNumber(afterEvaluate[2]);
      let attk2SkillNumber = rollNumber(afterEvaluate[3]);
      let roll1 = (options.rolls && options.rolls.roll1) ? options.rolls.roll1 : rolls.inlinerolls[att1RollNumber];
      let atk1 = (options.rolls && options.rolls.atk1) ? options.rolls.atk1 : rolls.inlinerolls[attk1SkillNumber];
      let roll2 = (options.rolls && options.rolls.roll2) ? options.rolls.roll2 : rolls.inlinerolls[att2RollNumber];
      let atk2 = (options.rolls && options.rolls.atk2) ? options.rolls.atk2 : rolls.inlinerolls[attk2SkillNumber];
      roll1.token = attaquant.token;
      atk1.token = attaquant.token;
      roll2.token = cible.token;
      atk2.token = cible.token;
      evt.action.rolls = evt.action.rolls || {};
      evt.action.rolls.roll1 = roll1;
      evt.action.rolls.atk1 = atk1;
      evt.action.rolls.roll2 = roll2;
      evt.action.rolls.atk2 = atk2;
      let d20roll1 = roll1.results.total;
      if (stateCOF.foudreDuTemps) foudreDuTemps(attaquant, d20roll1);
      let att1Skill = atk1.results.total;
      if (estAffaibli(attaquant) && predicateAsBool(attaquant, 'insensibleAffaibli')) att1Skill -= 2;
      let attackRoll1 = d20roll1 + att1Skill;
      if (options.chanceRollId && options.chanceRollId.roll1)
        attackRoll1 += options.chanceRollId.roll1;
      let d20roll2 = roll2.results.total;
      if (stateCOF.foudreDuTemps) foudreDuTemps(cible, d20roll2);
      let att2Skill = atk2.results.total;
      if (estAffaibli(cible) && predicateAsBool(cible, 'insensibleAffaibli')) att2Skill -= 2;
      let attackRoll2 = d20roll2 + att2Skill;
      if (options.chanceRollId && options.chanceRollId.roll2)
        attackRoll2 += options.chanceRollId.roll2;
      let action = "Attaque magique oppos\xE9e";
      let reussi;
      if (d20roll1 == 1) {
        if (d20roll2 == 1) reussi = (attackRoll1 >= attackRoll2);
        else reussi = false;
      } else if (d20roll2 == 1) reussi = true;
      else if (d20roll1 == 20) {
        if (d20roll2 == 20) reussi = (attackRoll1 >= attackRoll2);
        else reussi = true;
      } else reussi = (attackRoll1 >= attackRoll2);
      const display = startFramedDisplay(playerId, action, attaquant, {
        perso2: cible
      });
      let line = nomPerso(attaquant) + " fait " + buildinline(roll1);
      if (att1Skill > 0) line += "+" + att1Skill;
      else if (att1Skill < 0) line += att1Skill;
      if (options.chanceRollId && options.chanceRollId.roll1)
        line += "+" + options.chanceRollId.roll1;
      line += " = " + attackRoll1;
      if (!reussi) {
        var pcAttaquant = pointsDeChance(attaquant);
        if (pcAttaquant > 0)
          line += "<br/>" + boutonSimple("!cof-bouton-chance " + evt.id + " roll1", "Chance") +
          " (reste " + pcAttaquant + " PC)";
        if (predicateAsInt(attaquant, 'pacteSanglant', 0) >= 3) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 roll1", "Pacte sanglant (+3)");
        }
        if (predicateAsInt(attaquant, 'pacteSanglant', 0) >= 5) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 roll1", "Pacte sanglant (+5)");
        }
      }
      addLineToFramedDisplay(display, line);
      line = nomPerso(cible) + " fait " + buildinline(roll2);
      if (att2Skill > 0) line += "+" + att2Skill;
      else if (att2Skill < 0) line += att2Skill;
      if (options.chanceRollId && options.chanceRollId.roll2)
        line += "+" + options.chanceRollId.roll2;
      line += " = " + attackRoll2;
      if (reussi) {
        var pcCible = pointsDeChance(cible);
        if (pcCible > 0)
          line += "<br/>" + boutonSimple("!cof-bouton-chance " + evt.id + " roll2", "Chance") +
          " (reste " + pcCible + " PC)";
        if (predicateAsInt(cible, 'pacteSanglant', 0) >= 3) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 roll2", "Pacte sanglant (+3)");
        }
        if (predicateAsInt(cible, 'pacteSanglant', 0) >= 5) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 roll2", "Pacte sanglant (+5)");
        }
      }
      addLineToFramedDisplay(display, line);
      if (reussi) {
        diminueMalediction(cible, evt);
        addLineToFramedDisplay(display, "<b>Attaque r\xE9ussie !</b>");
      } else {
        diminueMalediction(attaquant, evt);
        addLineToFramedDisplay(display, "<b>L'attaque \xE9choue.</b>");
      }
      explications.forEach(explication => addLineToFramedDisplay(display, explication, 80));
      if (callback) callback(display, reussi);
      else {
        sendChat("", endFramedDisplay(display));
      }
    });
  }

  function injonction(playerId, attaquant, cible, options) {
    options.attaqueMentale = true;
    const evt = {
      type: 'injonction',
      action: {
        titre: "Injonction",
        attaquant: attaquant,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    attaqueMagiqueOpposee(playerId, attaquant, cible, options,
      function(display, reussi) {
        if (reussi) {
          if (attributeAsBool(cible, 'immunise24HA_injonction')) {
            addLineToFramedDisplay(display, nomPerso(cible) + " a d\xE9j\xE0 r\xE9sist\xE9 \xE0 une injonction aujourd'hui, c'est sans effet");
          } else if (predicateAsBool(cible, 'liberteDAction')) {
            addLineToFramedDisplay(display, nomPerso(cible) + " reste libre de ses actions !");
          } else {
            addLineToFramedDisplay(display, nomPerso(cible) + " ob\xE9it \xE0 l'injonction");
          }
          sendChat("", endFramedDisplay(display));
        } else {
          setTokenAttr(cible, 'immunise24HA_injonction', true, evt);
          addLineToFramedDisplay(display, nomPerso(cible) + " n'ob\xE9it pas \xE0 l'injonction");
          sendChat("", endFramedDisplay(display));
        }
      }, evt);
  }

  function tueurFantasmagorique(playerId, attaquant, cible, options) {
    const evt = {
      type: 'tueurFantasmagorique',
      action: {
        titre: "Tueur Fantasmagorique",
        attaquant: attaquant,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    attaqueMagiqueOpposee(playerId, attaquant, cible, options,
      function(display, reussi) {
        if (reussi) {
          if (estNonVivant(cible)) {
            addLineToFramedDisplay(display, nomPerso(cible) + " n'est pas une cr\xE9ature vivante, il ne peut croire \xE0 sa mort");
            sendChat("", endFramedDisplay(display));
            return;
          }
          if (attributeAsBool(cible, 'tueurFantasmagorique')) {
            addLineToFramedDisplay(display, nomPerso(cible) + " a d\xE9j\xE0 \xE9t\xE9 victime d'un tueur fantasmagorique aujourd'hui, c'est sans effet");
            sendChat("", endFramedDisplay(display));
            return;
          }
          setTokenAttr(cible, 'tueurFantasmagorique', true, evt);
          var s = {
            carac: 'SAG',
            seuil: 10 + modCarac(attaquant, 'charisme')
          };
          var niveauAttaquant = ficheAttributeAsInt(attaquant, 'niveau', 1);
          var niveauCible = ficheAttributeAsInt(cible, 'niveau', 1);
          if (niveauCible > niveauAttaquant)
            s.seuil -= (niveauCible - niveauAttaquant) * 5;
          else if (niveauCible < niveauAttaquant)
            s.seuil += (niveauAttaquant - niveauCible);
          var expliquer = function(message) {
            addLineToFramedDisplay(display, message, 80);
          };
          var saveOpts = {
            msgPour: " pour r\xE9sister au tueur fantasmagorique",
            attaquant: attaquant,
            rolls: options.rolls,
            chanceRollId: options.chanceRollId,
            type: 'magique'
          };
          const saveId = 'tueurFantasmagorique_' + cible.token.id;
          save(s, cible, saveId, expliquer, saveOpts, evt,
            function(reussiteSave, texte) {
              if (reussiteSave) {
                addLineToFramedDisplay(display, nomPerso(cible) + " perd l'\xE9quilibre et tombe par terre");
                setState(cible, 'renverse', true, evt);
              } else { //save rat\xE9
                addLineToFramedDisplay(display, nomPerso(cible) + " succombe \xE0 ses pires terreurs");
                updateCurrentBar(cible, 1, 0, evt);
                setState(cible, 'mort', true, evt);
              }
              sendChat("", endFramedDisplay(display));
            });
        } else {
          setTokenAttr(cible, 'tueurFantasmagorique', true, evt);
          sendChat("", endFramedDisplay(display));
        }
      }, evt);
  }

  function parseInjonctionMortelle(msg) {
    var options = parseOptions(msg);
    if (options === undefined || options.cmd === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 3) {
      error("Il faut au moins 2 arguments \xE0 !cof-injonction-mortelle", cmd);
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    var cible = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined || cible === undefined) {
      error("Arguments de !cof-injonction-mortelle", cmd);
      return;
    }
    var distance = distanceCombat(attaquant.token, cible.token, options.pageId);
    if (distance > 30) {
      sendPerso(attaquant, "est trop loin de " + nomPerso(cible) +
        " pour l'injonction mortelle");
      return;
    }
    injonctionMortelle(getPlayerIdFromMsg(msg), attaquant, cible, options);
  }

  function injonctionMortelle(playerId, attaquant, cible, options) {
    var evt = {
      type: 'injonctionMortelle',
      action: {
        titre: "Injonction Mortelle",
        playerId: playerId,
        attaquant: attaquant,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    let explications = options.messages || [];
    entrerEnCombat(attaquant, [cible], explications, evt);
    const display = startFramedDisplay(playerId, evt.action.titre, attaquant, {
      perso2: cible
    });
    explications.forEach(msg => addLineToFramedDisplay(display, msg, 80));
    if (attributeAsBool(cible, 'injonctionMortelle')) {
      addLineToFramedDisplay(display, nomPerso(cible) + " a d\xE9j\xE0 \xE9t\xE9 victime d'une injonction mortelle ce combat, c'est sans effet");
      sendChat("", endFramedDisplay(display));
      return;
    }
    if (predicateAsBool(cible, 'liberteDAction')) {
      addLineToFramedDisplay(display, nomPerso(cible) + " reste libre de ses actions !");
      sendChat("", endFramedDisplay(display));
      return;
    }
    setTokenAttr(cible, 'injonctionMortelle', true, evt);
    let saveOpts = {
      msgPour: " pour r\xE9sister \xE0 l'injonction mortelle",
      msgRate: ", rat\xE9.",
      attaquant: attaquant,
      rolls: options.rolls,
      chanceRollId: options.chanceRollId,
      necromancie: true
    };
    let saveId = 'injonctionMortelle_' + cible.token.id;
    let expliquer = function(message) {
      addLineToFramedDisplay(display, message, 80);
    };
    save({
        carac: 'CON',
        seuil: 15,
        type: 'magique'
      }, cible, saveId, expliquer, saveOpts, evt,
      function(reussite, rollText) {
        if (reussite) {
          let nc = ficheAttributeAsInt(attaquant, "niveau", 0);
          let dmg = {
            type: 'normal',
            value: '2d6+' + nc
          };
          sendChat('', '[[' + dmg.value + ']]', function(resDmg) {
            dmg.roll = dmg.roll || resDmg[0];
            let afterEvaluateDmg = dmg.roll.content.split(' ');
            let dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
            dmg.total = dmg.roll.inlinerolls[dmgRollNumber].results.total;
            dmg.display = buildinline(dmg.roll.inlinerolls[dmgRollNumber], dmg.type, options.magique);
            let name = nomPerso(cible);
            let explicationsDmg = [];
            cible.attaquant = attaquant;
            dealDamage(cible, dmg, [], evt, false, options, explicationsDmg, function(dmgDisplay, dmgFinal) {
              addLineToFramedDisplay(display,
                name + " re\xE7oit " + dmgDisplay + " DM");
              explicationsDmg.forEach(function(e) {
                addLineToFramedDisplay(display, e, 80, false);
              });
              sendChat("", endFramedDisplay(display));
            });
          });
        } else {
          addLineToFramedDisplay(display, nomPerso(cible) + " meurt sous l'injonction mortelle !", 80);
          updateCurrentBar(cible, 1, 0, evt);
          setState(cible, 'mort', true, evt);
          sendChat("", endFramedDisplay(display));
        }
      });
  }

  function parseSommeil(msg) { //sort de sommeil
    var options = parseOptions(msg);
    if (options === undefined) return;
    var args = options.cmd;
    if (args.length < 2) {
      error("La fonction !cof-sommeil a besoin du nom ou de l'id du lanceur de sort", args);
      return;
    }
    var lanceur = persoOfId(args[1], args[1]);
    if (lanceur === undefined) {
      error("Aucun personnage nomm\xE9 " + args[1], args);
      return;
    }
    var casterCharId = lanceur.charId;
    var casterChar = getObj('character', casterCharId);
    if (casterChar === undefined) {
      error("Fiche de personnage manquante");
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lectionn\xE9e pour le sort de sommeil", playerId);
        return;
      }
      var cibles = [];
      iterSelected(selected, function(perso) {
        cibles.push(perso);
      });
      doSommeil(lanceur, cibles, options);
    }, {
      lanceur: lanceur
    });
  }

  function doSommeil(lanceur, cibles, options, ciblesSansSave, ciblesAvecSave) {
    var evt = {
      type: 'sommeil',
      action: {
        lanceur: lanceur,
        cibles: cibles,
        ciblesSansSave: ciblesSansSave,
        ciblesAvecSave: ciblesAvecSave,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'sommeil', "lancer un sort de sommeil", evt)) return;
    let casterCharName = lanceur.token.get("name");
    let cha = modCarac(lanceur, 'charisme');
    let attMagText =
      addOrigin(casterCharName, '[[' + computeArmeAtk(lanceur, '@{ATKMAG}') + ']]');
    sendChat("", "[[1d6]] [[" + attMagText + "]]", function(res) {
      evt.action.rolls = options.rolls || {};
      let rollD6Id = 'sommeilD6';
      let rolls = res[0];
      let afterEvaluate = rolls.content.split(" ");
      let d6RollNumber = rollNumber(afterEvaluate[0]);
      let attMagRollNumber = rollNumber(afterEvaluate[1]);
      let rollD6 = evt.action.rolls[rollD6Id] || rolls.inlinerolls[d6RollNumber];
      evt.action.rolls[rollD6Id] = rollD6;
      let nbTargetsMax = rollD6.results.total + cha;
      let action = "<b>Capacit\xE9</b> : Sort de sommeil (max " + nbTargetsMax + " cibles)";
      let display = startFramedDisplay(options.playerId, action, lanceur);
      let attMag = rolls.inlinerolls[attMagRollNumber].results.total;
      let targetsWithSave = [];
      let targetsWithoutSave = [];
      cibles.forEach(function(perso) {
        if (estNonVivant(perso) || predicateAsBool(perso, 'immunite_endormi')) { //le sort de sommeil n'affecte que les cr\xE9atures vivantes
          addLineToFramedDisplay(display, nomPerso(perso) + " n'est pas affect\xE9 par le sommeil");
          return;
        }
        if (predicateAsBool(perso, "liberteDAction")) {
          addLineToFramedDisplay(display, nomPerso(perso) + " reste libre de ses mouvements !");
          return;
        }
        let pv = perso.token.get('bar1_max');
        if (pv > 2 * attMag) {
          let line = nomPerso(perso) + " a trop de PV pour \xEAtre affect\xE9 par le sort";
          addLineToFramedDisplay(display, line);
        } else if (pv > attMag) {
          targetsWithSave.push(perso);
        } else {
          targetsWithoutSave.push(perso);
        }
      });
      var ciblesSansSave;
      if (evt.action.ciblesSansSave) {
        ciblesSansSave = evt.action.ciblesSansSave;
        nbTargetsMax -= ciblesSansSave.length;
      } else {
        ciblesSansSave = [];
        var i, r;
        if (targetsWithoutSave.length > nbTargetsMax) {
          i = 0; //position to decide
          while (nbTargetsMax > 0) {
            r = randomInteger(nbTargetsMax) + i;
            ciblesSansSave.push(targetsWithoutSave[r]);
            targetsWithoutSave[r] = targetsWithoutSave[i];
            i++;
            nbTargetsMax--;
          }
        } else {
          ciblesSansSave = targetsWithoutSave;
          nbTargetsMax -= ciblesSansSave.length;
        }
      }
      evt.action.ciblesSansSave = ciblesSansSave;
      ciblesSansSave.forEach(function(t) {
        setState(t, 'endormi', true, evt);
        addLineToFramedDisplay(display, nomPerso(t) + " s'endort");
      });
      if (nbTargetsMax > 0 && targetsWithSave.length > 0) {
        var ciblesAvecSave;
        if (evt.action.ciblesAvecSave) {
          ciblesAvecSave = evt.action.ciblesAvecSave;
          nbTargetsMax -= ciblesAvecSave.length;
        } else {
          ciblesAvecSave = [];
          if (targetsWithSave.length > nbTargetsMax) {
            var j = 0;
            while (nbTargetsMax > 0) {
              var ra = randomInteger(nbTargetsMax) + j;
              ciblesAvecSave.push(targetsWithSave[ra]);
              targetsWithSave[ra] = targetsWithSave[j];
              j++;
              nbTargetsMax--;
            }
          } else {
            ciblesAvecSave = targetsWithSave;
            nbTargetsMax -= ciblesAvecSave.length;
          }
        }
        var seuil = 10 + cha;
        var tokensToProcess = ciblesAvecSave.length;
        var finalize = function() {
          if (tokensToProcess == 1) {
            sendChat("", endFramedDisplay(display));
          }
          tokensToProcess--;
        };
        evt.action.ciblesAvecSave = ciblesAvecSave;
        ciblesAvecSave.forEach(function(perso) {
          var testId = 'resisteSommeil_' + perso.token.id;
          testCaracteristique(perso, 'SAG', seuil, testId, options, evt,
            function(tr) {
              var line = "Jet de r\xE9sistance de " + nomPerso(perso) + ": " + tr.texte;
              var sujet = onGenre(perso, 'il', 'elle');
              if (tr.reussite) {
                line += "&gt;=" + seuil + ",  " + sujet + " ne s'endort pas." + tr.modifiers;
              } else {
                setState(perso, 'endormi', true, evt);
                line += "&lt;" + seuil + ", " + sujet + " s'endort" + tr.rerolls + tr.modifiers;
              }
              addLineToFramedDisplay(display, line);
              finalize();
            });
        });
      } else { // all targets are without save
        sendChat("", endFramedDisplay(display));
      }
    });
  }

  //!cof-attaque-magique-contre-pv {selected|token_id} {target|token_id}
  function attaqueMagiqueContrePV(msg) {
    var options = parseOptions(msg);
    if (options === undefined || options.cmd === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 3) {
      error("Il faut au moins 2 arguments \xE0 !cof-attaque-magique-contre-pv", cmd);
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    var cible = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined || cible === undefined) {
      error("Arguments de !cof-attaque-magique-contre-pv incorrects", cmd);
      return;
    }
    if (options.portee !== undefined) {
      let distance = distanceCombat(attaquant.token, cible.token, options.pageId);
      if (distance > options.portee) {
        sendPerso(attaquant, "est trop loin de " + nomPerso(cible) +
          " pour l'attaque magique");
        return;
      }
    }
    let pvMax = parseInt(cible.token.get('bar1_max'));
    if (isNaN(pvMax)) {
      error("Token avec des PV max qui ne sont pas un nombre", cible.token);
      return;
    }
    const evt = {
      type: 'Attaque magique',
    };
    addEvent(evt);
    if (limiteRessources(attaquant, options, 'attaque magique', "l'attaque magique", evt)) return;
    var attaquantChar = getObj('character', attaquant.charId);
    if (attaquantChar === undefined) {
      error("Fiche de l'attaquant introuvable");
      return;
    }
    attaquant.name = attaquantChar.get('name'); //TODO: utile ?
    let playerId = options.playerId || getPlayerIdFromMsg(msg);
    let explications = [];
    let bonusA = bonusDAttaque(attaquant, explications, evt);
    if (bonusA === 0) bonusA = "";
    else if (bonusA > 0) bonusA = " +" + bonusA;
    let attMagText = addOrigin(attaquant.name, "[[" + computeArmeAtk(attaquant, '@{ATKMAG}') + bonusA + "]]");
    let de = computeDice(attaquant);
    var action = "<b>Attaque magique</b> (contre pv max)";
    var display = startFramedDisplay(playerId, action, attaquant, {
      perso2: cible
    });
    sendChat("", "[[" + de + "]] " + attMagText, function(res) {
      var rolls = res[0];
      var afterEvaluate = rolls.content.split(" ");
      var attRollNumber = rollNumber(afterEvaluate[0]);
      var attSkillNumber = rollNumber(afterEvaluate[1]);
      let d20roll = rolls.inlinerolls[attRollNumber].results.total;
      if (stateCOF.foudreDuTemps) foudreDuTemps(attaquant, d20roll);
      var attSkill = rolls.inlinerolls[attSkillNumber].results.total;
      if (estAffaibli(attaquant) && predicateAsBool(attaquant, 'insensibleAffaibli')) attSkill -= 2;
      var attackRoll = d20roll + attSkill;
      let line =
        nomPerso(attaquant) + " fait " +
        buildinline(rolls.inlinerolls[attRollNumber]);
      if (attSkill > 0) line += "+" + attSkill + " = " + attackRoll;
      else if (attSkill < 0) line += attSkill + " = " + attackRoll;
      addLineToFramedDisplay(display, line);
      var reussi;
      if (d20roll == 1) reussi = false;
      else if (d20roll == 20) reussi = true;
      else reussi = (attackRoll >= pvMax);
      if (reussi) {
        addLineToFramedDisplay(display, "<b>Attaque r\xE9ussie !</b>");
      } else {
        diminueMalediction(attaquant, evt);
        addLineToFramedDisplay(display, "<b>L'attaque \xE9choue.</b>");
      }
      sendChat("", endFramedDisplay(display));
    }); //Fin du jet de d\xE9s pour l'attaque
  }

  function transeGuerison(msg) {
    if (stateCOF.combat) {
      sendPlayer(msg, "Pas possible de m\xE9diter en combat");
      return;
    }
    var options = parseOptions(msg);
    if (options === undefined) return;
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lectionn\xE9e pour la transe de gu\xE9rison", playerId);
        return;
      }
      var evt = {
        type: "Transe de gu\xE9rison",
      };
      iterSelected(selected, function(perso) {
        var token = perso.token;
        if (attributeAsBool(perso, 'transeDeGu\xE9rison')) {
          sendPerso(perso, "a d\xE9j\xE0 m\xE9dit\xE9 depuis le dernier combat");
          return;
        }
        var bar1 = parseInt(token.get("bar1_value"));
        var pvmax = parseInt(token.get("bar1_max"));
        if (isNaN(bar1) || isNaN(pvmax)) return;
        if (bar1 >= pvmax) {
          sendPerso(perso, "n'a pas besoin de m\xE9diter");
          return;
        }
        var sagMod = modCarac(perso, 'sagesse');
        var niveau = ficheAttributeAsInt(perso, 'niveau', 1);
        var soin = niveau + sagMod;
        if (soin < 0) soin = 0;
        if (bar1 === 0) {
          if (attributeAsBool(perso, 'etatExsangue')) {
            removeTokenAttr(perso, 'etatExsangue', evt, {
              msg: "retrouve des couleurs"
            });
          }
        }
        bar1 += soin;
        if (bar1 > pvmax) {
          soin -= (bar1 - pvmax);
          bar1 = pvmax;
        }
        updateCurrentBar(perso, 1, bar1, evt);
        setTokenAttr(perso, 'transeDeGu\xE9rison', true, evt);
        sendPerso(perso, "entre en m\xE9ditation pendant 10 minutes et r\xE9cup\xE8re " + soin + " points de vie.");
      });
      addEvent(evt);
    });
  }

  function raceIs(perso, race) {
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    return (perso.race.includes(race.toLowerCase()));
  }

  function estFee(perso) {
    if (predicateAsBool(perso, 'f\xE9e')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'licorne':
      case 'farfadet':
      case 'fee':
      case 'f\xE9e':
      case 'pixie':
      case 'lutin':
        return true;
      default:
        return false;
    }
  }

  function estDemon(perso) {
    if (predicateAsBool(perso, 'd\xE9mon')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'd\xE9mon':
      case 'demon':
      case 'balor':
      case 'marilith':
      case 'quasit':
      case 'succube':
        return true;
      default:
        return false;
    }
  }

  function estDraconique(perso) {
    if (predicateAsBool(perso, 'dragon')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'dragon':
      case 'draconide':
      case 'kobold':
        return true;
      default:
        let mots = perso.race.split(' ');
        return mots.includes('dragon');
    }
  }

  function estMortVivant(perso) {
    if (predicateAsBool(perso, 'mortVivant')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'squelette':
      case 'zombie':
      case 'mort-vivant':
      case 'mort vivant':
      case 'momie':
      case 'goule':
      case 'vampire':
        return true;
      default:
        return false;
    }
  }

  function estGeant(perso) {
    if (predicateAsBool(perso, 'g\xE9ant')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'g\xE9ant':
      case 'geant':
      case 'ogre':
      case 'troll':
      case 'ettin':
      case 'cyclope':
      case 'yai':
        return true;
      default:
        return false;
    }
  }

  function estGobelin(perso) {
    if (predicateAsBool(perso, 'gobelin')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'gobelin':
      case 'gobelours':
      case 'hobgobelin':
      case 'wikkawak':
        return true;
      default:
        return false;
    }
  }

  function estNonVivant(perso) {
    return (predicateAsBool(perso, 'nonVivant') ||
      attributeAsBool(perso, 'masqueMortuaire') ||
      attributeAsBool(perso, 'masqueMortuaireAmeLiee') ||
      estMortVivant(perso));
  }

  function estElfeNoir(perso) {
    if (predicateAsBool(perso, 'elfeNoir')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    if (perso.race.includes('elf') && perso.race.includes('noir')) return true;
    switch (perso.race) {
      case 'drider':
      case 'drow':
        return true;
      default:
        return false;
    }
  }

  function estElfe(perso) {
    if (predicateAsBool(perso, 'elfe')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    if (perso.race.includes('elfe')) return true;
    return false;
  }

  //Vrai pour les insectes et araign\xE9es
  function estInsecte(perso) {
    if (predicateAsBool(perso, 'insecte')) return true;
    if (perso.profil === undefined) {
      perso.profil = ficheAttribute(perso, 'profil', '');
      perso.profil = perso.profil.toLowerCase();
    }
    if (perso.profil == 'insecte') return true;
    if (perso.profil == 'araign\xE9e') return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    if (perso.race.includes('elf') && perso.race.includes('noir')) return true;
    switch (perso.race) {
      case 'ankheg':
      case 'araign\xE9e':
      case 'araignee':
      case 'insecte':
        return true;
      default:
        return false;
    }
  }

  function estHumanoide(perso) {
    if (predicateAsBool(perso, 'humanoide')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'humain':
      case 'nain':
      case 'elfe':
      case 'elfe des bois':
      case 'elfe noir':
      case 'drow':
      case 'haut elfe':
      case 'halfelin':
      case 'g\xE9ant':
      case 'geant':
      case 'ange':
      case 'barghest':
      case 'd\xE9mon':
      case 'doppleganger':
      case 'dryade':
      case 'gnoll':
      case 'gobelin':
      case 'gobelours':
      case 'hobegobelin':
      case 'homme-l\xE9zard':
      case 'kobold':
      case 'nymphe':
      case 'ogre':
      case 'orque':
      case 'pixie':
      case 'troll':
        return true;
      default:
        return perso.race.startsWith('humain');
    }
  }

  function estQuadrupede(perso) {
    if (predicateAsBool(perso, 'quadrupede')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'ankheg':
      case 'araign\xE9e':
      case 'araignee':
      case 'basilic':
      case 'b\xE9hir':
      case 'behir':
      case 'bulette':
      case 'bison':
      case 'centaure':
      case 'cheval':
      case 'chien':
      case 'chim\xE8re':
      case 'chimere':
      case 'cockatrice':
      case 'crocodile':
      case 'dragon':
      case 'drider':
      case 'el\xE9phant':
      case 'elephant':
      case '\xE9l\xE9phant':
      case 'mammouth':
      case 'griffon':
      case 'hipogriffe':
      case 'hippogriffe':
      case 'hydre':
      case 'licorne':
      case 'lion':
      case 'loup':
      case 'worg':
      case 'manticore':
      case 'ours':
      case 'panthere':
      case 'panth\xE8re':
      case 'pegase':
      case 'p\xE9gase':
      case 'pieuvre':
      case 'rat':
      case 'rhinoceros':
      case 'rhinoc\xE9ros':
      case 'sanglier':
      case 'taureau':
      case 'tigre':
        return true;
      default:
        return false;
    }
  }

  function estAnimal(perso) {
    if (predicateAsBool(perso, 'animal')) return true;
    let attr = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    let attrProfile = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'PROFIL';
    });
    if (attrProfile.length > 0) {
      if (attrProfile[0].get('current').trim().toLowerCase() == 'animal')
        return true;
    }
    let attrRace = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'RACE';
    });
    if (attrRace.length === 0) return false;
    let charRace = attrRace[0].get('current').trim().toLowerCase();
    switch (charRace) {
      case 'animal':
      case 'aigle':
      case 'araignee':
      case 'araign\xE9e':
      case 'basilic':
      case 'bulette':
      case 'bison':
      case 'calmar':
      case 'chauve-souris':
      case 'cheval':
      case 'chien':
      case 'crocodile':
      case 'dinosaure':
      case '\xE9l\xE9phant':
      case 'el\xE9phant':
      case 'elephant':
      case 'gorille':
      case 'griffon':
      case 'hipogriffe':
      case 'hydre':
      case 'insecte':
      case 'lion':
      case 'loup':
      case 'mammouth':
      case 'manticore':
      case 'ours':
      case 'ours-hibou':
      case 'panth\xE8re':
      case 'pegase':
      case 'p\xE9gase':
      case 'pieuvre':
      case 'rhinoc\xE9ros':
      case 'roc':
      case 'sanglier':
      case 'serpent':
      case 'rat':
      case 'taureau':
      case 'tigre':
      case 'wiverne':
        return true;
      default:
        return false;
    }
  }

  function estMauvais(perso) {
    if (predicateAsBool(perso, 'mauvais')) return true;
    if (estDemon(perso)) return true; //remplit perso.race
    switch (perso.race) {
      case 'squelette':
      case 'zombie':
      case '\xE9l\xE9mentaire':
      case 'momie':
        return true;
      default:
        return false;
    }
  }

  function estAussiGrandQue(perso1, perso2) {
    let t1 = taillePersonnage(perso1);
    let t2 = taillePersonnage(perso2);
    if (t1 === undefined || t2 === undefined) return true;
    return t1 >= t2;
  }

  //!cof-soin
  function soigner(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd.length < 2) {
      error("Il faut au moins un argument \xE0 !cof-soin", cmd);
      return;
    }
    let soigneur = options.lanceur;
    let pageId = options.pageId;
    let cible;
    let argSoin;
    if (cmd.length > 4) {
      error("Trop d'arguments \xE0 !cof-soin", cmd);
    }
    if (cmd.length > 2) { //cof-soin lanceur [cible] montant
      if (soigneur === undefined) {
        soigneur = persoOfId(cmd[1], cmd[1]);
        if (soigneur === undefined) {
          error("Le premier argument n'est pas un token valide", cmd[1]);
          return;
        }
        pageId = soigneur.token.get('pageid');
      }
      if (cmd.length > 3) { // on a la cible en argument
        cible = persoOfId(cmd[2], cmd[2], pageId);
        if (cible === undefined) {
          error("Le deuxi\xE8me argument n'est pas un token valide: " + msg.content, cmd[2]);
          return;
        }
        argSoin = cmd[3];
      } else {
        argSoin = cmd[2];
      }
    } else { //on a juste le montant des soins
      argSoin = cmd[1];
    }
    if (soigneur === undefined && (options.mana || (options.portee !== undefined) || options.limiteParJour || options.limiteParCombat || options.dose || options.limiteSoinsParJour)) {
      error("Il faut pr\xE9ciser un soigneur pour ces options d'effet", options);
      return;
    }
    let charId;
    let niveau = 1;
    let rangSoin = 0;
    let soins;
    if (soigneur) {
      charId = soigneur.charId;
      niveau = ficheAttributeAsInt(soigneur, 'niveau', 1);
      rangSoin = predicateAsInt(soigneur, 'voieDesSoins', 0);
    }
    let effet = "soins";
    let nbDes = 1;
    let souffleDeVie = false;
    if (options.tempeteDeManaIntense) nbDes += options.tempeteDeManaIntense;
    switch (argSoin) {
      case 'leger':
        effet += ' l\xE9gers';
        if (options.dose === undefined && options.limiteParJour === undefined)
          options.limiteAttribut = {
            nom: 'soinsLegers',
            message: "ne peut plus lancer de sort de soins l\xE9gers aujourd'hui",
            limite: rangSoin
          };
        let bonusLeger = niveau + predicateAsInt(soigneur, 'voieDuGuerisseur', 0);
        soins = "[[" + nbDes + (options.puissant ? "d10" : "d8");
        if (attributeAsBool(soigneur, 'formeDAnge') && predicateAsInt(soigneur, 'voieDeLArchange', 1) > 1) {
          soins += 'ro1';
        }
        soins += " +" + bonusLeger + "]]";
        if (options.portee === undefined) options.portee = 0;
        break;
      case 'modere':
        effet += ' mod\xE9r\xE9s';
        if (options.dose === undefined && options.limiteParJour === undefined)
          options.limiteAttribut = {
            nom: 'soinsModeres',
            message: "ne peut plus lancer de sort de soins mod\xE9r\xE9ss aujourd'hui",
            limite: rangSoin
          };
        if (options.portee === undefined) options.portee = 0;
        let bonusModere = niveau + predicateAsInt(soigneur, 'voieDuGuerisseur', 0);
        soins = "[[" + (nbDes + 1) + (options.puissant ? "d10" : "d8");
        if (attributeAsBool(soigneur, 'formeDAnge') && predicateAsInt(soigneur, 'voieDeLArchange', 1) > 1) {
          soins += 'ro1';
        }
        soins += " +" + bonusModere + "]]";
        break;
      case 'souffleDeVie':
        {
          let combat = stateCOF.combat;
          if (!combat) {
            whisperChar(charId, " ne peut pas lancer de soin de groupe en dehors des combats");
            return;
          }
          souffleDeVie = combat.tour;
          effet = 'souffleDeVie';
          if (options.portee === undefined) options.portee = 0;
          let bonus = niveau + predicateAsInt(soigneur, 'voieDuGuerisseur', 0);
          soins = "[[" + (nbDes + 1) + (options.puissant ? "d10" : "d8");
          if (attributeAsBool(soigneur, 'formeDAnge') && predicateAsInt(soigneur, 'voieDeLArchange', 1) > 1) {
            soins += 'ro1';
          }
          soins += " +" + bonus + "]]";
          break;
        }
      case 'groupe':
        if (!stateCOF.combat) {
          whisperChar(charId, " ne peut pas lancer de soin de groupe en dehors des combats");
          return;
        }
        effet += ' de groupe';
        if (options.dose === undefined && options.limiteParJour === undefined)
          options.limiteAttribut = {
            nom: 'attributDeCombat_soinsDeGroupe',
            message: " a d\xE9j\xE0 fait un soin de groupe durant ce combat",
            limite: 1
          };
        if (options.puissant) soins = "[[1d10";
        else soins = "[[" + nbDes + "d8";
        if (attributeAsBool(soigneur, 'formeDAnge') && predicateAsInt(soigneur, 'voieDeLArchange', 1) > 1) {
          soins += 'ro1';
        }
        let bonusGroupe = niveau + predicateAsInt(soigneur, 'voieDuGuerisseur', 0);
        soins += " + " + bonusGroupe + "]]";
        msg.content += " --alliesEnVue --self";
        if (options.mana === undefined && estPJ(soigneur)) {
          if (ficheAttributeAsBool(soigneur, 'option_pm', true))
            options.mana = 1;
        }
        break;
      case 'secondSouffle':
        {
          if (!stateCOF.combat) {
            whisperChar(charId, " ne peut pas utiliser la capacit\xE9 second souffle en dehors des combats");
            return;
          }
          effet = "second souffle";
          if (options.dose === undefined && options.limiteParJour === undefined)
            options.limiteAttribut = {
              nom: 'secondSouffleUtilise',
              message: " a d\xE9j\xE0 repris son souffle durant ce combat",
              limite: 1
            };
          soins = "[[1d10+";
          let bonus = predicateAsInt(soigneur, 'secondSouffle', 0, -1);
          if (bonus > 0) soins += bonus;
          else soins += niveau + "+" + modCarac(soigneur, 'constitution');
          soins += "]]";
          cible = soigneur;
          options.recuperation = true;
          if (bonus == -1 || bonus > 0) { //Il y a un pr\xE9dicat second souffle
            //On limite les soins \xE0 ce qui a \xE9t\xE9 perdu dans ce combat
            const pvDebut = attributeAsInt(soigneur, 'PVsDebutCombat', 0);
            let pv = parseInt(soigneur.token.get('bar1_value'));
            if (isNaN(pv)) return;
            if (pvDebut <= pv) {
              whisperChar(charId, "Aucun PV perdu pendant ce combat, second souffle sans effet");
              return;
            }
            options.limiteSoins = pvDebut - pv;
          }
          break;
        }
      default:
        if (options.tempeteDeManaIntense) {
          let firstDicePart = argSoin.match(/[1-9][0-9]*d\d+/i);
          if (firstDicePart && firstDicePart.length > 0) {
            let fdp = firstDicePart[0];
            nbDes = parseInt(fdp) + options.tempeteDeManaIntense;
            argSoin =
              argSoin.replace(fdp, nbDes + fdp.substring(fdp.search(/d/i)));
          } else {
            argSoin = '(' + argSoin + ')*' + (1 + options.tempeteDeManaIntense);
          }
        }
        if (soigneur && attributeAsBool(soigneur, 'formeDAnge') && predicateAsInt(soigneur, 'voieDeLArchange', 1) > 1) {
          argSoin = argSoin.replace(/([1-9][0-9]*d\d+)/gi, function(all, d) {
            return d + 'ro1';
          });
        }
        soins = "[[" + argSoin + "]]";
    }
    let ressourceLimiteSoinsParJour;
    if (soigneur && options.limiteSoinsParJour) {
      ressourceLimiteSoinsParJour = effet;
      if (options.limiteSoinsParJourRessource)
        ressourceLimiteSoinsParJour = options.limiteSoinsParJourRessource;
      ressourceLimiteSoinsParJour = "limiteParJour_Soins" + ressourceLimiteSoinsParJour;
      var soinsRestantsDuJour = attributeAsInt(soigneur, ressourceLimiteSoinsParJour, options.limiteSoinsParJour);
      if (soinsRestantsDuJour < 1) {
        whisperChar(charId, "Plus possible de faire ces soins aujourd'hui");
        return;
      }
      if (options.limiteSoins === undefined || options.limiteSoins > soinsRestantsDuJour) {
        options.limiteSoins = soinsRestantsDuJour;
      }
    }
    const playerId = getPlayerIdFromMsg(msg);
    if (options.tempeteDeMana && soigneur) {
      if (options.tempeteDeMana.cout === 0) {
        //On demande de pr\xE9ciser les options
        var optMana = {
          mana: options.mana,
          rang: options.rang,
          portee: options.portee,
          altruiste: options.altruiste,
          soins: true
        };
        setTempeteDeMana(playerId, soigneur, msg.content, optMana);
        return;
      } else {
        if (options.rang && options.tempeteDeMana.cout > options.rang) {
          sendPerso(soigneur, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
        }
      }
    }
    try {
      sendChat('', soins, function(res) {
        soins = res[0].inlinerolls[0].results.total;
        let soinTxt = buildinline(res[0].inlinerolls[0], 'normal', true);
        if (soins <= 0) {
          sendChar(charId, "ne r\xE9ussit pas \xE0 soigner (total de soins " + soinTxt + ")", true);
          return;
        }
        const evt = {
          type: effet
        };
        let limiteSoinsAtteinte;
        if (options.limiteSoins && soins > options.limiteSoins) {
          soins = options.limiteSoins;
          limiteSoinsAtteinte = true;
        }
        let ressourceLimiteCibleParJour;
        if (options.limiteCibleParJour) {
          ressourceLimiteCibleParJour = effet;
          if (options.limiteCibleParJourRessource)
            ressourceLimiteCibleParJour = options.limiteCibleParJourRessource;
          ressourceLimiteCibleParJour = "limiteParJour_" + ressourceLimiteCibleParJour;
        }
        let limiteATester = true;
        let soinImpossible = false;
        let nbCibles;
        let display;
        let pvsPartages = new Set();
        let iterCibles = function(callback) {
          if (cible) {
            nbCibles = 1;
            callback(cible);
          } else {
            getSelected(msg, function(selected) {
              nbCibles = selected.length;
              if (nbCibles > 1) {
                display = startFramedDisplay(playerId, effet, soigneur);
              } else if (nbCibles === 0) {
                sendChar(charId, "personne \xE0 soigner", true);
                return;
              }
              iterSelected(selected, callback);
            }, {
              lanceur: soigneur
            });
          }
        };
        let finSoin = function() {
          if (nbCibles == 1) {
            if (options.messages) {
              options.messages.forEach(function(message) {
                if (display) addLineToFramedDisplay(display, message);
                else sendChar(charId, message, true);
              });
            }
            if (display) sendChat("", endFramedDisplay(display));
            if (ressourceLimiteSoinsParJour) {
              whisperChar(charId, "peut encore soigner de " + attributeAsInt(soigneur, ressourceLimiteSoinsParJour, options.limiteSoinsParJour) + " PV aujourd'hui.");
            }
            addEvent(evt);
          }
          nbCibles--;
        };
        iterCibles(function(cible) {
          if (cible.name === undefined) {
            let cibleChar = getObj('character', cible.charId);
            if (cibleChar === undefined) {
              finSoin();
              return;
            }
            cible.name = cibleChar.get('name');
          }
          if (pvsPartages.has(cible.name)) {
            finSoin();
            return;
          }
          let ciblePartagee = predicatesNamed(cible, 'PVPartagesAvec');
          ciblePartagee.forEach(function(cp) {
            pvsPartages.add(cp);
          });
          if (ressourceLimiteCibleParJour) {
            let utilisations =
              attributeAsInt(cible, ressourceLimiteCibleParJour, options.limiteCibleParJour);
            if (utilisations === 0) {
              sendPerso(cible, "ne peut plus b\xE9n\xE9ficier de " + effet + " aujourd'hui");
              finSoin();
              return;
            }
            setTokenAttr(cible, ressourceLimiteCibleParJour, utilisations - 1, evt);
          }
          if (soinImpossible) {
            finSoin();
            return;
          }
          let token2 = cible.token;
          let nomCible = token2.get('name');
          let sujet = onGenre(cible, 'il', 'elle');
          let Sujet = onGenre(cible, 'Il', 'Elle');
          if (options.portee !== undefined) {
            if (options.puissantPortee || options.tempeteDeManaPortee) options.portee = options.portee * 2;
            let distance = distanceCombat(soigneur.token, token2, pageId);
            if (distance > options.portee) {
              if (display)
                addLineToFramedDisplay(display, "<b>" + nomCible + "</b> : trop loin pour le soin.");
              else
                sendChar(charId,
                  "est trop loin de " + nomCible + " pour le soigner.", true);
              finSoin();
              return;
            }
          }
          if (limiteATester) {
            limiteATester = false;
            if (limiteRessources(soigneur, options, effet, effet, evt)) {
              soinImpossible = true;
              display = undefined;
              finSoin();
              return;
            }
            if (display) {
              addLineToFramedDisplay(display, "R\xE9sultat des d\xE9s : " + soinTxt);
            }
            if (msg.content.includes(' --sacrifierPV')) { //paie autant de PV que soins
              if (soigneur === undefined) {
                error("Il faut pr\xE9ciser qui est le soigneur pour utiliser l'option --sacrifierPV", msg.content);
                soinImpossible = true;
                display = undefined;
                finSoin();
                return;
              }
              let pvSoigneur = parseInt(soigneur.token.get('bar1_value'));
              if (isNaN(pvSoigneur) || pvSoigneur <= 0) {
                sendPerso(soigneur,
                  "ne peut pas soigner car " + onGenre(soigneur, 'il', 'elle') + " n'a plus de PV");
                soinImpossible = true;
                display = undefined;
                finSoin();
                return;
              }
              if (pvSoigneur < soins) {
                soins = pvSoigneur;
              }
              updateCurrentBar(soigneur, 1, pvSoigneur - soins, evt);
              let msgSacrifice = "sacrifie " + soins + " PV" + (soins > 1 ? 's' : '');
              if (pvSoigneur == soins) {
                mort(soigneur, undefined, evt);
                msgSacrifice += " et en meurt";
              }
              if (display)
                addLineToFramedDisplay(display, nomPerso(soigneur) + ' ' + msgSacrifice);
              else sendPerso(soigneur, msgSacrifice);
            }
          }
          if (souffleDeVie) {
            let pv = parseInt(cible.token.get('bar1_value'));
            if (isNaN(pv) || pv > 0) {
              let m = nomPerso(cible) + " n'est pas \xE0 0 PV, impossible d'utiliser le souffle de vie pour " + onGenre(cible, 'lui', 'elle');
              if (display) addLineToFramedDisplay(display, m);
              else sendChar(charId, m, true);
              finSoin();
              return;
            }
            let d = tokenAttribute(cible, 'a0PVDepuis');
            if (d.length > 0) {
              d = d[0];
              let tour = parseInt(d.get('current'));
              let tropTard = false;
              if (!isNaN(tour)) {
                if (tour < souffleDeVie - 2) tropTard = true;
                if (tour == souffleDeVie - 2) {
                  let init = parseInt(d.get('max'));
                  tropTard = !isNaN(init) && init > stateCOF.combat.init;
                }
              }
              if (tropTard) {
                let m = nomPerso(cible) + " est \xE0 0 PV depuis plus de 2 tours, impossible d'utiliser le souffle de vie pour " + onGenre(cible, 'lui', 'elle');
                if (display) addLineToFramedDisplay(display, m);
                else sendChar(charId, m, true);
                finSoin();
                return;
              }
              evt.deletedAttributes = evt.deletedAttributes || [];
              deleteAttribute(d, evt);
              if (estPJ(cible) && reglesOptionelles.dommages.val.blessures_graves.val) {
                //Il faut alors annuler la perte de PR ou la blessure grave
                let pr = pointsDeRecuperation(cible);
                if (pr && (pr.current > 0 || !getState(cible, 'blesse'))) {
                  rajouterPointDeRecuperation(cible, evt, pr);
                } else {
                  setState(cible, 'blesse', false, evt);
                }
              }
            }
          }
          let callMax = function() {
            if (display) {
              addLineToFramedDisplay(display, "<b>" + nomCible + "</b> : pas besoin de soins.");
            } else {
              var maxMsg = "n'a pas besoin de ";
              if (options.recuperation) {
                maxMsg = "se reposer";
                charId = soigneur.charId;
              } else if (!soigneur || token2.id == soigneur.token.id) {
                maxMsg += "se soigner";
                charId = cible.charId;
              } else {
                maxMsg += "soigner " + nomCible;
              }
              sendChar(charId, maxMsg + ". " + Sujet + " est d\xE9j\xE0 au maximum de PV", true);
            }
          };
          let img = options.image;
          let extraImg = '';
          if (img !== "" && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
            extraImg = '<span style="padding: 4px 0;" >  ';
            extraImg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
            extraImg += '</span>';
          }
          const printTrue = function(s) {
            if (ressourceLimiteSoinsParJour) {
              addToAttributeAsInt(soigneur, ressourceLimiteSoinsParJour, options.limiteSoinsParJour, -s, evt);
            }
            if (display) {
              addLineToFramedDisplay(display,
                "<b>" + nomCible + "</b> : + " + s + " PV" + extraImg);
            } else {
              let msgSoin;
              if (!soigneur || token2.id == soigneur.token.id) {
                msgSoin = 'se soigne';
                charId = cible.charId;
              } else {
                msgSoin = 'soigne ' + nomCible;
              }
              msgSoin += " de ";
              if (options.recuperation) msgSoin = "r\xE9cup\xE8re ";
              if (limiteSoinsAtteinte || s < soins)
                msgSoin += s + " PV. (Le r\xE9sultat du jet \xE9tait " + soinTxt + ")";
              else msgSoin += soinTxt + " PV.";
              msgSoin += extraImg;
              sendChar(charId, msgSoin, true);
            }
          };
          let callTrueFinal = printTrue;
          if (msg.content.includes(' --transfer')) { //paie avec ses PV
            if (soigneur === undefined) {
              error("Il faut pr\xE9ciser qui est le soigneur pour utiliser l'option --transfer", msg.content);
              soinImpossible = true;
              finSoin();
              return;
            }
            let pvSoigneur = parseInt(soigneur.token.get('bar1_value'));
            if (isNaN(pvSoigneur) || pvSoigneur <= 0) {
              if (display)
                addLineToFramedDisplay(display, "<b>" + nomCible + "</b> : plus assez de PV pour le soigner");
              else
                sendPerso(soigneur,
                  "ne peut pas soigner " + nomCible + ", " + sujet + " n'a plus de PV");
              soinImpossible = true;
              finSoin();
              return;
            }
            if (pvSoigneur < soins) {
              soins = pvSoigneur;
            }
            callTrueFinal = function(s) {
              updateCurrentBar(soigneur, 1, pvSoigneur - s, evt);
              if (pvSoigneur == s) mort(soigneur, undefined, evt);
              printTrue(s);
            };
          }
          if (options.fx) {
            var p1e = {
              x: soigneur.token.get('left'),
              y: soigneur.token.get('top'),
            };
            var p2e = {
              x: cible.token.get('left'),
              y: cible.token.get('top'),
            };
            spawnFxBetweenPoints(p1e, p2e, options.fx, pageId);
          }
          if (options.son) playSound(options.son);
          if (options.targetFx) {
            spawnFx(cible.token.get('left'), cible.token.get('top'), options.targetFx, pageId);
          }
          soigneToken(cible, soins, evt, callTrueFinal, callMax, options);
          finSoin();
        }); //fin de iterCibles
      }); //fin du sendChat du jet de d\xE9s
    } catch (e) {
      if (soins) {
        log(msg.content);
        log("L'expression des soins \xE9tait " + soins + ", et il y a eu une erreur durant son \xE9valuation");
        if (argSoin) {
          error("L'expression des soins (" + argSoin + ") n'est pas bien form\xE9e", msg.content);
        } else {
          error("Erreur pendant l'\xE9valuation de l'expression des soins. Plus d'informations dans le log", msg);
        }
      } else {
        error("Erreur pendant les soins ", msg.content);
        throw e;
      }
    }
  }

  function removeConsommables(nom, evt, attrs) {
    const prefixes = new Set();
    let empty = true;
    attrs = attrs.filter(function(a) {
      let attrName = a.get('name');
      let m = consommableNomRegExp.exec(attrName);
      if (!m) return true;
      if (a.get('current').trim() == nom) {
        prefixes.add(m[1]);
        a.remove();
        empty = false;
        return false;
      }
      return true;
    });
    if (empty) return attrs;
    let regExp = '^(';
    let notFirst = false;
    prefixes.forEach(function(pref) {
      if (notFirst) regExp += '|';
      regExp += pref;
    });
    regExp += ').*?$';
    regExp = new RegExp(regExp);
    attrs = attrs.filter(function(a) {
      if (regExp.test(a.get('name'))) {
        a.remove();
        return false;
      }
      return true;
    });
    return attrs;
  }

  function ajouterConsommable(perso, nom, nb, action, evt) {
    if (perso.token.get('bar1_link') === '') { //Perso non li\xE9, on utilise un attribut
      let attrName = 'dose_' + nom;
      let attr = tokenAttribute(perso, attrName);
      if (attr.length > 0) {
        attr = attr[0];
        let bd = parseInt(attr.get('current'));
        if (!isNaN(bd) && bd > 0) nb += bd;
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attr,
          current: bd,
          max: attr.get('max')
        });
        attr.set({
          current: nb,
          max: action
        });
      } else {
        setTokenAttr(perso, attrName, nb, evt, {
          maxVal: action
        });
      }
    } else { //On va mettre les consommables dans l'\xE9quipement
      let attributes = findObjs({
        _type: 'attribute',
        _characterid: perso.charId
      });
      let found = attributes.find(function(attr) {
        let attrName = attr.get('name');
        let m = consommableNomRegExp.exec(attrName);
        if (!m) return false;
        if (attr.get('current').trim() != nom) return false;
        let consoPrefix = m[1];
        let attrEffet =
          charAttribute(perso.charId, consoPrefix + 'equip_effet');
        if (attrEffet.length === 0) {
          attrEffet = createObj('attribute', {
            characterid: perso.charId,
            name: consoPrefix + 'equip_effet',
            current: action
          });
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attrEffet,
          });
        } else if (attrEffet[0].get('current').trim() != action) {
          return false;
        }
        let attrQte = charAttribute(perso.charId, consoPrefix + 'equip_qte');
        if (attrQte.length === 0) {
          attrQte = createObj('attribute', {
            characterid: perso.charId,
            name: consoPrefix + 'equip_qte',
            current: nb + 1,
          });
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attrQte,
          });
          return true;
        }
        attrQte = attrQte[0];
        let quantite = parseInt(attrQte.get('current'));
        if (isNaN(quantite) || quantite < 1) quantite = 0;
        attrQte.set('current', quantite + nb);
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attrQte,
          current: quantite
        });
        return true;
      });
      // si le consommable n'a pas \xE9t\xE9 trouv\xE9, on le cr\xE9e avec une valeur de nb
      if (!found) {
        let pref = 'repeating_equipement_' + generateRowID() + '_';
        let attre = createObj("attribute", {
          name: pref + 'equip_nom',
          current: nom,
          characterid: perso.charId
        });
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attre,
        });
        attre = createObj('attribute', {
          name: pref + 'equip_effet',
          current: action,
          characterid: perso.charId
        });
        evt.attributes.push({
          attribute: attre,
        });
        if (nb > 1) {
          let attrQte = createObj('attribute', {
            characterid: perso.charId,
            name: pref + 'equip_qte',
            current: nb,
          });
          evt.attributes.push({
            attribute: attrQte,
          });
        }
      }
    }
  }

  function parseNatureNourriciere(msg) {
    var options = parseOptions(msg);
    getSelected(msg, function(selected) {
      iterSelected(selected, function(lanceur) {
        var voieDeLaSurvie = predicateAsInt(lanceur, 'voieDeLaSurvie', 0);
        if (voieDeLaSurvie < 1) {
          sendPerso(lanceur, " ne conna\xEEt pas la Voie de la Survie ?");
        }
        doNatureNourriciere(lanceur, options);
      });
    });
  }

  function doNatureNourriciere(perso, options) {
    const evt = {
      type: "natureNourriciere",
      action: {
        perso: perso,
        options: options,
        rolls: {}
      }
    };
    addEvent(evt);
    var voieDeLaSurvie = predicateAsInt(perso, 'voieDeLaSurvie', 0);
    var trouveBaies = predicateAsBool(perso, 'natureNourriciereBaies');
    if (options.rolls && options.rolls.duree) {
      evt.action.rolls.duree = options.rolls.duree;
    } else {
      evt.action.rolls.duree = rollDePlus(6);
    }
    var output = "cherche des herbes. ";
    if (trouveBaies) output = "cherche des baies. ";
    output += "Apr\xE8s " + evt.action.rolls.duree.roll + " heure";
    if (evt.action.rolls.duree.val > 1) output += "s";
    output += ", " + onGenre(perso, "il", "elle");
    var testId = 'natureNourriciere';
    testCaracteristique(perso, 'SAG', 10, testId, options, evt,
      function(tr) {
        var post = "";
        if ((tr.reussite && !trouveBaies) || (trouveBaies && !tr.reussite && tr.valeur > 7)) {
          if (voieDeLaSurvie > 0) {
            output += " revient avec " + voieDeLaSurvie + " plantes m\xE9dicinales." + tr.modifiers;
            var actionHerbes = "!cof-soin @{selected|token_id} @{selected|token_id} 1d6";
            ajouterConsommable(perso, 'Plante m\xE9dicinale', voieDeLaSurvie, actionHerbes, evt);
          } else {
            output += " revient avec de quoi soigner les bless\xE9s." + tr.modifiers;
          }
        } else if (tr.reussite && trouveBaies) {
          var niveau = ficheAttributeAsInt(perso, 'niveau', 1);
          var actionBaies = "!cof-consommer-baie " + niveau + " --limiteParJour 1 baieMagique";
          var nbBaies = voieDeLaSurvie + Math.floor((tr.valeur - 10) / 2);
          if (nbBaies === 0) nbBaies = 1;
          output += " revient avec " + nbBaies + " baies magiques." + tr.modifiers;
          ajouterConsommable(perso, 'Baie magique', nbBaies, actionBaies, evt);
        } else {
          output += " revient bredouille." + tr.rerolls + tr.modifiers;
        }
        output += "(test de SAG:" + tr.texte + ")";
        output += post;
        sendPerso(perso, output);
      });
  }

  function ignorerLaDouleur(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    var evtARefaire = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[1]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
    }
    getSelected(msg, function(selected) {
      iterSelected(selected, function(chevalier) {
        var token = chevalier.token;
        if (attributeAsInt(chevalier, 'douleurIgnoree', 0) > 0) {
          sendPerso(chevalier, "a d\xE9j\xE0 ignor\xE9 la doubleur une fois pendant ce combat");
          return;
        }
        if (evtARefaire === undefined || evtARefaire.type === undefined || !evtARefaire.type.startsWith('Attaque')) {
          sendPerso(chevalier, "s'y prend trop tard pour ignorer la douleur : la derni\xE8re action n'\xE9tait pas une attaque");
          return;
        }
        var aIgnore;
        var evt = {
          type: 'ignorer la douleur'
        };
        var PVid = token.get('bar1_link');
        if (PVid === '') { //token non li\xE9, effets seulement sur le token.
          if (evtARefaire.affecte) {
            var affecte = evtARefaire.affectes[token.id];
            if (affecte && affecte.prev) {
              var lastBar1 = affecte.prev.bar1_value;
              var bar1 = parseInt(token.get('bar1_value'));
              if (isNaN(lastBar1) || isNaN(bar1) || lastBar1 <= bar1) {
                //On regarde la barre 2, peut-\xEAtre qu'il s'agit de DM temporaires
                var lastBar2 = affecte.prev.bar2_value;
                var bar2 = parseInt(token.get('bar2_value'));
                if (isNaN(lastBar2) || isNaN(bar2) || bar2 <= lastBar2) {
                  sendPerso(chevalier, "ne peut ignorer la douleur : il semble que la derni\xE8re attaque ne lui ait pas enlev\xE9 de PV");
                  return;
                }
                updateCurrentBar(chevalier, 2, lastBar2, evt);
                setTokenAttr(chevalier, 'douleurIgnoree', bar2 - lastBar2, evt);
                aIgnore = true;
              } else {
                updateCurrentBar(chevalier, 1, lastBar1, evt);
                setTokenAttr(chevalier, 'douleurIgnoree', lastBar1 - bar1, evt);
                aIgnore = true;
              }
            }
          }
        } else { // token li\xE9, il faut regarder l'attribut
          var attrPV = evtARefaire.attributes.find(function(attr) {
            return (attr.attribute.id == PVid);
          });
          if (attrPV) {
            var lastPV = attrPV.current;
            var newPV = attrPV.attribute.get('current');
            if (isNaN(lastPV) || isNaN(newPV) || lastPV <= newPV) {
              sendPerso(chevalier, "ne peut ignorer la douleur : il semble que la derni\xE8re attaque ne lui ait pas enlev\xE9 de PV");
              return;
            }
            updateCurrentBar(chevalier, 1, lastPV, evt);
            setTokenAttr(chevalier, 'douleurIgnoree', lastPV - newPV, evt);
            aIgnore = true;
          } else { //peut-\xEAtre qu'il s'agit de DM temporaires
            PVid = token.get('bar2_link');
            attrPV = evtARefaire.attributes.find(function(attr) {
              return (attr.attribute.id == PVid);
            });
            if (attrPV) {
              var lastDmTemp = attrPV.current;
              var newDmTemp = attrPV.attribute.get('current');
              if (isNaN(lastDmTemp) || isNaN(newDmTemp) || newDmTemp <= lastDmTemp) {
                sendPerso(chevalier, "ne peut ignorer la douleur : il semble que la derni\xE8re attaque ne lui ait pas augment\xE9 les DM temporaires");
                return;
              }
              updateCurrentBar(chevalier, 2, lastDmTemp, evt);
              setTokenAttr(chevalier, 'douleurIgnoree', newDmTemp - lastDmTemp, evt);
              aIgnore = true;
            }
          }
        }
        if (aIgnore) {
          sendPerso(chevalier, " ignore la douleur de la derni\xE8re attaque");
          addEvent(evt);
        } else {
          sendPerso(chevalier, "ne peut ignorer la douleur : il semble que la derni\xE8re attaque ne l'ait pas affect\xE9");
        }
      });
    });
  }

  function fortifiant(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    const cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("La fonction !cof-fortifiant attend en argument le rang dans la Voie des \xE9lixirs du cr\xE9ateur", cmd);
      return;
    }
    const rang = parseInt(cmd[1]);
    if (isNaN(rang) || rang < 1) {
      error("Rang du fortifiant incorrect", cmd);
      return;
    }
    const evt = {
      type: 'fortifiant',
      attributes: []
    };
    addEvent(evt);
    getSelected(msg, function(selection) {
      iterSelected(selection, function(beneficiaire) {
        if (limiteRessources(beneficiaire, options, 'elixir_fortifiant', "boire un fortifiant", evt)) return;
        const soins = rollDePlus(4, {
          bonus: rang
        });
        sendPerso(beneficiaire, " boit un fortifiant");
        soigneToken(beneficiaire, soins.val, evt, function(soinsEffectifs) {
          let msgSoins = "et est soign\xE9 de ";
          if (soinsEffectifs == soins.val) msgSoins += soins.roll + " PV";
          else msgSoins += soinsEffectifs + " PV (le jet \xE9tait " + soins.roll + ")";
          sendPerso(beneficiaire, msgSoins);
        });
        // Finalement on met l'effet fortifie
        setTokenAttr(beneficiaire, 'fortifie', rang + 1, evt);
      });
    });
  }

  //Appliquer une huile instable sur l'arme de la cible
  // Par d\xE9faut, c'est l'arme en main de la cible
  // TODO: le faire pour les projectiles
  // !cof-huile-instable @{target|token_id}
  function huileInstable(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    const cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("La fonction !cof-huile-instable attend en argument la personne dont il faut enflammer l'arme", cmd);
      return;
    }
    let perso = persoOfId(cmd[1], cmd[1]);
    if (perso === undefined) {
      sendPlayer(msg, "Cible pour appliquer l'huile instable incorrecte");
      return;
    }
    let arme = armesEnMain(perso);
    if (arme === undefined) {
      sendPerso(perso, "Doit tenir son arme en main pour qu'on puisse appliquer l'huile instable");
      return;
    }
    let playerId = getPlayerIdFromMsg(msg);
    let effet = 'armeEnflammee(' + arme.label + ')';
    let mEffet = messageEffetTemp.armeEnflammee;
    let intel = 0;
    if (options.lanceur) {
      intel = modCarac(options.lanceur, 'intelligence');
    }
    let duree = (5 + intel) * 6;
    effetTemporaire(playerId, [perso], effet, mEffet, duree, options);
  }

  function lancerSort(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    const cmd = options.cmd;
    if (cmd === undefined) return;
    if (options.messages === undefined) options.messages = [];
    if (cmd.length > 1) options.messages.unshift(cmd.slice(1).join(' '));
    if (options.messages.length < 1) {
      options.messages.push("lance un sort");
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        if (options.lanceur) {
          selected = [{
            _id: options.lanceur.token.id
          }];
        } else {
          error("Pas de token s\xE9lection\xE9e pour !cof-lancer-sort", cmd);
          return;
        }
      }
      const evt = {
        type: "lancement de sort"
      };
      addEvent(evt);
      if (options.lanceur) {
        let lanceur = options.lanceur;
        if (options.tempeteDeMana) {
          if (options.tempeteDeMana.cout === 0) {
            //On demande de pr\xE9ciser les options
            let optMana = {
              mana: options.mana,
              dm: false,
              soins: false,
              duree: true,
              portee: true,
              rang: options.rang,
            };
            setTempeteDeMana(playerId, lanceur, msg.content, optMana);
            return;
          } else {
            if (options.rang && options.tempeteDeMana.cout > options.rang) {
              sendPerso(lanceur, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
            }
          }
        }
        if (limiteRessources(lanceur, options, undefined, "lancer un sort", evt)) return;
      }
      if (options.son) playSound(options.son);
      iterSelected(selected, function(cible) {
        if (!options.lanceur) {
          if (options.tempeteDeMana) {
            if (options.tempeteDeMana.cout === 0) {
              //On demande de pr\xE9ciser les options
              var optMana = {
                mana: options.mana,
                dm: false,
                soins: false,
                duree: true,
                portee: true,
                rang: options.rang,
              };
              setTempeteDeMana(playerId, cible, msg.content, optMana);
              return;
            } else {
              if (options.rang && options.tempeteDeMana.cout > options.rang) {
                sendPerso(cible, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
              }
            }
          }
          if (limiteRessources(cible, options, undefined, "lancer un sort", evt)) return;
        }
        options.messages.forEach(function(m) {
          sendPerso(cible, m, options.secret);
        });
        if (options.messagesMJ) {
          options.messagesMJ.forEach(function(m) {
            sendChar(cible.charId, '/w gm ' + m);
          });
        }
      });
    });
  }

  //Est-ce encore utile ? TODO
  function emulerAs(msg) {
    let cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il manque le nom du personnage pour !cof-as", msg.content);
      return;
    }
    cmd.shift();
    let nomPerso = cmd.shift();
    if (nomPerso.charAt(0) == '"') {
      nomPerso = nomPerso.substring(1);
      let inComma = cmd.length;
      while (inComma) {
        nomPerso += ' ' + cmd.shift();
        inComma--;
        if (nomPerso.endsWith('"')) {
          nomPerso = nomPerso.substr(0, nomPerso.length - 1);
          inComma = 0;
        }
      }
    }
    sendChat(nomPerso, cmd.join(' '));
  }


  //!cof-mur-de-force [opt] [duree]
  // opt peut \xEAtre mur, noImage ou vent
  // On peut changer la taille du mur avec l'option --portee.
  function murDeForce(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) return;
    let sphere = true;
    let imageSphere = stateCOF.options.images.val.image_mur_de_force.val;
    let typeMur = 'force';
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'mur':
          sphere = false;
          break;
        case 'noImage':
          imageSphere = undefined;
          break;
        case 'vent':
          typeMur = 'vent';
          imageSphere = stateCOF.options.images.val.image_mur_de_vent.val;
          break;
        default:
          imageSphere = cmd[1].replace('&#58;', ':');
      }
    }
    let duree;
    if (cmd.length > 2) {
      duree = parseInt(cmd[2]);
      if (isNaN(duree) || duree < 1) {
        error("Le deuxi\xE8me argument de !cof-mur-de-force doit \xEAtre une dur\xE9e", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Aucun personnage s\xE9lectionn\xE9 pour lancer le mur de " + typeMur, playerId);
        return;
      }
      const evt = {
        type: "Mur de " + typeMur
      };
      addEvent(evt);
      initiative(selected, evt);
      iterSelected(selected, function(lanceur) {
        if (options.tempeteDeMana) {
          if (options.tempeteDeMana.cout === 0) {
            //On demande de pr\xE9ciser les options
            let optMana = {
              mana: options.mana,
              dm: false,
              soins: false,
              duree: true,
              portee: true,
              rang: options.rang,
            };
            setTempeteDeMana(playerId, lanceur, msg.content, optMana);
            return;
          } else {
            if (options.rang && options.tempeteDeMana.cout > options.rang) {
              sendPerso(lanceur, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
            }
          }
        }
        let token = lanceur.token;
        let pageId = token.get('pageid');
        if (limiteRessources(lanceur, options, 'murDeForce', 'lancer un mur de ' + typeMur, evt)) return;
        if (options.son) playSound(options.son);
        whisperChar(lanceur.charId, "lance un sort de mur de " + typeMur);
        if (sphere) {
          let scale = computeScale(pageId);
          let diametre = 6;
          if (typeMur == 'vent') diametre = 10;
          if (options.portee) diametre = 2 * options.portee;
          diametre = PIX_PER_UNIT * (diametre / scale);
          if (options.puissantPortee || options.tempeteDeManaPortee) diametre += diametre;
          if (options.tempeteDeManaIntense)
            diametre *= (1 + options.tempeteDeManaIntense);
          let imageFields = {
            _pageid: pageId,
            imgsrc: imageSphere,
            represents: '',
            left: token.get('left'),
            top: token.get('top'),
            width: diametre,
            height: diametre,
            layer: 'map',
            name: "Mur de " + typeMur,
            isdrawing: true,
          };
          let newImage = createObj('graphic', imageFields);
          if (newImage) {
            evt.tokens = [newImage];
            toFront(newImage);
            setTokenAttr(lanceur, 'murDeForceId', newImage.id, evt);
            if (!duree) {
              switch (typeMur) {
                case 'force':
                  duree = 5 + modCarac(lanceur, 'charisme');
                  break;
                case 'vent':
                  duree = 5 + modCarac(lanceur, 'intelligence');
                  break;
                default:
                  duree = 1;
              }
            }
            if (options.puissantDuree || options.tempeteDeManaDuree) duree += duree;
            setAttrDuree(lanceur, 'murDeForce', duree, evt);
          } else {
            error("Impossible de cr\xE9er l'image " + options.image, imageFields);
          }
        } else {
          sendPlayerAndGM(msg, playerId, "placer l'image du mur sur la carte");
        }
      });
    });
  }

  function tokensEnCombat() {
    let cmp = Campaign();
    let turnOrder = cmp.get('turnorder');
    if (turnOrder === '') return []; // nothing in the turn order
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length === 0) return [];
    let tokens = [];
    turnOrder.forEach(function(a) {
      if (a.id == -1) return;
      tokens.push({
        _id: a.id
      });
    });
    return tokens;
  }

  function devientCapitaine(msg) {
    let cmd = msg.content.split(' ');
    cmd = cmd.filter(function(c) {
      return c !== '';
    });
    if (cmd.length < 2) {
      error("La fonction !cof-capitaine attend en argument l'id du capitaine", cmd);
      return;
    }
    const evt = {
      type: 'Capitaine'
    };
    let remove;
    let capitaine;
    let nomCapitaine;
    let bonus = 2;
    let titre = 'capitaine';
    if (cmd[1] == '--aucun') {
      remove = true;
    } else {
      capitaine = persoOfId(cmd[1], cmd[1]);
      if (capitaine === undefined) {
        error("Le premier argument de !cof-capitaine doit \xEAtre un token", cmd[1]);
        return;
      }
      setState(capitaine, 'chef', true, evt);
      nomCapitaine = nomPerso(capitaine);
      if (cmd.length > 2 && !cmd[2].startsWith('--')) {
        bonus = parseInt(cmd[2]);
        if (isNaN(bonus) || bonus < 0) {
          error("Le bonus de capitaine (second argument) doit \xEAtre un nombre positif", cmd);
          return;
        }
        if (bonus === 0) remove = true;
        if (bonus > 2) titre = 'commandant';
      }
    }
    getSelected(msg, function(selected) {
      if (selected.length === 0) {
        error("Pas de token s\xE9lectionn\xE9 pour !cof-capitaine");
        return;
      }
      iterSelected(selected, function(perso) {
        let token = perso.token;
        if (remove) {
          removeCharAttr(perso.charId, 'capitaine', evt);
          removeCharAttr(perso.charId, 'capitaineActif', evt);
          sendChat('COF', "/w GM " + nomPerso(perso) + " n'a plus de capitaine");
        } else {
          if (token.id == capitaine.token.id) return;
          setTokenAttr(perso, 'capitaine', idName(capitaine), evt, {
            maxVal: bonus,
            charAttr: true
          });
          sendChat('COF', "/w GM " + nomCapitaine + " est " + onGenre(capitaine, "le ", "la ") + titre + " de " + nomPerso(perso));
        }
      });
      addEvent(evt);
    });
  }


  function distribuerBaies(msg) {
    if (msg.selected === undefined || msg.selected.length != 1) {
      error("Pour utiliser !cof-distribuer-baies, il faut s\xE9lectionner un token", msg);
      return;
    }
    let druide = persoOfId(msg.selected[0]._id);
    if (druide === undefined) {
      error("Erreur de s\xE9lection dans !cof-distribuer-baies", msg.selected);
      return;
    }
    let niveau = ficheAttributeAsInt(druide, 'niveau', 1);
    const evt = {
      type: "Distribution de baies magiques"
    };
    let action = "Distribue des baies";
    let mangerBaie = "!cof-consommer-baie " + niveau + " --limiteParJour 1 baieMagique";
    getSelected(msg, function(selected, playerId) {
      const display = startFramedDisplay(playerId, action, druide);
      iterSelected(selected, function(perso) {
        let nom = nomPerso(perso);
        ajouterConsommable(perso, 'Baie magique', 1, mangerBaie, evt);
        let line = nom + " re\xE7oit une baie";
        if (perso.token.id == druide.token.id)
          line = nom + " en garde une pour " + onGenre(druide, "lui", "elle");
        addLineToFramedDisplay(display, line);
      });
      addEvent(evt);
      sendChat("", endFramedDisplay(display));
    }, {
      lanceur: druide
    }); //fin du getSelected
  }

  //!cof-consommer-baie niveau
  function consommerBaie(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd.length < 2) {
      error("Il faut un argument \xE0 !cof-consommer-baie", cmd);
      return;
    }
    let baie = parseInt(cmd[1]);
    if (isNaN(baie) || baie < 0) {
      error("L'argument de !cof-consommer-baie doit \xEAtre un nombre positif", cmd);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour !cof-consommer-baie", playerId);
        return;
      }
      const evt = {
        type: "consommer une baie"
      };
      addEvent(evt);
      iterSelected(selected, function(perso) {
        if (limiteRessources(perso, options, 'baieMagique', "a d\xE9j\xE0 mang\xE9 une baie aujourd'hui. Pas d'effet.", evt)) return;
        let soins = rollDePlus(6, {
          bonus: baie
        });
        soigneToken(perso, soins.val, evt, function(soinsEffectifs) {
            let msgSoins =
              "mange une baie magique. " +
              onGenre(perso, "Il est rassasi\xE9", "Elle est rassasi\xE9e") +
              " et r\xE9cup\xE8re ";
            if (soinsEffectifs == soins.val) msgSoins += soins.roll + " points de vie";
            else msgSoins += soinsEffectifs + " PV (le jet \xE9tait " + soins.roll + ")";
            sendPerso(perso, msgSoins);
          },
          function() {
            sendPerso(perso, "mange une baie magique. " + onGenre(perso, "Il", "Elle") + " se sent rassasi\xE9" + onGenre(perso, '', 'e') + '.');
          });
      });
    }); //fin de getSelected
  }

  function replaceInline(msg) {
    if (msg.inlinerolls) {
      msg.content = _.chain(msg.inlinerolls)
        .reduce(function(m, v, k) {
          m['$[[' + k + ']]'] = v.results.total || 0;
          return m;
        }, {})
        .reduce(function(m, v, k) {
          return m.replace(k, v);
        }, msg.content)
        .value();
    }
  }

  /* Quand on prot\xE8ge un alli\xE9, on stocke l'idName dans un attribut 'protegerUnAllie', et pour ce token, on met un
   * attribut 'protegePar_nom' o\xF9 nom est le nom du token protecteur, et qui contient l'idName du protecteur
   * Ces attributs disparaissent \xE0 la fin des combats */
  function protegerUnAllie(msg) {
    let args = msg.content.split(' ');
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-proteger-un-allie: " + msg.content, args);
      return;
    }
    const protecteur = persoOfId(args[1], args[1]);
    if (protecteur === undefined) {
      error("Le premier argument n'est pas un token valide", args[1]);
      return;
    }
    const nameProtecteur = nomPerso(protecteur);
    let tokenProtecteur = protecteur.token;
    let pageId = tokenProtecteur.get('pageid');
    let target = persoOfId(args[2], args[2], pageId);
    if (target === undefined) {
      error("Le deuxi\xE8me argument n'est pas un token valide: " + msg.content, args[2]);
      return;
    }
    let tokenTarget = target.token;
    if (tokenTarget.id == tokenProtecteur.id) {
      sendPerso(protecteur, "ne peut pas se prot\xE9ger i" + onGenre(protecteur, 'lui', 'elle') + "-m\xEAme");
      return;
    }
    const nameTarget = nomPerso(target);
    const evt = {
      type: "Prot\xE9ger un alli\xE9"
    };
    let attrsProtecteur = tokenAttribute(protecteur, 'protegerUnAllie');
    let protegePar = 'protegePar_' + nameProtecteur;
    let other;
    if (attrsProtecteur.length > 0) { //On prot\xE8ge d\xE9j\xE0 quelqu'un
      let previousTarget =
        persoOfIdName(attrsProtecteur[0].get('current'), pageId);
      if (previousTarget) {
        if (previousTarget.token.id == tokenTarget.id) {
          sendPerso(protecteur, "prot\xE8ge d\xE9j\xE0 " + nameTarget);
          return;
        }
        if (predicateAsBool(protecteur, 'protegerUnAllieAvance')) {
          let previousTarget2 =
            persoOfIdName(attrsProtecteur[0].get('max'), pageId);
          if (previousTarget2) {
            if (previousTarget2.token.id == tokenTarget.id) {
              sendPerso(protecteur, "prot\xE8ge d\xE9j\xE0 " + nameTarget);
              return;
            }
            removeTokenAttr(previousTarget2, protegePar, evt, {
              msg: "n'est plus prot\xE9g\xE9 par " + nameProtecteur
            });
          } else {
            other = attrsProtecteur[0].get('current');
          }
        }
        removeTokenAttr(previousTarget, protegePar, evt, {
          msg: "n'est plus prot\xE9g\xE9 par " + nameProtecteur
        });
      }
    }
    let distTargetProtecteur = distanceCombat(target.token, protecteur.token, pageId);
    if (distTargetProtecteur > 0) {
      sendPerso(protecteur, "est trop loin de " +
        nameTarget + " pour le prot\xE9ger");
      return;
    }
    if (ficheAttributeAsInt(protecteur, 'defbouclieron', 0) === 0) {
      let sujet = onGenre(protecteur, 'il', 'elle');
      sendPerso(protecteur, "ne porte pas son bouclier, " + sujet +
        " ne peut pas proteger " + nameTarget);
      return;
    }
    let opt = {
      maxVal: ''
    };
    if (other === undefined) {
      setTokenAttr(protecteur, 'protegerUnAllie', idName(target), evt, opt);
    } else {
      opt.maxVal = idName(target);
      setTokenAttr(protecteur, 'protegerUnAllie', other, evt, opt);
    }
    setTokenAttr(target, protegePar, idName(protecteur), evt);
    sendPerso(protecteur, "prot\xE8ge " + nameTarget);
    addEvent(evt);
  }

  function actionDefensive(msg) {
    let combat = stateCOF.combat;
    if (!combat) {
      sendPlayer(msg, "Il faut entrer en combat pour se d\xE9fendre");
      return;
    }
    let cmd = msg.content.split(' ');
    let def = 2; //pour une d\xE9fense simple
    let defMsg = "pr\xE9f\xE8re se d\xE9fendre pendant ce tour";
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'totale':
          def = 4;
          defMsg = "se consacre enti\xE8rement \xE0 sa d\xE9fense pendant ce tour";
          break;
        case 'simple':
          def = 2;
          break;
        default:
          error("Argument de !cof-action-defensive non reconnu", cmd);
      }
    }
    const evt = {
      type: "action d\xE9fensive"
    };
    getSelected(msg, function(selected) {
      initiative(selected, evt);
      iterSelected(selected, function(perso) {
        setTokenAttr(perso, 'defenseTotale', def, evt, {
          msg: defMsg,
          maxVal: combat.tour
        });
      });
      addEvent(evt);
    });
  }

  function strangulation(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-strangulation: " + msg.content, args);
      return;
    }
    var necromancien = persoOfId(args[1], args[1]);
    if (necromancien === undefined) {
      error("Le premier argument n'est pas un token", args[1]);
      return;
    }
    var pageId = necromancien.token.get('pageid');
    var target = persoOfId(args[2], args[2], pageId);
    if (target === undefined) {
      error("Le deuxi\xE8me argument n'est pas un token valide: " + msg.content, args[2]);
      return;
    }
    let name2 = nomPerso(target);
    if (!attributeAsBool(target, 'strangulation')) {
      sendPerso(necromancien, "ne peut pas maintenir la strangulation. Il faut (re)lancer le sort");
      return;
    }
    var evt = {
      type: "Strangulation"
    };
    var dureeStrang = tokenAttribute(target, 'dureeStrangulation');
    var nouvelleDuree = 1;
    if (dureeStrang.length > 0) {
      nouvelleDuree = parseInt(dureeStrang[0].get('current'));
      if (isNaN(nouvelleDuree)) {
        log("Dur\xE9e de strangulation n'est pas un nombre");
        log(dureeStrang);
        nouvelleDuree = 1;
      } else nouvelleDuree++;
    }
    setTokenAttr(target, 'dureeStrangulation', nouvelleDuree, evt, {
      maxVal: true
    });
    let deStrang = 6;
    if (msg.content.includes(' --puissant')) deStrang = 8;
    let dmgExpr = "[[1d" + deStrang + " ";
    let modInt = modCarac(necromancien, 'intelligence');
    if (modInt > 0) dmgExpr += "+" + modInt;
    else if (modInt < 0) dmgExpr += modInt;
    dmgExpr += "]]";
    sendChat('', dmgExpr, function(res) {
      var dmg = {
        type: 'magique',
        total: res[0].inlinerolls[0].results.total,
        display: buildinline(res[0].inlinerolls[0], 'normal', true),
      };
      dealDamage(target, dmg, [], evt, false, {
          attaquant: necromancien
        }, undefined,
        function(dmgDisplay, dmg) {
          sendPerso(necromancien, "maintient sa strangulation sur " + name2 + ". Dommages : " + dmgDisplay);
          addEvent(evt);
        });
    });
  }


  function ombreMortelle(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 4) {
      error("Pas assez d'arguments pour " + cmd[0], cmd);
      return;
    }
    var lanceur = persoOfId(cmd[1], cmd[1]);
    if (lanceur === undefined) {
      error("Le premier argument n'est pas un token valide", cmd[1]);
      return;
    }
    var pageId = options.pageId || lanceur.token.get('pageid');
    var cible = persoOfId(cmd[2], cmd[2], pageId);
    if (cible === undefined) {
      error("La cible n'est pas un token valide", cmd[2]);
      return;
    }
    let duree = parseInt(cmd[3]);
    if (isNaN(duree) || duree <= 0) {
      error("La dur\xE9e doit \xEAtre un nombre positif", cmd);
      return;
    }
    let image = options.image || stateCOF.options.images.val.image_ombre.val;
    if (options.portee !== undefined) {
      let distance = distanceCombat(lanceur.token, cible.token, pageId);
      if (distance > options.portee) {
        sendPerso(lanceur, "est trop loind de " + nomPerso(cible) +
          " pour animer son ombre");
        return;
      }
    }
    const evt = {
      type: "Ombre mortelle"
    };
    let msgRes = "invoquer une ombre mortelle";
    if (limiteRessources(lanceur, options, "Ombre_mortelle", msgRes, evt)) return;
    copieToken(cible, image, stateCOF.options.images.val.image_ombre.val, "Ombre de " + nomPerso(cible), 'ombreMortelle', duree, pageId, evt);
    let msgOmbre = "anime l'ombre de " + cible.tokName + ". Celle-ci commence \xE0 attaquer " + cible.tokName + "&nbsp;!";
    if (options.secret) whisperChar(lanceur.charId, msgOmbre);
    else sendPerso(lanceur, msgOmbre);
    addEvent(evt);
  }

  //renvoie l'attribut de l'effet temporaire cr\xE9\xE9
  function copieToken(cible, image1, image2, nom, effet, duree, pageId, evt) {
    let pv = parseInt(cible.token.get('bar1_value'));
    if (isNaN(pv)) {
      error("Token avec des PV qui ne sont pas un nombre", cible.token);
      return;
    }
    if (pv > 1) pv = Math.floor(pv / 2);
    let pvMax = parseInt(cible.token.get('bar1_max'));
    if (isNaN(pvMax)) {
      error("Token avec des PV max qui ne sont pas un nombre", cible.token);
      return;
    }
    if (pvMax > 1) pvMax = Math.floor(pvMax / 2);
    let tokenFields = {
      _pageid: pageId,
      imgsrc: image1,
      represents: cible.charId,
      left: cible.token.get('left') + 60,
      top: cible.token.get('top'),
      width: cible.token.get('width'),
      height: cible.token.get('height'),
      rotation: cible.token.get('rotation'),
      layer: 'objects',
      name: nom,
      bar1_value: pv,
      bar1_max: pvMax,
      bar2_value: cible.token.get('bar2_value'),
      bar2_max: cible.token.get('bar2_max'),
      bar3_value: cible.token.get('bar3_value'),
      bar3_max: cible.token.get('bar3_max'),
      showname: true,
      showplayers_name: true,
      showplayers_bar1: cible.token.get('showplayers_bar1'),
    };
    let newToken;
    if (image1) newToken = createObj('graphic', tokenFields);
    if (newToken === undefined) {
      tokenFields.imgsrc = cible.token.get('imgsrc').replace('/max.png', '/thumb.png').replace('/med.png', '/thumb.png');
      newToken = createObj('graphic', tokenFields);
      if (newToken === undefined) {
        log(tokenFields.imgsrc);
        if (image2 && image2 != image1) {
          tokenFields.imgsrc = image2;
          newToken = createObj('graphic', tokenFields);
        }
        if (newToken === undefined) {
          error("L'image du token s\xE9lectionn\xE9 n'a pas \xE9t\xE9 upload\xE9, et l'image par d\xE9faut n'est pas correcte. Impossible de cr\xE9er un token.", tokenFields);
          return;
        }
      }
    }
    evt.tokens = evt.tokens || [];
    evt.tokens.push(newToken);
    let perso = {
      token: newToken,
      charId: cible.charId
    };
    let attr = setAttrDuree(perso, effet, duree, evt);
    initPerso(perso, evt);
    return attr;
  }

  //retourne true si le joueur est effectivement d\xE9plac\xE9
  function movePlayerToPage(pid, oldPageId, newPageId) {
    if (getObj('player', pid) === undefined) return;
    var c = Campaign();
    var playerPages = c.get('playerspecificpages');
    var playersMainPage = c.get('playerpageid');
    if (!playerPages) playerPages = {};
    if ((playerPages[pid] && playerPages[pid] == oldPageId)) {
      if (playersMainPage == newPageId) {
        c.set('playerspecificpages', false);
        if (_.size(playerPages) > 1) {
          delete playerPages[pid];
          c.set('playerspecificpages', playerPages);
        }
      } else {
        playerPages[pid] = newPageId;
        c.set('playerspecificpages', false);
        c.set('playerspecificpages', playerPages);
      }
    } else if ((!playerPages[pid] && playersMainPage == oldPageId)) {
      playerPages[pid] = newPageId;
      var allPlayers = findObjs({
        _type: 'player'
      });
      var allOnNewPage = allPlayers.every(function(p) {
        if (playerIsGM(p.id)) return true;
        return playerPages[p.id] == newPageId;
      });
      c.set('playerspecificpages', false);
      if (allOnNewPage) {
        Campaign().set('playerpageid', newPageId);
      } else {
        c.set('playerspecificpages', playerPages);
      }
    }
  }

  function findEsc(escaliers, escName, i) {
    var fullEscName = escName + labelsEscalier[i];
    var sortieEscalier = escaliers.find(function(esc) {
      return esc.get('name') == fullEscName;
    });
    if (sortieEscalier === undefined && i > 0) return findEsc(escName, i - 1);
    return sortieEscalier;
  }

  //Attention : ne tient pas compte de la rotation !
  function intersection(pos1, size1, pos2, size2) {
    if (pos1 == pos2) return true;
    if (pos1 < pos2) return ((pos1 + size1 / 2) >= pos2 - size2 / 2);
    return ((pos2 + size2 / 2) >= pos1 - size1 / 2);
  }

  var labelsEscalier = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"];

  function escalier(msg) {
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de s\xE9lection de token pour !cof-escalier", playerId);
        log("!cof-escalier requiert de s\xE9lectionner des tokens");
        return;
      }
      var pageId = getObj('graphic', selected[0]._id).get('pageid');
      var escaliers = findObjs({
        _type: 'graphic',
        _pageid: pageId,
        layer: 'gmlayer'
      });
      if (escaliers.length === 0) {
        sendPlayer(msg, "Pas de token dans le layer GM", playerId);
        return;
      }
      var tmaps; //Les passages entre les maps.
      var versLeHaut = true;
      var loop = true;
      if (msg.content) {
        if (msg.content.includes(' bas')) {
          versLeHaut = false;
          loop = false;
        } else if (msg.content.includes(' haut')) {
          versLeHaut = true;
          loop = false;
        }
      }
      iterSelected(selected, function(perso) {
        var token = perso.token;
        var posX = token.get('left');
        var sizeX = token.get('width');
        var posY = token.get('top');
        var sizeY = token.get('height');
        var sortieEscalier;
        escaliers.forEach(function(esc) {
          if (sortieEscalier) return;
          if (intersection(posX, sizeX, esc.get('left'), esc.get('width')) &&
            intersection(posY, sizeY, esc.get('top'), esc.get('height'))) {
            var escName = esc.get('name');
            var l = escName.length;
            if (l > 1) {
              var label = escName.substr(l - 1, 1);
              escName = escName.substr(0, l - 1);
              var i = labelsEscalier.indexOf(label);
              if (versLeHaut) {
                if (i == 11) {
                  if (loop) escName += labelsEscalier[0];
                } else escName += labelsEscalier[i + 1];
              } else {
                if (i === 0) {
                  if (loop) escName += labelsEscalier[11];
                } else escName += labelsEscalier[i - 1];
              }
              var escs = escaliers;
              if (escName.startsWith('tmap_')) {
                if (!tmaps) {
                  tmaps = findObjs({
                    _type: 'graphic',
                    layer: 'gmlayer'
                  });
                  tmaps = tmaps.filter(function(e) {
                    return e.get('name').startsWith('tmap_');
                  });
                }
                escs = tmaps;
              }
              sortieEscalier = escs.find(function(esc2) {
                return esc2.get('name') == escName;
              });
              if (sortieEscalier === undefined && loop) {
                if (i > 0) { //sortie par le plus petit
                  escName = escName.substr(0, l - 1) + 'A';
                  sortieEscalier = escs.find(function(esc2) {
                    return esc2.get('name') == escName;
                  });
                } else {
                  sortieEscalier = findEsc(escs, escName.substr(0, l - 1), 10);
                }
              }
            }
          }
        });
        if (sortieEscalier) {
          let left = sortieEscalier.get('left');
          let top = sortieEscalier.get('top');
          let newPageId = sortieEscalier.get('pageid');
          //D\xE9placement du token
          if (newPageId == pageId) {
            token.set('left', left);
            token.set('top', top);
          } else {
            //On change de carte, il faut donc copier le token
            var tokenObj = JSON.parse(JSON.stringify(token));
            tokenObj._pageid = newPageId;
            //On met la taille du token \xE0 jour en fonction des \xE9chelles des cartes.
            var ratio = computeScale(pageId) / computeScale(newPageId);
            if (ratio < 0.9 || ratio > 1.1) {
              if (ratio < 0.25) ratio = 0.25;
              else if (ratio > 4) ratio = 4;
              tokenObj.width *= ratio;
              tokenObj.height *= ratio;
            }
            tokenObj.imgsrc = tokenObj.imgsrc.replace('/med.png', '/thumb.png');
            tokenObj.imgsrc = tokenObj.imgsrc.replace('/max.png', '/thumb.png');
            tokenObj.left = left;
            tokenObj.top = top;
            var newToken = createObj('graphic', tokenObj);
            if (newToken === undefined) {
              error("Impossible de copier le token, et donc de faire le changement de carte", tokenObj);
              return;
            }
          }
          //On d\xE9place ensuite le joueur.
          let character = getObj('character', perso.charId);
          if (character === undefined) return;
          let charControlledby = character.get('controlledby');
          if (charControlledby === '') {
            //Seul le MJ contr\xF4le le personnage
            let players = findObjs({
              _type: 'player',
              online: true
            });
            let gm = players.find(function(p) {
              return playerIsGM(p.id);
            });
            if (gm) {
              if (newPageId != pageId) movePlayerToPage(gm.id, pageId, newPageId);
              sendPing(left, top, newPageId, gm.id, true, gm.id);
            }
          } else {
            charControlledby.split(",").forEach(function(pid) {
              if (newPageId != pageId) movePlayerToPage(pid, pageId, newPageId);
              sendPing(left, top, newPageId, pid, true, pid);
            });
          }
          //Enfin, on efface le token de d\xE9part si on a chang\xE9 de page
          if (newPageId != pageId) token.remove();
          return;
        }
        let err = nomPerso(perso) + " n'est pas sur un escalier";
        if (!loop) {
          if (versLeHaut) err += " qui monte";
          else err += " qui descend";
        }
        sendPlayer(msg, err, playerId);
      });
    }); //fin getSelected
  }

  function defautDansLaCuirasse(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-defaut-dans-la-cuirasse", args);
      return;
    }
    var tireur = persoOfId(args[1], args[1]);
    if (tireur === undefined) {
      error("Le premier argument n'est pas un token valide", args[1]);
      return;
    }
    var pageId = tireur.token.get('pageid');
    var cible = persoOfId(args[2], args[2], pageId);
    if (cible === undefined) {
      error("La cible n'est pas un token valide", args[2]);
      return;
    }
    var evt = {
      type: "D\xE9faut dans la cuirasse"
    };
    setTokenAttr(cible, 'defautDansLaCuirasse_' + nomPerso(tireur), 2, evt);
    sendPerso(tireur, "passe le tour \xE0 analyser les points faibles de " + nomPerso(cible));
    addEvent(evt);
  }

  function postureDeCombat(msg) {
    var args = msg.content.split(' ');
    if (args.length < 4) {
      error("Pas assez d'arguments pour !cof-posture-de-combat", args);
      return;
    }
    var bonus = parseInt(args[1]);
    var attrDebuf = args[2];
    if (attrDebuf != 'DEF' && attrDebuf != 'ATT' && attrDebuf != 'DM') {
      error("L'attribut \xE0 d\xE9buffer pour la posture de combat est incorrect", args);
      return;
    }
    var attrBuf = args[3];
    if (attrBuf != 'DEF' && attrBuf != 'ATT' && attrBuf != 'DM') {
      error("L'attribut \xE0 augmenter pour la posture de combat est incorrect", args);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(guerrier) {
        if (isNaN(bonus) || bonus < 1) {
          sendPlayer(msg, "choisir un bonus positif (pas " + args[1] + ") pour sa posture de combat", playerId);
          return;
        }
        var rang = predicateAsInt(guerrier, "voieDuSoldat", 0);
        if (rang > 0 && rang < bonus) {
          sendPerso(guerrier, "ne peut choisir qu'un bonus inf\xE9rieur \xE0 " + rang + " pour sa posture de combat");
          return;
        }
        var evt = {
          type: "Posture de combat"
        };
        if (attrBuf == attrDebuf) {
          sendPerso(guerrier, "prend une posture de combat neutre");
          removeTokenAttr(guerrier, 'postureDeCombat', evt);
          addEvent(evt);
          return;
        }
        msg = "prend une posture ";
        switch (attrBuf) {
          case 'DEF':
            msg += "d\xE9fensive";
            break;
          case 'ATT':
            msg += "offensive";
            break;
          case 'DM':
            msg += "puissante";
            break;
          default:
        }
        msg += " mais ";
        switch (attrDebuf) {
          case 'DEF':
            msg += "risqu\xE9e";
            break;
          case 'ATT':
            msg += "moins pr\xE9cise";
            break;
          case 'DM':
            msg += "moins puissante";
            break;
          default:
        }
        setTokenAttr(guerrier, 'postureDeCombat', bonus, evt, {
          msg: msg,
          maxVal: attrDebuf + "_" + attrBuf
        });
        addEvent(evt);
      });
    });
  }

  function attaqueAOutrance(msg) {
    let args = msg.content.split(' ');
    if (args.length < 2) {
      error("Pas assez d'arguments pour !cof-attaque-a-outrance", args);
      return;
    }
    let bonus = parseInt(args[1]);
    if (bonus != 0 && bonus != 2 && bonus != 5) {
      error("Le malus de DEF ne peut \xEAtre que 0, 2 ou 5", args);
      return;
    }
    getSelected(msg, function(selected) {
      iterSelected(selected, function(guerrier) {
        const evt = {
          type: "Attaque \xE0 outrance"
        };
        if (bonus === 0) {
          sendPerso(guerrier, "n'attaque plus \xE0 outrance");
          removeTokenAttr(guerrier, 'attaqueAOutrance', evt);
          addEvent(evt);
          return;
        }
        msg = "attaque \xE0 outrance ";
        switch (bonus) {
          case 2:
            msg += "(-2 DEF, +1D6 DM)";
            break;
          case 5:
            msg += "(-5 DEF, +2D6 DM)";
            break;
          default:
        }
        setTokenAttr(guerrier, 'attaqueAOutrance', bonus, evt, {
          msg: msg,
        });
        addEvent(evt);
      });
    });
  }

  function parseTourDeForce(msg) { // Deprecated
    var options = parseOptions(msg);
    var cmd = options.cmd;
    if (cmd < 2) {
      error("Il manque un argument \xE0 !cof-tour-de-force", cmd);
      return;
    }
    var seuil = parseInt(cmd[1]);
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(barbare) {
        if (isNaN(seuil)) {
          sendPlayer(msg, "le seuil de difficult\xE9 du tour de force doit \xEAtre un nombre", playerId);
          return;
        }
        doTourDeForce(barbare, seuil, options);
      });
    });
  }

  function doTourDeForce(perso, seuil, options) { // Deprecated
    let evt = {
      type: "tourDeForce",
      action: {
        perso: perso,
        seuil: seuil,
        options: options
      }
    };
    addEvent(evt);
    let action = "<b>Capacit\xE9</b> : Tour de force";
    let display = startFramedDisplay(options.playerId, action, perso);
    let testId = 'tourDeForce';
    options.bonus = 10;
    testCaracteristique(perso, 'FOR', seuil, testId, options, evt,
      function(tr) {
        addLineToFramedDisplay(display, " Jet de force difficult\xE9 " + seuil);
        let smsg = nomPerso(perso) + " fait " + tr.texte;
        if (tr.reussite) {
          smsg += " => r\xE9ussite";
        } else {
          smsg += " => \xE9chec" + tr.rerolls;
        }
        addLineToFramedDisplay(display, smsg);
        let d4 = options.rolls.tourDeForceDmg || rollDePlus(4);
        evt.action.rolls.tourDeForceDmg = d4;
        let r = {
          total: d4.val,
          type: 'normal',
          display: d4.roll
        };
        let explications = [];
        perso.ignoreTouteRD = true;
        dealDamage(perso, r, [], evt, false, {}, explications,
          function(dmgDisplay, dmg) {
            let dmgMsg = "mais cela lui co\xFBte " + dmgDisplay + " PV";
            addLineToFramedDisplay(display, dmgMsg);
            explications.forEach(function(expl) {
              addLineToFramedDisplay(display, expl, 80);
            });
            sendChat('', endFramedDisplay(display));
          });
      });
  }

  function removePreDmg(options, perso, champ, newVal) {
    if (options.preDmg) {
      if (options.preDmg[perso.token.id]) {
        if (champ && options.preDmg[perso.token.id][champ]) {
          if (newVal) options.preDmg[perso.token.id][champ] = newVal;
          else delete options.preDmg[perso.token.id][champ];
        }
        if (champ === undefined || _.isEmpty(options.preDmg[perso.token.id]))
          delete options.preDmg[perso.token.id];
      }
      if (_.isEmpty(options.preDmg)) delete options.preDmg;
    }
  }

  //!cof-encaisser-un-coup, avec la personne qui encaisse s\xE9lectionn\xE9e
  function doEncaisserUnCoup(msg) {
    var optionsEncaisser = parseOptions(msg);
    if (optionsEncaisser === undefined) return;
    var cmd = optionsEncaisser.cmd;
    var evt = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evt = findEvent(cmd[1]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Personne n'est s\xE9lectionn\xE9 pour encaisser un coup", msg);
        return;
      }
      if (evt === undefined) {
        sendChat('', "Historique d'actions vide, pas d'action trouv\xE9e pour encaisser un coup");
        return;
      }
      if (evt.type != 'Attaque' || evt.succes === false) {
        sendChat('', "la derni\xE8re action n'est pas une attaque r\xE9ussie, trop tard pour encaisser le coup d'une action pr\xE9c\xE9dente");
        return;
      }
      var action = evt.action;
      if (action.options.distance) {
        sendChat('', "Impossible d'encaisser le dernier coup, ce n'\xE9tait pas une attaque au contact");
        return;
      }
      var toProceed;
      iterSelected(selected, function(chevalier) {
        if (!attributeAsBool(chevalier, 'encaisserUnCoup')) {
          sendPerso(chevalier, "n'est pas plac\xE9 pour encaisser un coup");
          return;
        }
        if (!peutController(msg, chevalier)) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton", playerId);
          return;
        }
        var cible = action.cibles.find(function(target) {
          return (target.token.id === chevalier.token.id);
        });
        if (cible === undefined) {
          sendPerso(chevalier, "n'est pas la cible de la derni\xE8re attaque");
          return;
        }
        action.choices = action.choices || {};
        action.choices[chevalier.token.id] = action.choices[chevalier.token.id] || {};
        action.choices[chevalier.token.id].encaisserUnCoup = true;
        toProceed = true;
      }); //fin iterSelected
      if (toProceed) {
        let options = action.currentOptions || {};
        options.rolls = action.rolls;
        options.choices = action.choices;
        resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, options, evt, action.explications, action.pageId, action.cibles);
      }
    }); //fin getSelected
  }

  function appliquerEncaisserUnCoup(cible, options, evt) {
    removeTokenAttr(cible, 'encaisserUnCoup', evt);
    cible.extraRD = defenseArmure(cible);
    removePreDmg(options, cible, "encaisserUnCoup");
  }

  //!cof-devier-les-coups, avec la personne qui encaisse s\xE9lectionn\xE9e
  function doDevierLesCoups(msg) {
    let optionsDevier = parseOptions(msg);
    if (optionsDevier === undefined) return;
    let cmd = optionsDevier.cmd;
    let evt = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evt = findEvent(cmd[1]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Personne n'est s\xE9lectionn\xE9 pour d\xE9vier les coups", msg);
        return;
      }
      if (evt === undefined) {
        sendChat('', "Historique d'actions vide, pas d'action trouv\xE9e pour d\xE9vier les coups");
        return;
      }
      if (evt.type != 'Attaque' || evt.succes === false) {
        sendChat('', "la derni\xE8re action n'est pas une attaque r\xE9ussie, trop tard pour d\xE9vier les coups d'une action pr\xE9c\xE9dente");
        return;
      }
      var action = evt.action;
      if (action.options.distance) {
        sendChat('', "Impossible d'encaisser le dernier coup, ce n'\xE9tait pas une attaque au contact");
        return;
      }
      var toProceed;
      iterSelected(selected, function(perso) {

        let testDevierCoups = testLimiteUtilisationsCapa(perso, 'devierLesCoups', 'tour', "ne peut plus d\xE9vier les coups \xE0 ce tour-ci");
        if (testDevierCoups === undefined) return;
        if (!peutController(msg, perso)) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton", playerId);
          return;
        }
        let cible = action.cibles.find(function(target) {
          return (target.token.id === perso.token.id);
        });
        if (cible === undefined) {
          sendPerso(perso, "n'est pas la cible de la derni\xE8re attaque");
          return;
        }
        action.choices = action.choices || {};
        action.choices[perso.token.id] = action.choices[perso.token.id] || {};
        action.choices[perso.token.id].devierLesCoups = testDevierCoups;
        toProceed = true;
      }); //fin iterSelected
      if (toProceed) {
        var options = action.currentOptions || {};
        options.rolls = action.rolls;
        options.choices = action.choices;
        resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, options, evt, action.explications, action.pageId, action.cibles);
      }
    }); //fin getSelected
  }

  function appliquerDevierLesCoups(cible, test, options, evt) {
    utiliseCapacite(cible, test, evt);
    cible.extraRDBouclier =
      ficheAttributeAsInt(cible, 'defbouclier', 0) *
      ficheAttributeAsInt(cible, 'defbouclieron', 0);
    removePreDmg(options, cible, 'devierLesCoups');
  }

  //!cof-parade-projectiles
  function doParadeProjectiles(msg) {
    var optionsParade = parseOptions(msg);
    if (optionsParade === undefined) return;
    var cmd = optionsParade.cmd;
    var evt = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evt = findEvent(cmd[1]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Personne n'est s\xE9lectionn\xE9 pour parer le projectile", msg);
        return;
      }
      if (evt === undefined) {
        sendChat('', "Historique d'actions vide, pas d'action trouv\xE9e pour parer le projectile");
        return;
      }
      if (evt.type != 'Attaque' || evt.succes === false) {
        sendChat('', "la derni\xE8re action n'est pas une attaque r\xE9ussie, trop tard pour parer le projectile d'une action pr\xE9c\xE9dente");
        return;
      }
      var action = evt.action;
      if (!action.options.distance) {
        sendChat('', "Impossible de parer le projectile, ce n'\xE9tait pas une attaque \xE0 distance");
        return;
      }
      if (action.options.poudre) {
        sendChat('', "Impossible de parer le projectile, il s'agit d'une arme \xE0 poudre");
        return;
      }
      if (action.cibles.length > 1) {
        sendChat('', "Impossible de parer un projectile qui touche plusieurs cibles");
        return;
      }
      let toProceed;
      iterSelected(selected, function(moine) {
        let testParadeProjectiles = testLimiteUtilisationsCapa(moine, 'paradeDeProjectiles', 'tour', "ne peut plus parer de projectiles");
        if (testParadeProjectiles === undefined) {
          return;
        }
        if (!peutController(msg, moine)) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton", playerId);
          return;
        }
        let cible = action.cibles.find(function(target) {
          return (target.token.id === moine.token.id);
        });
        if (cible === undefined) {
          sendPerso(moine, "n'est pas la cible de la derni\xE8re attaque");
          return;
        }
        action.choices = action.choices || {};
        action.choices[moine.token.id] = action.choices[moine.token.id] || {};
        action.choices[moine.token.id].paradeDeProjectiles = testParadeProjectiles;
        toProceed = true;
      }); //fin iterSelected
      if (toProceed) {
        var options = action.currentOptions || {};
        options.rolls = action.rolls;
        options.choices = action.choices;
        resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, options, evt, action.explications, action.pageId, action.cibles);
      }
    }); //fin getSelected
  }

  function appliquerParadeProjectiles(cible, test, options, evt) {
    utiliseCapacite(cible, test, evt);
    options.preDmgAnnule = true;
    removePreDmg(options, cible);
  }

  // asynchrone : on fait les jets du personnage en opposition
  // options :
  // predicat : on utilise un pr\xE9dicat et non un attribut. Peut \xEAtre 'tour' ou 'combat'
  // protecteur: c'est un protecteur qui prot\xE8ge la cible (pas compatible avec predicate
  function evitementGenerique(msg, verbe, attributeName, actionName, tente, msgDejaFait, carac, typeAttaque, msgReussite, opt) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 1) {
      error("Impossible de trouve la commande !", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Pas assez d'arguments pour " + cmd[0], cmd);
      return;
    }
    let evt;
    let chance;
    if (cmd.length > 2) { //On relance pour un \xE9v\xE9nement particulier
      evt = findEvent(cmd[2]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
      chance = cmd.length > 3 && cmd[3] == 'chance';
    } else {
      evt = lastEvent();
    }
    if (evt === undefined) {
      sendChat('', "Historique d'actions vide, pas d'action trouv\xE9e pour esquiver");
      return;
    }
    if (evt.type != 'Attaque') {
      sendChat('', "la derni\xE8re action n'est pas une attaque r\xE9ussie, trop tard pour " + verbe + " l'attaque pr\xE9c\xE9dente");
      return;
    }
    const perso = persoOfId(cmd[1]);
    if (perso === undefined) {
      error("Le premier argument de " + cmd[0] + " n'est pas un token de personnage", cmd);
      return;
    }
    let action = evt.action;
    let optionsAttaque = action.currentOptions;
    let pageId = action.pageId;
    let cible = action.cibles.find(function(target) {
      return (target.token.id === perso.token.id);
    });
    if (cible === undefined) {
      sendPerso(perso, "n'est pas la cible de la derni\xE8re attaque");
      return;
    }
    let attributAVerifier = attributeName;
    let persoAttribut = perso;
    if (opt.protecteur) { // c'est un personnage tiers qui prot\xE8ge la cible
      let protecteurAttrs = tokenAttribute(perso, attributeName + 'Valeur');
      if (protecteurAttrs.length < 1) {
        error("Erreur interne dans le bouton de protection, protecteur introuvable", cmd);
        return;
      }
      persoAttribut = persoOfId(protecteurAttrs[0].get("current"));
      attributAVerifier = attributeName + "Actif";
      if (persoAttribut === undefined) {
        error("Erreur interne dans le bouton de protection, protecteur introuvable", cmd);
        return;
      }
      opt.protecteur = persoAttribut;
    }
    if (!peutController(msg, persoAttribut)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    if (opt && opt.condition && !opt.condition(perso)) {
      resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, optionsAttaque, evt, action.explications, pageId, action.cibles);
    }
    let jetAdversaire = cible.attackRoll;
    if (jetAdversaire === undefined) {
      error("Impossible de trouver le jet de l'attaquant", cible);
      return;
    }
    let attribut;
    let testPredicat;
    if (opt && opt.predicat) {
      testPredicat = testLimiteUtilisationsCapa(perso, attributeName, opt.predicat, msgDejaFait, "ne sait pas faire " + actionName);
      if (testPredicat === undefined) return;
      testPredicat.perso = perso;
    } else if (attributAVerifier) {
      attribut = tokenAttribute(persoAttribut, attributAVerifier);
      if (attribut.length === 0) {
        sendPerso(persoAttribut, "ne sait pas faire " + actionName);
        return;
      }
      attribut = attribut[0];
      if (opt && opt.attrAsBool) {
        if (!attribut.get('current')) {
          sendPerso(persoAttribut, msgDejaFait);
          return;
        }
      } else {
        let curAttribut = parseInt(attribut.get('current'));
        if (isNaN(curAttribut)) {
          error("Resource pour " + actionName + " mal form\xE9e", attribut);
          return;
        }
        if (curAttribut < 1) {
          sendPerso(persoAttribut, msgDejaFait);
          return;
        }
      }
    }
    optionsAttaque.choices = action.choices || {};
    optionsAttaque.choices[perso.token.id] = optionsAttaque.choices[perso.token.id] || {};
    optionsAttaque.choices[perso.token.id].evitementGenerique =
      optionsAttaque.choices[perso.token.id].evitementGenerique || [];
    optionsAttaque.choices[perso.token.id].evitementGenerique.push({
      jetAdversaire,
      attribut,
      testPredicat,
      opt,
      attributeName,
      actionName,
      tente,
      carac,
      typeAttaque,
      msgReussite
    });
    optionsAttaque.rolls = action.rolls;
    resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, optionsAttaque, evt, action.explications, action.pageId, action.cibles);
  }

  function appliquerEvitementGenerique(cible, evitementGen, pageId, options, evt, callback) {
    let action = evt.action;
    let lanceur = cible;
    let {
      jetAdversaire,
      attribut,
      testPredicat,
      opt,
      attributeName,
      actionName,
      tente,
      carac,
      typeAttaque,
      msgReussite
    } = evitementGen;
    if (opt && opt.protecteur) {
      lanceur = opt.protecteur;
    }
    if (attribut) {
      if (opt && opt.attrAsBool) {
        evt.deletedAttributes = evt.deletedAttributes || [];
        evt.deletedAttributes.push(attribut);
      } else {
        let curAttribut = parseInt(attribut.get('current'));
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attribut,
          current: curAttribut
        });
        attribut.set('current', curAttribut - 1);
      }
    } else if (testPredicat) {
      utiliseCapacite(testPredicat.perso, testPredicat, evt);
    } else if (attributeName !== undefined) { //ni attribut ni pr\xE9dicat
      error("On n'a ni attribut ni pr\xE9dicat pour un \xE9vitement g\xE9n\xE9rique", evitementGen);
      return;
    }
    let optDice;
    if (typeAttaque == 'esquive') {
      let nbDe = nbreDeTestCarac(carac, lanceur);
      optDice = {
        carac,
        nbDe
      };
    }
    let attackRollExpr = "[[" + computeDice(lanceur, optDice) + "cs20cf1]]";
    sendChat('', attackRollExpr, function(res) {
      let testId = attributeName + "_" + lanceur.token.id;
      options.rolls = options.rolls || {};
      let attackRoll = options.rolls[testId] || res[0].inlinerolls[0];
      attackRoll.token = lanceur.token;
      evt.action.rolls = evt.action.rolls || {};
      evt.action.rolls[testId] = attackRoll;
      let d20roll = attackRoll.results.total;
      if (stateCOF.foudreDuTemps) foudreDuTemps(lanceur, d20roll);
      let msg = buildinline(attackRoll);
      let attBonus = ficheAttributeAsInt(lanceur, 'niveau', 1);
      if (estAffaibli(lanceur) && predicateAsBool(lanceur, 'insensibleAffaibli')) attBonus -= 2;
      switch (typeAttaque) {
        case 'distance':
          attBonus += ficheAttributeAsInt(lanceur, 'ATKTIR_DIV', 0);
          if (persoArran(lanceur)) {
            attBonus += ficheAttributeAsInt(lanceur, 'mod_atktir', 0);
          }
          attBonus += modCarac(lanceur, carac);
          break;
        case 'magique':
          attBonus += ficheAttributeAsInt(lanceur, 'ATKMAG_DIV', 0);
          if (persoArran(lanceur)) {
            attBonus += ficheAttributeAsInt(lanceur, 'mod_atkmag', 0);
            attBonus += modCarac(lanceur, 'intelligence');
          } else {
            attBonus += modCarac(lanceur, carac);
          }
          attBonus += predicateAsInt(lanceur, 'bonusAttaqueMagique', 0);
          break;
        case 'contact':
          attBonus += ficheAttributeAsInt(lanceur, 'ATKCAC_DIV', 0);
          attBonus += modCarac(lanceur, carac);
          break;
        case 'esquive':
          attBonus += predicateAsInt(lanceur, 'reflexesFelins', 0);
          attBonus += predicateAsInt(lanceur, 'esquiveVoleur', 0);
          attBonus += modCarac(lanceur, carac);
          break;
        default:
      }
      if (opt && opt.arme && lanceur.arme) {
        actionName = lanceur.arme.nom;
        if (lanceur.arme.attSkillDiv) attBonus += lanceur.arme.attSkillDiv;
      }
      if (opt && opt.armeGauche && lanceur.armeGauche) {
        actionName = lanceur.armeGauche.nom;
        if (lanceur.armeGauche.attSkillDiv) attBonus += lanceur.armeGauche.attSkillDiv;
      }
      let totalEvitement = d20roll + attBonus;
      if (attBonus > 0) msg += "+" + attBonus;
      else if (attBonus < 0) msg += attBonus;
      if (options.chanceRollId && options.chanceRollId[testId]) {
        totalEvitement += options.chanceRollId[testId];
        msg += "+" + options.chanceRollId[testId];
      }
      const optionsEvitement = {
        displayName: true,
        pasDeDmg: true
      };
      let attEvBonus = bonusAttaqueA(cible, actionName, evt, cible.messages, optionsEvitement);
      let bad = bonusAttaqueD(lanceur, action.attaquant, 0, pageId, evt, cible.messages, optionsEvitement);
      attEvBonus += bad;
      if (opt && opt.bonusAttaque) attEvBonus += opt.bonusAttaque;
      if (attEvBonus > 0) msg += "+" + attEvBonus;
      else if (attEvBonus < 0) msg += attEvBonus;
      msg = nomPerso(lanceur) + " tente " + tente + ". " +
        onGenre(lanceur, "Il", "elle") + " fait " + msg;
      var generalMsg = '';
      if (totalEvitement < jetAdversaire) {
        msg += " => Rat\xE9";
        var pc = pointsDeChance(lanceur);
        if (attackRoll.results.total != 1 && pc > 0) {
          generalMsg += '<br/>' +
            boutonSimple("!cof-bouton-chance " + evt.id + " " + testId, "Chance") +
            " (reste " + pc + " PC)";
        }
        if (stateCOF.combat && attributeAsBool(lanceur, 'runeForgesort_\xE9nergie') &&
          attributeAsInt(lanceur, 'limiteParCombat_runeForgesort_\xE9nergie', 1) > 0 &&
          (carac == 'force' || carac == 'constitution' || carac == 'dexterite')) {
          generalMsg += '<br/>' + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + testId, "Rune d'\xE9nergie");
        }
        if (stateCOF.combat && capaciteDisponible(lanceur, 'petitVeinard', 'combat')) {
          generalMsg += '<br/>' + boutonSimple("!cof-bouton-petit-veinard " + evt.id + " " + testId, "Petit veinard");
        }
        if (generalMsg === '') { //Ne retirer l'option que si aucun reroll possible
          removePreDmg(options, cible, attributeName);
        } else { //Sinon cacher le bouton mais laisser l'option reroll
          removePreDmg(options, cible, attributeName, 'reroll');
        }
      } else { //\xC9vitement r\xE9ussi
        if (opt && cible.critique && (opt.critiqueDevientNormal || (opt.critiqueAnnuleCritique && d20roll != 20))) {
          cible.critique = false;
          msg += " => R\xE9ussi, l'attaque fait des d\xE9g\xE2ts normaux";
          removePreDmg(options, cible, attributeName);
        } else {
          cible.touche = false;
          if (opt.annule) {
            delete options.preDmg;
            options.preDmgAnnule = true;
            generalMsg += " => R\xE9ussi, " + msgReussite;
          } else {
            action.ciblesTouchees = action.ciblesTouchees.filter(function(c) {
              return c.token.id != cible.token.id;
            });
            removePreDmg(options, cible);
            msg += " => R\xE9ussi, " + msgReussite;
          }
        }
      }
      callback(msg, generalMsg);
    });
  }

  //!cof-absorber-coup-au-bouclier id [evtid] [chance]
  function absorberCoupAuBouclier(msg) {
    var condition = function(guerrier) {
      if (ficheAttributeAsInt(guerrier, 'defbouclieron', 0) != 1) {
        sendPerso(guerrier, "ne porte pas son bouclier, il ne peut pas aborber de coup");
        return false;
      }
      return true;
    };
    evitementGenerique(msg, "absorber un coup au bouclier", 'absorberUnCoup',
      "d'absorption de coup au bouclier", "d'absorber un coup au bouclier",
      " a d\xE9j\xE0 essay\xE9 d'absorber un coup au bouclier ce tour", 'force', 'contact', "le coup est absorb\xE9 !", {
        attrAsBool: true,
        condition: condition
      });
  }

  //!cof-absorber-sort-au-bouclier id [evtid] [chance]
  function absorberSortAuBouclier(msg) {
    var condition = function(guerrier) {
      if (ficheAttributeAsInt(guerrier, 'defbouclieron', 0) != 1) {
        sendPerso(guerrier, "ne porte pas son bouclier, il ne peut pas aborber un sort");
        return false;
      }
      return true;
    };
    evitementGenerique(msg, "absorber un sort au bouclier", 'absorberUnSort',
      "d'absorption de sort au bouclier", "d'absorber un sort au bouclier",
      " a d\xE9j\xE0 essay\xE9 d'absorber un sort au bouclier ce tour", 'sagesse', 'magique', "le sort est absorb\xE9 !", {
        attrAsBool: true,
        condition: condition
      });
  }

  // asynchrone : on fait les jets du barbare en opposition
  //!cof-resister-a-la-magie id [evtid] [chance]
  function resisterALaMagie(msg) {
    evitementGenerique(msg, 'r\xE9sister \xE0 la magie', 'resistanceALaMagieBarbare',
      'r\xE9sistance \xE0 la magie', "de r\xE9sister \xE0 la magie",
      " a d\xE9j\xE0 essay\xE9 de r\xE9sister \xE0 la magie ce tour",
      'sagesse', 'magique', "il r\xE9siste \xE0 la magie !", {
        predicat: 'tour'
      });
  }

  // asynchrone : on fait les jets du magicien protecteur en opposition
  //!cof-cercle-protection id [evtid] [chance]
  function cercleDeProtection(msg) {
    evitementGenerique(msg, 'activer le cercle de protection', 'cercleDeProtection',
      'activation du cercle de protection', "de bloquer le sort avec le Cercle de Protection",
      " a d\xE9j\xE0 active le Cercle de Protection ce tour",
      'intelligence', 'magique', "le sort est annul\xE9 !", {
        protecteur: true,
        annule: true
      });
  }

  // asynchrone : on fait les jets du barde en opposition
  //!cof-esquive-acrobatique id [evtid] [chance]
  function doEsquiveAcrobatique(msg) {
    evitementGenerique(msg, 'esquiver', 'esquiveAcrobatique',
      'esquive acrobatique', "une esquive acrobatique", " a d\xE9j\xE0 fait une esquive acrobatique ce tour", 'dexterite', 'distance', "l'attaque est esquiv\xE9e !", {
        critiqueDevientNormal: true,
        predicat: 'tour'
      });
  }

  function doEsquiveDeLaMagie(msg) {
    evitementGenerique(msg, 'esquiver', undefined,
      "esquive de la magie", "d'esquiver la magie", " a d\xE9j\xE0 fait esquiv\xE9 la magie", 'dexterite', 'esquive', "l'attaque est esquiv\xE9e !", {});
  }

  function doEsquiveMagistrale(msg) {
    evitementGenerique(msg, 'esquiver', 'paradeMagistrale',
      'esquive acrobatique', "une esquive acrobatique", " a d\xE9j\xE0 fait une parade magistrale ce tour", 'dexterite', 'distance', "l'attaque est esquiv\xE9e !", {
        bonusAttaque: -5,
        critiqueDevientNormal: true,
        predicat: 'tour'
      });
  }

  function doParadeMagistrale(msg) {
    evitementGenerique(msg, 'parer', 'paradeMagistrale',
      'parade magistrale', "une parade magistrale", " a d\xE9j\xE0 fait une parade magistrale ce tour", 'dexterite', 'distance', "l'attaque est par\xE9e !", {
        arme: true,
        critiqueDevientNormal: true,
        predicat: 'tour'
      });
  }

  //!cof-parade-au-bouclier
  function doParadeAuBouclier(msg) {
    evitementGenerique(msg, 'parer', 'paradeAuBouclier',
      'parade au bouclier', "une parade au bouclier", " a d\xE9j\xE0 fait une parade au bouclier ce tour", 'force', 'contact', "l'attaque est par\xE9e !", {
        armeGauche: true,
        critiqueAnnuleCritique: true,
        predicat: 'tour'
      });
  }

  //!cof-chair-a-canon id1 id2 [evt_id]
  // id1 est l'id du pnj r\xE9current
  // id2 est l'id du token qui se met devant l'attaque
  function doChairACanon(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("pas assez d'argumennts pour !cof-chair-a-canon", cmd);
      return;
    }
    let evtARefaire;
    if (cmd.length > 3) { //On relance pour un \xE9v\xE9nement particulier
      evtARefaire = findEvent(cmd[3]);
    } else {
      evtARefaire = lastEvent();
    }
    if (evtARefaire === undefined) {
      error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
      return;
    }
    let pnjRec = persoOfId(cmd[1]);
    if (pnjRec === undefined) {
      error("Le premier argument de !cof-chair-a-canon n'est pas un token de personnage", cmd);
      return;
    }
    if (!peutController(msg, pnjRec)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let testChairACanon = testLimiteUtilisationsCapa(pnjRec, 'chairACanon', 'tour', "a d\xE9j\xE0 utilis\xE9 un sous-fifre ce tour", "ne sait pas utiliser ses sous-fifres pour se d\xE9fendre");
    if (testChairACanon === undefined) {
      return;
    }
    let sousFifre = persoOfId(cmd[2]);
    if (sousFifre === undefined) {
      error("Le second argument de !cof-chair-a-canon n'est pas un token de personnage", cmd);
      return;
    }
    if (evtARefaire === undefined) {
      sendChat('', "Historique d'actions vide, pas d'action trouv\xE9e pour la chair \xE0 canon");
      return;
    }
    if (evtARefaire.type != 'Attaque') {
      sendChat('', "la derni\xE8re action n'est pas une attaque");
      return;
    }
    let attaque = evtARefaire.action;
    if (attaque === undefined) {
      error("Attaque sans action", evtARefaire);
      return;
    }
    let originalTarget;
    attaque.cibles = attaque.cibles.filter(function(c) {
      if (originalTarget) return true;
      if (c.token.id != cmd[1]) return true;
      originalTarget = c;
      return false;
    });
    if (originalTarget === undefined) {
      error("Impossible de trouver " + nomPerso(pnjRec) + " parmi les cibles de l'attaque", attaque);
      return;
    }
    sousFifre.rollDmg = originalTarget.rollDmg;
    sousFifre.chairACanon = true;
    attaque.cibles.push(sousFifre);
    let optionsRedo = attaque.options;
    optionsRedo.rolls = attaque.rolls;
    let evt = {
      type: "chair \xE0 canon"
    };
    utiliseCapacite(pnjRec, testChairACanon, evt);
    undoEvent(evtARefaire);
    addEvent(evt);
    removePreDmg(attaque.options, originalTarget);
    redoEvent(evtARefaire, attaque);
  }

  // modifie res et le retourne (au cas o\xF9 il ne serait pas donn\xE9)
  function listRollResults(roll, res) {
    res = res || [];
    switch (roll.type) {
      case 'V': //top-level des rolls
        if (roll.rolls === undefined) break;
        roll.rolls.forEach(function(r) {
          listRollResults(r, res);
        });
        return res;
      case 'R': //jet simple
        if (roll.results === undefined) break;
        roll.results.forEach(function(r) {
          if (r.v) res.push(r.v);
          else if (r.d) res.push(r.d);
          else log("Type de r\xE9sultat de d\xE9 inconnu " + r);
        });
        return res;
      case 'M':
      case 'L':
        return res;
      case 'G':
        if (roll.rolls === undefined) break;
        roll.rolls.forEach(function(ra) {
          ra.forEach(function(r) {
            listRollResults(r, res);
          });
        });
        return res;
      default:
        log("tag inconnu");
    }
    error("Structure de roll inconnue", roll);
    return res;
  }

  //category est un tableau de string, le premier \xE9l\xE9ment \xE9tant la cat\xE9gorie
  //principale, le suivant la sous-cat\xE9gorie, etc
  //value peut \xEAtre un nombre, un tableau de nombres, ou un inline roll
  function addStatistics(playerId, category, value) {
    if (stateCOF.statistiques === undefined) return;
    var stat = stateCOF.statistiques;
    if (playerId) {
      var player = getObj('player', playerId);
      if (player) {
        //On utilise l'id roll20 qui semble persistante
        var pid = player.get('d20userid');
        stat[pid] = stat[pid] || {};
        stat = stat[pid];
      }
    }
    if (category) {
      category.forEach(function(cat) {
        stat[cat] = stat[cat] || {};
        stat = stat[cat];
      });
    }
    if (!Array.isArray(value)) {
      if (value.results) value = listRollResults(value.results);
      else value = [value];
    }
    value.forEach(function(v) {
      if (isNaN(v)) {
        error("statistique sur une valeur qui n'est pas un nombre", value);
        return;
      }
      if (typeof v != 'number') v = parseInt(v);
      if (stat.total) stat.total += v;
      else stat.total = v;
      if (stat.nombre) stat.nombre++;
      else stat.nombre = 1;
    });
  }

  function displayStatCategory(stats, indent, categoryName, accum) {
    var res = {
      nombre: 0,
      total: 0,
    };
    if (stats.nombre) { //on peut afficher des r\xE9sultats
      res.nombre = stats.nombre;
      res.total = stats.total;
    }
    var nindent = indent + "&nbsp;&nbsp;";
    var nAccum = [];
    for (const category in stats) {
      if (category == 'total' || category == 'nombre') break;
      var catRes = displayStatCategory(stats[category], nindent, category, nAccum);
      res.nombre += catRes.nombre;
      res.total += catRes.total;
    }
    var msg = "aucun jet cellect\xE9";
    if (res.nombre > 0) {
      var moyenne = res.total / res.nombre;
      msg = res.nombre + " jet" + ((res.nombre > 1) ? "s" : "") + ", moyenne " + moyenne;
    }
    if (nAccum.length > 0) msg = indent + categoryName + " (" + msg + ") :";
    else msg = indent + categoryName + " : " + msg;
    accum.push(msg);
    nAccum.forEach(function(m) {
      accum.push(m);
    });
    return res;
  }

  function displayStatistics(msg) {
    var stats = stateCOF.statistiques;
    var display = startFramedDisplay(getPlayerIdFromMsg(msg), "Statistiques");
    if (stats === undefined) {
      stats = stateCOF.statistiquesEnPause;
      if (stats)
        addLineToFramedDisplay(display, "Statistiques en pause");
      else {
        addLineToFramedDisplay(display, "Aucune statistique collect\xE9e");
        sendChat("COF", endFramedDisplay(display));
        return;
      }
    }
    var tot = {
      total: 0,
      nombre: 0
    };
    var players = findObjs({
      type: 'player'
    });
    var findPlayer = function(pid) {
      return players.find(function(p) {
        return (p.get('d20userid') == pid);
      });
    };
    var addMessages = function(mv) {
      mv.forEach(function(m) {
        addLineToFramedDisplay(display, m);
      });
    };
    for (const category in stats) {
      //first, check if the category is a player id
      var pl = findPlayer(category);
      var catName = category;
      if (pl) catName = pl.get('displayname');
      var accum = [];
      var catRes = displayStatCategory(stats[category], "", catName, accum);
      addMessages(accum);
      tot.total += catRes.total;
      tot.nombre += catRes.nombre;
    }
    addLineToFramedDisplay(display, tot.nombre + " jets au total, dont la somme fait " + tot.total);
    sendChat("COF", endFramedDisplay(display));
  }

  function parseDestructionDesMortsVivants(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    let args = options.cmd;
    if (args === undefined || args.length < 2) {
      error("Il faut au moins un argument \xE0 !cof-destruction-des-morts-vivants", args);
      return;
    }
    args.shift();
    let dm = args.join(' ');
    dm = dm.replace(/%/g, '&#37;');
    dm = dm.replace(/\)/g, '&#41;');
    dm = dm.replace(/\?/g, '&#63;');
    dm = dm.replace(/@/g, '&#64;');
    dm = dm.replace(/\[/g, '&#91;');
    dm = dm.replace(/\]/g, '&#93;');
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Il faut s\xE9lectionner le lanceur de la destruction des morts-vivants", playerId);
        return;
      }
      if (selected.length > 1) {
        sendPlayer(msg, "Ne s\xE9lectionner qu'un token \xE0 la fois pour lancer la destruction des mort-vivants.", playerId);
        return;
      }
      let playerName = msg.who;
      if (playerIsGM(playerId)) playerName = 'GM';
      iterSelected(selected, function(lanceur) {
        if (options.tempeteDeMana) {
          if (options.tempeteDeMana.cout === 0) {
            //On demande de pr\xE9ciser les options
            var optMana = {
              mana: options.mana,
              dm: true,
              soins: false,
              duree: false,
              rang: options.rang,
            };
            setTempeteDeMana(playerId, lanceur, msg.content, optMana);
            return;
          } else {
            if (options.rang && options.tempeteDeMana.cout > options.rang) {
              sendPlayerAndGM(msg, playerId, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
            }
          }
        }
        if (options.tempeteDeManaIntense) {
          let findNbDes = dm.match(/^([0-9]+)d/);
          if (findNbDes && findNbDes.length > 1) {
            let nbDes = parseInt(findNbDes[1]);
            dm = dm.replace(findNbDes[0], (nbDes + options.tempeteDeManaIntense) + 'd');
          } else {
            log("Pas r\xE9ussi \xE0 trouver le nombre de d\xE9s dans " + dm);
          }
        } else if (options.puissant) {
          let findValDes = dm.match(/^([0-9]+d)([0-9]+)/);
          if (findValDes && findValDes.length > 2) {
            let valDes = parseInt(findValDes[2]) + 2;
            dm = dm.replace(findValDes[0], findValDes[1] + valDes);
          } else {
            log("Pas r\xE9ussi \xE0 trouver le nombre de faces des d\xE9s dans " + dm);
          }
        }
        doDestructionDesMortsVivants(lanceur, playerName, dm, options);
      });
    });
  }

  function doDestructionDesMortsVivants(lanceur, playerName, dm, options) {
    let playerId = options.playerId;
    let evt = {
      type: "destructionMortsVivants",
      action: {
        lanceur: lanceur,
        playerName: playerName,
        playerId: playerId,
        dm: dm,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'destructionDesMortsVivants', "lancer une destruction des mort-vivants", evt)) return;
    let display = startFramedDisplay(playerId,
      "<b>Sort :<b> destruction des morts-vivants", lanceur);
    let testId = 'destructionDesMortsVivants_' + lanceur.token.id;
    let difficulte = 13;
    let malusRepetition;
    if (options.malusRepetition) {
      malusRepetition = attributeAsInt(lanceur, 'limiteParCombat_malusDestructionDesMortsVivants', 0);
      difficulte += malusRepetition;
      malusRepetition += options.malusRepetition;
    }
    testCaracteristique(lanceur, 'SAG', difficulte, testId, options, evt,
      function(testRes) {
        let msgJet = "Jet de SAG : " + testRes.texte;
        if (testRes.reussite) {
          addLineToFramedDisplay(display, msgJet + " &ge; " + difficulte + testRes.modifiers);
          if (malusRepetition)
            setTokenAttr(lanceur, 'limiteParCombat_malusDestructionDesMortsVivants', malusRepetition, evt);
          let cibles = [];
          let page = getObj("page", options.pageId);
          let murs = getWalls(page, options.pageId);
          let pt;
          if (murs) {
            pt = {
              x: lanceur.token.get('left'),
              y: lanceur.token.get('top')
            };
          }
          let tokensEnVue = findObjs({
            _type: 'graphic',
            _pageid: options.pageId,
            _subtype: 'token',
            layer: 'objects'
          });
          tokensEnVue.forEach(function(obj) {
            if (obj.id == lanceur.token.id) return;
            let objCharId = obj.get('represents');
            if (objCharId === '') return;
            if (obj.get('bar1_max') == 0) return; // jshint ignore:line
            let objChar = getObj('character', objCharId);
            if (objChar === undefined) return;
            if (murs) {
              if (obstaclePresent(obj.get('left'), obj.get('top'), pt, murs)) return;
            }
            let cible = {
              charId: objCharId,
              token: obj
            };
            if (!estMortVivant(cible)) return;
            if (getState(cible, 'mort')) return;
            if (predicateAsBool(cible, 'immunite_destruction')) {
              addLineToFramedDisplay(display, nomPerso(cible) + " ne semble pas affect\xE9 par la destruction des morts-vivants");
              return;
            }
            cibles.push(cible);
          });
          let nbCibles = cibles.length;
          if (nbCibles === 0) {
            addLineToFramedDisplay(display, "Aucun mort-vivant en vue");
            sendChat("", endFramedDisplay(display));
            return;
          }
          let expl = [];
          entrerEnCombat(lanceur, cibles, expl, evt);
          expl.forEach(function(e) {
            addLineToFramedDisplay(display, e, 80, false);
          });
          let optionsDM = {
            sortilege: true,
            lanceur: lanceur,
            aoe: true,
            evt: evt
          };
          dm = dm.trim();
          evt.action.cibles = cibles;
          let finalDisplay = function() {
            nbCibles--;
            if (nbCibles < 1) {
              sendChat('', endFramedDisplay(display));
            }
          };
          cibles.forEach(function(perso) {
            let name = nomPerso(perso);
            let explications = [];
            perso.attaquant = lanceur;
            try {
              sendChat('', '[[' + dm + ']]', function(resDmg) {
                let dmg = {
                  type: 'magique',
                  value: dm,
                  roll: resDmg[0]
                };
                let afterEvaluateDmg = dmg.roll.content.split(' ');
                let dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
                dmg.total = dmg.roll.inlinerolls[dmgRollNumber].results.total;
                dmg.display = buildinline(dmg.roll.inlinerolls[dmgRollNumber], dmg.type, optionsDM.magique);
                dealDamage(perso, dmg, [], evt, false, optionsDM, explications, function(dmgDisplay, dmgFinal) {
                  addLineToFramedDisplay(display,
                    name + " re\xE7oit " + dmgDisplay + " DM");
                  explications.forEach(function(e) {
                    addLineToFramedDisplay(display, e, 80, false);
                  });
                  finalDisplay();
                });
              }); //fin du jet de d\xE9s
            } catch (rollError) {
              error("Jet " + dm + " mal form\xE9", dm);
            }
          }); //fin forEach

        } else {
          addLineToFramedDisplay(display, msgJet + " < " + difficulte);
          let msgRate = nomPerso(lanceur) + " ne r\xE9ussit pas \xE0 invoquer son dieu." + testRes.rerolls + testRes.modifiers;
          addLineToFramedDisplay(display, msgRate);
          sendChat('', endFramedDisplay(display));
        }
      });
  }

  //!cof-enduire-poison label type dm save
  //si label = munition_nom, alors on enduit des munitions et non une arme.
  function parseEnduireDePoison(msg) {
    const options = parseOptions(msg);
    let optArgs = msg.content.split(' --');
    let cmd = options.cmd;
    optArgs.shift();
    if (cmd.length < 5) {
      error("Usage : !cof-enduire-poison L type force save", cmd);
      return;
    }
    let label = cmd[1];
    let typePoison = cmd[2];
    if (typePoison != 'rapide' && typePoison != 'affaiblissant') {
      error("Les seuls type de poison g\xE9r\xE9s sont rapide et affaiblissant, mais pas encore " + typePoison, cmd);
    }
    let nomMunition;
    let estMunition = label.startsWith('munition_');
    if (estMunition) nomMunition = label.substring(9);
    let forcePoison = cmd[3];
    let savePoison = parseInt(cmd[4]);
    if (isNaN(savePoison)) {
      error("Le dernier argument non optionnel doit \xEAtre la difficult\xE9 du test de CON", cmd);
      return;
    }
    let testINT = 14;
    optArgs.forEach(function(arg) {
      cmd = arg.split(' ');
      switch (cmd[0]) {
        case 'testINT':
          if (cmd.length < 2) {
            error("Il faut un argument \xE0 --testINT", cmd);
            return;
          }
          testINT = parseInt(cmd[1]);
          if (isNaN(testINT)) {
            error("Argument de --testINT invalide", cmd);
            testINT = 14;
          }
          return;
      }
    }); //fin du traitement des options
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        let labelArme = label;
        if (!estMunition) {
          if (labelArme == -1) {
            labelArme = tokenAttribute(perso, 'armeEnMain');
            if (labelArme.length > 0) {
              labelArme = labelArme[0].get('current');
            } else {
              sendPerso(perso, "n'a pas d'arme en main");
              return;
            }
          } else if (labelArme == -2) {
            labelArme = tokenAttribute(perso, 'armeEnMain');
            if (labelArme.length > 0) {
              labelArme = labelArme[0].get('max');
            } else {
              labelArme = '';
            }
            if (labelArme === '') {
              sendPerso(perso, "n'a pas d'arme en main gauche");
              return;
            }
          }
        }
        let attribut = 'enduitDePoison_' + labelArme;
        let armeEnduite;
        let attr = tokenAttribute(perso, attribut);
        let infosAdditionelles = savePoison;
        let arme;
        if (!estMunition) {
          arme = getWeaponStats(perso, labelArme);
          if (arme === undefined) {
            error("Pas d'arme de label " + labelArme, cmd);
            return;
          }
          if (arme.sortilege) {
            sendPerso(perso, "imossible d'enduire un sortil\xE8ge de poison", true);
            return;
          }
          if (arme.typeDegats == 'contondant') {
            sendPerso(perso, arme.name + " fait des d\xE9g\xE2ts contondants. Est-il vraiment possible de l'empoisonner ?", true);
          }
          if (arme.armeDeJet) estMunition = true;
        }
        if (estMunition) {
          let munitionsCourantes;
          let maxMunitions;
          if (arme) {
            armeEnduite = arme.name;
            munitionsCourantes = arme.nbArmesDeJet;
            maxMunitions = arme.nbArmesDeJetMax;
          } else {
            let munitions = listAllMunitions(perso);
            let m = munitions[nomMunition];
            if (m) {
              let typeMunition = fieldAsString(m, 'typemunition', 'Fl\xE8che');
              armeEnduite = fieldAsString(m, 'nommunition', typeMunition);
              munitionsCourantes = fieldAsInt(m, 'qtemunition', 1);
              maxMunitions = fieldAsInt(m, 'qtemunition_max', 1);
            } else { //ancienne variante, obsol\xE8te depuis mars 2023
              armeEnduite = nomMunition.replace(/_/g, ' ');
              let attrQte = tokenAttribute(perso, labelArme);
              if (attrQte.length === 0) {
                sendPerso(perso, "n'a pas de munition nomm\xE9e " + nomMunition);
                return;
              }
              attrQte = attrQte[0];
              munitionsCourantes = parseInt(attrQte.get('current'));
              maxMunitions = parseInt(attrQte.get('max'));
              if (isNaN(munitionsCourantes) || isNaN(maxMunitions)) {
                error("Attribut de munitions mal form\xE9", attrQte);
                return;
              }
            }
          }
          if (munitionsCourantes === 0) {
            sendPlayer(msg, "Plus de munition " + nomMunition, playerId);
            return;
          }
          let dejaEnduits = 0;
          if (attr.length > 0) {
            let infos = attr[0].get('max');
            let indexInfos = infos.indexOf(' ');
            if (indexInfos < 1) {
              error("Attribut de poison rapide de munition mal form\xE9 (il faudrait la difficult\xE9 du save + le nombre de munitions empoisonn\xE9es)", infos);
              return;
            }
            let oldSave = parseInt(infos.substring(0, indexInfos));
            dejaEnduits = parseInt(infos.substring(indexInfos + 1));
            if (isNaN(dejaEnduits)) dejaEnduits = 0;
            if (dejaEnduits > 0 &&
              (attr[0].get('current') != typePoison + ' ' + forcePoison ||
                oldSave != savePoison)) {
              sendPlayer(msg, "Il y a d\xE9j\xE0 du poison de type " + attr[0].get('current') + "et de save " + oldSave + " sur les munitions " + armeEnduite + ". Le script ne sait pas g\xE9rer diff\xE9rents poisons sur les m\xEAmes munitions.", playerId);
              return;
            }
          }
          infosAdditionelles = savePoison + ' ' + (dejaEnduits + 1);
          if (dejaEnduits >= maxMunitions) {
            sendPlayer(msg, "Toutes les munitions " + armeEnduite + " sont d\xE9j\xE0 enduites de poison", playerId);
            return;
          }
        } else {
          armeEnduite = getAttackName(labelArme, perso);
          if (armeEnduite === undefined) {
            error(perso.tokNname + " n'a pas d'arme associ\xE9e au label " + labelArme, cmd);
            return;
          }
          if (attributeAsBool(perso, attribut)) {
            sendPlayer(msg, armeEnduite + " est d\xE9j\xE0 enduit de poison.", playerId);
            return;
          }
        }
        if (predicateAsBool(perso, 'connaissanceDuPoison')) {
          //Pas besoin de test
          const evt = {
            type: 'enduireDePoison'
          };
          addEvent(evt);
          if (limiteRessources(perso, options, 'enduirePoison', 'enduire de poison', evt)) return;
          setTokenAttr(perso, attribut, typePoison + ' ' + forcePoison, evt, {
            maxVal: infosAdditionelles
          });
          sendPlayer(msg, armeEnduite + " est maintenant enduit de poison", playerId);
          return;
        }
        doEnduireDePoison(perso, armeEnduite, savePoison, typePoison, forcePoison, attribut, testINT, infosAdditionelles, options);
      });
    });
  }

  function doEnduireDePoison(perso, armeEnduite, savePoison, typePoison, forcePoison, attribut, testINT, infosAdditionelles, options) {
    const evt = {
      type: 'enduireDePoison',
      action: {
        perso,
        armeEnduite,
        savePoison,
        typePoison,
        forcePoison,
        attribut,
        testINT,
        infosAdditionelles,
        options
      }
    };
    addEvent(evt);
    if (limiteRessources(perso, options, 'enduirePoison', 'enduire de poison', evt)) return;
    const display = startFramedDisplay(options.playerId, "Essaie d'enduire " + armeEnduite + " de poison", perso);
    //Test d'INT pour savoir si l'action r\xE9ussit.
    let testId = 'enduireDePoison';
    testCaracteristique(perso, 'INT', testINT, testId, options, evt,
      function(tr) {
        let jet = "Jet d'INT : " + tr.texte;
        if (tr.echecCritique) { //\xE9chec critique
          jet += " \xC9chec critique !" + tr.rerolls + tr.modifiers;
          addLineToFramedDisplay(display, jet);
          addLineToFramedDisplay(display, nomPerso(perso) + " s'empoisonne.");
          sendChat('', "[[" + forcePoison + "]]", function(res) {
            let dmgRoll;
            if (options.rolls && options.rolls.enduireSelfDmg) {
              dmgRoll = options.rolls.enduireSelfDmg;
            } else {
              dmgRoll = res[0].inlinerolls[0];
            }
            evt.action.rolls.enduireSelfDmg = dmgRoll;
            if (typePoison == 'rapide') {
              let r = {
                total: dmgRoll.results.total,
                type: 'poison',
                display: buildinline(dmgRoll, 'poison')
              };
              options.partialSave = {
                carac: 'CON',
                seuil: savePoison
              };
              let explications = [];
              dealDamage(perso, r, [], evt, false, options, explications,
                function(dmgDisplay, dmg) {
                  explications.forEach(function(e) {
                    addLineToFramedDisplay(display, e);
                  });
                  addLineToFramedDisplay(display, nomPerso(perso) + " subit " + dmgDisplay + " DM");
                  sendChat('', endFramedDisplay(display));
                }); //fin de dmg dus \xE0 l'\xE9chec critique
            }
          }); //fin du jet de dmg
        } else if (tr.reussite) {
          jet += " &ge; " + testINT + tr.modifiers;
          addLineToFramedDisplay(display, jet);
          setTokenAttr(perso, attribut, typePoison + ' ' + forcePoison, evt, {
            maxVal: infosAdditionelles
          });
          addLineToFramedDisplay(display, armeEnduite + " est maintenant enduit de poison");
          sendChat("", endFramedDisplay(display));
        } else { //echec normal au jet d'INT
          jet += " < " + testINT + " : \xE9chec" + tr.rerolls + tr.modifiers;
          addLineToFramedDisplay(display, jet);
          sendChat("", endFramedDisplay(display));
        }
      }); //fin du test de carac
  }

  const listeElixirs = [{
      nom: '\xC9lixir fortifiant',
      attrName: 'fortifiant',
      action: "!cof-fortifiant $rang",
      rang: 1
    }, {
      nom: '\xC9lixir de feu gr\xE9geois',
      attrName: 'feu_gr\xE9geois',
      action: "!cof-attack @{selected|token_id} @{target|token_id} Feu Gr\xE9geois --auto --dm $rangd6 --feu --psave DEX [[$base_save+@{selected|INT}]] --disque 3 --portee 10 --targetFx burst-fire",
      rang: 2
    }, {
      nom: '\xC9lixir de gu\xE9rison',
      attrName: '\xE9lixir_de_gu\xE9rison',
      action: "!cof-soin 3d6+$INT",
      rang: 3
    }, {
      nom: "\xC9lixir d'agrandissement",
      attrName: "potion_d_agrandissement",
      action: "!cof-effet-temp agrandissement [[5+$INT]]",
      rang: 4
    }, {
      nom: "\xC9lixir de forme gazeuse",
      attrName: "potion_de_forme_gazeuse",
      action: "!cof-effet-temp formeGazeuse [[1d4+$INT]]",
      rang: 4
    }, {
      nom: "\xC9lixir de protection contre les \xE9l\xE9ments",
      attrName: "potion_de_protection_contre_les_\xE9l\xE9ments",
      action: "!cof-effet-temp protectionContreLesElements [[5+$INT]] --valeur $rang",
      rang: 4
    }, {
      nom: "\xC9lixir d'armure de mage",
      attrName: "potion_d_armure_de_mage",
      action: "!cof-effet-combat armureDuMage",
      rang: 4
    }, {
      nom: "\xC9lixir de chute ralentie",
      attrName: "potion_de_chute_ralentie",
      action: "est l\xE9ger comme une plume.",
      rang: 4
    }, {
      nom: "\xC9lixir d'invisibilit\xE9",
      attrName: "potion_d_invisibilit\xE9",
      action: "!cof-set-state invisible true --message se rend invisible ([[1d6+$INT]] minutes)",
      rang: 5
    }, {
      nom: "\xC9lixir de vol",
      attrName: "potion_de_vol",
      action: "se met \xE0 voler",
      rang: 5
    }, {
      nom: "\xC9lixir de respiration aquatique",
      attrName: "potion_de_respiration_aquatique",
      action: "peut respirer sous l'eau",
      rang: 5
    }, {
      nom: "\xC9lixir de flou",
      attrName: "potion_de_flou",
      action: "!cof-effet-temp flou [[1d4+$INT]]",
      rang: 5
    }, {
      nom: "\xC9lixir de h\xE2te",
      attrName: "potion_de_h\xE2te",
      action: "!cof-effet-temp hate [[1d6+$INT]]",
      rang: 5
    },
    //Le \xE9lixirs pour les terres d'Arran
    {
      nom: 'Huile instable',
      attrName: 'huileInstable',
      action: "!cof-huile-instable @{target|token_id}",
      rang: 3,
      arran: true
    }, {
      nom: '\xC9lixir de gu\xE9rison',
      attrName: '\xE9lixirGu\xE9rison',
      action: "!cof-soin 3d6+$INT",
      rang: 4,
      arran: true
    }, {
      nom: "\xC9lixir de peau d'\xE9corce",
      attrName: 'peauEcorce',
      action: "!cof-effet-temp peauDEcorce [[5+$SAG]] --valeur 4",
      rang: 5,
      arran: true
    }, {
      nom: "\xC9lixir d'image d\xE9cal\xE9e",
      attrName: 'imageDecalee',
      action: "!cof-effet-temp imageDecalee [[5+$SAG]]",
      rang: 5,
      arran: true
    }, {
      nom: "\xC9lixir de protection contre les \xE9l\xE9ments",
      attrName: 'protectionContreElements',
      action: "!cof-effet-temp protectionContreLesElements [[5+$SAG]] --valeur 5",
      rang: 5,
      arran: true
    },
  ];

  function exilirInconnu(elixir, perso, voieDesElixirs) {
    if (elixir.rang > voieDesElixirs) return true;
    if (elixir.rang < 3) return false;
    if (persoArran(perso)) return !elixir.arran;
    return elixir.arran;
  }


  const consommableNomRegExp = new RegExp(/^(repeating_equipement_.*_)equip_nom/);
  const consommableQuantiteRegExp = new RegExp(/^(repeating_equipement_.*_)equip_qte/);
  const consommableEffetRegExp = new RegExp(/^(repeating_equipement_.*_)equip_effet/);

  function listeConsommables(msg) {
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        if (perso.token.get('bar1_link') === '') {
          error("La liste de consommables n'est pas au point pour les tokens non li\xE9s", perso);
          return;
        }
        let display = startFramedDisplay(playerId, 'Liste de vos consommables :', perso, {
          chuchote: true
        });
        let attributes = findObjs({
          _type: 'attribute',
          _characterid: perso.charId
        });
        let consommables = {}; //map id -> nom, quantite, effet, attr
        attributes.forEach(function(attr) {
          let attrName = attr.get('name').trim();
          let m = consommableNomRegExp.exec(attrName);
          if (m) {
            let consoPrefix = m[1];
            consommables[consoPrefix] = consommables[consoPrefix] || {};
            consommables[consoPrefix].nom = attr.get('current');
            return;
          }
          m = consommableQuantiteRegExp.exec(attrName);
          if (m) {
            let consoPrefix = m[1];
            consommables[consoPrefix] = consommables[consoPrefix] || {};
            consommables[consoPrefix].quantite = parseInt(attr.get('current'));
            consommables[consoPrefix].attr = attr;
            return;
          }
          m = consommableEffetRegExp.exec(attrName);
          if (m) {
            let consoPrefix = m[1];
            consommables[consoPrefix] = consommables[consoPrefix] || {};
            consommables[consoPrefix].effet = attr.get('current');
            return;
          }
          //Consommables dans des attributs utilisateurs
          if (!(attrName.startsWith('dose_') || attrName.startsWith('consommable_') || attrName.startsWith('elixir_'))) return;
          let consName;
          if (attrName.startsWith("elixir_")) {
            let typeElixir = listeElixirs.find(function(i) {
              return "elixir_" + i.attrName == attrName;
            });
            if (typeElixir !== undefined) {
              consName = typeElixir.nom;
            }
          }
          if (consName === undefined) {
            consName = attrName.substring(attrName.indexOf('_') + 1);
            consName = consName.replace(/_/g, ' ');
          }
          let quantite = parseInt(attr.get('current'));
          if (isNaN(quantite) || quantite === 0) return;
          var action = attr.get('max').trim();
          while (consommables[attrName]) {
            attrName += randomInteger(1000);
          }
          consommables[attrName] = {
            nom: consName,
            quantite: quantite,
            effet: action,
            attr: attr,
          };
        }); //fin de la boucle sur les attributs
        var aConsommable;
        _.each(consommables, function(c, prefix) {
          if (c.effet === undefined || c.effet === '' || c.nom === undefined || c.nom === '') return;
          //La quantit\xE9 est de 1 par d\xE9faut sur la fiche
          if (c.quantite === undefined) {
            c.quantite = 1;
            c.attr = createObj('attribute', {
              _characterid: perso.charId,
              name: prefix + 'equip_qte',
              current: 1
            });
          } else if (isNaN(c.quantite) || c.quantite < 1) {
            return;
          }
          aConsommable = true;
          var ligne = c.quantite + ' ';
          ligne += bouton(c.effet, c.nom, perso, {
            ressource: c.attr
          });
          // Pictos : https://wiki.roll20.net/CSS_Wizardry#Pictos
          var overlay = ' title="Cliquez pour \xE9changer"';
          ligne += boutonSimple('!cof-echange-consommable ' + perso.token.id + ' @{target|token_id} ' + c.attr.id, '<span style="font-family:Pictos">r</span>', overlay);
          addLineToFramedDisplay(display, ligne);
        }); //fin de la boucle sur les onsommables
        if (aConsommable)
          addLineToFramedDisplay(display, '<em>Cliquez sur le consommable pour l\'utiliser ou sur <tt><span style="font-family:Pictos">r</span></tt> pour l\'\xE9changer avec un autre personnage.</em>');
        else
          addLineToFramedDisplay(display, "<code>Vous n'avez aucun consommable</code>");
        sendChat('', endFramedDisplay(display));
      });
    }); //fin du getSelected
  }

  // !cof-utilise-consommable tok_id attr_id [msg]
  // utilisation d'un consommable sans action en jeu
  function utiliseConsommable(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Erreur interne d'utilisation de consommables", cmd);
      return;
    }
    cmd.shift();
    var perso = persoOfId(cmd[0]);
    if (perso === undefined) {
      log("Propri\xE9taire perdu");
      sendChat('COF', "Plus possible d'utiliser cette action. R\xE9afficher les consommables.");
      return;
    }
    // V\xE9rifie les droits d'utiliser le consommable
    if (msg.selected && msg.selected.length == 1) {
      var utilisateur = persoOfId(msg.selected[0]._id);
      if (utilisateur === undefined) {
        sendChat('COF', "Le token s\xE9lectionn\xE9 n'est pas valide");
        return;
      }
      var d = distanceCombat(perso.token, utilisateur.token);
      if (d > 0) {
        sendPerso(utilisateur, "est trop loin de " + nomPerso(perso) + " pour utiliser ses objets");
        return;
      }
      perso = utilisateur;
    } else {
      //On regarde si le joueur contr\xF4le le token
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "Pas les droits pour \xE7a");
        return;
      }
    }
    //on r\xE9cup\xE8re l'attribut \xE0 utiliser
    cmd.shift();
    var attr = getObj('attribute', cmd[0]);
    if (attr === undefined) {
      log("Attribut a chang\xE9/perdu");
      log(msg.content);
      sendChat('COF', "Plus possible d'utiliser cette action. Veuillez r\xE9afficher les consommables.");
      return;
    }
    //Nom du consommable (pour affichage)
    var consName;
    var quantite = parseInt(attr.get('current'));
    var evt = {
      type: "Utilisation de consommable",
      attributes: [{
        attribute: attr,
        current: quantite,
      }]
    };
    var attrName = attr.get('name').trim();
    //On regarde si c'est un consommable sur la fiche
    let m = consommableQuantiteRegExp.exec(attrName);
    if (m) {
      var consoPrefix = m[1];
      var attrConsName = charAttribute(perso.charId, consoPrefix + 'equip_nom');
      if (attrConsName.length === 0) {
        error("Impossible de trouver le nom du consommable", attr);
        return;
      }
      consName = attrConsName[0].get('current').trim();
    } else {
      consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ').trim();
    }
    if (isNaN(quantite) || quantite < 1) {
      attr.set('current', 0);
      whisperChar(perso.charId + "Vous ne disposez plus de " + consName);
      return;
    }
    if (cmd.length > 1) {
      cmd.shift();
      sendPerso(perso, cmd.join(' '));
    }
    attr.set('current', quantite - 1);
    addEvent(evt);
  }

  //!cof-echange-consommable tid1 tid2 attrid
  function echangeConsommable(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 4) {
      error("Erreur interne de consommables", cmd);
      return;
    }
    if (cmd[1] == cmd[2]) {
      sendChat('COF', "\xC9change avec soi-m\xEAme, sans effet");
      return;
    }
    //perso1 = token avec qui va \xE9changer le consommable
    var perso1 = persoOfId(cmd[1]);
    if (perso1 === undefined) {
      log("Propri\xE9taire perdu");
      sendChat('COF', "Plus possible d'utiliser cette action. R\xE9afficher les consommables.");
      return;
    }
    //perso2 = token avec lequel on va faire l'\xE9change
    let perso2 = persoOfId(cmd[2]);
    if (perso2 === undefined) {
      log("Destinataire perdu");
      sendChat('COF', "Erreur concernant le destinataire. Veuillez r\xE9essayer.");
      return;
    }
    //On regarde si le joueur contr\xF4le le token
    if (!peutController(msg, perso1)) {
      sendPlayer(msg, "Pas les droits pour \xE7a");
      return;
    }
    //on r\xE9cup\xE8re l'attribut \xE0 \xE9changer de perso1
    var attr1 = getObj('attribute', cmd[3]);
    if (attr1 === undefined) {
      log("Attribut a chang\xE9/perdu");
      log(cmd);
      sendChat('COF', "Plus possible d'utiliser cette action. Veuillez r\xE9afficher les consommables.");
      return;
    }
    var consName;
    var quantite1 = parseInt(attr1.get('current'));
    var evt = {
      type: "\xC9change de consommable",
      attributes: [{
        attribute: attr1,
        current: quantite1,
      }]
    };
    var effet;
    var attrName = attr1.get('name').trim();
    //On regarde si c'est un consommable sur la fiche
    var m1 = consommableQuantiteRegExp.exec(attrName);
    if (m1) {
      var consoPrefix = m1[1];
      var attrConsName = charAttribute(perso1.charId, consoPrefix + 'equip_nom');
      var attrEffet = charAttribute(perso1.charId, consoPrefix + 'equip_effet');
      if (attrConsName.length === 0 || attrEffet.length === 0) {
        error("Impossible de trouver le nom ou l'effet du consommable", attr1);
        return;
      }
      consName = attrConsName[0].get('current').trim();
      effet = attrEffet[0].get('current').trim();
    } else {
      consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ').trim();
      effet = attr1.get('max').trim();
    }
    if (isNaN(quantite1) || quantite1 < 1) {
      attr1.set('current', 0);
      whisperChar(perso1.charId, "Vous ne disposez plus de " + consName);
      return;
    }
    // on baisse la valeur de 1 du consommable qu'on s'appr\xEAte \xE0 \xE9changer
    quantite1--;
    attr1.set('current', quantite1);
    // ajout du consommable dans perso2 :
    var attributes = findObjs({
      _type: 'attribute',
      _characterid: perso2.charId
    });
    var quantite2 = 0;
    // on recherche si le consommable existe chez perso2
    var found = attributes.find(function(attr2) {
      var attrName2 = attr2.get('name');
      let m2 = consommableNomRegExp.exec(attrName2);
      if (m2) {
        if (consName != attr2.get('current').trim()) return false;
        var consoPrefix2 = m2[1];
        var attrEffet2 = charAttribute(perso2.charId, consoPrefix2 + 'equip_effet');
        if (attrEffet2.length === 0) {
          attrEffet2 = createObj('attribute', {
            characterid: perso2.charId,
            name: consoPrefix2 + 'equip_effet',
            current: effet
          });
          evt.attributes.push({
            attribute: attrEffet2,
          });
        } else if (attrEffet2[0].get('current').trim() != effet) {
          error("\xC9change dangereux : pas le m\xEAme effet pour le consommable selon le personnage \n" +
            "Effet chez " + nomPerso(perso1) + " : " + effet + "\n" +
            "Effet chez " + nomPerso(perso2) + " : " + attrEffet2[0].get('current'), attr2.get('name'));
          return false;
        }
        var attrQte2 = charAttribute(perso2.charId, consoPrefix2 + 'equip_qte');
        if (attrQte2.length === 0) {
          quantite2 = 1;
          attrQte2 = createObj('attribute', {
            characterid: perso2.charId,
            name: consoPrefix2 + 'equip_qte',
            current: 2
          });
          evt.attributes.push({
            attribute: attrQte2,
          });
          return true;
        }
        attrQte2 = attrQte2[0];
        quantite2 = parseInt(attrQte2.get('current'));
        if (isNaN(quantite2) || quantite2 < 1) quantite2 = 0;
        attrQte2.set('current', quantite2 + 1);
        evt.attributes.push({
          attribute: attrQte2,
          current: quantite2
        });
        return true;
      } else if (!m1 && attrName == attrName2.trim()) {
        if (attr2.get('max').trim() != effet) {
          error("\xC9change dangereux : pas le m\xEAme effet pour le consommable selon le personnage \n" +
            "Effet chez " + nomPerso(perso1) + " : " + effet + "\n" +
            "Effet chez " + nomPerso(perso2) + " : " + attr2.get('max'), attr2);
          return false;
        }
        quantite2 = parseInt(attr2.get('current'));
        if (isNaN(quantite2) || quantite2 < 1) quantite2 = 0;
        attr2.set('current', quantite2 + 1);
        evt.attributes.push({
          attribute: attr2,
          current: quantite2,
          max: effet
        });
        return true;
      }
      return false;
    });
    // si le consommable n'a pas \xE9t\xE9 trouv\xE9, on le cr\xE9e avec une valeur de 1.
    if (!found) {
      if (m1) {
        var pref = 'repeating_equipement_' + generateRowID() + '_';
        var attre = createObj("attribute", {
          name: pref + 'equip_nom',
          current: consName,
          characterid: perso2.charId
        });
        evt.attributes.push({
          attribute: attre,
        });
        attre = createObj("attribute", {
          name: pref + 'equip_effet',
          current: effet,
          characterid: perso2.charId
        });
        evt.attributes.push({
          attribute: attre,
        });
      } else {
        var attr2 = createObj("attribute", {
          name: attrName,
          current: 1,
          max: effet,
          characterid: perso2.charId
        });
        evt.attributes.push({
          attribute: attr2,
        });
      }
    }
    quantite2++;
    // on envoie un petit message pr\xE9cisant la r\xE9sultante de l'action.
    sendChat('COF', "Echange entre " + nomPerso(perso1) + " et " + nomPerso(perso2) + " termin\xE9e.");
    whisperChar(perso1.charId, " Il vous reste " + quantite1 + " " + consName + ".");
    whisperChar(perso2.charId, " Vous poss\xE9dez d\xE9sormais " + quantite2 + " " + consName + ".");
    // le MJ est notifi\xE9 :
    sendChat('COF', "/w GM " + nomPerso(perso1) + " vient de donner <strong>1</strong> " + consName + " \xE0 " + nomPerso(perso2) + ".");
    addEvent(evt);
  }

  function parseProvocation(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("La commande !cof-provocation requiert 2 arguments", cmd);
      return;
    }
    let voleur = persoOfId(cmd[1]);
    if (voleur === undefined) {
      error("Le premier argument de !cof-provocation n'est pas un token valide");
      return;
    }
    let cible = persoOfId(cmd[2]);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-provocation n'est pas un token valide");
      return;
    }
    if (cmd.length > 3 && cmd[3] == 'raillerie') {
      if (predicateAsBool(cible, 'raillerieImpossible')) {
        sendPerso(cible, "ne semble pas comprendre les railleries de " + nomPerso(voleur));
        return;
      }
      options.raillerie = true;
      options.bonusAttrs = options.bonusAttrs || [];
      options.bonusAttrs.push('resistanceRaillerie');
    }
    doProvocation(voleur, cible, options);
  }

  function doProvocation(voleur, cible, options) {
    let evt = {
      type: 'provocation',
      action: {
        titre: "Provocation",
        voleur: voleur,
        cible: cible,
        options: options,
      }
    };
    addEvent(evt);
    let nomVoleur = nomPerso(voleur);
    let nomCible = nomPerso(cible);
    let titre = 'Provocation';
    let action = 'provocation';
    if (options.raillerie) {
      titre = 'Raillerie';
      action = 'raillerie';
    }
    if (limiteRessources(voleur, options, action, action, evt)) return;
    const display =
      startFramedDisplay(options.playerId, titre, voleur, {
        perso2: cible
      });
    let explications = [];
    const rollId = 'provocation_' + cible.token.id;
    testOppose(rollId, voleur, 'CHA', options, cible, 'INT',
      options, explications, evt,
      function(res, crit, rt1, rt2) {
        explications.forEach(function(l) {
          addLineToFramedDisplay(display, l);
        });
        let reussite;
        switch (res) {
          case 0: //en cas d'\xE9galit\xE9, on consid\xE8re que la provocation est r\xE9ussie
            diminueMalediction(cible, evt);
            switch (crit) {
              case -1:
                reussite = "Sur un malentendu, la " + action + " r\xE9ussit...";
                if (options.raillerie) setAttrDuree(cible, 'enerve', 1, evt);
                break;
              case 0:
              case 1:
                reussite = "La " + action + " r\xE9ussit tout juste.";
                if (options.raillerie) {
                  setAttrDuree(cible, 'enerve', 1, evt);
                  setTokenAttr(cible, 'resistanceRaillerie',
                    attributeAsInt(cible, 'resistanceRaillerie', 0) + 2, evt);
                }
            }
            break;
          case 1:
            switch (crit) {
              case -1:
                reussite = nomCible + " marche compl\xE8tement, il attaque " + nomVoleur;
                if (options.raillerie) {
                  setAttrDuree(cible, 'enerve', 1, evt);
                  removeTokenAttr(cible, 'resistanceRaillerie', evt);
                }
                break;
              case 0:
                if (options.raillerie) {
                  setAttrDuree(cible, 'enerve', 1, evt);
                  reussite = nomVoleur + " a r\xE9ussi \xE0 bien \xE9nerver " + nomCible;
                  setTokenAttr(cible, 'resistanceRaillerie',
                    attributeAsInt(cible, 'resistanceRaillerie', 0) + 1, evt);
                } else reussite = "La provocation r\xE9ussit.";
                break;
              case 1:
                reussite = "La provocation est une r\xE9ussite critique !";
                setAttrDuree(cible, 'enerve', 1, evt);
                setTokenAttr(cible, 'resistanceRaillerie',
                  attributeAsInt(cible, 'resistanceRaillerie', 0) - 1, evt);
            }
            break;
          case 2:
            switch (crit) {
              case -1:
                reussite = "\xC9chec critique de la " + action + " !";
                if (options.raillerie) {
                  setTokenAttr(cible, 'resistanceRaillerie',
                    attributeAsInt(cible, 'resistanceRaillerie', 0) + 5, evt);
                }
                break;
              case 0:
                if (options.raillerie) {
                  setTokenAttr(cible, 'resistanceRaillerie',
                    attributeAsInt(cible, 'resistanceRaillerie', 0) + 1, evt);
                }
                reussite = "La provocation \xE9choue";
                break;
              case 1:
                if (options.raillerie) {
                  setTokenAttr(cible, 'resistanceRaillerie',
                    attributeAsInt(cible, 'resistanceRaillerie', 0) + 10, evt);
                }
                reussite = nomCible + " voit clair dans le jeu de " + nomVoleur + ". La provocation \xE9choue.";
            }
        }
        addLineToFramedDisplay(display, reussite);
        sendChat('', endFramedDisplay(display));
      }); //Fin du test oppos\xE9
  }

  function enSelle(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Il faut 2 arguments pour !cof-en-selle", msg.content);
      return;
    }
    cmd.shift();
    const cavalier = persoOfId(cmd[0]);
    if (cavalier === undefined) {
      error("Premier argument de !cof-en-selle incorrect", cmd);
      return;
    }
    const tokenC = cavalier.token;
    const pageId = tokenC.get('pageid');
    let evt = {
      type: 'En selle'
    };
    addEvent(evt);
    let attrMonteSur = tokenAttribute(cavalier, 'monteSur');
    if (attrMonteSur.length > 0) {
      //Alors le cavalier va descendre de sa monture
      attrMonteSur = attrMonteSur[0];
      const monture = persoOfIdName(attrMonteSur.get('current'), pageId, true);
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attrMonteSur);
      attrMonteSur.remove();
      if (monture === undefined) {
        sendPerso(cavalier, "descend de sa monture");
      } else {
        sendPerso(cavalier, "descend de " + nomPerso(monture));
        removeTokenAttr(monture, 'estMontePar', evt);
        removeTokenAttr(monture, 'positionSurMonture', evt);
      }
      return;
    }
    cmd.shift();
    let nomMonture = cmd.join(' ');
    let monture = persoOfId(nomMonture, nomMonture, pageId);
    if (monture === undefined || !predicateAsBool(monture, 'monture')) {
      sendPerso(cavalier, "ne peut pas monter l\xE0-dessus");
      log(nomMonture);
      return;
    }
    const tokenM = monture.token;
    nomMonture = tokenM.get('name');
    if (attributeAsBool(monture, 'estMontePar')) {
      //V\xE9rifie si le cavalier existe bien sur cette page.
      let cavalierBis;
      let estMontePar = tokenAttribute(monture, 'estMontePar');
      estMontePar.forEach(function(emp) {
        if (cavalierBis) return;
        cavalierBis = persoOfIdName(emp.get('current'), pageId);
        if (cavalierBis === undefined) emp.remove();
      });
      if (cavalierBis) {
        sendPerso(cavalier, "ne peut monter sur " + nomMonture + " car " + onGenre(monture, 'il', 'elle') + " a d\xE9j\xE0 un cavalier, " + nomPerso(cavalierBis));
        return;
      }
    }
    if (distanceCombat(tokenC, tokenM, pageId) > 0) {
      sendPerso(cavalier, "est trop loin de " + nomMonture);
      return;
    }
    setTokenAttr(cavalier, 'monteSur', idName(monture), evt, {
      msg: " monte sur " + nomMonture,
    });
    setTokenAttr(monture, 'estMontePar', idName(cavalier), evt);
    setTokenAttr(monture, 'positionSurMonture', tokenC.get('left') - tokenM.get('left'), evt, {
      maxVal: tokenC.get('top') - tokenM.get('top')
    });
    setTokenAttr(monture, 'directionSurMonture', tokenC.get('rotation') - tokenM.get('rotation'), evt);
    if (stateCOF.combat) {
      updateInit(monture.token, evt);
      if (stateCOF.options.affichage.val.init_dynamique.val) {
        setTokenInitAura(monture);
      }
    }
  }

  function rangVoieDesElixirs(perso, noMsg) {
    let arran = persoArran(perso);
    let voieDesElixirs;
    if (arran) {
      voieDesElixirs = predicateAsInt(perso, 'voieDeLAlchimie', 0);
      if (voieDesElixirs === 0)
        voieDesElixirs = predicateAsInt(perso, 'voieDesElixirs', 0);
    } else voieDesElixirs = predicateAsInt(perso, 'voieDesElixirs', 0);
    if (voieDesElixirs < 1 && !noMsg) {
      if (arran)
        sendPerso(perso, "ne conna\xEEt pas la Voie de l'Alchimie");
      else
        sendPerso(perso, "ne conna\xEEt pas la Voie des \xC9lixirs");
      return;
    }
    return voieDesElixirs;
  }

  //!cof-creer-elixir token_id elixir
  //on peut remplacer token_id par character_id
  function creerElixir(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-creer-elixir", msg.content);
      return;
    }
    let forgesort = persoOfId(cmd[1], cmd[1], options.pageId);
    if (forgesort === undefined) {
      if (msg.selected && msg.selected.length == 1) {
        forgesort = persoOfId(msg.selected[0]._id);
      }
      if (forgesort === undefined) {
        let c = getObj('character', cmd[1]);
        if (c === undefined) {
          error("Impossible de savoir qui cr\xE9e l'\xE9lixir", cmd);
          return;
        }
        forgesort = {
          charId: cmd[1]
        };
      }
    }
    let voieDesElixirs = rangVoieDesElixirs(forgesort);
    if (!voieDesElixirs) return;
    let elixir = listeElixirs.find(function(i) {
      if (exilirInconnu(i, forgesort, voieDesElixirs)) return false;
      return i.attrName == cmd[2];
    });
    if (elixir === undefined) { //Version perso des \xE9lixirs
      let altElixirs = findObjs({
        _type: 'attribute',
        _characterid: forgesort.charId
      });
      altElixirs.find(function(attr) {
        let attrName = attr.get('name');
        if (!attrName.startsWith('Elixir ')) return false;
        let rang = parseInt(attrName.substring(7));
        if (isNaN(rang) || rang > 3) return false;
        let nomElixir = attr.get('current');
        if (nomElixir != cmd[2]) return false;
        elixir = {
          nom: nomElixir,
          attrName: nomElixir,
          action: attr.get('max'),
          rang: rang
        };
        return true;
      });
      if (elixir === undefined) {
        error(nomPerso(forgesort) + " est incapable de cr\xE9er " + cmd[2], cmd);
        return;
      }
    }
    const evt = {
      type: "Cr\xE9ation d'\xE9lixir"
    };
    addEvent(evt);
    let arran = persoArran(forgesort);
    //D\xE9pense de mana
    if (!arran && reglesOptionelles.mana.val.elixirs_sorts.val && ficheAttributeAsBool(forgesort, 'option_pm', true)) {
      if (reglesOptionelles.mana.val.mana_totale.val) {
        switch (elixir.rang) {
          case 1:
            options.mana = 1;
            break;
          case 2:
            options.mana = 3;
            break;
          case 3:
            options.mana = 6;
            break;
          case 4:
            options.mana = 10;
            break;
          case 5:
            options.mana = 15;
            break;
        }
      } else if (elixir.rang > 2) {
        options.mana = elixir.rang - 2;
      }
    }
    let elixirsACreer = tokenAttribute(forgesort, 'elixirsACreer');
    if (elixirsACreer.length === 0) {
      error(nomPerso(forgesort) + " ne peut cr\xE9er d'\xE9lixirs " + cmd[2], cmd);
      return;
    }
    elixirsACreer = elixirsACreer[0];
    let extraFortifiants = toInt(elixirsACreer.get('max'), 0);
    let extra = extraFortifiants > 0 && elixir.rang == 1;
    if (!extra) options.decrAttribute = elixirsACreer.id;
    if (limiteRessources(forgesort, options, 'elixirsACreer', '\xE9lixirs \xE0 cr\xE9er', evt)) return;
    if (extra) {
      evt.attributes = evt.attributes || [];
      evt.attributes.push({
        attribute: elixirsACreer,
        current: elixirsACreer.get('current'),
        max: extraFortifiants
      });
      elixirsACreer.set('max', extraFortifiants - 1);
    }
    let attrName = 'elixir_' + elixir.attrName;
    let message = "cr\xE9e un " + elixir.nom;
    let attr = tokenAttribute(forgesort, attrName);
    if (attr.length === 0) {
      let rang = voieDesElixirs;
      let base_save = 10;
      if (predicateAsBool(forgesort, 'boutefeu') &&
        elixir.action.includes('--feu')) {
        rang = rang + 1;
        base_save = base_save + 2;
      }
      let action = elixir.action.replace(/\$rang/g, rang);
      action = action.replace(/\$base_save/g, base_save);
      action = action.replace(/\$INT/g, modCarac(forgesort, 'intelligence'));
      action = action.replace(/\$SAG/g, modCarac(forgesort, 'sagesse'));
      setTokenAttr(forgesort, attrName, 1, evt, {
        msg: message,
        maxVal: action
      });
    } else {
      let nb = parseInt(attr[0].get('current'));
      if (isNaN(nb) || nb < 1) nb = 0;
      setTokenAttr(forgesort, attrName, nb + 1, evt, {
        msg: message
      });
    }
  }

  function gestionElixir(msg) {
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(forgesort) {
        let voieDesElixirs = rangVoieDesElixirs(forgesort);
        if (!voieDesElixirs) return;
        let elixirsACreer = voieDesElixirs * 2;
        let fortifiantExtra = 0;
        let attrElixirs = tokenAttribute(forgesort, 'elixirsACreer');
        if (attrElixirs.length === 0) {
          //TODO: ajouter un evenement pour pouvoir faire un undo
          let opt = {};
          if (predicateAsBool(forgesort, 'fortifiantAvance')) {
            opt.maxVal = 2;
            fortifiantExtra = 2;
          }
          attrElixirs = setTokenAttr(forgesort, 'elixirsACreer', elixirsACreer, {}, opt);
        } else {
          attrElixirs = attrElixirs[0];
          elixirsACreer = toInt(attrElixirs.get('current'), 0);
          fortifiantExtra = toInt(attrElixirs.get('max'), 0);
        }
        let titre;
        if (elixirsACreer < 1) {
          if (fortifiantExtra < 1)
            titre = "Impossible de cr\xE9er un autre \xE9lixir aujourd'hui";
          else {
            titre = "Encore " + fortifiantExtra + " fortifiant";
            if (fortifiantExtra > 1) titre += 's';
            titre += "\xE0 cr\xE9er";
          }
        } else {
          titre = "Encore " + elixirsACreer + " \xE9lixir";
          if (elixirsACreer > 1) titre += 's';
          if (fortifiantExtra > 0) {
            titre += " et " + fortifiantExtra + " fortifiant";
            if (fortifiantExtra > 1) titre += 's';
          }
          titre += " \xE0 cr\xE9er";
        }
        let display = startFramedDisplay(playerId, titre, forgesort, {
          chuchote: true
        });
        listeElixirs.forEach(function(elixir) {
          if (exilirInconnu(elixir, forgesort, voieDesElixirs)) return;
          if (elixir.rang < 4) {
            //Il est possible de changer l'\xE9lixir par d\xE9faut
            let altElixir = charAttribute(forgesort.charId, 'Elixir ' + elixir.rang);
            if (altElixir.length > 0) {
              elixir.nom = altElixir[0].get('current');
              elixir.attrName = altElixir[0].get('current');
              elixir.action = altElixir[0].get('max');
            }
          }
          let nbElixirs = 0;
          let attr = tokenAttribute(forgesort, 'elixir_' + elixir.attrName);
          if (attr.length > 0) {
            attr = attr[0];
            nbElixirs = parseInt(attr.get('current'));
            if (isNaN(nbElixirs) || nbElixirs < 0) nbElixirs = 0;
          }
          let nomElixir = elixir.nom;
          let options = '';
          let action;
          if (elixirsACreer > 0 || (elixir.rang == 1 && fortifiantExtra > 0)) {
            action = "!cof-creer-elixir ";
            if (forgesort.token) action += forgesort.token.id;
            else action += forgesort.charId;
            action += ' ' + elixir.attrName;
            options += bouton(action, nbElixirs, forgesort) + ' ';
          } else {
            options = nbElixirs + ' ';
          }
          if (nbElixirs > 0) {
            let rang = voieDesElixirs;
            let base_save = 10;
            if (predicateAsBool(forgesort, 'boutefeu') &&
              elixir.action.contains('--feu')) {
              rang = rang + 1;
              base_save = base_save + 2;
            }
            action = elixir.action;
            action = action.replace(/\$rang/g, rang);
            action = action.replace(/\$base_save/g, base_save);
            action = action.replace(/\$INT/g, modCarac(forgesort, 'intelligence'));
            action = action.replace(/\$SAG/g, modCarac(forgesort, 'sagesse'));
            options += bouton(action, nomElixir, forgesort, {
              ressource: attr
            });
          } else {
            options += nomElixir;
          }
          addLineToFramedDisplay(display, options);
        });
        sendChat('', endFramedDisplay(display));
      });
    }); //Fin du getSelected
  }

  function persoOfCharId(charId, pageId, errMsg) {
    let token;
    let tokensPersonnage =
      findObjs({
        _type: 'graphic',
        _subtype: 'token',
        represents: charId,
        _pageid: pageId
      });
    if (tokensPersonnage.length === 0) {
      tokensPersonnage =
        findObjs({
          _type: 'graphic',
          _subtype: 'token',
          represents: charId,
        });
      if (tokensPersonnage.length === 0) {
        error("Impossible de trouver le token du personnage " + charId + " " + errMsg);
        return;
      }
      if (tokensPersonnage.length > 1) {
        let pageIds = characterPageIds(charId);
        token = tokensPersonnage.find(function(t) {
          return pageIds.has(t.get('pageid'));
        });
      }
    } else if (tokensPersonnage.length > 1) {
      log("Attention, plus d'un toke pour le personnage " + charId + " " + errMsg);
    }
    if (token === undefined) token = tokensPersonnage[0];
    return {
      token,
      charId
    };
  }

  function proposerRenouveauElixirs(evt, attrs, options) {
    let attrsNamed = allAttributesNamed(attrs, 'elixir');
    if (attrsNamed.length === 0) return attrs;
    // Trouver les forgesorts avec des \xE9lixirs sur eux
    let forgesorts = {};
    attrsNamed.forEach(function(attr) {
      // Check de l'existence d'un cr\xE9ateur
      let charId = attr.get('characterid');
      let personnage = persoOfCharId(charId, options.pageId, "avec un \xE9lixir");
      if (personnage === undefined) personnage = {
        charId
      };
      let voieDesElixirs = rangVoieDesElixirs(personnage, true);
      //TODO: r\xE9fl\xE9chir \xE0 une solution pour le renouveau des \xE9lixirs \xE9chang\xE9s
      if (voieDesElixirs > 0) {
        let elixirsDuForgesort = forgesorts[charId];
        if (elixirsDuForgesort === undefined) {
          elixirsDuForgesort = {
            forgesort: personnage,
            voieDesElixirs: voieDesElixirs,
            elixirsParRang: {}
          };
        }
        // Check de l'\xE9lixir \xE0 renouveler
        let nomElixir = attr.get('name');
        let typeElixir = listeElixirs.find(function(i) {
          if (i.rang > voieDesElixirs) return false;
          return "elixir_" + i.attrName == nomElixir;
        });
        if (typeElixir === undefined) {
          error("Impossible de trouver l'\xE9lixir \xE0 renouveler");
          return;
        }
        // Check des doses
        let doses = attr.get("current");
        if (isNaN(doses)) {
          error("Erreur interne : \xE9lixir mal form\xE9");
          return;
        }
        if (doses > 0) {
          // Tout est ok, cr\xE9ation de l'item
          let elixirArenouveler = {
            typeElixir: typeElixir,
            doses: doses
          };
          let elixirsParRang = elixirsDuForgesort.elixirsParRang;
          if (elixirsParRang[typeElixir.rang] === undefined) {
            elixirsParRang[typeElixir.rang] = [elixirArenouveler];
          } else elixirsParRang[typeElixir.rang].push(elixirArenouveler);
          forgesorts[charId] = elixirsDuForgesort;
        }
      }
    });
    // Display par personnage
    for (const [forgesortCharId, elixirsDuForgesort] of Object.entries(forgesorts)) {
      // Init du display pour le personnage
      let displayOpt = {
        chuchote: true
      };
      let allPlayers = getPlayerIds({
        charId: forgesortCharId
      });
      let playerId;
      if (allPlayers === undefined || allPlayers.length < 1) {
        displayOpt.chuchote = 'gm';
      } else {
        playerId = allPlayers[0];
      }
      let forgesort = elixirsDuForgesort.forgesort;
      let opt = {};
      if (predicateAsBool(forgesort, 'fortifiantAvance')) {
        opt.maxVal = 2;
      }
      setTokenAttr(forgesort, 'elixirsACreer', elixirsDuForgesort.voieDesElixirs * 2, evt, opt);
      let display = startFramedDisplay(allPlayers[0], "Renouveler les \xE9lixirs", forgesort, displayOpt);
      let actionToutRenouveler = "";
      // Boucle par rang de rune
      for (const rang in elixirsDuForgesort.elixirsParRang) {
        let elixirsDeRang = elixirsDuForgesort.elixirsParRang[rang];
        if (elixirsDeRang === undefined || elixirsDeRang.length < 1) continue;
        addLineToFramedDisplay(display, "Elixirs de rang " + rang, undefined, true);
        let actionTout = '';
        let ligneBoutons = '';
        // Boucle par \xE9lixir de ce rang \xE0 renouveler
        for (const i in elixirsDeRang) {
          let elixir = elixirsDeRang[i];
          // Boucle par dose
          for (let j = 0; j < elixir.doses; j++) {
            let action = "!cof-creer-elixir ";
            if (forgesort.token) action += forgesort.token.id;
            else action += forgesort.charId;
            action += ' ' + elixir.typeElixir.attrName;
            actionTout += action + "\n";
            actionToutRenouveler += action + "\n";
            let nomElixirComplet = elixir.typeElixir.nom;
            ligneBoutons += bouton(action, nomElixirComplet.replace("Elixir de ", "").replace("Elixir d'", ""), forgesort);
          }
        }
        ligneBoutons += bouton(actionTout, "Tout", forgesort, {
          buttonStyle: "background-color: blue;"
        });
        addLineToFramedDisplay(display, ligneBoutons, undefined, true);
      }
      let boutonToutRenouveler =
        bouton(actionToutRenouveler, "Tout renouveler", forgesort, {
          buttonStyle: "background-color: green;"
        });
      addLineToFramedDisplay(display, boutonToutRenouveler, undefined, true);
      sendChat('', endFramedDisplay(display));
    }
    return removeAllAttributes("elixir", evt, attrs);
  }

  function listeRunes(rang) {
    var liste = [];
    if (rang < 2) return liste;
    liste.push({
      nom: "Rune d'\xE9nergie",
      action: "!cof-rune-energie",
      attrName: "runeForgesort_\xE9nergie",
      rang: 2
    });
    if (rang < 3) return liste;
    liste.push({
      nom: "Rune de protection",
      action: "!cof-rune-protection",
      attrName: "runeForgesort_protection",
      rang: 3
    });
    if (rang < 4) return liste;
    liste.push({
      nom: "Rune de puissance",
      action: "!cof-rune-puissance",
      attrName: "runeForgesort_puissance",
      rang: 4
    });
    return liste;
  }

  function gestionRunes(msg) {
    getSelected(msg, function(selected, playerId) {
      const player = getObj('player', playerId);
      if (player === undefined) {
        error("Impossible de trouver le joueur", playerId);
        return;
      }
      iterSelected(selected, function(forgesort) {
        let voieDesRunes = predicateAsInt(forgesort, 'voieDesRunes', 0);
        if (voieDesRunes < 1) {
          sendPerso(forgesort, "ne conna\xEEt pas la Voie des Runes.");
          return;
        } else if (voieDesRunes < 2) {
          sendPerso(forgesort, "ne peut \xE9crire que des Runes de d\xE9fense.");
          return;
        }
        let titre = "Cr\xE9ation de runes";
        let display = startFramedDisplay(playerId, titre, forgesort, {
          chuchote: true
        });
        listeRunes(voieDesRunes).forEach(function(rune) {
          var action = "!cof-creer-rune " + forgesort.token.id + " @{target|token_id} " + rune.rang;
          if (rune.rang === 4) action += " ?{Num\xE9ro de l'arme de la cible?}";
          var options = bouton(action, rune.nom, forgesort);
          addLineToFramedDisplay(display, options);
        });
        sendChat('', endFramedDisplay(display));
      });
    }); //Fin du getSelected
  }

  //!cof-creer-rune token_id rune
  function creerRune(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 4) {
      error("Pas assez d'arguments pour !cof-creer-runes", msg.content);
      return;
    }
    var forgesort = persoOfId(cmd[1], cmd[1], options.pageId);
    if (forgesort === undefined) {
      if (msg.selected && msg.selected.length == 1) {
        forgesort = persoOfId(msg.selected[0]._id);
      }
      if (forgesort === undefined) {
        error("Impossible de savoir qui cr\xE9e la rune", cmd);
        return;
      }
    }
    var target = persoOfId(cmd[2], cmd[2], options.pageId);
    if (target === undefined) {
      error("Impossible de savoir \xE0 qui octroyer la rune", cmd);
      return;
    }
    var voieDesRunes = predicateAsInt(forgesort, 'voieDesRunes', 0);
    if (voieDesRunes < 1) {
      sendPerso(forgesort, "ne conna\xEEt pas la Voie des Runes");
      return;
    } else if (voieDesRunes < 2) {
      sendPerso(forgesort, "ne peut \xE9crire que des Runes de d\xE9fense.");
      return;
    }
    var rune = listeRunes(voieDesRunes).find(function(i) {
      return i.rang == cmd[3];
    });
    if (rune === undefined) {
      error(nomPerso(forgesort) + " est incapable de cr\xE9er " + cmd[3], cmd);
      return;
    }
    var labelArme;
    if (rune.rang == 4) {
      if (cmd.length < 5) {
        error("La rune de puissance n\xE9cessite de choisir un label d'arme.");
        return;
      }
      labelArme = parseInt(cmd[4]);
    }
    var evt = {
      type: "Cr\xE9ation de rune"
    };
    addEvent(evt);
    if (ficheAttributeAsBool(forgesort, 'option_pm', true)) {
      if (reglesOptionelles.mana.val.mana_totale.val) {
        switch (rune.rang) {
          case 2:
            options.mana = 3;
            break;
          case 3:
            options.mana = 6;
            break;
          case 4:
            options.mana = 10;
            break;
        }
      } else if (rune.rang > 2) {
        options.mana = rune.rang - 2;
      }
    }
    let attrName = rune.attrName;
    let message = "re\xE7oit ";
    let typeRune;
    switch (rune.rang) {
      case 2:
        typeRune = "une rune d'\xE9nergie";
        break;
      case 3:
        typeRune = "une rune de protection";
        break;
      case 4:
        typeRune = "une rune de puissance sur son ";
        let arme = getWeaponStats(target, labelArme);
        if (arme) typeRune += arme.name;
        else typeRune += "arme " + labelArme;
        attrName += "(" + labelArme + ")";
        break;
    }
    message += typeRune;
    if (attributeAsInt(target, attrName, 0) > 0) {
      error("La cible poss\xE8de d\xE9j\xE0 une rune " + typeRune, cmd);
      return;
    }
    if (options.mana !== undefined && limiteRessources(forgesort, options, undefined, "cr\xE9er " + typeRune, evt)) return;
    setTokenAttr(target, attrName, 1, evt, {
      msg: message,
      maxVal: forgesort.charId
    });
    if (rune.rang === 3 && reglesOptionelles.dommages.val.max_rune_protection.val) {
      setTokenAttr(target, "runeProtectionMax", voieDesRunes * 10, evt, {
        maxVal: forgesort.charId
      });
    }
  }

  //TODO: passer pageId en argument au lieu de prendre la page des joueurs
  function proposerRenouveauRunes(evt, attrs, options) {
    let attrsNamed = allAttributesNamed(attrs, 'runeForgesort');
    if (attrsNamed.length === 0) return attrs;
    // Filtrer par Forgesort, dans l'\xE9ventualit\xE9 qu'il y en ait plusieurs actifs
    let forgesorts = {};
    attrsNamed.forEach(function(attr) {
      // Check de l'existence d'un cr\xE9ateur
      let forgesortId = attr.get('max');
      if (forgesortId === undefined) {
        error("Impossible de retrouver le cr\xE9ateur de la rune : " + attr);
        return;
      }
      let runesDuForgesort = forgesorts[forgesortId];
      if (runesDuForgesort === undefined) {
        // Check de l'existence d'un token pr\xE9sent pour le cr\xE9ateur
        let forgesort = persoOfCharId(forgesortId, options.pageId, "ayant cr\xE9\xE9 une rune");
        if (forgesort === undefined) {
          attr.remove();
          return;
        }
        // Check du perso voie des Runes
        let voieDesRunes = predicateAsInt(forgesort, 'voieDesRunes', 0);
        if (voieDesRunes < 1) {
          sendPerso(forgesort, "ne conna\xEEt pas la Voie des Runes");
          return;
        } else if (voieDesRunes < 2) {
          sendPerso(forgesort, "ne peut \xE9crire que des Runes de d\xE9fense.");
          return;
        }
        runesDuForgesort = {
          forgesort: forgesort,
          voieDesRunes: voieDesRunes,
          runesParRang: {}
        };
      }
      // Check de la pr\xE9sence d'un token pour la cible
      let targetCharId = attr.get('characterid');
      let target = persoOfCharId(targetCharId, options.pageId, "ayant une rune");
      if (target === undefined) return;
      // Check de la rune \xE0 renouveler
      let runeName = attr.get('name');
      let typeRune =
        listeRunes(runesDuForgesort.voieDesRunes).find(function(i) {
          return i.attrName == runeName.split("(")[0];
        });
      if (typeRune === undefined) {
        error("Impossible de trouver la rune \xE0 renouveler");
        return;
      }
      // Tout est ok, cr\xE9ation de l'item
      let runeARenouveler = {
        target: target,
        typeRune: typeRune,
        runeName: runeName
      };
      let runesParRang = runesDuForgesort.runesParRang;
      if (runesParRang[typeRune.rang] === undefined) {
        runesParRang[typeRune.rang] = [runeARenouveler];
      } else runesParRang[typeRune.rang].push(runeARenouveler);
      forgesorts[forgesortId] = runesDuForgesort;
    });
    // Display par personnage
    for (const [forgesortCharId, runesDuForgesort] of Object.entries(forgesorts)) {
      // Init du desplay pour le personnage
      let displayOpt = {
        chuchote: true
      };
      let allPlayers = getPlayerIds({
        charId: forgesortCharId
      });
      let playerId;
      if (allPlayers === undefined || allPlayers.length < 1) {
        displayOpt.chuchote = 'gm';
      } else {
        playerId = allPlayers[0];
      }
      let forgesort = runesDuForgesort.forgesort;
      let display = startFramedDisplay(allPlayers[0], "Renouveler les runes", forgesort, displayOpt);
      let actionToutRenouveler = "";
      // Boucle par rang de rune
      for (const rang in runesDuForgesort.runesParRang) {
        let runesDeRang = runesDuForgesort.runesParRang[rang];
        if (runesDeRang === undefined || runesDeRang.length < 1) continue;
        addLineToFramedDisplay(display, runesDeRang[0].typeRune.nom, undefined, true);
        let actionTout = "";
        let ligneBoutons = "";
        // Boucle par rune de ce rang \xE0 renouveler
        for (const i in runesDeRang) {
          let rune = runesDeRang[i];
          let action =
            "!cof-creer-rune " + forgesort.token.id + " " + rune.target.token.id + " " + rang;
          if (rang == 4) {
            let runeName = rune.runeName;
            action += " " + runeName.substring(runeName.indexOf("(") + 1, runeName.indexOf(")"));
          }
          actionTout += action + "\n";
          actionToutRenouveler += action + "\n";
          ligneBoutons += bouton(action, nomPerso(rune.target), forgesort);
        }
        ligneBoutons += bouton(actionTout, "Tout", forgesort, {
          buttonStyle: "background-color: blue;"
        });
        addLineToFramedDisplay(display, ligneBoutons, undefined, true);
      }
      let boutonToutRenouveler =
        bouton(actionToutRenouveler, "Tout renouveler", forgesort, {
          buttonStyle: "background-color: green;"
        });
      addLineToFramedDisplay(display, boutonToutRenouveler, undefined, true);
      sendChat('', endFramedDisplay(display));
    }
    return removeAllAttributes("runeForgesort", evt, attrs);
  }

  function parseRageDuBerserk(msg) {
    let typeRage = 'rage';
    if (msg.content.includes(' --furie')) typeRage = 'furie';
    getSelected(msg, function(selection, playerId) {
      if (selection.length === 0) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour la rage", playerId);
        return;
      }
      const options = parseOptions(msg);
      if (options === undefined) return;
      if (options.son) playSound(options.son);
      let persos = [];
      iterSelected(selection, function(perso) {
        persos.push(perso);
      });
      doRageDuBerserk(persos, typeRage, options);
    });
  }

  function doRageDuBerserk(persos, typeRage, options) {
    const evt = {
      type: "rage",
      action: {
        persos: persos,
        typeRage: typeRage,
        options: options
      }
    };
    addEvent(evt);
    persos.forEach(function(perso) {
      let attrRage = tokenAttribute(perso, 'rageDuBerserk');
      if (attrRage.length > 0) {
        attrRage = attrRage[0];
        typeRage = attrRage.get('current');
        let difficulte = 13;
        if (typeRage == 'furie') difficulte = 16;
        //Jet de sagesse difficult\xE9 13 pou 16 pour sortir de cet \xE9tat
        let display = startFramedDisplay(options.playerId, "Essaie de calmer sa " + typeRage, perso);
        let testId = 'rageDuBerserk_' + perso.token.id;
        testCaracteristique(perso, 'SAG', difficulte, testId, options, evt,
          function(tr) {
            addLineToFramedDisplay(display, "<b>R\xE9sultat du jet de SAG :</b> " + tr.texte);
            if (tr.reussite) {
              addLineToFramedDisplay(display, "C'est r\xE9ussi, " + nomPerso(perso) + " se calme." + tr.modifiers);
              removeTokenAttr(perso, 'rageDuBerserk', evt);
            } else {
              let msgRate = "C'est rat\xE9, " + nomPerso(perso) + " reste enrag\xE9" + tr.rerolls + tr.modifiers;
              addLineToFramedDisplay(display, msgRate);
            }
            sendChat('', endFramedDisplay(display));
          });
      } else {
        //Le barbare passe en rage
        if (limiteRessources(perso, options, 'rageDuBerserk', "entrer en rage du berserk", evt)) {
          return;
        }
        if (!stateCOF.combat) {
          initiative([{
            _id: perso.token.id
          }], evt);
        }
        setTokenAttr(perso, 'rageDuBerserk', typeRage, evt, {
          msg: "entre dans une " + typeRage + " berserk !"
        });
      }
    });
  }

  //!cof-arme-secrete @{selected|token_id} @{target|token_id}
  function parseArmeSecrete(msg) {
    var options = parseOptions(msg);
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il faut deux arguments \xE0 !cof-arme-secrete", cmd);
      return;
    }
    var barde = persoOfId(cmd[1]);
    var cible = persoOfId(cmd[2]);
    if (barde === undefined || cible === undefined) {
      error("Token non valide pour l'arme secr\xE8te", cmd);
      return;
    }
    if (attributeAsInt(barde, 'armeSecreteBardeUtilisee')) {
      sendPerso(barde, "a d\xE9j\xE0 utilis\xE9 son arme secr\xE8te durant ce combat");
      return;
    }
    doArmeSecrete(barde, cible, options);
  }

  function doArmeSecrete(perso, cible, options) {
    var evt = {
      type: 'armeSecrete',
      action: {
        perso: perso,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    if (!stateCOF.combat) {
      initiative([{
        _id: perso.token.id
      }, {
        _id: cible.token.id
      }], evt);
    }
    setTokenAttr(perso, 'armeSecreteBardeUtilisee', true, evt);
    var intCible = ficheAttributeAsInt(cible, 'intelligence', 10);
    var testId = 'armeSecreteBarde';
    testCaracteristique(perso, 'CHA', intCible, testId, options, evt, function(tr) {
      var display = startFramedDisplay(options.playerId,
        "Arme secr\xE8te", perso, {
          perso2: cible
        });
      var line = "Jet de CHA : " + tr.texte;
      if (tr.reussite) {
        line += " &ge; " + intCible + tr.modifiers;
        addLineToFramedDisplay(display, line);
        addLineToFramedDisplay(display, nomPerso(cible) + " est compl\xE8tement d\xE9stabilis\xE9");
        setAttrDuree(cible, 'armeSecreteBarde', 1, evt);
      } else {
        line += " &lt; " + intCible + tr.rerolls + tr.modifiers;
        addLineToFramedDisplay(display, line);
        addLineToFramedDisplay(display, nomPerso(cible) + " reste insensible au charme de " + nomPerso(perso));
      }
      sendChat("", endFramedDisplay(display));
    }); //fin testCarac
  }

  function nouveauNomDePerso(nom) {
    var characters = findObjs({
      _type: 'character'
    });
    characters = characters.map(function(c) {
      return c.get('name');
    });
    var trouve = characters.indexOf(nom);
    if (trouve < 0) return nom;
    var n = 2;
    while (1) {
      var nomP = nom + ' ' + n;
      trouve = characters.indexOf(nomP);
      if (trouve < 0) return nomP;
      n++;
    }
  }

  //Cr\xE9e un nouveau personnage (de type PNJ par d\xE9faut)
  //spec contient les charact\xE9ristiques, attributs et abilities
  //  - attributesFiche contient les attributs d\xE9finis dans la fiche
  //      nom_attribut: valeur
  //  - pv (permet d'\xEAtre ind\xE9pendant de PJ ou PNJ)
  //  - attaques, liste d'attaques, chacune avec (nom, atk, dmnbde, dmde, dm,...)
  //  - attributes autres attributs (name, current, max)
  //  - abilities (name, action), toujours rajout\xE9es \xE0 la liste d'actions
  //  - actions (titre, code), ajout\xE9es aux listes d'actions
  function createCharacter(nom, playerId, avatar, token, spec, evt, createur) {
    let res = createObj('character', {
      name: nom,
      avatar: avatar,
      controlledby: playerId
    });
    if (!res) return;
    let charId = res.id;
    if (token) {
      token.set('represents', charId);
    }
    let attrs = findObjs({
      _type: 'attribute',
      _characterid: charId,
    });
    let attrVersion =
      attrs.find(function(a) {
        return a.get('name').toLowerCase() == 'version';
      });
    if (!attrVersion) {
      createObj('attribute', {
        _characterid: charId,
        name: 'version',
        current: versionFiche
      });
    }
    attrVersion =
      attrs.find(function(a) {
        return a.get('name').toLowerCase() == 'scriptVersion';
      });
    if (!attrVersion) {
      createObj('attribute', {
        _characterid: charId,
        name: 'scriptVersion',
        current: true,
        max: stateCOF.version
      });
    }
    let pnj = true;
    if (spec.attributesFiche) {
      if (spec.attributesFiche.type_personnage == 'PJ') pnj = false;
      for (let attrName in spec.attributesFiche) {
        /*jshint loopfunc: true */
        let attr =
          attrs.filter(function(a) {
            return a.get('name') == attrName;
          });
        if (attr.length === 0) {
          createObj('attribute', {
            _characterid: charId,
            name: attrName,
            current: spec.attributesFiche[attrName]
          });
        } else {
          attr[0].set('current', spec.attributesFiche[attrName]);
        }
      }
    }
    if (pnj &&
      (!spec.attributesFiche || spec.attributesFiche.type_personnage === undefined)) {
      createObj('attribute', {
        _characterid: charId,
        name: 'type_personnage',
        current: 'PNJ'
      });
    }
    if (pnj) {
      createObj('attribute', {
        _characterid: charId,
        name: 'tab',
        current: 'carac. pnj'
      });
    }
    if (spec.pv) {
      let pvAttr = attrs.filter(function(a) {
        return a.get('name').toUpperCase() == 'PV';
      });
      if (pvAttr.length === 0) {
        pvAttr = createObj('attribute', {
          _characterid: charId,
          name: 'PV',
          current: spec.pv,
          max: spec.pv
        });
      } else {
        pvAttr = pvAttr[0];
        pvAttr.set('current', spec.pv);
        pvAttr.set('max', spec.pv);
      }
      if (pnj) {
        pvAttr = attrs.filter(function(a) {
          return a.get('name').toLowerCase() == 'pnj_pv';
        });
        if (pvAttr.length === 0) {
          pvAttr = createObj('attribute', {
            _characterid: charId,
            name: 'pnj_pv',
            current: spec.pv,
            max: spec.pv
          });
        } else {
          pvAttr = pvAttr[0];
          pvAttr.set('current', spec.pv);
          pvAttr.set('max', spec.pv);
        }
      }
      if (token) {
        token.set('bar1_link', pvAttr.id);
        token.set('bar1_value', spec.pv);
        token.set('bar1_max', spec.pv);
      }
    }
    if (spec.attaques) {
      let maxAttackLabel = 0;
      let prefix_attaques = 'repeating_armes_';
      if (pnj) prefix_attaques = 'repeating_pnjatk_';
      spec.attaques.forEach(function(att) {
        let id = generateRowID();
        let pref = prefix_attaques + id + '_arme';
        _.forEach(att, function(value, field) {
          createObj('attribute', {
            _characterid: charId,
            name: pref + field,
            current: value
          });
        });
        maxAttackLabel++;
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'label',
          current: maxAttackLabel
        });
      });
      createObj('attribute', {
        _characterid: charId,
        name: 'max_attack_label',
        current: maxAttackLabel
      });
    }
    if (spec.attributes) {
      spec.attributes.forEach(function(a) {
        a._characterid = charId;
        let attr = createObj('attribute', a);
        if (createur && a.lie) {
          addEffetTemporaireLie(createur, attr, evt);
        }
      });
    }
    if (spec.abilities) {
      spec.abilities.forEach(function(a) {
        a._characterid = charId;
        a.istokenaction = true;
        createObj('ability', a);
      });
    }
    if (spec.actions) {
      var rang = 0;
      spec.actions.forEach(function(a) {
        rang++;
        let pref = 'repeating_actions_' + generateRowID() + '_';
        createObj('attribute', {
          name: pref + 'actionoptflag',
          current: 'off',
          characterid: charId,
        });
        createObj('attribute', {
          name: pref + 'actionrang',
          current: rang,
          characterid: charId,
        });
        createObj('attribute', {
          name: pref + 'actiontitre',
          current: a.titre,
          characterid: charId,
        });
        if (a.code) {
          createObj('attribute', {
            name: pref + 'actioncode',
            current: a.code,
            characterid: charId,
          });
        }
      });
      if (rang > 0) {
        createObj('attribute', {
          name: 'maxrangaction',
          current: rang,
          characterid: charId
        });
      }
    }
    createObj('attribute', {
      name: 'montrerarmeenmain',
      current: 0,
      characterid: charId
    });
    if (token) setDefaultTokenForCharacter(res, token);
    return res;
  }

  //!cof-animer-arbre lanceur-id target-id [rang]
  function animerUnArbre(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-animer-arbre attend 2 arguments", msg.content);
      return;
    }
    let druide = persoOfId(cmd[1], cmd[1], options.pageId);
    if (druide === undefined) {
      error("Le premier argument de !cof-animer-arbre n'est pas un token valie", cmd);
      return;
    }
    let tokenArbre = getObj('graphic', cmd[2]);
    if (tokenArbre === undefined) {
      error("Le deuxi\xE8me argument de !cof-animer-arbre n'est pas un token", cmd);
      return;
    }
    if (tokenArbre.get('represents') !== '') {
      sendPerso(druide, "ne peut pas animer " + tokenArbre.get('name'));
      return;
    }
    if (options.portee !== undefined) {
      let dist = distanceCombat(druide.token, tokenArbre, options.pageId);
      if (dist > options.portee) {
        sendPerso(druide, "est trop loin de l'arbre");
        return;
      }
    }
    let rang = predicateAsInt(druide, 'voieDesVegetaux', 3);
    if (cmd.length > 3) { //Le rang est sp\xE9cifi\xE9 en argument optionnel
      let cmd3 = parseInt(cmd[3]);
      if (isNaN(cmd3) || cmd3 < 1) {
        error("Le rang n'est pas un nombre valie. On utilise " + rang + " \xE0 la place", cmd);
      } else rang = cmd3;
    }
    const evt = {
      type: "Animation d'un arbre"
    };
    addEvent(evt);
    if (limiteRessources(druide, options, 'animerUnArbre', 'animer un arbre', evt)) return;
    if (!stateCOF.combat) {
      initPerso(druide, evt);
    }
    let niveau = ficheAttributeAsInt(druide, 'niveau', 1);
    let nomArbre = nouveauNomDePerso('Arbre anim\xE9');
    let avatar = "https://s3.amazonaws.com/files.d20.io/images/42323556/6qxlm965aFhBXGoYFy5fqg/thumb.png?1510582137";
    let specArbre = {
      pv: rang * 10,
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: niveau,
        force: 18,
        pnj_for: 4,
        dexterite: 7,
        pnj_dex: -2,
        constitution: 20,
        pnj_con: 5,
        intelligence: 8,
        pnj_int: -1,
        sagesse: 14,
        pnj_sag: 2,
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 5,
        pnj_def: 13,
        pnj_init: 7,
        RDS: '10/feu_hache',
        race: 'arbre',
        taille: 'grand'
      },
      attaques: [{
        nom: 'Branches',
        atk: niveau,
        dmnbde: 1,
        dmde: 6,
        dm: 3,
        typedegats: 'contondant',
      }],
      attributes: [{
        name: 'arbreAnime',
        current: niveau,
        max: getInit(),
        lie: options.mana !== undefined
      }]
    };
    let charArbre = createCharacter(nomArbre, options.playerId, avatar, tokenArbre, specArbre, evt, druide);
    evt.characters = [charArbre];
    sendChar(charArbre.id, "commence \xE0 s'animer", true);
    initiative([{
      _id: tokenArbre.id
    }], evt);
    // Ajout de l'arbre anim\xE9 aux alli\xE9s du Druide
    let alliesDruide = alliesParPerso[druide.charId] || new Set();
    alliesDruide.add(charArbre.id);
    alliesParPerso[druide.charId] = alliesDruide;
  }

  //!cof-rune-protection
  function runeProtection(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser les runes de protection qu'en combat");
      return;
    }
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    var evt = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un \xE9v\xE9nement particulier
      evt = findEvent(cmd[1]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a \xE9t\xE9 annul\xE9e", cmd);
        return;
      }
    }
    if (evt.type != 'Attaque') {
      sendChat('', "la derni\xE8re action n'est pas une attaque r\xE9ussie, trop tard pour absorber l'attaque pr\xE9c\xE9dente");
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Personne n'est s\xE9lectionn\xE9 pour utiliser une rune", msg);
        return;
      }
      var action = evt.action;
      iterSelected(selected, function(perso) {
        if (!peutController(msg, perso)) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton", playerId);
          return;
        }
        var cible = action.cibles.find(function(target) {
          return (target.token.id === perso.token.id);
        });
        if (cible === undefined) {
          sendPerso(perso, "n'est pas la cible de la derni\xE8re attaque");
          return;
        }
        if (!attributeAsBool(perso, 'runeForgesort_protection')) {
          sendPerso(perso, "n'a pas de rune de protection");
          return;
        }
        if (attributeAsInt(perso, 'limiteParCombat_runeForgesort_protection', 1) < 1) {
          sendPerso(perso, "a d\xE9j\xE0 utilis\xE9 sa rune de protection durant ce combat");
          return;
        }
        action.choices = action.choices || {};
        action.choices[perso.token.id] = action.choices[perso.token.id] || {};
        action.choices[perso.token.id].runeForgesort_protection = true;
      }); //fin iterSelected
      let options = action.currentOptions || {};
      options.rolls = action.rolls;
      options.choices = action.choices;
      resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, options, evt, action.explications, action.pageId, action.cibles);
    }); //fin getSelected
  }

  function appliquerRuneDeProtection(cible, options, evt) {
    if (reglesOptionelles.dommages.val.max_rune_protection.val) {
      cible.utiliseRuneProtectionMax = attributeAsInt(cible, 'runeProtectionMax', 30);
    } else {
      cible.utiliseRuneProtection = true;
    }
    removePreDmg(options, cible);
  }

  //!cof-delivrance @{selected|token_id} @{target|token_id}
  function delivrance(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-delivrance attend 2 arguments", msg.content);
      return;
    }
    let pretre = persoOfId(cmd[1], cmd[1], options.pageId);
    if (pretre === undefined) {
      error("Le premier argument de !cof-delivrance n'est pas un token valide", msg.content);
      return;
    }
    let cible = persoOfId(cmd[2], cmd[2], options.pageId);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-delivrance n'est pas un token valide", msg.content);
      return;
    }
    if (options.portee !== undefined) {
      let dist = distanceCombat(pretre.token, cible.token, options.pageId);
      if (dist > options.portee) {
        sendPerso(pretre, "est trop loin de " + nomPerso(cible));
        return;
      }
    }
    const evt = {
      type: "D\xE9livrance",
      deletedAttributes: []
    };
    addEvent(evt);
    if (limiteRessources(pretre, options, 'd\xE9livrance', 'd\xE9livrance', evt)) return;
    let display = startFramedDisplay(getPlayerIdFromMsg(msg), 'D\xE9livrance', pretre, {
      perso2: cible
    });
    let printEffet = function(message) {
      addLineToFramedDisplay(display, nomPerso(cible) + ' ' + message);
    };
    let optFin = {
      print: printEffet,
      pageId: options.pageId
    };
    _.each(messageEffetTemp, function(effet, nomEffet) {
      if (effet.prejudiciable) {
        //Attention, ne fonctionne pas avec les effets g\xE9n\xE9riques
        let attr = tokenAttribute(cible, nomEffet);
        if (attr.length > 0)
          finDEffet(attr[0], nomEffet, attr[0].get('name'), cible.charId, evt, optFin);
      }
    });
    _.each(messageEffetCombat, function(effet, nomEffet) {
      if (effet.prejudiciable) {
        let attr = tokenAttribute(cible, nomEffet);
        if (attr.length > 0) {
          printEffet(messageFin(cible, effet));
          evt.deletedAttributes.push(attr[0]);
          attr[0].remove();
        }
      }
    });
    _.each(messageEffetIndetermine, function(effet, nomEffet) {
      if (effet.prejudiciable) {
        let attr = tokenAttribute(cible, nomEffet);
        if (attr.length > 0) {
          printEffet(messageFin(cible, effet));
          evt.deletedAttributes.push(attr[0]);
          attr[0].remove();
        }
      }
    });
    if (attributeAsBool(cible, 'malediction')) {
      printEffet("n'est plus maudite");
      removeTokenAttr(cible, 'malediction', evt);
    }
    if (attributeAsBool(cible, 'pointsDeSang')) {
      printEffet("n'a plus de point de sang.");
      removeTokenAttr(cible, 'pointsDeSang', evt);
    }
    //On enl\xE8ve les \xE9tats pr\xE9judiciables
    if (getState(cible, 'aveugle')) {
      printEffet("retrouve la vue");
      setState(cible, 'aveugle', false, evt);
    }
    if (getState(cible, 'affaibli')) {
      printEffet("retrouve des forces");
      setState(cible, 'affaibli', false, evt);
    }
    if (getState(cible, 'etourdi')) {
      printEffet("retrouve ses esprits");
      setState(cible, 'etourdi', false, evt);
    }
    if (getState(cible, 'paralyse')) {
      printEffet("peut \xE0 nouveau bouger");
      setState(cible, 'paralyse', false, evt);
    }
    if (getState(cible, 'ralenti')) {
      printEffet("retrouve une vitesse normale");
      setState(cible, 'ralenti', false, evt);
    }
    if (getState(cible, 'endormi')) {
      printEffet("se r\xE9veille");
      setState(cible, 'endormi', false, evt);
    }
    if (getState(cible, 'apeure')) {
      printEffet("reprend courage");
      setState(cible, 'apeure', false, evt);
    }
    //R\xE9g\xE9n\xE9ration d'une carac affaiblie de 1d4, si il y en a.
    if (attributeAsInt(cible, 'affaiblissementdesagesse', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'sagesse', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points de sagesse");
    } else if (attributeAsInt(cible, 'affaiblissementdecharisme', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'charisme', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points de charisme");
    } else if (attributeAsInt(cible, 'affaiblissementdeintelligence', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'intelligence', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points d'intelligence");
    }
    if (attributeAsInt(cible, 'affaiblissementdeconstitution', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'constitution', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points de constitution");
    } else if (attributeAsInt(cible, 'affaiblissementdeforce', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'force', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points de force");
    } else if (attributeAsInt(cible, 'affaiblissementdedexterite', 0) > 0) {
      let d4 = rollDePlus(4);
      diminueAffaiblissement(cible, 'dexterite', d4.val, evt);
      printEffet("r\xE9cup\xE8re " + d4.roll + " points de dext\xE9rit\xE9");
    }
    sendChat('', endFramedDisplay(display));
  }

  function guerisonPerso(perso, evt, lanceur) {
    let msgSoin;
    if (lanceur) {
      if (lanceur.token.id == perso.token.id) {
        msgSoin = 'se soigne';
      } else {
        msgSoin = 'soigne ' + nomPerso(perso);
      }
    } else {
      msgSoin = 'r\xE9cup\xE8re';
    }
    msgSoin += ' de toutes les blessures subies';
    if (lanceur) sendPerso(lanceur, msgSoin);
    else sendPerso(perso, msgSoin);
    if (getState(perso, 'blesse')) {
      setState(perso, 'blesse', false, evt);
    } else { //On peut bien faire r\xE9cup\xE9rer un PR
      let d = rajouterPointDeRecuperation(perso, evt);
      if (d) sendPerso(perso, "r\xE9cup\xE8re un point de r\xE9cup\xE9ration");
    }
    let soins = perso.token.get('bar1_max') - perso.token.get('bar1_value');
    if (isNaN(soins)) {
      updateCurrentBar(perso, 1, perso.token.get('bar1_max'), evt);
      return;
    }
    //Les affaiblissements de caract\xE9ristiques
    allCaracs.forEach(function(carac) {
      let malus = attributeAsInt(perso, 'affaiblissementde' + carac, 0);
      if (malus > 0) {
        diminueAffaiblissement(perso, carac, malus, evt, malus);
        sendPerso(perso, "r\xE9cup\xE8re " + malus + " points " + deCarac(carac));
      }
    });
    if (soins <= 0) {
      //Rien d'autre \xE0 faire (le script ne g\xE8re pas encore le reste)
      return;
    }
    soigneToken(perso, soins, evt);
  }

  //!cof-guerison @{selected|token_id} @{target|token_id}
  function guerison(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-guerison attend le lanceur et la cible en argument", msg.content);
      return;
    }
    let lanceur = persoOfId(cmd[1], cmd[1], options.pageId);
    if (lanceur === undefined) {
      error("Le premier argument de !cof-guerison n'est pas un token valide", msg.content);
      return;
    }
    let cible = persoOfId(cmd[2], cmd[2], options.pageId);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-guerison n'est pas un token valide", msg.content);
      return;
    }
    if (options.dose === undefined && options.decrAttribute === undefined) {
      options.limiteParJour = 1;
    }
    if (options.portee !== undefined) {
      const dist = distanceCombat(lanceur.token, cible.token, options.pageId);
      if (dist > options.portee) {
        sendPerso(lanceur, "est trop loin de " + nomPerso(cible));
        return;
      }
    }
    const evt = {
      type: "Gu\xE9rison",
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'gu\xE9rison', 'gu\xE9rison', evt)) return;
    guerisonPerso(cible, evt, lanceur);
    if (options.messages) {
      options.messages.forEach(function(m) {
        sendChat('', m);
      });
    }
  }

  function armeDeContact(perso, arme, labelArmeDefaut, armeContact) {
    if (arme) return arme;
    arme = armesEnMain(perso);
    if (arme === undefined && labelArmeDefaut)
      arme = getWeaponStats(perso, labelArmeDefaut);
    //L'arme doit \xEAtre une arme de contact ?
    if (armeContact && arme && arme.portee) {
      sendPerso(perso, armeContact + " " + arme.name + " est une arme \xE0 distance.");
      return;
    }
    if (arme) {
      return arme;
    }
    arme = {
      name: 'Attaque par d\xE9faut',
      attSkillDiv: 0,
      attSkill: "@{ATKCAC}",
      crit: 20,
      parDefaut: true,
    };
    return arme;
  }

  function attaqueContactOpposee(playerId, attaquant, defenseur, evt, options, callback) {
    let explications = [];
    options = options || {
      pasDeDmg: true
    };
    options.contact = true;
    entrerEnCombat(attaquant, [defenseur], explications, evt);
    //Recherche des armes utilis\xE9es
    let armeAttaquant =
      armeDeContact(attaquant, options.armeAttaquant, options.labelArmeAttaquant, options.armeAttaquantContact);
    let armeDefenseur =
      armeDeContact(defenseur, options.armeDefenseur, options.labelArmeDefenseur, options.armeDefenseurContact);
    let action = options.action || "<b>Attaque oppos\xE9e</b>";
    if (!armeAttaquant.parDefaut) {
      action += " <span style='" + BS_LABEL + " " + BS_LABEL_INFO + "; text-transform: none; font-size: 100%;'>(" + armeAttaquant.name + ")</span>";
    }
    const display = startFramedDisplay(playerId, action, attaquant, {
      perso2: defenseur
    });
    let critAttaquant = critEnAttaque(attaquant, armeAttaquant, options);
    let dice = 20;
    let malusAttaque = 0;
    if (estAffaibli(attaquant)) {
      if (predicateAsBool(attaquant, 'insensibleAffaibli')) {
        malusAttaque = -2;
        explications.push("Attaquant affaibli, mais insensible => -2 en Attaque");
      } else {
        dice = 12;
        explications.push("Attaquant affaibli => D12 au lieu de D20 en Attaque");
      }
    } else if (getState(attaquant, 'immobilise')) {
      dice = 12;
      explications.push("Attaquant immobilis\xE9 => D12 au lieu de D20 en Attaque");
    }
    let toEvaluateAttack = attackExpression(attaquant, 1, dice, critAttaquant, true, armeAttaquant);
    try {
      sendChat('', toEvaluateAttack, function(resAttack) {
        let rollsAttack = resAttack[0];
        if (options.rolls && options.rolls.attack)
          rollsAttack = options.rolls.attack;
        let afterEvaluateAttack = rollsAttack.content.split(' ');
        let attRollNumber = rollNumber(afterEvaluateAttack[0]);
        let attSkillNumber = rollNumber(afterEvaluateAttack[1]);
        let d20rollAttaquant = rollsAttack.inlinerolls[attRollNumber].results.total;
        if (stateCOF.foudreDuTemps) foudreDuTemps(attaquant, d20rollAttaquant);
        let attSkill = rollsAttack.inlinerolls[attSkillNumber].results.total;
        let attBonus =
          bonusAttaqueA(attaquant, armeAttaquant.name, evt, explications, options);
        attBonus += malusAttaque;
        let pageId = options.pageId || attaquant.token.get('pageid');
        attBonus +=
          bonusAttaqueD(attaquant, defenseur, 0, pageId, evt, explications, options);
        let attackRollAttaquant = d20rollAttaquant + attSkill + attBonus;
        let attRollValue = buildinline(rollsAttack.inlinerolls[attRollNumber]);
        attRollValue += (attSkill > 0) ? "+" + attSkill : (attSkill < 0) ? attSkill : "";
        attRollValue += (attBonus > 0) ? "+" + attBonus : (attBonus < 0) ? attBonus : "";
        if (options.bonusAttaqueAttaquant) {
          options.bonusAttaqueAttaquant.forEach(function(bad) {
            attRollValue += (bad.val > 0) ? "+" + bad.val : (bad.val < 0) ? bad.val : "";
            attackRollAttaquant += bad.val;
            if (bad.explication) explications.push(bad.explication);
          });
        }
        addLineToFramedDisplay(display, "Jet de " + nomPerso(attaquant) + " : " + attRollValue);
        var critDefenseur = critEnAttaque(defenseur, armeDefenseur, options);
        dice = 20;
        malusAttaque = 0;
        if (estAffaibli(defenseur)) {
          if (predicateAsBool(defenseur, 'insensibleAffaibli')) {
            malusAttaque = -2;
            explications.push("D\xE9fenseur affaibli, mais insensible => -2 en Attaque");
          } else {
            dice = 12;
            explications.push("D\xE9fenseur affaibli => D12 au lieu de D20 en Attaque");
          }
        } else if (getState(defenseur, 'immobilise')) {
          dice = 12;
          explications.push("D\xE9fenseur immobilis\xE9 => D12 au lieu de D20 en Attaque");
        }
        toEvaluateAttack = attackExpression(defenseur, 1, dice, critDefenseur, true, armeDefenseur);
        sendChat('', toEvaluateAttack, function(resAttack) {
          var rollsAttack = resAttack[0];
          if (options.rolls && options.rolls.attackDefenseur)
            rollsAttack = options.rolls.attackDefenseur;
          afterEvaluateAttack = rollsAttack.content.split(' ');
          attRollNumber = rollNumber(afterEvaluateAttack[0]);
          attSkillNumber = rollNumber(afterEvaluateAttack[1]);
          var d20rollDefenseur = rollsAttack.inlinerolls[attRollNumber].results.total;
          if (stateCOF.foudreDuTemps) foudreDuTemps(defenseur, d20rollDefenseur);
          attSkill = rollsAttack.inlinerolls[attSkillNumber].results.total;
          attBonus =
            bonusAttaqueA(defenseur, armeDefenseur.name, evt, explications, options);
          attBonus += malusAttaque;
          attBonus +=
            bonusAttaqueD(defenseur, attaquant, 0, pageId, evt, explications, options);
          var attackRollDefenseur = d20rollDefenseur + attSkill + attBonus;
          attRollValue = buildinline(rollsAttack.inlinerolls[attRollNumber]);
          attRollValue += (attSkill > 0) ? "+" + attSkill : (attSkill < 0) ? attSkill : "";
          attRollValue += (attBonus > 0) ? "+" + attBonus : (attBonus < 0) ? attBonus : "";
          if (options.bonusAttaqueDefenseur) {
            options.bonusAttaqueDefenseur.forEach(function(bad) {
              attRollValue += (bad.val > 0) ? "+" + bad.val : (bad.val < 0) ? bad.val : "";
              attackRollDefenseur += bad.val;
              if (bad.explication) explications.push(bad.explication);
            });
          }
          addLineToFramedDisplay(display, "Jet de " + nomPerso(defenseur) + " : " + attRollValue);
          var resultat = {
            rollAttaquant: attackRollAttaquant,
            rollDefenseur: attackRollDefenseur,
            armeAttaquant: armeAttaquant
          };
          if (d20rollAttaquant == 1 && d20rollDefenseur > 1) {
            resultat.echec = true;
            resultat.echecCritique = true;
            diminueMalediction(attaquant, evt);
          } else if (d20rollDefenseur == 1 && d20rollAttaquant > 1) {
            resultat.succes = true;
            resultat.echecCritiqueDefenseur = true;
            diminueMalediction(defenseur, evt);
          } else if (d20rollAttaquant >= critAttaquant && d20rollDefenseur < critDefenseur) {
            resultat.succes = true;
            resultat.critique = true;
            diminueMalediction(defenseur, evt);
          } else if (d20rollAttaquant < critAttaquant && d20rollDefenseur >= critDefenseur) {
            resultat.succes = false;
            resultat.critiqueDefenseur = true;
            diminueMalediction(attaquant, evt);
          } else if (attackRollAttaquant < attackRollDefenseur) {
            resultat.echec = true;
            diminueMalediction(attaquant, evt);
          } else {
            resultat.succes = true;
            diminueMalediction(defenseur, evt);
          }
          callback(resultat, display, explications); //evt est mis \xE0 jour
        }); //fin du sendchat pour jet du d\xE9fenseur
      }); //Fin du sendChat pour jet de l'attaquant
    } catch (rollError) {
      error("Erreur pendant le jet " + toEvaluateAttack + " dans attaqueContactOppos\xE9", options);
    }
  }

  function testAttaqueOpposee(msg) {
    let cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il faut 2 personnages pour un test d'attaque en opposition", cmd);
      return;
    }
    const attaquant = persoOfId(cmd[1], cmd[1]);
    const defenseur = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-test-attaque-opposee doit \xEAtre un token valide", cmd[1]);
      return;
    }
    if (defenseur === undefined) {
      error("Le deuxi\xE8me argument de !cof-test-attaque-opposee doit \xEAtre un token valide", cmd[2]);
      return;
    }
    const evt = {
      type: "Test d'attaque oppos\xE9e"
    };
    const options = {
      pasDeDmg: true
    };
    if (cmd.length > 3) options.labelArmeAttaquant = cmd[3];
    let playerId = getPlayerIdFromMsg(msg);
    attaqueContactOpposee(playerId, attaquant, defenseur, evt, options,
      function(res, display, explications) {
        if (res.succes)
          addLineToFramedDisplay(display, nomPerso(attaquant) + " remporte le test");
        else
          addLineToFramedDisplay(display, nomPerso(defenseur) + " remporte le test");
        explications.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
        sendChat('', endFramedDisplay(display));
        addEvent(evt);
      });
  }

  //!cof-desarmer attaquant cible, optionellement un label d'arme
  function desarmer(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il manque des arguments \xE0 !cof-desarmer", msg.content);
      return;
    }
    var guerrier = persoOfId(cmd[1], cmd[1]);
    if (guerrier === undefined) {
      error("Le premier argument de !cof-desarmer n'est pas un token valide", cmd);
      return;
    }
    var cible = persoOfId(cmd[2], cmd[2]);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-desarmer n'est pas un token valide", cmd);
      return;
    }
    let pageId = guerrier.token.get('pageid');
    if (distanceCombat(guerrier.token, cible.token, pageId)) {
      sendPerso(guerrier, "est trop loin de " + nomPerso(cible) + " pour le d\xE9sarmer.");
      return;
    }
    var options = {
      action: "<b>D\xE9sarmement</b>",
      armeContact: "doit porter une arme de contact pour d\xE9sarmer son adversaire.",
      pasDeDmg: true,
      pageId: pageId,
    };
    //On cherche l'arme de la cible. On en aura besoin pour d\xE9sarmer
    let armeCible = armesEnMain(cible);
    let attrArmeCible = cible.attrArmeEnMain;
    if (armeCible) {
      options.armeDefenseur = armeCible;
      if (armeCible.deuxMains) {
        options.bonusAttaqueDefenseur = [{
          val: 5,
          explication: nomPerso(cible) + " porte une arme \xE0 2 mains => +5 \xE0 son jet"
        }];
      }
    }
    const enleverArmeCible = function() {
      if (attrArmeCible) {
        evt.deletedAttributes = evt.deletedAttributes || [];
        evt.deletedAttributes.push(attrArmeCible);
        attrArmeCible.remove();
        cible.armesEnMain = undefined;
      }
    };
    const evt = {
      type: 'D\xE9sarmer'
    };
    if (cmd.length > 3) options.labelArmeAttaquant = cmd[3];
    const playerId = getPlayerIdFromMsg(msg);
    attaqueContactOpposee(playerId, guerrier, cible, evt, options,
      function(res, display, explications) {
        let resultat;
        if (res.echecCritique) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_DANGER + "'><b>\xE9chec&nbsp;critique</b></span>";
        } else if (res.echecCritiqueDefenseur) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succ\xE8s</b></span>, " + nomPerso(cible) + " laisse tomber son arme, difficile de la r\xE9cup\xE9rer...";
          enleverArmeCible();
        } else if (res.critique) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>r\xE9ussite critique</b></span> : " + nomPerso(cible) + " est d\xE9sarm\xE9, et " + nomPerso(guerrier) + " emp\xEAche de reprendre l'arme";
          enleverArmeCible();
        } else if (res.critiqueDefenseur) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>\xE9chec</b></span>, " + nomPerso(cible) + " garde son arme bien en main";
        } else if (res.echec) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>\xE9chec</b></span>, " + nomPerso(guerrier) + " n'a pas r\xE9ussi \xE0 d\xE9sarmer son adversaire";
        } else { //succ\xE8s
          enleverArmeCible();
          if (res.rollAttaquant > res.rollDefenseur + 9) {
            resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succ\xE8s</b></span>, " + nomPerso(guerrier) + " d\xE9sarme son adversaire et l'emp\xEAche de r\xE9cup\xE9rer son arme";
          } else {
            resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succ\xE8s</b></span>, " + nomPerso(guerrier) + " d\xE9sarme son adversaire.";
          }
        }
        addLineToFramedDisplay(display, resultat);
        explications.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
        sendChat('', endFramedDisplay(display));
        addEvent(evt);
      });
  }

  function appliquerBloquer(attaquant, cible, critique, evt, envoyerMessage) {
    let msg;
    if (envoyerMessage) msg = "est bloqu\xE9 par son adversaire";
    setAttrDuree(cible, 'bloqueManoeuvre', 1, evt, msg);
    if (critique)
      appliquerTenirADistance(attaquant, cible, false, evt, envoyerMessage);
  }

  function appliquerTenirADistance(attaquant, cible, critique, evt, envoyerMessage) {
    let msg;
    if (envoyerMessage) msg = "est tenu \xE0 distance par son adversaire";
    setAttrDuree(
      cible, 'tenuADistanceManoeuvre(' + attaquant.token.id + ')', 1, evt, msg);
    if (critique) appliquerBloquer(attaquant, cible, false, evt, envoyerMessage);
  }

  const listeManoeuvres = {
    aveugler: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        let duree = 1;
        if (critique) duree = randomInteger(6);
        let msg;
        if (envoyerMessage) msg = "est aveugl\xE9 par son adversaire";
        setAttrDuree(
          cible, 'aveugleManoeuvre', duree, evt, msg);
        return critique; //Pour les DMs en plus
      },
      verbe: 'aveugler',
      duelliste: false
    },
    bloquer: {
      appliquer: appliquerBloquer,
      penalitePlusPetit: true,
      verbe: 'bloquer',
      duelliste: true
    },
    desarmer: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        let attrArmeCible = tokenAttribute(cible, 'armeEnMain');
        if (attrArmeCible.length > 0) {
          attrArmeCible = attrArmeCible[0];
          evt.deletedAttributes = evt.deletedAttributes || [];
          evt.deletedAttributes.push(attrArmeCible);
          attrArmeCible.remove();
        }
        if (envoyerMessage) {
          let msgDesarme = "est d\xE9sarm\xE9" + onGenre(cible, '', 'e');
          if (critique) msgDesarme += ", son adversaire lui a pris son arme.";
          else msgDesarme += ".";
          sendPerso(cible, msgDesarme);
        }
      },
      verbe: 'd\xE9sarmer',
      duelliste: true
    },
    faireDiversion: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var msg;
        if (envoyerMessage) msg = "a son attention attir\xE9e ailleurs";
        var malus = -5;
        if (critique) malus = -10;
        setAttrDuree(cible, 'diversionManoeuvre', 1, evt, msg);
        setTokenAttr(cible, 'diversionManoeuvreValeur', malus, evt);
      },
      verbe: 'faire diversion sur',
      duelliste: false
    },
    menacer: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        let msg;
        if (envoyerMessage) msg = "est sous le coup d'une menace";
        let effet = 'menaceManoeuvre(' + attaquant.token.id;
        if (critique) effet += ',crit';
        effet += ')';
        setAttrDuree(cible, effet, 1, evt, msg);
      },
      verbe: 'menacer',
      duelliste: false
    },
    renverser: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        if (envoyerMessage) sendPerso(cible, "tombe au sol");
        setState(cible, 'renverse', true, evt);
        return critique; //Pour les DM en plus
      },
      penalitePlusPetit: true,
      verbe: 'renverser',
      duelliste: true
    },
    repousser: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var distance = rollDePlus(6);
        if (critique && distance < 3) distance = 3;
        if (envoyerMessage)
          sendPerso(cible, "est repouss\xE9" + onGenre(cible, '', 'e') + " et doit reculer de " + distance.roll + "m.");
        if (critique) setState(cible, 'renverse', true, evt);
      },
      penalitePlusPetit: true,
      verbe: 'repousser',
      duelliste: true
    },
    tenirADistance: {
      appliquer: appliquerTenirADistance,
      verbe: 'tenir \xE0 distance',
      duelliste: true
    }
  };

  //!cof-appliquer-manoeuvre id1 id2 effet attrId
  //attrId est utilis\xE9 pour limiter le nombre d'utilisations
  function appliquerManoeuvre(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 5) {
      error("cof-appliquer-manoeuvre attend 4 arguments", msg.content);
      return;
    }
    if (!_.has(listeManoeuvres, cmd[3])) {
      error("Manoeuvre " + cmd[3] + " inconnue.", cmd);
      return;
    }
    var limiteAttr = getObj('attribute', cmd[4]);
    if (limiteAttr === undefined) {
      sendPlayer(msg, "La manoeuvre a d\xE9j\xE0 \xE9t\xE9 choisie");
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-appliquer-maneuvre n'est pas un token valide", cmd);
      return;
    }
    var cible = persoOfId(cmd[2], cmd[2]);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-appliquer-manoeuvre n'est pas un token valide", cmd);
      return;
    }
    var effet = listeManoeuvres[cmd[3]];
    var evt = {
      type: 'Application de manoeuvre',
      deletedAttributes: [limiteAttr]
    };
    limiteAttr.remove();
    effet.appliquer(attaquant, cible, false, evt, true);
    addEvent(evt);
  }

  //!cof-manoeuvre id1 id2 effet
  function manoeuvreRisquee(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    options.pasDeDmg = true;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 4) {
      error("cof-manoeuvre attend 3 arguments", msg.content);
      return;
    }
    if (!_.has(listeManoeuvres, cmd[3])) {
      sendPlayer(msg, "Manoeuvre " + cmd[3] + " inconnue.");
      return;
    }
    let effet = listeManoeuvres[cmd[3]];
    let attaquant = persoOfId(cmd[1], cmd[1]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-maneuvre n'est pas un token valide", cmd);
      return;
    }
    let cible = persoOfId(cmd[2], cmd[2]);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-manoeuvre n'est pas un token valide", cmd);
      return;
    }
    const evt = {
      type: 'manoeuvre'
    };
    if (effet.penalitePlusPetit) {
      let tailleAttaquant = taillePersonnage(attaquant);
      let tailleCible = taillePersonnage(cible);
      if (tailleAttaquant && tailleCible && tailleAttaquant < tailleCible) {
        let penalite = 5 * (tailleAttaquant - tailleCible);
        options.bonusAttaqueAttaquant = [{
          val: penalite,
          explication: nomPerso(attaquant) + " est plus petit que " + nomPerso(cible) + " => " + penalite + " Att"
        }];
      }
    }
    let playerId = getPlayerIdFromMsg(msg);
    let manoeuvreDuelliste = effet.duelliste && predicateAsBool(attaquant, 'manoeuvreDuelliste');
    attaqueContactOpposee(playerId, attaquant, cible, evt, options,
      function(res, display, explications) {
        let dmSupp;
        if (res.succes) {
          addLineToFramedDisplay(display, nomPerso(attaquant) + " r\xE9ussit \xE0 " + effet.verbe + " " + nomPerso(cible));
          dmSupp = effet.appliquer(attaquant, cible, res.critique, evt);
          if (manoeuvreDuelliste && !dmSupp) {
            let pageId = cible.token.get('pageid');
            let defense = defenseOfPerso(attaquant, cible, pageId, evt, options);
            dmSupp = res.rollAttaquant >= defense + 10;
          }
        } else {
          addLineToFramedDisplay(display, nomPerso(attaquant) + " ne r\xE9ussit pas \xE0 " + effet.verbe + " " + nomPerso(cible));
          //Envoyer \xE0 la cible la possibilit\xE9 d'appliquer un effet de son choix
        }
        explications.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
        if (dmSupp) {
          let actionGratuite =
            "!cof-attack " + attaquant.token.id + " " + cible.token.id + " -1 --auto";
          addLineToFramedDisplay(display, nomPerso(attaquant) + " fait en plus des d\xE9g\xE2ts \xE0 " + nomPerso(cible) + boutonSimple(actionGratuite, "lancer une attaque pour d\xE9terminer le montant"), 80);
        }
        sendChat("", endFramedDisplay(display));
        addEvent(evt);
        /*if (dmSupp) {
           turnAction(attaquant, playerId);
        }*/
        if (!res.succes && !manoeuvreDuelliste) {
          let charCible = getObj('character', cible.charId);
          if (charCible === undefined) {
            error("Cible sans personnage associ\xE9", cible);
            return;
          }
          let titre = "Choisir un effet contre " + nomPerso(attaquant);
          //On cr\xE9e un display sans le header
          display = startFramedDisplay(undefined, titre, cible, {
            retarde: true
          });
          //Attribut pour empecher plusieurs utilisations
          let attrLimit = createObj('attribute', {
            _characterid: cible.charId,
            name: 'limiteApplicationManoeuvre',
            current: '1'
          });
          for (let man in listeManoeuvres) {
            let appliquerManoeuvre = '!cof-appliquer-manoeuvre ' + cible.token.id + ' ' + attaquant.token.id + ' ' + man + ' ' + attrLimit.id;
            let ligneManoeuvre = boutonSimple(appliquerManoeuvre, man);
            addLineToFramedDisplay(display, ligneManoeuvre, 90);
          }
          // on envoie la liste aux joueurs qui g\xE8rent le voleur
          let playerIds = getPlayerIds(cible);
          playerIds.forEach(function(playerid) {
            addFramedHeader(display, playerid, true);
            sendChat('', endFramedDisplay(display));
          });
          if (playerIds.length === 0) {
            addFramedHeader(display, undefined, 'gm');
            sendChat('', endFramedDisplay(display));
          }
        }
      });
  }

  //!cof-expert-combat-bousculer
  function expertDuCombatBousculer(msg) {
    let cmd = msg.content.split(' ');
    if (!stateCOF.combat) {
      error("On ne peut utiliser !cof-expert-combat-bousculer qu'en combat", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("Il manque des arguments \xE0 !cof-expert-combat-bousculer", msg.content);
      return;
    }
    let expert = persoOfId(cmd[1], cmd[1]);
    if (expert === undefined) {
      error("Le premier argument de !cof-expert-combat-bousculer n'est pas un token valide", cmd);
      return;
    }
    let cible = persoOfId(cmd[2], cmd[2]);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-expert-combat-bousculer n'est pas un token valide", cmd);
      return;
    }
    if (!predicateAsBool(expert, 'expertDuCombat')) {
      error(nomPerso(expert) + " n'est pas un expert du combat !", cmd);
      return;
    }
    let pageId = expert.token.get('pageid');
    if (distanceCombat(expert.token, cible.token, pageId)) {
      sendPerso(expert, "est trop loin de " + nomPerso(cible) + " pour le bousculer.");
      return;
    }
    const evt = {
      type: 'Bousculer'
    };
    addEvent(evt);
    if (!persoUtiliseDeExpertDuCombat(expert, evt)) return;
    var deExpertise = rollDePlus(6);
    var playerId = getPlayerIdFromMsg(msg);
    var explications = [];
    testOppose("bouculer", expert, "FOR", {
      bonus: deExpertise.val
    }, cible, "FOR", {}, explications, evt, function(resultat, crit, rt1, rt2) {
      var display = startFramedDisplay(playerId, "Bousculer", expert, {
        perso2: cible
      });
      explications.push("D\xE9 d'expertise : " + deExpertise.roll);
      if (resultat === 1) {
        addLineToFramedDisplay(display, nomPerso(cible) + " est repouss\xE9 de " +
          Math.ceil(deExpertise.val / 2) + " m\xE8tre" + (deExpertise.val > 1 ? "s" : "") + "<br/>S'il est accul\xE9 : " +
          boutonSimple("!cof-dmg " + deExpertise.val + " --target " + cmd[2], "Appliquer " + deExpertise.val + " DM"));
        setState(cible, "renverse", "true", evt);
      } else {
        addLineToFramedDisplay(display, nomPerso(cible) + " n'est pas renvers\xE9");
      }
      explications.forEach(function(expl) {
        addLineToFramedDisplay(display, expl, 80);
      });
      sendChat("", endFramedDisplay(display));
    });
  }

  function sendCommands(from, commands) {
    if (commands.length === 0) return;
    var c = commands.shift();
    if (c.startsWith('!')) {
      _.delay(function() {
        sendChat(from, c);
        sendCommands(from, commands);
      }, 10);
    } else error("multi-commande invalide", c);
  }

  //!cof-multi-command !cmd1 ... --cof-multi-command !cmd2 .. --cof-multi-command !cmd3...
  function multiCommand(msg) {
    var posFirstCommand = msg.content.indexOf('!', 2);
    var commands = msg.content.substr(posFirstCommand).split(' --cof-multi-command ');
    sendCommands(msg.who, commands);
    /* commands.forEach(function(c) {
       if (c.startsWith('!')) sendChat(msg.who, c);
       else error("multi-commande invalide", c);
     });*/
  }

  const predateurs = {
    loup: {
      nom: 'Loup',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59094468/bX_aTjrVAbIRHjpRn-HwdQ/max.jpg?1532611383",
      token: "https://s3.amazonaws.com/files.d20.io/images/59489165/3R9Ob68sTiqvNeEhwzwWcg/thumb.png?1533047142",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 1,
        force: 12,
        pnj_for: 1,
        dexterite: 12,
        pnj_dex: 1,
        constitution: 12,
        pnj_con: 1,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 3,
        pnj_def: 14,
        pnj_init: 12,
        race: 'loup',
        taille: 'moyen'
      },
      pv: 9,
      attaques: [{
        nom: 'Morsure',
        atk: 2,
        dmnbde: 1,
        dmde: 6,
        dm: 1,
      }],
      attributes: [],
      abilities: []
    },
    loupAlpha: {
      nom: 'Loup alpha',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59094818/J0yWdxryZFKakJtNGJNNvw/max.jpg?1532612061",
      token: "https://s3.amazonaws.com/files.d20.io/images/60183959/QAMH6WtyoK78aa4zX_mR_Q/thumb.png?1533898482",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 2,
        force: 16,
        pnj_for: 3,
        dexterite: 12,
        pnj_dex: 1,
        constitution: 16,
        pnj_con: 3,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 4,
        pnj_def: 15,
        INIT_DIV: 5,
        pnj_init: 17,
        race: 'loup',
        taille: 'moyen'
      },
      pv: 15,
      attaques: [{
        nom: 'Morsure',
        atk: 4,
        dmnbde: 1,
        dmde: 6,
        dm: 3,
      }],
      attributes: [{
        name: 'discr\xE9tion',
        current: 5
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]] --target @{target|token_id}'
      }],
      actions: [{
        titre: 'Attaque en embuscade',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }]
    },
    worg: {
      nom: 'Grand loup',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/25294798/4dJ_60uP2mw6UJA2elkoXA/max.jpg?1479223790",
      token: "https://s3.amazonaws.com/files.d20.io/images/60184237/smG5o2-siD2pChhPblO_sQ/thumb.png?1533899118",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 3,
        force: 16,
        pnj_for: 3,
        dexterite: 12,
        pnj_dex: 1,
        constitution: 16,
        pnj_con: 3,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 4,
        pnj_int: -3,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 6,
        pnj_def: 17,
        INIT_DIV: 5,
        pnj_init: 17,
        race: 'loup',
        taille: 'moyen'
      },
      pv: 35,
      attaques: [{
        nom: 'Morsure',
        atk: 6,
        dmnbde: 1,
        dmde: 6,
        dm: 5,
      }],
      attributes: [{
        name: 'discr\xE9tion',
        current: 5
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]'
      }],
      actions: [{
        titre: 'Attaque en embuscade',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }]
    },
    lion: {
      nom: 'Lion',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486104/SngxPIGXDJKdCqsbrXxRYQ/max.jpg?1533041390",
      token: "https://s3.amazonaws.com/files.d20.io/images/60184437/df1MT2T6lrfo7st02Htxeg/thumb.png?1533899407",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 4,
        force: 20,
        pnj_for: 5,
        dexterite: 18,
        pnj_dex: 4,
        dex_sup: '@{jetsup}',
        pnj_dex_sup: 'on',
        constitution: 20,
        pnj_con: 5,
        intelligence: 4,
        pnj_int: -3,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -3,
        DEFDIV: 4,
        pnj_def: 18,
        INIT_DIV: 5,
        pnj_init: 23,
        race: 'lion',
        taille: 'grand'
      },
      pv: 30,
      attaques: [{
        nom: 'Morsure',
        atk: 7,
        dmnbde: 2,
        dmde: 6,
        dm: 5,
      }],
      attributes: [{
        name: 'discr\xE9tion',
        current: 5
      }, {
        name: 'predicats_script',
        current: 'devorer',
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]'
      }],
      actions: [{
        titre: 'Attaque en embuscade',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }, {
        titre: 'D\xE9vorer',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1'
      }]
    },
    grandLion: {
      nom: 'Grand lion',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486144/8wHs_5WfEIeL_7dKbALHHA/max.jpg?1533041459",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186141/mUZzndi9_sYIzdVVNNka_w/thumb.png?1533903070",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 5,
        force: 22,
        pnj_for: 6,
        dexterite: 18,
        pnj_dex: 3,
        dex_sup: '@{jetsup}',
        pnj_dex_sup: 'on',
        constitution: 20,
        pnj_con: 5,
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 14,
        pnj_cha: 2,
        DEFDIV: 6,
        pnj_def: 20,
        pnj_init: 18,
        race: 'lion',
        taille: 'grand'
      },
      pv: 50,
      attaques: [{
        nom: 'Morsure',
        atk: 9,
        dmnbde: 2,
        dmde: 6,
        dm: 7,
      }],
      attributes: [{
        name: 'discr\xE9tion',
        current: 5
      }, {
        name: 'predicats_script',
        current: 'devorer',
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]'
      }],
      actions: [{
        titre: 'Attaque en embuscade',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }, {
        titre: 'D\xE9vorer',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1'
      }]
    },
    oursPolaire: {
      nom: 'Ours polaire',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486216/UssilagWK_2dfVGuPABBpA/max.png?1533041591",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186288/B1uAii9G01GcPfQFNozIbw/thumb.png?1533903333",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 6,
        force: 26,
        pnj_for: 8,
        for_sup: '@{jetsup}',
        pnj_for_sup: 'on',
        dexterite: 11,
        pnj_dex: 0,
        constitution: 26,
        pnj_con: 8,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 10,
        pnj_def: 20,
        pnj_init: 11,
        race: 'ours',
        taille: 'grand'
      },
      pv: 70,
      attaques: [{
        nom: 'Morsure',
        atk: 12,
        dmnbde: 2,
        dmde: 8,
        dm: 7,
      }],
      attributes: [{
        name: 'predicats_script',
        curreent: 'peutEnrager',
      }],
      actions: [{
        titre: 'Charge',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --m2d20 --pietine}'
      }, ]
    },
    tigreDentsDeSabre: {
      nom: 'Tigre \xE0 dents de sabre',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486272/f5lUcN3Y9H0thmJPrqa6FQ/max.png?1533041702",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186469/ShcrgpvgXKiQsLVOyg4SZQ/thumb.png?1533903741",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 7,
        force: 26,
        pnj_for: 8,
        for_sup: '@{jetsup}',
        pnj_for_sup: 'on',
        dexterite: 18,
        pnj_dex: 4,
        dex_sup: '@{jetsup}',
        pnj_dex_sup: 'on',
        constitution: 26,
        pnj_con: 8,
        intelligence: 2,
        pnj_int: -4,
        sagesse: 12,
        pnj_sag: 1,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 2,
        pnj_cha: -4,
        DEFDIV: 8,
        pnj_def: 22,
        pnj_init: 18,
        race: 'tigre',
        taille: 'grand'
      },
      pv: 90,
      attaques: [{
        nom: 'Morsure',
        atk: 14,
        dmnbde: 2,
        dmde: 6,
        dm: 12,
      }],
      attributes: [{
        name: 'discr\xE9tion',
        current: 5
      }, {
        name: 'predicats_script',
        current: 'devorer',
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]',
      }],
      actions: [{
        titre: 'Attaque en embuscade',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }, {
        titre: 'D\xE9vorer',
        ccode: '!cof-attack @{selected|token_id} @{target|token_id} 1'
      }]
    },
    oursPrehistorique: {
      nom: 'Ours pr\xE9historique',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486323/V6RVSlBbeRJi_aIaIuGGBw/max.png?1533041814",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186633/lNHXvCOsvfPMZDQnqJKQVw/thumb.png?1533904189",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 8,
        force: 32,
        pnj_for: 11,
        dexterite: 10,
        pnj_dex: 0,
        constitution: 32,
        pnj_con: 11,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 12,
        pnj_def: 22,
        pnj_init: 10,
        RDS: 2,
        race: 'ours',
        taille: '\xE9norme'
      },
      pv: 110,
      attaques: [{
        nom: 'Griffes',
        atk: 17,
        dmnbde: 3,
        dmde: 6,
        dm: 13,
      }],
      attributes: [{
        name: 'fauchage',
        current: 'true'
      }],
      actions: [{
        titre: 'Charge',
        code: '!cof-attack @{selected|token_id} @{target|token_id} 1 --m2d20 --pietine}'
      }, ]
    }
  };

  function conjurationPredateur(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Pas de commande", msg.content);
      return;
    }
    let renforce = 0;
    if (cmd.length > 1) {
      renforce = parseInt(cmd[1]);
      if (isNaN(renforce)) {
        error("Il faut un nombre comme premier argument de !cof-conjuration-de-predateur");
        renforce = 0;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        error("pas de lanceur pour la conjuration de pr\xE9dateurs", msg);
        return;
      }
      let evt = {
        type: 'conjuration de pr\xE9dateurs'
      };
      let combat = initiative(selected, evt);
      let abort;
      iterSelected(selected, function(invocateur) {
        if (abort) return;
        if (options.tempeteDeMana) {
          if (selected.length > 1) {
            sendPlayerAndGM(msg, playerId, "Il faut s\xE9lectionner un seul token pour les options de temp\xEAte de mana");
            abort = true;
            return;
          }
          if (options.tempeteDeMana.cout === 0) {
            //On demande de pr\xE9ciser les options
            let optMana = {
              mana: options.mana,
              portee: false,
              duree: true,
              dm: true,
              intense: 0,
              rang: 1
            };
            setTempeteDeMana(playerId, invocateur, msg.content, optMana);
            abort = true;
            return;
          } else {
            if (options.tempeteDeMana.cout > 1) {
              sendPlayerAndGM(msg, playerId, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
            }
          }
        }
        if (limiteRessources(invocateur, options, 'invocationPredateur', 'lancer une invocation de pr\xE9dateur', evt)) return;
        let pageId = invocateur.token.get('pageid');
        let niveau = ficheAttributeAsInt(invocateur, 'niveau', 1);
        if (!renforce) {
          renforce = predicateAsInt(invocateur, 'voieDeLaConjuration', 0);
          if (renforce == 1) renforce = 0;
        }
        niveau += renforce;
        let predateur;
        if (niveau < 5) predateur = predateurs.loup;
        else if (niveau < 9) predateur = predateurs.loupAlpha;
        else if (niveau < 12) predateur = predateurs.worg;
        else if (niveau < 15) predateur = predateurs.lion;
        else if (niveau < 18) predateur = predateurs.grandLion;
        else if (niveau < 21) predateur = predateurs.oursPolaire;
        else if (niveau < 23) predateur = predateurs.tigreDentsDeSabre;
        else predateur = predateurs.oursPrehistorique;
        if (options.tempeteDeManaIntense) {
          // on copie les attaques pour leur ajouter --si predateurConjure
          let attaques = predateur.attaques;
          predateur = {...predateur
          };
          predateur.attaques = [];
          attaques.forEach(function(attaque) {
            attaque = {...attaque
            };
            attaque.options = '--si etat predateurConjure';
            predateur.attaques.push(attaque);
          });
        }
        let nomPredateur =
          predateur.nom + ' de ' + nomPerso(invocateur);
        let token = createObj('graphic', {
          name: nomPredateur,
          subtype: 'token',
          pageid: pageId,
          imgsrc: predateur.token,
          left: invocateur.token.get('left'),
          top: invocateur.token.get('top'),
          width: 70,
          height: 70,
          layer: 'objects',
          showname: 'true',
          showplayers_bar1: 'true',
          light_hassight: 'true',
          light_angle: 0, //Pour que le joueur ne voit rien par ses yeux
          has_bright_light_vision: true,
          has_limit_field_of_vision: true,
        });
        toFront(token);
        let charPredateur =
          createCharacter(nomPredateur, playerId, predateur.avatar, token, predateur, evt);
        //Tous les pr\xE9dateurs sont des quadrup\xE8des
        let persoPredateur = {
          token: token,
          charId: charPredateur.id
        };
        setPredicate(persoPredateur, 'quadrupede', evt);
        //Attribut de predateur conjur\xE9 pour la disparition automatique
        let attr = createObj('attribute', {
          name: 'predateurConjure',
          _characterid: charPredateur.id,
          current: 5 + modCarac(invocateur, 'charisme'),
          max: combat.init
        });
        if (options.mana !== undefined) {
          addEffetTemporaireLie(invocateur, attr, evt);
        }
        if (options.tempeteDeManaIntense) {
          createObj('attribute', {
            name: 'predateurConjureTempeteDeManaIntense',
            _characterid: charPredateur.id,
            current: options.tempeteDeManaIntense,
          });
        }
        evt.characters = [charPredateur];
        evt.tokens = [token];
        initiative([{
          _id: token.id
        }], evt);
        // Ajout du Pr\xE9dateur aux alli\xE9s de l'invocateur
        let alliesInvocateur = alliesParPerso[invocateur.charId] || new Set();
        alliesInvocateur.add(charPredateur.id);
        alliesParPerso[invocateur.charId] = alliesInvocateur;
      }); //end iterSelected
      addEvent(evt);
    }); //end getSelected
  }

  //!cof-sphere-de-feu
  function sphereDeFeu(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Pas de commande", msg.content);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        error("pas de lanceur pour la sphere de feu", msg);
        return;
      }
      let evt = {
        type: "invocation d'une sph\xE8re de feu",
      };
      let combat = initiative(selected, evt);
      iterSelected(selected, function(invocateur) {
        if (limiteRessources(invocateur, options, 'sphereDeFeu', 'lancer un sort de sph\xE8re de feu', evt)) return;
        let character = getObj('character', invocateur.charId);
        if (character === undefined) {
          error("Impossible de trouver le personnage de " + nomPerso(invocateur), invocateur);
          return;
        }
        let pageId = invocateur.token.get('pageid');
        let niveau = ficheAttributeAsInt(invocateur, 'niveau', 1);
        let sphere = {
          nom: 'Sph\xE8re de feu',
          avatar: "https://s3.amazonaws.com/files.d20.io/images/260057530/nL8O6US3f1BpeTJkodWNCg/max.png?16394116785",
          token: "https://s3.amazonaws.com/files.d20.io/images/260057530/nL8O6US3f1BpeTJkodWNCg/thumb.png?16394116785",
          attributesFiche: {
            type_personnage: 'PNJ',
            niveau: 1,
          },
          pv: 1,
          attaques: [{
            nom: 'Br\xFBlure',
            atk: 0,
            dmnbde: 3,
            dmde: 6,
            dm: 0,
            typedegats: 'feu',
            modificateurs: 'auto',
            options: '--saveDM DEX ' + (10 + modCarac(invocateur, 'intelligence')),
          }],
          attributes: [{
            name: 'predicats_script',
            current: 'nonVivant immunite_feu sansEsprit initiativeDeriveeDe::' + character.get('name') + '\n',
          }, {
            name: 'predateurConjure', //Pas exactement \xE7a, mais \xE7a fait ce qu'il faut
            current: niveau,
            max: combat.init,
            lie: options.mana !== undefined
          }],
        };
        let nomSphere = sphere.nom + ' de ' + nomPerso(invocateur);
        let token = createObj('graphic', {
          name: nomSphere,
          subtype: 'token',
          pageid: pageId,
          imgsrc: sphere.token,
          left: invocateur.token.get('left'),
          top: invocateur.token.get('top'),
          width: 35,
          height: 35,
          layer: 'objects',
          showname: 'true',
          showplayers_bar1: 'true',
          light_hassight: 'true',
          light_angle: 0, //Pour que le joueur ne voit rien par ses yeux
          has_bright_light_vision: true,
          has_limit_field_of_vision: true,
        });
        if (token === undefined) {
          error("Impossible de cr\xE9er le token de la sph\xE8re de feu ", sphere);
          return;
        }
        toFront(token);
        let charSphere =
          createCharacter(nomSphere, playerId, sphere.avatar, token, sphere, evt, invocateur);
        evt.characters = [charSphere];
        evt.tokens = [token];
        initiative([{
          _id: token.id
        }], evt);
        // Ajout du Pr\xE9dateur aux alli\xE9s de l'invocateur
        let alliesInvocateur = alliesParPerso[invocateur.charId] || new Set();
        alliesInvocateur.add(charSphere.id);
        alliesParPerso[invocateur.charId] = alliesInvocateur;
      }); //end iterSelected
      addEvent(evt);
    }); //end getSelected
  }

  //!cof-conjuration-armee [d\xE9 de DM] --limiteParJour...
  function conjurationArmee(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Il faut s\xE9lectionner le lanceur de la conjuration d'arm\xE9\xE9", playerId);
        return;
      }
      let abort;
      iterSelected(selected, function(invocateur) {
        if (abort) return;
        if (options.tempeteDeMana) {
          if (selected.length > 1) {
            sendPlayerAndGM(msg, playerId, "Il faut s\xE9lectionner un seul token pour les options de temp\xEAte de mana");
            abort = true;
            return;
          }
          if (options.tempeteDeMana.cout === 0) {
            //On demande de pr\xE9ciser les options
            let optMana = {
              mana: options.mana,
              portee: false,
              duree: false,
              dm: true,
              intense: 0,
              rang: 3
            };
            setTempeteDeMana(playerId, invocateur, msg.content, optMana);
            abort = true;
            return;
          } else {
            if (options.tempeteDeMana.cout > 1) {
              sendPlayerAndGM(msg, playerId, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
            }
          }
        }
        let pageId = invocateur.token.get('pageid');
        let niveau = ficheAttributeAsInt(invocateur, 'niveau', 1);
        const evt = {
          type: "Conjuration d'arm\xE9e"
        };
        if (limiteRessources(invocateur, options, 'conjurationArmee', "conjurer une arm\xE9e", evt)) {
          addEvent(evt);
          return;
        }
        let dm;
        if (cmd.length > 1) {
          dm = parseDice(cmd[1]);
        }
        if (dm === undefined) {
          dm = {
            nbDe: 1,
            dice: 6,
            bonus: 0
          };
          let rang = predicateAsInt(invocateur, 'voieDeLaConjuration', 3);
          if (rang == 4) {
            dm.dice = 10;
          } else if (rang > 4) {
            dm.nbDe = 2;
          }
        }
        let nomArmee = "Arm\xE9e de " + nomPerso(invocateur);
        let token = createObj('graphic', {
          name: nomArmee,
          subtype: 'token',
          pageid: pageId,
          imgsrc: 'https://s3.amazonaws.com/files.d20.io/images/73283129/-jrKAyQQ1P7zpD09xeTbXw/thumb.png?1549546953',
          left: invocateur.token.get('left'),
          top: invocateur.token.get('top'),
          width: 70,
          height: 70,
          layer: 'objects',
          showname: 'true',
          showplayers_bar1: 'true',
          light_hassight: 'true',
          light_angle: 0, //Pour que le joueur ne voit rien par ses yeux
          has_bright_light_vision: true,
          has_limit_field_of_vision: true,
          aura1_radius: 10,
          aura1_color: "#d56eef",
          aura1_square: true
        });
        toFront(token);
        let avatar = "https://s3.amazonaws.com/files.d20.io/images/73283254/r6sbxbP1QKKtqXyYq-MlLA/max.png?1549547198";
        let attaque = {
          nom: 'Attaque',
          dmnbde: dm.nbDe,
          dmde: dm.dice,
          modificateurs: 'auto',
          options: "--allonge 20 --si etat armeeConjuree",
        };
        if (dm.bonus) attaque.dm = dm.bonus;
        let attributes = [{
          name: 'armeeConjuree',
          current: invocateur.charId,
          lie: options.mana !== undefined
        }];
        if (options.tempeteDeManaIntense) {
          attributes.push({
            name: 'armeeConjureeTempeteDeManaIntense',
            current: options.tempeteDeManaIntense
          });
        }
        let charArmee =
          createCharacter(nomArmee, playerId, avatar, token, {
            pv: niveau * 10,
            attaques: [attaque],
            attributes: attributes
          }, evt, invocateur);
        evt.characters = [charArmee];
        evt.tokens = [token];
        if (stateCOF.combat) {
          initiative([{
            _id: token.id
          }], evt);
        }
      });
    });
  }

  //!cof-tenebres token-lanceur token-cible
  // possibilit\xE9 de --brumes pour un effet de brumes
  function tenebres(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("!cof-tenebres mal form\xE9, il faut un token comme premier argument", msg.content);
      return;
    }
    let necromant = persoOfId(cmd[1], cmd[1], options.pageId);
    if (necromant === undefined) {
      error("Le premier argument de !cof-tenebres n'est pas un token valide", cmd);
      return;
    }
    let target = persoOfId(cmd[2], cmd[2], options.pageId);
    if (target === undefined) {
      error("Le second argument de !cof-tenebres n'est pas un token valide", cmd);
      return;
    }
    options.lanceur = necromant;
    const playerId = getPlayerIdFromMsg(msg);
    if (options.tempeteDeMana) {
      if (options.tempeteDeMana.cout === 0) {
        //On demande de pr\xE9ciser les options
        let optMana = {
          mana: options.mana,
          portee: true,
          duree: true,
          intense: 0,
          rang: 1
        };
        setTempeteDeMana(playerId, options.lanceur, msg.content, optMana);
        return;
      } else {
        if (options.tempeteDeMana.cout > 1) {
          sendPlayerAndGM(msg, playerId, "Attention, le co\xFBt de la temp\xEAte de mana (" + options.tempeteDeMana.cout + ") est sup\xE9rieur au rang du sort");
        }
      }
    }
    let portee = options.portee || 20;
    if (options.puissantPortee || options.tempeteDeManaPortee) {
      portee = portee * 2;
    }
    let rayon = options.rayon;
    if (rayon === undefined) {
      rayon = options.brumes ? 20 : 5;
    }
    if (options.puissant || options.tempeteDeManaIntense) rayon = Math.floor(Math.sqrt(2) * rayon);
    if (distanceCombat(necromant.token, target.token, options.pageId, {
        strict2: true
      }) > portee) {
      sendPlayer(msg, "Le point vis\xE9 est trop loin (port\xE9e " + portee + ")", playerId);
      return;
    }
    let duree = 5;
    if (options.brumes) duree += modCarac(necromant, 'sagesse');
    else duree += modCarac(necromant, 'intelligence');
    if (options.puissantDuree || options.tempeteDeManaDuree) {
      duree = duree * 2;
    }
    const evt = {
      type: 'tenebres'
    };
    addEvent(evt);
    if (options.brumes) {
      if (limiteRessources(necromant, options, 'brumes', 'lancer un sort de brumes', evt)) return;
    } else {
      if (limiteRessources(necromant, options, 'tenebres', 'lancer un sort de t\xE9n\xE8bres', evt)) return;
    }
    if (!stateCOF.combat) {
      initPerso(necromant, evt);
    }
    let rayonUnite = scaleDistance(necromant, rayon);
    let tokSpec = {
      showname: true,
      subtype: 'token',
      pageid: options.pageId,
      left: target.token.get("left"),
      top: target.token.get("top"),
    };
    if (options.brumes) {
      tokSpec.name = "Brumes de " + nomPerso(necromant);
      tokSpec.imgsrc = 'https://s3.amazonaws.com/files.d20.io/images/274452104/DUq74hFhXq9yPK3Q1KinlA/thumb.png?1646665878';
      tokSpec.width = rayonUnite * PIX_PER_UNIT;
      tokSpec.height = rayonUnite * PIX_PER_UNIT;
      tokSpec.layer = 'map';
    } else {
      tokSpec.name = "T\xE9n\xE8bres de " + nomPerso(necromant);
      tokSpec.imgsrc = 'https://s3.amazonaws.com/files.d20.io/images/192072874/eJXFx20fD931DuBDvzAnQQ/thumb.png?1610469273';
      tokSpec.width = 70;
      tokSpec.height = 70;
      tokSpec.layer = 'objects';
      tokSpec.aura1_radius = 0;
      tokSpec.aura1_color = "#c1c114";
      tokSpec.aura1_square = true;
      tokSpec.aura2_radius = rayonUnite;
      tokSpec.aura2_color = "#000000";
      tokSpec.showplayers_aura2 = true;
    }
    let token = createObj('graphic', tokSpec);
    if (token) {
      evt.tokens = [token];
    }
    if (stateCOF.options.affichage.val.duree_effets.val) {
      if (options.brumes)
        sendPerso(necromant, "lance un sort de brumes pour " + duree + " tours");
      else
        sendPerso(necromant, "lance un sort de t\xE9n\xE8bres pour " + duree + " tours");
    }
    // Calcul des cibles \xE0 aveugler
    let cibles = [];
    let allToksDisque =
      findObjs({
        _type: 'graphic',
        _pageid: options.pageId,
        _subtype: 'token',
        layer: 'objects'
      });
    let saufAllies = msg.content.includes(" --saufAllies");
    let allies;
    if (saufAllies) {
      allies = alliesParPerso[necromant.charId];
      allies = (new Set(allies)).add(necromant.charId);
    }
    allToksDisque.forEach(function(obj) {
      if (obj.get('bar1_max') == 0) return; // jshint ignore:line
      let objCharId = obj.get('represents');
      if (objCharId === '') return;
      if (saufAllies && allies.has(objCharId)) return;
      let cible = {
        token: obj,
        charId: objCharId
      };
      if (getState(cible, 'mort')) return;
      let distanceCentre =
        distanceCombat(target.token, obj, options.pageId, {
          strict1: true
        });
      if (distanceCentre > rayon) return;
      cibles.push(cible);
    });
    let effetAveugle = {
      effet: 'aveugleTemp',
      duree: duree
    };
    if (options.brumes) effetAveugle.effet = 'penombreTemp';
    cibles.forEach(function(perso) {
      setEffetTemporaire(perso, effetAveugle, duree, evt, {});
    });
    let effetTenebres = {
      effet: 'tenebres',
      duree: duree,
      valeur: token.id,
      pasDeMessageDActivation: true,
      attaquant: necromant
    };
    if (options.brumes) effetTenebres.effet = 'brumes';
    setEffetTemporaire(necromant, effetTenebres, duree, evt, options);
    if (target.token.get('bar1_max') == 0) { // jshint ignore:line
      //C'est juste un token utilis\xE9 pour d\xE9finir le disque
      target.token.remove(); //On l'enl\xE8ve, normalement plus besoin
    }
    if (options.messages) {
      options.messages.forEach(function(m) {
        sendPerso(necromant, m, options.secret);
      });
    }
  }

  const demonInvoque = {
    nom: 'D\xE9mon',
    avatar: "https://s3.amazonaws.com/files.d20.io/images/183633585/DWpHYp4SLPCDCMHdmTyKOw/thumb.png?1607339938",
    token: "https://s3.amazonaws.com/files.d20.io/images/183633585/DWpHYp4SLPCDCMHdmTyKOw/thumb.png?1607339938",
    attributesFiche: {
      type_personnage: 'PNJ',
      niveau: 5,
      force: 20,
      pnj_for: 5,
      for_sup: '@{jetsup}',
      pnj_for_sup: 'on',
      dexterite: 14,
      pnj_dex: 2,
      constitution: 18,
      pnj_con: 4,
      con_sup: '@{jetsup}',
      pnj_con_sup: 'on',
      intelligence: 14,
      pnj_int: 2,
      sagesse: 14,
      pnj_sag: 2,
      charisme: 10,
      pnj_cha: 0,
      DEFDIV: 3,
      pnj_def: 17,
      pnj_init: 16,
      race: 'd\xE9mon',
      taille: 'moyen'
    },
    attaques: [{
      nom: 'Griffes',
      dmnbde: 1,
      dmde: 8,
      dm: 5,
      modificateurs: 'magique'
    }],
    attributes: [{
      name: 'predicats_script',
      current: 'd\xE9mon'
    }],
    abilities: []
  };

  function invocationDemon(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("!cof-invoquer-demon mal form\xE9, il faut un token comme premier argument", msg.content);
      return;
    }
    let necromant = persoOfId(cmd[1], cmd[1], options.pageId);
    if (necromant === undefined) {
      error("Le premier argument de !cof-invoquer-demon n'est pas un token valie", cmd);
      return;
    }
    options.lanceur = necromant;
    getSelected(msg, function(selected, playerId) {
      const evt = {
        type: 'invocationDemon',
        action: {
          rolls: {}
        }
      };
      addEvent(evt);
      if (limiteRessources(necromant, options, 'invoquerDemon', 'lance une invocation de d\xE9mon', evt)) return;
      let d6 = rollDePlus(6);
      evt.action.rolls.invocationDemonDmg = d6;
      let r = {
        total: d6.val,
        type: 'normal',
        display: d6.roll
      };
      let explications = [];
      necromant.ignoreTouteRD = true;
      dealDamage(necromant, r, [], evt, false, {}, explications,
        function(dmgDisplay, dmg) {
          if (!stateCOF.combat) {
            initPerso(necromant, evt);
          }
          let tokenDemon = "D\xE9mon de " + nomPerso(necromant);
          let token = createObj('graphic', {
            name: tokenDemon,
            showname: 'true',
            subtype: 'token',
            pageid: options.pageId,
            imgsrc: demonInvoque.token,
            left: necromant.token.get('left'),
            top: necromant.token.get('top'),
            width: 70,
            height: 70,
            layer: 'objects',
            showplayers_bar1: 'true',
            light_hassight: 'true',
            light_angle: 0,
            has_bright_light_vision: true,
            has_limit_field_of_vision: true,
          });
          toFront(token);
          let niveau = ficheAttributeAsInt(necromant, "niveau", 1);
          let demon = {...demonInvoque
          };
          demon.pv = niveau * 5;
          demon.attaques[0].atk = niveau;
          let charDemon = createCharacter(tokenDemon, playerId, demonInvoque.avatar, token, demon, evt);
          evt.characters = [charDemon];
          evt.tokens = [token];
          let duree = 5 + modCarac(necromant, 'intelligence');
          //Attribut de d\xE9mon invoqu\xE9 pour la disparition automatique
          createObj('attribute', {
            name: 'demonInvoque',
            _characterid: charDemon.id,
            current: duree,
            max: getInit()
          });
          createObj('attribute', {
            name: 'resistanceA_nonMagique',
            _characterid: charDemon.id,
            current: 'true',
          });
          initiative([{
            _id: token.id
          }], evt);
          // Ajout du D\xE9mon aux alli\xE9s du N\xE9cromant
          var alliesNecromant = alliesParPerso[necromant.charId] || new Set();
          alliesNecromant.add(charDemon.id);
          alliesParPerso[necromant.charId] = alliesNecromant;
          var msg = "invoque un d\xE9mon";
          if (stateCOF.options.affichage.val.duree_effets.val) msg += " pour " + duree + " tours";
          msg += " mais cela lui co\xFBte " + dmgDisplay + " PV";
          sendPerso(necromant, msg);
        });
    }, options);
  }

  const zombieAnime = {
    nom: 'Zombie',
    avatar: "https://s3.amazonaws.com/files.d20.io/images/147503510/RKFKQefVjSiyNPJtvBuGOg/thumb.png?1593643543",
    token: "https://s3.amazonaws.com/files.d20.io/images/147503510/RKFKQefVjSiyNPJtvBuGOg/thumb.png?1593643543",
    attributesFiche: {
      type_personnage: 'PNJ',
      niveau: 1,
      force: 12,
      pnj_for: 1,
      dexterite: 8,
      pnj_dex: -1,
      constitution: 12,
      pnj_con: 1,
      intelligence: 2,
      pnj_int: -4,
      sagesse: 6,
      pnj_sag: -2,
      charisme: 2,
      pnj_cha: -4,
      pnj_def: 10,
      pnj_init: 8,
      race: 'mort-vivant',
      taille: 'moyen'
    },
    attaques: [{
      nom: 'Coup',
      atk: 3,
      dmnbde: 1,
      dmde: 6,
      dm: 1
    }],
    pv: 12,
    attributes: [],
    abilities: []
  };

  function animerMort(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("!cof-animer-mort mal form\xE9, il faut un token comme premier argument", msg.content);
      return;
    }
    const necromant = persoOfId(cmd[1], cmd[1], options.pageId);
    if (necromant === undefined) {
      error("Le premier argument de !cof-animer-mort n'est pas un token valie", cmd);
      return;
    }
    let zombiesControles = attributeAsInt(necromant, 'zombiesControles', 0);
    let rangVoie = predicateAsInt(necromant, 'voieOutreTombe', 1);
    if (zombiesControles >= rangVoie) {
      sendPerso(necromant, "ne peut plus animer de Zombie car il en contr\xF4le d\xE9j\xE0 assez.");
      return;
    }
    options.lanceur = necromant;
    const evt = {
      type: 'animerMort',
      action: {
        rolls: {}
      },
      characters: [],
      tokens: []
    };
    addEvent(evt);
    if (limiteRessources(necromant, options, 'animerMort', "lancer un sort d'Animation des morts", evt)) return;
    let combat = stateCOF.combat;
    if (!combat) {
      combat = initPerso(necromant, evt);
    }
    let nomToken = "Zombie de " + nomPerso(necromant);
    let token = createObj('graphic', {
      name: nomToken,
      showname: 'true',
      subtype: 'token',
      pageid: options.pageId,
      imgsrc: zombieAnime.token,
      left: necromant.token.get('left'),
      top: necromant.token.get('top'),
      width: 70,
      height: 70,
      layer: 'objects',
      showplayers_bar1: 'true',
      light_hassight: 'true',
      light_angle: 0,
      has_bright_light_vision: true,
      has_limit_field_of_vision: true,
    });
    toFront(token);
    let zombie = {
      ...zombieAnime
    };
    let playerId = getPlayerIdFromMsg(msg);
    let charZombie = createCharacter(nomToken, playerId, zombieAnime.avatar, token, zombie, evt);
    evt.characters.push(charZombie);
    evt.tokens.push(token);
    // D\xE9gradation du Zombie
    createObj('attribute', {
      name: 'degradationZombie',
      _characterid: charZombie.id,
      current: 71,
      max: combat.init,
    });
    // Gestion de la limitation des zombies
    createObj('attribute', {
      name: 'necromant',
      _characterid: charZombie.id,
      current: necromant.token.id,
    });
    initiative([{
      _id: token.id
    }], evt);
    // Ajout du Zombie aux alli\xE9s du N\xE9cromant
    let alliesNecromant = alliesParPerso[necromant.charId] || new Set();
    alliesNecromant.add(charZombie.id);
    alliesParPerso[necromant.charId] = alliesNecromant;
    sendPerso(necromant, "anime un Zombie", options.secret);
    if (options.messages) {
      options.messages.forEach(function(m) {
        sendPerso(necromant, m, options.secret);
      });
    }
    setTokenAttr(necromant, "zombiesControles", zombiesControles + 1, evt);
  }

  const PAUSE = String.fromCharCode(0x23F8);
  const PLAY = String.fromCharCode(0x23F5);
  const MONTER = String.fromCharCode(0x2197);
  const DESCENDRE = String.fromCharCode(0x2198);

  //Cr\xE9e les macros utiles au jeu
  const gameMacros = [{
    name: 'Actions',
    action: "!cof-liste-actions",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'Attaque',
    action: "!cof-attack @{selected|token_id} @{target|token_id}",
    visibleto: 'all',
    istokenaction: false
  }, {
    name: 'Consommables',
    action: "!cof-consommables",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'Bouger',
    action: "!cof-bouger",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: MONTER,
    oldName: 'Monter',
    action: "!cof-escalier haut",
    visibleto: 'all',
    istokenaction: true,
    inBar: false
  }, {
    name: DESCENDRE,
    oldName: 'Descendre',
    action: "!cof-escalier bas",
    visibleto: 'all',
    istokenaction: true,
    inBar: false
  }, {
    name: 'Fin-combat',
    action: "!cof-fin-combat",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Init',
    action: "!cof-init",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Jets',
    action: "!cof-jet",
    visibleto: 'all',
    istokenaction: true,
  }, {
    name: 'Jets-GM',
    action: "!cof-jet --secret",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Nuit',
    action: "!cof-nouveau-jour ?{Repos?|Oui,--repos|Non}",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Repos',
    action: "!cof-recuperation",
    visibleto: 'all',
    istokenaction: true,
    inBar: false
  }, {
    name: 'Statut',
    action: "!cof-statut",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'Surprise',
    action: "!cof-surprise ?{difficult\xE9}",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Torche',
    action: "!cof-torche @{selected|token_id}",
    visibleto: 'all',
    istokenaction: true,
  }, {
    name: '\xC9teindre',
    action: "!cof-eteindre-lumiere ?{Quelle lumi\xE8re?|Tout}",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'devient',
    action: "!cof-set-state ?{\xC9tat|mort|surpris|assomme|renverse|aveugle|affaibli|etourdi|paralyse|ralenti|immobilise|endormi|apeure|invisible|blesse|encombre} true",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'enl\xE8ve',
    action: "!cof-set-state ?{\xC9tat|mort|surpris|assomme|renverse|aveugle|affaibli|etourdi|paralyse|ralenti|immobilise|endormi|apeure|invisible|blesse|encombre} false",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Suivre',
    action: "!cof-suivre @{selected|token_id} @{target|token_id}",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'undo',
    action: "!cof-undo",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: PAUSE,
    action: "!cof-pause",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, ];

  function setGameMacros(msg) {
    let playerId = msg.playerid;
    let force = playerIsGM(playerId) && msg.content.includes('--force');
    let inBar = [];
    let allMacros = findObjs({
      _type: 'macro'
    });
    gameMacros.forEach(function(m) {
      let prev =
        allMacros.find(function(macro) {
          return macro.get('name') == m.name;
        });
      if (prev === undefined) {
        m.playerid = playerId;
        createObj('macro', m);
        sendPlayer(msg, "Macro " + m.name + " cr\xE9\xE9e.");
        if (m.inBar) inBar.push(m.name);
      } else if (force) {
        prev.set('action', m.action);
        prev.set('visibleto', m.visibleto);
        prev.set('istokenaction', m.istokenaction);
        sendPlayer(msg, "Macro " + m.name + " r\xE9\xE9crite.");
        if (m.inBar) inBar.push(m.name);
      } else {
        sendPlayer(msg, "Macro " + m.name + " d\xE9j\xE0 pr\xE9sente (utiliser --force pour r\xE9\xE9crire).");
      }
    });
    if (inBar.length > 0) {
      sendPlayer(msg, "Macros \xE0 mettre dans la barre d'action du MJ : " + inBar.join(', '));
    }
    stateCOF.gameMacros = gameMacros;
  }

  function ajouteLumiere(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    const cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Il faut au moins 2 arguments \xE0 !cof-lumiere", cmd);
      return;
    }
    const cible = persoOfId(cmd[1]);
    if (cible === undefined) {
      error("le premier argument de !cof-lumi\xE8re doit \xEAtre un token", cmd);
      return;
    }
    const radius = parseInt(cmd[2]);
    if (isNaN(radius) || radius <= 0) {
      error("La distance de vue de la lumi\xE8re doit \xEAtre positive", cmd[2]);
      return;
    }
    let dimRadius = '';
    if (cmd.length > 3) {
      dimRadius = parseInt(cmd[3]);
      if (isNaN(dimRadius)) {
        error("La distance de vue de la lumi\xE8re assombrie doit \xEAtre un nombre", cmd[3]);
        dimRadius = '';
      }
    }
    let nomToken = 'lumiere';
    if (cmd.length > 4) {
      nomToken = cmd[4].trim();
      if (nomToken === '') nomToken = 'lumiere';
    }
    const evt = {
      type: 'lumiere',
    };
    addEvent(evt);
    if (limiteRessources(options.lanceur, options, 'lumi\xE8re', "lumi\xE8re", evt)) return;
    ajouteUneLumiere(cible, nomToken, radius, dimRadius, evt);
  }

  function eteindreUneLumiere(perso, pageId, al, lumName, evt) {
    if (al === undefined) {
      let attrLumiere = tokenAttribute(perso, 'lumiere');
      al = attrLumiere.find(function(a) {
        return a.get('current') == lumName;
      });
      if (al === undefined) return;
    }
    let lumId = al.get('max');
    if (lumId == 'surToken') {
      //Il faut enlever la lumi\xE8re sur tous les tokens
      let allTokens = [perso.token];
      if (perso.token.get('bar1_value') !== '') {
        allTokens = findObjs({
          type: 'graphic',
          represents: perso.charId
        });
        allTokens = allTokens.filter(function(tok) {
          return tok.get('bar1_value') !== '';
        });
      }
      allTokens.forEach(function(token) {
        setToken(token, 'light_radius', '', evt);
        setToken(token, 'light_dimradius', '', evt);
        setToken(token, 'emits_bright_light', false, evt);
        setToken(token, 'emits_low_light', false, evt);
      });
      al.remove();
      return;
    }
    let lumiere = getObj('graphic', lumId);
    if (lumiere === undefined) {
      let tokensLumiere = findObjs({
        _type: 'graphic',
        layer: 'walls',
        name: lumName
      });
      if (tokensLumiere.length === 0) {
        log("Pas de token pour la lumi\xE8re " + lumName);
        al.remove();
        return;
      }
      lumiere = tokensLumiere.shift();
      if (tokensLumiere.length > 0) {
        //On cherche le token le plus proche de perso
        let d = distancePixToken(lumiere, perso.token);
        let samePage = lumiere.get('pageid') == pageId;
        tokensLumiere.forEach(function(tl) {
          if (tl.get('pageid') != pageId) return;
          if (samePage) {
            let d2 = distancePixToken(tl, perso.token);
            if (d2 < d) {
              d = d2;
              lumiere = tl;
            }
          } else {
            lumiere = tl;
          }
        });
      }
    }
    al.remove();
    if (lumiere) lumiere.remove();
  }

  function eteindreLumieres(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lectionn\xE9e pour !cof-eteindre-lumiere", playerId);
        return;
      }
      const cmd = options.cmd;
      let groupe;
      if (cmd.length > 1) groupe = cmd[1];
      if (groupe && groupe.toLowerCase() == 'tout') groupe = '';
      let pageId = options.pageId;
      const evt = {
        type: "Eteindre la lumi\xE8re"
      };
      iterSelected(selected, function(perso) {
        pageId = pageId || perso.token.get('pageid');
        let attrLumiere = tokenAttribute(perso, 'lumiere');
        attrLumiere.forEach(function(al) {
          let lumName = al.get('current');
          if (groupe && !lumName.startsWith(groupe)) return;
          eteindreUneLumiere(perso, pageId, al, lumName, evt);
        });
      });
    }, options);
  }

  function switchTorche(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    const cmd = options.cmd;
    if (cmd.length < 2) {
      error("Il faut pr\xE9ciser le token en argument de !cof-torche");
      return;
    }
    let pageId = options.pageId;
    const perso = persoOfId(cmd[1], cmd[1], pageId);
    if (perso === undefined) {
      error("Token invalide", cmd);
      return;
    }
    pageId = pageId || perso.token.get('pageid');
    var diminueDuree = 0;
    if (cmd.length > 2) {
      //Dans ce cas, c'est pour diminuer la dur\xE9e de vie de la torche
      diminueDuree = parseInt(cmd[2]);
      if (isNaN(diminueDuree) || diminueDuree <= 0) {
        sendPlayer(msg, "Le deuxi\xE8me argument de !cof-torche doit \xEAtre un nombre strictement positif " + msg.content);
        return;
      }
    }
    var evt;
    //On commence par chercher si une torche est allum\xE9e
    var torcheAllumee = false;
    var attrLumiere = tokenAttribute(perso, 'lumiere').filter(function(a) {
      return a.get('current').startsWith('torche');
    });
    if (!diminueDuree && attrLumiere.length > 0) {
      torcheAllumee = true;
      evt = {
        type: "\xC9teindre les torches"
      };
      attrLumiere.forEach(function(al) {
        let lumName = al.get('current');
        eteindreUneLumiere(perso, pageId, al, lumName, evt);
      });
    }
    var nbTorches = 0;
    var tempsTorche = 0;
    var attrTorches = tokenAttribute(perso, 'torches');
    if (attrTorches.length > 0) {
      nbTorches = parseInt(attrTorches[0].get('current'));
      if (isNaN(nbTorches) || nbTorches < 0) {
        error("Nombre de torches incorrect", nbTorches);
        if (evt) addEvent(evt);
        return;
      }
      if (!torcheAllumee && nbTorches === 0) {
        whisperChar(perso.charId, "n'a pas de torche.");
        return;
      }
      tempsTorche = parseInt(attrTorches[0].get('max'));
      if (isNaN(tempsTorche) || tempsTorche < 0) {
        error("Temps restant pour la torche incorrect", tempsTorche);
        if (evt) addEvent(evt);
        return;
      }
      if (tempsTorche === 0) {
        if (nbTorches === 0) { //Donc forc\xE9ment torcheAllumee
          //On remet l'attribut dans un \xE9tat convenable
          setTokenAttr(perso, 'torches', 0, evt, {
            maxVal: 60
          });
          addEvent(evt);
          return;
        }
        nbTorches--;
        tempsTorche = 60;
      }
      if (diminueDuree) {
        evt = evt || {
          type: "Diminuer le duree de vie d'une torche"
        };
        var temps = diminueDuree;
        tempsTorche -= diminueDuree;
        if (tempsTorche <= 0) {
          nbTorches--;
          temps += tempsTorche;
          tempsTorche = 60;
          var msgDiminue = "torche \xE9puis\xE9e.";
          if (nbTorches === 0) {
            msgDiminue += " Plus de torche !";
          } else if (nbTorches == 1) {
            msgDiminue += " Plus qu'une torche.";
          } else {
            msgDiminue += " Il lui reste " + nbTorches + " torches.";
          }
          whisperChar(perso.charId, msgDiminue);
        }
        setTokenAttr(perso, 'torches', nbTorches, evt, {
          maxVal: tempsTorche
        });
        sendChar(perso.charId, '/w gm temps de torche diminu\xE9 de ' + temps + ' minutes');
        addEvent(evt);
        return;
      }
      if (torcheAllumee) {
        var msgTorche = "/w gm torche \xE9teinte. ";
        if (nbTorches > 1) {
          msgTorche += "Reste " + (nbTorches - 1) + " torche";
          if (nbTorches > 2) msgTorche += "s neuves";
          else msgTorche += " neuve";
          msgTorche += ", et une torche pouvant encore \xE9clairer " + tempsTorche + " minutes.";
        } else {
          msgTorche += "Elle peut encore \xE9clairer " + tempsTorche + " minutes.";
        }
        sendChar(perso.charId,
          msgTorche +
          boutonSimple("!cof-torche " + perso.token.id + " ?{Dur\xE9e?}", "Temps depuis allumage"));
        addEvent(evt);
        return;
      }
      evt = {
        type: "Allumer une torche"
      };
      ajouteUneLumiere(perso, 'torche', 13, 7, evt);
      var msgAllume =
        "allume une torche, qui peut encore \xE9clairer pendant " + tempsTorche +
        " minute";
      if (tempsTorche > 1) msgAllume += 's';
      msgAllume += '.';
      if (nbTorches > 1) {
        msgAllume += " Il lui reste encore " + (nbTorches - 1);
        if (nbTorches == 2) msgAllume += " autre torche.";
        else msgAllume += " autres torches.";
      }
      whisperChar(perso.charId, msgAllume);
      addEvent(evt);
      return;
    }
    //On ne tient pas le compte pr\xE9cis des torches
    if (torcheAllumee) {
      whisperChar(perso.charId, "\xE9teint sa torche");
    } else {
      evt = {
        type: "Allumer une torche"
      };
      ajouteUneLumiere(perso, 'torche', 13, 7, evt);
      whisperChar(perso.charId, "allume sa torche");
    }
    addEvent(evt);
  }

  //!cof-options
  //!cof-options opt1 [... optn] val, met l'option \xE0 val
  //!cof-options [opt0 ... optk] reset remet toutes les options \xE0 leur valeur patr d\xE9faut
  //Dans tous les cas, affiche les options du niveau demand\xE9
  function setCofOptions(msg) {
    const playerId = getPlayerIdFromMsg(msg);
    if (!playerIsGM(playerId)) {
      sendPlayer(msg, "Seul le MJ peut changer les options du script", playerId);
      return;
    }
    let cmd = msg.content.split(' ');
    let cofOptions = stateCOF.options;
    if (cofOptions === undefined) {
      sendPlayer(msg, "Options non diponibles", playerId);
      return;
    }
    let prefix = '';
    let up;
    let defOpt = defaultOptions;
    let newOption;
    let lastCmd;
    let fini;
    let current = '';
    cmd.shift();
    cmd.forEach(function(c) {
      if (fini) {
        sendPlayer(msg, "Option " + c + " ignor\xE9e", playerId);
        return;
      }
      if (c == 'reset') {
        for (let opt in cofOptions) delete cofOptions[opt];
        copyOptions(cofOptions, defOpt);
        fini = true;
      } else if (cofOptions[c]) {
        if (cofOptions[c].type == 'options') {
          if (defOpt[c] === undefined) {
            sendPlayer(msg, "Option " + c + " inconnue dans les options par d\xE9faut", playerId);
            fini = true;
            return;
          }
          defOpt = defOpt[c].val;
          cofOptions = cofOptions[c].val;
          up = prefix;
          prefix += ' ' + c;
        } else {
          newOption = cofOptions[c];
        }
      } else {
        if (newOption) { //on met newOption \xE0 c
          let val = c;
          switch (newOption.type) {
            case 'bool':
              switch (c) {
                case 'oui':
                case 'true':
                case '1':
                  val = true;
                  break;
                case 'non':
                case 'false':
                case '0':
                  val = false;
                  break;
                default:
                  sendPlayer(msg, "L'option " + lastCmd + " ne peut \xEAtre que true ou false", playerId);
                  val = newOption.val;
              }
              fini = true;
              break;
            case 'int':
              val = parseInt(c);
              if (isNaN(val)) {
                sendPlayer(msg, "L'option " + lastCmd + " est une valeur enti\xE8re", playerId);
                val = newOption.val;
              }
              fini = true;
              break;
            default:
              if (current === '') current = val;
              else current += ' ' + val;
              val = current;
          }
          newOption.val = val;
        } else if (lastCmd) {
          sendPlayer(msg, "L'option " + lastCmd + " ne contient pas de sous-option " + c, playerId);
        } else {
          sendPlayer(msg, "Option " + c + " inconnue.", playerId);
        }
      }
      lastCmd = c;
    });
    let titre = "Options de COFantasy";
    if (prefix !== '') {
      titre += "<br>" + prefix + ' (';
      titre += boutonSimple('!cof-options' + up, 'retour') + ')';
    }
    let display = startFramedDisplay(playerId, titre, undefined, {
      chuchote: true
    });
    for (let opt in cofOptions) {
      let optVu = opt.replace(/_/g, ' ');
      let line = '<span title="' + cofOptions[opt].explications + '">' +
        optVu + '</span> : ';
      let action = '!cof-options' + prefix + ' ' + opt;
      let displayedVal = cofOptions[opt].val;
      let after = '';
      switch (cofOptions[opt].type) {
        case 'options':
          displayedVal = '<span style="font-family: \'Pictos\'">l</span>';
          break;
        case 'bool':
          action += ' ?{Nouvelle valeur de ' + optVu + '|actif,true|inactif,false}';
          if (displayedVal)
          // Bizarrement, le caract\xE8re '*' modifie la suite du tableau
            displayedVal = '<span style="font-family: \'Pictos\'">3</span>';
          else
            displayedVal = '<span style="font-family: \'Pictos\'">&midast;</span>';
          break;
        case 'int':
          action += ' ?{Nouvelle valeur de ' + optVu + '(entier)}';
          break;
        case 'image':
          action += " ?{Entrez l'url pour " + optVu + '}';
          after =
            '<img src="' + displayedVal + '" style="width: 30%; height: auto; border-radius: 6px; margin: 0 auto;">';
          displayedVal = '<span style="font-family: \'Pictos\'">u</span>';
          break;
        case 'son':
          action += " ?{Entrez le nom du son pour " + optVu + '}';
          if (displayedVal === '') {
            displayedVal = '<span title="pas de son" style="font-family: \'Pictos Custom\'">u</span>';
          } else {
            after = boutonSimple('!cof-jouer-son ' + displayedVal,
              '<span style="font-family: \'Pictos\'">&gt;</span> ');
            displayedVal = '<span title="' + displayedVal + '" style="font-family: \'Pictos\'">m</span>';
          }
          break;
        default:
          action += ' ?{Nouvelle valeur de ' + optVu + '}';
      }
      line += boutonSimple(action, displayedVal) + after;
      addLineToFramedDisplay(display, line);
    }
    addLineToFramedDisplay(display, boutonSimple('!cof-options' + prefix + ' reset', 'Valeurs par d\xE9faut'), 70);
    sendChat('', endFramedDisplay(display));
  }

  function lancerDefiSamourai(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-defi-samourai demande au moins 2 options",
        msg.content);
      return;
    }
    let pageId = options.pageId;
    let samourai = persoOfId(cmd[1], cmd[1], pageId);
    if (samourai === undefined) {
      error("Le token s\xE9lectionn\xE9 n'est pas valide", msg.content);
      return;
    }
    if (attributeAsBool(samourai, 'defiSamourai')) {
      sendPlayer(msg, nomPerso(samourai) + " a d\xE9j\xE0 lanc\xE9 un d\xE9fi durant ce combat.");
      return;
    }
    let cible = persoOfId(cmd[2], cmd[2], pageId);
    if (cible === undefined) {
      error("Le deuxi\xE8me token s\xE9lectionn\xE9 n'est pas valide", msg.content);
      return;
    }
    const evt = {
      type: 'D\xE9fi samoura\xEF'
    };
    let explications = [];
    entrerEnCombat(samourai, [cible], explications, evt);
    explications.forEach(function(m) {
      sendPerso(samourai, m);
    });
    let bonus;
    if (cmd.length > 3) {
      bonus = parseInt(cmd[3]);
      if (isNaN(bonus) || bonus < 1) {
        error("Bonus de d\xE9fi de samoura\xEF incorrect", cmd[3]);
        bonus = undefined;
      }
    }
    if (bonus === undefined)
      bonus = predicateAsInt(samourai, 'voieDeLHonneur', 2);
    setTokenAttr(samourai, 'defiSamourai', bonus, evt, {
      msg: nomPerso(samourai) + " lance un d\xE9fi \xE0 " + nomPerso(cible),
      maxVal: idName(cible)
    });
  }

  function parseEnveloppement(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    const cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 6) {
      error("Il manque des arguments \xE0 !cof-enveloppement", cmd);
      return;
    }
    let cube = persoOfId(cmd[1]);
    if (cube === undefined) {
      error("Token non d\xE9fini", cmd[1]);
      return;
    }
    if (!peutController(msg, cube)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    let cible = persoOfId(cmd[2]);
    if (cible === undefined) {
      error("Token non d\xE9fini", cmd[2]);
      return;
    }
    let difficulte = parseInt(cmd[3]);
    if (isNaN(difficulte)) {
      error("Difficult\xE9 n'est pas un nombre, on prend 15 par d\xE9faut", cmd[3]);
      difficulte = 15;
    }
    let exprDM;
    let type;
    switch (cmd[4]) {
      case 'label':
      case 'ability':
        type = 'enveloppement';
        exprDM = cmd[4] + ' ' + cmd[5];
        break;
      case 'etreinte':
        type = '\xE9treinte';
        exprDM = cmd[4] + ' ' + cmd[5];
        break;
      default:
        error("Impossible de d\xE9terminer les d\xE9g\xE2ts quand envelopp\xE9", cmd[4]);
        return;
    }
    doEnveloppement(cube, cible, difficulte, type, exprDM, options);
  }

  //!cof-enveloppement cubeId targetId Difficulte Attaque
  //Attaque peut \xEAtre soit label l, soit ability a, soit etreinte expr
  function doEnveloppement(attaquant, cible, difficulte, type, exprDM, options) {
    const evt = {
      type: type,
      action: {
        titre: "Enveloppement",
        attaquant: attaquant,
        cible: cible,
        difficulte: difficulte,
        type: type,
        exprDM: exprDM,
        options: options,
      }
    };
    addEvent(evt);
    //Choix de la caract\xE9ristique pour r\xE9sister : FOR ou DEX
    let caracRes = meilleureCarac('FOR', 'DEX', cible, 10 + modCarac(attaquant, 'force'));
    let titre = (type == '\xE9treinte') ? '\xC9treinte' : 'Enveloppement';
    let display = startFramedDisplay(options.playerId, titre, attaquant, {
      perso2: cible
    });
    let explications = [];
    let rollId = 'enveloppement_' + cible.token.id;
    testOppose(rollId, attaquant, 'FOR', options, cible, caracRes, options,
      explications, evt,
      function(res, crit, rt1, rt2) {
        let act = " a absorb\xE9 ";
        switch (res) {
          case 1:
            if (type == '\xE9treinte') act = " s'est enroul\xE9 autour de ";
            explications.push(nomPerso(attaquant) + act + nomPerso(cible));
            let attaquantId = idName(attaquant);
            let maxval = difficulte;
            if (type == '\xE9treinte') maxval = 'etreinte ' + difficulte;
            setTokenAttr(cible, 'enveloppePar', attaquantId, evt, {
              maxVal: maxval
            });
            let cibleId = idName(cible);
            moveTokenWithUndo(cible.token, attaquant.token.get('left'), attaquant.token.get('top'), evt);
            toFront(attaquant.token);
            setTokenAttr(attaquant, 'enveloppe', cibleId, evt, {
              maxVal: exprDM
            });
            if (type == '\xE9treinte') setState(cible, 'immobilise', true, evt);
            break;
          case 2:
            if (caracRes == 'FOR') {
              if (type == '\xE9treinte') act = '\xE9treindre';
              else act = 'absorber';
              explications.push(nomPerso(cible) + " r\xE9siste et ne se laisse pas " + act);
            } else {
              if (type == '\xE9treinte') act = "l'\xE9treinte";
              else act = "l'absorption";
              explications.push(nomPerso(cible) + " \xE9vite " + act);
            }
            break;
          default: //match null, la cible s'en sort
            if (type == '\xE9treinte') act = "l'\xE9treinte";
            else act = "l'enveloppement";
            explications.push(nomPerso(cible) + " \xE9chappe de justesse \xE0 " + act);
        }
        explications.forEach(function(e) {
          addLineToFramedDisplay(display, e);
        });
        sendChat("", endFramedDisplay(display));
      });
  }

  //!cof-echapper-enveloppement
  function parseEchapperEnveloppement(msg) {
    let options = msg.options || parseOptions(msg);
    if (options === undefined) return;
    let libere =
      options.cmd && options.cmd.length > 1 && options.cmd[1] == 'libere';
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "!cof-echapper-enveloppement sans s\xE9lection de token", playerId);
        log("!cof-echapper-enveloppement requiert de s\xE9lectionner des tokens");
        return;
      }
      iterSelected(selected, function(perso) {
        let attr = tokenAttribute(perso, 'enveloppePar');
        if (attr.length === 0) {
          sendPlayer(msg, nomPerso(perso) + " n'est pas englouti.", playerId);
          return;
        }
        attr = attr[0];
        let cube = persoOfIdName(attr.get('current'), options.pageId);
        if (cube === undefined) {
          error("Attribut enveloppePar mal form\xE9, on le supprime", attr.get('current'));
          attr.remove();
          unlockToken(perso);
          return;
        }
        let etreinte = false;
        let maxAttr = attr.get('max') + '';
        if (maxAttr.startsWith('etreinte ')) {
          etreinte = true;
          maxAttr = maxAttr.substring(9);
        }
        if (libere) {
          let evt = {
            type: 'Lib\xE9ration',
            deletedAttributes: [attr]
          };
          addEvent(evt);
          attr.remove();
          unlockToken(perso);
          if (etreinte) setState(perso, 'immobilise', false, evt);
          attr = tokenAttribute(cube, 'enveloppe');
          attr.forEach(function(a) {
            let ca = persoOfIdName(a.get('current'));
            if (ca && ca.token.id == perso.token.id) {
              evt.deletedAttributes.push(a);
              a.remove();
            }
          });
          sendChar(cube.charId, "lib\xE8re " + nomPerso(perso));
          return;
        }
        let difficulte = parseInt(maxAttr);
        if (isNaN(difficulte)) {
          error("Difficult\xE9 mal form\xE9e", attr.get('max'));
          difficulte = 15;
        }
        doEchapperEnveloppement(perso, etreinte, cube, difficulte, options);
      });
    });
  }

  function doEchapperEnveloppement(perso, etreinte, cube, difficulte, options) {
    const evt = {
      type: (etreinte) ? "echapperEtreinte" : "echapperEnveloppement",
      personnage: perso,
      action: {
        perso: perso,
        etreinte: etreinte,
        cube: cube,
        difficulte: difficulte,
        options: options,
        rolls: options.rolls || {}
      }
    };
    addEvent(evt);
    let titre = "Tentative de sortir de " + nomPerso(cube);
    if (etreinte) titre = "Tentative de se lib\xE9rer de l'etreinte de " + cube.tokName;
    const display = startFramedDisplay(options.playerId, titre, perso, {
      chuchote: options.secret
    });
    const testId = 'enveloppement_' + perso.token.id;
    testCaracteristique(perso, 'FOR', difficulte, testId, options, evt,
      function(tr) {
        addLineToFramedDisplay(display, "<b>R\xE9sultat :</b> " + tr.texte);
        if (tr.reussite) {
          addLineToFramedDisplay(display, "C'est r\xE9ussi, " + nomPerso(perso) + " s'extirpe de " + cube.tokName + tr.modifiers);
          toFront(perso.token);
          evt.deletedAttributes = evt.deletedAttributes || [];
          let attr = tokenAttribute(perso, 'enveloppePar')[0];
          evt.deletedAttributes.push(attr);
          attr.remove();
          unlockToken(perso, evt);
          if (etreinte) setState(perso, 'immobilise', false, evt);
          attr = tokenAttribute(cube, 'enveloppe');
          attr.forEach(function(a) {
            let ca = persoOfIdName(a.get('current'));
            if (ca && ca.token.id == perso.token.id) {
              evt.deletedAttributes.push(a);
              a.remove();
            }
          });
        } else {
          var msgRate = "C'est rat\xE9." + tr.rerolls + tr.modifiers;
          addLineToFramedDisplay(display, msgRate);
        }
        sendChat('', endFramedDisplay(display));
      });
  }

  function parseLibererAgrippe(msg) {
    let options = msg.options || parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Il faut l'id du token en argument de !cof-liberer-agrippe", msg.content);
      return;
    }
    let perso = persoOfId(cmd[1], cmd[1], options.pageId);
    let attrName = 'estAgrippePar';
    let attr = tokenAttribute(perso, 'estAgrippePar');
    if (attr.length === 0) {
      attr = tokenAttribute(perso, 'etreinteImmolePar');
      attrName = 'etreinteImmolePar';
      if (attr.length === 0) {
        attr = tokenAttribute(perso, 'etreinteScorpionPar');
        attrName = 'etreinteScorpionPar';
        if (attr.length === 0) {
          attr = tokenAttribute(perso, 'estDevorePar');
          attrName = 'estDevorePar';
          if (attr.length === 0) {
            sendPlayer(msg, nomPerso(perso) + " n'est pas agripp\xE9.");
            return;
          }
        }
      }
    }
    attr = attr[0];
    let agrippant = persoOfIdName(attr.get('current'), options.pageId);
    if (agrippant === undefined) {
      error("Attribut " + attrName + " mal form\xE9, on le supprime", attr.get('current'));
      attr.remove();
      unlockToken(perso);
      return;
    }
    doLibererAgrippe(perso, agrippant, attrName, options);
  }

  //!cof-liberer-agrippe token_id
  function doLibererAgrippe(perso, agrippant, attrName, options) {
    const evt = {
      type: 'libererAgrippe',
      action: {
        titre: "Se lib\xE9rer",
        perso: perso,
        agrippant: agrippant,
        attrName: attrName,
        options: options
      }
    };
    addEvent(evt);
    let titre = "Tentative de se lib\xE9rer de " + nomPerso(agrippant);
    let playerId = options.playerId;
    let display = startFramedDisplay(playerId, titre, perso, {
      chuchote: options.secret
    });
    let explications = [];
    const rollId = 'libererAgrippe_' + perso.token.id;
    let options1 = {...options
    };
    if (attrName == 'etreinteImmolePar') options1.dice = 20;
    testOppose(rollId, perso, 'FOR', options1, agrippant, 'FOR',
      options, explications, evt,
      function(tr, crit, rt1, rt2) {
        explications.forEach(function(e) {
          addLineToFramedDisplay(display, e);
        });
        if (tr == 2) {
          let msgRate = "C'est rat\xE9, " + nomPerso(perso) + " est toujours ";
          if (attrName == 'etreinteImmolePar' || attrName == 'etreinteScorpionPar')
            msgRate += "prisonnier de l'\xE9treinte de " + nomPerso(agrippant);
          else if (attrName == 'estDevorePar')
            msgRate += 'saisi' + eForFemale(perso) + '.';
          else msgRate += "agripp\xE9" + eForFemale(perso) + ".";
          addLineToFramedDisplay(display, msgRate);
          if (attrName == 'etreinteScorpionPar') { // Cas d'\xE9treinte de scorpion avec dommages automatiques
            let d6 = evt.action.rolls.etreinteDmg || rollDePlus(6, {
              bonus: 3
            });
            evt.action.rolls.etreinteDmg = d6;
            let r = {
              total: d6.val,
              type: 'normal',
              display: d6.roll
            };
            let explications2 = [];
            perso.ignoreTouteRD = true;
            dealDamage(perso, r, [], evt, false, {}, explications2, function(dmgDisplay) {
              let dmgMsg = "L'\xE9treinte du scorpion inflige " + dmgDisplay + " d\xE9g\xE2ts.";
              setTokenAttr(perso, "etreinteScorpionRatee", true, evt);
              addLineToFramedDisplay(display, dmgMsg);
              explications2.forEach(function(expl) {
                addLineToFramedDisplay(display, expl, 80);
              });
              sendChat('', endFramedDisplay(display));
            });
          } else {
            sendChat('', endFramedDisplay(display));
          }
        } else {
          if (tr === 0)
            addLineToFramedDisplay(display, "R\xE9ussi de justesse, " + nomPerso(perso) + " se lib\xE8re.");
          else //tr == 1
            addLineToFramedDisplay(display, "R\xE9ussi, " + nomPerso(perso) + " se lib\xE8re.");
          toFront(perso.token);
          evt.deletedAttributes = evt.deletedAttributes || [];
          let attr = tokenAttribute(perso, attrName);
          attr[0].remove();
          unlockToken(perso, evt);
          evt.deletedAttributes.push(attr[0]);
          if (attrName == 'estAgrippePar') removeTokenAttr(perso, 'agrippeParUnDemon', evt);
          if (attrName == 'etreinteImmolePar' || attrName == 'estDevorePar' || attr[0].get('max'))
            setState(perso, 'immobilise', false, evt);
          if (attrName == 'etreinteScorpionPar') {
            let etrScorpAttr = tokenAttribute(perso, "etreinteScorpionRatee");
            if (etrScorpAttr && etrScorpAttr.length > 0) {
              etrScorpAttr[0].remove();
              evt.deletedAttributes.push(etrScorpAttr[0]);
            }
          }
          let attrAgrippant = 'agrippe';
          if (attrName == 'etreinteImmolePar') attrAgrippant = 'etreinteImmole';
          if (attrName == 'etreinteScorpionPar') attrAgrippant = 'etreinteScorpionSur';
          if (attrName == 'estDevorePar') attrAgrippant = 'devore';
          attr = tokenAttribute(agrippant, attrAgrippant);
          attr.forEach(function(a) {
            let ca = persoOfIdName(a.get('current'));
            if (ca && ca.token.id == perso.token.id) {
              evt.deletedAttributes.push(a);
              a.remove();
              unlockToken(ca, evt);
            }
          });
          sendChat('', endFramedDisplay(display));
          if (attrName == 'etreinteScorpionPar') {
            turnAction(perso);
          }
        }
      });
  }

  function parseLibererEcrase(msg) {
    let options = msg.options || parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Il faut l'id du token en argument de !cof-liberer-ecrase", msg.content);
      return;
    }
    let perso = persoOfId(cmd[1], cmd[1], options.pageId);
    let attrName = 'estEcrasePar';
    let attr = tokenAttribute(perso, attrName);
    if (attr.length === 0) {
      sendPlayer(msg, nomPerso(perso) + " n'est pas \xE9cras\xE9.");
      return;
    }
    attr = attr[0];
    let agrippant = persoOfIdName(attr.get('current'), options.pageId);
    if (agrippant === undefined) {
      error("Attribut " + attrName + " mal form\xE9, on le supprime", attr.get('current'));
      attr.remove();
      unlockToken(perso);
      return;
    }
    let difficulte = 16;
    if (attributeAsBool(agrippant, 'rage')) difficulte += 2;
    let bonus = 0;
    let explications = [];
    if (attributeAsBool(perso, 'protectionContreLeMal') &&
      estMauvais(agrippant)) {
      let bonusProtectionContreLeMal = getValeurOfEffet(perso, 'protectionContreLeMal', 2);
      bonus += bonusProtectionContreLeMal;
      explications.push("Protection contre le mal => +" + bonusProtectionContreLeMal + " au jet pour se lib\xE9rer");
    }
    if (predicateAsBool(perso, 'actionLibre')) {
      bonus += 5;
      explications.push("Action libre => +5 pour r\xE9sister aux entraves");
    }
    let carac = meilleureCarac('FOR', 'DEX', perso, difficulte - bonus);
    if (bonus) options.bonus = bonus;
    let titre = "Tentative de se lib\xE9rer de " + nomPerso(agrippant);
    doLibererEcrase(perso, agrippant, titre, carac, difficulte, explications, options);
  }

  //!cof-liberer-ecrase token_id
  function doLibererEcrase(perso, agrippant, titre, carac, difficulte, explications, options) {
    const evt = {
      type: 'libererEcrase',
      action: {
        titre,
        perso,
        agrippant,
        carac,
        difficulte,
        explications,
        options
      }
    };
    addEvent(evt);
    let playerId = options.playerId;
    let display = startFramedDisplay(playerId, titre, perso, {
      chuchote: options.secret
    });
    const rollId = 'libererEcrase' + perso.token.id;
    testCaracteristique(perso, carac, difficulte, rollId, options, evt,
      function(tr, expl) {
        let smsg = nomPerso(perso) + " fait ";
        expl = expl.concat(explications);
        if (expl.length === 0) {
          smsg += tr.texte;
        } else {
          smsg += '<span title="';
          expl.forEach(function(e, i) {
            if (i > 0) smsg += "&#13;";
            smsg += e;
          });
          smsg += '">' + tr.texte + '</span>';
        }
        if (tr.reussite) {
          smsg += " => r\xE9ussi, " + nomPerso(perso) + " se lib\xE8re.";
          smsg += tr.modifiers;
          addLineToFramedDisplay(display, smsg);
          toFront(perso.token);
          evt.deletedAttributes = evt.deletedAttributes || [];
          let attr = tokenAttribute(perso, 'estEcrasePar');
          attr[0].remove();
          unlockToken(perso, evt);
          evt.deletedAttributes.push(attr[0]);
          attr = tokenAttribute(agrippant, 'ecrase');
          attr.forEach(function(a) {
            let ca = persoOfIdName(a.get('current'));
            if (ca && ca.token.id == perso.token.id) {
              evt.deletedAttributes.push(a);
              a.remove();
              unlockToken(ca, evt);
            }
          });
        } else {
          smsg += " => \xE9chec, " + nomPerso(perso) + " est toujours saisi dans les bras de " + nomPerso(agrippant);
          smsg += tr.rerolls + tr.modifiers;
          addLineToFramedDisplay(display, smsg);
        }
        sendChat('', endFramedDisplay(display));
        if (tr.reussite) turnAction(perso);
      });
  }

  //!cof-animer-cadavre lanceur cible
  function animerCadavre(msg) {
    var options = msg.options || parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-animer-cadavre attend 2 arguments", msg.content);
      return;
    }
    var lanceur = persoOfId(cmd[1], cmd[1], options.pageId);
    if (lanceur === undefined) {
      error("Le premier argument de !cof-animer-cadavre n'est pas un token valide", msg.content);
      return;
    }
    var cible = persoOfId(cmd[2], cmd[2], options.pageId);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-animer-cadavre n'est pas un token valide", msg.content);
      return;
    }
    if (!getState(cible, 'mort')) {
      sendPlayer(msg, nomPerso(cible) + " n'est pas mort" + eForFemale(cible) + ".");
      return;
    }
    if (attributeAsBool(cible, 'cadavreAnime')) {
      sendPlayer(msg, nomPerso(cible) + " a d\xE9j\xE0 \xE9t\xE9 anim\xE9" + eForFemale(cible) + ".");
      return;
    }
    var niveauLanceur = ficheAttributeAsInt(lanceur, 'niveau', 1);
    var niveauCible = ficheAttributeAsInt(cible, 'niveau', 1);
    if (niveauCible > niveauLanceur) {
      sendPlayer(msg, nomPerso(cible) + " est de NC " + niveauCible + ", sup\xE9rieur \xE0 celui de " + nomPerso(lanceur) + " (" + niveauLanceur + ")");
      return;
    }
    var evt = {
      type: "Animer un cadvre"
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'animerUnCadavre', "animer un cadavre", evt)) return;
    sendPerso(lanceur, 'r\xE9anime ' + nomPerso(cible));
    setState(cible, 'mort', false, evt);
    var pvmax = parseInt(cible.token.get("bar1_max"));
    updateCurrentBar(cible, 1, pvmax, evt);
    setTokenAttr(cible, 'cadavreAnime', true, evt, {
      msg: 'se rel\xE8ve'
    });
  }

  var niveauxEbriete = [
    "sobre",
    "pompette",
    "bourr\xE9",
    "ivre-mort",
    "en coma \xE9thylique"
  ];

  function augmenteEbriete(personnage, evt, expliquer) {
    let n = attributeAsInt(personnage, 'niveauEbriete', 0) + 1;
    if (n >= niveauxEbriete.length) {
      expliquer(nomPerso(personnage) + " est d\xE9j\xE0 en coma \xE9thylique.");
      return;
    }
    expliquer(nomPerso(personnage) + " devient " + niveauxEbriete[n]);
    setTokenAttr(personnage, 'niveauEbriete', n, evt);
  }

  function diminueEbriete(personnage, evt, expliquer) {
    let n = attributeAsInt(personnage, 'niveauEbriete', 0);
    if (n < 1) return;
    n--;
    if (n >= niveauxEbriete.length) n = niveauxEbriete.length - 1;
    expliquer(nomPerso(personnage) + " redevient " + niveauxEbriete[n]);
    setTokenAttr(personnage, 'niveauEbriete', n, evt);
  }

  function parseVapeursEthyliques(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cibles = [];
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "pas de cible trouv\xE9e, action annul\xE9e", playerId);
        return;
      }
      iterSelected(selected, function(perso) {
        cibles.push(perso);
      });
      doVapeursEthyliques(playerId, cibles, options);
    }, options); //fin getSelected
  }

  function doVapeursEthyliques(playerId, persos, options) {
    var evt = {
      type: 'vapeursEthyliques',
      action: {
        playerId: playerId,
        persos: persos,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(options.lanceur, options, 'vapeursEthyliques', "lancer une fiole de vapeurs \xE9thyliques", evt)) {
      addEvent(evt);
      return;
    }
    var display = startFramedDisplay(playerId, 'Vapeurs \xE9thyliques');
    var expliquer = function(m) {
      addLineToFramedDisplay(display, m);
    };
    var explications = [];
    if (options.save) {
      explications.push(" Jet de " + options.save.carac + " " + options.save.seuil + " pour r\xE9sister \xE0 l'alcool");
    }
    entrerEnCombat(options.lanceur, persos, explications, evt);
    explications.forEach(explication => expliquer(explications));
    var count = persos.length;
    var finalize = function() {
      if (count == 1) sendChat('', endFramedDisplay(display));
      count--;
    };
    persos.forEach(function(perso) {
      if (options.save) {
        var saveOpts = {
          hideSaveTitle: true,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: 'poison'
        };
        let saveId = 'vapeursEthyliques_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt,
          function(succes, rollText) {
            if (!succes) {
              augmenteEbriete(perso, evt, expliquer);
              setTokenAttr(perso, 'vapeursEthyliques', 0, evt, {
                maxVal: options.save.seuil
              });
            }
            finalize();
          });
      } else { //pas de save
        augmenteEbriete(perso, evt, expliquer);
        setTokenAttr(perso, 'vapeursEthyliques', 0, evt);
        finalize();
      }
    });
  }

  function desaouler(msg) {
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Aucune s\xE9lection pour !cof-desaouler", playerId);
        return;
      }
      var evt = {
        type: 'desao\xFBler'
      };
      var expliquer = function(s) {
        sendChat('', s);
      };
      iterSelected(selected, function(perso) {
        diminueEbriete(perso, evt, expliquer);
      });
      addEvent(evt);
    });
  }

  function parseBoireAlcool(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var persos = [];
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        persos.push(perso);
      });
      doBoireAlcool(playerId, persos, options);
    }, options); //fin getSelected
  }

  function doBoireAlcool(playerId, persos, options) {
    var evt = {
      type: 'boireAlcool',
      action: {
        playerId: playerId,
        persos: persos,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(options.lanceur, options, 'boireAlcool', "est affect\xE9 par l'alcool", evt)) {
      return;
    }
    var display = startFramedDisplay(playerId, 'Alcool');
    var expliquer = function(m) {
      addLineToFramedDisplay(display, m);
    };
    if (options.save) {
      expliquer("Jet de " + options.save.carac + " " + options.save.seuil + " pour r\xE9sister \xE0 l'alcool");
    }
    var count = persos.length;
    var finalize = function() {
      if (count == 1) sendChat('', endFramedDisplay(display));
      count--;
    };
    persos.forEach(function(perso) {
      if (options.save) {
        var saveOpts = {
          hideSaveTitle: true,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: 'poison'
        };
        let saveId = 'boireAlcool_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt,
          function(succes, rollText) {
            if (!succes) {
              augmenteEbriete(perso, evt, expliquer);
            }
            finalize();
          });
      } else { //pas de save
        augmenteEbriete(perso, evt, expliquer);
        finalize();
      }
    });
  }

  function jouerSon(msg) {
    let sonIndex = msg.content.indexOf(' ');
    if (sonIndex > 0) {
      //On joue un son
      let son = msg.content.substring(sonIndex + 1);
      playSound(son);
    } else { //On arr\xEAte tous les sons
      let AMdeclared;
      try {
        AMdeclared = Roll20AM;
      } catch (e) {
        if (e.name != "ReferenceError") throw (e);
      }
      if (AMdeclared) {
        //With Roll20 Audio Master
        sendChat("GM", "!roll20AM --audio,stop|");
      } else {
        let jukebox = findObjs({
          type: 'jukeboxtrack',
          playing: true
        });
        jukebox.forEach(function(track) {
          track.set('playing', false);
        });
      }
    }
  }

  function bonusCouvert(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) return;
    let nouveauBonus = 0;
    if (cmd.length > 1) {
      nouveauBonus = parseInt(cmd[1]);
      if (isNaN(nouveauBonus) || nouveauBonus < 0) {
        error("Il faut un argument positif pour !cof-bonus-couvert", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error('pas de token s\xE9lectionn\xE9 pour !cof-bonus-couvert');
        return;
      }
      var evt = {
        type: 'Bonus couvert'
      };
      addEvent(evt);
      if (limiteRessources(options.lanceur, options, 'bonus couvert', 'bonus couvert', evt)) return;
      iterSelected(selected, function(perso) {
        if (nouveauBonus) {
          setTokenAttr(perso, 'bonusCouvert', nouveauBonus, evt, {
            msg: "se met \xE0 couvert",
            secret: options.secret
          });
        } else {
          removeTokenAttr(perso, 'bonusCouvert', evt, {
            msg: "n'est plus \xE0 couvert",
            secret: options.secret
          });
        }
      }); //fin iterSelected
    }, options); //fin getSelected
  }

  //!cof-set-attribute nom valeur [max]
  function setAttributeInterface(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) return;
    if (cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-set-attribute", cmd);
      return;
    }
    let opt = {
      secret: options.secret
    };
    if (cmd.length > 3) {
      opt.maxVal = cmd[3];
    }
    if (options.messages && options.messages.length > 0)
      opt.msg = options.messages[0];
    getSelected(msg, function(selected, playerId) {
      /*if (!playerIsGM(playerId)) {
        sendChat('COF', "Seul le MJ peut utiliser la commande !cof-set-attributes");
        return;
      }*/
      if (selected.length === 0) {
        error('pas de token s\xE9lectionn\xE9 pour !cof-set-attribute');
        return;
      }
      const evt = {
        type: 'Changement attribut'
      };
      addEvent(evt);
      if (limiteRessources(options.lanceur, options, 'changementAttribut', 'changementAttribut', evt)) return;
      iterSelected(selected, function(perso) {
        setTokenAttr(perso, cmd[1], cmd[2], evt, opt);
        if (options.etats) {
          for (let etat in options.etats) {
            setState(perso, etat, options.etats[etat], evt);
          }
        }
      }); //fin iterSelected
    }, options);
  }

  function setPredicate(perso, predicat, evt) {
    let pred = ficheAttribute(perso, 'predicats_script', '');
    if (pred.includes(predicat)) {
      return;
    }
    if (pred === '') pred = predicat;
    else pred = pred + ' ' + predicat;
    evt = evt || {};
    setFicheAttr(perso, 'predicats_script', pred, evt);
  }

  //!cof-set-predicate nom [valeur]
  function setPredicateInterface(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) return;
    if (cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-set-predicate", cmd);
      return;
    }
    let predicat = cmd[1].trim();
    let set = true;
    if (cmd.length > 2) {
      set = cmd[2];
    }
    let opt = {
      secret: options.secret
    };
    if (options.messages && options.messages.length > 0)
      opt.msg = options.messages[0];
    let predicats = state.COFantasy.predicats;
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error('pas de token s\xE9lectionn\xE9 pour !cof-set-predicate');
        return;
      }
      const evt = {
        type: 'Changement predicat'
      };
      addEvent(evt);
      if (limiteRessources(options.lanceur, options, 'changementPredicat', 'changementPredicat', evt)) return;
      iterSelected(selected, function(perso) {
        let pred = ficheAttribute(perso, 'predicats_script', '');
        switch (set) {
          case 'true':
          case 'vrai':
          case 'oui':
            if (pred.includes(predicat)) {
              sendPlayer(msg, 'Pr\xE9dicat ' + predicat + ' d\xE9j\xE0 pr\xE9sent', playerId);
              return;
            }
            if (pred === '') pred = predicat;
            else pred = pred + ' ' + predicat;
            setFicheAttr(perso, 'predicats_script', pred, evt);
            if (predicats) predicats[perso.charId] = undefined;
            sendPlayer(msg, 'Pr\xE9dicat ' + predicat + ' ajout\xE9', playerId);
            break;
          case 'false':
          case 'faux':
          case 'non':
            let regPred = new RegExp('(^| |,|\n)' + predicat + '($| |,|\n)');
            let newPred = pred.replace(regPred, ' ');
            if (newPred == pred) {
              sendPlayer(msg, 'Pr\xE9dicat ' + predicat + ' non trouv\xE9', playerId);
            } else {
              setFicheAttr(perso, 'predicats_script', newPred, evt);
              if (predicats) predicats[perso.charId] = undefined;
              sendPlayer(msg, 'Pr\xE9dicat ' + predicat + ' enlev\xE9', playerId);
            }
            break;
          default:
            error("L'argument de " + msg.content + " est inutilisable", set);
            return;
        }
        if (options.etats) {
          for (let etat in options.etats) {
            setState(perso, etat, options.etats[etat], evt);
          }
        }
      }); //fin iterSelected
    }, options);
  }

  //!cof-defense-armee-des-morts tokenId
  function defenseArmeeDesMorts(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    if (cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-defense-armee-des-morts", cmd);
      return;
    }
    var perso = persoOfId(cmd[1]);
    if (perso === undefined) {
      error("Le token renseign\xE9 pour !cof-defense-armee-des-morts est inconnu", cmd);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "ne peut pas faire \xE7a.");
      return;
    }
    var evt = {
      type: "DefenseArmeeDesMorts"
    };
    addEvent(evt);
    var opt = {
      msg: "se d\xE9fend contre les morts"
    };
    setTokenAttr(perso, "defenseArmeeDesMorts", true, evt, opt);
  }

  function addLigneOptionAttaque(display, perso, val, texte, attr) {
    var box;
    var action = "!cof-options-d-attaque " + attr + "_check ?{" + texte + "?|";
    if (val) {
      box = '<span style="font-family: \'Pictos\'">3</span>';
      action += "Non|Oui}";
    } else {
      box = ' ';
      action += "Oui|Non}";
    }
    action += " --target " + perso.token.id;
    var ligne = boutonSimple(action, box) + texte;
    addLineToFramedDisplay(display, ligne);
  }

  //!cof-options-d-attaque, affiche les options d'attaque du token s\xE9lectionn\xE9
  // si on donne reset en argument, remet tout \xE0 z\xE9ro
  // si on donne en argument option valeur, change la valeur de l'option
  function optionsDAttaque(msg) {
    const options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) return;
    let evt = {
      type: "Option d'attaque"
    };
    let def0 = {
      default: 0
    };
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        //D'abord on lit les valeurs
        let aepc = ficheAttributeAsBool(perso, 'attaque_en_puissance_check', false);
        let arc = ficheAttributeAsBool(perso, 'attaque_risquee_check', false);
        let aac = ficheAttributeAsBool(perso, 'attaque_assuree_check', false);
        let adtc = ficheAttributeAsBool(perso, 'attaque_dm_temp_check', false);
        let aep = ficheAttributeAsInt(perso, 'attaque_en_puissance', 1);
        let adg;
        if (persoEstPNJ(perso)) {
          adg = ficheAttributeAsInt(perso, 'attaque_de_groupe', 1);
        }
        if (cmd.length > 1 && cmd[1] == 'reset') {
          if (adg > 1) {
            setFicheAttr(perso, 'attaque_de_groupe', 1, evt, {
              default: 1
            });
            adg = 1;
          }
          if (aepc) {
            setFicheAttr(perso, 'attaque_en_puissance_check', 0, evt, def0);
            aepc = false;
          }
          if (arc) {
            setFicheAttr(perso, 'attaque_risquee_check', 0, evt, def0);
            arc = false;
          }
          if (aac) {
            setFicheAttr(perso, 'attaque_assuree_check', 0, evt, def0);
            aac = false;
          }
          if (adtc) {
            setFicheAttr(perso, 'attaque_dm_temp_check', 0, evt, def0);
            adtc = false;
          }
          turnAction(perso, playerId);
          return;
        } else if (cmd.length > 2) {
          switch (cmd[1]) {
            case 'attaque_en_puissance_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!aepc) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  aepc = true;
                  aac = false;
                }
              } else {
                if (aepc) {
                  setFicheAttr(perso, cmd[1], 0, evt, def0);
                  aepc = false;
                }
              }
              break;
            case 'attaque_risquee_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!arc) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  arc = true;
                }
              } else {
                if (arc) {
                  setFicheAttr(perso, cmd[1], 0, evt, def0);
                  arc = false;
                }
              }
              break;
            case 'attaque_assuree_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!aac) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  aac = true;
                  aepc = false;
                }
              } else {
                if (aac) {
                  setFicheAttr(perso, cmd[1], 0, evt, def0);
                  aac = false;
                }
              }
              break;
            case 'attaque_dm_temp_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!adtc) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  adtc = true;
                }
              } else {
                if (adtc) {
                  setFicheAttr(perso, cmd[1], 0, evt, def0);
                  adtc = false;
                }
              }
              break;
            case 'attaque_de_groupe':
              if (persoEstPNJ(perso)) {
                var nadg = parseInt(cmd[2]);
                if (isNaN(nadg) || nadg < 1) nadg = 1;
                if (nadg != adg) {
                  setFicheAttr(perso, cmd[1], nadg, evt, {
                    default: 1
                  });
                  adg = nadg;
                }
              }
              break;
            case 'attaque_en_puissance':
              let naep = parseInt(cmd[2]);
              if (isNaN(naep) || naep < 1) naep = 1;
              if (naep != aep) {
                setFicheAttr(perso, cmd[1], naep, evt, {
                  default: 1
                });
                aep = naep;
              }
              break;
            default:
              error("Argument de !cof-options-d-attaque non reconnu", cmd);
              //Mais on peut quand m\xEAme afficher les options
          }
          turnAction(perso, playerId);
          return;
        }
        var action;
        var title = "Options d'attaque";
        var opt_display = {
          chuchote: true
        };
        if (aepc || arc || aac || adtc || (persoEstPNJ(perso) && adg > 1)) {
          action = "!cof-options-d-attaque reset --target " + perso.token.id;
          opt_display.action_right = boutonSimple(action, 'r\xE9init.');
        }
        var display = startFramedDisplay(playerId, title, perso, opt_display);
        var ligne = '';
        var overlay = '';
        if (persoEstPNJ(perso)) {
          ligne = "Attaque de groupe : ";
          action = "!cof-options-d-attaque attaque_de_groupe ?{Combien d'adversaires par jet?}";
          action += " --target " + perso.token.id;
          overlay = 'title="+2 Att. par cr\xE9ature, si Att > DEF + 5, DM x2, si critique DM x3"';
          ligne += boutonSimple(action, adg, overlay);
          if (adg < 2) {
            ligne += "attaquant";
          } else {
            ligne += "attaquants";
          }
          addLineToFramedDisplay(display, ligne);
        }
        var text;
        action = "!cof-options-d-attaque attaque_en_puissance_check ?{Attaque en puissance?|";
        if (aepc) {
          text = '<span style="font-family: \'Pictos\'">3</span>';
          action += "Non|Oui}";
        } else {
          text = '<span> </span>';
          action += "Oui|Non}";
        }
        action += " --target " + perso.token.id;
        ligne = boutonSimple(action, text) + "Attaque en puissance";
        action = "!cof-options-d-attaque attaque_en_puissance ?{nombre de d\xE9s de bonus (-5 att par d\xE9)?}";
        action += " --target " + perso.token.id;
        ligne += "(+" + boutonSimple(action, aep) + "d";
        if (predicateAsBool(perso, 'tropPetit') && !attributeAsBool(perso, 'grandeTaille')) {
          ligne += "4 DM)";
        } else {
          ligne += "6 DM)";
        }
        addLineToFramedDisplay(display, ligne);
        addLigneOptionAttaque(display, perso, arc, "Attaque risqu\xE9e", 'attaque_risquee');
        addLigneOptionAttaque(display, perso, aac, "Attaque assur\xE9e", 'attaque_assuree');
        addLigneOptionAttaque(display, perso, adtc, "Attaque pour assommer", 'attaque_dm_temp');
        sendChat('', endFramedDisplay(display));
      });
    });
    if (evt.attributes) addEvent(evt);
  }

  //si evt est d\xE9fini, on ajoute les actions \xE0 evt
  function nePlusSuivre(perso, pageId, evt, reutilise) {
    let attrSuit = tokenAttribute(perso, 'suit');
    if (attrSuit.length > 0) {
      attrSuit = attrSuit[0];
      let idSuivi = attrSuit.get('current');
      let suivi = persoOfIdName(idSuivi, pageId);
      if (evt) {
        evt.attributes = evt.attribute || [];
        evt.attributes.push({
          attribute: attrSuit,
          current: idSuivi,
          max: attrSuit.get('max')
        });
      }
      if (!reutilise) attrSuit.remove();
      if (suivi === undefined) {
        sendPerso(perso, "ne suit plus personne");
        return;
      } else {
        sendPerso(perso, "ne suit plus " + nomPerso(suivi));
        let suivantDeSuivi = tokenAttribute(suivi, 'estSuiviPar');
        if (suivantDeSuivi.length > 0) {
          suivantDeSuivi = suivantDeSuivi[0];
          let currentSuivantDeSuivi = suivantDeSuivi.get('current');
          let found;
          let csds = currentSuivantDeSuivi.split(':::').filter(function(idn) {
            if (found) return true;
            let sp = splitIdName(idn);
            if (sp === undefined) return false;
            if (sp.id == perso.token.id) {
              found = true;
              return false;
            }
            if (sp.name == perso.token.get('name')) {
              found = true;
              return false;
            }
            return true;
          });
          if (csds.length === 0) {
            if (evt) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              evt.deletedAttributes.push(suivantDeSuivi);
            }
            suivantDeSuivi.remove();
          } else {
            if (evt) {
              evt.attributes.push({
                attribute: suivantDeSuivi,
                current: currentSuivantDeSuivi
              });
            }
            suivantDeSuivi.set('current', csds.join(':::'));
          }
        }
      }
      return attrSuit;
    }
  }

  //!cof-suivre @{selected|token_id} @{target|token_id}
  function suivre(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) return;
    if (cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-suivre", cmd);
      return;
    }
    let perso = persoOfId(cmd[1], cmd[1], options.pageId);
    if (perso === undefined) {
      error("Token s\xE9lectionne incorrect pour !cof-suivre", cmd);
      return;
    }
    let pageId = perso.token.get('pageid');
    let cible = persoOfId(cmd[2], cmd[2], pageId);
    if (cible === undefined) {
      error("Cible incorrecte pour !cof-suivre", cmd);
      return;
    }
    let evt = {
      type: 'Suivre',
      attributes: []
    };
    //D'abord on arr\xEAte de suivre si on suivait quelqu'un
    let attrSuit = nePlusSuivre(perso, pageId, evt, true);
    let cibleId = idName(cible);
    let attr = tokenAttribute(cible, 'estSuiviPar');
    let suiveurs;
    if (attr.length === 0) {
      attr = setTokenAttr(cible, 'estSuiviPar', '', evt);
      suiveurs = [];
    } else {
      attr = attr[0];
      suiveurs = attr.get('current');
      evt.attributes.push({
        attribute: attr,
        current: suiveurs,
      });
      suiveurs = suiveurs.split(':::');
    }
    let xt = perso.token.get('left');
    let yt = perso.token.get('top');
    let xc = cible.token.get('left');
    let yc = cible.token.get('top');
    let distance = Math.floor(Math.sqrt((xc - xt) * (xc - xt) + (yc - yt) * (yc - yt)));
    if (attrSuit) {
      //alors evt contient d\xE9j\xE0 attrSuit
      attrSuit.set('current', cibleId);
      attrSuit.set('max', distance);
    } else {
      setTokenAttr(perso, 'suit', cibleId, evt, {
        maxVal: distance
      });
    }
    suiveurs.push(idName(perso));
    attr.set('current', suiveurs.join(':::'));
    sendPerso(perso, "suit " + nomPerso(cible));
    addEvent(evt);
  }

  // !cof-centrer-sur-token tid (ou nom de token)
  function centrerSurToken(msg) {
    let cmd = msg.content.split(' ').filter(function(c) {
      return c !== '';
    });
    if (cmd.length < 2) {
      error("Il faut pr\xE9ciser un token sur lequel se centrer", cmd);
      return;
    }
    let playerId = getPlayerIdFromMsg(msg);
    let pageId;
    if (playerIsGM(playerId)) {
      let p = getObj('player', playerId);
      if (p === undefined) {
        error("Impossible de trouver le joueur qui a lanc\xE9 la commande", msg);
        return;
      }
      pageId = p.get('_lastpage');
    } else {
      let c = Campaign();
      let ps = c.get('playerspecificpages');
      if (ps) pageId = ps[playerId];
      if (pageId === undefined) pageId = c.get('playerpageid');
    }
    let indexNom = msg.content.indexOf(' ');
    let nom = msg.content.substring(indexNom).trim();
    let perso = persoOfId(cmd[1], nom, pageId);
    if (perso === undefined) {
      sendPlayer(msg, "Impossible de trouver le personnage sur lequel se centrer", playerId);
      return;
    }
    let token = perso.token;
    sendPing(token.get('left'), token.get('top'), pageId, playerId, true, playerId);
  }

  function afficherRichesse(perso, dest) {
    var msg = '';
    var possede;
    var pp = ficheAttributeAsInt(perso, 'bourse_pp', 0);
    if (pp > 0) {
      msg = pp + " PP";
      possede = true;
    }
    var po = ficheAttributeAsInt(perso, 'bourse_po', 0);
    if (po > 0) {
      if (possede) msg += ', ';
      else possede = true;
      msg += po + " PO";
    }
    var pa = ficheAttributeAsInt(perso, 'bourse_pa', 0);
    if (pa > 0) {
      if (possede) msg += ', ';
      else possede = true;
      msg += pa + " PA";
    }
    var pc = ficheAttributeAsInt(perso, 'bourse_pc', 0);
    if (pc > 0) {
      if (possede) msg += ' et ';
      else possede = true;
      msg += pc + " PC";
    }
    if (possede) msg = 'poss\xE8de ' + msg;
    else msg = "n'a pas d'argent";
    if (dest) sendPlayer(dest, nomPerso(perso) + ' ' + msg);
    else whisperChar(perso.charId, msg);
  }

  function depenserSous(perso, unite, bourse, depense) {
    if (depense <= 0) return 0;
    var retenue = 0;
    if (bourse[unite] < depense) {
      retenue = Math.ceil((depense - bourse[unite]) / 10);
      bourse[unite] += retenue * 10;
    }
    bourse[unite] -= depense;
    return retenue;
  }

  function ajouteLignePieces(perso, display, unite, nom, piece) {
    let finAction = unite + " --target " + perso.token.id;
    let val = ficheAttributeAsInt(perso, 'bourse_' + unite, 0);
    let line = '<table style="width:100%"><tr><td>';
    let action =
      "!cof-bourse fixer ?{Nouveau montant de pi\xE8ces " + piece + " ?} " + finAction;
    line += boutonSimple(action, val) + '<b>' + nom + '</b>';
    line += '</td><td style="text-align: right;">';
    action = "!cof-bourse depenser ?{Pi\xE8ces " + piece + " \xE0 d\xE9penser ?} " + finAction;
    line += boutonSimple(action, 'D\xE9penser');
    action = "!cof-bourse gagner ?{Pi\xE8ces " + piece + "  ?} " + finAction;
    line += boutonSimple(action, 'Gagner');
    line += '</td></tr></table>';
    addLineToFramedDisplay(display, line);
  }

  //!cof-bourse [action]
  //Les actions peuvent \xEAtre depenser val [unite], fixer val unite ou gagner val [unite]
  function gestionBourse(msg) {
    var cmd = msg.content.split(' ').filter(function(c) {
      return c.trim() !== '';
    });
    var action = '';
    var montant;
    var unite = 'pa';
    var depense = {
      pc: 0,
      pa: 0,
      po: 0,
      pp: 0
    };
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'depenser':
        case 'd\xE9penser':
        case 'gagner':
        case 'fixer':
          if (cmd.length < 3) {
            error("Il faut sp\xE9cifier un montant \xE0 " + cmd[1], msg.content);
            return;
          }
          montant = parseInt(cmd[2]);
          if (isNaN(montant)) {
            error("montant " + cmd[2] + " incorrect", cmd);
            return;
          }
          if (cmd[1] == 'gagner') {
            montant = -montant;
            action = 'depenser';
          } else if (cmd[1] == 'fixer') {
            if (montant < 0) {
              error("On ne peut avoir qu'un nombre positif de pi\xE8ces", cmd);
              return;
            }
            action = 'fixer';
          } else action = 'depenser';
          if (cmd.length > 3 && !cmd[3].startsWith('--')) {
            unite = cmd[3].toLowerCase().trim();
            if (unite != 'pp' && unite != 'po' && unite != 'pa' && unite != 'pc') {
              error("Pi\xE8ces non reconnues : " + cmd[3], cmd);
              return;
            }
            depense[unite] = montant;
          } else if (action == 'fixer') {
            error("Il faut pr\xE9ciser les unit\xE9s pour !cof-bourse fixer", msg.content);
            return;
          }
          depense.total = depense.pc + 10 * (depense.pa + 10 * (depense.po + 10 * depense.pp));
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de personnage s\xE9lectionn\xE9 pour !cof-bourse", playerId);
        return;
      }
      var evt = {
        type: 'bourse'
      };
      iterSelected(selected, function(perso) {
        switch (action) {
          case 'depenser':
            var pc = ficheAttributeAsInt(perso, 'bourse_pc', 0);
            var pa = ficheAttributeAsInt(perso, 'bourse_pa', 0);
            var po = ficheAttributeAsInt(perso, 'bourse_po', 0);
            var pp = ficheAttributeAsInt(perso, 'bourse_pp', 0);
            if (depense.total < 0) {
              if (depense.pc < 0) {
                pc -= depense.pc;
                setTokenAttr(perso, 'bourse_pc', pc, evt, {
                  charAttr: true
                });
              }
              if (depense.pa < 0) {
                pa -= depense.pa;
                setTokenAttr(perso, 'bourse_pa', pa, evt, {
                  charAttr: true
                });
              }
              if (depense.po < 0) {
                po -= depense.po;
                setTokenAttr(perso, 'bourse_po', po, evt, {
                  charAttr: true
                });
              }
              if (depense.pp < 0) {
                pp -= depense.pp;
                setTokenAttr(perso, 'bourse_pp', pp, evt, {
                  charAttr: true
                });
              }
              addEvent(evt);
              afficherRichesse(perso);
              return;
            }
            var montantPossede = pc + 10 * (pa + 10 * (po + 10 * pp));
            if (montantPossede < depense.total) {
              sendPerso(perso, "ne poss\xE8de pas assez d'argent pour cette d\xE9pense");
              afficherRichesse(perso, msg);
              return;
            }
            var bourse = {
              pc: pc,
              pa: pa,
              po: po,
              pp: pp
            };
            // On privil\xE9gie les d\xE9penses directes
            var dpp = depense.pp;
            if (dpp <= bourse.pp) {
              bourse.pp -= dpp;
              dpp = 0;
            } else {
              dpp -= bourse.pp;
              bourse.pp = 0;
            }
            var dpo = depense.po;
            if (dpo < bourse.po) {
              bourse.po -= dpo;
              dpo = 0;
            } else {
              dpo -= bourse.po;
              bourse.po = 0;
            }
            var dpa = depense.pa;
            if (dpa <= bourse.pa) {
              bourse.pa -= dpa;
              dpa = 0;
            } else {
              dpa -= bourse.pa;
              bourse.pa = 0;
            }
            var dpc = depense.pc;
            if (dpc < bourse.pc) {
              bourse.pc -= dpc;
              dpc = 0;
            } else {
              dpc -= bourse.pc;
              bourse.pc = 0;
            }
            // Puis on d\xE9pense d'abord la petite monnaie
            var v = dpc + 10 * (dpa + 10 * (dpo + 10 * dpp));
            v = depenserSous(perso, 'pc', bourse, v);
            v = depenserSous(perso, 'pa', bourse, v);
            v = depenserSous(perso, 'po', bourse, v);
            v = depenserSous(perso, 'pp', bourse, v);
            if (v > 0) {
              error("Erreur interne de calcul, il reste " + v + " PP \xE0 d\xE9penser ??", bourse);
              return;
            }
            if (bourse.pc != pc)
              setTokenAttr(perso, 'bourse_pc', bourse.pc, evt, {
                charAttr: true
              });
            if (bourse.pa != pa)
              setTokenAttr(perso, 'bourse_pa', bourse.pa, evt, {
                charAttr: true
              });
            if (bourse.po != po)
              setTokenAttr(perso, 'bourse_po', bourse.po, evt, {
                charAttr: true
              });
            if (bourse.pp != pp)
              setTokenAttr(perso, 'bourse_pp', bourse.pp, evt, {
                charAttr: true
              });
            addEvent(evt);
            afficherRichesse(perso);
            return;
          case 'fixer':
            addEvent(evt);
            setTokenAttr(perso, 'bourse_' + unite, montant, evt, {
              charAttr: true
            });
            afficherRichesse(perso);
            return;
          default:
            if (selected.length > 1) {
              afficherRichesse(perso, msg);
              return;
            }
            let optionsDisplay = {
              chuchote: true,
              image: 'https://www.on6rm.be/wp-content/uploads/2015/08/vignette_2_bourse-argent.png'
            };
            let titre = "Bourse de " + nomPerso(perso);
            let display = startFramedDisplay(playerId, titre, perso, optionsDisplay);
            ajouteLignePieces(perso, display, 'pp', 'Platine', "de platine");
            ajouteLignePieces(perso, display, 'po', 'Or', "d'or");
            ajouteLignePieces(perso, display, 'pa', 'Argent', "d'argent");
            ajouteLignePieces(perso, display, 'pc', 'Cuivre', "de cuivre");
            sendChat('', endFramedDisplay(display));
        }
      });
    });
  }

  //!cof-mot-de-pouvoir-immobilise --lanceur toid
  function motDePouvoirImmobilise(msg) {
    let options = parseOptions(msg);
    let pageId = options.pageId;
    let evt = {
      type: 'Mot de pouvoir'
    };
    addEvent(evt);
    if (options.lanceur) {
      sendPerso(options.lanceur, "prononce un mot avec la Voix d'une puissance sup\xE9rieure. Tous ses ennemis sont immobilis\xE9s et ses alli\xE9s sont galvanis\xE9s.");
      let allies = alliesParPerso[options.lanceur.charId];
      if (allies) {
        let tokens = findObjs({
          _type: 'graphic',
          _subtype: 'token',
          _pageid: pageId,
          layer: 'objects'
        });
        tokens.forEach(function(tok) {
          let ci = tok.get('represents');
          if (ci === '') return;
          if (!allies.has(ci)) return;
          let perso = {
            charId: ci,
            token: tok
          };
          setAttrDuree(perso, 'bonusAttaqueTemp', 1, evt);
        });
      }
    }
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        if (predicateAsBool(perso, 'liberteDAction') ||
          predicateAsBool(perso, 'actionLibre') ||
          (predicateAsInt(perso, 'voieDeLArchange', 1) > 1 && attributeAsBool(perso, 'formeDAnge'))
        ) {
          sendPerso(perso, "reste libre de ses mouvements");
          return;
        }
        setState(perso, 'immobilise', true, evt);
        setAttrDuree(perso, 'immobiliseTemp', 1, evt);
      });
    }, options);
  }

  // Ajoute evt \xE0 l'historique si pr\xE9sent
  // msg n'est pas forc\xE9ment pr\xE9sent
  function nextTurnChargeFantastique(msg, oldTurnOrder) {
    if (oldTurnOrder) Campaign().set('turnorder', oldTurnOrder);
    let cf = stateCOF.chargeFantastique;
    if (cf === undefined) {
      sendChat("Pas de charge fantastique en cours");
      return;
    }
    if (stateCOF.chargeFantastique.activeTokenId && !peutController(msg, persoOfId(stateCOF.chargeFantastique.activeTokenId))) {
      sendPlayer(msg, "ne peut utiliser ce bouton maintenant");
      return;
    }
    let evt = {
      type: "Tour de charge fantastique",
      chargeFantastique: cf
    };
    let tid, perso;
    if (cf.mouvements && cf.mouvements.length > 0) {
      evt.chargeFantastique.mouvements = [...cf.mouvements];
      evt.chargeFantastique.attaques = cf.attaques;
      tid = cf.mouvements.shift();
      perso = persoOfId(tid);
      if (perso === undefined) {
        error("Personnage en charge fantastique manquant", tid);
        return;
      }
      addEvent(evt);
      let playerIds = getPlayerIds(perso);
      let playerId;
      let optionsDisplay = {
        chuchote: 'gm'
      };
      if (playerIds.length > 0) {
        playerId = playerIds[0];
        optionsDisplay.chuchote = true;
      }
      stateCOF.chargeFantastique.activeTokenId = perso.token.id;
      setTokenInitAura(perso);
      var display = startFramedDisplay(playerId, "Charge fantastique", perso, optionsDisplay);
      addLineToFramedDisplay(display, "Phase de mouvement : d\xE9placez votre token en ligne droite");
      addLineToFramedDisplay(display, "puis " + boutonSimple("!cof-next-charge-fantastique", "cliquez ici"));
      sendChat('', endFramedDisplay(display));
      return;
    }
    if (cf.attaques && cf.attaques.length > 0) {
      evt.chargeFantastique.attaques = [...cf.attaques];
      tid = cf.attaques.shift();
      cf.tokenAttaque = tid;
      if (cf.attaques.length === 0) cf.attaques = undefined;
      perso = persoOfId(tid);
      if (perso === undefined) {
        error("Personnage en charge fantastique manquant", tid);
        return;
      }
      addEvent(evt);
      stateCOF.chargeFantastique.activeTokenId = perso.token.id;
      setTokenInitAura(perso);
      turnAction(perso);
      return;
    }
    stateCOF.chargeFantastique = undefined;
  }

  // !cof-charge-fantastique token_id
  function chargeFantastque(msg) {
    var options = parseOptions(msg);
    var cmd = options.cmd;
    if (!cmd || cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-charge-fantastique", cmd);
      return;
    }
    var chevalier = persoOfId(cmd[1], cmd[1], options.pageId);
    if (chevalier === undefined) {
      error("Le token s\xE9lectionn\xE9 ne repr\xE9sente pas un personnage", cmd);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error('pas de token s\xE9lectionn\xE9 pour !cof-charge-fantastique', msg.content);
        return;
      }
      var evt = {
        type: 'Charge fantastique'
      };
      addEvent(evt);
      if (limiteRessources(chevalier, options, 'chargeFantastique', 'charge fantastique', evt)) return;
      sendPerso(chevalier, "m\xE8ne une charge fantastique !");
      initiative(selected, evt);
      stateCOF.chargeFantastique = {};
      var ordreActions = [];
      var chevalierIn;
      iterSelected(selected, function(perso) {
        if (perso.token.id == chevalier.token.id) {
          chevalierIn = true;
          return;
        }
        ordreActions.push({
          init: persoInit(perso, evt),
          perso: perso
        });
      });
      ordreActions.sort(function(p1, p2) {
        if (p1.init < p2.init) return 1;
        if (p1.init > p2.init) return -1;
        // Priorit\xE9 aux joueurs
        // Premier crit\xE8re : la barre de PV des joueurs est li\xE9e
        if (p1.perso.token.get('bar1_link') === '') {
          if (p2.perso.token.get('bar1_link') === '') return 0;
          return 1;
        }
        if (p2.perso.token.get('bar1_link') === '') return -1;
        // Deuxi\xE8me crit\xE8re : les joueurs ont un DV
        let dvA = ficheAttributeAsInt(p1.perso, "DV", 0);
        let dvB = ficheAttributeAsInt(p2.perso, "DV", 0);
        if (dvA === 0) {
          if (dvB === 0) return 0;
          return 1;
        }
        if (dvB === 0) return -1;
        //Entre joueurs, priorit\xE9 \xE0 la plus grosse sagesse
        let sagA = ficheAttributeAsInt(p1.perso, 'sagesse', 10);
        let sagB = ficheAttributeAsInt(p2.perso, 'sagesse', 10);
        if (sagA < sagB) return 1;
        if (sagB > sagA) return -1;
        return 0;
      });
      let mouvements = ordreActions.map(function(p) {
        return p.perso.token.id;
      });
      if (chevalierIn) mouvements.unshift(chevalier.token.id);
      stateCOF.chargeFantastique.mouvements = mouvements;
      stateCOF.chargeFantastique.attaques = [...mouvements];
      nextTurnChargeFantastique();
    }, {
      lanceur: chevalier
    }); //fin du getSelected
  }

  //!cof-prescience token_id
  function utiliserPrescience(msg) {
    let options = parseOptions(msg);
    let cmd = options.cmd;
    if (!cmd || cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-prescience", cmd);
      return;
    }
    let ensorceleur = persoOfId(cmd[1], cmd[1], options.pageId);
    if (ensorceleur === undefined) {
      error("Impossible de trouver le personnage qui utilise prescience", cmd);
      return;
    }
    let combat = stateCOF.combat;
    if (!combat) {
      sendPlayer(msg, "On ne peut utiliser prescience qu'en combat");
      return;
    }
    if (stateCOF.prescience === undefined) {
      error("Pas de sauvegarde disponible pour la prescience", stateCOF);
      return;
    }
    var testPrescience =
      testLimiteUtilisationsCapa(ensorceleur, 'prescience', 'combat',
        "ne peut plus utiliser son pouvoir de prescience pendant ce combat",
        "ne peut pas faire de prescience");
    if (testPrescience === undefined) {
      return;
    }
    //On commence par faire les undo
    var evt = lastEvent();
    if (evt === undefined) {
      error("Impossible d'utiliser la prescience car l'historique est vide", cmd);
      return;
    }
    //Au cas o\xF9, on v\xE9rifie que l'\xE9v\xE9nement de d\xE9but de tour est bien pr\xE9sent
    if (!findEvent(stateCOF.prescience.evt.id)) {
      error("Impossible de trouver le d\xE9but du tour dans l'historique.", stateCOF.prescience);
      return;
    }
    while (evt && evt.id != stateCOF.prescience.evt.id) {
      undoEvent();
      evt = lastEvent();
    }
    //Ensuite on remet les tokens en position
    stateCOF.prescience.dernieresPositions.forEach(function(pos) {
      pos.token.set('left', pos.left);
      pos.token.set('top', pos.top);
    });
    //Et enfin, on diminue les utilisations de prescience et on diminue la mana si possible.
    utiliseCapacite(ensorceleur, testPrescience, {});
    //Pas d'undo possible
    //on cherche si un autre personnage dispose de prescience
    let allToks =
      findObjs({
        _type: 'graphic',
        _pageid: combat.pageId,
        _subtype: 'token',
      });
    let prescienceActif = allToks.find(function(tok) {
      let ci = tok.get('represents');
      if (ci === undefined) return false;
      let perso = {
        token: tok,
        charId: ci
      };
      return capaciteDisponible(perso, 'prescience', 'combat');
    });
    if (!prescienceActif) stateCOF.prescience = undefined;
    if (limiteRessources(ensorceleur, options, 'prescience', "lancer un sort de prescience", {})) return;
    setTokenAttr(ensorceleur, 'prescienceUtilisee', true, {});
    initiative([{
      _id: ensorceleur.token.id
    }], {}, true);
    updateNextInit(ensorceleur);
  }

  //Synchronise les tokens de m\xEAme nom entre les cartes
  function multiCartes(msg) {
    let options = parseOptions(msg);
    let enlever = options && options.cmd && options.cmd.length > 1 &&
      options.cmd[1] == 'false';
    getSelected(msg, function(selected, playerId) {
      let evt = {
        type: "Synchronisation des tokens"
      };
      if (selected.length === 0) {
        if (enlever) {
          removeAllAttributes('tokensSynchronises', evt);
          addEvent(evt);
          return;
        }
        sendPlayer(msg, "Aucun token selectionn\xE9 pour !cof-multi-cartes", playerId);
        return;
      }
      addEvent(evt);
      if (enlever) {
        iterSelected(selected, function(perso) {
          sendPlayer(msg, nomPerso(perso) + " n'est plus synchronis\xE9", playerId);
          removeTokenAttr(perso, 'tokensSynchronises', evt);
        });
        return;
      }
      let allTokens = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        layer: 'objects',
      });
      iterSelected(selected, function(perso) {
        let name = nomPerso(perso);
        let left = perso.token.get('left');
        let top = perso.token.get('top');
        let listTokens = [perso.token.id];
        //On cherche les tokens de m\xEAme nom et on les met en m\xEAme position
        allTokens.forEach(function(tok) {
          if (tok.get('represents') != perso.charId) return;
          if (tok.get('name') != name) return;
          if (tok.id == perso.token.id) return;
          tok.set('left', left);
          tok.set('top', top);
          listTokens.push(tok.id);
        });
        if (listTokens.length < 2) {
          sendPlayer(msg, name + " n'a qu'un seul token sur toutes les cartes", playerId);
          return;
        }
        setTokenAttr(perso, 'tokensSynchronises', listTokens.join(), evt);
      });
    });
  }

  function ombreMouvante(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour !cof-ombre-mouvante", playerId);
        return;
      }
      iterSelected(selected, function(perso) {
        doOmbreMouvante(perso, playerId, options);
      });
    });
  }

  function doOmbreMouvante(voleur, playerId, options) {
    const evt = {
      type: "ombre_mouvante",
      action: {
        perso: voleur,
        playerId,
        options,
      }
    };
    addEvent(evt);
    if (limiteRessources(voleur, options, 'ombreMouvante', 'dispara\xEEtre dans les ombres', evt)) return;
    let optionsDisplay = {
      secret: options.secret
    };
    let display = startFramedDisplay(playerId, 'Ombre mouvante', voleur, optionsDisplay);
    testCaracteristique(voleur, 'DEX', 10, 'ombreMouvante', options, evt,
      function(tr, explications) {
        let msgRes = "<b>R\xE9sultat :</b> " + tr.texte;
        if (tr.reussite) {
          msgRes += ", " + nomPerso(voleur) + " dispara\xEEt dans les ombres";
          addLineToFramedDisplay(display, msgRes + tr.modifiers);
          let ef = {
            effet: 'invisibleTemp',
            duree: true,
            pasDeMessageDActivation: true
          };
          setEffetTemporaire(voleur, ef, 1, evt, {});
          if (options.fx)
            spawnFx(voleur.token.get('left'), voleur.token.get('top'), options.fx, voleur.token.get('pageid'));
        } else {
          msgRes += ", " + nomPerso(voleur) + " ne r\xE9ussit pas \xE0 se fondre dans les ombres.";
          addLineToFramedDisplay(display, msgRes + tr.rerolls + tr.modifiers);
        }
        explications.forEach(function(m) {
          addLineToFramedDisplay(display, m, 80);
        });
        if (options.messages) {
          options.messages.forEach(function(m) {
            addLineToFramedDisplay(display, m);
          });
        }
        if (display.retarde) {
          addFramedHeader(display, playerId, true);
          sendChat('', endFramedDisplay(display));
          addFramedHeader(display, undefined, 'gm');
          sendChat('', endFramedDisplay(display));
        } else sendChat('', endFramedDisplay(display));
      });
  }

  const attributesWithTokNames = new RegExp('^enveloppe($|_)|^enveloppePar($|_)|^agrippe($|_)|^agrippePar($|_)|^devore($|_)|^devorePar($|_)||^ecrase($|_)|^ecrasePar($|_)|^aGobe($|_)|^estGobePar($|_)|^etreinteImmole($|_)|^etreinteImmolePar($|_)|^etreinteScorpion($|_)|^etreinteScorpionPar($|_)|^capitaine($|_)|^suit($|_)|^estSuiviPar($|_)');

  //!cof-reveler-nom [nouveau nom des tokens]
  function revelerNom(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9 pour !cof-reveler-nom", playerId);
        return;
      }
      let nouveauNomToken;
      if (cmd.length > 1) nouveauNomToken = cmd.slice(1).join(' ');
      if (selected.length > 1 && nouveauNomToken) {
        sendPlayer(msg, "Attention, on ne peut s\xE9lectionner qu'un seul token quand on pr\xE9cise le nouveau nom des tokens", playerId);
        return;
      }
      const evt = {
        type: "R\xE9v\xE9lation de nom",
        characterNames: [],
        defaultTokens: [],
        attributes: []
      };
      addEvent(evt);
      let allAttrs = findObjs({
        _type: 'attribute',
      });
      let attrsWithTokNames = allAttrs.filter(function(attr) {
        return attributesWithTokNames.test(attr.get('name'));
      });
      let attrsWithCharNames;
      let treated = new Set(); //On ne veut pas traiter un personnage plus d'une fois.
      iterSelected(selected, function(perso) {
        if (treated.has(perso.charId)) return;
        treated.add(perso.charId);
        let character = getObj('character', perso.charId);
        if (character === undefined) {
          error("Personnage de " + nomPerso(perso) + " perdu", perso);
          return;
        }
        let displayName = ficheAttribute(perso, 'displayname', '@{character_name}');
        let ancienNom;
        let nouveauNom;
        if (displayName == '@{alias}') {
          setFicheAttr(perso, 'displayname', '@{character_name}', evt, {
            default: '@{character_name}'
          });
          ancienNom = ficheAttribute(perso, 'alias', '');
          nouveauNom = character.get('name');
          sendChat('', ancienNom + " \xE9tait en r\xE9alit\xE9 " + nouveauNom + " !");
        } else {
          nouveauNom = ficheAttribute(perso, 'alias', '');
          ancienNom = character.get('name');
          if (nouveauNom === '') {
            sendPlayer(msg, ancienNom + " n'a pas d'alias, rien \xE0 r\xE9v\xE9ler.");
            return;
          }
          setFicheAttr(perso, 'alias', '', evt, {
            default: ''
          });
          sendChar(perso.charId, "\xE9tait en r\xE9alit\xE9 " + nouveauNom + " !");
          evt.characterNames.push({
            character: character,
            name: ancienNom
          });
          character.set('name', nouveauNom);
          //On change aussi les pr\xE9dicats qui stoquent le nom du personnage
          if (attrsWithCharNames === undefined) {
            attrsWithCharNames = allAttrs.filter(function(attr) {
              return attr.get('name') == 'predicats_script';
            });
          }
          attrsWithCharNames.forEach(function(attr) {
            let predicats = attr.get('current');
            let i = predicats.indexOf('PVPartagesAvec::' + ancienNom + '\n');
            if (i < 0) return;
            evt.attributes.push({
              attribute: attr,
              current: predicats
            });
            predicats = predicats.replace('PVPartagesAvec::' + ancienNom + '\n',
              'PVPartagesAvec::' + nouveauNom + '\n',
            );
            attr.set('current', predicats);
          });
        }
        if (!nouveauNomToken) nouveauNomToken = nouveauNom;
        let traitementEnCours;
        character.get('_defaulttoken', function(defaultToken) {
          if (traitementEnCours) return;
          traitementEnCours = true;
          let defaultTokenName;
          let defaultTokenToSet;
          if (defaultToken !== '') {
            defaultToken = JSON.parse(defaultToken);
            evt.defaultTokens.push({
              character: character,
              defaultToken: {...defaultToken
              }
            });
            defaultTokenName = defaultToken.name;
            defaultToken.name = nouveauNomToken;
            defaultTokenToSet = true;
          }
          let tokens =
            findObjs({
              _type: 'graphic',
              _subtype: 'token',
              represents: perso.charId
            });
          tokens.forEach(function(tok) {
            let tokName = tok.get('name');
            if (defaultTokenToSet) {
              defaultTokenToSet = false;
              setDefaultTokenFromSpec(character, defaultToken, tok);
            }
            let tokAttr;
            if (tok.get('bar1_link') === '') {
              if (defaultTokenName) {
                if (tokName.startsWith(defaultTokenName)) {
                  let suffix = tokName.substring(defaultTokenName.length);
                  let localTokName = nouveauNomToken + suffix;
                  setToken(tok, 'name', localTokName, evt);
                  tokAttr = tokAttr || findObjs({
                    _type: 'attribute',
                    _characterid: perso.charId
                  });
                  let endName = "_" + tokName;
                  tokAttr.forEach(function(attr) {
                    let attrName = attr.get('name');
                    if (attrName.endsWith(endName)) {
                      evt.attributes.push({
                        attribute: attr,
                        current: attr.get('current'),
                        name: attrName
                      });
                      var posEnd = attrName.length - tokName.length;
                      attrName = attrName.substring(0, posEnd) + localTokName;
                      attr.set('name', attrName);
                    }
                  });
                  attrsWithTokNames = attrsWithTokNames.filter(function(attr) {
                    let sp = splitIdName(attr.get('current'));
                    if (sp === undefined) return false;
                    if (sp.id == tok.id || sp.name == tokName) {
                      evt.attributes.push({
                        attribute: attr,
                        current: attr.get('current'),
                      });
                      attr.set('current', sp.id + ' ' + localTokName);
                      return false;
                    } else {
                      return true;
                    }
                  });
                } else {
                  sendPlayer(msg, "Pas de renommage de " + tokName, playerId);
                }
              } else {
                sendPlayer(msg, "Pas de token par d\xE9faut pour " + tokName + ", ce n'est pas encore g\xE9r\xE9 dans !cof-reveler-nom", playerId);
              }
            } else {
              if (defaultTokenName && tokName == defaultTokenName) {
                setToken(tok, 'name', nouveauNomToken, evt);
                attrsWithTokNames = attrsWithTokNames.filter(function(attr) {
                  let sp = splitIdName(attr.get('current'));
                  if (sp === undefined) return false;
                  if (sp.id == tok.id || sp.name == tokName) {
                    evt.attributes.push({
                      attribute: attr,
                      current: attr.get('current'),
                    });
                    attr.set('current', sp.id + ' ' + nouveauNomToken);
                    return false;
                  } else {
                    return true;
                  }
                });
              } else {
                sendPlayer(msg, "Pas de renommage de " + tokName, playerId);
              }
            }
          });
        });
      });
    });
  }

  function tenebresMagiques(msg) {
    let cmd = msg.content.split(' ');
    cmd = cmd.filter(function(c) {
      return c.trim() !== '';
    });
    let b = true;
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'true':
        case 'oui':
        case 'noir':
          b = true;
          break;
        case 'non':
        case 'sortir':
        case 'false':
        case 'fin':
          b = false;
          break;
        default:
          error("Option de !cof-tenebres-magiques non reconnue", cmd);
          return;
      }
    }
    if (b) {
      if (stateCOF.tenebresMagiques) {
        sendPlayer('GM', "Les personnages sont d\xE9j\xE0 dans des t\xE9n\xE8bres magiques");
        return;
      }
      sendPlayer('GM', "Les personnages entrent dans des t\xE9n\xE8bres magiques");
      stateCOF.tenebresMagiques = {};
    } else {
      stateCOF.tenebresMagiques = undefined;
      sendPlayer('GM', "Les personnages sortent des t\xE9n\xE8bres magiques");
    }
  }

  function fioleDeLumiere(msg) {
    let cmd = msg.content.split(' ');
    let tm = stateCOF.tenebresMagiques;
    if (tm === undefined) {
      sendPlayer(msg, "Pas de t\xE9n\xE8bres magiques, pas d'effet de fiole");
      return;
    }
    cmd = cmd.filter(function(c) {
      return c.trim() !== '';
    });
    if (cmd.length < 2) {
      error("Il faut un argument \xE0 !cof-fiole-de-lumiere", cmd);
      return;
    }
    var distance = parseInt(cmd[1]);
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Aucun personnage s\xE9lectionn\xE9", cmd);
        return;
      }
      if (selected.length > 1) {
        error("Il n'y a qu'une seule fiole de lumi\xE8re", cmd);
        return;
      }
      var evt = {
        type: 'fioleDeLumiere'
      };
      addEvent(evt);
      iterSelected(selected, function(perso) {
        if (cmd[1] == 'fin' || isNaN(distance) || distance < 0) {
          tm.fioleDeLumiere = undefined;
          let pageId = perso.token.get('pageid');
          eteindreUneLumiere(perso, pageId, undefined, 'fioleDeLumiere', evt);
        } else {
          tm.fioleDeLumiere = {
            porteur: perso,
            distance: distance
          };
          var dimRadius = '';
          if (cmd.length > 3) {
            dimRadius = parseInt(cmd[3]);
            if (isNaN(dimRadius)) {
              error("La distance de vue de la lumi\xE8re assombrie doit \xEAtre un nombre", cmd[3]);
              dimRadius = '';
            }
          }
          ajouteUneLumiere(perso, 'fioleDeLumiere', distance, dimRadius, evt);
        }
      });
    });
  }

  //!cof-agripper-de-demon @{selected|token_id} @{target|token_id}
  function agripperDeDemon(msg) {
    let cmd = msg.content.split(' ');
    cmd = cmd.filter(function(c) {
      return c !== '';
    });
    if (cmd.length < 3) {
      error("Il faut sp\xE9cifier un attaquant et un d\xE9fenseur pour !cof-agripper-de-demon", cmd);
      return;
    }
    let attaquant = persoOfId(cmd[1], cmd[1]);
    let defenseur = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-agripper-de-demon doit \xEAtre un token valide", cmd[1]);
      return;
    }
    if (defenseur === undefined) {
      error("Le deuxi\xE8me argument de !cof-agripper-de-demon doit \xEAtre un token valide", cmd[2]);
      return;
    }
    if (attributeAsBool(defenseur, 'armureDEau')) {
      sendChat("L'armure d'eau emp\xEAche " + nomPerso(defenseur) + " d'\xEAtre aggrip\xE9");
      return;
    }
    const evt = {
      type: "Agripper (d\xE9mon)"
    };
    let options = {
      pasDeDmg: true
    };
    if (cmd.length > 3) options.labelArmeAttaquant = cmd[3];
    const playerId = getPlayerIdFromMsg(msg);
    attaqueContactOpposee(playerId, attaquant, defenseur, evt, options,
      function(res, display, explications) {
        if (res.succes) {
          addLineToFramedDisplay(display, nomPerso(attaquant) + " agrippe fermement " + nomPerso(defenseur));
          setTokenAttr(attaquant, 'agrippe', idName(defenseur), evt);
          setTokenAttr(defenseur, 'estAgrippePar', idName(attaquant), evt);
          setTokenAttr(defenseur, 'agrippeParUnDemon', true, evt);
        } else {
          addLineToFramedDisplay(display, nomPerso(defenseur) + " \xE9chappe \xE0 la tentative de saisie.");
        }
        explications.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
        sendChat("", endFramedDisplay(display));
        addEvent(evt);
      });
  }

  function deleteAttribute(attr, evt) {
    evt.deletedAttributes.push(attr);
    attr.remove();
  }

  function changeAttributeName(attr, nom, evt) {
    evt.attributes.push({
      attribute: attr,
      name: nom
    });
    attr.set('name', nom);
  }

  function ajouteCompetence(perso, comp, carac, val, evt) {
    let prefix = 'repeating_competences_' + generateRowID() + '_comp_';
    let attrSpec = {
      characterid: perso.charId
    };
    attrSpec.name = prefix + 'nom';
    attrSpec.current = comp;
    let attr = createObj('attribute', attrSpec);
    evt.attributes.push({
      attribute: attr
    });
    attrSpec.name = prefix + 'bonus';
    attrSpec.current = val;
    let attrBonus = createObj('attribute', attrSpec);
    evt.attributes.push({
      attribute: attrBonus
    });
    attrSpec.name = prefix + 'bonusTotal';
    attr = createObj('attribute', attrSpec);
    evt.attributes.push({
      attribute: attr
    });
    attrSpec.name = prefix + 'carac';
    attrSpec.current = carac;
    attr = createObj('attribute', attrSpec);
    evt.attributes.push({
      attribute: attr
    });
    if ((carac == 'DEX' && comp != 'crochetage' && comp != 'd\xE9samor\xE7age') ||
      (carac == 'CON' && comp == 'survie') ||
      comp == 'natation' || comp == 'escalade') {
      attrSpec.name = prefix + 'malus';
      attrSpec.current = 'armure';
      attr = createObj('attribute', attrSpec);
      evt.attributes.push({
        attribute: attr
      });
      attrBonus.setWithWorker('current', val);
      attr.setWithWorker('current', 'armure');
    } else if (comp == 'perception' || comp == 'vigilance') {
      attrSpec.name = prefix + 'malus';
      attrSpec.current = 'casque';
      attr = createObj('attribute', attrSpec);
      evt.attributes.push({
        attribute: attr
      });
      attrBonus.setWithWorker('current', val);
      attr.setWithWorker('current', 'casque');
    }
  }

  const regAtkPF1 = new RegExp("^(repeating_npcatk-(melee|ranged|special)_[^_]*_)(.*)$");
  const regAbilitiesPF1 = new RegExp("^(repeating_abilities_[^_]*_)(.*)$");
  const regFeatsPF1 = new RegExp("^(repeating_feats_[^_]*_)(.*)$");

  //Transforme les personnages des tokens de Pathfinder 1 en COF
  //Suppose qu'il s'agit d'un PNJ
  function translateFromPathfinder1(msg) {
    let treatedChars = new Set();
    const optAttr = {
      charAttr: true
    };
    getSelected(msg, function(selected, playerId) {
      let evt = {
        type: 'Tranformation depuis Pathfinder 1',
        deletedAttributes: [],
        attributes: [],
        defaultTokens: []
      };
      addEvent(evt);
      iterSelected(selected, function(perso) {
        if (treatedChars.has(perso.charId)) return;
        treatedChars.add(perso.charId);
        if (!charAttributeAsBool(perso, 'ac')) {
          sendPlayer(msg, nomPerso(perso) + " d\xE9j\xE0 converti (pas d'attribut ac)");
          return;
        }
        let attributes = findObjs({
          _type: 'attribute',
          _characterid: perso.charId,
        });
        setFicheAttr(perso, 'type_personnage', 'PNJ', evt);
        setFicheAttr(perso, 'tab', 'carac. pnj', evt);
        let setAttr = function(nom, valeur) {
          setTokenAttr(perso, nom, valeur, evt, optAttr);
        };
        let attributsIgnores = '';
        let predicats = '';
        let capacites = '';
        let notes = '';
        let equip_div = '';
        let dexterite = 10;
        let mod_dex = 0;
        let init = 0;
        let rd = '';
        let race = '';
        let attaques = {};
        let abilities = {};
        let feats = {};
        let def;
        attributes.forEach(function(attr) {
          let nom = attr.get('name');
          switch (nom) {
            case 'ac':
              def = parseInt(attr.get('current'));
              changeAttributeName(attr, 'pnj_def', evt);
              return;
            case 'class':
              let c = attr.get('current');
              if (c.startsWith('Female ')) {
                setFicheAttr(perso, 'sexe', 'F', evt);
                c = c.substring(7).trim();
                attr.set('current', c);
              } else if (c.startsWith('Male ')) {
                setFicheAttr(perso, 'sexe', 'M', evt);
                c = c.substring(5).trim();
                attr.set('current', c);
              }
              if (c.startsWith('goblin ')) {
                race = "Gobelin";
                c = c.substring(7).trim();
                attr.set('current', c);
              } else if (c.startsWith('human')) {
                race = "Humain";
                c = c.substring(6).trim();
                attr.set('current', c);
              }
              changeAttributeName(attr, 'profil', evt);
              return;
            case 'defensive_abilities':
              {
                let da = attr.get('current');
                let nonPrisEnCompte = '';
                da.split(',').forEach(function(d) {
                  d = d.trim();
                  if (d === '') return;
                  switch (d) {
                    case 'incorporeal':
                      predicats += 'creatureIntangible ';
                      return;
                    case 'uncanny dodge':
                      predicats += 'immunite_surpris ';
                      return;
                    case 'improved uncanny dodge':
                      predicats += 'immuniteAuxSournoises ';
                      return;
                    case 'rejuvenation':
                      return; //Pas d'effet en combat
                    default:
                      if (d.startsWith('channel resistance ')) {
                        let resChannel = parseInt(d.substring(19));
                        if (isNaN(resChannel)) {
                          log("Capacit\xE9 d\xE9fensive " + d + " non connue");
                        } else {
                          predicats += 'bonusSaveContre_positif:' + resChannel + ' ';
                          return;
                        }
                      } else if (d.startsWith('bravery ')) {
                        let courage = parseInt(d.substring(8));
                        if (isNaN(courage)) {
                          log("Capacit\xE9 d\xE9fensive " + d + " non connue");
                        } else {
                          predicats += 'courage:' + courage + ' ';
                          return;
                        }
                      } else {
                        log("Capacit\xE9 d\xE9fensive " + d + " non connue");
                      }
                      if (nonPrisEnCompte === '')
                        nonPrisEnCompte = 'Capacit\xE9s d\xE9fensives : ' + d;
                      else nonPrisEnCompte += ', ' + d;
                  }
                });
                if (nonPrisEnCompte !== '') notes += nonPrisEnCompte + '\n';
                return;
              }
            case 'weaknesses':
              {
                let wea = attr.get('current');
                let nonPrisEnCompte = '';
                wea.split(',').forEach(function(w) {
                  w = w.trim();
                  if (w === '') return;
                  switch (w) {
                    case 'resurrection vulnerability':
                      notes += "D\xE9truit par un sort de r\xE9surection \n";
                      return;
                    case 'vulnerable to acid':
                      predicats += 'vulnerableA_acide ';
                      return;
                    case 'vulnerable to cold':
                      predicats += 'vulnerableA_froid ';
                      return;
                    case 'vulnerable to disease':
                      predicats += 'vulnerableA_maladie ';
                      return;
                    case 'vulnerable to electricity':
                      predicats += 'vulnerableA_electrique ';
                      return;
                    case 'vulnerable to fire':
                      predicats += 'vulnerableA_feu ';
                      return;
                    case 'vulnerable to poison':
                      predicats += 'vulnerableA_poison ';
                      return;
                    default:
                      log("Faiblesse " + w + " non connue");
                      if (nonPrisEnCompte === '')
                        nonPrisEnCompte = 'Faiblesses : ' + w;
                      else nonPrisEnCompte += ', ' + w;
                  }
                });
                if (nonPrisEnCompte !== '') notes += nonPrisEnCompte + '\n';
                return;
              }
            case 'hp':
              changeAttributeName(attr, 'PV', evt);
              return;
            case 'hp_notes':
              let hpNote = attr.get('current');
              if (hpNote.startsWith('fast healing ')) {
                let n = parseInt(hpNote.substring(13));
                if (!isNaN(n) && n > 0) {
                  predicats += 'vitaliteSurnaturelle:' + n + ' ';
                  let index = 13 + ('' + n).length;
                  hpNote = hpNote.substring(index);
                }
              }
              if (hpNote === '') deleteAttribute(attr, evt);
              else attributsIgnores += 'hp_notes : ' + hpNote + ' .\n';
              return;
            case 'immune':
              let immunites = attr.get('current').split(' ');
              let immunitesNonTraitees = '';
              immunites.forEach(function(i) {
                i = i.trim();
                if (i.endsWith(',')) i = i.substring(0, i.length - 1);
                if (i === '') return;
                switch (i) {
                  case 'acid':
                    predicats += 'immunite_acide ';
                    return;
                  case 'cold':
                    predicats += 'immunite_froid ';
                    return;
                  case 'disease':
                    predicats += 'immunite_maladie ';
                    return;
                  case 'death':
                    predicats += 'immunite_mort ';
                    return;
                  case 'electricity':
                    predicats += 'immunite_electrique ';
                    return;
                  case 'fire':
                    predicats += 'immunite_feu ';
                    return;
                  case 'mind-affecting':
                    predicats += 'sansEsprit ';
                    return;
                  case 'paralysis':
                    predicats += 'immunite_paralyse ';
                    return;
                  case 'petrification':
                    predicats += 'immunite_petrification ';
                    return;
                  case 'poison':
                    predicats += 'immunite_poison ';
                    return;
                  case 'construct':
                    predicats += 'sansEsprit creatureArtificielle immuniteSaignement';
                    return;
                  case 'undead':
                  case 'traits':
                  case 'effects':
                  case 'plants':
                    return;
                  default:
                    log("Immunit\xE9 \xE0 " + i + " non trait\xE9e");
                    immunitesNonTraitees += i + ' ';
                }
              });
              if (immunitesNonTraitees !== '') {
                log("Immunit\xE9s non trait\xE9es : " + immunitesNonTraitees);
                attributsIgnores += 'immune : ' + immunitesNonTraitees + '.\n';
              }
              deleteAttribute(attr, evt);
              return;
            case 'resist':
              let resistances = attr.get('current').split(', ');
              let resistancesNonTraitees = '';
              resistances.forEach(function(r) {
                r = r.trim();
                if (r === '') return;
                let res = r.split(' ');
                if (res.length != 2) {
                  resistancesNonTraitees += r + ', ';
                  return;
                }
                let resVal = parseInt(res[1]);
                if (isNaN(resVal) || resVal < 1) {
                  resistancesNonTraitees += r + ', ';
                  return;
                }
                switch (res[0]) {
                  case 'acid':
                    if (rd === '') rd = 'acide:' + resVal;
                    else rd += ', acide:' + resVal;
                    return;
                  case 'cold':
                    if (rd === '') rd = 'froid:' + resVal;
                    else rd += ', froid:' + resVal;
                    return;
                  case 'disease':
                    if (rd === '') rd = 'maladie:' + resVal;
                    else rd += ', maladie:' + resVal;
                    return;
                  case 'electricity':
                    if (rd === '') rd = 'electrique:' + resVal;
                    else rd += ', electrique:' + resVal;
                    return;
                  case 'fire':
                    if (rd === '') rd = 'feu:' + resVal;
                    else rd += ', feu:' + resVal;
                    return;
                  case 'poison':
                    if (rd === '') rd = 'poison:' + resVal;
                    else rd += ', poison:' + resVal;
                    return;
                  default:
                    log("R\xE9sistance \xE0 " + res[0] + " non trait\xE9e");
                    resistancesNonTraitees += r + ', ';
                }
              });
              if (resistancesNonTraitees !== '') {
                log("Resistances non trait\xE9es : " + resistancesNonTraitees);
                attributsIgnores += 'resist : ' + resistancesNonTraitees + '.\n';
              }
              deleteAttribute(attr, evt);
              return;
            case 'initiative':
              init = parseInt(attr.get('current'));
              if (isNaN(init)) init = 0;
              deleteAttribute(attr, evt);
              return;
            case 'languages':
              capacites += 'Langues: ' + attr.get('current') + '\n';
              deleteAttribute(attr, evt);
              return;
            case 'npc_cr':
              changeAttributeName(attr, 'niveau', evt);
              return;
            case 'npc_alignment':
              if (attr.get('current').includes('E')) predicats += 'mauvais ';
              deleteAttribute(attr, evt);
              return;
            case 'npc_dr':
              let rdn = attr.get('current');
              if (rdn) {
                rdn = '' + rdn;
                rdn = rdn.replace('bludgeoning', 'contondant').replace('slashing', 'tranchant').replace('piercing', 'percant').replace('silver', 'argent').replace('magic', 'magique').replace('adamantine', 'adamantium').replace('cold iron', 'ferFroid').replace('/-', '');
                if (rd === '') rd = rdn;
                else rd += ', ' + rdn;
              }
              deleteAttribute(attr, evt);
              return;
            case 'npc_type':
              let npcType = attr.get('current');
              switch (npcType.split(' ')[0]) {
                case 'aberration':
                  predicats += 'aberration ';
                  break;
                case 'humanoid':
                  predicats += 'humanoide ';
                  break;
                case 'animal':
                  predicats += 'animal ';
                  break;
                case 'construct':
                  predicats += 'nonVivant ';
                  break;
                case 'fey':
                  predicats += 'f\xE9e ';
                  break;
                case 'outsider':
                  predicats += 'ext\xE9rieur ';
                  break;
                case 'undead':
                  predicats += 'nonVivant mortVivant ';
                  break;
                case 'vermin':
                case 'Vermin':
                  predicats += 'insecte ';
                  break;
                case 'plant':
                  predicats += 'plante vegetatif ';
                  break;
                default:
                  if (npcType.includes('humanoid')) {
                    predicats += 'humanoide ';
                    break;
                  }
                  log("npc_type non reconnue : " + npcType);
                  if (race === '') race = npcType;
              }
              deleteAttribute(attr, evt);
              return;
            case 'size':
              let taille = '';
              switch (attr.get('current')) {
                case 'fine':
                case 'diminutive':
                  taille = 'minuscule';
                  break;
                case 'tiny':
                  taille = 'tr\xE8s petit';
                  break;
                case 'small':
                  taille = 'petite';
                  break;
                case 'medium':
                  break;
                case 'large':
                  taille = 'grand';
                  break;
                case 'huge':
                  taille = '\xE9norme';
                  break;
                case 'gargantuan':
                case 'colossal':
                  taille = 'colossal';
                  break;
                default:
                  taille = attr.get('current');
              }
              if (taille !== '') setAttr('taille', taille);
              deleteAttribute(attr, evt);
              return;
            case 'tactics':
              let tactics = attr.get('current');
              if (tactics !== '') notes += 'Tactiques : ' + tactics + '\n';
              deleteAttribute(attr, evt);
              return;
            case 'background':
              let background = attr.get('current');
              if (background !== '') notes += 'Background : ' + background + '\n';
              deleteAttribute(attr, evt);
              return;
            case 'treasure':
            case 'combat_gear':
              let gear = attr.get('current');
              if (gear != 'none' && gear !== '') equip_div += gear + '\n';
              deleteAttribute(attr, evt);
              return;
            case 'charisma':
              changeAttributeName(attr, 'charisme', evt);
              return;
            case 'charisma_mod':
              changeAttributeName(attr, 'pnj_cha', evt);
              return;
            case 'constitution':
              return;
            case 'constitution_mod':
              changeAttributeName(attr, 'pnj_con', evt);
              return;
            case 'dexterity':
              dexterite = parseInt(attr.get('current'));
              changeAttributeName(attr, 'dexterite', evt);
              return;
            case 'dexterity_mod':
              mod_dex = parseInt(attr.get('current'));
              changeAttributeName(attr, 'pnj_dex', evt);
              return;
            case 'intelligence':
              return;
            case 'intelligence_mod':
              changeAttributeName(attr, 'pnj_int', evt);
              return;
            case 'strength':
              changeAttributeName(attr, 'force', evt);
              return;
            case 'strength_mod':
              changeAttributeName(attr, 'pnj_for', evt);
              return;
            case 'wisdom':
              changeAttributeName(attr, 'sagesse', evt);
              return;
            case 'wisdom_mod':
              changeAttributeName(attr, 'pnj_sag', evt);
              return;
            case 'acrobatics':
              ajouteCompetence(perso, 'acrobatie', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'appraise':
              ajouteCompetence(perso, 'estimation', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'bluff':
              ajouteCompetence(perso, 'mentir', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'climb':
              ajouteCompetence(perso, 'escalade', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'craft':
              ajouteCompetence(perso, 'artisanat', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'diplomacy':
              ajouteCompetence(perso, 'diplomatie', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'disable_device':
              ajouteCompetence(perso, 'd\xE9samor\xE7age', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'disguise':
              ajouteCompetence(perso, 'd\xE9guisement', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'escape_artist':
              ajouteCompetence(perso, '\xE9vasion', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'fly':
              ajouteCompetence(perso, 'vol', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'handle_animal':
              ajouteCompetence(perso, 'dressage', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'heal':
              ajouteCompetence(perso, 'soigner', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'intimidate':
              ajouteCompetence(perso, 'intimidation', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_arcana':
              ajouteCompetence(perso, 'connaissance (arcanes)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_dungeoneering':
              ajouteCompetence(perso, 'connaissance (donjons)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_engineering':
              ajouteCompetence(perso, 'connaissance (ing\xE9ni\xE9rie)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_geography':
              ajouteCompetence(perso, 'connaissance (g\xE9ographie)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_history':
              ajouteCompetence(perso, 'connaissance (histoire)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_local':
              ajouteCompetence(perso, 'connaissance (local)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_nature':
              ajouteCompetence(perso, 'connaissance (nature)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_nobility':
              ajouteCompetence(perso, 'connaissance (noblesse)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_planes':
              ajouteCompetence(perso, 'connaissance (plans)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'knowledge_religion':
              ajouteCompetence(perso, 'connaissance (religion)', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'linguistics':
              ajouteCompetence(perso, 'linguistique', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'perception':
              ajouteCompetence(perso, 'perception', 'SAG', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'perform':
              ajouteCompetence(perso, 'arts', 'CHA', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'profession':
              ajouteCompetence(perso, 'profession', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'ride':
              ajouteCompetence(perso, '\xC9quitation', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'sense_motive':
              ajouteCompetence(perso, 'psychologie', 'SAG', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'sleight_of_hand':
              ajouteCompetence(perso, 'pick-pocket', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'spellcraft':
              ajouteCompetence(perso, 'sortil\xE8ges', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'stealth':
              ajouteCompetence(perso, 'discr\xE9tion', 'DEX', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'survival':
              ajouteCompetence(perso, 'survie', 'SAG', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'swim':
              ajouteCompetence(perso, 'natation', 'FOR', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
              //Attributs de toutes facons modifi\xE9s:
            case 'tab':
            case 'type_personnage':
              return;
            case 'use_magic_device':
              ajouteCompetence(perso, 'objets magiques', 'INT', attr.get('current'), evt);
              deleteAttribute(attr, evt);
              return;
            case 'version':
              evt.attributes.push({
                attribute: attr,
                current: versionFiche
              });
              attr.set('current', versionFiche);
              return;
            case 'whispertype':
              if (attr.get('current') == '/w gm') {
                changeAttributeName(attr, 'jets_caches', evt);
              } else {
                deleteAttribute(attr, evt);
              }
              return;
            case 'scriptVersion':
            case 'bab':
            case 'environment':
            case 'skills_racial_modifiers':
            case 'fortitude':
            case 'reflex':
            case 'will': //On n'y touche pas pour l'instant. \xC0 voir plus tard
              let x = attr.get('current');
              if (x === undefined || x === '') deleteAttribute(attr, evt);
              return;
            case 'ac_ability_primary':
            case 'ac_ability_maximum':
            case 'ac_flatfooted':
            case 'ac_notes':
            case 'ac_touch':
            case 'alignment':
            case 'ask_modifier':
            case 'ask_atk_modifier':
            case 'ask_dmg_modifier':
            case 'ask_whisper':
            case 'ask_public_roll':
            case 'ask_whisper_roll':
            case 'bab_multi':
            case 'caster1_dc_level_0':
            case 'class_favored':
            case 'class1_level':
            case 'cmb_mod':
            case 'cmd_mod':
            case 'encumbrance':
            case 'encumbrance_ability_maximum':
            case 'encumbrance_drag_push':
            case 'encumbrance_lift_head':
            case 'encumbrance_lift_ground':
            case 'encumbrance_load_light':
            case 'encumbrance_load_medium':
            case 'encumbrance_load_heavy':
            case 'encumbrance_run_factor':
            case 'encumbrance_size':
            case 'fob_multi':
            case 'hd':
            case 'hd_roll':
            case 'level':
            case 'npc':
            case 'npc_speed':
            case 'npcdrop_name':
            case 'npcdrop_category':
            case 'npcdrop_data':
            case 'options-flag-npc':
            case 'build-flag-npc':
            case 'npc_fromcompendium':
            case 'armor_spell_failure':
            case 'npc_icon_climate':
            case 'npc_icon_terrain':
            case 'npc_icon_type':
            case 'npc_expansion':
            case 'npc_xp':
            case 'organization':
            case 'senses':
            case 'size_display':
            case 'space':
            case 'speed':
            case 'spell_flag':
            case 'spellabilities_flag':
            case 'sq':
            case 'xp':
            case 'l1mancer_status': //Attributs ignor\xE9s
              deleteAttribute(attr, evt);
              return;
            default:
              if (nom.endsWith('_display') || nom.endsWith('_flag') ||
                nom.endsWith('half_mod')) {
                deleteAttribute(attr, evt);
                return;
              }
              let m = regAtkPF1.exec(nom);
              if (m) {
                attaques[m[1]] = attaques[m[1]] || {};
                attaques[m[1]][m[3]] = attr.get('current');
                deleteAttribute(attr, evt);
                return;
              }
              m = regAbilitiesPF1.exec(nom);
              if (m) {
                abilities[m[1]] = abilities[m[1]] || {};
                abilities[m[1]][m[2]] = attr.get('current');
                deleteAttribute(attr, evt);
                return;
              }
              m = regFeatsPF1.exec(nom);
              if (m) {
                feats[m[1]] = feats[m[1]] || {};
                feats[m[1]][m[2]] = attr.get('current');
                deleteAttribute(attr, evt);
                return;
              }
              let v = attr.get('current');
              if (v && ('' + v).trim() !== '') {
                attributsIgnores += nom + ' : ' + v;
                let max = attr.get('max');
                if (max) attributsIgnores += ' , ' + max;
                attributsIgnores += ' .\n';
              }
              deleteAttribute(attr, evt);
          }
        });
        let maxAttackLabel = 0;
        for (let pref in attaques) {
          let attaque = attaques[pref];
          log(attaque);
          let nomAttaque = attaque.atkname || 'Attaque';
          if (nomAttaque.startsWith('favored enemy ')) {
            let i = nomAttaque.indexOf('(');
            let j = nomAttaque.indexOf(')');
            if (i < 1 || i > j) {
              notes += nomAttaque + '\n';
            } else {
              let ennemis = nomAttaque.substring(i + 1, j).split(' ');
              let ennemiJure = '';
              let pasDEnnemi = true;
              for (let e of ennemis) {
                e = e.trim();
                if (e === '') continue;
                switch (e) {
                  case 'goblinoids':
                    if (pasDEnnemi) {
                      ennemiJure = 'gobelin';
                      pasDEnnemi = false;
                    } else ennemiJure += ', gobelin';
                    break;
                  case 'elves':
                    if (pasDEnnemi) {
                      ennemiJure = 'elfe';
                      pasDEnnemi = false;
                    } else ennemiJure += ', elfe';
                    break;
                  case 'dragons':
                    if (pasDEnnemi) {
                      ennemiJure = 'dragon';
                      pasDEnnemi = false;
                    } else ennemiJure += ', dragon';
                    break;
                  case 'giants':
                    if (pasDEnnemi) {
                      ennemiJure = 'geant';
                      pasDEnnemi = false;
                    } else ennemiJure += ', geant';
                    break;
                  case 'humans':
                    if (pasDEnnemi) {
                      ennemiJure = 'humain';
                      pasDEnnemi = false;
                    } else ennemiJure += ', humain';
                    break;
                  default:
                    if (!e.startsWith('+')) {
                      log("Ennemi jur\xE9 non reconnu : " + e);
                    }
                }
              }
              if (ennemiJure !== '')
                predicats += 'ennemiJure::' + ennemiJure + '\n';
              else notes += nomAttaque + '\n';
            }
            continue;
          } else if (nomAttaque.startsWith("weapon training (")) {
            continue;
          }
          let prefix = 'repeating_pnjatk_' + generateRowID() + '_arme';
          createObj('attribute', {
            _characterid: perso.charId,
            name: prefix + 'nom',
            current: nomAttaque
          });
          let spec = '';
          let options = '';
          for (let field in attaque) {
            switch (field) {
              case 'atkmod':
                createObj('attribute', {
                  _characterid: perso.charId,
                  name: prefix + 'atk',
                  current: attaque.atkmod
                });
                break;
              case 'atkcritrange':
                createObj('attribute', {
                  _characterid: perso.charId,
                  name: prefix + 'crit',
                  current: attaque.atkcritrange
                });
                break;
              case 'dmgbase':
                let dm = parseDice(attaque.dmgbase, 'd\xE9g\xE2ts');
                if (dm) {
                  if (dm.nbDe)
                    createObj('attribute', {
                      _characterid: perso.charId,
                      name: prefix + 'dmnbde',
                      current: dm.nbDe
                    });
                  if (dm.dice != 4)
                    createObj('attribute', {
                      _characterid: perso.charId,
                      name: prefix + 'dmde',
                      current: dm.dice
                    });
                  if (dm.bonus)
                    createObj('attribute', {
                      _characterid: perso.charId,
                      name: prefix + 'dm',
                      current: dm.bonus
                    });
                }
                break;
              case 'dmgtype':
                let types = attaque.dmgtype.split('; ');
                let typeInconnu = true;
                for (let t of types) {
                  switch (t) {
                    case 'piercing':
                      if (typeInconnu) {
                        createObj('attribute', {
                          _characterid: perso.charId,
                          name: prefix + 'typedegats',
                          current: 'percant'
                        });
                        typeInconnu = false;
                      }
                      break;
                    case 'bludgeoning':
                      if (typeInconnu) {
                        createObj('attribute', {
                          _characterid: perso.charId,
                          name: prefix + 'typedegats',
                          current: 'contondant'
                        });
                        typeInconnu = false;
                      }
                      break;
                    case 'slashing':
                      typeInconnu = false;
                      break;
                    default:
                      spec += t + ' ';
                  }
                }
                break;
              case 'atkrange':
                let range = parseInt(attaque.atkrange);
                if (isNaN(range) || range < 0) range = 1;
                else range = Math.floor(range / 2);
                createObj('attribute', {
                  _characterid: perso.charId,
                  name: prefix + 'portee',
                  current: range
                });
                break;
              case 'dmgcritmulti':
                let cm = parseInt(attaque.dmgcritmulti);
                if (!isNaN(cm) && cm > 2) {
                  options += '--incrCritCoef ' + (cm - 2) + ' ';
                }
                break;
              case 'atkname': //d\xE9j\xE0 trait\xE9 plus haut
              case 'options-flag':
              case 'dmgflag':
              case 'dmg2type':
              case 'atkdisplay':
              case 'multipleatk':
              case 'atkmod2':
                break;
              default:
                spec += field + ' : ' + attaque[field];
            }
          }
          if (spec)
            createObj('attribute', {
              _characterid: perso.charId,
              name: prefix + 'spec',
              current: spec
            });
          if (options)
            createObj('attribute', {
              _characterid: perso.charId,
              name: prefix + 'options',
              current: options
            });
          createObj('attribute', {
            _characterid: perso.charId,
            name: prefix + 'optflag',
            current: 'on'
          });
          maxAttackLabel++;
          createObj('attribute', {
            _characterid: perso.charId,
            name: prefix + 'label',
            current: maxAttackLabel
          });
        }
        for (let pref in abilities) {
          let ab = abilities[pref];
          if (ab.name) notes += ab.name + ' : ';
          if (ab.description) notes += ab.description + '\n';
        }
        for (let pref in feats) {
          let feat = feats[pref];
          switch (feat.name) {
            case undefined:
              continue;
            case 'Improved Initiative':
            case 'Toughness':
            case 'Weapon Finesse':
            case 'Dodge':
            case 'Combat Casting':
            case 'Brew Potion':
              continue;
            case 'Defect Arrows':
              predicats += 'paradeDeProjectiles ';
              break;
            case 'Point-Blank Shot':
              predicats += 'tirPrecis:1 ';
              break;
            case 'Iron Will':
              predicats += 'bonusSagesseMagie:2 ';
              break;
            default:
              if (feat.name.startsWith('Weapon Focus (')) continue;
              if (feat.name.startsWith('Weapon Specialization (')) continue;
              notes += feat.name + ' : ';
              if (feat.benefits) notes += feat.benefits + '\n';
              else if (feat.description) notes += feat.description + '\n';
              attributsIgnores += 'Feat ' + feat.name + ' : {';
              for (let field in feat) {
                if (field == 'name') continue;
                attributsIgnores += ' ' + field + ' : ' + feat[field] + ',';
              }
              attributsIgnores += '} .\n';
          }
        }
        if (maxAttackLabel > 0) setAttr('max_attack_label', maxAttackLabel);
        //Puis on met les attributs n\xE9cessaires
        if (attributsIgnores !== '')
          setAttr('Attributs Pathfinder', attributsIgnores);
        if (predicats !== '') setAttr('predicats_script', predicats);
        if (capacites !== '') setAttr('capacites_pnj', capacites);
        if (notes !== '') setAttr('notes', notes);
        if (equip_div !== '') setAttr('equip_div', equip_div);
        if (rd !== '') setAttr('RDS', rd);
        if (race !== '') setAttr('race', race);
        setTokenAttr(perso, 'scriptVersion', 'true', evt, {
          charAttr: true,
          maxVal: stateCOF.version
        });
        let initiative = dexterite + init - mod_dex;
        if (isNaN(initiative)) initiative = 10 + 2 * init;
        setAttr('pnj_init', initiative);
        // N\xE9cessaire pour \xE9viter que les sheetworkers re-calculent init et def
        if (initiative != dexterite) setAttr('INIT_DIV', initiative - dexterite);
        if (def != 10 + mod_dex) setAttr('DEFDIV', def - 10 - mod_dex);
        //Finalement, on change le token par d\xE9faut
        let acAttr = perso.token.get('bar2_link');
        affectToken(perso.token, 'bar2_link', acAttr, evt);
        perso.token.set('bar2_link', '');
        let ac = perso.token.get('bar2_value');
        affectToken(perso.token, 'bar2_value', ac, evt);
        perso.token.set('bar2_value', '');
        let character = getObj('character', perso.charId);
        if (character) {
          let defaultToken = JSON.parse(JSON.stringify(perso.token));
          evt.defaultTokens.push({
            character: character,
            defaultToken: defaultToken
          });
          setDefaultTokenForCharacter(character, perso.token);
          sendChat('COFantasy', "/w gm traduction de " + character.get('name') + " vers COF");
        } else {
          sendChat('COFantasy', "/w gm traduction de " + nomPerso(perso) + " vers COF, mais personnage introuvable");
        }
      });
    });
  }

  function canalisationParPM(expr, deParPM, phylactere, options) {
    let res = expr;
    let indexPM = expr.indexOf('pm');
    if (indexPM > 0) {
      let nbPMs = parseInt(expr.substring(0, indexPM));
      if (!isNaN(nbPMs) || nbPMs > 0) {
        if (nbPMs == 1) {
          options.mana = options.mana || 0;
          options.mana++;
          res = deParPM;
          if (phylactere) res += '+ ' + phylactere;
        } else {
          let de = parseDice(deParPM);
          if (de) {
            res = '';
            if (de.nbDe) {
              options.mana = options.mana || 0;
              options.mana += nbPMs;
              res = (nbPMs * de.nbDe) + 'd' + de.dice;
              if (de.bonus) res += '+ ';
            }
            if (de.bonus) res += (nbPMs * de.bonus);
            if (phylactere) {
              let dp = parseDice(phylactere);
              if (dp) {
                if (dp.nbDe) {
                  res += '+ ' + (nbPMs * dp.nbDe) + 'd' + dp.dice;
                }
                if (dp.bonus) res += '+ ' + (nbPMs * dp.bonus);
              }
            }
          }
        }
      }
    }
    return res;
  }

  //!cof-canaliser [positif|negatif] --soin expr --dm expr
  function canaliser(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Il manque le type de canalisation", msg.content);
      return;
    }
    let positif = true;
    if (cmd[1] === 'false' || cmd[1] === 'negatif' || cmd[1] === 'n\xE9gatif')
      positif = false;
    if (options.soin === undefined && options.dm === undefined) {
      sendPlayer(msg, "Rien \xE0 canaliser. Il faut pr\xE9ciser un montant de soins ou de d\xE9g\xE2ts");
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length != 1) {
        sendPlayer(msg, "Il faut s\xE9lectionner un personnage", playerId);
        return;
      }
      let token = getObj('graphic', selected[0]._id);
      if (token === undefined) {
        error("Token non reconnu", selected);
        return;
      }
      let charId = token.get('represents');
      if (charId === undefined || charId === '') {
        error("Le token ne repr\xE9sente pas un personnage", token);
        return;
      }
      let pretre = {
        token: token,
        charId: charId
      };
      let evt = {
        type: 'canalisation'
      };
      addEvent(evt);
      //Conversion des #n pm en soins et dm
      let deParPM = predicateAsBool(pretre, 'deCanalisation');
      if (deParPM) {
        let phylactere;
        if (positif) phylactere = predicateAsBool(pretre, 'phylacterePositif');
        else phylactere = predicateAsBool(pretre, 'phylactereNegatif');
        if (options.soin) {
          options.soin = canalisationParPM(options.soin, deParPM, phylactere, options);
        }
        if (options.dm) {
          options.dm = canalisationParPM(options.dm, deParPM, phylactere, options);
        }
      }
      if (limiteRessources(pretre, options, 'canalisation', 'canalisation', evt)) {
        return;
      }
      let display = startFramedDisplay(playerId, "Canalisation", pretre);
      let pageId = token.get('pageid');
      let page = getObj('page', pageId);
      let murs = getWalls(page, pageId);
      let pc;
      if (murs) {
        pc = {
          x: token.get('left'),
          y: token.get('top')
        };
      }
      let allToks =
        findObjs({
          _type: "graphic",
          _pageid: pageId,
          _subtype: 'token',
          layer: 'objects'
        });
      let cibles = [];
      allToks.forEach(function(obj) {
        let objCharId = obj.get('represents');
        if (objCharId === '') return;
        if (obj.get('bar1_max') == 0) return; // jshint ignore:line
        let cible = {
          token: obj,
          charId: objCharId
        };
        if (getState(cible, 'mort')) return; //pas d'effet aux morts
        let objChar = getObj('character', objCharId);
        if (objChar === undefined) return;
        let distance = distanceCombat(token, obj, pageId, {
          strict1: true
        });
        if (distance > 10) return;
        if (murs) {
          if (obstaclePresent(obj.get('left'), obj.get('top'), pc, murs)) return;
        }
        cibles.push(cible);
      });
      cibles = enleveDoublonsPartagePV(cibles);
      let nbCibles = cibles.length;
      if (options.soin && options.dm) nbCibles += nbCibles;
      let ciblesAttaquees = [];
      let sync = function() {
        nbCibles--;
        if (nbCibles < 1) {
          if (ciblesAttaquees.length > 0) {
            let explications = [];
            entrerEnCombat(pretre, ciblesAttaquees, explications, evt);
            explications.forEach(function(e) {
              addLineToFramedDisplay(display, e);
            });
          }
          sendChat('', endFramedDisplay(display));
        }
      };
      if (options.soin) {
        let soins = '[[' + options.soin + ']]';
        cibles.forEach(function(target) {
          if (estMortVivant(target) == positif) {
            sync();
            return;
          }
          try {
            sendChat('', soins, function(res) {
              let soins = res[0].inlinerolls[0].results.total;
              let soinTxt = buildinline(res[0].inlinerolls[0], 'normal', true);
              if (soins <= 0) {
                sendPerso(pretre, "ne r\xE9ussit pas \xE0 soigner (total de soins " + soinTxt + ")", true);
                sync();
                return;
              }
              //TODO: tenir compte des PV partag\xE9s
              soigneToken(target, soins, evt,
                function(soinsEffectifs) {
                  let line = "<b>" + nomPerso(target) + "</b> : + ";
                  if (soinsEffectifs == soins) {
                    line += soinTxt + 'PV';
                  } else {
                    line += soinsEffectifs + 'PV (jet: ' + soinTxt + ')';
                  }
                  addLineToFramedDisplay(display, line);
                  sync();
                },
                function() {
                  addLineToFramedDisplay(display, "<b>" + nomPerso(target) + "</b> : pas besoin de soins.");
                  sync();
                }, options);
            });
          } catch (rollError) {
            error("Jet " + options.soin + " mal form\xE9", options);
          }
        });
      }
      if (options.dm) {
        parseDmgOptions(msg.content, options);
        let dm = '[[' + options.dm + ']]';
        if (options.maxDmg) {
          dm = dm.replace(/d([1-9])/g, "*$1");
        }
        let dmgType = options.type || 'magique';
        options.energiePositive = positif;
        cibles.forEach(function(target) {
          if (target.token.id == pretre.token.id ||
            estMortVivant(target) != positif) {
            sync();
            return;
          }
          ciblesAttaquees.push(target);
          try {
            sendChat('', dm, function(res) {
              let dmg = {
                type: dmgType,
                value: options.dm,
                roll: res[0],
              };
              let afterEvaluateDmg = dmg.roll.content.split(' ');
              let dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
              dmg.total = dmg.roll.inlinerolls[dmgRollNumber].results.total;
              dmg.display = buildinline(dmg.roll.inlinerolls[dmgRollNumber], dmg.type, options.magique);
              let explications = [];
              copyDmgOptionsToTarget(target, options);
              dealDamage(target, dmg, [], evt, false, options, explications, function(dmgDisplay, dmgFinal) {
                addLineToFramedDisplay(display,
                  nomPerso(target) + " re\xE7oit " + dmgDisplay + " DM");
                explications.forEach(function(e) {
                  addLineToFramedDisplay(display, e, 80, false);
                });
                sync();
              });
            });
          } catch (rollError) {
            error("Jet " + options.dm + " mal form\xE9", dm);
          }
        });
      }
    });
  }

  const objetsAnimes = {
    1: {
      token: "https://s3.amazonaws.com/files.d20.io/images/250177368/mJsYWMFqDeEmJDJy8tJKWA/thumb.png?1634130296",
      avatar: "https://s3.amazonaws.com/files.d20.io/images/250177753/IMzDqEpNpuznVnAMYRil8A/max.jpg?1634130507",
      taille: 'tr\xE8s petite',
      force: 4,
      pnj_for: -3,
      constitution: 4,
      pnj_con: -3,
      pnj_def: 10,
      pv: 4,
      dmnbde: 0,
      dmde: 4,
      dm: 1,
    },
    2: {
      token: "https://s3.amazonaws.com/files.d20.io/images/250179877/-j9v1JoPrX7StcH0jGTtMQ/thumb.png?1634132408",
      avatar: "https://s3.amazonaws.com/files.d20.io/images/250179870/ana7iPnNx6lgPLRtSmBzXA/max.jpg?1634132399",
      taille: 'petite',
      force: 6,
      pnj_for: -2,
      constitution: 6,
      pnj_con: -2,
      pnj_def: 10,
      pv: 8,
      dmnbde: 1,
      dmde: 4,
      dm: 0,
    },
    4: {
      token: "https://s3.amazonaws.com/files.d20.io/images/250181751/L0JdDzCXjJnOlbUPJufU7A/thumb.png?1634133729",
      avatar: "https://s3.amazonaws.com/files.d20.io/images/250181765/aELyP7xCTkSddnD6-8Kllw/max.jpg?1634133738",
      taille: 'moyenne',
      force: 10,
      pnj_for: 0,
      constitution: 10,
      pnj_con: 0,
      pnj_def: 12,
      pv: 15,
      dmnbde: 1,
      dmde: 6,
      dm: 0,
    },
    7: {
      token: "https://s3.amazonaws.com/files.d20.io/images/250303501/Kj38iSV6T0BIZMhGm74xqA/thumb.png?1634197833",
      avatar: "https://s3.amazonaws.com/files.d20.io/images/250303491/pzSiwMs-tZqTiluuFIz8tA/max.jpg?1634197823",
      taille: 'moyenne',
      force: 16,
      pnj_for: 3,
      constitution: 16,
      pnj_con: 3,
      pnj_def: 14,
      pv: 30,
      dmnbde: 1,
      dmde: 6,
      dm: 3,
    },
    10: {
      token: "https://s3.amazonaws.com/files.d20.io/images/250303495/k0LqXjurwtySR-aZQjsI1Q/thumb.png?1634197828",
      avatar: "https://s3.amazonaws.com/files.d20.io/images/250303482/COH6jsSUovSjVQfvbjU51Q/max.jpg?1634197812",
      taille: 'grande',
      force: 22,
      pnj_for: 6,
      constitution: 22,
      pnj_con: 6,
      pnj_def: 16,
      pv: 50,
      dmnbde: 2,
      dmde: 6,
      dm: 6,
    }
  };

  //!cof-animation-des-objets lid niveau [tid]
  // la cible optionelle correspond \xE0 un token existant non associ\xE9 \xE0 un personnage
  function animationDesObjets(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("Usage : !cof-animation-des-objets @{selected|token_id} niveau", msg.content);
      return;
    }
    let lanceur = persoOfId(cmd[1], cmd[1], options.pageId);
    if (lanceur === undefined) {
      error("Token incorrect", cmd);
      return;
    }
    let niveauObjet = parseInt(cmd[2]);
    if (isNaN(niveauObjet) || niveauObjet < 1) {
      error("Le niveau de l'objet anim\xE9 doit \xEAtre un nombre positif", cmd);
      return;
    }
    if (niveauObjet > 10) niveauObjet = 10;
    let stats = objetsAnimes[niveauObjet];
    while (stats === undefined) {
      niveauObjet--;
      stats = objetsAnimes[niveauObjet];
    }
    let niveau = ficheAttributeAsInt(lanceur, 'niveau', 1);
    let dejaAnime = attributeAsInt(lanceur, 'niveauDesObjetsAnimes', 0);
    let playerId = getPlayerIdFromMsg(msg);
    if (dejaAnime + niveauObjet > niveau) {
      sendPlayer(msg, "Impossible d'animer plus d'objets pour le moment : somme des niveau anim\xE9s = " + dejaAnime, playerId);
      return;
    }
    let evt = {
      type: "Animation d'objet",
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'animationObjet', "animation d'un objet", evt)) return;
    let tokenSize = 70;
    switch (stats.taille) {
      case 'tr\xE8s petite':
        tokenSize = 35;
        break;
      case 'petite':
        tokenSize = 50;
        break;
      case 'grande':
        tokenSize = 105;
        break;
    }
    let tokenObjet;
    let aPartirDExistant;
    if (cmd.length > 3) {
      tokenObjet = getObj('graphic', cmd[3]);
      aPartirDExistant = (tokenObjet !== undefined);
    }
    let pageId = lanceur.token.get('pageid');
    tokenObjet = tokenObjet ||
      createObj('graphic', {
        name: 'Objet anim\xE9',
        subtype: 'token',
        pageid: pageId,
        imgsrc: stats.token,
        left: lanceur.token.get('left'),
        top: lanceur.token.get('top'),
        width: tokenSize,
        height: tokenSize,
        layer: 'objects',
        showname: 'true',
        showplayers_bar1: 'true',
        light_hassight: 'true',
        light_losangle: 0,
        has_bright_light_vision: true,
        has_limit_field_of_vision: true,
        limit_field_of_vision_total: 0,
      });
    if (tokenObjet === undefined) {
      error("Impossible de cr\xE9er le token", stats);
      return;
    }
    toFront(tokenObjet);
    let persoObjet = {
      nom: 'Objet anim\xE9 par ' + nomPerso(lanceur),
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: niveauObjet,
        force: stats.force,
        pnj_for: stats.pnj_for,
        dexterite: 10,
        pnj_dex: 0,
        constitution: stats.constitution,
        pnj_con: stats.pnj_con,
        intelligence: 2,
        pnj_int: -4,
        sagesse: 2,
        pnj_sag: -4,
        charisme: 2,
        pnj_cha: -4,
        pnj_def: stats.pnj_def,
        pnj_init: 10
      },
      pv: stats.pv,
      attaques: [{
        nom: 'Frapper',
        atk: computeArmeAtk(lanceur, '@{ATKMAG}'),
        typedegats: 'contondant',
        dmnbde: stats.dmnbde,
        dmde: stats.dmde,
        dm: stats.dm
      }],
      attributes: [{
        name: 'objetAnime',
        current: 5 + modCarac(lanceur, 'intelligence'),
        max: getInit(),
        lie: options.mana !== undefined
      }, {
        name: 'objetAnimePar',
        current: idName(lanceur)
      }, {
        name: 'predicats_script',
        current: 'nonVivant'
      }]
    };
    let charObjet =
      createCharacter(persoObjet.nom, playerId, stats.avatar, tokenObjet, persoObjet, evt, lanceur);
    evt.tokens = [tokenObjet];
    evt.characters = [charObjet];
    if (aPartirDExistant)
      setPredicate({
        token: tokenObjet,
        charId: charObjet.id
      }, 'animeAPartirDExistant', evt);
    initiative([{
      _id: lanceur.token.id,
    }, {
      _id: tokenObjet.id
    }], evt);
    setTokenAttr(lanceur, 'niveauDesObjetsAnimes', dejaAnime + niveauObjet, evt);
    let allies = alliesParPerso[lanceur.charId] || new Set();
    allies.add(charObjet.charId);
    alliesParPerso[lanceur.charId] = allies;
  }

  //!cof-soigner-affaiblissement carac valeur
  function soignerAffaiblissement(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("Usage : !cof-soigner-affaiblissement carac valeur", msg.content);
      return;
    }
    let carac;
    switch (cmd[1]) {
      case 'FOR':
      case 'force':
        carac = 'force';
        break;
      case 'DEX':
      case 'dexterite':
      case 'dexterit\xE9':
      case 'dext\xE9rit\xE9':
      case 'dext\xE9rite':
        carac = 'dexterite';
        break;
      case 'CON':
      case 'constution':
        carac = 'constitution';
        break;
      case 'INT':
      case 'intelligence':
        carac = 'intelligence';
        break;
      case 'SAG':
      case 'sagesse':
        carac = 'sagess';
        break;
      case 'CHA':
      case 'charisme':
        carac = 'charisme';
        break;
      default:
        error("Caract\xE9ristique " + carac + " non reconnue", cmd);
        return;
    }
    let valeur = parseInt(cmd[2]);
    if (isNaN(valeur) || valeur < 1) {
      error("La valeur de soin d'affaiblissement doit \xEAtre un nombre positif", cmd);
      return;
    }
    let lanceur = options.lanceur;
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lection\xE9e pour le soin d'affaiblissement", playerId);
        return;
      }
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine du soin", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) {
            options.lanceur = lanceur;
          }
        }
      }
      let evt = {
        type: "Soin d'affaiblissement de " + carac
      };
      addEvent(evt);
      if (limiteRessources(lanceur, options, carac, carac, evt)) return;
      iterSelected(selected, function(perso) {
        if (options.portee !== undefined) {
          if (options.puissantPortee) options.portee = options.portee * 2;
          let dist = distanceCombat(lanceur.token, perso.token);
          if (dist > options.portee) {
            sendPerso(lanceur, " est trop loin de " + nomPerso(perso));
            return;
          }
        }
        let malus = attributeAsInt(perso, 'affaiblissementde' + carac, 0);
        if (malus === 0) {
          sendPerso(perso, "n'a pas d'affaiblissement " + deCarac(carac));
          return;
        }
        diminueAffaiblissement(perso, carac, valeur, evt, malus);
      });
    });
  }

  //!cof-affaiblir-carac carac valeur
  function parseAffaiblirCarac(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("Usage : !cof-affaiblir-carac carac valeur", msg.content);
      return;
    }
    let carac;
    switch (cmd[1]) {
      case 'FOR':
      case 'force':
        carac = 'force';
        break;
      case 'DEX':
      case 'dexterite':
      case 'dexterit\xE9':
      case 'dext\xE9rit\xE9':
      case 'dext\xE9rite':
        carac = 'dexterite';
        break;
      case 'CON':
      case 'constution':
        carac = 'constitution';
        break;
      case 'INT':
      case 'intelligence':
        carac = 'intelligence';
        break;
      case 'SAG':
      case 'sagesse':
        carac = 'sagess';
        break;
      case 'CHA':
      case 'charisme':
        carac = 'charisme';
        break;
      case 'RAND':
      case 'rand':
      case 'random':
        carac = 'random';
        break;
      default:
        error("Caract\xE9ristique " + carac + " non reconnue", cmd);
        return;
    }
    let valeur = parseInt(cmd[2]);
    if (isNaN(valeur) || valeur < 1) {
      error("La valeur d'affaiblissement doit \xEAtre un nombre positif", cmd);
      return;
    }
    let lanceur = options.lanceur;
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible s\xE9lection\xE9e pour l'affaiblissement", playerId);
        return;
      }
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine de l'affaiblissement", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) {
            options.lanceur = lanceur;
          }
        }
      }
      let cibles = [];
      iterSelected(selected, function(perso) {
        if (options.portee !== undefined) {
          if (options.puissantPortee) options.portee = options.portee * 2;
          let dist = distanceCombat(lanceur.token, perso.token);
          if (dist > options.portee) {
            sendPerso(lanceur, " est trop loin de " + nomPerso(perso));
            return;
          }
        }
        if (options.type && immuniseAuType(perso, options.type, lanceur)) {
          sendPerso(perso, "ne semble pas affect\xE9 par " + stringOfType(options.type));
          return;
        }
        cibles.push(perso);
      });
      if (cibles.length == 0) {
        return;
      }
      affaiblirCarac(playerId, cibles, carac, valeur, options);
    }, options);
  }

  function randomCarac() {
    switch (randomInteger(6)) {
      case 1:
        return 'force';
      case 2:
        return 'dexterite';
      case 3:
        return 'constitution';
      case 4:
        return 'intelligence';
      case 5:
        return 'sagesse';
      case 6:
        return 'charisme';
    }
    error("Erreur interne dans randomCarac");
  }

  function randomCaracForId(id, options) {
    if (options.randomCaracs) {
      if (options.randomCaracs[id]) return options.randomCaracs[id];
    } else {
      options.randomCaracs = {};
    }
    let carac = randomCarac();
    options.randomCaracs[id] = carac;
    return carac;
  }

  //carac est une caract\xE9ristique enti\xE8re
  function affaiblirCaracPerso(perso, carac, valeur, expliquer, evt) {
    let nomAttr = 'affaiblissementde' + carac;
    let malus = addToAttributeAsInt(perso, nomAttr, 0, valeur, evt);
    let cn = caracNormale(perso, carac);
    if (malus > cn) {
      valeur += cn - malus;
      setTokenAttr(perso, nomAttr, cn, evt);
    }
    if (valeur < 1) return;
    expliquer("perd " + valeur + " points de " + carac);
    if (carac == 'constitution') {
      if (malus >= cn) {
        mort(perso, expliquer, evt);
        return;
      }
      let perteMod = Math.floor(valeur / 2);
      if (valeur % 2 == 1) {
        if ((cn - malus) % 2 == 1) perteMod++;
      }
      if (perteMod > 0) {
        let niveau = ficheAttributeAsInt(perso, 'niveau', 1);
        let pvPerdus = niveau * perteMod;
        let bar1 = parseInt(perso.token.get("bar1_value"));
        let pvmax = parseInt(perso.token.get("bar1_max"));
        if (isNaN(bar1) || isNaN(pvmax)) {
          error("Affaiblissement de constitution sur un token sans points de vie", perso);
          return;
        }
        let attrpvMaxNormaux = tokenAttribute(perso, 'pvMaxNormaux');
        if (attrpvMaxNormaux.length === 0) {
          setTokenAttr(perso, 'pvMaxNormaux', pvmax, evt);
        }
        pvmax -= pvPerdus;
        if (pvmax < 1) {
          pvPerdus += pvmax - 1;
          pvmax = 1;
        }
        bar1 -= pvPerdus;
        if (bar1 < 0) bar1 = 0;
        updateCurrentBar(perso, 1, bar1, evt, pvmax);
        if (bar1 === 0) mort(perso, expliquer, evt);
      }
    } else { //autre caract\xE9ristiques
      if (malus >= cn) {
        setState(perso, 'renverse', true, evt);
        setState(perso, 'assomme', true, evt);
      }
    }
  }

  function affaiblirCarac(playerId, cibles, carac, valeur, options) {
    const evt = {
      type: 'affaiblissement',
      action: {
        titre: "Affaiblissement de " + carac,
        playerId: playerId,
        cibles: cibles,
        carac: carac,
        valeur: valeur,
        options: options
      }
    };
    let lanceur = options.lanceur;
    let explications = options.messages || [];
    let whisper = '';
    if (options.secret) {
      let player;
      if (playerId) player = getObj('player', playerId);
      if (player !== undefined) {
        whisper = '/w "' + player.get('displayname') + '" ';
      }
    }
    addEvent(evt);
    if (limiteRessources(lanceur, options, carac, carac, evt)) return;
    explications.forEach(function(e) {
      sendChat('', e);
    });
    cibles.forEach(function(perso) {
      let car = carac;
      if (carac == 'random') car = randomCaracForId(perso.token.id, options);
      let expliquer = function(s) {
        sendPerso(perso, s);
      };
      if (options.save) {
        let saveOpts = {
          msgPour: " pour r\xE9sister \xE0 un affaiblissement de " + car,
          msgRate: ", rat\xE9.",
          attaquant: lanceur,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: options.type
        };
        let saveId = 'affaiblissement' + car + "_" + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt,
          function(reussite, rollText) {
            if (!reussite) {
              affaiblirCaracPerso(perso, car, valeur, expliquer, evt);
            }
          });
      } else {
        affaiblirCaracPerso(perso, car, valeur, expliquer, evt);
      }
    });
  }

  // !cof-fin-reaction-violente token_id
  function finReactionViolente(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Usage : !cof-fin-reaction-violente token_id", msg.content);
      return;
    }
    let perso = persoOfId(cmd[1]);
    if (perso === undefined) {
      error("Le premier argument de !cof-fin-reatcion-violente n'est pas un token valide", cmd);
      return;
    }
    let playerId = getPlayerIdFromMsg(msg);
    let attr = tokenAttribute(perso, 'reactionViolente');
    if (attr.length === 0) {
      sendPlayer(msg, "Action inutile, " + perso.token.ge('name') + " n'est pas sous l'effet d'une r\xE9action violente", playerId);
      return;
    }
    attr = attr[0];
    let duree = parseInt(attr.get('current'));
    if (isNaN(duree) || duree < 1) duree = 1;
    let evt = {
      type: "Fin de r\xE9action violente",
      deletedAttributes: [attr]
    };
    addEvent(evt);
    attr.remove();
    sendPerso(perso, "prend sur " + onGenre(perso, 'lui', 'elle') + " pour contenir sa r\xE9action violente");
    options.ignoreRD = true;
    let de = 6;
    if (predicateAsBool(perso, 'sangFroid')) de = 4;
    let degats = rollDePlus(de, {
      nbDes: duree
    });
    let dmg = {
      type: 'normal',
      total: degats.val,
      display: degats.roll
    };
    dealDamage(perso, dmg, [], evt, false, options, undefined,
      function(dmgDisplay, dmgFinal) {
        sendPerso(perso, "s'inflige " + dmgDisplay + " DM");
      });
  }

  //!cof-explosion correspond \xE0 !cof-attack token token --explosion pour chaque  token s\xE9lectionn\xE9
  function attaqueExplosion(msg) {
    if (!msg.content) return;
    let index = msg.content.indexOf(' ');
    if (index < 1) {
      error("Il manque le label de l'attaque \xE0 utiliser pour !cof-explosion", msg.content);
      return;
    }
    let args_msg = msg.content.substring(index);
    //On va ensuite enlever tout ce qui vient apr\xE8s --target
    index = args_msg.indexOf(' --target ');
    if (index > 0) args_msg = args_msg.substring(0, index);
    args_msg += ' --explosion';
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        let id = perso.token.id;
        let msga = {...msg,
          content: '!cof-attack ' + id + ' ' + id + args_msg
        };
        parseAttack(msga);
      });
    }, {
      ignoreAllies: true,
      ignoreDisque: true
    }); //On ignore les options d'alli\xE9s dans le getSelected
  }

  function setFoudreDuTemps(msg) {
    let playerId = getPlayerIdFromMsg(msg);
    if (!playerIsGM(playerId)) {
      sendPlayer(msg, "Commande r\xE9serv\xE9e au MJ", playerId);
      return;
    }
    let cmd = msg.content.split(' ');
    cmd = cmd.filter(function(c) {
      return c.trim() !== '';
    });
    let min = 13;
    let max = 13;
    if (stateCOF.foudreDuTemps) {
      min = stateCOF.foudreDuTemps.min;
      max = stateCOF.foudreDuTemps.max;
    }
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'true':
        case 'oui':
          break;
        case 'non':
        case 'sortir':
        case 'false':
        case 'fin':
          max = 1;
          min = 20;
          break;
        default:
          min = parseInt(cmd[1]);
          if (isNaN(min)) {
            error("Le premier argument de !cof-foudre-du-temps est invalide", cmd);
            return;
          }
          if (cmd.length > 2) {
            max = parseInt(cmd[2]);
            if (isNaN(max)) {
              error("Le second argument de !cof-foudre-du-temps est invalide", cmd);
              max = min;
            }
          }
      }
    }
    if (min < 1) min = 1;
    if (max > 20) max = 20;
    if (max >= min) {
      stateCOF.foudreDuTemps = stateCOF.foudreDuTemps || {};
      stateCOF.foudreDuTemps.min = min;
      stateCOF.foudreDuTemps.max = max;
      let message = "Les foudres du temps sont actives pour des jets ";
      if (min == max) message += "de " + min;
      else message += "entre " + min + " et " + max;
      sendPlayer('GM', message);
    } else {
      stateCOF.foudreDuTemps = undefined;
      sendPlayer('GM', "Les personnages ne sont plus sous l'effet des foudres du temps");
    }
  }

  function agrandirPage(msg) {
    let cmd = msg.content.split(' ');
    if (cmd.length < 1) {
      error("Il manque le facteur d'agrandissement", cmd);
      return;
    }
    let facteur = parseFloat(cmd[1]);
    if (isNaN(facteur) || facteur <= 0) {
      error("Facteur incorrect", cmd);
      return;
    }
    let playerId = getPlayerIdFromMsg(msg);
    if (!playerIsGM(playerId)) {
      sendPlayer(msg, "Commande r\xE9serv\xE9e aux MJs", playerId);
      return;
    }
    let pageId = getPageId(playerId);
    if (!pageId) {
      error("Impossible de trouver la page", playerId);
      return;
    }
    let page = getObj('page', pageId);
    if (page === undefined) {
      error("Impossible de trouver la page correspondant \xE0 l'id", pageId);
      return;
    }
    let agrandir = function(o, field) {
      o.set(field, o.get(field) * facteur);
    };
    let move = function(o) {
      agrandir(o, 'top');
      agrandir(o, 'left');
    };
    let scale = function(o) {
      agrandir(o, 'width');
      agrandir(o, 'height');
    };
    scale(page);
    let objects = findObjs({
      _type: 'graphic',
      _pageid: pageId
    });
    objects.forEach(function(o) {
      move(o);
      if (o.get('layer') == 'map') scale(o);
    });
    let paths = findObjs({
      _type: 'path',
      _pageid: pageId
    });
    paths.forEach(function(p) {
      move(p);
      agrandir(p, 'scaleX');
      agrandir(p, 'scaleY');
    });
    let texts = findObjs({
      _type: 'text',
      _pageid: pageId
    });
    texts.forEach(function(t) {
      move(t);
    });
    sendPlayer('GM', "Agrandissement termin\xE9");
  }

  function decoincer(msg) {
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de token s\xE9lectionn\xE9", playerId);
        return;
      }
      if (!playerIsGM(playerId)) {
        sendPlayer(msg, "Action r\xE9serv\xE9e au MJ", playerId);
        return;
      }
      const evt = {
        type: "D\xE9coincer",
        tokens: []
      };
      let pageId;
      iterSelected(selected, function(perso) {
        if (attributeAsBool(perso, 'decoince')) {
          sendPlayer(msg, nomPerso(perso) + " peut d\xE9j\xE0 \xEAtre d\xE9plac\xE9", playerId);
          return;
        }
        if (!perso.token.get('lockMovement')) {
          sendPlayer(msg, nomPerso(perso) + "n'est pas bloqu\xE9", playerId);
          return;
        }
        let nom = 'decoince ' + perso.token.get('name');
        pageId = pageId || perso.token.get('pageid');
        let tokenBougeAttr = tokenAttribute(perso, 'bougeGraceA');
        if (tokenBougeAttr.length > 0) {
          tokenBougeAttr = tokenBougeAttr[0];
          let tokenBouge = getObj('graphic', tokenBougeAttr.get('current'));
          if (tokenBouge === undefined) {
            //On cherche un token de nom decoince + nom du perso
            tokenBouge = findObjs({
              _type: 'graphic',
              _pageid: pageId,
              represents: perso.charId,
              name: nom
            });
            if (tokenBouge.length > 0) {
              tokenBouge = tokenBouge[0];
              tokenBougeAttr.set('current', tokenBouge.id);
            } else {
              tokenBougeAttr.remove();
            }
          }
          if (tokenBouge) {
            if (tokenBouge.get('pageid') == pageId) {
              toFront(tokenBouge);
              return;
            }
            tokenBouge.remove();
            tokenBougeAttr.remove();
          }
        }
        let tokenFields = {
          _pageid: pageId,
          represents: perso.charId,
          layer: perso.token.get('layer'),
          left: perso.token.get('left'),
          top: perso.token.get('top'),
          rotation: perso.token.get('rotation'),
          width: perso.token.get('width'),
          height: perso.token.get('height'),
          name: nom,
          aura1_radius: 0,
          aura1_color: "#EE9911",
          showplayers_aura1: false,
          showplayers_name: false,
          showplayers_bar1: false,
          showplayers_bar2: false,
          showplayers_bar3: false,
          imgsrc: IMG_INVISIBLE,
        };
        let tokenBouge = createObj('graphic', tokenFields);
        if (!tokenBouge) {
          error("Impossible de cr\xE9er de token pour d\xE9coincer " + nomPerso(perso), tokenFields);
          return;
        }
        evt.tokens.push(tokenBouge);
        toFront(tokenBouge);
        setTokenAttr(perso, 'bougeGraceA', tokenBouge.id, evt);
      });
      if (pageId) sendPlayer(msg, "Penser \xE0 supprimer le token invisible quand vous aurez termin\xE9 le d\xE9placement", playerId);
    });
  }

  function pauseGame() {
    if (stateCOF.pause) stateCOF.pause = false;
    else stateCOF.pause = true;
    let tokens = findObjs({
      _type: 'graphic',
      _subtype: 'token',
      layer: 'objects'
    });
    let charTreated = new Set();
    let charTreatedBlocked = new Set();
    tokens.forEach(function(token) {
      let charId = token.get('represents');
      if (charId === '') return;
      let character = getObj('character', charId);
      if (character === undefined) return;
      let charControlledby = character.get('controlledby');
      if (charControlledby === '') return;
      let controlledByPlayer = charControlledby.split(',').some(function(pid) {
        return pid == 'all' || !playerIsGM(pid);
      });
      if (!controlledByPlayer) return;
      if (stateCOF.pause) token.set('lockMovement', true);
      else {
        let linked = token.get('bar1_link') !== '';
        if (linked && charTreated.has(charId)) {
          if (!charTreatedBlocked.has(charId)) token.set('lockMovement', false);
        } else {
          const perso = {
            token,
            charId
          };
          if (linked) {
            charTreated.add(charId);
            if (persoImmobilise(perso)) {
              charTreatedBlocked.add(charId);
              return;
            }
          } else if (persoImmobilise(perso)) return;
          token.set('lockMovement', false);
          enleveDecoince(perso);
        }
      }
    });
    let macros = findObjs({
      _type: 'macro'
    });
    let macro = macros.find(function(m) {
      let action = m.get('action');
      return action == '!cof-pause';
    });
    if (stateCOF.pause) {
      if (macro) macro.set('name', PLAY);
      sendChat('COF', "Jeu en pause");
    } else {
      if (macro) macro.set('name', PAUSE);
      sendChat('COF', "Fin de la pause");
    }
  }

  //!cof-sentir-la-corruption @{selected|token_id} @{target|token_id}
  function parseSentirLaCorruption(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("Usage : !cof-sentir-la-corruption token_id token_id", msg.content);
      return;
    }
    let chasseur = persoOfId(cmd[1]);
    if (chasseur === undefined) {
      error("Le premier argument de !cof-sentir-la-corruption n'est pas un token valide", msg.content);
      return;
    }
    let cible = persoOfId(cmd[2]);
    if (cible === undefined) {
      error("Le deuxi\xE8me argument de !cof-sentir-la-corruption n'est pas un token valide", msg.content);
      return;
    }
    let portee = 30;
    if (options.portee !== undefined) portee = options.portee;
    if (distanceCombat(chasseur.token, cible.token) > portee) {
      sendPerso(chasseur, " est trop loin de " + nomPerso(cible) + " pour sentir " + onGenre(cible, "s'il", "si elle") + " est corrompu" + eForFemale(cible));
      return;
    }
    let playerId = getPlayerIdFromMsg(msg);
    sentirLaCorruption(playerId, chasseur, cible, options);
  }

  function sentirLaCorruption(playerId, chasseur, cible, options) {
    const evt = {
      type: "Sentir la corruption",
      action: {
        playerId,
        chasseur,
        cible,
        options,
      }
    };
    addEvent(evt);
    if (limiteRessources(chasseur, options, 'sentirLaCorruption', 'sentir la corruption', evt)) return;
    let optionsDisplay = {
      secret: options.secret
    };
    let display = startFramedDisplay(playerId, 'Sentir la corruption', chasseur, optionsDisplay);
    testCaracteristique(chasseur, 'SAG', 15, 'sentirLaCorruptionChasseur', options, evt,
      function(tr, explications) {
        let msgRes = "<b>Jet de SAG :</b> " + tr.texte;
        explications.forEach(function(m) {
          addLineToFramedDisplay(display, m, 80);
        });
        let endDisplay = function() {
          if (options.messages) {
            options.messages.forEach(function(m) {
              addLineToFramedDisplay(display, m);
            });
          }
          if (display.retarde) {
            addFramedHeader(display, playerId, true);
            sendChat('', endFramedDisplay(display));
            addFramedHeader(display, undefined, 'gm');
            sendChat('', endFramedDisplay(display));
          } else sendChat('', endFramedDisplay(display));
        };
        if (tr.reussite) {
          addLineToFramedDisplay(display, msgRes + tr.modifiers);
          if (estHumanoide(cible)) {
            testCaracteristique(cible, 'INT', 15, 'sentirLaCorruptionCible', options, evt,
              function(tr, explications) {
                let msgRes = "<b>Jet d'INT de " + nomPerso(cible) + " :</b> " + tr.texte;
                //On n'affiche pas les possibilit\xE9s de rerolls, sinon il faudrait un bouton pour "continuer" afin de ne pas afficher le r\xE9sultat.
                addLineToFramedDisplay(display, msgRes + tr.modifiers);
                explications.forEach(function(m) {
                  addLineToFramedDisplay(display, m, 80);
                });
                msgRes = nomPerso(chasseur);
                if (tr.reussite || !predicateAsBool(cible, 'corrompu')) {
                  msgRes += " ne sent aucune corruption chez " + nomPerso(cible);
                } else {
                  msgRes += " sent de la corruption chez " + nomPerso(cible);
                }
                addLineToFramedDisplay(display, msgRes);
                if (options.fx)
                  spawnFx(chasseur.token.get('left'), chasseur.token.get('top'), options.fx, chasseur.token.get('pageid'));
                endDisplay();
              });
          } else {
            let msgRes = nomPerso(chasseur);
            if (predicateAsBool(cible, 'corrompu'))
              msgRes += " sent de la corruption chez " + nomPerso(cible);
            else
              msgRes += " ne sent aucune corruption chez " + nomPerso(cible);
            addLineToFramedDisplay(display, msgRes + tr.modifiers);
            if (options.fx)
              spawnFx(chasseur.token.get('left'), chasseur.token.get('top'), options.fx, chasseur.token.get('pageid'));
            endDisplay();
          }
        } else {
          addLineToFramedDisplay(display, msgRes + tr.rerolls + tr.modifiers);
          addLineToFramedDisplay(display, nomPerso(chasseur) + " ne r\xE9ussit pas \xE0 sentir la corruption.");
          endDisplay();
        }
      });
  }

  //!cof-creer-baies nbre
  function creerBaies(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    let nbBaies;
    if (cmd.length > 1) {
      nbBaies = parseInt(cmd[1]);
      if (isNaN(nbBaies) || nbBaies < 1) {
        sendPlayer(msg, "Aucune baie cr\xE9\xE9e. la commnde en demandait " + cmd[1]);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Utilisation de !cof-creer-baies sans s\xE9lection de token", playerId);
        return;
      }
      const evt = {
        type: "Cr\xE9ation de baies"
      };
      addEvent(evt);
      iterSelected(selected, function(druide) {
        if (limiteRessources(druide, options, 'creationDeBaies', "cr\xE9er des baies", evt)) return;
        let niveau = ficheAttributeAsInt(druide, 'niveau', 1);
        let mangerBaie = "!cof-consommer-baie " + niveau + " --limiteParJour 1 baieMagique";
        let nb;
        if (nbBaies) {
          nb = {
            val: nbBaies,
            roll: nbBaies + ''
          };
        } else {
          nb = rollDePlus(6, {
            bonus: modCarac(druide, 'sagesse')
          });
        }
        ajouterConsommable(druide, 'Baie magique', nb.val, mangerBaie, evt);
        sendPerso(druide, "cr\xE9e " + nb.roll + " baies magiques");
      });
    });
  }

  function doRetourBoomerang(lanceur, label, evt) {
    if (stateCOF.combat && stateCOF.options.affichage.val.init_dynamique.val) {
      threadSync++;
      activateRoundMarker(threadSync, lanceur.token);
    }
    let weaponStats = getWeaponStats(lanceur, label);
    if (!weaponStats || !weaponStats.armeDeJet) {
      error("Il semble que l'arme ne soit pas une arme de jet", label);
      return;
    }
    let attrName = weaponStats.prefixe + 'armejetqte';
    let attr = findObjs({
      _type: 'attribute',
      _characterid: lanceur.charId,
      name: attrName
    }, {
      caseInsensitive: true
    });
    evt.attributes = evt.attributes || [];
    let max = 1;
    if (attr.length > 0) {
      attr = attr[0];
      if (attr.length > 1) {
        error("Plus d'un attribut pour la quantit\xE9 d'armes de jet", attr);
        attr[1].remove();
      }
      max = parseInt(attr.get('max'));
      if (isNaN(max) || max < 1) {
        error("Maximum de " + weaponStats.name + " mal form\xE9, v\xE9rifier sur la fiche", attr);
        max = 1;
      }
      evt.attributes.push({
        attribute: attr,
        current: weaponStats.nbArmesDeJet,
        max: max
      });
    } else {
      attr = createObj('attribute', {
        characterid: lanceur.charId,
        name: attrName,
        current: 1,
        max: 1
      });
      evt.attributes.push({
        attribute: attr,
      });
    }
    if (weaponStats.nbArmesDeJet >= max) {
      error(nomPerso(lanceur) + " a d\xE9j\xE0 toutes ses armes de jet (" + max + ")", weaponStats);
      return;
    }
    attr.set('current', weaponStats.nbArmesDeJet + 1);
    sendPerso(lanceur, "rattrape son " + weaponStats.name);
  }

  //!cof-retour-boomerang id label
  function retourBoomerang(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("Il manque des arguments \xE0 !cof-retour-boomerang", cmd);
      return;
    }
    let lanceur = persoOfId(cmd[1]);
    if (!lanceur) {
      error("L'id du token ayan lanc\xE9 les armes est incorrecte", cmd);
      return;
    }
    let evt = {
      type: "Retour arme de jet"
    };
    addEvent(evt);
    doRetourBoomerang(lanceur, cmd[2], evt);
  }

  //Pour ouvrir une porte sans event, en particulier en cas de pause
  // !cof-open-door id
  function openDoor(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Il manque un argument \xE0 !cof-open-door", cmd);
      return;
    }
    let door = getObj('door', cmd[1]);
    if (door === undefined) {
      error("Impossible de trouver la porte", cmd);
      return;
    }
    door.set('isOpen', true);
  }

  //Demande de bouger son token jusqu'\xE0 destination
  function attaqueLigneBouger(msg) {
    const playerId = getPlayerIdFromMsg(msg);
    if (stateCOF.pause && !playerIsGM(playerId)) {
      sendPlayer(msg, "Le jeu est en pause", playerId);
      return;
    }
    let args = msg.content.split(' ');
    if (args.length < 2) {
      error("Il manque un argument \xE0 !cof-attack-line", args);
      return;
    }
    const attaquant = persoOfId(args[1]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-attack-line n'est pas un token valide", args[1]);
      return;
    }
    let token = attaquant.token;
    let restArgs = args.slice(2).join(' ');
    let command = '!cof-attack-line-from ' + token.get('left') + ' ' + token.get('top') + ' ' + token.id + ' ' + restArgs;
    sendPlayer(msg, "D\xE9placer votre token jusqu'au bout de la ligne (l'emplacement doit \xEAtre libre), et " + boutonSimple(command, "cliquer ici"), playerId);
    return;
  }

  //En partant de from, retourne la premi\xE8re position sur le segment [from, to] 
  // \xE0 distance dist de pt. S'il n'y en a pas, retourne la projection de pt sur le segment
  function positionLigne(from, to, token, dist) {
    let fx = from.x;
    let fy = from.y;
    let tx = to.x;
    let ty = to.y;
    let x = token.get('left');
    let y = token.get('top');
    let a = (tx - fx) * (tx - fx) + (ty - fy) * (ty - fy);
    let b = 2 * ((fx - x) * (tx - fx) + (fy - y) * (ty - fy));
    let c = (fx - x) * (fx - x) + (fy - y) * (fy - y) - dist * dist;
    let delta = b * b - 4 * a * c;
    if (delta >= 0) {
      let k = (b + Math.sqrt(delta)) / (2 * a);
      if (k > 0) k = 0;
      if (k < -1) k = -1;
      return [fx - k * (tx - fx), fy - k * (ty - fy)];
    }
    //sinon on projette
    let ps = (x - fx) * (tx - fx) + (y - fy) * (tx - fy) + 0.0;
    let k = ps / Math.sqrt(a);
    if (k < 0) k = 0;
    if (k > 1) k = 1;
    return [fx + k * (tx - fx), fy + k * (ty - fy)];
  }

  //!cof-attack-line-from left top id
  function attaqueLigne(msg) {
    const playerId = getPlayerIdFromMsg(msg);
    if (stateCOF.pause && !playerIsGM(playerId)) {
      sendPlayer(msg, "Le jeu est en pause", playerId);
      return;
    }
    let optArgs = msg.content.split(' --');
    let args = optArgs[0].split(' ');
    args = args.filter(function(a) {
      return a !== '';
    });
    optArgs.shift();
    if (args.length < 4) {
      error("Pas assez d'arguments pour !cof-attack-line: " + msg.content, args);
      return;
    }
    let originLeft = parseInt(args[1]);
    let originTop = parseInt(args[2]);
    if (isNaN(originLeft) || isNaN(originTop)) {
      error("Coordonn\xE9es non num\xE9riques dans !co-attack-line", args);
      return;
    }
    const attaquant = persoOfId(args[3]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-attack-line n'est pas un token valide", args[3]);
      return;
    }
    let destLeft = attaquant.token.get('left');
    let destTop = attaquant.token.get('top');
    //On remet l'attaquant \xE0 sa place
    attaquant.token.set('left', originLeft);
    attaquant.token.set('top', originTop);
    let combat = stateCOF.combat;
    if (stateCOF.options.affichage.val.init_dynamique.val && roundMarker &&
      combat) {
      if ((!stateCOF.chargeFantastique && combat.activeTokenId == attaquant.token.id) ||
        (stateCOF.chargeFantastique && stateCOF.chargeFantastique.activeTokenId == attaquant.token.id)) {
        roundMarker.set('left', originLeft);
        roundMarker.set('top', originTop);
      }
    }
    let pageId = attaquant.token.get('pageid');
    let scale = computeScale(pageId);
    let restArgs = '';
    if (args.length > 4) {
      restArgs = args.slice(4).join(' ');
    }
    let ptDest = {
      x: destLeft,
      y: destTop
    };
    let ptOrigin = {
      x: originLeft,
      y: originTop
    };
    let tropLoin = false;
    //On cherche si argument --distanceMax, pas utilis\xE9 par cof-attack
    optArgs = optArgs.filter(function(cmd) {
      if (!cmd.startsWith('distanceMax')) return true;
      let a = cmd.split(' ');
      if (a.length < 2) {
        error("Il manque un argument \xE0 --distanceMax", cmd);
        return false;
      }
      let distanceMax = parseInt(a[1]);
      if (isNaN(distanceMax) || distanceMax < 0) {
        error("la distance max n'est pas un nombre positif", cmd);
        return false;
      }
      let distancePix = distancePoints(ptOrigin, ptDest);
      let distance = ((distancePix / PIX_PER_UNIT) * scale);
      if (distance > distanceMax) {
        sendPlayer(msg, "Ligne d'attaque trop grande, choisir une destination plus proche");
        tropLoin = true;
      }
      return false;
    });
    if (optArgs.length > 0) {
      restArgs = restArgs + ' --' + optArgs.join(' --');
    }
    if (tropLoin) return;
    //On regarde si l'emplacement est bien vide.
    let tokens = findObjs({
      _pageid: pageId,
      _type: 'graphic',
      _subtype: 'token',
      layer: attaquant.token.get('layer')
    });
    tokens = tokens.filter(function(tok) {
      return tok.id != attaquant.token.id && tok.get('represents');
    });
    let attRayon = tokenSize(attaquant.token, 0);
    let overLap = tokens.some(function(tok) {
      let pt = pointOfToken(tok);
      let distancePix = distancePoints(pt, ptDest);
      return distancePix < attRayon + tokenSize(tok, 0);
    });
    if (overLap) {
      sendPlayer(msg, "La place n'est pas libre", playerId);
      return;
    }
    //Puis s'il n'y a pas d'obstacles sur le trajet
    let page = getObj('page', pageId);
    let murs = getWalls(page, pageId);
    if (murs) {
      let pc = {
        x: originLeft,
        y: originTop
      };
      if (obstaclePresent(destLeft, destTop, pc, murs)) {
        sendPlayer(msg, "Il y a des obstacles sur le trajet", playerId);
        return;
      }
    }
    //On d\xE9termine les cibles sur le trajet
    let cibles = [];
    tokens.forEach(function(tok) {
      let cible = {
        token: tok,
        charId: tok.get('represents')
      };
      if (nePeutPlusPrendreDM(cible, {})) return; //pas de d\xE9g\xE2ts aux morts
      let distToTrajectory = distancePixTokenSegment(tok, ptOrigin, ptDest);
      if (distToTrajectory > attRayon + tokenSize(tok, 0))
        return;
      cible.tokName = tok.get('name');
      let tokChar = getObj('character', cible.charId);
      if (tokChar === undefined) return;
      cible.name = tokChar.get('name');
      let pt = pointOfToken(tok);
      cible.distanceOrigine = distancePoints(ptOrigin, pt);
      cibles.push(cible);
    });
    if (cibles.length === 0) {
      sendPlayer(msg, "Aucune cible valide sur le trajet", playerId);
      return;
    }
    const evt = {
      type: "Attaque en ligne"
    };
    addEvent(evt);
    let explications = [];
    combat = entrerEnCombat(attaquant, [], explications, evt);
    explications.forEach(function(m) {
      sendPerso(attaquant, m);
    });
    combat.attackId = combat.attackId || 0;
    combat.attackCallbacks = combat.attackCallBacks || {};
    //On trie les cibles selon leur distance \xE0 l'origine.
    cibles.sort(function(c1, c2) {
      return c1.distanceOrigine - c2.distanceOrigine;
    });
    combat.attackId++;
    let firstAttack = combat.attackId;
    cibles.forEach(function(cible) {
      let nextAttack = combat.attackId + 1;
      let dist = attRayon + tokenSize(cible.token, 0);
      let [left, top] = positionLigne(ptOrigin, ptDest, cible.token, dist);
      let comAttaque = '!cof-attack ' + attaquant.token.id + ' ' + cible.token.id + ' ' + restArgs + ' --attackId ' + nextAttack;
      let comSkip = '!cof-skip-attack ' + nextAttack;
      let m = boutonSimple(comAttaque, "Attaquer " + cible.tokName) + " ou " +
        boutonSimple(comSkip, "Continuer");
      combat.attackCallbacks[combat.attackId] = function(evt) {
        moveTokenWithUndo(attaquant.token, left, top, evt);
        sendPlayer(msg, m, playerId);
      };
      combat.attackId++;
    });
    combat.attackCallbacks[combat.attackId] = function() {
      attaquant.token.set('left', destLeft);
      attaquant.token.set('top', destTop);
    };
    combat.attackCallbacks[firstAttack]();
  }

  function skipAttack(msg) {
    let args = msg.content.split(' ');
    if (args.length < 2) {
      error("Il manque l'id dans !cof-skip-attack", args);
      return;
    }
    let options = {
      attackId: args[1]
    };
    let evt = {
      type: "skip attack"
    };
    addEvent(evt);
    attackCallback(options, evt);
  }

  //!cof-vision-nocturne distance [distance vue normale]
  function ajouterVisionNocturne(msg) {
    let options = parseOptions(msg);
    if (options === undefined) return;
    let cmd = options.cmd;
    if (cmd === undefined) {
      error("Probl\xE8me de parse options", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Il manque un argument \xE0 !cof-vision-nocturne", cmd);
      return;
    }
    let distance = parseInt(cmd[1]);
    if (isNaN(distance) || distance < 0) {
      error("Distance de vue incorrecte", cmd);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Utilisation de !cof-vision-nocturne sans s\xE9lection de token", playerId);
        return;
      }
      const evt = {
        type: 'vision nocturne',
      };
      addEvent(evt);
      iterSelected(selected, function(perso) {
        let token = perso.token;
        setToken(token, 'has_night_vision', true, evt);
        setToken(token, 'night_vision_effect', 'Nocturnal', evt);
        setToken(token, 'night_vision_distance', distance, evt);
      });
    });
  }

  function apiCommand(msg) {
    msg.content = msg.content.replace(/\s+/g, ' '); //remove duplicate whites
    const command = msg.content.split(' ', 1);
    // First replace inline rolls by their values
    replaceInline(msg);
    switch (command[0]) {
      case '!cof-affaiblir-carac':
        parseAffaiblirCarac(msg);
        return;
      case '!cof-agrandir-page':
        agrandirPage(msg);
        return;
      case '!cof-animation-des-objets':
        animationDesObjets(msg);
        return;
      case '!cof-armure-magique':
        armureMagique(msg);
        return;
      case '!cof-attack':
        parseAttack(msg);
        return;
      case '!cof-attack-line':
        attaqueLigneBouger(msg);
        return;
      case '!cof-attack-line-from': //seulement utilis\xE9 en interne
        attaqueLigne(msg);
        return;
      case '!cof-attendre':
        attendreInit(msg);
        return;
      case '!cof-bouger':
        decoincer(msg);
        return;
      case '!cof-bouton-chance':
        boutonChance(msg);
        return;
      case '!cof-bouton-pousser-kiai':
        kiai(msg);
        return;
      case '!cof-canaliser':
        canaliser(msg);
        return;
      case '!cof-confirmer-attaque':
        confirmerAttaque(msg);
        return;
      case '!cof-creer-baies':
        creerBaies(msg);
        return;
      case '!cof-expert-combat':
      case '!cof-expert-combat-touche':
      case '!cof-expert-combat-dm':
        expertDuCombat(msg);
        return;
      case '!cof-expert-combat-def':
        expertDuCombatDEF(msg);
        return;
      case '!cof-expert-combat-bousculer':
        expertDuCombatBousculer(msg);
        return;
      case '!cof-explosion':
        attaqueExplosion(msg);
        return;
      case '!cof-hors-combat': //ancienne syntaxe, plus document\xE9e
      case '!cof-fin-combat':
        sortirDuCombat();
        return;
      case '!cof-fin-reaction-violente':
        finReactionViolente(msg);
        return;
      case '!cof-foudre-du-temps':
        setFoudreDuTemps(msg);
        return;
      case '!cof-huile-instable':
        huileInstable(msg);
        return;
      case "!cof-init":
        initiativeInterface(msg);
        return;
      case '!cof-jet':
        jet(msg);
        return;
      case '!cof-liste-actions':
        apiTurnAction(msg);
        return;
      case '!cof-mettre-a-zero-pv':
        interfaceMettreAZeroPV(msg);
        return;
      case '!cof-montrer-resultats-attaque':
        montrerResultatsAttaque(msg);
        return;
      case '!cof-montrer-resultats-jet':
        montrerResultatJet(msg);
        return;
      case '!cof-nouveau-jour':
        parseNouveauJour(msg);
        return;
      case '!cof-open-door':
        openDoor(msg);
        return;
      case '!cof-options':
        setCofOptions(msg);
        return;
      case '!cof-pathfinder1':
        translateFromPathfinder1(msg);
        return;
      case '!cof-pause':
        pauseGame();
        return;
      case "!cof-recharger":
        recharger(msg);
        return;
      case '!cof-recuperation':
        parseRecuperer(msg);
        return;
      case '!cof-resultat-jet':
        resultatJet(msg);
        return;
      case '!cof-retour-boomerang':
        retourBoomerang(msg);
        return;
      case "!cof-rune-protection":
        runeProtection(msg);
        return;
      case "!cof-rune-puissance":
      case "!cof-bouton-rune-puissance":
        runePuissance(msg);
        return;
      case "!cof-rune-energie":
      case "!cof-bouton-rune-energie":
        runeEnergie(msg);
        return;
      case '!cof-sentir-la-corruption':
        parseSentirLaCorruption(msg);
        return;
      case '!cof-skip-attack':
        skipAttack(msg);
        return;
      case '!cof-soigner-affaiblissement':
        soignerAffaiblissement(msg);
        return;
      case '!cof-sphere-de-feu':
        sphereDeFeu(msg);
        return;
      case '!cof-statut':
        statut(msg);
        return;
      case '!cof-surprise':
        parseSurprise(msg);
        return;
      case '!cof-tenebres-magiques':
        tenebresMagiques(msg);
        return;
      case '!cof-undo':
        undoEvent();
        return;
      case '!cof-vision-nocturne':
        ajouterVisionNocturne(msg);
        return;
      case "!cof-buf-def":
        bufDef(msg);
        return;
      case "!cof-remove-buf-def":
        removeBufDef(msg);
        return;
      case "!cof-aoe": //deprecated
      case "!cof-dmg":
        parseDmgDirects(msg);
        return;
      case "!cof-set-state":
        parseSetState(msg);
        return;
      case "!cof-save-state":
        parseSaveState(msg);
        return;
      case "!cof-save-effet":
        parseSaveEffet(msg);
        return;
      case "!cof-degainer":
        parseDegainer(msg);
        return;
      case "!cof-echange-init":
        echangeInit(msg);
        return;
      case "!cof-a-couvert":
        aCouvert(msg);
        return;
      case "!cof-bonus-couvert":
        bonusCouvert(msg);
        return;
      case "!cof-effet-temp":
        parseEffetTemporaire(msg);
        return;
      case "!cof-effet-combat":
        effetCombat(msg);
        return;
      case "!cof-effet":
        parseEffetIndetermine(msg);
        return;
      case "!cof-fin-classe-effet":
        finClasseDEffet(msg);
        return;
      case "!cof-attaque-magique":
        parseAttaqueMagique(msg);
        return;
      case "!cof-injonction":
        parseAttaqueMagique(msg, 'injonction');
        return;
      case "!cof-sommeil":
        parseSommeil(msg);
        return;
      case "!cof-attaque-magique-contre-pv":
        attaqueMagiqueContrePV(msg);
        return;
      case "!cof-transe-guerison":
        transeGuerison(msg);
        return;
      case "!cof-soin":
      case "!cof-soins":
        soigner(msg);
        return;
      case "!cof-nature-nourriciere":
        parseNatureNourriciere(msg);
        return;
      case "!cof-ignorer-la-douleur":
        ignorerLaDouleur(msg);
        return;
      case "!cof-fortifiant":
        fortifiant(msg);
        return;
      case "!cof-intercepter":
        intercepter(msg);
        return;
      case "!cof-interposer":
        interposer(msg);
        return;
      case "!cof-esquive-fatale":
        doEsquiveFatale(msg);
        return;
      case "!cof-exemplaire":
        exemplaire(msg);
        return;
      case "!cof-intervention-divine":
        interventionDivine(msg);
        return;
      case "!cof-lancer-sort":
        lancerSort(msg);
        return;
      case "!cof-as":
        emulerAs(msg);
        return;
      case "!cof-peur":
        parsePeur(msg);
        return;
      case "!cof-distribuer-baies":
        distribuerBaies(msg);
        return;
      case "!cof-consommer-baie":
        consommerBaie(msg);
        return;
      case "!cof-proteger-un-allie":
        protegerUnAllie(msg);
        return;
      case "!cof-action-defensive":
        actionDefensive(msg);
        return;
      case "!cof-strangulation":
        strangulation(msg);
        return;
      case "!cof-ombre-mortelle":
        ombreMortelle(msg);
        return;
      case "!cof-escalier":
        escalier(msg);
        return;
      case "!cof-defaut-dans-la-cuirasse":
        defautDansLaCuirasse(msg);
        return;
      case '!cof-posture-de-combat':
        postureDeCombat(msg);
        return;
      case '!cof-attaque-a-outrance':
        attaqueAOutrance(msg);
        return;
      case '!cof-mur-de-force':
        murDeForce(msg);
        return;
      case '!cof-capitaine':
        devientCapitaine(msg);
        return;
      case '!cof-tueur-fantasmagorique':
        parseAttaqueMagique(msg, 'tueurFantasmagorique');
        return;
      case '!cof-injonction-mortelle':
        parseInjonctionMortelle(msg);
        return;
      case '!cof-tour-de-force': // Deprecrated
        parseTourDeForce(msg);
        return;
      case '!cof-prouesse':
        boutonProuesse(msg);
        return;
      case '!cof-tour-force':
        boutonTourDeForce(msg);
        return;
      case '!cof-pacte-sanglant':
        boutonPacteSanglant(msg);
        return;
      case '!cof-pacte-sanglant-def':
        boutonPacteSanglantDef(msg);
        return;
      case '!cof-encaisser-un-coup':
        doEncaisserUnCoup(msg);
        return;
      case '!cof-devier-les-coups':
        doDevierLesCoups(msg);
        return;
      case '!cof-parade-projectiles':
        doParadeProjectiles(msg);
        return;
      case "!cof-parade-au-bouclier":
        doParadeAuBouclier(msg);
        return;
      case "!cof-esquive-acrobatique":
        doEsquiveAcrobatique(msg);
        return;
      case "!cof-esquive-de-la-magie":
        doEsquiveDeLaMagie(msg);
        return;
      case "!cof-resister-a-la-magie":
        resisterALaMagie(msg);
        return;
      case "!cof-cercle-protection":
        cercleDeProtection(msg);
        return;
      case "!cof-parade-magistrale":
        doParadeMagistrale(msg);
        return;
      case "!cof-esquive-magistrale":
        doEsquiveMagistrale(msg);
        return;
      case "!cof-absorber-au-bouclier":
      case "!cof-absorber-coup-au-bouclier":
        absorberCoupAuBouclier(msg);
        return;
      case "!cof-absorber-sort-au-bouclier":
        absorberSortAuBouclier(msg);
        return;
      case "!cof-chair-a-canon":
        doChairACanon(msg);
        return;
      case "!cof-demarrer-statistiques":
        if (stateCOF.statistiquesEnPause) {
          stateCOF.statistiques = stateCOF.statistiquesEnPause;
          delete stateCOF.statistiquesEnPause;
        } else {
          stateCOF.statistiques = {}; //remet aussi les statistiques \xE0 0
        }
        return;
      case "!cof-arreter-statistiques":
        delete stateCOF.statistiques;
        return;
      case "!cof-pause-statistiques":
        if (stateCOF.statistiques) {
          stateCOF.statistiquesEnPause = stateCOF.statistiques;
          delete stateCOF.statistiques;
        } // sinon, ne pas \xE9craser les statistiques d\xE9j\xE0 en pause
        return;
      case '!cof-statistiques':
        displayStatistics(msg);
        return;
      case '!cof-destruction-des-morts-vivants':
        parseDestructionDesMortsVivants(msg);
        return;
      case '!cof-enduire-poison':
        parseEnduireDePoison(msg);
        return;
      case '!cof-consommables':
        listeConsommables(msg);
        return;
      case '!cof-utilise-consommable': //Usage interne seulement
        utiliseConsommable(msg);
        return;
      case '!cof-echange-consommable': //Usage interne seulement
        echangeConsommable(msg);
        return;
      case '!cof-provocation':
        parseProvocation(msg);
        return;
      case '!cof-en-selle':
        enSelle(msg);
        return;
      case '!cof-creer-elixir': //usage interne seulement
        creerElixir(msg);
        return;
      case '!cof-elixirs':
        gestionElixir(msg);
        return;
      case '!cof-runes':
        gestionRunes(msg);
        return;
      case '!cof-creer-rune': // usage interne seulement
        creerRune(msg);
        return;
      case '!cof-rage-du-berserk':
        parseRageDuBerserk(msg);
        return;
      case '!cof-arme-secrete':
        parseArmeSecrete(msg);
        return;
      case '!cof-animer-arbre':
        animerUnArbre(msg);
        return;
      case '!cof-delivrance':
      case '!cof-guerir':
        delivrance(msg);
        return;
      case '!cof-guerison':
        guerison(msg);
        return;
      case '!cof-test-attaque-opposee':
        testAttaqueOpposee(msg);
        return;
      case '!cof-manoeuvre':
        manoeuvreRisquee(msg);
        return;
      case '!cof-appliquer-manoeuvre':
        appliquerManoeuvre(msg);
        return;
      case '!cof-desarmer':
        desarmer(msg);
        return;
      case '!cof-tempete-de-mana':
        optionsDeTempeteDeMana(msg);
        return;
      case '!cof-tour-suivant':
        tourSuivant(msg);
        return;
      case '!cof-multi-command':
        multiCommand(msg);
        return;
      case '!cof-conjuration-de-predateur':
        conjurationPredateur(msg);
        return;
      case '!cof-conjuration-armee':
        conjurationArmee(msg);
        return;
      case '!cof-set-macros':
        setGameMacros(msg);
        return;
      case '!cof-lumiere':
        ajouteLumiere(msg);
        return;
      case '!cof-eteindre-lumiere':
        eteindreLumieres(msg);
        return;
      case '!cof-torche':
        switchTorche(msg);
        return;
      case '!cof-defi-samourai':
        lancerDefiSamourai(msg);
        return;
      case '!cof-enveloppement':
        parseEnveloppement(msg);
        return;
      case '!cof-echapper-enveloppement':
        parseEchapperEnveloppement(msg);
        return;
      case '!cof-liberer-agrippe':
        parseLibererAgrippe(msg);
        return;
      case '!cof-liberer-ecrase':
        parseLibererEcrase(msg);
        return;
      case '!cof-animer-cadavre':
        animerCadavre(msg);
        return;
      case '!cof-vapeurs-ethyliques':
        parseVapeursEthyliques(msg);
        return;
      case '!cof-desaouler':
        desaouler(msg);
        return;
      case '!cof-boire-alcool':
        parseBoireAlcool(msg);
        return;
      case '!cof-jouer-son':
        jouerSon(msg);
        return;
      case '!cof-bouton-echec-total':
        echecTotal(msg);
        return;
      case '!cof-usure-off':
        let combat = stateCOF.combat;
        if (combat) {
          combat.usureOff = true;
          sendChat('COF', "/w GM Pas d'usure de la DEF sur ce combat");
        }
        return;
      case '!cof-set-attribute':
        setAttributeInterface(msg);
        return;
      case '!cof-set-predicate':
        setPredicateInterface(msg);
        return;
      case '!cof-options-d-attaque':
        optionsDAttaque(msg);
        return;
      case '!cof-petit-veinard':
      case '!cof-bouton-petit-veinard':
        petitVeinard(msg);
        return;
      case '!cof-suivre':
        suivre(msg);
        return;
      case '!cof-centrer-sur-token':
        centrerSurToken(msg);
        return;
      case '!cof-bourse':
        gestionBourse(msg);
        return;
      case '!cof-mot-de-pouvoir-immobilise':
        motDePouvoirImmobilise(msg);
        return;
      case '!cof-charge-fantastique':
        chargeFantastque(msg);
        return;
      case '!cof-next-charge-fantastique':
        nextTurnChargeFantastique(msg);
        return;
      case '!cof-tenebres':
        tenebres(msg);
        return;
      case '!cof-defense-armee-des-morts':
        defenseArmeeDesMorts(msg);
        return;
      case '!cof-invoquer-demon':
        invocationDemon(msg);
        return;
      case '!cof-animer-mort':
        animerMort(msg);
        return;
      case '!cof-prescience':
        utiliserPrescience(msg);
        return;
      case '!cof-multi-cartes':
        multiCartes(msg);
        return;
      case '!cof-ombre-mouvante':
        ombreMouvante(msg);
        return;
      case '!cof-reveler-nom':
        revelerNom(msg);
        return;
      case '!cof-fiole-de-lumiere':
        fioleDeLumiere(msg);
        return;
      case '!cof-agripper-de-demon':
        agripperDeDemon(msg);
        return;
      default:
        let errMsg = "Commande " + command[0] + " non reconnue.";
        log(errMsg);
        log(command);
        try {
          sendPlayer(msg, errMsg);
        } catch (e) {
          errMsg = errMsg.replace('[', '[ ');
          sendPlayer(msg, "Message sans jet : " + errMsg);
        }
        return;
    }
  }

  //Attributs possibles :
  // activation : message \xE0 l'activation
  // activationF : message \xE0 l'activation si la cible est f\xE9minine
  // actif : message de statut
  // actifF : message de statut si la cible est f\xE9minine
  // fin : message \xE0 la fin de l'effet
  // dm : permet d'infliger des dm
  // soins : soigne
  // prejudiciable: est un effet pr\xE9judiciable, qui peut \xEAtre enlev\xE9 par d\xE9livrance
  // generic: admet un argument entre parenth\xE8ses
  // seulementVivant: ne peut s'appliquer qu'aux cr\xE9atures vivantes
  // visible : l'effet est visible
  // msgSave: message \xE0 afficher quand on r\xE9siste \xE0 l'effet. Sera pr\xE9c\xE9d\xE9 de "pour "
  // entrave: effet qui immobilise, paralyse ou ralentit
  // statusMarker: marker par d\xE9faut pour l'effet
  const messageEffetTemp = {
    aCouvert: {
      activation: "reste \xE0 couvert",
      actif: "est \xE0 couvert",
      fin: "n'est pas \xE0 couvert"
    },
    affecteParAura: {
      activation: "entre dans une aura",
      actif: "est entr\xE9 dans une aura ce tour",
      actifF: "est entr\xE9e dans une aura ce tour",
      fin: "fin d'aura",
      generic: true,
    },
    apeureTemp: {
      activation: "prend peur",
      actif: "est domin\xE9 par sa peur",
      actifF: "est domin\xE9e par sa peur",
      fin: "retrouve du courage",
      msgSave: "retrouver du courage",
      prejudiciable: true,
      visible: true
    },
    aveugleTemp: {
      activation: "n'y voit plus rien !",
      actif: "est aveugl\xE9",
      actifF: "est aveugl\xE9e",
      fin: "retrouve la vue",
      msgSave: "retrouver la vue",
      prejudiciable: true,
      visible: true
    },
    benediction: {
      activation: "est touch\xE9 par la b\xE9n\xE9diction",
      activationF: "est touch\xE9e par la b\xE9n\xE9diction",
      actif: "est b\xE9ni",
      actifF: "est b\xE9nie",
      fin: "l'effet de la b\xE9n\xE9diction s'estompe"
    },
    blessureSanglante: {
      activation: "saigne abondamment",
      actif: "saigne abondamment",
      fin: "le saignement cesse enfin",
      prejudiciable: true,
      seulementVivant: true,
      visible: true,
      dm: true,
    },
    carquoisMagique: {
      activation: "enchante son carquois",
      actif: "a un carquois enchannt\xE9",
      fin: "le carquois redevient normal",
      visible: true,
    },
    chantDesHeros: {
      activation: "\xE9coute le chant du barde",
      actif: "est inspir\xE9 par le Chant des H\xE9ros",
      actifF: "est inspir\xE9e par le Chant des H\xE9ros",
      fin: "n'est plus inspir\xE9 par le Chant des H\xE9ros",
      finF: "n'est plus inspir\xE9e par le Chant des H\xE9ros"
    },
    drainDeForce: {
      activation: "se sent drain\xE9 de sa force",
      activationF: "se sent drain\xE9e de sa force",
      actif: "est sous l'effet d'un drain de force",
      msgSave: "ne plus \xEAtre affaibli",
      fin: "n'est plus affaibli",
      finF: "n'est plus affaiblie",
      prejudiciable: true,
      seulementVivant: true,
    },
    formeDAnge: {
      activation: "prend la forme d'un ange ail\xE9",
      actif: "est en forme d'ange et peut jeter des sorts en vol stationnaire",
      fin: "retrouve sa forme normale. Esp\xE9rons qu'il \xE9tait au sol...",
      finF: "retrouve sa forme normale. Esp\xE9rons qu'elle \xE9tait au sol...",
      visible: true,
    },
    frappeDesArcanes: {
      activation: "insuffle sa puissance magique dans son attaque",
      actif: "ne peut plus lancer de sorts pour l'instant",
      fin: "retrouve assez de puissance magique pour lancer des sorts",
    },
    frenesieMinotaure: {
      activation: "entre en fr\xE9n\xE9sie",
      actif: "est en fr\xE9n\xE9sie",
      fin: "retrouve son calme",
      msgSave: "retrouver son calme",
    },
    inspiration: {
      activation: "est inspir\xE9",
      activationF: "est inspir\xE9e",
      actif: "est sous l'effet d'une inspiration",
      fin: "n'est plus inspir\xE9",
      finF: "n'est plus inspir\xE9e"
    },
    imageDecalee: {
      activation: "d\xE9cale l\xE9g\xE8rement son image",
      actif: "a d\xE9cal\xE9 son image",
      fin: "appara\xEEt \xE0 nouveau l\xE0 o\xF9 il se trouve",
      finF: "appara\xEEt \xE0 nouveau l\xE0 o\xF9 elle se trouve",
      visible: false
    },
    paradeCroisee: {
      activation: "se met en position pour parer des deux armes",
      actif: "est en position de parade crois\xE9e",
      fin: "ne b\xE9n\xE9ficie plus de sa parade crois\xE9e",
      visible: true,
    },
    paralyseTemp: {
      activation: "est paralys\xE9 : aucune action ni d\xE9placement possible",
      activationF: "est paralys\xE9e : aucune action ni d\xE9placement possible",
      actif: "est paralys\xE9",
      actifF: "est paralys\xE9e",
      fin: "n'est plus paralys\xE9",
      finF: "n'est plus paralys\xE9e",
      msgSave: "ne plus \xEAtre paralys\xE9",
      prejudiciable: true,
      visible: true,
      entrave: true
    },
    paralyseGoule: {
      activation: "est paralys\xE9 : aucune action ni d\xE9placement possible",
      activationF: "est paralys\xE9e : aucune action ni d\xE9placement possible",
      actif: "est paralys\xE9",
      actifF: "est paralys\xE9e",
      fin: "n'est plus paralys\xE9",
      finF: "n'est plus paralys\xE9e",
      msgSave: "ne plus \xEAtre paralys\xE9",
      prejudiciable: true,
      visible: true
    },
    peauDEcorce: {
      activation: "donne \xE0 sa peau la consistance de l'\xE9corce",
      actif: "a la peau dure comme l'\xE9corce",
      fin: "retrouve une peau normale",
      visible: true
    },
    peauDEcorceAmeLiee: {
      activation: "voit sa peau se durcir",
      actif: "a la peau un peu rugueuse",
      fin: "retrouve une peau normale",
      visible: true
    },
    penombreTemp: {
      activation: "ne voit plus tr\xE8s loin",
      actif: "est dans la p\xE9nombre",
      fin: "retrouve une vue normale",
      msgSave: "retrouver la vue",
      prejudiciable: true,
    },
    peurEtourdi: {
      activation: "prend peur: il peut fuir ou rester recroquevill\xE9",
      activationF: "prend peur: elle peut fuir ou rester recroquevill\xE9",
      actif: "est paralys\xE9 par la peur",
      actifF: "est paralys\xE9e par la peur",
      fin: "retrouve du courage et peut \xE0 nouveau agir",
      msgSave: "retrouver du courage",
      prejudiciable: true,
      visible: true
    },
    protectionContreLesProjectiles: {
      activation: "gagne une protection contre les projectiles",
      actif: "est prot\xE9g\xE9 contre les projectiles",
      actifF: "est prot\xE9g\xE9e contre les projectiles",
      fin: "n'est plus prot\xE9g\xE9 contre les projectiles",
      finF: "n'est plus prot\xE9g\xE9e contre les projectiles",
      visible: false,
    },
    ralentiTemp: {
      activation: "est ralenti : une seule action, pas d'action limit\xE9e",
      activationF: "est ralentie : une seule action, pas d'action limit\xE9e",
      actif: "est ralenti",
      actifF: "est ralentie",
      msgSave: "ne plus \xEAtre ralenti",
      fin: "n'est plus ralenti",
      finF: "n'est plus ralentie",
      prejudiciable: true,
      visible: true,
      entrave: true
    },
    rayonAffaiblissant: {
      activation: "est touch\xE9 par un rayon affaiblissant",
      activationF: "est touch\xE9e par un rayon affaiblissant",
      actif: "est sous l'effet d'un rayon affaiblissant",
      msgSave: "ne plus \xEAtre affaibli",
      fin: "n'est plus affaibli",
      finF: "n'est plus affaiblie",
      prejudiciable: true
    },
    rituelAssure: {
      activation: "passe un tour complet \xE0 pr\xE9parer un sort",
      actif: "a pr\xE9par\xE9 un rituel assur\xE9",
      fin: "",
      visible: false
    },
    secoue: {
      activation: "h\xE9site un peu, il est secou\xE9",
      activationF: "h\xE9site un peu, elle est secou\xE9e",
      actif: "a un peu peur",
      fin: "retrouve du courage",
      msgSave: "retrouver du courage",
      prejudiciable: true,
      visible: true
    },
    secretsDeLAuDela: {
      activation: "contacte des esprits",
      actif: "des esprits lui murmurent des secrets oubli\xE9s",
      fin: "les esprits repartent"
    },
    souffleDeMort: {
      activation: "est terrifi\xE9 par la mort de son alli\xE9",
      activationF: "est terrifi\xE9e par la mort de son alli\xE9",
      actif: "ne peut agir suite au souffle de mort",
      fin: "retrouve ses esprits",
      msgSave: "pouvoir agir malgr\xE9 la mort de son alli\xE9",
      prejudiciable: true,
      visible: true,
    },
    immobiliseTemp: {
      activation: "est immobilis\xE9 : aucun d\xE9placement possible",
      activationF: "est immobilis\xE9e : aucun d\xE9placement possible",
      actif: "est immobilis\xE9",
      actifF: "est immobilis\xE9e",
      fin: "n'est plus immobilis\xE9",
      finF: "n'est plus immobilis\xE9e",
      msgSave: "pouvoir bouger",
      prejudiciable: true,
      visible: true,
      entrave: true
    },
    etourdiTemp: {
      activation: "est \xE9tourdi : aucune action et -5 en DEF",
      activationF: "est \xE9tourdie : aucune action et -5 en DEF",
      actif: "est \xE9tourdi",
      actifF: "est \xE9tourdie",
      fin: "n'est plus \xE9tourdi",
      finF: "n'est plus \xE9tourdie",
      msgSave: "se reprendre",
      prejudiciable: true,
      visible: true
    },
    affaibliTemp: {
      activation: "se sent faible",
      actif: "est affaibli",
      actifF: "est affaiblie",
      fin: "se sent moins faible",
      msgSave: "retrouver des forces",
      prejudiciable: true
    },
    assommeTemp: {
      activation: "est assomm\xE9",
      activationF: "est assomm\xE9e",
      actif: "est assomm\xE9",
      actifF: "est assomm\xE9e",
      fin: "reprend conscience",
      msgSave: "reprendre conscience",
      prejudiciable: true,
      visible: true
    },
    nauseeuxTemp: {
      activation: "souffre de violentes douleurs au ventre",
      actif: "est naus\xE9eux, seul le mouvement est possible",
      actifF: "est naus\xE9euse, seul le mouvement est possible",
      fin: "se sent mieux",
      msgSave: "ne plus \xEAtre naus\xE9eux",
      prejudiciable: true,
      visible: true
    },
    invisibleTemp: {
      activation: "dispara\xEEt",
      actif: "est invisible",
      fin: "r\xE9appara\xEEt",
      msgSave: "ne pas devenir invisible",
      visible: true
    },
    aveugleManoeuvre: {
      activation: "est aveugl\xE9 par la manoeuvre",
      activationF: "est aveugl\xE9e par la manoeuvre",
      actif: "a du mal \xE0 voir o\xF9 sont ses adversaires",
      fin: "retrouve une vision normale",
      msgSave: "voir \xE0 nouveau",
      prejudiciable: true,
      visible: true
    },
    bloqueManoeuvre: {
      activation: "est bloqu\xE9 par la manoeuvre",
      activationF: "est bloqu\xE9e par la manoeuvre",
      actif: "est bloqu\xE9 et ne peut pas se d\xE9placer",
      actifF: "est bloqu\xE9e et ne peut pas se d\xE9placer",
      fin: "peut \xE0 nouveau se d\xE9placer",
      msgSave: "pouvoir se d\xE9placer",
      prejudiciable: true,
      entrave: true
    },
    diversionManoeuvre: {
      activation: "est d\xE9concentr\xE9",
      activationF: "est d\xE9concentr\xE9e",
      actif: "a \xE9t\xE9 perturb\xE9 par une diversion",
      actifF: "a \xE9t\xE9 perturb\xE9e par une diversion",
      fin: "se reconcentre sur le combat",
      msgSave: "se reconcentrer sur le combat",
      prejudiciable: true,
      visible: true
    },
    menaceManoeuvre: {
      activation: "est menac\xE9",
      activationF: "est menac\xE9e",
      actif: "a \xE9t\xE9 menac\xE9, risque de plus de DM",
      actifF: "a \xE9t\xE9 menac\xE9e, risque de plus de DM",
      fin: "n'est plus sous la menace",
      msgSave: "ne plus \xEAtre sous la menace",
      prejudiciable: true,
      generic: true
    },
    tenuADistanceManoeuvre: {
      activation: "est tenu \xE0 distance",
      activationF: "est tenue \xE0 distance",
      actif: "est tenu \xE0 distance de son adversaire, il ne peut pas l'attaquer",
      actifF: "est tenue \xE0 distance de son adversaire, elle ne peut pas l'attaquer",
      fin: "peut \xE0 nouveau attaquer son adversaire",
      msgSave: "pouvoir \xE0 nouveau attaquer son adversaire",
      prejudiciable: true,
      generic: true,
      visible: true,
      entrave: true
    },
    epeeDansante: {
      activation: "fait appara\xEEtre une lame d'\xE9nergie lumineuse",
      actif: "contr\xF4le une lame d'\xE9nergie lumineuse",
      fin: "La lame d'\xE9nergie lumineuse dispara\xEEt",
      dm: true,
      visible: true
    },
    rapiereDansante: {
      activation: "fait appara\xEEtre une rapi\xE8re d'\xE9nergie lumineuse",
      actif: "contr\xF4le une rapi\xE8re d'\xE9nergie lumineuse",
      fin: "La rapi\xE8re d'\xE9nergie lumineuse dispara\xEEt",
      dm: true,
      visible: true
    },
    putrefaction: {
      activation: "vient de contracter une sorte de l\xE8pre fulgurante",
      actif: "est en pleine putr\xE9faction",
      fin: "La putr\xE9faction s'arr\xEAte.",
      msgSave: "r\xE9sister \xE0 la putr\xE9faction",
      prejudiciable: true,
      dm: true,
      visible: true
    },
    forgeron: {
      activation: "enflamme son arme",
      actif: "a une arme en feu",
      fin: "L'arme n'est plus enflamm\xE9e.",
      dm: true,
      generic: true,
      visible: true
    },
    armeEnflammee: {
      activation: "voit son arme prendre feu",
      actif: "a une arme enflamm\xE9e",
      fin: "L'arme n'est plus enflamm\xE9e.",
      dm: true,
      generic: true,
      visible: true
    },
    armesEnflammees: {
      activation: "voit ses armes prendre feu",
      actif: "a des armes enflamm\xE9es",
      fin: "Les armes ne sont plus enflamm\xE9es.",
      dm: true,
      visible: true
    },
    dotGen: {
      activation: "subit un effet",
      actif: "subit r\xE9guli\xE8rement des d\xE9g\xE2ts",
      fin: "ne subit plus ces effets de d\xE9g\xE2ts",
      dm: true,
      prejudiciable: true,
      generic: true
    },
    rechargeGen: {
      activation: "doit maintenant attendre un peu avant de pouvoir le refaire",
      actif: "attend avant de pouvoir refaire une action",
      fin: "a r\xE9cup\xE9r\xE9",
      generic: true
    },
    dmgArme: {
      activation: "enduit son arme d'une huile magique",
      actif: "a une arme plus puissante",
      fin: "L'arme retrouve sa puissance normale",
      dm: true,
      generic: true
    },
    flou: {
      activation: "devient flou",
      activationF: "devient floue",
      actif: "appara\xEEt flou",
      actifF: "appara\xEEt floue",
      fin: "redevient net",
      visible: true
    },
    agrandissement: {
      activation: "se met \xE0 grandir",
      actif: "est vraiment tr\xE8s grand",
      actifF: "est vraiment tr\xE8s grande",
      fin: "retrouve sa taille normale",
      visible: true
    },
    formeGazeuse: {
      activation: "semble perdre de la consistance",
      actif: "est en forme gazeuse",
      fin: "retrouve sa consistance normale",
      visible: true
    },
    intangible: {
      activation: "devient translucide",
      actif: "est intangible",
      fin: "redevient solide",
      visible: true
    },
    intangibleInvisible: {
      activation: "dispara\xEEt",
      actif: "est intangible et invisible",
      fin: "r\xE9appara\xEEt",
      visible: true
    },
    sousTension: {
      activation: "se charge d'\xE9nergie \xE9lectrique",
      actif: "est charg\xE9 d'\xE9nergie \xE9lectrique",
      actifF: "est charg\xE9e d'\xE9nergie \xE9lectrique",
      fin: "n'est plus charg\xE9 d'\xE9nergie \xE9lectrique",
      finF: "n'est plus charg\xE9e d'\xE9nergie \xE9lectrique",
      dm: true,
      visible: false
    },
    strangulation: {
      activation: "commence \xE0 \xE9touffer",
      actif: "est \xE9trangl\xE9",
      actifF: "est \xE9trangl\xE9e",
      fin: "respire enfin",
      msgSave: "pouvoir respirer",
      prejudiciable: true,
      seulementVivant: true,
      dm: true,
      visible: true
    },
    ombreMortelle: {
      activation: "voit son ombre s'animer et l'attaquer !",
      actif: "est une ombre anim\xE9e",
      fin: "retrouve une ombre normale",
      dm: true,
      visible: true
    },
    dedoublement: {
      activation: "voit un double translucide sortir de lui",
      activationF: "voit un double translucide sortir d'elle",
      actif: "est un double translucide",
      fin: "le double dispara\xEEt",
      dm: true,
      visible: true
    },
    zoneDeSilence: {
      activation: "n'entend plus rien",
      actif: "est totalement sourd",
      actifF: "est totalement sourde",
      fin: "peut \xE0 nouveau entendre"
    },
    danseIrresistible: {
      activation: "se met \xE0 danser",
      actif: "danse malgr\xE9 lui",
      actifF: "danse malgr\xE9 elle",
      fin: "s'arr\xEAte de danser",
      msgSave: "s'arr\xEAter de danser",
      prejudiciable: true,
      visible: true
    },
    confusion: {
      activation: "ne sait plus tr\xE8s bien ce qu'il fait l\xE0",
      activationF: "ne sait plus tr\xE8s bien ce qu'elle fait l\xE0",
      actif: "est en pleine confusion",
      fin: "retrouve ses esprits",
      msgSave: "retrouver ses esprits",
      prejudiciable: true,
      visible: true
    },
    murDeForce: {
      activation: "fait appara\xEEtre un mur de force",
      actif: "en entour\xE9 d'un mur de force",
      actifF: "en entour\xE9e d'un mur de force",
      fin: "voit son mur de force dispara\xEEtre",
      visible: true
    },
    asphyxie: {
      activation: "commence \xE0 manquer d'air",
      actif: "\xE9touffe",
      fin: "peut \xE0 nouveau respirer",
      msgSave: "pouvoir respirer normalement",
      prejudiciable: true,
      seulementVivant: true,
      statusMarker: 'blue',
      dm: true,
      visible: true
    },
    forceDeGeant: {
      activation: "devient plus fort",
      activationE: "devient plus forte",
      actif: "a une force de g\xE9ant",
      fin: "retrouve sa force normale"
    },
    saignementsSang: {
      activation: "commence \xE0 saigner du nez, des oreilles et des yeux",
      actif: "saigne de tous les orifices du visage",
      fin: "ne saigne plus",
      msgSave: "ne plus saigner",
      prejudiciable: true,
      statusMarker: 'red',
      dm: true,
      visible: true
    },
    encaisserUnCoup: {
      activation: "se place de fa\xE7on \xE0 d\xE9vier un coup sur son armure",
      actif: "est plac\xE9 de fa\xE7on \xE0 d\xE9vier un coup",
      actifF: "est plac\xE9e de fa\xE7on \xE0 d\xE9vier un coup",
      fin: "n'est plus en position pour encaisser un coup"
    },
    seulContreTous: {
      activation: "se place de fa\xE7on \xE0 faire face \xE0 tous ses adversaires",
      actif: "riposte",
      fin: "ne fait plus face \xE0 tous ses adversaires"
    },
    absorberUnCoup: {
      activation: "se pr\xE9pare \xE0 absorber un coup avec son bouclier",
      actif: "est pr\xEAt \xE0 absorber un coup avec son bouclier",
      actifF: "est pr\xEAte \xE0 absorber un coup avec son bouclier",
      fin: "n'est plus en position de prendre le prochain coup sur son bouclier"
    },
    absorberUnSort: {
      activation: "se pr\xE9pare \xE0 absorber un sort avec son bouclier",
      actif: "est pr\xEAt \xE0 absorber un sort avec son bouclier",
      actifF: "est pr\xEAte \xE0 absorber un sort avec son bouclier",
      fin: "n'est plus en position de se prot\xE9ger d'un sort avec son bouclier"
    },
    nueeDInsectes: {
      activation: "est attaqu\xE9 par une nu\xE9e d'insectes",
      activationF: "est attaqu\xE9e par une nu\xE9e d'insectes",
      actif: "est entour\xE9 d'une nu\xE9e d'insectes",
      actifF: "est entour\xE9e d'une nu\xE9e d'insectes",
      fin: "est enfin d\xE9barass\xE9 des insectes",
      finF: "est enfin d\xE9barass\xE9e des insectes",
      msgSave: "se d\xE9barasser des insectes",
      prejudiciable: true,
      dm: true,
      visible: true
    },
    nueeDeCriquets: {
      activation: "est attaqu\xE9 par une nu\xE9e de criquets",
      activationF: "est attaqu\xE9e par une nu\xE9e de criquets",
      actif: "est entour\xE9 d'une nu\xE9e de criquets",
      actifF: "est entour\xE9e d'une nu\xE9e de criquets",
      fin: "est enfin d\xE9barass\xE9 des criquets",
      finF: "est enfin d\xE9barass\xE9e des criquets",
      msgSave: "se d\xE9barasser des criquets",
      prejudiciable: true,
      dm: true,
      visible: true
    },
    nueeDeScorpions: {
      activation: "est attaqu\xE9 par une nu\xE9e de scorpions",
      activationF: "est attaqu\xE9e par une nu\xE9e de scorpions",
      actif: "est entour\xE9 d'une nu\xE9e de scorpions",
      actifF: "est entour\xE9e d'une nu\xE9e de scorpions",
      fin: "est enfin d\xE9barass\xE9 des scorpions",
      finF: "est enfin d\xE9barass\xE9e des scorpions",
      msgSave: "se d\xE9barasser des scorpions",
      prejudiciable: true,
      dm: true,
      visible: true
    },
    toiles: {
      activation: "voit des toiles d'araign\xE9es appara\xEEtre tout autour",
      actif: "est bloqu\xE9 par des toiles d'araign\xE9es",
      actifF: "est bloqu\xE9e par des toiles d'araign\xE9es",
      fin: "se lib\xE8re des toiles",
      msgSave: "se lib\xE9rer des toiles",
      prejudiciable: true,
      statusMarker: 'cobweb',
      visible: true,
      entrave: true
    },
    prisonVegetale: {
      activation: "voit des plantes pousser et s'enrouler autour de ses jambes",
      actif: "est bloqu\xE9 par des plantes",
      actifF: "est bloqu\xE9e par des plantes",
      fin: "se lib\xE8re des plantes",
      msgSave: "se lib\xE9rer des plantes",
      prejudiciable: true,
      statusMarker: 'green',
      visible: true,
      entrave: true
    },
    protectionContreLesElements: {
      activation: "lance un sort de protection contre les \xE9l\xE9ments",
      actif: "est prot\xE9g\xE9 contre les \xE9l\xE9ments",
      actifF: "est prot\xE9g\xE9e contre les \xE9l\xE9ments",
      fin: "n'est plus prot\xE9g\xE9 contre les \xE9l\xE9ments",
      finF: "n'est plus prot\xE9g\xE9e contre les \xE9l\xE9ments"
    },
    masqueMortuaire: {
      activation: "prend l'apparence de la mort",
      actif: "semble mort et anim\xE9",
      actifF: "semble morte et anim\xE9e",
      fin: "retrouve une apparence de vivant",
      visible: true
    },
    masqueMortuaireAmeLiee: {
      activation: "est li\xE9 \xE0 une apparence de la mort",
      activationF: "est li\xE9e \xE0 une apparence de la mort",
      actif: "semble en lien avec la mort",
      fin: "n'est plus en lien avec la mort"
    },
    armeBrulante: {
      activation: "sent son arme lui chauffer la main",
      actif: "se br\xFBle la main sur son arme",
      fin: "sent son arme refroidir",
      dm: true
    },
    armureBrulante: {
      activation: "sent son armure chauffer",
      actif: "br\xFBle dans son armure",
      fin: "sent son armure refroidir",
      dm: true
    },
    masqueDuPredateur: {
      activation: "prend les traits d'un pr\xE9dateur",
      actif: "a les traits d'un pr\xE9dateur",
      fin: "redevient normal",
      finF: "redevient normale",
      visible: true
    },
    masqueDuPredateurAmeLiee: {
      activation: "est li\xE9 \xE0 une \xE2me de pr\xE9dateur",
      activationF: "est li\xE9e \xE0 une \xE2me de pr\xE9dateur",
      actif: "b\xE9n\xE9ficie d'un lien avec un pr\xE9dateur",
      fin: "le lien dispara\xEEt",
      visible: false
    },
    aspectDeLaSuccube: {
      activation: "acquiert une beaut\xE9 fascinante",
      actif: "est d'une beaut\xE9 fascinante",
      fin: "retrouve sa beaut\xE9 habituelle",
      visible: true
    },
    aspectDuDemon: {
      activation: "prend l\x2019apparence d\x2019un d\xE9mon",
      actif: "a l\x2019apparence d\x2019un d\xE9mon",
      fin: "retrouve son apparence habituelle",
      visible: true
    },
    sangMordant: {
      activation: "transforme son sang",
      actif: "a du sang acide",
      fin: "retrouve un sang normal"
    },
    armeSecreteBarde: {
      activation: "est d\xE9stabilis\xE9",
      activationF: "est d\xE9stabilis\xE9e",
      actif: "est d\xE9stabilis\xE9 par une action de charme",
      actifF: "est d\xE9stabilis\xE9e par une action de charme",
      fin: "retrouve ses esprits",
      msgSave: "retrouver ses esprits",
      prejudiciable: true,
      visible: true
    },
    regeneration: {
      activation: "commence \xE0 se r\xE9g\xE9n\xE9rer",
      actif: "se r\xE9g\xE9n\xE8re",
      fin: "a fini de se r\xE9g\xE9n\xE9rer",
      soins: true,
      visible: true
    },
    arbreAnime: {
      activation: "commence \xE0 bouger",
      actif: "est un arbre anim\xE9",
      fin: "redevient un arbre ordinaire",
      visible: true
    },
    objetAnime: {
      activation: "commence \xE0 bouger",
      actif: "est un objet anim\xE9",
      fin: "redevient un objet ordinaire",
      visible: true
    },
    magnetisme: {
      activation: "contr\xF4le le magn\xE9tisme",
      actif: "contr\xF4le le magn\xE9tisme",
      fin: "relache son contr\xF4le du magn\xE9tisme"
    },
    hate: {
      activation: "voit son m\xE9tabolisme s'acc\xE9l\xE9rer",
      actif: "peut faire une action de plus par tour",
      fin: "retrouve un m\xE9tabolisme normal (plus d'action suppl\xE9mentaire)"
    },
    ailesCelestes: {
      activation: "sent des ailes c\xE9lestes lui pousser dans le dos",
      actif: "poss\xE8de des ailes c\xE9lestes",
      fin: "n'a plus d'aile c\xE9leste. Esp\xE9rons qu'il \xE9tait au sol...",
      finF: "n'a plus d'aile c\xE9leste. Esp\xE9rons qu'elle \xE9tait au sol...",
      visible: true
    },
    sanctuaire: {
      activation: "lance un sort de sanctuaire",
      actif: "est prot\xE9g\xE9 par un sanctuaire",
      actifF: "est prot\xE9g\xE9e par un sanctuaire",
      fin: "n'est plus prot\xE9g\xE9 par le sanctuaire",
      finF: "n'est plus prot\xE9g\xE9e par le sanctuaire"
    },
    rechargeSouffle: {
      activation: "doit maintenant attendre un peu avant de pouvoir le refaire",
      actif: "attend avant de pouvoir refaire un souffle",
      fin: "a r\xE9cup\xE9r\xE9"
    },
    paralysieRoublard: {
      activation: "est paralys\xE9 par la douleur",
      activationF: "est paralys\xE9e par la douleur",
      actif: "ne peut pas attaquer ni se d\xE9placer",
      fin: "peut \xE0 nouveau attaquer et se d\xE9placer",
      msgSave: "r\xE9sister \xE0 la douleur",
      prejudiciable: true,
      seulementVivant: true,
      visible: true,
      entrave: true
    },
    mutationOffensive: {
      activation: "\xE9change une partie de son corps avec celle d'une cr\xE9ature monstrueuse",
      actif: "poss\xE8de un appendice monstrueux",
      fin: "retrouve un corps normal",
      visible: true
    },
    formeDArbre: {
      activation: "se transorme en arbre",
      actif: "est transform\xE9 en arbre",
      actifF: "est transform\xE9e en arbre",
      fin: "retrouve sa forme normale",
      visible: true
    },
    statueDeBois: {
      activation: "se transforme en statue de bois",
      actif: "est transform\xE9 en statue de bois",
      actifF: "est transform\xE9e en statue de bois",
      fin: "retrouve sa forme normale",
      msgSave: "ne plus \xEAtre une statue de bois",
      prejudiciable: true,
      visible: true
    },
    clignotement: {
      activation: "dispara\xEEt, puis r\xE9appara\xEEt",
      actif: "clignote",
      fin: "ne dispara\xEEt plus",
      visible: true
    },
    agitAZeroPV: {
      activation: "continue \xE0 agir malgr\xE9 les blessures",
      actif: "devrait \xEAtre \xE0 terre",
      fin: "subit l'effet de ses blessures",
      visible: true
    },
    predateurConjure: {
      activation: "appara\xEEt depuis un autre plan",
      actif: "est un pr\xE9dateur conjur\xE9",
      fin: "dispara\xEEt",
      dm: true
    },
    champDeProtection: {
      activation: "devient prot\xE9g\xE9 par un champ t\xE9l\xE9kin\xE9tique",
      actif: "est prot\xE9g\xE9 par un champ t\xE9l\xE9kin\xE9tique",
      actifF: "est prot\xE9g\xE9e par un champ t\xE9l\xE9kin\xE9tique",
      fin: "n'est plus sous l'effet d'un champ de protection",
    },
    attaqueArmeeConjuree: {
      activation: "se bat contre une arm\xE9e conjur\xE9e",
      actif: "se bat contre une arm\xE9e conjur\xE9e",
      fin: "ne se bat plus contre l'arm\xE9e conjur\xE9e"
    },
    rechargeDuKiai: {
      activation: "pousse un kiai",
      actif: "ne peut pas encore pousser un autre kiai",
      fin: "peut pousser un autre kiai"
    },
    memePasMalBonus: {
      activation: "enrage suite au coup critique",
      actif: "a subit un coup critique",
      fin: "ne b\xE9n\xE9ficie plus des effets de m\xEAme pas mal"
    },
    attaqueRisquee: {
      activation: "fait une attaque risqu\xE9e",
      actif: "s'est mis en danger par une attaque risqu\xE9e",
      fin: "retrouve une position moins risqu\xE9e",
    },
    peauDePierreMag: {
      activation: "transforme sa peau en pierre",
      actif: "voit ses d\xE9g\xE2ts r\xE9duits par sa Peau de pierre",
      fin: "retrouve sa peau normale",
      visible: true
    },
    expose: {
      activation: "s'expose aux attaques de sa cible",
      actif: "est expos\xE9 aux attaques de son adversaire",
      actifF: "est expos\xE9e aux attaques de son adversaire",
      fin: "n'est plus expos\xE9",
      finF: "n'est plus expos\xE9e",
      msgSave: "ne plus s'exposer",
      prejudiciable: true
    },
    effetRetarde: {
      activation: "il va bient\xF4t se produire quelque chose",
      actif: "s'attend \xE0 un effet",
      fin: "effet retard\xE9 activ\xE9",
      generic: true,
      prejudiciable: true
    },
    messageRetarde: {
      activation: "il va bient\xF4t se produire quelque chose",
      actif: "s'attend \xE0 un effet",
      fin: "effet activ\xE9",
      generic: true
    },
    detectionDeLInvisible: {
      activation: "voit les choses invibles et cach\xE9es",
      actif: "d\xE9tecte l'invisible",
      fin: "ne voit plus les choses invisibles",
    },
    bonusAttaqueTemp: {
      activation: "affecte son attaque",
      actif: "a son attaque affect\xE9e",
      fin: "retrouve son attaque normale",
    },
    enerve: {
      activation: "est \xE9nerv\xE9 par ces railleries",
      activationF: "est \xE9nerv\xE9e par ces railleries",
      actif: "est \xE9nerv\xE9",
      actifF: "est \xE9nerv\xE9e",
      fin: "retrouve son calme",
      msgSave: "retrouver son calme",
      prejudiciable: true,
      visible: true
    },
    cercleDeProtection: {
      activation: "est prot\xE9g\xE9 par le Cercle de protection",
      activationF: "est prot\xE9g\xE9e par le Cercle de protection",
      actif: "est dans le Cercle de protection",
      fin: "sort du Cercle de protection",
    },
    tenebres: {
      activation: "lance un sort de T\xE9n\xE8bres",
      actif: "maintient un sort de T\xE9n\xE8bres",
      fin: "les t\xE9n\xE8bres se dissipent",
      visible: true
    },
    brumes: {
      activation: "lance un sort de brumes",
      actif: "maintient un sort de brumes",
      fin: "les brumes se dissipent",
      visible: true
    },
    progresserACouvert: {
      activation: "est \xE0 couvert de bouclier",
      actif: "est \xE0 couvert de bouclier",
      fin: "n'est plus \xE0 couvert de bouclier"
    },
    cyclone: {
      activation: "se transforme en tourbillon de mati\xE8re \xE9l\xE9mentaire",
      actif: "est en cyclone",
      fin: "retrouve sa forme habituelle",
      visible: true
    },
    momentDePerfection: {
      activation: "atteint un instant de perfection",
      actif: "semble tout voir au ralenti autour de lui",
      fin: "voit le temps reprendre son cours normal",
    },
    armeeDesMorts: {
      activation: "invoque d'innombrables squelettes \xE9mergeant du sol",
      actif: "invoque d'innombrables squelettes",
      fin: "laisse les morts en paix",
      visible: true
    },
    demonInvoque: {
      activation: "appara\xEEt depuis un autre plan",
      actif: "est un d\xE9mon invoqu\xE9",
      fin: "dispara\xEEt",
      dm: true
    },
    degradationZombie: {
      activation: "se rel\xE8ve d'entre les morts",
      actif: "est un zombie anim\xE9",
      fin: "tombe en poussi\xE8re",
      dm: true
    },
    hemorragie: {
      activation: "saigne \xE0 la moindre blessure",
      actif: "saigne \xE0 la moindre blessure",
      fin: "soigne son h\xE9morragie",
      msgSave: "gu\xE9rir de son h\xE9morragie",
      prejudiciable: true
    },
    lienDeSang: {
      activation: "est li\xE9 par le sang",
      activationF: "est li\xE9e par le sang",
      actif: "a un lien de sang",
      fin: "perd son lien de sang",
      msgSave: "ne plus \xEAtre li\xE9 par le sang",
      prejudiciable: true
    },
    tenirADistance: {
      activation: "utilise son allonge pour tenir ses ennemis \xE0 distance",
      actif: "utilise son allonge pour tenir ses ennemis \xE0 distance",
      fin: "ne tient plus ses ennemis \xE0 distance"
    },
    reactionViolente: {
      activation: "est pris de folie et attaque la personne qui s'est moqu\xE9e de lui",
      activationF: "est prise de folie et attaque la personne qui s'est moqu\xE9e d'elle",
      actif: "a une r\xE9action violente et doit attaquer",
      fin: "reprend son calme",
      msgSave: "r\xE9sister \xE0 la provocation",
      prejudiciable: true,
    },
    poisonAffaiblissantLatent: {
      activation: "sent qu'un poison commence \xE0 se r\xE9pandre dans ses veines",
      actif: "est empoisonn\xE9, mais l'effet du poison ne se fait pas encore sentir",
      actifF: "est empoisonn\xE9e, mais l'effet du poison ne se fait pas encore sentir",
      fin: "se sent faible",
      msgSave: "r\xE9sister au poison",
      prejudiciable: true,
      seulementVivant: true,
    },
  };

  function buildPatternEffets(listeEffets, postfix) {
    if (postfix && postfix.length === 0) postfix = undefined;
    let expression = "(";
    expression = _.reduce(listeEffets, function(reg, msg, effet) {
      let res = reg;
      if (res !== "(") res += "|";
      res += "^" + effet;
      if (msg.generic) res += "\\([^)_]*\\)";
      res += "(";
      if (postfix) {
        postfix.forEach(function(p, i) {
          if (i) res += "|";
          res += p + "$|" + p + "_";
        });
      } else res += "$|_";
      res += ")";
      return res;
    }, expression);
    expression += ")";
    return new RegExp(expression);
  }

  const patternEffetsTemp = buildPatternEffets(messageEffetTemp);

  function estEffetTemp(name) {
    return (patternEffetsTemp.test(name));
  }

  const patternAttributEffetsTemp =
    buildPatternEffets(messageEffetTemp, ['Puissant', 'Valeur', 'SaveParTour', 'SaveActifParTour', 'SaveParTourType', 'TempeteDeManaIntense', 'Options']);

  function estAttributEffetTemp(name) {
    return (patternAttributEffetsTemp.test(name));
  }

  //On sait d\xE9j\xE0 que le nom a pass\xE9 le test estEffetTemp
  function effetTempOfAttribute(attr) {
    let ef = attr.get('name');
    if (ef === undefined || messageEffetTemp[ef]) return ef;
    //D'abord on enl\xE8ve le nom du token
    let pu = ef.indexOf('_');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetTemp[ef]) return ef;
    }
    //Ensuite on enl\xE8ve les parties entre parenth\xE8se pour les effets g\xE9n\xE9riques
    pu = ef.indexOf('(');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetTemp[ef]) return ef;
    }
    error("Impossible de d\xE9terminer l'effet correspondant \xE0 " + ef, attr);
  }

  function messageOfEffetTemp(effetC) {
    let res = messageEffetTemp[effetC];
    if (res) return res;
    let p = effetC.indexOf('(');
    if (p > 0) {
      let ef = effetC.substring(0, p);
      res = messageEffetTemp[ef];
      return res;
    }
    error("Effet temporaire non trouv\xE9", effetC);
  }

  const messageEffetCombat = {
    a0PVDepuis: {
      activation: "est \xE0 0 PV",
      actif: "est \xE0 0 PV",
      fin: ""
    },
    armureMagique: {
      activation: "est entour\xE9 d'un halo magique",
      activationF: "est entour\xE9e d'un halo magique",
      actif: "est prot\xE9g\xE9 par une armure magique",
      actifF: "est prot\xE9g\xE9e par une armure magique",
      fin: "n'est plus entour\xE9 d'un halo magique",
      finF: "n'est plus entour\xE9e d'un halo magique"
    },
    armureDuMage: {
      activation: "fait appara\xEEtre un nuage magique argent\xE9 qui le prot\xE8ge",
      activationF: "fait appara\xEEtre un nuage magique argent\xE9 qui la prot\xE8ge",
      actif: "est entour\xE9 d'une armure du mage",
      actifF: "est entour\xE9e d'une armure du mage",
      fin: "n'a plus son armure du mage"
    },
    armureDEau: {
      activation: "fait appara\xEEtre une couche d'eau de quelques centim\xE8tres qui le prot\xE8ge",
      activationF: "fait appara\xEEtre une couche d'eau de quelques centim\xE8tres qui la prot\xE8ge",
      actif: "est entour\xE9 d'une armure d'eau'",
      actifF: "est entour\xE9e d'une armure d'eau'",
      fin: "n'a plus son armure d'eau'"
    },
    armeDArgent: {
      activation: "cr\xE9e une arme d'argent et de lumi\xE8re",
      actif: "poss\xE8de une arme d'argent et de lumi\xE8re",
      fin: "ne poss\xE8de plus d'arme d'argent et de lumi\xE8re",
      dm: true
    },
    attaqueAOutrance: {
      activation: "attaque \xE0 outrance",
      actif: "attaque \xE0 outrance",
      fin: "attaque normalement",
    },
    bonusInitEmbuscade: { //Effet interne pour la capacit\xE9 Surveillance
      activation: "a un temps d'avance en cas d'embuscade",
      actif: "a un temps d'avance",
      fin: ""
    },
    criDeGuerre: {
      activation: "pousse son cri de guerre",
      actif: "a effray\xE9 ses adversaires",
      fin: ""
    },
    criDuPredateur: {
      activation: "pousse un hurlement effrayant",
      actif: "a lib\xE9r\xE9 son \xE2me de pr\xE9dateur",
      fin: ""
    },
    danseDesLames: {
      activation: "entre en transe",
      actif: "danse la danse des lames",
      fin: "termine sa danse des lames"
    },
    enflamme: {
      activation: "prend feu !",
      actif: "est en feu",
      fin: "les flammes s'\xE9teignent",
      dm: true,
      statusMarker: 'red',
    },
    enrage: {
      activation: "devient enrag\xE9",
      activationF: "devient enrag\xE9e",
      actif: "est enrag\xE9",
      actifF: "est enrag\xE9e",
      fin: "retrouve son calme",
      msgSave: "retrouver son calme",
    },
    fureurDrakonideCritique: {
      activation: "est rendu furieux par le coup critique",
      activationF: "est rendue furieuse par le coup critique",
      actif: "est en furie draconide",
      fin: "retrouve son calme"
    },
    protectionContreLeMal: {
      activation: "re\xE7oit une b\xE9n\xE9diction de protection contre le mal",
      actif: "est prot\xE9g\xE9 contre le mal",
      actifF: "est prot\xE9g\xE9e contre le mal",
      fin: "n'est plus prot\xE9g\xE9 contre le mal",
      finF: "n'est plus prot\xE9g\xE9e contre le mal",
    },
    putrefactionOutreTombe: {
      activation: "sent ses chairs pourrir",
      actif: "subit le contrecoup d'une putr\xE9faction",
      fin: "se remet de la putr\xE9faction",
      msgSave: "ne plus \xEAtre putr\xE9fi\xE9",
      prejudiciable: true,
      dm: true
    },
    rage: {
      activation: "entre en rage",
      actif: "est en rage",
      fin: "retrouve son calme",
      msgSave: "retrouver son calme",
    },
    rageDuBerserk: {
      activation: "entre dans une rage berserk",
      actif: "est dans une rage berserk",
      fin: "retrouve son calme",
      msgSave: "retrouver son calme",
    },
    bonusInitVariable: {
      activation: "entre en combat",
      actif: "est en combat",
      fin: ''
    },
    defiSamourai: {
      activation: "lance un d\xE9fi",
      actif: "a lanc\xE9 un d\xE9fi",
      fin: ''
    },
    agrippe: {
      activation: "agrippe sa cible",
      actif: "agrippe sa cible",
      fin: "lache sa cible"
    },
    estAgrippePar: {
      activation: "est agripp\xE9",
      activationF: "est agripp\xE9e",
      actif: "est agripp\xE9",
      actifF: "est agripp\xE9e",
      fin: "se lib\xE8re",
      msgSave: "se lib\xE9rer",
      entrave: true
    },
    devore: {
      activation: "saisit sa cible",
      actif: "saisit sa cible",
      fin: "lache sa cible",
    },
    estDevorePar: {
      activation: "est saisi",
      activationF: "est saisie",
      actif: "est saisi",
      actifF: "est saisie",
      fin: "se lib\xE8re",
      msgSave: "se lib\xE9rer",
      entrave: true
    },
    ecrase: {
      activation: "saisit sa cible entre ses bras",
      actif: "saisit sa cible entre ses bras",
      fin: "lache sa cible",
    },
    estEcrasePar: {
      activation: "est saisi",
      activationF: "est saisie",
      actif: "est saisi",
      actifF: "est saisie",
      fin: "se lib\xE8re",
      msgSave: "se lib\xE9rer",
      entrave: true
    },
    aGobe: {
      activation: "avale sa cible",
      actif: "a aval\xE9 une cr\xE9ature vivante",
      fin: "dig\xE8re sa cible"
    },
    estGobePar: {
      activation: "est aval\xE9",
      activationF: "est aval\xE9e",
      actif: "est dans le ventre d'une cr\xE9ature",
      fin: "fin de la digestion, sort du ventre",
      msgSave: "sortir du ventre",
      entrave: true
    },
    inconfort: {
      activation: "commence \xE0 \xEAtre g\xEAn\xE9 par son armure",
      activationF: "commence \xE0 \xEAtre g\xEAn\xE9e par son armure",
      actif: "est g\xEAn\xE9 par son armure",
      actifF: "est g\xEAn\xE9e par son armure",
      fin: "r\xE9ajuste son armure",
    },
    noyade: {
      activation: "commence \xE0 se noyer",
      actif: "se noie",
      fin: "peut \xE0 nouveau respirer",
      msgSave: "surnager",
      prejudiciable: true,
      seulementVivant: true,
      dm: true,
      visible: true
    },
    blessureQuiSaigne: {
      activation: "re\xE7oit une blessure qui saigne",
      actif: "saigne \xE0 cause d'une blessure",
      fin: "saigne beaucoup moins",
      msgSave: "ne plus saigner",
      prejudiciable: true,
      dm: true
    },
    poisonAffaiblissant: {
      activation: "sent le poison ralentir ses mouvements",
      actif: "est empoisonn\xE9",
      actifF: "est empoisonn\xE9e",
      fin: "le poison n'agit plus",
      msgSave: "r\xE9sister au poison",
      prejudiciable: true,
      seulementVivant: true,
    },
  };

  const patternEffetsCombat = buildPatternEffets(messageEffetCombat);

  function estEffetCombat(name) {
    return (patternEffetsCombat.test(name));
  }

  const patternAttributEffetsCombat =
    buildPatternEffets(messageEffetCombat, ['Puissant', 'Valeur', 'SaveParTour', 'SaveActifParTour', 'SaveParTourType', 'TempeteDeManaIntense', 'Options']);

  function estAttributEffetCombat(name) {
    return (patternAttributEffetsCombat.test(name));
  }

  function effetCombatOfAttribute(attr) {
    let ef = attr.get('name');
    if (ef === undefined || messageEffetCombat[ef]) return ef;
    //D'abord on enl\xE8ve le nom du token
    let pu = ef.indexOf('_');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetCombat[ef]) return ef;
    }
    error("Impossible de d\xE9terminer l'effet correspondant \xE0 " + ef, attr);
  }

  // Si un effet est prejudiciable, enlev\xE9 par d\xE9livrance
  const messageEffetIndetermine = {
    armesNaturelles: {
      activation: "se fait pousser griffes et crocs",
      actif: "a des griffes et des crocs",
      fin: "n'a plus de griffes et crocs visibles"
    },
    charme: {
      activation: "devient un ami de longue date",
      activationF: "devient une amie de longue date",
      actif: "est sous le charme de quelqu'un",
      fin: "retrouve ses esprits",
      prejudiciable: true
    },
    conditionsHostiles: {
      activation: "se trouve dans des conditions hostiles",
      actif: "est en conditions hostiles",
      fin: "retrouve des conditions normales",
    },
    fievreux: {
      activation: "se sent fi\xE9vreux",
      activationF: "se sent fi\xE9vreuse",
      actif: "est fi\xE9vreux",
      actifF: "est fi\xE9vreuse",
      fin: "se sent mieux",
      prejudiciable: true
    },
    foretVivanteEnnemie: {
      activation: "est g\xEAn\xE9 par la for\xEAt",
      activationF: "est g\xEAn\xE9e par la for\xEAt",
      actif: "est d\xE9sorient\xE9 par la for\xEAt",
      actifF: "est d\xE9sorient\xE9e par la for\xEAt",
      fin: "se retrouve dans une for\xEAt normale",
      entrave: true
    },
    grandeTaille: {
      activation: "devient aussi grand qu'un humain",
      activationF: "devient aussi grande qu'une humaine",
      actif: "est grand comme un humain",
      actifF: "est grande comme une humaine",
      fin: "retrouve sa taille normale"
    },
    lameDeLigneePerdue: {
      activation: "perd sa lame de lign\xE9e",
      actif: "a perdu sa lame de lign\xE9e",
      fin: "retrouve sa lame de lign\xE9e",
    },
    marcheSylvestre: {
      activation: "se deplace maintenant en terrain difficile",
      actif: "profite du terrain difficile",
      fin: "est maintenant en terrain normal"
    },
    mutationCuirasse: {
      activation: "endurcit sa peau",
      actif: "a la peau recouverte d'une cuirasse",
      fin: "retrouve une peau normale"
    },
    mutationEcaillesRouges: {
      activation: "recouvre sa peau d'\xE9cailles rouges",
      actif: "a la peau recouverte d'\xE9cailles rouges",
      fin: "retrouve une peau normale"
    },
    mutationFourrureViolette: {
      activation: "se fait pousser une fourrure violette",
      actif: "a la peau recouverte d'une fourrure violette",
      fin: "retrouve une peau normale"
    },
    mutationMusclesHypertrophies: {
      activation: "devient plus muscl\xE9",
      activationF: "devient plus muscl\xE9e",
      actif: "a les muscles hypertrophi\xE9s",
      fin: "retrouve des muscles normaux",
    },
    mutationOuies: {
      activation: "se fait pousser des ou\xEFes",
      actif: "poss\xE8de des ou\xEFes",
      fin: "n'a plus d'ou\xEFes"
    },
    mutationSangNoir: {
      activation: "prend un teint plus sombre",
      actif: "a le sang noir",
      fin: "retrouve un sang normal"
    },
    mutationSilhouetteFiliforme: {
      activation: "devient plus fin",
      activationF: "devient plus fine",
      actif: "a une silhouette filiforme",
      fin: "retrouve une silhouette normale",
    },
    mutationSilhouetteMassive: {
      activation: "devient plus massif",
      activationF: "devient plus massive",
      actif: "a une silhouette massive",
      fin: "retrouve une silhouette normale",
    },
    presenceGlaciale: {
      activation: "transforme son corps en glace vivante",
      actif: "est form\xE9 de glace",
      actifF: "est form\xE9e de glace",
      fin: "retrouve un corps normal",
    },
    sixiemeSens: {
      activation: "fait un rituel de divination",
      actif: "sait un peu \xE0 l'avance ce qu'il va se passer",
      fin: "l'effet du rituel de divination prend fin",
    },
    constructionTailleHumaine: {
      activation: "rentre dans une construction de taille humaine.",
      actif: "est un peu \xE0 l'\xE9troit, le b\xE2timent est trop petit",
      fin: "sort de la construction de taille humains."
    },
    espaceExigu: {
      activation: "entre dans un espace exigu.",
      actif: "est \xE0 l'\xE9troit.",
      fin: "sort de l'espace exigu."
    },
    sangDeLArbreCoeur: {
      activation: "boit une potion de Sang de l'Arbre-Coeur",
      actif: "a bu une potion de Sang de l'Arbre-Coeur",
      fin: "les effets de la potion de Sang de l'Arbre-Coeur diminuent un peu"
    },
    ondesCorruptrices: { //nombre, \xE0 mettre avec !cof-effet ondesCorruptrices 2
      activation: "se sent naus\xE9eux",
      activationF: "se sent naus\xE9euse",
      actif: "se sent naus\xE9eux",
      actifF: "se sent naus\xE9euse",
      fin: "se sent un peu mieux",
      prejudiciable: true
    },
    reactionAllergique: {
      activation: "ressent de fortes d\xE9mangeaisons",
      actif: "est victime d'une r\xE9action allergique",
      fin: "les d\xE9mangeaisons cessent",
      prejudiciable: true
    },
    poisonAffaiblissantLong: {
      activation: "sent le poison ralentir ses mouvements",
      actif: "est empoisonn\xE9",
      actifF: "est empoisonn\xE9e",
      fin: "le poison n'agit plus",
      msgSave: "r\xE9sister au poison",
      prejudiciable: true,
      seulementVivant: true,
    },
  };

  const patternEffetsIndetermine = buildPatternEffets(messageEffetIndetermine);

  function estEffetIndetermine(name) {
    return (patternEffetsIndetermine.test(name));
  }

  function effetIndetermineOfAttribute(attr) {
    let ef = attr.get('name');
    if (ef === undefined || messageEffetIndetermine[ef]) return ef;
    //D'abord on enl\xE8ve le nom du token
    let pu = ef.indexOf('_');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetIndetermine[ef]) return ef;
    }
    error("Impossible de d\xE9terminer l'effet correspondant \xE0 " + ef, attr);
  }

  function attributeExtending(charId, attrName, effetC, extension) {
    let nameWithExtension = effetC + extension + attrName.substr(effetC.length);
    return findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: nameWithExtension
    });
  }

  //L'argument effetC doit \xEAtre le nom complet, pas la base
  //evt.deletedAttributes doit \xEAtre d\xE9fini
  function enleverEffetAttribut(charId, effetC, attrName, extension, evt) {
    let attrSave = attributeExtending(charId, attrName, effetC, extension);
    attrSave.
    forEach(function(attrS) {
      evt.deletedAttributes.push(attrS);
      attrS.remove();
    });
  }

  //Nom de l'effet, avec la partie g\xE9n\xE9rique, mais sans le nom de token
  function effetComplet(effet, attrName) {
    if (effet == attrName) return effet;
    //On a un effet li\xE9 \xE0 un token ou bien un effet g\xE9n\xE9rique
    if (attrName.charAt(effet.length) == '(') {
      let p = attrName.indexOf(')', effet.length);
      if (p > 0) return attrName.substring(0, p + 1);
    }
    return effet;
  }

  function rollAndDealDmg(perso, dmg, type, effet, attrName, msg, count, evt, options, callback, display) {
    if (options.valeur) {
      let attrsVal = tokenAttribute(perso, options.valeur);
      if (attrsVal.length > 0) {
        dmg = attrsVal[0].get('current');
        let dmgDice = parseDice(dmg);
        if (dmgDice) {
          if (dmgDice.nbDe === 0) dmg = {
            cst: dmgDice.bonus
          };
          else if (dmgDice.bonus === 0) dmg = {
            de: dmgDice.dice,
            nbDe: dmgDice.nbDe
          };
        }
      }
    }
    let dmgExpr = dmg;
    let tdmi = attributeAsInt(perso, effet + 'TempeteDeManaIntense', 0);
    if (dmg.de) {
      if (tdmi) {
        dmgExpr = (tdmi + dmg.nbDe) + 'd' + dmg.de;
        removeTokenAttr(perso, effet + 'TempeteDeManaIntense', evt);
      } else dmgExpr = dmg.nbDe + 'd' + dmg.de;
    } else if (dmg.cst) {
      if (tdmi) {
        dmgExpr = dmg.cst * (1 + tdmi);
        removeTokenAttr(perso, effet + 'TempeteDeManaIntense', evt);
      } else dmgExpr = dmg.cst;
    } else if (options.dotGen) {
      //alors dmg = '' et type = ''
      let valAttr = tokenAttribute(perso, effet + 'Valeur');
      if (valAttr.length === 0) {
        //Par d\xE9faut, 1d6 DM normaux
        dmgExpr = "1d6";
        type = 'normal';
      } else {
        dmgExpr = valAttr[0].get('current');
        type = valAttr[0].get('max');
        if (type === '') type = 'normal';
      }
    }
    let optionsAttr = tokenAttribute(perso, effet + 'Options');
    optionsAttr.forEach(function(oAttr) {
      parseDmgOptions(oAttr.get('current'), options);
    });
    copyDmgOptionsToTarget(perso, options);
    sendChat('', "[[" + dmgExpr + "]]", function(res) {
      let rolls = res[0];
      let dmgRoll = rolls.inlinerolls[0];
      let r = {
        total: dmgRoll.results.total,
        type: type,
        display: buildinline(dmgRoll, type)
      };
      let explications;
      if (display) explications = [];
      if (options.saignement) {
        let sourceDrain = saignementAvecDrain(perso, effet);
        r.drainDeSang = sourceDrain;
      }
      dealDamage(perso, r, [], evt, false, options, explications,
        function(dmgDisplay, dmg) {
          if (dmg > 0) {
            let msgDm;
            if (msg) msgDm = msg + '. ' + onGenre(perso, 'Il', 'Elle');
            else msgDm = '';
            if (display) {
              explications.forEach(function(m) {
                addLineToFramedDisplay(display, m);
              });
              addLineToFramedDisplay(display, nomPerso(perso) + ' ' + msgDm + " subit " + dmgDisplay + " DM");
              sendChat('', endFramedDisplay(display));
            } else if (effet == attrName) {
              sendPerso(perso, msgDm + " subit " + dmgDisplay + " DM");
            } else {
              let tokenName = attrName.substring(attrName.indexOf('_') + 1);
              sendChat('', tokenName + ' ' + msgDm + " subit " + dmgDisplay + " DM");
            }
          }
          count.v--;
          if (count.v === 0) callback();
        });
    }); //fin sendChat du jet de d\xE9
  }

  //asynchrone
  // effet est le nom complet de l'effet
  function degatsParTour(charId, pageId, effet, attrName, dmg, type, msg, evt, options, callback) {
    options = options || {};
    let count;
    iterTokensOfAttribute(charId, pageId, effet, attrName,
      function(token, total) {
        if (count === undefined) count = {
          v: total
        };
        let perso = {
          token,
          charId
        };
        if (getState(perso, 'mort')) {
          if (callback) callback();
          return;
        }
        if (options.save) {
          let playerId = getPlayerIds(perso);
          let nameEffet = effet;
          if (effet.startsWith('dotGen('))
            nameEffet = effet.substring(7, effet.indexOf(')'));
          let display = startFramedDisplay(playerId, "Effet de " + nameEffet, perso);
          let saveId = "degatsParTour_" + effet + "_" + token.id;
          let expliquer = function(m) {
            addLineToFramedDisplay(display, m);
          };
          let msgPour = " pour ne pas prendre de d\xE9g\xE2ts de " + nameEffet;
          let sujet = onGenre(perso, 'il', 'elle');
          let msgReussite = ", " + sujet + " ne perd pas de PV ce tour";
          let saveOpts = {
            msgPour: msgPour,
            msgReussite: msgReussite,
            rolls: options.rolls,
            chanceRollId: options.chanceRollId,
            type: type
          };
          save(options.save, perso, saveId, expliquer, saveOpts, evt, function(reussite, texte) {
            if (reussite) {
              sendChat('', endFramedDisplay(display));
              return;
            }
            rollAndDealDmg(perso, dmg, type, effet, attrName, msg, count, evt, options, callback, display);
          });
          return;
        }
        rollAndDealDmg(perso, dmg, type, effet, attrName, msg, count, evt, options, callback);
      }); //fin iterTokensOfAttribute
  }

  //asynchrone
  function soigneParTour(charId, pageId, effet, attrName, soinsExpr, msg, evt, options, callback) {
    options = options || {};
    msg = msg || '';
    let count = -1;
    iterTokensOfAttribute(charId, pageId, effet, attrName,
      function(token, total) {
        if (count < 0) count = total;
        const perso = {
          token: token,
          charId: charId
        };
        let tdmi = attributeAsInt(perso, effet + "TempeteDeManaIntense", 0);
        if (tdmi) {
          soinsExpr = "(" + soinsExpr + ")*" + (1 + tdmi);
          removeTokenAttr(perso, effet + "TempeteDeManaIntense", evt);
        }
        let localSoinsExpr = soinsExpr;
        if (options.valeur) {
          let attrsVal = tokenAttribute(perso, options.valeur);
          if (attrsVal.length > 0) localSoinsExpr = attrsVal[0].get('current');
        }
        sendChat('', "[[" + localSoinsExpr + "]]", function(res) {
          let rolls = res[0];
          let soinRoll = rolls.inlinerolls[0];
          let soins = soinRoll.results.total;
          let displaySoins = buildinline(soinRoll, 'normal', true);
          soigneToken(perso, soins, evt,
            function(s) {
              if (s < soins) sendPerso(perso, "r\xE9cup\xE8re tous ses PV.");
              else sendPerso(perso, "r\xE9cup\xE8re " + displaySoins + " PV.");
              count--;
              if (count === 0) callback();
            },
            function() {
              count--;
              if (count === 0) callback();
            });
        }); //fin sendChat du jet de d\xE9
      }); //fin iterTokensOfAttribute
  }

  function getEffectOptions(perso, effet) {
    let options = {};
    let optionsAttr = tokenAttribute(perso, effet + 'Options');
    optionsAttr.forEach(function(oAttr) {
      parseDmgOptions(oAttr.get('current'), options);
    });
    copyDmgOptionsToTarget(perso, options);
    return options;
  }

  // gestion des effets qui se d\xE9clenchent \xE0 la fin de chaque tour
  // N'ajoute pas evt \xE0 l'historique
  // Asynchrone (\xE0 cause des saves par tour)
  function changementDeTour(tour, attrs, evt, combat, pageId, options) {
    // Enlever les bonus d'un tour
    attrs = removeAllAttributes('limiteParTour', evt, attrs);
    attrs = removeAllAttributes('actionConcertee', evt, attrs);
    attrs = removeAllAttributes('interposer', evt, attrs);
    attrs = removeAllAttributes('exemplaire', evt, attrs);
    attrs = removeAllAttributes('attaqueMalgreMenace', evt, attrs);
    attrs = removeAllAttributes('prescienceUtilisee', evt, attrs);
    attrs = removeAllAttributes('increvableHumainUtilise', evt, attrs);
    resetAttr(attrs, 'cercleDeProtectionActif', evt);
    // Pour d\xE9faut dans la cuirasse, on diminue si la valeur est 2, et on supprime si c'est 1
    let defautsDansLaCuirasse = allAttributesNamed(attrs, 'defautDansLaCuirasse');
    defautsDansLaCuirasse.forEach(function(attr) {
      if (attr.get('current') < 2) {
        if (evt.deletedAttributes) evt.deletedAttributes.push(attr);
        else evt.deletedAttributes = [attr];
        attr.remove();
      } else {
        let prevAttr = {
          attribute: attr,
          current: 2
        };
        evt.attributes.push(prevAttr);
        attr.set('current', 1);
      }
    });
    // Pour la feinte, on augmente la valeur, et on supprime si la valeur est 2
    let feinte = allAttributesNamed(attrs, 'feinte');
    feinte.forEach(function(attr) {
      let valFeinte = parseInt(attr.get('current'));
      if (isNaN(valFeinte) || valFeinte > 0) {
        evt.deletedAttributes.push(attr);
        attr.remove();
      } else {
        let prevAttr = {
          attribute: attr,
          current: 0
        };
        evt.attributes.push(prevAttr);
        attr.set('current', 1);
      }
    });
    //Les tests rat\xE9s
    let trTour = allAttributesNamed(attrs, 'testsRatesDuTour');
    trTour.forEach(function(tr) {
      let curTr = tr.get('current');
      if (curTr === '') {
        evt.deletedAttributes.push(tr);
        tr.remove();
      } else {
        let maxTr = tr.get('max');
        evt.attributes.push({
          attribute: tr,
          current: curTr,
          max: maxTr
        });
        tr.set('max', curTr);
        tr.set('current', '');
      }
    });
    let vapeth = allAttributesNamed(attrs, 'vapeursEthyliques');
    vapeth.forEach(function(attr) {
      let ve = parseInt(attr.get('current'));
      if (isNaN(ve)) ve = 0;
      evt.attributes.push({
        attribute: attr,
        current: 0
      });
      attr.set('current', ve + 1);
      let veCharId = attr.get('characterid');
      if (veCharId === undefined || veCharId === '') {
        error("Attribut sans personnage associ\xE9", attr);
        return;
      }
      let veSeuil = parseInt(attr.get('max'));
      if (isNaN(veSeuil)) veSeuil = 0;
      veSeuil -= Math.floor(ve / 2);
      iterTokensOfAttribute(veCharId, combat.pageId,
        'vapeursEthyliques', attr.get('name'),
        function(tok) {
          let perso = {
            charId: veCharId,
            token: tok
          };
          let testId = 'vapeursEthyliques_' + perso.token.id;
          testCaracteristique(perso, 'CON', veSeuil, testId, options, evt, function(testRes) {
            let res = "tente un jet de CON " + veSeuil + " pour combattre les vapeurs \xE9thyliques " + testRes.texte;
            if (testRes.reussite) {
              res += " => r\xE9ussi." + testRes.modifiers;
              let expliquer;
              if (attr.get('name') == 'vapeursEthyliques') {
                expliquer = function(s) {
                  sendChar(veCharId, s, true);
                };
              } else {
                expliquer = function(s) {
                  sendChat('', nomPerso(perso) + ' ' + s);
                };
              }
              expliquer(res);
              diminueEbriete(perso, evt, expliquer);
            } else {
              res += " => rat\xE9" + testRes.rerolls + testRes.modifiers;
              sendPerso(perso, res);
            }
          });
        });
    });
    // nouveau tour : enlever le statut surpris
    // et faire les actions de d\xE9but de tour
    let selected = [];
    updateNextInitSet.forEach(function(id) {
      selected.push({
        _id: id
      });
    });
    let allTokens = findObjs({
      _type: 'graphic',
      _subtype: 'token',
      _pageid: pageId,
      layer: 'objects'
    });
    let allPersos = [];
    allTokens.forEach(function(token) {
      let charId = token.get('represents');
      if (charId === '') return;
      let c = getObj('character', charId);
      if (c === undefined) {
        token.remove();
        return;
      }
      allPersos.push({
        token,
        charId
      });
    });
    allPersos.forEach(function(perso) {
      if (getState(perso, 'surpris')) { //surprise
        setState(perso, 'surpris', false, {});
        selected.push({
          _id: perso.token.id
        });
      }
      if (getState(perso, 'enseveli')) {
        let degats = rollDePlus(6, {
          nbDes: 2
        });
        let dmg = {
          type: 'magique',
          total: degats.val,
          display: degats.roll
        };
        dealDamage(perso, dmg, [], evt, false, {}, undefined,
          function(dmgDisplay, dmgFinal) {
            sendPerso(perso, " est \xE9cras\xE9 ! " +
              onGenre(perso, 'Il', 'Elle') + " subit " + dmgDisplay + " DM");
          });
      }
      let enflammeAttr = tokenAttribute(perso, 'enflamme');
      if (enflammeAttr.length > 0) {
        let enflamme = parseInt(enflammeAttr[0].get('current'));
        // Pour ne pas faire les d\xE9g\xE2ts plusieurs fois (plusieurs tokens pour un m\xEAme personnage), on utilise la valeur max de l'attribut
        let dernierTourEnflamme = parseInt(enflammeAttr[0].get('max'));
        if ((isNaN(dernierTourEnflamme) || dernierTourEnflamme < tour) &&
          !isNaN(enflamme) && enflamme > 0) {
          let optFlammes = {
            resultatDesSeuls: true,
            bonus: enflamme - 1
          };
          let {
            val,
            roll
          } = rollDePlus(6, optFlammes);
          let d6Enflamme = optFlammes.resultatDesSeuls;
          let dmgEnflamme = {
            type: 'feu',
            total: val,
            display: roll
          };
          if (getState(perso, 'mort')) {
            sendChat('', "Le cadavre de " + nomPerso(perso) + " continue de br\xFBler");
          } else {
            dealDamage(perso, dmgEnflamme, [], evt, false, {}, undefined,
              function(dmgDisplay, dmgFinal) {
                sendPerso(perso, " est en flamme ! " +
                  onGenre(perso, 'Il', 'Elle') + " subit " + dmgDisplay + " DM");
              });
          }
          if (d6Enflamme < 3) {
            sendPerso(perso, ": les flammes s'\xE9teignent");
            removeTokenAttr(perso, 'enflamme', evt);
            let ms = messageEffetCombat.enflamme.statusMarker;
            if (ms) {
              affectToken(perso.token, 'statusmarkers', perso.token.get('statusmarkers'), evt);
              perso.token.set('status_' + ms, false);
            }
          } else {
            enflammeAttr[0].set('max', tour);
          }
        }
      }
      if (attributeAsBool(perso, 'estGobePar') && !getState(perso, 'mort')) {
        let jet = rollDePlus(6, {
          nbDes: 3
        });
        let dmg = {
          type: 'normal', //correspond \xE0 de l'asphyxie
          total: jet.val,
          display: jet.roll
        };
        if (immuniseAsphyxie(perso)) dmg.type = 'acide';
        dealDamage(perso, dmg, [], evt, false, {}, undefined,
          function(dmgDisplay, dmgFinal) {
            sendPerso(perso, "est en train d'\xEAtre dig\xE9r\xE9. " + onGenre(perso, 'Il', 'Elle') + " perd " + dmgDisplay + " PVs");
          });
      }
      if (attributeAsBool(perso, 'blessureQuiSaigne') &&
        !getState(perso, 'mort') &&
        !predicateAsBool(perso, 'immuniteSaignement') &&
        !predicateAsBool(perso, 'controleSanguin')) {
        let jetSaignement = rollDePlus(6);
        let dmgSaignement = {
          type: 'normal',
          total: jetSaignement.val,
          display: jetSaignement.roll
        };
        let optDMSaignements = getEffectOptions(perso, 'blessureQuiSaigne');
        dealDamage(perso, dmgSaignement, [], evt, false, optDMSaignements, undefined,
          function(dmgDisplay, dmgFinal) {
            sendPerso(perso, "saigne. " + onGenre(perso, 'Il', 'Elle') + " perd " + dmgDisplay + " PVs");
          });
      }
      if (attributeAsBool(perso, 'noyade') && !getState(perso, 'mort') && !immuniseAsphyxie(perso)) {
        let playerId = getPlayerIds(perso);
        let display = startFramedDisplay(playerId, "Noyade", perso);
        let saveId = "Noyade_" + perso.token.id;
        let expliquer = function(m) {
          addLineToFramedDisplay(display, m);
        };
        let msgPour = " pour ne pas prendre de d\xE9g\xE2ts de noyade";
        let sujet = onGenre(perso, 'il', 'elle');
        let msgReussite = ", " + sujet + " ne perd pas de PV ce tour";
        let saveOpts = {
          msgPour: msgPour,
          msgReussite: msgReussite,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: 'normal'
        };
        let saveNoyade = {
          carac: 'CON',
          seuil: 15
        };
        save(saveNoyade, perso, saveId, expliquer, saveOpts, evt, function(reussite, texte) {
          if (reussite) {
            sendChat('', endFramedDisplay(display));
            return;
          }
          let jetNoyade = rollDePlus(6);
          let dmNoyade = {
            type: 'normal',
            total: jetNoyade.val,
            display: jetNoyade.roll
          };
          let explications = [];
          dealDamage(perso, dmNoyade, [], evt, false, options, explications,
            function(dmgDisplay, dmg) {
              explications.forEach(function(m) {
                addLineToFramedDisplay(display, m);
              });
              addLineToFramedDisplay(display, nomPerso(perso) + "se noie et subit " + dmgDisplay + " DM");
              sendChat('', endFramedDisplay(display));
            });
        });
      }
      let vitaliteSurnaturelle = predicateAsBool(perso, 'vitaliteSurnaturelle');
      if (vitaliteSurnaturelle) {
        let indexType = vitaliteSurnaturelle.indexOf('/');
        let vitaliteSurnat = vitaliteSurnaturelle;
        if (indexType > 0)
          vitaliteSurnat = vitaliteSurnat.substring(0, indexType);
        vitaliteSurnat = vitaliteSurnat.trim();
        let regenereMemeMort;
        if ((vitaliteSurnat + '').endsWith('+')) {
          vitaliteSurnat = vitaliteSurnat.substr(0, vitaliteSurnat.length - 1);
          regenereMemeMort = true;
        }
        if (regenereMemeMort || !getState(perso, 'mort')) {
          vitaliteSurnat = parseInt(vitaliteSurnat);
          if (vitaliteSurnat > 0) {
            let saufDMType;
            if (indexType > 0 && indexType < vitaliteSurnaturelle.length - 1)
              saufDMType = vitaliteSurnaturelle.substring(indexType + 1).split(',');
            soigneToken(perso, vitaliteSurnat, evt,
              function(s) {
                whisperChar(perso.charId, 'r\xE9cup\xE8re ' + s + ' PVs.');
              },
              function() {}, {
                saufDMType
              }
            );
          }
        }
      }
      if (attributeAsBool(perso, 'sangDeLArbreCoeur') && !getState(perso, 'mort')) {
        soigneToken(perso, 5, evt,
          function(s) {
            whisperChar(perso.charId, "r\xE9g\xE9n\xE8re " + s + " PVs. (gr\xE2ce \xE0 la potion de sang de l'Arbre Coeur)");
          },
          function() {}
        );
      }
      let increvableActif = tokenAttribute(perso, 'increvableActif');
      if (increvableActif.length > 0) {
        increvableActif[0].remove();
        let soins = randomInteger(6) + randomInteger(6) + randomInteger(6) + modCarac(perso, 'constitution');
        soigneToken(perso, soins, evt, function(soinsEffectifs) {
          let msgSoins = "est increvable et r\xE9cup\xE8re ";
          if (soinsEffectifs == soins) msgSoins += soins + " points de vie";
          else msgSoins += soinsEffectifs + " PV (le jet \xE9tait " + soins + ")";
          whisperChar(perso.charId, msgSoins);
        });
      }
      let degradationZombie = attributeAsInt(perso, 'degradationZombie', -1);
      if (degradationZombie % 6 === 0) {
        let r = {
          total: 1,
          type: 'normal',
          display: 1
        };
        perso.ignoreTouteRD = true;
        dealDamage(perso, r, [], evt, false, {}, [], function() {
          // V\xE9rification si le Zombie est toujours vivant
          let token = getObj('graphic', perso.token.id);
          if (token) whisperChar(perso.charId, "se d\xE9grade et perd 1 PV");
        });
      }
    });
    setActiveToken(combat, undefined, evt);
    initiative(selected, evt, true); // met Tour \xE0 la fin et retrie
    updateNextInitSet = new Set();
    // Saves \xE0 faire \xE0 la fin de chaque tour. Asynchrone, mais pas grave ?
    attrs.forEach(function(attr) {
      let attrName = attr.get('name');
      let indexSave = attrName.indexOf('SaveParTour');
      if (indexSave < 0) return;
      let indexSaveType = attrName.indexOf('SaveParTourType');
      if (indexSaveType > 0) return;
      let effetC = attrName.substring(0, indexSave);
      let effetTemp = estEffetTemp(effetC);
      if (!cof_states[effetC] && !effetTemp && !estEffetCombat(effetC)) return;
      let carac = attr.get('current');
      if (!isCarac(carac)) {
        error("Save par tour " + attrName + " mal form\xE9", carac);
        return;
      }
      let seuil = parseInt(attr.get('max'));
      if (isNaN(seuil)) {
        error("Save par tour " + attrName + " mal form\xE9", seuil);
        return;
      }
      let charId = attr.get('characterid');
      attrName = effetC + attrName.substr(indexSave + 11);
      let token;
      iterTokensOfAttribute(charId, pageId, effetC, attrName, function(tok) {
        if (token === undefined) token = tok;
      });
      if (token === undefined) {
        log("Pas de token pour le save " + attrName);
        return;
      }
      const perso = {
        token: token,
        charId: charId
      };
      if (getState(perso, 'mort')) {
        return;
      }
      let expliquer = function(msg) {
        sendPerso(perso, msg);
      };
      let met;
      if (effetTemp) met = messageOfEffetTemp(effetC);
      else if (cof_states[effetC]) {
        let se = stringOfEtat(effetC, perso);
        met = {
          etat: true,
          msgSave: "ne plus \xEAtre " + se,
          fin: "n'est plus " + se,
          actif: "est toujours " + se
        };
      } else met = messageEffetCombat[effetC];
      let msgPour = " pour ";
      if (met.msgSave) msgPour += met.msgSave;
      else {
        msgPour += "ne plus \xEAtre sous l'effet de ";
        if (effetC.startsWith('dotGen('))
          msgPour += effetC.substring(7, effetC.indexOf(')'));
        else msgPour += effetC;
      }
      let sujet = onGenre(perso, 'il', 'elle');
      let msgReussite = ", " + sujet + ' ' + messageFin(perso, met);
      let msgRate = ", " + sujet + ' ' + messageActif(perso, met);
      let saveOpts = {
        msgPour: msgPour,
        msgReussite: msgReussite,
        msgRate: msgRate,
        rolls: options.rolls,
        chanceRollId: options.chanceRollId
      };
      let attrType = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attr.get('name').replace('SaveParTour', 'SaveParTourType')
      });
      if (attrType.length > 0) {
        saveOpts.type = attrType[0].get('current');
      }
      let attrEffet;
      if (met.etat) {
        attrEffet = {
          id: effetC
        };
      } else {
        attrEffet = findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: attrName
        });
        if (attrEffet === undefined || attrEffet.length === 0) {
          if (getObj('attribute', attr.id)) {
            error("Save sans effet " + attrName, attr);
            findObjs({
              _type: 'attribute',
              _characterid: charId,
              name: attr.get('name').replace('SaveParTour', 'SaveParTourType')
            }).forEach(function(a) {
              a.remove();
            });
            attr.remove();
          }
          return;
        }
        attrEffet = attrEffet[0];
      }
      let saveId = 'saveParTour_' + attrEffet.id + '_' + perso.token.id;
      let s = {
        carac: carac,
        seuil: seuil,
        entrave: met.entrave
      };
      save(s, perso, saveId, expliquer, saveOpts, evt,
        function(reussite, texte) { //asynchrone
          if (reussite) {
            if (met.etat) {
              setState(perso, effetC, false, evt);
            } else {
              let eff = effetC;
              if (effetTemp) eff = effetTempOfAttribute(attrEffet);
              finDEffet(attrEffet, eff, attrName, charId, evt, {
                attrSave: attr,
                pageId: pageId
              });
            }
          }
        });
    }); //fin boucle attrSave
    let armeesDesMorts = allAttributesNamed(attrs, 'armeeDesMorts');
    let degatsArmeeFull = {};
    let degatsArmeeDefense = {};
    let gmId;
    armeesDesMorts.forEach(function(armee) {
      let charId = armee.get('characterid');
      let boost = 0;
      if (charAttribute(charId, "armeeDesMortsPuissant").length > 0) boost = 1;
      else boost = attrAsInt(charAttribute(charId, "armeeDesMortsTempeteDeManaIntense"), 0);
      let rayon = Math.floor(20 * Math.sqrt(1 + boost));
      let allies = alliesParPerso[charId] || new Set();
      //Pour chaque token representant ce perso
      allPersos.forEach(function(perso) {
        if (perso.charId != charId) return;
        //On cherche ensuite les tokens \xE0 portee
        allPersos.forEach(function(target) {
          if (target.token.id == perso.token.id) return;
          let tokRepresents = target.charId;
          if (tokRepresents == charId) return;
          if (allies.has(tokRepresents)) return;
          if (degatsArmeeDefense[target.token.id] != undefined || degatsArmeeFull[target.token.id] != undefined) return;
          if (distanceCombat(perso.token, target.token, pageId) > rayon) return;
          if (attributeAsBool(target, 'defenseArmeeDesMorts')) {
            degatsArmeeDefense[target.token.id] = target;
          } else {
            degatsArmeeFull[target.token.id] = target;
          }
        });
      });
      if (!gmId) {
        gmId = getGMId();
        if (!gmId) {
          error("Impossible de trouver un MJ");
          return;
        }
      }
    });
    let targetLine = '';
    Object.keys(degatsArmeeFull).forEach(function(tokId) {
      targetLine += " --target " + tokId;
    });
    if (targetLine != "")
      sendChat('player|' + gmId, "!cof-dmg 3d6" + targetLine + " --titre D\xE9g\xE2ts des morts-vivants anim\xE9s");
    targetLine = "";
    Object.keys(degatsArmeeDefense).forEach(function(tokId) {
      targetLine += " --target " + tokId;
    });
    if (targetLine != "")
      sendChat('player|' + gmId, "!cof-dmg 1d6" + targetLine + " --titre D\xE9g\xE2ts des morts-vivants anim\xE9s sur les cibles qui les combattent");
    removeAllAttributes("defenseArmeeDesMorts", evt, attrs);
    if (stateCOF.prescience) {
      //On affiche la prescience aux joueurs concern\xE9s
      allPersos.forEach(function(perso) {
        if (capaciteDisponible(perso, 'prescience', 'combat')) {
          whisperChar(perso.charId, "Possibilit\xE9 d'utiliser la " + boutonSimple('!cof-prescience ' + perso.token.id + ' --mana 2', "Prescience"));
        }
      });
      stateCOF.nextPrescience = {
        evt: evt,
        dernieresPositions: []
      };
      allTokens.forEach(function(tok) {
        stateCOF.nextPrescience.dernieresPositions.push({
          token: tok,
          left: tok.get('left'),
          top: tok.get('top')
        });
      });
    }
    if (stateCOF.tenebresMagiques && stateCOF.tenebresMagiques.attaques) {
      stateCOF.tenebresMagiques.attaques = undefined;
    }
  }

  //evt a un champ attributes et un champ deletedAttributes
  //evt n'est pas ajout\xE9 \xE0 l'historique dans cette fonction
  function nextTurnOfActive(active, attrs, evt, combat, pageId, options) {
    if (active === undefined) return;
    if (active.id == "-1" && active.custom == "Tour") { //Nouveau tour
      let tour = parseInt(active.pr);
      if (isNaN(tour)) {
        error("Tour invalide", active);
        return;
      }
      if (!evt.combat) evt.combat = {...combat
      };
      evt.combat.tour = tour - 1;
      evt.updateNextInitSet = updateNextInitSet;
      active.pr = tour - 1; // pr\xE9paration au calcul de l'undo
      sendChat("GM", "D\xE9but du tour " + tour);
      combat.tour = tour;
      combat.init = 1000;
      changementDeTour(tour, attrs, evt, combat, pageId, options);
    } else { // change le token actif
      setActiveToken(combat, active.id, evt);
    }
  }

  function actionEffet(attr, effet, attrName, charId, pageId, evt, callBack) {
    switch (effet) {
      case 'putrefaction': //prend 1d6 DM
        degatsParTour(charId, pageId, effet, attrName, {
            nbDe: 1,
            de: 6
          }, 'maladie',
          "pourrit", evt, {
            magique: true
          }, callBack);
        return;
      case 'asphyxie': //prend 1d6 DM
        degatsParTour(charId, pageId, effet, attrName, {
            nbDe: 1,
            de: 6
          }, 'normal',
          "ne peut plus respirer", evt, {
            asphyxie: true
          }, callBack);
        return;
      case 'saignementsSang': //prend 1d6 DM
        if (charPredicateAsBool(charId, 'immuniteSaignement') ||
          charPredicateAsBool(charId, 'controleSanguin')) {
          callBack();
          return;
        }
        degatsParTour(charId, pageId, effet, attrName, {
            nbDe: 1,
            de: 6
          }, 'normal',
          "saigne par tous les orifices du visage", evt, {
            magique: true,
            saignement: true
          }, callBack);
        return;
      case 'blessureSanglante': //prend 1d6 DM
        if (charPredicateAsBool(charId, 'immuniteSaignement') ||
          charPredicateAsBool(charId, 'controleSanguin')) {
          callBack();
          return;
        }
        degatsParTour(charId, pageId, effet, attrName, {
            nbDe: 1,
            de: 6
          }, 'normal',
          "saigne abondamment", evt, {
            saignement: true
          }, callBack);
        return;
      case 'armureBrulante': //prend 1d4 DM
        degatsParTour(charId, pageId, effet, attrName, {
            nbDe: 1,
            de: 4
          }, 'feu',
          "br\xFBle dans son armure", evt, {
            valeur: 'armureBrulanteValeur'
          }, callBack);
        return;
      case 'nueeDInsectes': //prend 1 DM
        degatsParTour(charId, pageId, effet, attrName, {
            cst: 1
          }, 'normal',
          "est piqu\xE9 par les insectes", evt, {
            valeur: 'nueeDInsectesValeur'
          }, callBack);
        return;
      case 'nueeDeCriquets': //prend 1 DM
        degatsParTour(charId, pageId, effet, attrName, {
            cst: 2
          }, 'normal',
          "est piqu\xE9 par les criquets", evt, {}, callBack);
        return;
      case 'nueeDeScorpions': //prend 1D6 DM
        degatsParTour(charId, pageId, effet, attrName, {
            nbDe: 1,
            de: 6
          }, 'normal',
          "est piqu\xE9 par les scorpions", evt, {}, callBack);
        return;
      case 'armeBrulante': //prend 1 DM
        degatsParTour(charId, pageId, effet, attrName, {
            cst: 1
          }, 'feu',
          "se br\xFBle avec son arme", evt, {
            valeur: 'armeBrulanteValeur'
          }, callBack);
        return;
      case 'regeneration': //soigne
        soigneParTour(charId, pageId, effet, attrName, 3, "r\xE9g\xE9n\xE8re", evt, {
          valeur: 'regenerationValeur'
        }, callBack);
        return;
      case 'strangulation':
        let nameDureeStrang = 'dureeStrangulation';
        if (effet != attrName) { //concerne un token non li\xE9
          nameDureeStrang += attrName.substring(attrName.indexOf('_'));
        }
        let dureeStrang = findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: nameDureeStrang
        });
        if (dureeStrang.length === 0) {
          let attrDuree = createObj('attribute', {
            characterid: charId,
            name: nameDureeStrang,
            current: 0,
            max: false
          });
          evt.attributes.push({
            attribute: attrDuree,
          });
        } else {
          let strangUpdate = dureeStrang[0].get('max');
          if (strangUpdate) { //a \xE9t\xE9 mis \xE0 jour il y a au plus 1 tour
            evt.attributes.push({
              attribute: dureeStrang[0],
              current: dureeStrang[0].get('current'),
              max: strangUpdate
            });
            dureeStrang[0].set('max', false);
          } else { //Ça fait trop longtemps, on arr\xEAte tout
            sendChar(charId, messageFin({
              charId
            }, messageEffetTemp[effet]), true);
            evt.attributes.pop(); //On enl\xE8ve des attributs modifi\xE9s pour mettre dans les attribute supprim\xE9s.
            evt.deletedAttributes.push(attr);
            attr.remove();
            evt.deletedAttributes.push(dureeStrang[0]);
            dureeStrang[0].remove();
          }
        }
        callBack();
        return;
      case 'dotGen':
        let effetC = effetComplet(effet, attrName);
        degatsParTour(charId, pageId, effetC, attrName, {}, '', "", evt, {
          dotGen: true
        }, callBack);
        return;
      default:
        callBack();
        return;
    }
  }

  //Appel\xE9 si le turn order change, mais aussi en interne
  //si evt est d\xE9j\xE0 d\xE9fini, ne l'ajoute pas au turn order
  function nextTurn(cmp, options, evt) {
    if (!cmp.get('initiativepage')) return;
    let combat = stateCOF.combat;
    if (!combat) {
      error("Le script n'est pas en mode combat", cmp);
    }
    let turnOrder = cmp.get('turnorder');
    let pageId = combat.pageId;
    if (pageId === undefined) {
      pageId = cmp.get('playerpageid');
      combat.pageId = pageId;
    }
    if (turnOrder === '') return; // nothing in the turn order
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length < 1) return; // Juste le compteur de tour
    if (stateCOF.nextPrescience) {
      stateCOF.prescience = stateCOF.nextPrescience;
      stateCOF.nextPrescience = undefined;
    }
    let active = turnOrder[0];
    let init = parseInt(active.pr);
    if (active.id == "-1" && active.custom == "Tour") {
      let tour = init; //= parseInt(active.pr);
      init = 0;
      if (isNaN(tour)) {
        error("Le tour n'est pas un nombre");
        return;
      }
      turnOrder[0] = {...active
      };
      turnOrder[0].pr = tour - 1;
    }
    let lastHead = turnOrder.pop();
    turnOrder.unshift(lastHead);
    if (evt === undefined) {
      evt = {
        type: 'nextTurn',
        attributes: [],
        deletedAttributes: [],
        turnorder: JSON.stringify(turnOrder)
      };
      addEvent(evt);
    } else {
      evt.attributes = evt.attributes || [];
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.turnorder = evt.turnorder || JSON.stringify(turnOrder);
    }
    if (stateCOF.chargeFantastique) {
      //cmp.set('turnorder', evt.turnorder);
      if (stateCOF.chargeFantastique.attaques) {
        nextTurnChargeFantastique(undefined, evt.turnorder);
        return;
      }
      stateCOF.chargeFantastique = undefined;
    }
    let attrs = findObjs({
      _type: 'attribute'
    });
    // Si on a chang\xE9 d'initiative, alors diminue les effets temporaires
    if (combat.init > init) {
      if (stateCOF.tokensTemps && stateCOF.tokensTemps.length > 0) {
        stateCOF.tokensTemps = stateCOF.tokensTemps.filter(function(tt) {
          if (init < tt.init && tt.init <= combat.init) {
            if (tt.duree > 1) {
              evt.tokensTemps = evt.tokensTemps || [];
              evt.tokensTemps.push({
                tt,
                ancienneDuree: tt.duree
              });
              tt.duree--;
              return true;
            } else {
              let token = getObj('graphic', tt.tid);
              if (token) {
                let ett = {...tt
                };
                ett.deletedToken = getTokenFields(token);
                evt.deletedTokensTemps = evt.deletedTokensTemps || [];
                evt.deletedTokensTemps.push(ett);
                token.remove();
              }
              return false;
            }
          } else {
            return true;
          }
        });
      }
      //attrsTemp ne contient que les attributs dont la dur\xE9e doit baisser
      let attrsTemp = attrs.filter(function(obj) {
        if (!estEffetTemp(obj.get('name'))) return false;
        let obji = obj.get('max');
        return (init <= obji && obji < combat.init) || (init === 0 && obji == 1000);
      });
      if (!evt.combat) evt.combat = {...stateCOF.combat
      };
      combat.init = init;
      // Boucle sur les effets temps peut \xEAtre asynchrone \xE0 cause des DM
      let count = attrsTemp.length;
      if (count === 0) {
        nextTurnOfActive(active, attrs, evt, combat, pageId, options);
        return;
      }
      let fin = function() {
        count--;
        if (count === 0) nextTurnOfActive(active, attrs, evt, combat, pageId, options);
      };
      attrsTemp.forEach(function(attr) {
        let charId = attr.get('characterid');
        const effet = effetTempOfAttribute(attr);
        if (effet === undefined) {
          //erreur, on stoppe tout
          log(attr);
          fin();
          return;
        }
        let attrName = attr.get('name');
        let effetC = effetComplet(effet, attrName);
        let v = parseInt(attr.get('current'));
        if (isNaN(v)) v = 1;
        if (v <= 1) { //L'effet arrive en fin de vie, doit \xEAtre supprim\xE9
          //Sauf si on a accumul\xE9 plusieurs fois l'effet
          let accumuleAttr = attributeExtending(charId, attrName, effetC, 'DureeAccumulee');
          if (accumuleAttr.length > 0) {
            accumuleAttr = accumuleAttr[0];
            let dureeAccumulee = accumuleAttr.get('current') + '';
            let listeDureeAccumulee = dureeAccumulee.split(',');
            evt.attributes.push({
              attribute: attr,
              current: v
            });
            let nDuree = parseInt(listeDureeAccumulee.pop());
            if (isNaN(nDuree)) {
              v = 1;
              fin();
              return;
            } else v = nDuree + 1; //car on va le diminuer plus bas.
            if (listeDureeAccumulee.length === 0) {
              evt.deletedAttributes.push(accumuleAttr);
              accumuleAttr.remove();
            } else {
              evt.attributes.push({
                attribute: accumuleAttr,
                current: dureeAccumulee
              });
              accumuleAttr.set('current', listeDureeAccumulee.join(','));
            }
          } else {
            //L'action finale
            actionEffet(attr, effet, attrName, charId, pageId, evt, function() {
              let effetFinal = finDEffet(attr, effet, attrName, charId, evt, {
                pageId
              });
              if (effetFinal && effetFinal.oldTokenId == active.id) {
                active.id = effetFinal.newTokenId;
                if (active.id === undefined) {} else if (active.id == '-1') {
                  active.custom = 'Tour';
                }
              }
              fin();
            });
            return;
          }
        }
        //Effet encore actif
        evt.attributes.push({
          attribute: attr,
          current: v
        });
        if (v > 1) attr.set('current', v - 1);
        actionEffet(attr, effet, attrName, charId, pageId, evt, fin);
      }); //fin de la boucle sur tous les attributs d'effets temporaires
    } else { //L'initiative n'a pas boug\xE9e
      nextTurnOfActive(active, attrs, evt, combat, pageId, options);
    }
  }

  //Fonction appel\xE9e par !cof-tour-suivant
  function tourSuivant(msg) {
    let combat = stateCOF.combat;
    if (!combat) {
      sendPlayer(msg, "Vous n'\xEAtes pas en combat");
      return;
    }
    let cmp = Campaign();
    let turnOrder = cmp.get('turnorder');
    if (turnOrder === '') {
      error("Personne n'est en combat", turnOrder);
      return;
    }
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length < 1) {
      error("Personne n'est en combat", turnOrder);
      return;
    }
    let active = turnOrder.shift();
    let persoActif = persoOfId(active.id);
    if (persoActif === undefined) {
      error("Impossible de trouver le personnage actif", active);
      return;
    }
    if (!peutController(msg, persoActif)) {
      sendPlayer(msg, "Ce n'est pas votre tour (personnage actif : " + nomPerso(persoActif) + ")");
      return;
    }
    turnOrder.push(active);
    if (turnOrder[0].id == "-1" && turnOrder[0].custom == "Tour") {
      //Il faut aussi augmenter la valeur du tour
      let tour = parseInt(turnOrder[0].pr);
      if (isNaN(tour)) {
        error("Tour invalide", turnOrder);
        return;
      }
      turnOrder[0].pr = tour + 1;
    }
    cmp.set('turnorder', JSON.stringify(turnOrder));
    nextTurn(cmp);
  }

  //nb \xE0 11 pour ne pas retenter de lire les attributs
  function scriptVersionToCharacter(character, nb) {
    let charId = character.id;
    //On v\xE9rifie que les attributs sont peupl\xE9s
    let attrs = findObjs({
      _type: 'attribute',
      _characterid: charId,
    });
    if (attrs.length === 0) {
      nb = nb || 1;
      if (nb < 9) {
        _.delay(function() {
          scriptVersionToCharacter(character, nb + 1);
        }, 2000);
        return;
      }
    }
    attrs = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: 'scriptVersion',
    }, {
      caseInsensitive: true
    });
    if (attrs.length === 0) {
      let attr = createObj('attribute', {
        characterid: charId,
        name: 'scriptVersion',
        current: true,
        max: state.COFantasy.version
      });
      attr.setWithWorker({
        current: true,
        max: state.COFantasy.version
      });
    } else {
      if (attrs.length > 1) {
        for (let i = 1; i < attrs.length; i++) {
          attrs[i].remove();
        }
      }
      attrs[0].setWithWorker({
        current: true,
        max: state.COFantasy.version
      });
    }
  }

  function destroyToken(token) { //to remove unused local attributes
    let charId = token.get('represents');
    if (charId === '') return;
    let perso = {
      charId: charId,
      token: token
    };
    let pageId = token.get('pageid');
    let nomToken = token.get('name');
    if (nomToken.startsWith('decoince ')) {
      let originalToken = findObjs({
        _type: 'graphic',
        _pageid: pageId,
        represents: charId,
        name: nomToken.substring(9)
      });
      if (originalToken.length === 0) return;
      perso.token = originalToken[0];
      removeTokenAttr(perso, 'bougeGraceA');
      return;
    }
    //On regarde si il existe une copie de ce token, par exemple \xE0 cause de l'invisibilit\xE9
    let otherTokens = findObjs({
      _type: 'graphic',
      _pageid: pageId,
      represents: charId,
      name: nomToken
    });
    if (otherTokens.length > 0) return;
    let tokenBougeAttr = tokenAttribute(perso, 'bougeGraceA');
    tokenBougeAttr.forEach(function(a) {
      let tokenBouge = getObj('graphic', a.get('current'));
      if (tokenBouge) {
        tokenBouge.remove();
      } else {
        tokenBouge = findObjs({
          _type: 'graphic',
          _pageid: pageId,
          represents: charId,
          name: 'decoince ' + token.get('name')
        });
        if (tokenBouge.length > 0) {
          tokenBouge = tokenBouge[0];
          tokenBouge.remove();
        }
      }
      a.remove();
    });
    nePlusSuivre(perso, pageId);
    let deplacementsSynchronises = tokenAttribute(perso, 'tokensSynchronises');
    let keepToken;
    deplacementsSynchronises.forEach(function(attr) {
      let listTokens = attr.get('current').split(',');
      listTokens = listTokens.filter(function(tid) {
        return tid != token.id;
      });
      if (listTokens.length < 2) attr.remove();
      else keepToken = true;
    });
    if (keepToken || token.get('bar1_link') !== '') return;
    let endName = "_" + token.get('name');
    let tokAttr = findObjs({
      _type: 'attribute',
      _characterid: charId
    });
    tokAttr = tokAttr.filter(function(obj) {
      return obj.get('name').endsWith(endName);
    });
    if (tokAttr.length > 0) {
      log("Removing token local attributes");
      log(tokAttr);
      tokAttr.forEach(function(attr) {
        attr.remove();
      });
    }
  }

  function persoImmobilise(perso) {
    return (
      stateCOF.pause ||
      !isActive(perso) ||
      getState(perso, 'immobilise') ||
      attributeAsBool(perso, 'bloqueManoeuvre') ||
      attributeAsBool(perso, 'enveloppePar') ||
      attributeAsBool(perso, 'prisonVegetale') ||
      attributeAsBool(perso, 'toiles') ||
      attributeAsBool(perso, 'estGobePar') ||
      attributeAsBool(perso, 'agrippeParUnDemon') ||
      attributeAsBool(perso, 'etreinteScorpionPar') ||
      attributeAsBool(perso, 'estEcrasePar')
    );
  }

  function unlockToken(perso, evt) {
    if (!perso.token.get('lockMovement')) return;
    if (persoImmobilise(perso)) return;
    if (evt) affectToken(perso.token, 'lockMovement', true, evt);
    perso.token.set('lockMovement', false);
    enleveDecoince(perso, evt);
  }

  function getGMId() {
    let gm = findObjs({
      _type: 'player'
    }).find(function(p) {
      return playerIsGM(p.id);
    });
    if (!gm) {
      error("Impossible de trouver un MJ");
      return;
    }
    return gm.id;
  }

  function doAuraDrainDeForce(playerId, origine, cibles, mEffet, options) {
    let per;
    if (cibles.length < 2) per = cibles[0];
    else per = origine;
    let display = startFramedDisplay(playerId, "Aura de drain de force", per);
    const evtEffet = {
      type: 'auraDrainDeForce',
      action: {
        playerId,
        origine,
        cibles,
        mEffet,
        options,
      }
    };
    addEvent(evtEffet);
    activerEffetTemporaire(origine, cibles, 'drainDeForce', mEffet, 1, options, evtEffet, '', [], display);
  }

  //retourne le nombre de cibles affect\xE9es
  function appliquerAura(origine, cibles, pageId, aura, evt, renew) {
    let effet;
    cibles = cibles.filter(function(perso) {
      if (distanceCombat(origine.token, perso.token, pageId) > aura.portee)
        return false;
      if (aura.seulementVivant && estNonVivant(perso)) return false;
      effet = effet || 'affecteParAura(' + aura.id + ')';
      if (!renew && attributeAsBool(perso, effet)) return false;
      return true;
    });
    if (cibles.length === 0) return 0;
    cibles.forEach(function(perso) {
      setAttrDuree(perso, effet, 1, evt);
    });
    switch (aura.effet) {
      case 'drainDeForce':
        let options = {
          save: {
            carac: 'CON',
            seuil: 12,
            msgPour: ' pour ne pas \xEAtre affaibli' + eForFemale(cibles[0])
          }
        };
        let mEffet = messageEffetTemp.drainDeForce;
        let playerId;
        if (cibles.length > 1) {
          playerId = getGMId();
        } else {
          let pl = getPlayerIds(cibles[0]);
          if (pl === undefined) return;
          if (pl.length > 0) playerId = pl[0];
        }
        doAuraDrainDeForce(playerId, origine, cibles, mEffet, options);
        return;
      case 'auraGenerique':
        let cmd = aura.effetCmd;
        cibles.forEach(function(perso) {
          cmd += " --target " + perso.token.id;
        });
        let gmid = getGMId();
        if (!gmid) {
          error("Impossible de trouver un MJ");
          return;
        }
        sendChat('player|' + gmid, cmd);
        return;
      default:
        error("Aura inconnue", aura);
    }
    return cibles.length;
  }

  //R\xE9agit au d\xE9placement manuel d'un token.
  // suivis est l'ensemble des tokens qui a d\xE9j\xE0 \xE9t\xE9 boug\xE9 suite \xE0 ce d\xE9placement
  function moveToken(token, prev, synchronisation, suivis) {
    let charId = token.get('represents');
    if (charId === '') return;
    let perso = {
      token,
      charId
    };
    let pageId = token.get('pageid');
    let x = token.get('left');
    let y = token.get('top');
    let deplacement = prev && (prev.left != x || prev.top != y);
    if (!deplacement) return;
    //Effets des auras, asynchrone
    if (stateCOF.combat && stateCOF.combat.auras) {
      const evt = {
        type: "Appliquer auras",
      };
      addEvent(evt);
      stateCOF.combat.auras.forEach(function(aura) {
        let origine = persoOfId(aura.origineId, aura.origineName, pageId);
        if (!origine) return;
        let cibles = [perso];
        if (origine.token.id == token.id) {
          cibles = [];
          let allToks = findObjs({
            _type: 'graphic',
            _pageid: pageId,
            _subtype: 'token',
            layer: 'objects'
          });
          allToks.forEach(function(tok) {
            if (tok.id == token.id) return;
            let ci = tok.get('represents');
            if (ci === '') return;
            let p = {
              charId: ci,
              token: tok,
            };
            cibles.push(p);
          });
        }
        appliquerAura(origine, cibles, pageId, aura, evt);
      });
    }
    if (!synchronisation) {
      let deplacementsSynchronises = tokenAttribute(perso, 'tokensSynchronises');
      deplacementsSynchronises.forEach(function(attr) {
        let listTokens = attr.get('current');
        listTokens.split(',').forEach(function(tid) {
          if (tid == token.id) return;
          let tok = getObj('graphic', tid);
          if (tok === undefined) {
            error("Impossible de trouver le token d'id " + tid + " synchronis\xE9 avec " + token.get('name'), attr);
            return;
          }
          tok.set('left', x);
          tok.set('top', y);
          moveToken(tok, prev, true);
        });
      });
    }
    suivis = suivis || new Set();
    let nomToken = token.get('name');
    if (nomToken.startsWith('decoince ')) {
      let originalToken = findObjs({
        _type: 'graphic',
        _pageid: pageId,
        represents: charId,
        name: nomToken.substring(9)
      });
      if (originalToken.length === 0) return;
      originalToken = originalToken[0];
      let sprev = {
        left: originalToken.get('left'),
        top: originalToken.get('top'),
        rotation: originalToken.get('rotation'),
      };
      originalToken.set('left', x);
      originalToken.set('top', y);
      originalToken.set('rotation', token.get('rotation'));
      moveToken(originalToken, sprev, synchronisation, suivis);
      return;
    }
    //On regarde d'abord si perso est sur une monture
    let attrMonteSur = tokenAttribute(perso, 'monteSur');
    if (attrMonteSur.length > 0) {
      let monture = persoOfIdName(attrMonteSur[0].get('current'), pageId, true);
      if (monture === undefined) {
        sendPerso(perso, "descend de sa monture");
        attrMonteSur[0].remove();
      } else {
        if (monture.token.get('pageid') != pageId || monture.token.get('lockMovement')) {
          sendPerso(perso, "descend de " + nomPerso(monture));
          removeTokenAttr(monture, 'estMontePar');
          removeTokenAttr(monture, 'positionSurMonture');
          attrMonteSur[0].remove();
        } else if (!suivis.has(monture.token.id)) {
          let position = tokenAttribute(monture, 'positionSurMonture');
          if (position.length > 0) {
            let dx = parseInt(position[0].get('current'));
            let dy = parseInt(position[0].get('max'));
            if (!(isNaN(dx) || isNaN(dy))) {
              let sprev = {
                left: monture.token.get('left'),
                top: monture.token.get('top'),
              };
              monture.token.set('left', x - dx);
              monture.token.set('top', y - dy);
              monture.token.set('rotation', token.get('rotation') - attributeAsInt(monture, 'directionSurMonture', 0));
              suivis.add(token.id);
              moveToken(monture.token, sprev, synchronisation, suivis);
            }
          }
        }
        if (stateCOF.combat) {
          const evt = {
            type: "initiative"
          };
          updateInit(monture.token, evt);
          // R\xE9adapter l'init_dynamique au token du perso
          if (stateCOF.options.affichage.val.init_dynamique.val) {
            setTokenInitAura(perso);
          }
        }
      }
    }
    //Si il est invisible, on bouge aussi l'autre token
    let attrInvisible = tokenAttribute(perso, 'tokenInvisible');
    if (attrInvisible.length > 0) {
      attrInvisible = attrInvisible[0];
      let tidInv1 = attrInvisible.get('current'); //Originel, normalement sur le gmlayer
      let tidInv2 = attrInvisible.get('max');
      let autreInvisible;
      if (token.id == tidInv1) {
        autreInvisible = getObj('graphic', tidInv2);
        if (!autreInvisible) {
          autreInvisible =
            findObjs({
              _type: 'graphic',
              _subtype: 'token',
              _pageid: token.get('pageid'),
              layer: 'objects',
              represents: perso.charId,
              name: token.get('name')
            });
          if (autreInvisible.length > 0) autreInvisible = autreInvisible[0];
          else autreInvisible = undefined;
        }
      } else if (token.id == tidInv2) {
        autreInvisible = getObj('graphic', tidInv1);
        if (!autreInvisible) {
          autreInvisible =
            findObjs({
              _type: 'graphic',
              _subtype: 'token',
              _pageid: token.get('pageid'),
              layer: 'gmlayer',
              represents: perso.charId,
              name: token.get('name')
            });
          if (autreInvisible.length > 0) autreInvisible = autreInvisible[0];
          else autreInvisible = undefined;
        }
      }
      if (!autreInvisible) {
        switch (token.get('layer')) {
          case 'objects':
            autreInvisible =
              findObjs({
                _type: 'graphic',
                _subtype: 'token',
                _pageid: token.get('pageid'),
                layer: 'gmlayer',
                represents: perso.charId,
                name: token.get('name')
              });
            if (autreInvisible.length > 0) autreInvisible = autreInvisible[0];
            else autreInvisible = undefined;
            break;
          case 'gmlayer':
            autreInvisible =
              findObjs({
                _type: 'graphic',
                _subtype: 'token',
                _pageid: token.get('pageid'),
                layer: 'objects',
                represents: perso.charId,
                name: token.get('name')
              });
            if (autreInvisible.length > 0) autreInvisible = autreInvisible[0];
            else autreInvisible = undefined;
            break;
          default:
            error("Impossible de trouver la couche du token " + token.get('name'), token);
        }
      }
      if (autreInvisible) {
        autreInvisible.set('left', x);
        autreInvisible.set('top', y);
      }
    }
    //si non, perso est peut-\xEAtre une monture
    let attrMontePar = tokenAttribute(perso, 'estMontePar');
    attrMontePar.forEach(function(a) {
      let cavalier = persoOfIdName(a.get('current'), pageId);
      if (cavalier === undefined) {
        a.remove();
        return;
      }
      if (!suivis.has(cavalier.token.id)) {
        let position = tokenAttribute(perso, 'positionSurMonture');
        if (position.length > 0) {
          let dx = parseInt(position[0].get('current'));
          let dy = parseInt(position[0].get('max'));
          if (!(isNaN(dx) || isNaN(dy))) {
            x += dx;
            y += dy;
          }
        }
        cavalier.token.set('left', x);
        cavalier.token.set('top', y);
        cavalier.token.set('rotation', token.get('rotation') + attributeAsInt(perso, 'directionSurMonture', 0));
      }
    });
    //Si le token suivait quelqu'un, ce n'est plus le cas
    if (prev.suit === undefined) nePlusSuivre(perso, pageId);
    //On bouge tous les tokens qui suivent le personnage
    //sauf si on a d\xE9j\xE0 \xE9t\xE9 boug\xE9.
    if (!suivis.has(token.id)) {
      suivis.add(token.id);
      let attrSuivi = tokenAttribute(perso, 'estSuiviPar');
      let page = getObj('page', pageId);
      if (page === undefined) {
        error("Impossible de trouver la page du token", perso);
        return;
      }
      if (attrSuivi.length > 0) {
        let width = page.get('width') * PIX_PER_UNIT;
        let height = page.get('height') * PIX_PER_UNIT;
        let pt = {
          x: x,
          y: y
        };
        let murs = getWalls(page, pageId, prev.murs);
        let distance =
          Math.sqrt((x - prev.left) * (x - prev.left) + (y - prev.top) * (y - prev.top));
        attrSuivi.forEach(function(as) {
          let suivants = as.get('current').split(':::');
          let removedSuivant;
          suivants = suivants.filter(function(idn) {
            let suivant = persoOfIdName(idn, pageId);
            if (suivant === undefined) {
              removedSuivant = true;
              return false;
            }
            let sw = suivant.token.get('width');
            let sh = suivant.token.get('height');
            if (sw > width) return false;
            if (sh > width) return false;
            let sx = suivant.token.get('left');
            let sy = suivant.token.get('top');
            //On essaie de garder la m\xEAme position par rapport au token, en supposant qu'on \xE9tait derri\xE8re lui
            let attrSuit = tokenAttribute(suivant, 'suit');
            let dp;
            if (attrSuit.length > 0) {
              dp = parseInt(attrSuit[0].get('max'));
            }
            if (dp === undefined || isNaN(dp) || dp < 1) {
              dp = Math.sqrt((prev.left - sx) * (prev.left - sx) + (prev.top - sy) * (prev.top - sy));
            }
            let nsx = x + (prev.left - x) * dp / distance;
            let nsy = y + (prev.top - y) * dp / distance;
            if (nsx < 0) nsx = 0;
            if (nsy < 0) nsy = 0;
            if (nsx + sw / 2 > width) nsx = Math.floor(width - sw / 2);
            if (nsy + sh / 2 > height) nsy = Math.floor(height - sh / 2);
            //v\xE9rifie si de la nouvelle position on peut voir le suivi
            if (obstaclePresent(nsx, nsy, pt, murs)) {
              //On essaie de suivre le chemin du token, \xE0 la place
              //D'abord se d\xE9placer vers l'ancienne position de perso, au maximum de distance pixels
              var distLoc = distance;
              if (distLoc - dp < 5) {
                nsx = prev.left;
                nsy = prev.top;
              } else {
                if (dp > distLoc) {
                  nsx = sx + (prev.left - sx) * distLoc / dp;
                  nsy = sy + (prev.top - sy) * distLoc / dp;
                  if (obstaclePresent(nsx, nsy, pt, murs)) {
                    sendPerso(suivant, "ne peut plus suivre " + nomPerso(perso) + " car " + onGenre(suivant, 'il', 'elle') + " ne " + onGenre(perso, 'le', 'la') + " voit plus");
                    removeTokenAttr(suivant, 'suit');
                    removedSuivant = true;
                    return false;
                  }
                } else {
                  //On part de l'ancienne position, et on peut encore avancer
                  distLoc -= dp;
                  nsx = prev.left + (x - prev.left) * distLoc / distance;
                  nsy = prev.top + (y - prev.top) * distLoc / distance;
                  if (obstaclePresent(nsx, nsy, pt, murs)) {
                    nsx = prev.left;
                    nsy = prev.top;
                  }
                }
              }
            }
            suivant.token.set('left', nsx);
            suivant.token.set('top', nsy);
            let sprev = {
              left: sx,
              top: sy,
              suit: true,
              murs: murs
            };
            moveToken(suivant.token, sprev, synchronisation, suivis); //pour faire suivre ceux qui le suivent
            return true;
          });
          if (removedSuivant) {
            if (suivants.length === 0) {
              as.remove();
            } else {
              as.set('current', suivants.join(':::'));
            }
          }
        });
      }
    }
    // Update position du token d'initiative dynamique
    let combat = stateCOF.combat;
    if (stateCOF.options.affichage.val.init_dynamique.val && roundMarker &&
      combat) {
      if ((!stateCOF.chargeFantastique && combat.activeTokenId == token.id) ||
        (stateCOF.chargeFantastique && stateCOF.chargeFantastique.activeTokenId == token.id)) {
        roundMarker.set('left', x);
        roundMarker.set('top', y);
      } else {
        // Cas sp\xE9ciaux du cavaliers : au tour du cavalier, l'init_dynamique suit la monture
        let estMontePar = tokenAttribute(perso, 'estMontePar');
        if (estMontePar.length > 0) {
          let sp = splitIdName(estMontePar[0].get('current'));
          if (sp && combat.activeTokenId == sp.id) {
            let cavalier = persoOfId(sp.id);
            roundMarker.set('left', cavalier.token.get('left'));
            roundMarker.set('top', cavalier.token.get('top'));
          }
        }
      }
    }
    //On d\xE9place les tokens de lumi\xE8re, si il y en a
    let attrLumiere = tokenAttribute(perso, 'lumiere');
    attrLumiere.forEach(function(al) {
      let lumId = al.get('max');
      if (lumId == 'surToken') return;
      let lumiereExiste;
      let lumiere = getObj('graphic', lumId);
      if (lumiere && lumiere.get('pageid') != pageId) {
        lumiere = undefined;
        lumiereExiste = true;
      }
      if (lumiere === undefined) {
        let tokensLumiere = findObjs({
          _type: 'graphic',
          _pageid: pageId,
          layer: 'walls',
          name: al.get('current')
        });
        if (tokensLumiere.length === 0) {
          if (lumiereExiste) return;
          log("Pas de token pour la lumi\xE8re " + al.get('current'));
          al.remove();
          return;
        }
        lumiere = tokensLumiere.shift();
        if (tokensLumiere.length > 0) {
          //On cherche le token le plus proche de la position pr\xE9c\xE9dente
          let d = distanceTokenPrev(lumiere, prev);
          tokensLumiere.forEach(function(tl) {
            let d2 = distanceTokenPrev(tl, prev);
            if (d2 < d) {
              d = d2;
              lumiere = tl;
            }
          });
        }
      }
      if (lumiere === undefined) {
        if (lumiereExiste) return;
        log("Pas de token pour la lumi\xE8re " + al.get('current'));
        al.remove();
        return;
      }
      lumiere.set('left', x);
      lumiere.set('top', y);
    });
    let attrEnveloppe = tokenAttribute(perso, 'enveloppe');
    attrEnveloppe = attrEnveloppe.concat(tokenAttribute(perso, 'aGobe'));
    attrEnveloppe = attrEnveloppe.concat(tokenAttribute(perso, 'ecrase'));
    attrEnveloppe.forEach(function(a) {
      var cible = persoOfIdName(a.get('current'), pageId);
      if (cible === undefined) {
        a.remove();
        return;
      }
      cible.token.set('left', x);
      cible.token.set('top', y);
    });
  }

  function synchronisationDesEtats(perso) {
    for (let etat in cof_states) {
      // R\xE9cup\xE8re la valeur de l'\xE9tat sur la fiche
      let valEtat;
      if (etat == 'affaibli') { // Cas particulier affaibli sur la fiche perso
        valEtat = (ficheAttributeAsInt(perso, 'affaibli', 20) == 12);
      } else { // Autre cas
        valEtat = ficheAttributeAsBool(perso, etat, false);
      }
      let field = cof_states[etat];
      if (perso.token.get(field) != valEtat) perso.token.set(field, valEtat);
    }
  }

  //Op\xE9rations diverses au moment o\xF9 on pose un token.
  //Si le token repr\xE9sente un personnage et avec la barre de vie non li\xE9e,
  // assure un nom unique en ajoutant un num\xE9ro
  // On en profite aussi pour mettre certaines valeurs par d\xE9faut
  // retourne un perso si c'est un token de personnage
  function renameToken(token, tokenName) {
    let charId = token.get('represents');
    if (charId === undefined || charId === '') return;
    let perso = {
      token: token,
      charId: charId
    };
    const pageId = token.get('pageid');
    //Vision
    let visionNoir = predicateAsInt(perso, 'visionDansLeNoir', 0);
    if (visionNoir > 0) {
      visionNoir = scaleDistance(perso, visionNoir);
      let page = getObj('page', pageId);
      let udl = page && page.get('dynamic_lighting_enabled');
      if (udl) {
        token.set('has_night_vision', true);
        //token.set('night_vision_tint', '#555555');
        token.set('night_vision_distance', visionNoir);
      } else {
        token.set('light_radius', visionNoir);
        token.set('light_dimradius', -1);
        token.set('light_otherplayers', false);
        token.set('light_hassight', true);
        token.set('light_angle', 360);
      }
    }
    if (token.get('bar1_link') !== '') {
      //Cas des tokens non mooks
      let attrMonteSur = tokenAttribute(perso, 'monteSur');
      if (attrMonteSur.length > 0) {
        let monture = persoOfIdName(attrMonteSur[0].get('current'), pageId);
        if (monture === undefined) {
          sendPerso(perso, "descend de sa monture");
          attrMonteSur[0].remove();
        } else {
          if (monture.token.get('pageid') != pageId) {
            sendPerso(perso, "descend de " + nomPerso(monture));
            removeTokenAttr(monture, 'estMontePar');
            removeTokenAttr(monture, 'positionSurMonture');
            attrMonteSur[0].remove();
          }
        }
        synchronisationDesEtats(perso);
        synchronisationDesLumieres(perso, pageId);
      }
      return perso;
    }
    //cas des mooks : num\xE9rotation
    let copyOf = 0;
    let tokenBaseName = tokenName;
    if (tokenBaseName.includes('%%NUMBERED%%')) {
      if (typeof TokenNameNumber !== 'undefined') return perso; //On laisse tokenNameNumber g\xE9rer \xE7a
      tokenBaseName = tokenBaseName.replace('%%NUMBERED%%', '');
    } else {
      // On regarde si le nom se termine par un entier
      let lastSpace = tokenBaseName.lastIndexOf(' ');
      if (lastSpace > 0) {
        copyOf = +tokenBaseName.substring(lastSpace + 1);
        if (isNaN(copyOf)) copyOf = 0;
        else tokenBaseName = tokenBaseName.substring(0, lastSpace);
      }
    }
    let otherTokens = findObjs({
      _type: 'graphic',
      //_pageid: token.get('pageid'),
      represents: charId
    });
    otherTokens = otherTokens.filter(function(tok) {
      var pid = tok.get('pageid');
      var page = getObj('page', pid);
      if (page) {
        return !(page.get('archived'));
      }
      return false;
    });
    var numero = 1;
    var nePasModifier = false;
    if (typeof TokenNameNumber !== 'undefined' && tokenBaseName.length > 0) {
      if (!isNaN(tokenBaseName[tokenBaseName.length - 1]))
        nePasModifier = true;
    }
    otherTokens.forEach(function(ot) {
      if (ot.id == token.id) return;
      var name = ot.get('name');
      if (nePasModifier && name == tokenBaseName) nePasModifier = false;
      if (name.startsWith(tokenBaseName)) {
        var suffixe = name.replace(tokenBaseName + ' ', '');
        if (isNaN(suffixe)) return;
        var n = parseInt(suffixe);
        if (n == copyOf) {
          if (ot.get('pageid') == pageId) copyOf = 0;
        }
        if (n >= numero) numero = n + 1;
      }
    });
    if (nePasModifier || copyOf > 0) return perso;
    token.set('name', tokenBaseName + ' ' + numero);
    return perso;
  }


  function addToken(token, nb) {
    let tokenName = token.get('name');
    //La plupart du temps, il faut attendre un peu que le nom soit affect\xE9
    if (tokenName !== '') {
      let perso = renameToken(token, tokenName);
      if (perso === undefined) return;
      const arme = predicateAsBool(perso, 'armeParDefaut');
      if (arme !== undefined && arme !== true) {
        degainerArme(perso, arme, {}, {
          secret: true
        });
      }
      synchronisationDesLumieres(perso);
      return;
    }
    nb = nb || 1;
    if (nb > 10) return; //Tant pis, peut-\xEAtre que le nom est vide
    _.delay(function() {
      addToken(token, nb + 1);
    }, 50);
  }

  // Surveillance sur le changement d'\xE9tat du token
  function changeMarker(token, prev) {
    const charId = token.get('represents');
    if (charId === undefined || charId === '') return; // Uniquement si token li\xE9 \xE0 un perso
    const perso = {
      token,
      charId
    };
    const evt = {
      type: "set_state",
    };
    let aff = affectToken(token, 'statusmarkers', prev.statusmarkers, evt);
    let currentMarkers = [];
    let markers = token.get("statusmarkers");
    if (markers !== '') {
      currentMarkers = markers.split(',');
    }
    let previousMarkers = [];
    if (prev.statusmarkers !== '') {
      previousMarkers = prev.statusmarkers.split(',');
    }
    let options = {
      affectToken: aff
    };
    // Pour tous les markers disparus
    previousMarkers.forEach(function(marker) {
      if (currentMarkers.includes(marker)) return;
      let etat = etat_de_marker[marker];
      if (etat) {
        setState(perso, etat, false, evt, options);
      } else {
        let effet = effet_de_marker[marker];
        if (effet) {
          let attr = tokenAttribute(perso, effet);
          if (attr.length === 0) return;
          finDEffet(attr[0], effet, attr[0].get('name'), perso.charId, evt);
        }
      }
    });
    // Ensuite les markers apparus
    currentMarkers.forEach(function(marker) {
      if (previousMarkers.includes(marker)) return;
      let etat = etat_de_marker[marker];
      if (etat) {
        let succes = setState(perso, etat, true, evt, options);
        if (!succes) token.set('status_' + marker, false);
      } else {
        let effet = effet_de_marker[marker];
        if (effet) { //si on a un effet de combat, on peut le lancer.
          let mEffet = messageEffetCombat[effet];
          if (mEffet) {
            setTokenAttr(perso, effet, true, evt, {
              msg: messageActivation(perso, mEffet)
            });
          }
        }
      }
    });
    addEvent(evt);
  }

  function synchronisationDesLumieres(perso, pageId) {
    let attrLumiere = tokenAttribute(perso, 'lumiere');
    if (attrLumiere) {
      let token = perso.token;
      attrLumiere.forEach(function(al) {
        let lumId = al.get('max');
        if (lumId == 'surToken') {
          if (!token.get('emits_bright_light') && !token.get('emits_low_light')) {
            //On cherche un token qui repr\xE9sente le m\xEAme personnage et \xE9met de la lumi\xE8re
            let allTokens = findObjs({
              type: 'graphic',
              represents: perso.charId
            });
            let tok = allTokens.find(function(t) {
              return t.get('emits_bright_light') || t.get('emits_low_light');
            });
            if (!tok) {
              al.remove();
              return;
            }
            token.set('emits_bright_light', tok.get('emits_bright_light'));
            token.set('emits_low_light', tok.get('emits_low_light'));
          }
          return;
        }
        //Lumi\xE8re sur un token qui suit le perso.
        let lumiere = getObj('graphic', lumId);
        if (lumiere && lumiere.get('pageid') != pageId) {
          let copyLum = createObj('graphic', {
            _pageid: pageId,
            imgsrc: lumiere.get('imgsrc'),
            left: token.get('left'),
            top: token.get('top'),
            width: 70,
            height: 70,
            layer: 'walls',
            name: lumiere.get('name'),
            emits_low_light: lumiere.get('emits_low_light'),
            low_light_distance: lumiere.get('low_light_distance'),
            emits_bright_light: lumiere.get('emits_bright_light'),
            bright_light_distance: lumiere.get('bright_light_distance'),
          });
          if (copyLum) {
            al.set('max', copyLum.id);
            lumiere.remove();
          }
        }
      });
    }
  }

  //Actions \xE0 faire pour maintenir la coh\xE9rence des tokens qui repr\xE9sentent le m\xEAme personnage.
  function changePlayerPage(campaign) {
    let currentMap = getObj('page', campaign.get('playerpageid'));
    let tokens = findObjs({
      _pageid: currentMap.id,
      _type: 'graphic',
      _subtype: 'token'
    });
    tokens.forEach(function(token) {
      let charId = token.get('represents');
      if (charId === undefined || charId === '') return; // Si token li\xE9 \xE0 un perso
      if (token.get('bar1_link') === '') return; // Si unique
      let perso = {
        token,
        charId
      };
      synchronisationDesEtats(perso);
      synchronisationDesLumieres(perso, currentMap.id);
    });
  }

  function enleveDecoince(perso, evt) {
    let tokenBougeAttr = tokenAttribute(perso, 'bougeGraceA');
    if (tokenBougeAttr.length === 0) return;
    if (evt) evt.deletedAttributes = evt.deletedAttributes || [];
    tokenBougeAttr.forEach(function(a) {
      let tokenBouge = getObj('graphic', a.get('current'));
      if (tokenBouge) {
        if (evt) deleteTokenWithUndo(tokenBouge, evt);
        else tokenBouge.remove();
      } else {
        let pageId = perso.token.get('pageid');
        tokenBouge = findObjs({
          _type: 'graphic',
          _pageid: pageId,
          represents: perso.charId,
          name: 'decoince ' + perso.token.get('name')
        });
        if (tokenBouge.length > 0) {
          tokenBouge = tokenBouge[0];
          if (evt) deleteTokenWithUndo(tokenBouge, evt);
          else tokenBouge.remove();
        }
      }
      if (evt) evt.deletedAttributes.push(a);
      a.remove();
    });
  }


  function changeTokenLock(token, prev) {
    const charId = token.get('represents');
    if (charId === undefined || charId === '') return; // Uniquement si token li\xE9 \xE0 un perso
    if (token.get('lockMovement')) return; //Rien de sp\xE9cial \xE0 faire
    const perso = {
      token,
      charId
    };
    const evt = {
      type: "unlock",
      deletedAttributes: []
    };
    addEvent(evt);
    affectToken(perso.token, 'lockMovement', prev.lockMovement, evt);
    enleveDecoince(perso, evt);
  }

  function changeDoor(door, prev) {
    if (!stateCOF.pause) return;
    if (prev.isOpen) return;
    if (door.get('isOpen')) {
      door.set('isOpen', false);
      let b = boutonSimple('!cof-open-door ' + door.id, "Ouvrir");
      sendChat('COF', "/w GM " + b + " (jeu en pause)");
    }
  }

  return {
    apiCommand,
    nextTurn,
    destroyToken,
    moveToken,
    changeHandout,
    addToken,
    changeMarker,
    changeTokenLock,
    changePlayerPage,
    setStateCOF,
    scriptVersionToCharacter,
    changeDoor,
    predicateOfRaw,
    listAllAttacks,
    getWeaponStats
  };

}();

on('ready', function() {
  const scriptVersion = '3.11';
  on('add:token', COFantasy.addToken);
  on("change:campaign:playerpageid", COFantasy.changePlayerPage);
  state.COFantasy = state.COFantasy || {
    combat: false,
    eventId: 0,
    version: scriptVersion,
  };
  COFantasy.setStateCOF();
  if (state.COFantasy.version === undefined) {
    state.COFantasy.eventId = 0;
  }
  const handout = findObjs({
    _type: 'handout'
  });
  const characters = findObjs({
    _type: 'character',
  });
  if (state.COFantasy.version < 1.0) {
    log("Mise \xE0 jour des attributs et macros vers la version 1.0");
    //Mise \xE0 jour des effets temporaires avec _
    let strReg = "(rayon_affaiblissant|peau_d_ecorce|chant_des_heros|image_decalee|a_couvert|sous_tension|forgeron_|armeEnflammee)";
    let regName = new RegExp("^" + strReg);
    let regText = new RegExp(strReg);
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      let attrName = attr.get('name');
      if (regName.test(attrName)) {
        attrName = attrName.replace(/rayon_affaiblissant/, 'rayonAffaiblissant');
        attrName = attrName.replace(/peau_d_ecorce/, 'peauDEcorce');
        attrName = attrName.replace(/chant_des_heros/, 'chantDesHeros');
        attrName = attrName.replace(/image_decalee/, 'imageDecalee');
        attrName = attrName.replace(/a_couvert/, 'aCouvert');
        attrName = attrName.replace(/sous_tension/, 'sousTension');
        attrName = attrName.replace(/forgeron_([^_\s)]*)/, 'forgeron($1)');
        attrName = attrName.replace(/armeEnflammee([^_\s)]*)/, 'armeEnflammee($1)');
        attr.set('name', attrName);
      }
      //Pour les consommables, il faut aussi changer le champ max;
      let attrMax = attr.get('max');
      if (regText.test(attrMax)) {
        attrMax = attrMax.replace(/rayon_affaiblissant/g, 'rayonAffaiblissant');
        attrMax = attrMax.replace(/peau_d_ecorce/g, 'peauDEcorce');
        attrMax = attrMax.replace(/chant_des_heros/g, 'chantDesHeros');
        attrMax = attrMax.replace(/image_decalee/g, 'imageDecalee');
        attrMax = attrMax.replace(/a_couvert/g, 'aCouvert');
        attrMax = attrMax.replace(/sous_tension/g, 'sousTension');
        attrMax = attrMax.replace(/forgeron_([^_\s)]*)/g, 'forgeron($1)');
        attrMax = attrMax.replace(/armeEnflammee([^_\s)]*)/g, 'armeEnflammee($1)');
        attr.set('max', attrMax);
      }
    });
    let macros = findObjs({
      _type: 'macro'
    }).concat(findObjs({
      _type: 'ability'
    }));
    macros.forEach(function(m) {
      let action = m.get('action');
      if (regText.test(action)) {
        action = action.replace(/rayon_affaiblissant/g, 'rayonAffaiblissant');
        action = action.replace(/peau_d_ecorce/g, 'peauDEcorce');
        action = action.replace(/chant_des_heros/g, 'chantDesHeros');
        action = action.replace(/image_decalee/g, 'imageDecalee');
        action = action.replace(/a_couvert/g, 'aCouvert');
        action = action.replace(/sous_tension/g, 'sousTension');
        action = action.replace(/forgeron_([^_\s)]*)/g, 'forgeron($1)');
        action = action.replace(/armeEnflammee([^_\s)]*)/g, 'armeEnflammee($1)');
        m.set('action', action);
      }
    });
    log("Mise \xE0 jour effectu\xE9e.");
  }
  if (state.COFantasy.version < 2.0) {
    log("Mise \xE0 jour des attributs et macros vers la version 2.0");
    let strReg = "(--argent)";
    let regName = new RegExp("^" + strReg);
    let regText = new RegExp(strReg);
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      let attrName = attr.get('name');
      if (regName.test(attrName)) {
        attrName = attrName.replace(/--argent/, '--armeDArgent');
        attr.set('name', attrName);
      }
      //Pour les consommables, il faut aussi changer le champ max;
      let attrMax = attr.get('max');
      if (regText.test(attrMax)) {
        attrMax = attrMax.replace(/--argent/g, '--armeDArgent');
        attr.set('max', attrMax);
      }
    });
    let macros = findObjs({
      _type: 'macro'
    }).concat(findObjs({
      _type: 'ability'
    }));
    macros.forEach(function(m) {
      let action = m.get('action');
      if (regText.test(action)) {
        action = action.replace(/--argent/g, '--armeDArgent');
        m.set('action', action);
      }
    });
    log("Mise \xE0 jour effectu\xE9e.");
  }
  if (state.COFantasy.version < 2.02) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      let attrName = attr.get('name');
      if (attrName == 'mort-vivant') attr.set('name', 'mortVivant');
    });
    log("Mise \xE0 jour effectu\xE9e.");
  }
  if (state.COFantasy.version < 2.03) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      let attrName = attr.get('name');
      if (attrName == 'runeDEnergie') attr.set('name', 'runeForgesort_\xE9nergie');
      if (attrName == 'runeDeProtection') attr.set('name', 'runeForgesort_protection');
      if (attrName.includes('runeDePuissance')) {
        attr.set('name', 'runeForgesort_puissance(' + attrName.substring(attrName.indexOf("(") + 1, attrName.indexOf(")")) + ')');
      }
    });
    log("Mise \xE0 jour des runes effectu\xE9e.");
  }
  if (state.COFantasy.version < 2.04) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      let attrName = a.get('name');
      if (!attrName.startsWith('RD_')) return;
      if (attrName == 'RD_critique') return;
      let rds = parseInt(a.get('current'));
      if (isNaN(rds) || rds < 1) {
        a.remove();
        return;
      }
      let cid = a.get('characterid');
      let attrRD = 'RDS';
      let attrRDS = findObjs({
        _type: 'attribute',
        _characterid: cid,
        name: attrRD
      }, {
        caseInsensitive: true
      });
      if (attrRDS.length === 0) {
        attrRDS = createObj('attribute', {
          characterid: cid,
          name: attrRD,
          current: '',
          max: ''
        });
      } else attrRDS = attrRDS[0];
      let rdPerso = attrRDS.get('current');
      attrName = attrName.substring(3);
      if (attrName.startsWith('sauf_')) {
        attrName = attrName.substr(5);
        if (rdPerso.trim() === '') rdPerso = rds + '/' + attrName;
        else rdPerso += ', ' + rds + '/' + attrName;
        attrRDS.set('current', rdPerso);
        a.remove();
        return;
      }
      if (attrName == 'rdt' || attrName == 'sauf') return;
      if (rdPerso.trim() === '') rdPerso = attrName + ':' + rds;
      else rdPerso += ', ' + attrName + ':' + rds;
      attrRDS.set('current', rdPerso);
      a.remove();
    });
    log("Mise \xE0 jour de la RD effectu\xE9e");
  }
  if (state.COFantasy.version < 2.05) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      let attrName = a.get('name');
      if (!attrName.startsWith('dose_') && !attrName.startsWith('consommable_')) return;
      let action = a.get('max');
      if (!action.startsWith('!cof-lancer-sort')) return;
      let mana = action.charAt(17);
      let message = action.substring(19);
      a.set("max", "!cof-lancer-sort --message " + message + " --mana " + mana);
    });
    log("Mise \xE0 jour des consommables !cof-lancer-sort effectu\xE9e");
    let macros = findObjs({
      _type: 'macro'
    }).concat(findObjs({
      _type: 'ability'
    }));
    macros.forEach(function(m) {
      let macro = m.get("action");
      if (!macro.startsWith('!cof-lancer-sort')) return;
      let mana = macro.charAt(17);
      let message = macro.substring(19);
      m.set("action", "!cof-lancer-sort --message " + message + " --mana " + mana);
    });
    log("Mise \xE0 jour des ability & macros !cof-lancer-sort effectu\xE9e");
  }
  if (state.COFantasy.version < 2.10) {
    let tokens = findObjs({
      _type: 'graphic',
      _subtype: 'token'
    });
    tokens.forEach(function(token) {
      let charId = token.get('represents');
      if (charId === '') return;
      let bar1_link = token.get('bar1_link');
      if (bar1_link === '') return;
      let attrLie = getObj('attribute', bar1_link);
      if (attrLie === undefined) return;
      if (attrLie.get('name') != 'pnj_pv') return;
      let attrPV = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'PV'
      }, {
        caseInsensitive: true
      });
      if (attrPV.length === 0) return;
      token.set('bar1_link', attrPV[0].id);
    });
    let charsToTreat = characters.length;
    let removeAttrs = function() {
      charsToTreat--;
      if (charsToTreat > 0) return;
      log("Supression des attributs obsol\xE8tes");
      let attrs = findObjs({
        _type: 'attribute',
      });
      attrs.forEach(function(a) {
        switch (a.get('name')) {
          case 'PR1':
          case 'PR2':
          case 'PR3':
          case 'PR4':
          case 'PR5':
          case 'pnj_pv':
          case 'pnj_dmtemp':
          case 'pnj_rd':
            a.remove();
        }
      });
    };
    if (charsToTreat === 0) removeAttrs();
    const pageId = Campaign().get('playerpageid');
    characters.forEach(function(character) {
      character.get('_defaulttoken', function(token) {
        if (token === '') {
          removeAttrs();
          return;
        }
        token = JSON.parse(token);
        if (!token) {
          removeAttrs();
          return;
        }
        let bar1_link = token.bar1_link;
        if (bar1_link === '') {
          removeAttrs();
          return;
        }
        let attrLie = getObj('attribute', bar1_link);
        if (attrLie === undefined) {
          removeAttrs();
          return;
        }
        if (attrLie.get('name') != 'pnj_pv') {
          removeAttrs();
          return;
        }
        let attrPV = findObjs({
          _type: 'attribute',
          _characterid: character.id,
          name: 'PV'
        }, {
          caseInsensitive: true
        });
        if (attrPV.length === 0) {
          removeAttrs();
          return;
        }
        token.bar1_link = attrPV[0].id;
        token.pageid = pageId;
        token.imgsrc = token.imgsrc.replace('/med.png', '/thumb.png');
        token.imgsrc = token.imgsrc.replace('/max.png', '/thumb.png');
        let newToken = createObj('graphic', token);
        if (newToken) {
          setDefaultTokenForCharacter(character, newToken);
          newToken.remove();
        } else {
          log('Impossible de cr\xE9er un token pour ' + token.name);
          log(token);
        }
        removeAttrs();
      });
    });
    log("Mise \xE0 jour des attributs et tokens effectu\xE9e");
  }
  if (state.COFantasy.version < 2.11) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      if (a.get('name') != 'capitaine') return;
      let nomCapitaine = a.get('current');
      let idCapitaine = a.get('max');
      let na = {
        current: idCapitaine + ' ' + nomCapitaine,
        max: 2
      };
      a.set(na);
    });
    log("Mise \xE0 jour des attributs de capitaine effectu\xE9e");
  }
  if (state.COFantasy.version < 2.12) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      let attrName = a.get('name');
      if (!attrName.startsWith('dose_') && !attrName.startsWith('consommable_')) return;
      let charId = a.get('characterid');
      //On ne passe dans la liste que pour les persos de type PJ
      let typePerso = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'type_personnage',
      }, {
        caseInsensitive: true
      });
      if (typePerso.length > 0 && typePerso[0].get('current') != 'PJ') return;
      let consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ');
      if (consName === '') return;
      let quantite = parseInt(a.get('current'));
      if (isNaN(quantite) || quantite < 0) return;
      let pref = 'repeating_equipement_' + generateRowID() + '_';
      let versionFiche = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'version',
      }, {
        caseInsensitive: true
      });
      if (versionFiche.length === 0) versionFiche = 0;
      else versionFiche = parseFloat(versionFiche[0].get('current'));
      if (versionFiche < 4.01) {
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip-nom',
          current: consName
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip-qte',
          current: quantite
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip-effet',
          current: a.get('max').trim(),
        });
      } else {
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip_nom',
          current: consName
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip_qte',
          current: quantite
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip_effet',
          current: a.get('max').trim(),
        });
      }
      a.remove();
    });
    log("D\xE9placement des attributs de consommables vers la fiche");
  }
  if (state.COFantasy.version < 2.13) {
    //On enl\xE8ve les attributs obsol\xE8tes de la verison 4.00 de la fiche
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      if (a.get('name').toLowerCase() == 'equip-div') {
        if (a.get('current') === '') {
          a.remove();
          return;
        }
        let charId = a.get('characterid');
        let newAttr = findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: 'equip_div',
        }, {
          caseInsensitive: true
        });
        newAttr = newAttr.filter(function(na) {
          if (na.get('current') === '') {
            na.remove();
            return false;
          }
          return true;
        });
        if (newAttr.length === 0) {
          a.set('name', 'equip_div');
        } else {
          let character = getObj('character', charId);
          if (character === undefined) return;
          sendChat("COFantasy", "Supprimer l'attribut 'equip-div' du personnage" + character.get('name'));
          log("Supprimer l'attribut 'equip-div' du personnage" + character.get('name'));
          log("valeur courante " + newAttr[0].get('current'));
          log("Ancienne valeur " + a.get('current'));
          return;
        }
      }
    });
  }
  if (state.COFantasy.version < 2.14) {
    //Migration des \xE9l\xE9ments de r\xE8gles optionnels
    //Divers
    if (state.COFantasy.options.regles.val.poudre_explosif) {
      state.COFantasy.options.regles.val.divers.val.poudre_explosif.val = state.COFantasy.options.regles.val.poudre_explosif.val;
      delete state.COFantasy.options.regles.val.poudre_explosif;
    }
    if (state.COFantasy.options.regles.val.forme_d_arbre_amelioree) {
      state.COFantasy.options.regles.val.divers.val.forme_d_arbre_amelioree.val = state.COFantasy.options.regles.val.forme_d_arbre_amelioree.val;
      delete state.COFantasy.options.regles.val.forme_d_arbre_amelioree;
    }
    if (state.COFantasy.options.regles.val.interchangeable_attaque) {
      state.COFantasy.options.regles.val.divers.val.interchangeable_attaque.val = state.COFantasy.options.regles.val.interchangeable_attaque.val;
      delete state.COFantasy.options.regles.val.interchangeable_attaque;
    }
    //Dommages
    if (state.COFantasy.options.regles.val.dm_minimum) {
      state.COFantasy.options.regles.val.dommages.val.dm_minimum.val = state.COFantasy.options.regles.val.dm_minimum.val;
      delete state.COFantasy.options.regles.val.dm_minimum;
    }
    if (state.COFantasy.options.regles.val.crit_elementaire) {
      state.COFantasy.options.regles.val.dommages.val.crit_elementaire.val = state.COFantasy.options.regles.val.crit_elementaire.val;
      delete state.COFantasy.options.regles.val.crit_elementaire;
    }
    if (state.COFantasy.options.regles.val.blessures_graves) {
      state.COFantasy.options.regles.val.dommages.val.blessures_graves.val = state.COFantasy.options.regles.val.blessures_graves.val;
      delete state.COFantasy.options.regles.val.blessures_graves;
    }
    //Haute DEF
    if (state.COFantasy.options.regles.val.usure_DEF) {
      state.COFantasy.options.regles.val.haute_DEF.val.usure_DEF.val = state.COFantasy.options.regles.val.usure_DEF.val;
      delete state.COFantasy.options.regles.val.usure_DEF;
    }
    if (state.COFantasy.options.regles.val.generer_options_attaques) {
      log("Options d'attaques supprim\xE9es ; veuiller utiliser le bouton 'Options' de la liste d'Actions \xE0 la place");
      sendChat('COFantasy', "Options d'attaques supprim\xE9es ; veuiller utiliser le bouton 'Options' de la liste d'Actions \xE0 la place");
      delete state.COFantasy.options.regles.val.generer_options_attaques;
    }
    if (state.COFantasy.options.regles.val.generer_attaque_groupe) {
      log("Attaques de groupe supprim\xE9es ; veuiller utiliser le bouton 'Options' de la liste d'Actions \xE0 la place");
      sendChat('COFantasy', "Options d'attaques supprim\xE9es ; veuiller utiliser le bouton 'Options' de la liste d'Actions \xE0 la place");
      delete state.COFantasy.options.regles.val.generer_attaque_groupe;
    }
    if (state.COFantasy.options.regles.val.bonus_attaque_groupe) {
      state.COFantasy.options.regles.val.haute_DEF.val.bonus_attaque_groupe.val = state.COFantasy.options.regles.val.bonus_attaque_groupe.val;
      delete state.COFantasy.options.regles.val.bonus_attaque_groupe;
    }
    if (state.COFantasy.options.regles.val.crit_attaque_groupe) {
      state.COFantasy.options.regles.val.haute_DEF.val.crit_attaque_groupe.val = state.COFantasy.options.regles.val.crit_attaque_groupe.val;
      delete state.COFantasy.options.regles.val.crit_attaque_groupe;
    }
    //Initiative
    if (state.COFantasy.options.regles.val.initiative_variable) {
      state.COFantasy.options.regles.val.initiative.val.initiative_variable.val = state.COFantasy.options.regles.val.initiative_variable.val;
      delete state.COFantasy.options.regles.val.initiative_variable;
    }
    if (state.COFantasy.options.regles.val.initiative_variable_individuelle) {
      state.COFantasy.options.regles.val.initiative.val.initiative_variable_individuelle.val = state.COFantasy.options.regles.val.initiative_variable_individuelle.val;
      delete state.COFantasy.options.regles.val.initiative_variable_individuelle;
    }
    //Mana
    if (state.COFantasy.options.regles.val.mana_totale) {
      state.COFantasy.options.regles.val.mana.val.mana_totale.val = state.COFantasy.options.regles.val.mana_totale.val;
      delete state.COFantasy.options.regles.val.mana_totale;
    }
    if (state.COFantasy.options.regles.val.elixirs_sorts) {
      state.COFantasy.options.regles.val.mana.val.elixirs_sorts.val = state.COFantasy.options.regles.val.elixirs_sorts.val;
      delete state.COFantasy.options.regles.val.elixirs_sorts;
    }
    log("R\xE8gles optionelles mises \xE0 jour");
  }
  if (state.COFantasy.version < 2.15) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      let attrName = a.get('name');
      if (!attrName.startsWith('dose_') && !attrName.startsWith('consommable_')) return;
      let charId = a.get('characterid');
      //On ne passe dans la liste que pour les persos de type PNJ
      let typePerso = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'type_personnage',
      }, {
        caseInsensitive: true
      });
      if (typePerso.length > 0 && typePerso[0].get('current') == 'PJ') return;
      let consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ');
      if (consName === '') return;
      let quantite = parseInt(a.get('current'));
      if (isNaN(quantite) || quantite < 0) return;
      let pref = 'repeating_equipement_' + generateRowID() + '_';
      createObj('attribute', {
        _characterid: charId,
        name: pref + 'equip_nom',
        current: consName
      });
      createObj('attribute', {
        _characterid: charId,
        name: pref + 'equip_qte',
        current: quantite
      });
      createObj('attribute', {
        _characterid: charId,
        name: pref + 'equip_effet',
        current: a.get('max').trim(),
      });
      a.remove();
    });
    log("D\xE9placement des attributs de consommables de PNJs vers la fiche");
  }
  if (state.COFantasy.version < 2.16) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    let handouts = findObjs({
      _type: 'handout'
    });
    let handhoutComp = handouts.find(function(h) {
      let handName = h.get('name');
      return (handName == 'Comp\xE9tences' || handName == 'Competences');
    });
    if (handhoutComp) {
      let listeCompetences = {
        FOR: [],
        DEX: [],
        CON: [],
        SAG: [],
        INT: [],
        CHA: [],
        nombre: 0
      };
      handhoutComp.get('notes', function(note) { // asynchronous
        let carac; //La carac dont on sp\xE9cifie les comp\xE9tences actuellement
        note = note.trim();
        if (note.startsWith('<p>')) note = note.substring(3);
        note = note.trim().replace(/<span[^>]*>|<\/span>/g, '');
        note = note.replace(/<p>/g, '<br>');
        note = note.replace(/<\/p>/g, '');
        let lignes = note.trim().split('<br>');
        lignes.forEach(function(ligne) {
          ligne = ligne.trim();
          let header = ligne.split(':');
          if (header.length > 1) {
            let c = header.shift().trim().toUpperCase();
            if (c != 'FOR' && c != 'CON' && c != 'DEX' && c != 'INT' && c != 'SAG' && c != 'CHA') return;
            carac = c;
            ligne = header.join(':').trim();
          }
          if (ligne.length === 0) return;
          if (carac === undefined) {
            log("Comp\xE9tences sans caract\xE9ristique associ\xE9e");
            return;
          }
          let comps = ligne.split(/, |\/| /);
          comps.forEach(function(comp) {
            if (comp.length === 0) return;
            listeCompetences[carac].push(comp);
            listeCompetences.nombre++;
          });
        });
        let compToCarac = {};
        listeCompetences.FOR.forEach(function(c) {
          compToCarac[c] = 'FOR';
          compToCarac[c.toLowerCase()] = 'FOR';
        });
        listeCompetences.CON.forEach(function(c) {
          compToCarac[c] = 'CON';
          compToCarac[c.toLowerCase()] = 'CON';
        });
        listeCompetences.DEX.forEach(function(c) {
          compToCarac[c] = 'DEX';
          compToCarac[c.toLowerCase()] = 'DEX';
        });
        listeCompetences.INT.forEach(function(c) {
          compToCarac[c] = 'INT';
          compToCarac[c.toLowerCase()] = 'INT';
        });
        listeCompetences.SAG.forEach(function(c) {
          compToCarac[c] = 'SAG';
          compToCarac[c.toLowerCase()] = 'SAG';
        });
        listeCompetences.CHA.forEach(function(c) {
          compToCarac[c] = 'CHA';
          compToCarac[c.toLowerCase()] = 'CHA';
        });
        attrs.forEach(function(a) {
          let attrName = a.get('name');
          switch (attrName) {
            case 'RACE':
              a.set('name', 'race');
              return;
            case 'PROFIL':
              a.set('name', 'profil');
              return;
            case 'NIVEAU':
              a.set('name', 'niveau');
              return;
            case 'SEXE':
              a.set('name', 'sexe');
              return;
            case 'AGE':
              a.set('name', 'age');
              return;
            case 'TAILLE':
              a.set('name', 'taille');
              return;
            case 'POIDS':
              a.set('name', 'poids');
              return;
            case 'FORCE':
              a.set('name', 'force');
              return;
            case 'DEXTERITE':
              a.set('name', 'dexterite');
              return;
            case 'CONSTITUTION':
              a.set('name', 'constitution');
              return;
            case 'INTELLIGENCE':
              a.set('name', 'intelligence');
              return;
            case 'SAGESSE':
              a.set('name', 'sagesse');
              return;
            case 'CHARISME':
              a.set('name', 'charisme');
              return;
          }
          //Les comp\xE9tences
          let charId = a.get('characterid');
          //On ne bouge les comp\xE9tences que pour les persos de type PJ
          let typePerso = findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: 'type_personnage',
          }, {
            caseInsensitive: true
          });
          if (typePerso.length > 0 && typePerso[0].get('current') != 'PJ') return;
          if (compToCarac[attrName] === undefined) return;
          let prefix = 'repeating_competences_' + generateRowID() + '_comp_';
          let attrSpec = {
            characterid: charId
          };
          attrSpec.name = prefix + 'nom';
          attrSpec.current = attrName;
          createObj('attribute', attrSpec);
          attrSpec.name = prefix + 'bonus';
          attrSpec.current = a.get('current');
          let attrBonus = createObj('attribute', attrSpec);
          attrSpec.name = prefix + 'bonusTotal';
          createObj('attribute', attrSpec);
          attrSpec.name = prefix + 'carac';
          attrSpec.current = compToCarac[attrName];
          createObj('attribute', attrSpec);
          let attrMalus;
          if ((attrSpec.current == 'DEX' && attrName != 'crochetage' && attrName != 'd\xE9samor\xE7age') ||
            (attrSpec.current == 'CON' && attrName == 'survie') ||
            attrName == 'natation' || attrName == 'escalade') {
            attrSpec.name = prefix + 'malus';
            attrSpec.current = 'armure';
            attrMalus = createObj('attribute', attrSpec);
            attrBonus.setWithWorker('current', a.get('current'));
            attrMalus.setWithWorker('current', 'armure');
          } else if (attrName == 'perception' || attrName == 'vigilance') {
            attrSpec.name = prefix + 'malus';
            attrSpec.current = 'casque';
            attrMalus = createObj('attribute', attrSpec);
            attrBonus.setWithWorker('current', a.get('current'));
            attrMalus.setWithWorker('current', 'casque');
          }
          a.remove();
        });
      }); //end hand.get(notes)
    } else {
      attrs.forEach(function(a) {
        let attrName = a.get('name');
        switch (attrName) {
          case 'RACE':
            a.set('name', 'race');
            return;
          case 'PROFIL':
            a.set('name', 'profil');
            return;
          case 'NIVEAU':
            a.set('name', 'niveau');
            return;
          case 'SEXE':
            a.set('name', 'sexe');
            return;
          case 'AGE':
            a.set('name', 'age');
            return;
          case 'TAILLE':
            a.set('name', 'taille');
            return;
          case 'POIDS':
            a.set('name', 'poids');
            return;
          case 'FORCE':
            a.set('name', 'force');
            return;
          case 'DEXTERITE':
            a.set('name', 'dexterite');
            return;
          case 'CONSTITUTION':
            a.set('name', 'constitution');
            return;
          case 'INTELLIGENCE':
            a.set('name', 'intelligence');
            return;
          case 'SAGESSE':
            a.set('name', 'sagesse');
            return;
          case 'CHARISME':
            a.set('name', 'charisme');
            return;
        }
      });
    }
    log("Mise \xE0 jour des attributs de comp\xE9tence effectu\xE9");
  }
  if (state.COFantasy.version < 2.17) {
    let macros = findObjs({
      _type: 'macro'
    }).concat(findObjs({
      _type: 'ability'
    }));
    macros.forEach(function(m) {
      let macro = m.get("action");
      let newMacro = macro.replace("!cof-tenebres @{selected|token_id} --disque @{target|token_id} 5 20",
        "!cof-tenebres @{selected|token_id} @{target|token_id}");
      if (macro !== newMacro)
        m.set("action", newMacro);
    });
    log("Mise \xE0 jour des ability T\xE9n\xE8bres effectu\xE9e");
  }
  let updateReset = function(a, nom, typ) {
    let c = parseInt(a.get('current'));
    let m = parseInt(a.get('max'));
    if (c === m) return;
    if (isNaN(m)) return;
    a.set('current', m);
    createObj('attribute', {
      name: 'limitePar' + typ + '__' + nom,
      characterid: a.get('characterid'),
      current: c
    });
  };
  if (state.COFantasy.version < 2.18) {
    if (state.COFantasy.combat) {
      let attrs = findObjs({
        _type: 'attribute',
      });
      attrs.forEach(function(a) {
        let nom = a.get('name');
        switch (nom) {
          case 'chairACanon':
          case 'attaqueEnTraitre':
          case 'paradeDeProjectiles':
          case 'prouesse':
          case 'devierLesCoups':
            updateReset(a, nom, 'Tour');
            return;
          case 'increvable':
          case 'esquiveFatale':
          case 'interventionDivine':
          case 'petitVeinard':
          case 'prescience':
          case 'kiai':
            updateReset(a, nom, 'Combat');
            return;
          default:
            return;
        }
      });
    }
    log("Mise \xE0 jour des attributs effectu\xE9e");
  }
  if (state.COFantasy.version < 3.00) {
    let macros = findObjs({
      _type: 'macro'
    });
    characters.forEach(function(c) {
      let cid = c.id;
      let abilities = findObjs({
        _type: 'ability',
        _characterid: cid,
      });
      let actionsDuTour;
      let actionAbilities = abilities.filter(function(a) {
        let an = a.get('name');
        if (an.startsWith('#') && an.endsWith('#')) {
          if (actionsDuTour) return true;
          if (an == '#TurnAction#' || an == '#Actions#') {
            actionsDuTour = a;
            return false;
          }
          return true;
        }
        return false;
      });
      let listeARemplir = 1;
      let abilitiesInList = new Set();
      actionAbilities.forEach(function(a) {
        if (listeARemplir > 4) return;
        let listeActions = a.get('action')
          .replace(/\n/gm, '').replace(/\r/gm, '')
          .replace(/%#([^#]*)#/g, '\n!cof-liste-actions $1')
          .replace(/\/\/%/g, '\n\/\/__pc')
          .replace(/\/\/#/g, '\n\/\/__mc')
          .replace(/\/\/!/g, '\n\/\/__cmd')
          .replace(/%/g, '\n%').replace(/#/g, '\n#').replace(/!/g, '\n!')
          .split('\n');
        if (listeActions.length === 0) return;
        let n = 0;
        let attrRang = findObjs({
          _type: 'attribute',
          _characterid: cid,
          name: 'maxrangaction' + listeARemplir
        }, {
          caseInsensitive: true
        });
        if (attrRang && attrRang.length > 0) {
          attrRang = attrRang[0];
          n = parseInt(attrRang.get('current'));
          if (isNaN(n) || n < 0) n = 0;
        } else {
          attrRang = createObj('attribute', {
            name: 'maxrangaction' + listeARemplir,
            current: 0,
            characterid: cid
          });
        }
        listeActions.forEach(function(action) {
          action = action.trim();
          if (action === '') return;
          if (n === 0 && action.startsWith('!options')) {
            createObj('attribute', {
              name: 'optionslisteactions' + listeARemplir,
              current: action.substring(8).trim(),
              characterid: cid,
            });
            createObj('attribute', {
              name: 'action' + listeARemplir + 'optflag',
              current: 'on',
              characterid: cid,
            });
            return;
          }
          let pref = 'repeating_actions' + listeARemplir + '_' + generateRowID() + '_';
          n++;
          if (action.startsWith('//')) {
            action = action.substring(2);
            if (action.startsWith('__pc')) {
              action = action.substr(4);
              abilitiesInList.add(action.split(' ')[0]);
              action = '%' + action;
            } else if (action.startsWith('__mc')) action = '#' + action.substr(4);
            else if (action.startsWith('__cmd')) action = '!' + action.substr(5);
            createObj('attribute', {
              name: pref + 'actiontitre',
              current: action,
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actionmontree',
              current: 0,
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actionoptflag',
              current: 'off',
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actionrang',
              current: n,
              characterid: cid,
            });
            return;
          }
          if (action.startsWith('!cof-liste-actions ')) {
            action = action.substring(19);
            createObj('attribute', {
              name: pref + 'actiontype',
              current: 'liste',
              characterid: cid,
            });
          } else if (action.startsWith('%')) {
            let abName = action.split(' ')[0].substr(1);
            abilitiesInList.add(abName);
          }
          createObj('attribute', {
            name: pref + 'actiontitre',
            current: action,
            characterid: cid,
          });
          createObj('attribute', {
            name: pref + 'actionoptflag',
            current: 'off',
            characterid: cid,
          });
          createObj('attribute', {
            name: pref + 'actionrang',
            current: n,
            characterid: cid,
          });
        });
        if (n === 0) return;
        let an = a.get('name');
        createObj('attribute', {
          name: 'nomlisteaction' + listeARemplir,
          current: an.substring(1, an.length - 1),
          characterid: cid,
        });
        attrRang.set('current', n);
        listeARemplir++;
        a.remove();
      });
      let n = 0;
      let attrRang = findObjs({
        _type: 'attribute',
        _characterid: cid,
        name: 'maxrangaction'
      }, {
        caseInsensitive: true
      });
      if (attrRang && attrRang.length > 0) {
        attrRang = attrRang[0];
        n = parseInt(attrRang.get('current'));
        if (isNaN(n) || n < 0) n = 0;
      } else {
        attrRang = createObj('attribute', {
          name: 'maxrangaction',
          current: 0,
          characterid: cid
        });
      }
      if (actionsDuTour) {
        let actions = actionsDuTour.get('action')
          .replace(/\n/gm, '').replace(/\r/gm, '')
          .replace(/%#([^#]*)#/g, '\n!cof-liste-actions $1')
          .replace(/\/\/%/g, '\n\/\/__pc')
          .replace(/\/\/#/g, '\n\/\/__mc')
          .replace(/\/\/!/g, '\n\/\/__cmd')
          .replace(/%/g, '\n%').replace(/#/g, '\n#').replace(/!/g, '\n!')
          .split('\n');
        actions.forEach(function(action) {
          action = action.trim();
          if (action === '') return;
          let pref;
          let actionMontree = true;
          if (action.startsWith('//')) {
            action = action.substring(2);
            if (action.startsWith('__pc')) action = '%' + action.substr(4);
            else if (action.startsWith('__mc')) action = '#' + action.substr(4);
            else if (action.startsWith('__cmd')) action = '!' + action.substr(5);
            actionMontree = false;
          }
          if (action.startsWith('!cof-liste-actions ')) {
            n++;
            pref = 'repeating_actions_' + generateRowID() + '_';
            createObj('attribute', {
              name: pref + 'actionoptflag',
              current: 'off',
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actionrang',
              current: n,
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actiontitre',
              current: action.substring(19),
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actiontype',
              current: 'liste',
              characterid: cid,
            });
            if (!actionMontree) createObj('attribute', {
              name: pref + 'actionmontree',
              current: 0,
              characterid: cid,
            });
            return;
          }
          let actionCommands = action.split(' ');
          actionCommands = actionCommands.filter(function(c) {
            return c !== '';
          });
          let actionCmd = actionCommands[0];
          let actionText = actionCmd.replace(/-/g, ' ').replace(/_/g, ' ');
          let found = false;
          switch (actionCmd.charAt(0)) {
            case '%':
              // Ability
              actionCmd = actionCmd.substr(1);
              actionText = actionText.substr(1);
              abilities.forEach(function(abilitie, index) {
                if (found) return;
                if (abilitie.get('name') === actionCmd) {
                  // l'ability existe
                  found = true;
                  n++;
                  pref = 'repeating_actions_' + generateRowID() + '_';
                  createObj('attribute', {
                    name: pref + 'actionoptflag',
                    current: 'off',
                    characterid: cid,
                  });
                  createObj('attribute', {
                    name: pref + 'actionrang',
                    current: n,
                    characterid: cid,
                  });
                  if (!actionMontree) createObj('attribute', {
                    name: pref + 'actionmontree',
                    current: 0,
                    characterid: cid,
                  });
                  if (abilitiesInList.has(actionCmd) || abilitie.get('istokenaction')) {
                    //On garde le texte partag\xE9 de l'ability.
                    createObj('attribute', {
                      name: pref + 'actiontitre',
                      current: action,
                      characterid: cid,
                    });
                    return;
                  }
                  let command = abilitie.get('action').trim();
                  if (actionCommands.length > 1) {
                    //On rajoute les options de l'ability
                    command += action.substr(action.indexOf(' '));
                  }
                  createObj('attribute', {
                    name: pref + 'actiontitre',
                    current: actionText,
                    characterid: cid,
                  });
                  createObj('attribute', {
                    name: pref + 'actioncode',
                    current: command,
                    characterid: cid,
                  });
                  //On peut effacer l'ability
                  abilitie.remove();
                }
              });
              return;
            case '#':
              n++;
              pref = 'repeating_actions_' + generateRowID() + '_';
              createObj('attribute', {
                name: pref + 'actionoptflag',
                current: 'off',
                characterid: cid,
              });
              createObj('attribute', {
                name: pref + 'actionrang',
                current: n,
                characterid: cid,
              });
              if (!actionMontree) createObj('attribute', {
                name: pref + 'actionmontree',
                current: 0,
                characterid: cid,
              });
              // Macro
              //D'abord le cas de #Attaque, car le nom affich\xE9 est celui de l'arme
              if (actionCmd == '#Attaque' && actionCommands.length > 1) {
                createObj('attribute', {
                  name: pref + 'actiontitre',
                  current: action,
                  characterid: cid,
                });
                return;
              }
              actionCmd = actionCmd.substr(1);
              actionText = actionText.substr(1);
              macros.forEach(function(macro, index) {
                if (found) return;
                if (macro.get('name') === actionCmd) {
                  found = true;
                  let command = macro.get('action').trim();
                  if (actionCommands.length > 1) {
                    //On rajoute les options de la macro
                    command += action.substr(action.indexOf(' '));
                  }
                  createObj('attribute', {
                    name: pref + 'actiontitre',
                    current: actionText,
                    characterid: cid,
                  });
                  createObj('attribute', {
                    name: pref + 'actioncode',
                    current: command,
                    characterid: cid,
                  });
                }
              });
              return;
            default:
              n++;
              pref = 'repeating_actions_' + generateRowID() + '_';
              createObj('attribute', {
                name: pref + 'actionoptflag',
                current: 'off',
                characterid: cid,
              });
              createObj('attribute', {
                name: pref + 'actionrang',
                current: n,
                characterid: cid,
              });
              createObj('attribute', {
                name: pref + 'actiontitre',
                current: action,
                characterid: cid,
              });
              if (!actionMontree) createObj('attribute', {
                name: pref + 'actionmontree',
                current: 0,
                characterid: cid,
              });
          }
        });
        actionsDuTour.remove();
      } else if (state.COFantasy.options &&
        state.COFantasy.options.affichage &&
        state.COFantasy.options.affichage.val &&
        state.COFantasy.options.affichage.val.actions_par_defaut.val) {
        //Par d\xE9faut, on montrait la liste de toutes les abilities
        abilities.forEach(function(a) {
          n++;
          let pref = 'repeating_actions_' + generateRowID() + '_';
          createObj('attribute', {
            name: pref + 'actionoptflag',
            current: 'off',
            characterid: cid,
          });
          createObj('attribute', {
            name: pref + 'actionrang',
            current: n,
            characterid: cid,
          });
          let nom = a.get('name');
          if (nom.startsWith('#') && nom.endsWith('#')) {
            createObj('attribute', {
              name: pref + 'actiontitre',
              current: nom.substring(1, nom.length - 2),
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actiontype',
              current: 'liste',
              characterid: cid,
            });
          } else if (a.get('istokenaction')) {
            createObj('attribute', {
              name: pref + 'actiontitre',
              current: '%' + nom,
              characterid: cid,
            });
          } else { //On copie l'ability et on l'efface
            let actionText = nom.replace(/-/g, ' ').replace(/_/g, ' ');
            let command = a.get('action').trim();
            createObj('attribute', {
              name: pref + 'actiontitre',
              current: actionText,
              characterid: cid,
            });
            createObj('attribute', {
              name: pref + 'actioncode',
              current: command,
              characterid: cid,
            });
            a.remove();
          }
        });
      }
      if (n > 0) attrRang.set('current', n);
    });
    log("Mise \xE0 jour des listes d'action effectu\xE9e");
    //Ensuite les pr\xE9dicats bool\xE9ens
    let predicates = '^(' +
      'actionLibre|agripper|ambidextreDuelliste|animal|argumentDeTaille' +
      '|armureProtection|aucuneActionCombat|baroudHonneur' +
      '|botteMortelle|bouclierPsi|briseurDOs|bucheron|champion' +
      '|chasseurEmerite|chatimentDuMale|chimiste|ciblesMultiples' +
      '|combatEnPhalange|combatKinetique|commandant|controleDuMetabolisme' +
      '|creatureArtificielle|crocEnJambe|defenseIntuitive|d\xE9mon|devorer' +
      '|durACuire|ecuyer|elfeNoir|enchainement|energieDeLaMort' +
      '|estUneIllusion|exsangue|f\xE9e|fievreChene|frappeChirurgicale|gober' +
      '|graceFeline|graceFelineVoleur|grosMonstreGrosseArme|grosseTete' +
      '|hachesEtMarteaux|hausserLeTon|horsDePortee|humanoide' +
      '|ignorerLaDouleur|immuniteAuxArmes|immuniteAuxSournoises' +
      '|immuniteSaignement|increvableHumain|inderacinable|insecte' +
      '|insensibleAffaibli|instinctDeSurvieHumain|intelligenceDuCombat' +
      '|invisibleEnCombat|invulnerable|joliCoup|langageSombreHetre' +
      '|liberteDAction|manoeuvreDuelliste|mauvais|memePasMal|monture' +
      '|montureLoyale|montureMagique|morsureDuSerpent|mortVivant' +
      '|nAbandonneJamais|natureNourriciereBaies|nonVivant' +
      '|ordreDuChevalierDragon|peauDePierre|peutEnrager|projection' +
      '|proprioception|protectionDMZone|quadrupede|raillerieImpossible' +
      '|reduireLaDistance|riposte|saisirEtBroyer|sangDeFerIf' +
      '|sansEsprit|sansPeur|scienceDuCritique|secondSouffle|sensAffutes' +
      '|sergent|tirParabolique|tourDeForce|tropPetit|ventreMou' +
      '|vieArtificielle' +
      '|diviseEffet_.*|immunite_.*|protectionDMZone_.*' +
      ')$';
    let predicateRegExp = new RegExp(predicates);
    let parChar = {};
    findObjs({
      _type: 'attribute',
    }).forEach(function(attribute) {
      let nom = attribute.get('name');
      if (predicateRegExp.test(nom)) {
        let charId = attribute.get('characterid');
        parChar[charId] = parChar[charId] || new Set();
        parChar[charId].add(nom);
        attribute.remove();
      } else {
        switch (nom) {
          case 'immunitePeur':
            {
              let charId = attribute.get('characterid');
              parChar[charId] = parChar[charId] || new Set();
              parChar[charId].add('immunite_peur');
              attribute.remove();
            }
            break;
          case 'immuniteContreSurprise':
            {
              let charId = attribute.get('characterid');
              parChar[charId] = parChar[charId] || new Set();
              parChar[charId].add('immunite_surpris');
              attribute.remove();
            }
            break;
          case 'geant':
            {
              let charId = attribute.get('characterid');
              parChar[charId] = parChar[charId] || new Set();
              parChar[charId].add('g\xE9ant');
              attribute.remove();
            }
            break;
        }
      }
    });
    for (let charId in parChar) {
      let pred = parChar[charId];
      let predText = '';
      for (let p of pred) {
        predText += p + ' ';
      }
      let attr = findObjs({
        _tyoe: 'attribute',
        _characterid: charId,
        name: 'predicats_script'
      }, {
        caseInsensitive: true
      });
      if (attr.length === 0) {
        createObj('attribute', {
          name: 'predicats_script',
          current: predText,
          characterid: charId
        });
      } else {
        attr = attr[0];
        attr.set('current', predText + attr.get('current'));
      }
    }
    log("Transformation des attributs bool\xE9ens en pr\xE9dicats");
  }
  let getPredicateAttr = function(charId) {
    let attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: 'predicats_script'
    }, {
      caseInsensitive: true
    });
    let predText = '';
    if (attr.length === 0) {
      attr = createObj('attribute', {
        name: 'predicats_script',
        current: '',
        characterid: charId
      });
    } else {
      attr = attr[0];
      predText = attr.get('current');
      if (predText !== '') predText += '\n';
    }
    return {
      attr,
      predText
    };
  };
  if (state.COFantasy.version < 3.01) {
    let predicates = '^(' +
      'absorptionEnergie|adaptable|armureDeVent|attaqueEnMeute' +
      '|cavalierEmerite|coefPVMana|DEF_magie|dentellesEtRapiere' +
      '|esquiveVoleur|faireMouche|frenesie|initEnMain' +
      '|increvable|instinctDeSurvie|interventionDivine|loupParmiLesLoups' +
      '|piquresDInsectes|prouesse|radarMental|RD_critique|reflexesFelins' +
      '|siphonDesAmes|siphonDesAmesPrioritaire|tirPrecis|vetementsSacres' +
      '|visionDansLeNoir|voieDeLaConjuration|voieDeLArcEtDuCheval' +
      '|voieDeLaMagieElementaire|voieDeLaSurvie|voieDeLaTelekinesie' +
      '|voieDeLHonneur|voieDesElixirs|voieDesMutations|voieDesRunes' +
      '|voieDesSoins|voieDesVegetaux|voieDuGuerisseur' +
      '|voieDuMeneurDHomme|voieDuMetal|voieDuSoldat|vulnerableCritique' +
      '|initEnMain.*' +
      ')$';
    let predicateRegExp = new RegExp(predicates);
    let parChar = {};
    findObjs({
      _type: 'attribute',
    }).forEach(function(attribute) {
      let nom = attribute.get('name');
      if (predicateRegExp.test(nom)) {
        let charId = attribute.get('characterid');
        parChar[charId] = parChar[charId] || {};
        parChar[charId][nom] = attribute.get('current');
        attribute.remove();
      }
    });
    for (let charId in parChar) {
      let pred = parChar[charId];
      let {
        attr,
        predText
      } = getPredicateAttr(charId);
      for (let p in pred) {
        let val = pred[p];
        if (val === 'true') predText += p + ' ';
        else predText += p + ':' + val + ' ';
      }
      attr.set('current', predText);
    }
    log("Transformation des attributs num\xE9riques en pr\xE9dicats");
  }
  if (state.COFantasy.version < 3.02) {
    const regPJ = new RegExp("^(repeating_armes_[^_]*_)(.*)$");
    const regPNJ = new RegExp("^(repeating_pnjatk_[^_]*_)(.*)$");
    characters.forEach(function(c) {
      const charId = c.id;
      let reg;
      const attrType = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'type_personnage'
      }, {
        caseInsensitive: true
      });
      if (attrType.length === 0 || attrType[0].get('current') == 'PJ') {
        reg = regPJ;
      } else {
        reg = regPNJ;
      }
      let attributes = findObjs({
        _type: 'attribute',
        _characterid: charId,
      });
      let munitions = {}; //map de nom de munition d'attaques vers attribut
      let attaques = {};
      attributes.forEach(function(attr) {
        const nom = attr.get('name');
        if (nom.length > 9 && nom.startsWith('munition_')) {
          let fin = nom.substring(9);
          munitions[fin] = attr;
          return;
        }
        const m = reg.exec(nom);
        if (!m) return;
        attaques[m[1]] = attaques[m[1]] || {};
        attaques[m[1]][m[2]] = attr;
      });
      _.forEach(attaques, function(att, pref) {
        if (att.armetypeattaque === undefined) return;
        if (att.armetypeattaque.get('current') != 'Arme de jet') return;
        let options = [];
        if (att.armeoptions !== undefined) {
          options = att.armeoptions.get('current');
          if (options.startsWith('-')) options = ' ' + options;
          options = options.split(' --');
        }
        let typesMunitions = 0;
        let current = 1;
        let max = 1;
        let taux = 0;
        let attrMunition;
        let optionsSansMunitions = options.filter(function(opt) {
          opt = opt.trim();
          let cmd = opt.split(' ');
          if (cmd.length < 2) return true;
          if (cmd[0] != 'munition') return true;
          let ma = munitions[cmd[1]];
          if (ma === undefined) return true;
          attrMunition = ma;
          typesMunitions++;
          max = parseInt(ma.get('max'));
          if (isNaN(max) || max < 0) max = 1;
          current = parseInt(ma.get('current'));
          if (isNaN(current) || current < 0 || current > max) current = max;
          if (cmd.length > 2) {
            taux = parseInt(cmd[2]);
            if (isNaN(taux) || taux < 0 || taux > 100) taux = 0;
          } else {
            taux = 100; //La valeur par d\xE9faut en option.
          }
          return false;
        });
        if (typesMunitions == 1) {
          let qte = att.armejetqte;
          if (qte === undefined) {
            if (current !== 1 || max !== 1) {
              createObj('attribute', {
                characterid: charId,
                name: pref + 'armejetqte',
                current: current,
                max: max
              });
            }
          } else {
            qte.set('current', current);
            qte.set('max', max);
          }
          let at = att.armejettaux;
          if (at === undefined) {
            if (taux !== 0) {
              createObj('attribute', {
                characterid: charId,
                name: pref + 'armejettaux',
                current: taux
              });
            }
          } else {
            at.set('current', taux);
          }
          att.armeoptions.set('current', optionsSansMunitions.join(' --'));
          attrMunition.remove();
        } else { // On ne sait pas faire la traduction
          let mod = att.armemodificateurs;
          if (mod === undefined) {
            createObj('attribute', {
              characterid: charId,
              name: pref + 'armemodificateurs',
              current: 'retourneEnMain'
            });
          } else {
            mod.set('current', mod.get('current') + ' retourneEnMain');
          }
        }
      });
    });
    log("Mise \xE0 jour des armes de jet effectu\xE9e");
  }
  if (state.COFantasy.version < 3.03) {
    findObjs({
      _type: 'attribute',
    }).forEach(function(attribute) {
      let nom = attribute.get('name');
      if (nom != 'armeParDefaut') return;
      let charId = attribute.get('characterid');
      let arme = attribute.get('current');
      attribute.remove();
      let {
        attr,
        predText
      } = getPredicateAttr(charId);
      predText += 'armeParDefaut';
      if (arme.trim() !== '') predText += ':' + arme;
      attr.set('current', predText);
    });
    log("Mise \xE0 jour de pr\xE9dicats effectu\xE9e");
  }
  if (state.COFantasy.version < 3.04) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    if (state.COFantasy.combat) {
      attrs.forEach(function(a) {
        let nom = a.get('name');
        switch (nom) {
          case 'resistanceALaMagieBarbare':
          case 'esquiveAcrobatique':
          case 'paradeMagistrale':
          case 'paradeAuBouclier':
            updateReset(a, nom, 'Tour');
            return;
          default:
            return;
        }
      });
    }
    let predicates = '^(' +
      'armureLourdeGuerrier|attaqueEnTraitre|bonusFeinte|chairACanon' +
      '|corpsElementaire|devierLesCoups' +
      '|esquiveAcrobatique|esquiveFatale|fauchage|frappeDuVide|interchangeable|kiai|pacifisme|pacteSanglant|paradeAuBouclier|paradeMagistrale' +
      '|paradeDeProjectiles|petitVeinard|porteurDuBouclierDeGrabuge|prescience|resistanceALaMagie' +
      '|resistanceALaMagieBarbare|riposteGuerrier|tirFatal|traquenard|voieOutreTombe' +
      '|bonusSaveContre_.*|eclaire_.*' +
      ')$';
    let predicateRegExp = new RegExp(predicates);
    let parChar = {};
    attrs.forEach(function(attribute) {
      let nom = attribute.get('name');
      if (predicateRegExp.test(nom)) {
        let charId = attribute.get('characterid');
        parChar[charId] = parChar[charId] || {};
        parChar[charId][nom] = attribute.get('current');
        if (nom == 'bonusFeinte') {
          let nbDesFeinte = attribute.get('max');
          if (nbDesFeinte !== '') parChar[charId].nbDesFeinte = nbDesFeinte;
        } else if (nom == 'pacifisme') {
          parChar[charId][nom] = attribute.get('max');
        } else if (nom == 'traquenard') {
          parChar[charId][nom] = 'true';
        } else if (nom == 'fauchage') {
          let tailleFauchage = attribute.get('max');
          if (tailleFauchage !== '')
            parChar[charId].tailleFauchage = tailleFauchage;
        } else if (nom.startsWith('eclaire_')) {
          let eclaireFaible = attribute.get('max');
          if (eclaireFaible !== '') {
            let nomFaible = nom.replace('eclaire_', 'eclaireFaible_');
            parChar[charId][nomFaible] = eclaireFaible;
          }
        }
        attribute.remove();
      }
      if (nom.startsWith('charge_')) {
        let charId = attribute.get('characterid');
        parChar[charId] = parChar[charId] || {};
        parChar[charId][nom] = attribute.get('current');
        //On n'efface pas, l'attribut reste pour la valeur courante de charge
      } else if (nom == 'defierLaMort') {
        let charId = attribute.get('characterid');
        parChar[charId] = parChar[charId] || {};
        parChar[charId][nom] = 'true';
      }
    });
    for (let charId in parChar) {
      let pred = parChar[charId];
      let {
        attr,
        predText
      } = getPredicateAttr(charId);
      for (let p in pred) {
        let val = pred[p];
        if (val === 'true' || val === '' || val == 1) predText += p + ' ';
        else predText += p + ':' + val + ' ';
      }
      attr.set('current', predText);
    }
    log("Transformation d'attributs de combat en pr\xE9dicats");
  }
  if (state.COFantasy.version < 3.05) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      let name = a.get('name');
      if (name == 'pnj_armure' || name == 'pnj_bouclier') a.remove();
    });
    log("Suppression des attributs pnj d'armure et de bouclier");
  }
  if (state.COFantasy.version < 3.07) {
    //Collecte des persos ayant un pr\xE9dicat charge_ ou eclaire_
    let charIds = {};
    let attrs = findObjs({
      _type: 'attribute',
    });
    const change = /(charge_|eclaire_|initEnMain)/;
    attrs.forEach(function(a) {
      let n = a.get('name');
      if (n.match(/^repeating_(armes|pnjatk)_[^_]*_armespec$/)) {
        let spec = a.get('current');
        if (spec.includes('DEF ')) {
          spec = spec.replace(/\bDEF\b\s*\+/g, 'DEF:');
          a.set('current', spec);
        }
        return;
      }
      if (n == 'armeBonusDef' || n == 'armeGaucheBonusDef') {
        a.remove();
        return;
      }
      if (n == 'predicats_script') {
        let pred = a.get('current');
        if (pred === '') return;
        if (change.test(pred)) {
          charIds[a.get('characterid')] = pred;
        }
      }
    });
    let setSpecial = function(nom, pred, predicates, attaques, charId) {
      let l = nom.length + 1;
      let label = pred.substring(l);
      let att = attaques[label];
      if (att === undefined) return;
      let special = att.armespec;
      if (special === undefined || special === '') special = nom;
      else special += ' ' + nom;
      let valeur = parseInt(predicates[pred]);
      if (!isNaN(valeur)) special += ':' + valeur;
      att.armespec = special;
      let attrName = att.prefixe + 'armespec';
      let attr = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attrName
      });
      if (attr.length > 0) {
        attr[0].set('current', special);
      } else {
        createObj('attribute', {
          name: attrName,
          current: special,
          characterid: charId
        });
      }
    };
    for (let charId in charIds) {
      let predicates = COFantasy.predicateOfRaw(charIds[charId]);
      let perso = {
        charId
      };
      const attaques = COFantasy.listAllAttacks(perso);
      let initEnMainToDo = true;
      for (let pred in predicates) {
        if (pred.startsWith('charge_')) {
          setSpecial('charge', pred, predicates, attaques, charId);
        } else if (pred.startsWith('eclaire_')) {
          setSpecial('eclaire', pred, predicates, attaques, charId);
        } else if (pred.startsWith('eclaireFaible_')) {
          setSpecial('eclaireFaible', pred, predicates, attaques, charId);
        } else if (initEnMainToDo && pred.startsWith('initEnMain')) {
          let label = pred.substring(10);
          let att = attaques[label];
          if (att === undefined) continue;
          let newPred = 'plusViteQueSonOmbre:';
          let arme = COFantasy.getWeaponStats(perso, label);
          if (!arme.poudre && arme.arbalete) newPred += 'arbalete';
          let valeur = parseInt(predicates[pred]);
          if (isNaN(valeur) || valeur == 10) {
            if (newPred.endsWith(':')) newPred = newPred.substring(0, newPred.length - 1);
          } else {
            newPred += valeur;
          }
          let {
            attr,
            predText
          } = getPredicateAttr(charId);
          predText = predText.replace(/initEnMain.*:\s*\d+\b/, newPred);
          predText = predText.replace(/initEnMain.*:\s*\d+\b/g, '');
          attr.set('current', predText);
          initEnMainToDo = false;
        }
      }
    }
    log("Copie des pr\xE9dicats de charge et \xE9clairage vers les attaques des armes");
  }
  if (state.COFantasy.version < 3.08) {
    let attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      let n = a.get('name');
      if (!n.startsWith('poisonRapide_')) return;
      let cur = 'rapide ' + a.get('current');
      let nouveauNom = 'enduitDePoison' + n.substring(12);
      a.set('name', nouveauNom);
      a.set('current', cur);
    });
    log("Changement de nom d'attributs pour les armes enduites de poison");
  }
  if (state.COFantasy.version < 3.09) {
    if (state.COFantasy.combat === true) {
      state.COFantasy.combat = {
        pageId: state.COFantasy.combat_pageid,
      };
    }
    state.COFantasy.combat_pageid = undefined;
    state.COFantasy.activeTokenId = undefined;
    state.COFantasy.activeTokenName = undefined;
    state.COFantasy.tour = undefined;
    state.COFantasy.init = undefined;
    state.COFantasy.usureOff = undefined;
  }
  if (state.COFantasy.version < 3.10) {
    let attrs_preds = findObjs({
      _type: 'attribute',
      name: 'predicats_script'
    });
    attrs_preds.forEach(function(a) {
      let preds = a.get('current');
      if (preds.includes('laissez-le-moi')) {
        preds = preds.replace('laissez-le-moi', 'laissezLeMoi');
        a.set('current', preds);
      }
    });
    log("Changement du pr\xE9dicat laissez-le-moi");
  }
  if (state.COFantasy.version < 3.11) {
    //aura sera pass\xE9 en actions plus tard
    let predicates = '^(' +
      'attributsDeStatut|chairACanonDe|defDeriveeDe|dmSiToucheContact' +
      '|ecuyerDe|ennemiJure|entrerEnCombatAvec|familier|guetteur' +
      '|initiativeDeriveeDe|lienEpique|messageSiCritique|montureDe' +
      '|PVPartagesAvec|surveillance|tokenFormeDArbre|vitaliteSurnaturelle' +
      ')$';
    let predicateRegExp = new RegExp(predicates);
    let parChar = {};
    findObjs({
      _type: 'attribute',
    }).forEach(function(attribute) {
      let nom = attribute.get('name');
      if (predicateRegExp.test(nom)) {
        let charId = attribute.get('characterid');
        parChar[charId] = parChar[charId] || getPredicateAttr(charId);
        let text = parChar[charId].predText;
        text += nom + '::' + attribute.get('current');
        let m = attribute.get('max');
        if (m) {
          switch (nom) {
            case 'vitaliteSurnaturelle':
              text += '/' + m;
              break;
            case 'dmSiToucheContact':
              text += ' --' + m;
              break;
            default:
              log("Attribut " + nom + " avec un champ max " + m);
              text += '\n// max: ' + m;
          }
        }
        parChar[charId].predText = text + '\n';
        attribute.remove();
      }
    });
    for (let charId in parChar) {
      parChar[charId].attr.set('current', parChar[charId].predText);
    }
    log("Transformation des attributs complexes en pr\xE9dicats");
  }
  state.COFantasy.version = scriptVersion;
  handout.forEach(function(hand) {
    COFantasy.changeHandout(hand);
  });
  //V\xE9rification de la version sur les fiches
  characters.forEach(function(c) {
    COFantasy.scriptVersionToCharacter(c, 11);
  });
  COF_loaded = true;
  let load_msg = "COFantasy " + scriptVersion;
  if (COF_BETA) load_msg += ' beta';
  log(load_msg + " loaded");
});

on("chat:message", function(msg) {
  "use strict";
  if (COF_loaded && msg.type == "api" && msg.content.startsWith('!cof-')) {
    if (COF_BETA) {
      COFantasy.apiCommand(msg);
    } else {
      try {
        COFantasy.apiCommand(msg);
      } catch (e) {
        sendChat('COF', "Erreur durant l'ex\xE9cution de " + msg.content);
        log("Erreur durant l'ex\xE9cution de " + msg.content);
        log(msg);
        let errMsg = e.name;
        if (e.lineNumber) errMsg += " at " + e.lineNumber;
        else if (e.number) errMsg += " at " + e.number;
        errMsg += ': ' + e.message;
        sendChat('COF', errMsg);
        log(errMsg);
      }
    }
  }
});

on("change:handout", COFantasy.changeHandout);
on("destroy:handout", function(prev) {
  COFantasy.changeHandout(undefined, prev);
});
on("change:campaign:turnorder", COFantasy.nextTurn);
on('destroy:token', COFantasy.destroyToken);
on('change:graphic:lockMovement', COFantasy.changeTokenLock);
on('change:graphic:statusmarkers', COFantasy.changeMarker);
on('change:token', COFantasy.moveToken);
on('add:character', function(c) {
  if (COF_loaded) {
    COFantasy.scriptVersionToCharacter(c);
  }
});
on("change:door:isOpen", COFantasy.changeDoor);
on("change:attribute", function(attr, prev) {
  if (!COF_loaded) return;
  let predicats = state.COFantasy.predicats;
  if (!predicats) return;
  let n = attr.get("name");
  if (n == "predicats_script" || n.includes('armepredicats'))
    predicats[attr.get('characterid')] = undefined;
});
