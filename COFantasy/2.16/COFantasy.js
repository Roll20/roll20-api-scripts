// Needs the Vector Math scripty
// ------------------ generateRowID code from the Aaron ---------------------
var generateUUID = (function() {
    "use strict";
    var a = 0,
      b = [];
    return function() {
      var c = (new Date()).getTime() + 0,
        d = c === a;
      a = c;
      for (var e = new Array(8), f = 7; 0 <= f; f--) {
        e[f] = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(c % 64);
        c = Math.floor(c / 64);
      }
      c = e.join("");
      if (d) {
        for (f = 11; 0 <= f && 63 === b[f]; f--) {
          b[f] = 0;
        }
        b[f]++;
      } else {
        for (f = 0; 12 > f; f++) {
          b[f] = Math.floor(64 * Math.random());
        }
      }
      for (f = 0; 12 > f; f++) {
        c += "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(b[f]);
      }
      return c;
    };
  }()),

  generateRowID = function() {
    "use strict";
    return generateUUID().replace(/_/g, "Z");
  };
//--------------- end generateRowID ----------------------------------------

var COF_loaded = false;

var COFantasy = COFantasy || function() {

  "use strict";

  const PIX_PER_UNIT = 70;
  const HISTORY_SIZE = 150;
  const BS_LABEL = 'text-transform: uppercase; display: inline; padding: .2em .6em .3em; font-size: 75%; line-height: 2; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: .25em;';
  const BS_LABEL_SUCCESS = 'background-color: #5cb85c;';
  const BS_LABEL_INFO = 'background-color: #5bc0de;';
  const BS_LABEL_WARNING = 'background-color: #f0ad4e;';
  const BS_LABEL_DANGER = 'background-color: #d9534f;';
  const DEFAULT_DYNAMIC_INIT_IMG = 'https://s3.amazonaws.com/files.d20.io/images/4095816/086YSl3v0Kz3SlDAu245Vg/thumb.png?1400535580';

  var markerCatalog = {};
  var eventHistory = [];
  var updateNextInitSet = new Set();

  var flashyInitMarkerScale = 1.6;

  var defaultOptions = {
    regles: {
      explications: "Options qui influent sur les règles du jeu",
      type: 'options',
      val: {
        divers: {
          explications: "Options diverses",
          type: 'options',
          val: {
            forme_d_arbre_amelioree: {
              explications: "+50% à l'effet de la peau d'écorce en forme d'arbre.",
              val: true,
              type: 'bool'
            },
            poudre_explosif: {
              explications: "Les armes à poudre font des dégâts explosifs",
              val: true,
              type: 'bool'
            },
            interchangeable_attaque: {
              explications: "La capacité interchangeable donne moins de DEF mais plus d'attaque",
              val: true,
              type: 'bool'
            }
          }
        },
        dommages: {
          explications: "Règles optionnelles sur les dommages",
          type: 'options',
          val: {
            blessures_graves: {
              explications: "Si les DMs dépassent CON+niveau, ou si on arrive à 0 PV, on perd un PR, et si plus de PR, affaibli.",
              val: true,
              type: 'bool'
            },
            dm_minimum: {
              explications: "Dégâts minimum d'une attaque ou autre source de DM.",
              val: 0,
              type: 'int'
            },
            crit_elementaire: {
              explications: "Les DMs constants d'un autre type que celui de l'arme sont aussi multipliés en cas de critique",
              val: false,
              type: 'bool'
            },
            max_rune_protection: {
              explications: "Les DMs qu'une rune de protection est capable d'absorber sont limités à 10x le rang du forgesort dans la voie des runes",
              val: true,
              type: 'bool'
            }
          }
        },
        haute_DEF: {
          explications: "Options de jeu pour gérer la haute DEF",
          type: 'options',
          val: {
            usure_DEF: {
              explications: "Malus de -2 en DEF tous les n tours. Mettre à 0 pour ne pas avoir de malus d'usure",
              val: 5,
              type: 'int'
            },
            bonus_attaque_groupe: {
              explications: "Lors d'une attaque de groupe, bonus à la touche par créature supplémentaire",
              val: 2,
              type: 'int'
            },
            crit_attaque_groupe: {
              explications: "Lors d'une attaque de groupe, si le jet de touche dépasse DEF + cette valeur, les dommages sont doublés (0 = jamais)",
              val: 5,
              type: 'int'
            }
          }
        },
        initiative: {
          explications: "Options qui influent sur les règles du jeu",
          type: 'options',
          val: {
            initiative_variable: {
              explications: "Ajoute 1d6 à l'initiative, lancé une fois par combat par type de créature",
              val: false,
              type: 'bool'
            },
            initiative_variable_individuelle: {
              explications: "Lancer l'initiative variable pour chaque créature (nécessite d'activer l'Initiative variable)",
              val: false,
              type: 'bool'
            }
          }
        },
        mana: {
          explications: "Options de Mana",
          type: 'options',
          val: {
            mana_totale: {
              explications: "Tous les sorts ont un coût, celui des tempêtes de mana est multiplié par 3",
              val: false,
              type: 'bool'
            },
            contrecoup: {
              explications: "Avec la Mana Totale, permet au lanceur de sort de payer un déficit de PM en PV (COF p. 181)",
              val: false,
              type: 'bool'
            },
            brulure_de_magie: {
              explications: "Permettre d'utiliser ses PV comme PM (Magie de CO Terres d'Arran, incompatible avec Mana Totale)",
              val: false,
              type: 'bool'
            },
            elixirs_sorts: {
              explications: "Toutes fabrications d'élixir sont considérées comme des sorts (qui peuvent coûter de la mana)",
              val: true,
              type: 'bool'
            },
          }
        }
      }
    },
    affichage: {
      explications: "Options d'affichage",
      type: 'options',
      val: {
        MJ_voit_actions: {
          explications: "À chaque nouveau personnage en combat, montre le choix d'actions au MJ, même pour les PJs.",
          val: false,
          type: 'bool'
        },
        avatar_dans_cadres: {
          explications: "Si faux, on utilise l'image du token.",
          val: true,
          type: 'bool'
        },
        manoeuvres: {
          explications: "Affiche les manoeuvres dans la liste d'actions",
          val: true,
          type: 'bool'
        },
        actions_par_defaut: {
          explications: "Sans ability #Actions#, affiche la liste des abilities",
          val: true,
          type: 'bool'
        },
        montre_def: {
          explications: "montre la DEF des adversaires dans les cadres de combat",
          val: true,
          type: 'bool'
        },
        duree_effets: {
          explications: "Le script indique la durée des effets associés aux tokens",
          val: false,
          type: 'bool'
        },
        init_dynamique: {
          explications: "Fait apparître une aura dynamique sur le token qui a l'initiative",
          val: true,
          type: 'bool'
        },
        fiche: {
          explications: "La fiche interagit avec le script",
          val: true,
          type: 'bool'
        },
        markers_personnalises: {
          explications: "Utilisation des markers personnalisés commençant par cof",
          val: true,
          type: 'bool'
        },
        table_crit: {
          explications: "Utilisation d'une table de critiques nommée Echec-Critique-Contact",
          val: false,
          type: 'bool'
        },
        depense_mana: {
          explications: "Le script précise la quantité de mana utilisée dans le chat à chaque fois",
          val: false,
          type: 'bool'
        }
      }
    },
    images: {
      explications: "Images par défaut",
      type: 'options',
      val: {
        image_init: {
          explications: "Image utilisée pour indiquer le personnage dont c'est le tour",
          type: 'image',
          val: DEFAULT_DYNAMIC_INIT_IMG
        },
        image_double: {
          explications: 'Image utilisée pour la capacité dédoublement',
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/33854984/q10B3KtWsCxcMczLo4BSUw/thumb.png?1496303265"
        },
        image_ombre: {
          explications: "Image utilisée pour l'ombre mortelle",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/2781735/LcllgIHvqvu0HAbWdXZbJQ/thumb.png?13900368485"
        },
        image_arbre: {
          explications: "Image utilisée pour la forme d'arbre",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/52767134/KEGYUXeKnxZr5dbDwQEO4Q/thumb.png?15248300835"
        },
        image_mur_de_force: {
          explication: "Image utilisée pour un mur de force sphérique",
          type: 'image',
          val: "https://s3.amazonaws.com/files.d20.io/images/33213510/5r3NGSso1QBJMJewTEKv0A/thumb.png?1495195634"
        },
      }
    },
    macros_a_jour: {
      explications: "Met automatiquement les macros à jour",
      type: 'bool',
      val: true
    }
  };

  function copyOptions(dst, src) {
    for (var o in src) {
      var opt = src[o];
      var isOption = opt.type == 'options';
      if (dst[o] === undefined) {
        dst[o] = {
          explications: opt.explications,
          val: {},
          type: opt.type,
        };
        if (!isOption) dst[o].val = opt.val;
      }
      if (isOption) copyOptions(dst[o].val, opt.val);
    }
  }

  //Liste de tables par défaut
  var gameTables = [{
    name: "Echec-Critique-Contact",
    showplayers: false,
    items: [{
      name: "FOR - Bousculé  : le personnage est renversé par son adversaire. Il subit un dé malus au test de FOR si l’adversaire " +
        "est d’une catégorie de taille supérieure et bénéficie d’un dé bonus dans le cas inverse. " +
        "Il subit une attaque gratuite de la part d’un adversaire pendant qu’il est étalé au sol (-5 en DEF).",
      weight: 1,
    }, {
      name: "DEX - Maladresse : le personnage laisse tomber au sol l'objet avec lequel il attaque. S’il essaye de le ramasser, " +
        "il subit une attaque gratuite.",
      weight: 1,
    }, {
      name: "CON - Coup de mou: le personnage subit l’état affaibli pendant 3 rounds. Ou il peut annuler cet état en reprenant" +
        "son souffle par une action limitée.",
      weight: 1,
    }, {
      name: "INT - Erreur tactique : le personnage subit une attaque (gratuite) d’un adversaire à son contact.",
      weight: 1,
    }, {
      name: "SAG - Distrait : le personnage se laisse distraire et ne voit pas venir la prochaine attaque, " +
        "l’adversaire bénéficiera d’un bonus de +10.",
      weight: 1,
    }, {
      name: "CHA - Ridicule : le personnage fait un faux mouvement à la fois douloureux et ridicule, il subit " +
        "l’état étourdi pendant un round pour reprendre contenance.",
      weight: 1,
    }, {
      name: "Votre arme se brise . S’il s’agit d’une arme magique, le dé DM est simplement réduit d'une catégorie " +
        "(2d6/d12=>d10=>d8=>d6=>d4=>d3) jusqu’à la fin du combat.",
      weight: 1,
    }, {
      name: "Une pièce d’armure bouge et elle devient plus gênante que protectrice Cuir : - 1 en DEF et en attaque " +
        "pour le reste du combat. Maille : -2, Plaque -3.",
      weight: 1,
    }, {
      name: "Simple échec de l'attaque",
      weight: 12,
    }, ],
  }, ];

  var stateCOF = state.COFantasy;
  var reglesOptionelles; // = stateCOF.options.regles.val;

  // List of states:
  var cof_states = {
    assome: 'status_pummeled',
    mort: 'status_dead',
    surpris: 'status_lightning-helix',
    renverse: 'status_back-pain',
    aveugle: 'status_bleeding-eye',
    affaibli: 'status_half-heart',
    etourdi: 'status_half-haze',
    paralyse: 'status_fishing-net',
    ralenti: 'status_snail',
    immobilise: 'status_cobweb',
    endormi: 'status_sleepy',
    apeure: 'status_screaming',
    invisible: 'status_ninja-mask',
    blesse: 'status_arrowed',
    encombre: 'status_frozen-orb',
    penombre: 'status_archery-target',
    enseveli: 'status_edge-crack'
  };

  //Remplis quand on sait quels sont les markers dans setStateCOF
  var etat_de_marker = {};

  function tokenAttribute(personnage, name) {
    var token = personnage.token;
    // Tokens Mook : attribut mook d'abord, attribut character sinon
    if (token && token.get('bar1_link') === '') {
      var mookName = name + "_" + token.get('name');
      var attrs = findObjs({
        _type: 'attribute',
        _characterid: personnage.charId,
      });
      var attrMook = [];
      var attrCharacter = [];
      attrs.forEach(function(attr) {
        if (attr.get('name') == mookName) attrMook.push(attr);
        else if (attr.get('name') == name) attrCharacter.push(attr);
      });
      return attrMook.length > 0 ? attrMook : attrCharacter;
    } // Tokens Characters : recherche normale
    else return findObjs({
      _type: 'attribute',
      _characterid: personnage.charId,
      name: name
    });
  }

  function charAttribute(charId, name, option) {
    return findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: name
    }, option);
  }

  function attrAsInt(attr, def) {
    if (attr.length === 0) return def;
    attr = parseInt(attr[0].get('current'));
    if (isNaN(attr)) return def;
    return attr;
  }

  function attrAsBool(attr) {
    if (attr.length === 0) return false;
    attr = attr[0].get('current');
    if (attr == '0' || attr == 'false') return false;
    if (attr) return true;
    return false;
  }

  // Attention, def, la valeur par défaut, doit être la même que sur la fiche
  function ficheAttribute(personnage, name, def) {
    var attr = charAttribute(personnage.charId, name, {
      caseInsensitive: true
    });
    if (attr.length === 0) return def;
    return attr[0].get('current');
  }

  function ficheAttributeAsInt(personnage, name, def) {
    var attr = charAttribute(personnage.charId, name, {
      caseInsensitive: true
    });
    if (attr === undefined) return def;
    return attrAsInt(attr, def);
  }

  //Il faut une valeur par défaut, qui correspond à celle de la fiche
  function ficheAttributeAsBool(personnage, name, def) {
    var attr = charAttribute(personnage.charId, name, {
      caseInsensitive: true
    });
    if (attr.length === 0) return def;
    return attrAsBool(attr);
  }

  // Caution not to use token when the attribute should not be token dependant
  function attributeAsInt(personnage, name, def) {
    var attr = tokenAttribute(personnage, name);
    return attrAsInt(attr, def);
  }

  function attributeAsBool(personnage, name) {
    var attr = tokenAttribute(personnage, name);
    return attrAsBool(attr);
  }

  function charAttributeAsInt(perso, name, def) {
    var attr = charAttribute(perso.charId, name);
    return attrAsInt(attr, def);
  }

  function charAttributeAsBool(perso, name) {
    var attr = charAttribute(perso.charId, name);
    return attrAsBool(attr);
  }

  function charIdAttributeAsBool(charId, name) {
    var attr = charAttribute(charId, name);
    return attrAsBool(attr);
  }

  function error(msg, obj) {
    log(msg);
    log(obj);
    sendChat("COFantasy", msg);
  }

  function determineSettingDeJeu() {
    var characters = findObjs({
      _type: 'character'
    });
    var charsGenerique = [];
    var charsArran = [];
    characters.forEach(function(c) {
      var typePerso = charAttribute(c.id, 'type_personnage', {
        caseInsensitive: true
      });
      if (typePerso.length > 0 && typePerso[0].get('current') == 'PNJ')
        return; //Les fiches de PNJ sont les mêmes
      var setting = charAttribute(c.id, 'option_setting', {
        caseInsensitive: true
      });
      if (setting.length === 0) {
        charsGenerique.push(c);
        return;
      }
      if (setting[0].get('current') == 'arran') charsArran.push(c);
      else charsGenerique.push(c);
    });
    if (charsArran.length <= charsGenerique.length) {
      log("Utilisation des règles COF génériques");
      if (charsArran.length > 0) {
        error("Attention, des personnages suivent les options de jeu des Terres d'Arran (voir le log pour la liste)", charsArran);
        charsArran.forEach(function(c) {
          var g = getObj('character', c.id);
          if (g) log(g.get('name'));
          else log(c);
        });
        stateCOF.setting_mixte = true;
      }
      return;
    }
    log("Utilisation des règles des Terres d'Arran");
    if (charsGenerique.length > 0) {
      error("Attention, des personnages ne suivent pas les options de jeu des Terres d'Arran (voir le log pour la liste)", charsGenerique);
      charsGenerique.forEach(function(c) {
        var g = getObj('character', c.id);
        if (g) log(g.get('name'));
        else log(c);
      });
      stateCOF.setting_mixte = true;
      return;
    }
    stateCOF.setting_arran = true;
  }

  var statusForInitAlly;
  var statusForInitEnemy;

  //Appelé au lancement du script, mise à jour de certaines variables globales
  function setStateCOF() {
    stateCOF = state.COFantasy;
    if (stateCOF.roundMarkerId) {
      roundMarker = getObj('graphic', stateCOF.roundMarkerId);
      if (roundMarker === undefined) {
        log("Le marqueur d'init a changé d'id");
        roundMarker = findObjs({
          _type: 'graphic',
          represents: '',
          layer: 'objects',
          name: 'Init marker',
        });
        if (roundMarker.length > 0) {
          roundMarker = roundMarker[0];
          stateCOF.roundMarkerId = roundMarker.id;
        } else {
          roundMarker = undefined;
          stateCOF.roundMarkerId = undefined;
        }
      }
    }
    if (stateCOF.combat_pageid) {
      var pageCombat = getObj('page', stateCOF.combat_pageid);
      if (pageCombat === undefined) {
        if (stateCOF.roundMarkerId && roundMarker) {
          stateCOF.combat_pageid = roundMarker.get('pageid');
        } else {
          stateCOF.combat_pageid = Campaign().get('playerpageid');
        }
      }
    }
    if (!stateCOF.personnageCibleCree) {
      //On cherche si un personnage cible existe déjà
      var persos = findObjs({
        _type: 'character',
        name: 'Cible',
        controlledby: 'all'
      });
      if (persos.length === 0) {
        var pages = findObjs({
          _type: 'page'
        });
        if (pages.length > 0) {
          var pageId = pages[0].id;
          var charCible = createObj('character', {
            name: 'Cible',
            controlledby: 'all',
            inplayerjournals: 'all',
            avatar: 'https://s3.amazonaws.com/files.d20.io/images/33041174/5JdDVh-34C-kZglTE1aq-w/max.png?1494837870',
          });
          if (charCible) {
            var attrPV = charAttribute(charCible.id, 'PV', {
              caseInsensitive: true
            });
            if (attrPV.length > 0) attrPV = attrPV[0];
            else attrPV = createObj('attribute', {
              name: 'PV',
              characterid: charCible.id,
              current: 0,
              max: 0
            });
            var attrType = charAttribute(charCible.id, 'type_personnage', {
              caseInsensitive: true
            });
            if (attrType.length > 0) {
              attrType[0].setWithWorker('current', 'PNJ');
            } else {
              attrType = createObj('attribute', {
                name: 'type_personnage',
                characterid: charCible.id,
                current: 'PJ',
              });
              attrType.setWithWorker('current', 'PNJ');
            }
            var tokenCible = createObj('graphic', {
              name: 'Cible',
              layer: 'objects',
              _pageid: pageId,
              imgsrc: 'https://s3.amazonaws.com/files.d20.io/images/33041174/5JdDVh-34C-kZglTE1aq-w/thumb.png?1494837870',
              represents: charCible.id,
              width: PIX_PER_UNIT,
              height: PIX_PER_UNIT,
              bar1_link: attrPV ? attrPV.id : ''
            });
            if (tokenCible) {
              setDefaultTokenForCharacter(charCible, tokenCible);
              tokenCible.remove();
            }
          }
        }
      }
      stateCOF.personnageCibleCree = true;
    }
    //Création des tables par défaut
    if (!stateCOF.tablesCrees) {
      var allTables = findObjs({
        _type: "rollabletable",
      });
      gameTables.forEach(function(gameTable) {
        var table = allTables.find(function(table) {
          return table.get("name") == gameTable.name;
        });
        if (table === undefined) {
          table = createObj("rollabletable", {
            name: gameTable.name,
            showplayers: gameTable.showplayers,
          });
          gameTable.items.forEach(function(tableItem) {
            tableItem.rollabletableid = table.id;
            createObj("tableitem", tableItem);
          });
        }
      });
      stateCOF.tablesCrees = true;
    }
    // Le setting
    determineSettingDeJeu();
    // Les options de jeu
    if (stateCOF.options === undefined) stateCOF.options = {};
    copyOptions(stateCOF.options, defaultOptions);
    reglesOptionelles = stateCOF.options.regles.val;
    // Les macros utiles en jeu
    if (stateCOF.options.macros_a_jour.val) {
      var macros = findObjs({
        _type: 'macro'
      });
      var players = findObjs({
        _type: 'player'
      });
      var mjs = [];
      players.forEach(function(p) {
        if (playerIsGM(p.id)) mjs.push(p.id);
      });
      var inBar = [];
      if (stateCOF.gameMacros) {
        //Check modified or removed macros
        stateCOF.gameMacros.forEach(function(gm) {
          var ngm = gameMacros.find(function(ngm) {
            return ngm.name == gm.name;
          });
          if (ngm) {
            if (ngm.action == gm.action && ngm.visibleto == gm.visibleto && ngm.istokenaction == gm.istokenaction) return;
            macros.forEach(function(m) {
              if (m.get('name') != ngm.name) return;
              if (ngm.action != gm.action && m.get('action') == gm.action)
                m.set('action', ngm.action);
              if (ngm.visibleto != gm.visibleto && m.get('visibleto') == gm.visibleto)
                m.set('visibleto', ngm.visibleto);
              if (ngm.istokenaction != gm.istokenaction && m.get('istokenaction') == gm.istokenaction)
                m.set('istokenaction', ngm.istokenaction);
              sendChat('COF', '/w GM Macro ' + ngm.name + ' mise à jour.');
            });
          } else {
            macros.forEach(function(m) {
              if (m.get('name') != gm.name) return;
              if (m.get('action') != gm.action) return;
              m.remove();
              sendChat('COF', '/w GM Macro ' + ngm.name + ' effacée.');
            });
          }
        });
        //Nouvelles macros
        gameMacros.forEach(function(ngm) {
          var gm = stateCOF.gameMacros.find(function(gm) {
            return ngm.name == gm.name;
          });
          if (!gm) {
            var prev =
              macros.find(function(macro) {
                return macro.get('name') == ngm.name;
              });
            if (prev === undefined) {
              sendChat('COF', '/w GM Macro ' + ngm.name + ' créée.');
              if (ngm.inBar) inBar.push(ngm.name);
              mjs.forEach(function(playerId, i) {
                if (i === 0 || ngm.visibleto === '') {
                  ngm.playerid = playerId;
                  createObj('macro', ngm);
                }
              });
            }
          }
        });
      } else {
        //Peut-être la première fois, vérifier les macros
        if (stateCOF.macros) {
          //ancienne version, et on avait copié les macros
          //on enlève juste Escalier, et on remplace par Monter et Descendre
          var mesc = macros.find(function(m) {
            return m.get('name') == 'Escalier';
          });
          if (mesc) {
            createObj('macro', {
              name: 'Monter',
              action: "!cof-escalier",
              visibleto: '',
              istokenaction: true,
              inBar: false,
              _playerid: mesc.playerid
            });
            createObj('macro', {
              name: 'Descendre',
              action: "!cof-escalier bas",
              visibleto: '',
              istokenaction: true,
              inBar: false,
              _playerid: mesc.playerid
            });
            mesc.remove();
          }
        } else {
          gameMacros.forEach(function(m) {
            var prev =
              macros.find(function(macro) {
                return macro.get('name') == m.name;
              });
            if (prev === undefined) {
              sendChat('COF', '/w GM Macro ' + m.name + ' créée.');
              if (m.inBar) inBar.push(m.name);
              mjs.forEach(function(playerId, i) {
                if (i === 0 || m.visibleto === '') {
                  m.playerid = playerId;
                  createObj('macro', m);
                }
              });
            }
          });
        }
      }
      if (inBar.length > 0) {
        sendChat('COF', "/w GM Macros à mettre dans la barre d'action du MJ : " + inBar.join(', '));
      }
      stateCOF.gameMacros = gameMacros;
    }
    // Récupération des token Markers attachés à la campagne image, nom, tag, Id
    var markers = JSON.parse(Campaign().get("token_markers"));
    markers.forEach(function(m) {
      markerCatalog[m.name] = m;
    });
    // Option Markers personnalisés activé
    if (stateCOF.options.affichage.val.markers_personnalises.val) {
      var cof_states_perso = {
        assome: 'status_cof-assomme',
        surpris: 'status_cof-surpris',
        renverse: 'status_cof-renverse',
        aveugle: 'status_cof-aveugle',
        affaibli: 'status_cof-affaibli',
        etourdi: 'status_cof-etourdi',
        paralyse: 'status_cof-paralyse',
        ralenti: 'status_cof-ralenti',
        immobilise: 'status_cof-immobilise',
        endormi: 'status_cof-endormi',
        apeure: 'status_cof-apeure',
        invisible: 'status_cof-invisible',
        blesse: 'status_cof-blesse',
        encombre: 'status_cof-encombre',
        penombre: 'status_cof-penombre',
        enseveli: 'status_edge-crack'
      };
      // On boucle sur la liste des états pour vérifier que les markers sont bien présents !
      var markersAbsents = [];
      var ancientSet = true;
      Object.keys(cof_states_perso).forEach(function(etat) {
        var markerName = cof_states_perso[etat].substring(7);
        var marker = markerCatalog[markerName];
        if (marker) {
          cof_states[etat] = "status_" + marker.tag;
          ancientSet = false;
        } else {
          markersAbsents.push(markerName);
        }
      });
      // Cas particulier des deux markers d'initiative
      if (markerCatalog["cof-init-ally"]) {
        statusForInitAlly = "status_" + markerCatalog["cof-init-ally"].tag;
      } else {
        markersAbsents.push("cof-init-ally");
      }
      if (markerCatalog["cof-init-enemy"]) {
        statusForInitEnemy = "status_" + markerCatalog["cof-init-enemy"].tag;
      } else {
        markersAbsents.push("cof-init-enemy");
      }
      // Cas des markers d'effet temporaire, 3 cas particuliers :
      // uniquement le tag sans "status_" devant
      if (markerCatalog["cof-asphyxie"]) {
        messageEffetTemp.asphyxie.statusMarker = markerCatalog["cof-asphyxie"].tag;
      } else {
        markersAbsents.push("cof-asphyxie");
      }
      if (markerCatalog["cof-saigne"]) {
        messageEffetTemp.saignementsSang.statusMarker = markerCatalog["cof-saigne"].tag;
      } else {
        markersAbsents.push("cof-saigne");
      }
      if (markerCatalog["cof-prison-vegetale"]) {
        messageEffetTemp.prisonVegetale.statusMarker = markerCatalog["cof-prison-vegetale"].tag;
      } else {
        markersAbsents.push("cof-prison-vegetale");
      }
      if (!ancientSet) {
        markersAbsents.forEach(function(m) {
          log("Marker " + m + " introuvable");
        });
        log("Markers personnalisés activés.");
      } else {
        log("Utilisation des markers par défaut");
      }
    }
    //Construction de la table markers => etat
    etat_de_marker = {};
    for (var etat in cof_states) {
      var marker = cof_states[etat].substring(7);
      etat_de_marker[marker] = etat;
    }
  }

  function etatRendInactif(etat) {
    var res =
      etat == 'mort' || etat == 'surpris' || etat == 'assome' ||
      etat == 'etourdi' || etat == 'paralyse' || etat == 'endormi' ||
      etat == 'apeure';
    return res;
  }

  // retourne un tableau contenant la liste des ID de joueurs connectés controlant le personnage lié au Token
  function getPlayerIds(perso) {
    var character = getObj('character', perso.charId);
    if (character === undefined) return;
    var charControlledby = character.get('controlledby');
    if (charControlledby === '') return [];
    var playerIds = [];
    charControlledby.split(",").forEach(function(controlledby) {
      var player = getObj('player', controlledby);
      if (player === undefined) return;
      if (player.get('online')) playerIds.push(controlledby);
    });
    return playerIds;
  }

  function characterPageIds(charId) {
    var character = getObj('character', charId);
    if (character === undefined) return;
    var charControlledBy = character.get('controlledby');
    var playersIds = new Set();
    if (charControlledBy !== '') {
      charControlledBy.split(",").forEach(function(controlledby) {
        if (controlledby == 'all') {
          var players = findObjs({
            _type: 'player'
          });
          players.forEach(function(p) {
            if (p.get('online')) playersIds.add(p.id);
          });
        }
        var player = getObj('player', controlledby);
        if (player === undefined) return;
        if (player.get('online')) playersIds.add(controlledby);
      });
    }
    if (playersIds.size === 0) {
      findObjs({
        _type: 'player'
      }).forEach(function(p) {
        if (playerIsGM(p.id)) playersIds.add(p.id);
      });
    }
    var res = new Set();
    playersIds.forEach(function(pid) {
      res.add(getPageId(pid));
    });
    return res;
  }

  //PNJ au sens de la fiche utilisée, pas forcément en jeu
  function persoEstPNJ(perso) {
    if (perso.pnj) return true;
    var typePerso = ficheAttribute(perso, 'type_personnage', 'PJ');
    perso.pnj = (typePerso == 'PNJ');
    return perso.pnj;
  }

  var attackNameRegExp = new RegExp(/^(repeating_armes_.*_)armenom$/);
  var attackNamePNJRegExp = new RegExp(/^(repeating_pnjatk_.*_)armenom$/);

  //Met perso.pnj à true si on a un PNJ
  function getAttack(attackLabel, perso) {
    var res;
    var attributes = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    var findAttack = function(n) {
      return attackNameRegExp.exec(n);
    };
    if (persoEstPNJ(perso)) {
      findAttack = function(n) {
        return attackNamePNJRegExp.exec(n);
      };
    }
    var trouve;
    attributes.forEach(function(a) {
      if (trouve) return;
      if (a.get('name').toLowerCase() == 'type_personnage') {
        trouve = true;
        if (a.get('current') == 'PNJ') {
          perso.pnj = true;
          findAttack = function(n) {
            return attackNamePNJRegExp.exec(n);
          };
        }
      }
    });
    attributes.forEach(function(a) {
      if (res) return;
      var an = a.get('name');
      var m = findAttack(an);
      if (m) {
        var attPrefix = m[1];
        var weaponName = a.get('current');
        if (weaponName === undefined || weaponName === "") {
          error("Pas de nom pour une attaque");
          return;
        }
        var weaponLabel = ficheAttribute(perso, attPrefix + "armelabel", 0);
        if (weaponLabel == attackLabel) {
          res = {
            attackPrefix: attPrefix,
            weaponName: weaponName
          };
        }
      }
    });
    return res;
  }

  function getState(personnage, etat) {
    var token = personnage.token;
    var charId = personnage.charId;
    var res = false;
    if (token !== undefined) {
      res = token.get(cof_states[etat]);
      if (token.get('bar1_link') === '') return res;
      // else, look for the character value, if any
      if (charId === undefined) charId = token.get('represents');
      personnage.charId = charId;
    }
    if (charId === '') {
      error("token with a linked bar1 but representing no character", token);
      return false;
    }
    if (etat == 'affaibli') { //special case due to new character sheet
      var de = ficheAttributeAsInt(personnage, 'ETATDE', 20);
      if (de === 20) {
        if (res && token !== undefined) token.set(cof_states[etat], false);
        return false;
      } else if (de === 12) {
        if (!res && token !== undefined) token.set(cof_states[etat], true);
        return true;
      }
    }
    var attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: etat
    });
    if (attr.length === 0) {
      if (res && token !== undefined) token.set(cof_states[etat], false);
      return false;
    }
    if (!res && token !== undefined) token.set(cof_states[etat], true);
    return true;
  }

  //Met le champ field à value du token dans evt, pour permettre le undo
  function affectToken(token, field, value, evt) {
    evt.affectes = evt.affectes || {};
    var aff = evt.affectes[token.id];
    if (aff === undefined) {
      aff = {
        affecte: token,
        prev: {}
      };
      evt.affectes[token.id] = aff;
    }
    if (aff.prev[field] === undefined) aff.prev[field] = value;
    return aff;
  }

  function estAffaibli(perso) {
    if (perso.affaibli !== undefined) return perso.affaibli;
    if (getState(perso, 'affaibli')) {
      perso.affaibli = true;
      return true;
    }
    if (getState(perso, 'blesse')) {
      perso.affaibli = true;
      return true;
    }
    perso.affaibli = false;
    return false;
  }

  function setToken(token, field, newValue, evt) {
    var prevValue = token.get(field);
    affectToken(token, field, prevValue, evt);
    token.set(field, newValue);
  }

  function isActive(perso) {
    var inactif =
      getState(perso, 'mort') || getState(perso, 'surpris') ||
      getState(perso, 'assome') || getState(perso, 'etourdi') ||
      getState(perso, 'paralyse') || getState(perso, 'endormi') ||
      getState(perso, 'apeure') || attributeAsBool(perso, 'statueDeBois');
    return !inactif;
  }

  function sendChar(charId, msg) {
    var dest = '';
    if (charId) dest = 'character|' + charId;
    sendChat(dest, msg);
  }

  //Chuchote le message à tous les joueurs présents qui controllent le
  //personnage, plus le MJ
  function whisperChar(charId, msg) {
    var character = getObj('character', charId);
    if (character) {
      var controlled = character.get('controlledby');
      if (controlled.includes('all')) sendChar(charId, msg);
      else {
        controlled.split(',').forEach(function(c) {
          if (c !== '' && !playerIsGM(c)) {
            var p = getObj('player', c);
            if (p && p.get('online')) {
              sendChar(charId, '/w "' + p.get('_displayname') + '" ' + msg);
            }
          }
        });
        sendChar(charId, "/w GM " + msg);
      }
    } else {
      sendChar(charId, "/w GM " + msg);
    }
  }

  // options: bonus:int, deExplosif:bool
  //Renvoie 1dk + bonus, avec le texte
  //champs val et roll
  function rollDePlus(de, options) {
    options = options || {};
    options.nbDes = options.nbDes || 1;
    var count = options.nbDes;
    var bonus = options.bonus || 0;
    var explose = options.deExplosif || false;
    var texteJetDeTotal = '';
    var jetTotal = 0;
    do {
      var jetDe = randomInteger(de);
      texteJetDeTotal += jetDe;
      jetTotal += jetDe;
      explose = explose && (jetDe === de);
      if (explose) {
        texteJetDeTotal += ',';
      } else {
        count--;
        if (count > 0) {
          texteJetDeTotal += ',';
        }
      }
    } while ((explose || count > 0) && jetTotal < 1000);
    var res = {
      val: jetTotal + bonus
    };
    var msg = '<span style="display: inline-block; border-radius: 5px; padding: 0 4px; background-color: #F1E6DA; color: #000;" title="' + options.nbDes + 'd';
    msg += de;
    if (options.deExplosif) msg += '!';
    if (bonus > 0) {
      msg += '+' + bonus;
      texteJetDeTotal += '+' + bonus;
    } else if (bonus < 0) {
      msg += bonus;
      texteJetDeTotal += bonus;
    }
    msg += ' = ' + texteJetDeTotal + '" class="a inlinerollresult showtip tipsy-n">';
    msg += res.val + "</span>";
    res.roll = msg;
    return res;
  }

  //Si evt est défini, alors on considère qu'il faut y mettre la valeur actuelle
  function updateCurrentBar(perso, barNumber, val, evt, maxVal) {
    var token = perso.token;
    var prevToken;
    var HTdeclared;
    try {
      HTdeclared = HealthColors;
    } catch (e) {
      if (e.name != "ReferenceError") throw (e);
    }
    if (HTdeclared) {
      //Pour pouvoir annuler les effets de HealthColor sur le statut
      affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
      prevToken = JSON.parse(JSON.stringify(token));
    }
    var fieldv = 'bar' + barNumber + '_value';
    var fieldm;
    if (maxVal) fieldm = 'bar' + barNumber + '_max';
    var attrId = token.get('bar' + barNumber + '_link');
    var attr;
    if (attrId !== '') attr = getObj('attribute', attrId);
    if (attr === undefined) {
      var prevVal = token.get(fieldv);
      if (evt) affectToken(token, fieldv, prevVal, evt);
      token.set(fieldv, val);
      if (maxVal) {
        if (evt) affectToken(token, fieldm, token.get(fieldm), evt);
        token.set(fieldm, val);
      }
      if (HTdeclared) HealthColors.Update(token, prevToken);
      return;
    }
    if (evt) {
      evt.attributes = evt.attributes || [];
      evt.attributes.push({
        attribute: attr,
        current: attr.get('current'),
        max: attr.get('max'),
        withWorker: true
      });
    }
    var aset = {
      current: val
    };
    if (maxVal) aset.max = maxVal;
    attr.setWithWorker(aset);
    if (HTdeclared) HealthColors.Update(token, prevToken);
    //Gestion du lien des PVs entre familier et son maître
    if (barNumber == 1) {
      var persoLie = charAttribute(perso.charId, 'PVPartagesAvec');
      if (persoLie.length > 0) {
        persoLie = persoLie[0].get('current');
        persoLie = findObjs({
          _type: 'character',
          name: persoLie
        });
        if (persoLie.length > 0) {
          var attrLie = charAttribute(persoLie[0].id, 'pv', {
            caseInsensitive: true
          });
          if (attrLie.length > 0) {
            attrLie = attrLie[0];
            if (evt) {
              evt.attributes.push({
                attribute: attrLie,
                current: attrLie.get('current'),
                max: attrLie.get('max')
              });
            }
            attrLie.setWithWorker(aset);
          }
        }
      }
    }
  }

  //options peut contenir
  // msg: un message à afficher
  // maxVal: la valeur max de l'attribut
  // secret: le message n'est pas affiché pour tout le monde.
  // charAttr: si présent, on utilise un attribut de personnage
  // renvoie l'attribut crée ou mis à jour
  function setTokenAttr(personnage, attribute, value, evt, options) {
    var charId = personnage.charId;
    var token = personnage.token;
    var maxval = '';
    if (options && options.maxVal !== undefined) maxval = options.maxVal;
    if (options && options.msg !== undefined) {
      if (options.secret) whisperChar(charId, options.msg);
      else sendChar(charId, options.msg);
    }
    evt.attributes = evt.attributes || [];
    // check if the token is linked to the character. If not, use token name
    // in attribute name (token ids don't persist over API reload)
    var fullAttribute = attribute;
    if (token && (!options || !options.charAttr)) {
      var link = token.get('bar1_link');
      if (link === '') fullAttribute += "_" + token.get('name');
    }
    var attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: fullAttribute
    });
    if (attr.length === 0) {
      attr = createObj('attribute', {
        characterid: charId,
        name: fullAttribute,
        current: value,
        max: maxval
      });
      evt.attributes.push({
        attribute: attr,
        current: null
      });
      if (token) {
        var pageId = token.get('pageid');
        switch (attribute) {
          case 'agrandissement':
            var width = token.get('width');
            var height = token.get('height');
            affectToken(token, 'width', width, evt);
            affectToken(token, 'height', height, evt);
            width += width / 2;
            height += height / 2;
            token.set('width', width);
            token.set('height', height);
            break;
          case 'formeDArbre':
            //On copie les PVs pour pouvoir les restaurer à la fin de l'effet
            setTokenAttr(personnage, 'anciensPV', token.get('bar1_value'), evt, {
              maxVal: token.get('bar1_max')
            });
            //On va créer une copie de token, mais avec une image d'arbre
            var tokenFields = {
              _pageid: pageId,
              represents: personnage.charId,
              left: token.get('left'),
              top: token.get('top'),
              width: token.get('width'),
              height: token.get('height'),
              rotation: token.get('rotation'),
              layer: 'objects',
              name: token.get('name'),
              bar1_value: token.get('bar1_value'),
              bar1_max: token.get('bar1_max'),
              bar1_link: token.get('bar1_link'),
              bar2_value: token.get('bar2_value'),
              bar2_max: token.get('bar2_max'),
              bar2_link: token.get('bar2_link'),
              bar3_value: token.get('bar3_value'),
              bar3_max: token.get('bar3_max'),
              aura1_radius: token.get('aura1_radius'),
              aura1_color: token.get('aura1_color'),
              aura1_square: token.get('aura1_square'),
              showplayers_aura1: token.get('showplayers_aura1'),
              aura2_radius: token.get('aura2_radius'),
              aura2_color: token.get('aura2_color'),
              aura2_square: token.get('aura2_square'),
              showplayers_aura2: token.get('showplayers_aura2'),
              statusmarkers: token.get('statusmarkers'),
              light_radius: token.get('light_radius'),
              light_dimradius: token.get('light_dimradius'),
              light_otherplayers: token.get('light_otherplayers'),
              light_hassight: token.get('light_hassight'),
              light_angle: token.get('light_angle'),
              light_losangle: token.get('light_losangle'),
              light_multiplier: token.get('light_multiplier'),
              has_bright_light_vision: token.get('has_bright_light_vision'),
              has_night_vision: token.get('has_night_vision'),
              night_vision_distance: token.get('night_vision_distance'),
              night_vision_tint: token.get('night_vision_tint'),
              emits_bright_light: token.get('emits_bright_light'),
              bright_light_distance: token.get('bright_light_distance'),
              emits_low_light: token.get('emits_low_light'),
              low_light_distance: token.get('low_light_distance'),
              has_limit_field_of_vision: token.get('has_limit_field_of_vision'),
              has_limit_field_of_night_vision: token.get('has_limit_field_of_night_vision'),
              limit_field_of_vision_center: token.get('limit_field_of_vision_center'),
              limit_field_of_vision_total: token.get('limit_field_of_vision_total'),
              showname: token.get('showname'),
              showplayers_name: token.get('showplayers_name'),
              showplayers_bar1: token.get('showplayers_bar1'),
            };
            var tokenArbre;
            var imageArbre = findObjs({
              _type: 'attribute',
              _characterid: personnage.charId,
              name: 'tokenFormeDArbre'
            });
            if (imageArbre.length > 0) {
              tokenFields.imgsrc = imageArbre[0].get('current');
              tokenArbre = createObj('graphic', tokenFields);
            }
            if (tokenArbre === undefined) {
              tokenFields.imgsrc = stateCOF.options.images.val.image_arbre.val;
              tokenArbre = createObj('graphic', tokenFields);
            }
            if (tokenArbre) {
              evt.tokens = evt.tokens || [];
              evt.tokens.push(tokenArbre);
              //On met l'ancien token dans le gmlayer, car si l'image vient du marketplace, il est impossible de le recréer depuis l'API
              setToken(token, 'layer', 'gmlayer', evt);
              setTokenAttr(personnage, 'changementDeToken', true, evt);
              replaceInTurnTracker(token.id, tokenArbre.id, evt);
              personnage.token = tokenArbre;
              token = tokenArbre;
            }
            //On met maintenant les nouveaux PVs
            //selon Kegron http://www.black-book-editions.fr/forums.php?topic_id=4800&tid=245841#msg245841
            var niveau = ficheAttributeAsInt(personnage, 'niveau', 1);
            var nouveauxPVs = getValeurOfEffet(personnage, 'formeDArbre', niveau * 5);
            updateCurrentBar(personnage, 1, nouveauxPVs, evt, nouveauxPVs);
            //L'initiative change
            initPerso(personnage, evt, true);
            break;
          case 'bloqueManoeuvre':
          case 'enveloppePar':
          case 'prisonVegetale':
          case 'statueDeBois':
            nePlusSuivre(personnage, pageId, evt);
            break;
          case 'armeeDesMorts':
            personnage.token.set("aura2_radius", 20);
            personnage.token.set("aura2_color", "#b6d7a8");
            personnage.token.set("showplayers_aura2", true);
            break;
        }
      }
      return attr;
    }
    attr = attr[0];
    evt.attributes.push({
      attribute: attr,
      current: attr.get('current'),
      max: attr.get('max')
    });
    attr.set('current', value);
    if (options && options.maxVal !== undefined) attr.set('max', maxval);
    return attr;
  }

  // evt peut être undefined
  // options peut avoir les champs msg et secret
  function removeTokenAttr(personnage, attribute, evt, options) {
    var charId = personnage.charId;
    var token = personnage.token;
    // check if the token is linked to the character. If not, use token name
    // in attribute name (token ids don't persist over API reload)
    if (token) {
      var link = token.get('bar1_link');
      if (link === '') attribute += "_" + token.get('name');
    }
    var attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: attribute
    });
    if (attr.length === 0) return;
    if (options && options.msg !== undefined) {
      if (options.secret) whisperChar(charId, options.msg);
      else sendChar(charId, options.msg);
    }
    attr = attr[0];
    if (evt) {
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attr);
    }
    attr.remove();
  }

  function removeCharAttr(charId, attribute, evt, msg) {
    removeTokenAttr({
      charId: charId
    }, attribute, evt, {
      msg: msg
    });
  }

  //fonction avec callback, mais synchrone
  function soigneToken(perso, soins, evt, callTrue, callMax, options) {
    options = options || {};
    var token = perso.token;
    var bar1 = parseInt(token.get("bar1_value"));
    var pvmax = parseInt(token.get("bar1_max"));
    if (isNaN(bar1) || isNaN(pvmax)) {
      error("Soins sur un token sans points de vie", token);
      return;
    }
    var updateBar1;
    if (bar1 >= pvmax) bar1 = pvmax;
    else updateBar1 = true;
    if (soins < 0) soins = 0;
    var nonSoignable = 0;
    //Update des dm suivis
    var attrs = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    var regSuivis = '^DMSuivis([^_]+)';
    var link = token.get('bar1_link');
    if (link === '') regSuivis += "_" + token.get('name') + '$';
    else regSuivis += '$';
    regSuivis = new RegExp(regSuivis);
    var soinsSuivis = soins;
    var soinsImpossible = new Set(options.saufDMType);
    attrs.forEach(function(a) {
      if (soinsSuivis === 0) return;
      var an = a.get('name');
      an = an.match(regSuivis);
      if (an && an.length > 0) {
        var ds = parseInt(a.get('current'));
        if (ds > 0) {
          if (an[0].length < 2) {
            error("Match non trouvé pour les soins", an);
            return;
          }
          if (soinsImpossible.has(an[1])) {
            nonSoignable += ds;
          } else {
            if (ds > soinsSuivis) {
              evt.attributes = evt.attributes || [];
              evt.attributes.push({
                attribute: a,
                current: ds
              });
              ds -= soinsSuivis;
              a.set('current', ds);
              soinsSuivis = 0;
            } else {
              soinsSuivis -= ds;
              ds = 0;
            }
          }
        } else ds = 0;
        if (ds === 0) {
          evt.deletedAttributes = evt.deletedAttributes || [];
          evt.deletedAttributes.push(a);
          a.remove();
        }
      }
    });
    pvmax -= nonSoignable;
    if (bar1 === 0) {
      if (attributeAsBool(perso, 'etatExsangue')) {
        removeTokenAttr(perso, 'etatExsangue', evt, {
          msg: "retrouve des couleurs"
        });
      } else if (getState(perso, 'mort')) {
        setState(perso, 'renverse', true, evt);
        setState(perso, 'mort', false, evt);
      }
    }
    if (charAttributeAsBool(perso, 'vieArtificielle')) {
      soins = Math.floor(soins / 2);
    }
    bar1 += soins;
    var soinsEffectifs = soins;
    if (bar1 > pvmax) {
      if (attributeAsBool(perso, 'formeDArbre')) {
        var apv = tokenAttribute(perso, 'anciensPV');
        if (apv.length > 0) {
          apv = apv[0];
          var anciensPV = parseInt(apv.get('current'));
          var anciensMax = parseInt(apv.get('max'));
          if (!(isNaN(anciensPV) || isNaN(anciensMax)) &&
            anciensPV < anciensMax) {
            var soinsTransferes = bar1 - pvmax;
            if (anciensMax - anciensPV < soinsTransferes)
              soinsTransferes = anciensMax - anciensPV;
            anciensPV += soinsTransferes;
            bar1 -= soinsTransferes;
            setTokenAttr(perso, 'anciensPV', anciensPV, evt, {
              maxVal: anciensMax
            });
          }
        }
      }
      // On  cherche si il y a des DM temporaires à soigner
      if (bar1 > pvmax) {
        var hasMana = (ficheAttributeAsInt(perso, 'PM', 0) > 0);
        var dmgTemp;
        var estMook = token.get("bar1_link") === '';
        var nameAttrDMTEMP = 'DMTEMP';
        if (hasMana) {
          if (estMook) dmgTemp = attributeAsInt(perso, 'DMTEMP', 0);
          else dmgTemp = ficheAttributeAsInt(perso, nameAttrDMTEMP, 0);
        } else {
          dmgTemp = parseInt(token.get('bar2_value'));
          if (isNaN(dmgTemp)) dmgTemp = 0;
        }
        if (dmgTemp > 0) {
          var newDmgTemp = dmgTemp - bar1 + pvmax;
          if (newDmgTemp < 0) {
            newDmgTemp = 0;
            bar1 -= dmgTemp;
          } else bar1 = pvmax;
          if (hasMana) setTokenAttr(perso, 'DMTEMP', newDmgTemp, evt);
          else updateCurrentBar(perso, 2, newDmgTemp, evt);
        }
        soinsEffectifs -= (bar1 - pvmax);
        bar1 = pvmax;
      }
    }
    if (updateBar1) updateCurrentBar(perso, 1, bar1, evt);
    if (soinsEffectifs > 0) {
      if (callTrue) callTrue(soinsEffectifs);
    } else {
      if (callMax) callMax();
    }
  }

  function splitIdName(idn) {
    var pos = idn.indexOf(' ');
    if (pos < 1 || pos >= idn.length) {
      error("IdName mal formé", idn);
      return;
    }
    var name = idn.substring(pos + 1);
    return {
      id: idn.substring(0, pos),
      name: name
    };
  }

  //Renvoie le token et le charId. Si l'id ne correspond à rien, cherche si
  //on trouve un nom de token, sur la page passée en argument (ou sinon
  //sur la page active de la campagne)
  function persoOfId(id, name, pageId) {
    var token = getObj('graphic', id);
    if (token === undefined) {
      if (name === undefined) return undefined;
      if (pageId === undefined) {
        pageId = Campaign().get('playerpageid');
      }
      var tokens = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        name: name
      });
      if (tokens.length === 0) return undefined;
      if (tokens.length > 1) {
        error("Ambigüité sur le choix d'un token : il y a " +
          tokens.length + " tokens nommés " + name, tokens);
      }
      token = tokens[0];
    }
    var charId = token.get('represents');
    if (charId === '') {
      error("le token sélectionné ne représente pas de personnage", token);
      return undefined;
    }
    return {
      token: token,
      charId: charId
    };
  }

  //Retourne le perso correspondant à un token id suivi du nom de token
  //Permet d'avoir une information robuste en cas d'interruption du script
  function persoOfIdName(idn, pageId) {
    var sp = splitIdName(idn);
    if (sp === undefined) return;
    var perso = persoOfId(sp.id, sp.name, pageId);
    if (perso === undefined) {
      log("Impossible de trouver le personnage correspondant à " + sp.name);
      return;
    }
    perso.tokName = perso.token.get('name');
    if (perso.tokName == sp.name) return perso;
    log("En cherchant le token " + idn + ", on trouve " + perso.tokName);
    log(perso);
    return perso;
  }

  function computeScale(pageId) {
    var page = getObj("page", pageId);
    var scale = parseFloat(page.get('scale_number'));
    if (isNaN(scale) || scale <= 0) return 1.0;
    var cellSize = parseFloat(page.get('snapping_increment'));
    if (!isNaN(cellSize) && cellSize > 0) scale /= cellSize;
    var unit = page.get('scale_units');
    switch (unit) {
      case 'ft':
        scale *= 0.3048;
        break;
      case 'cm':
        scale *= 0.01;
        break;
      case 'km':
        scale *= 1000;
        break;
      case 'mi':
        scale *= 1609.34;
        break;
      case 'in':
        scale *= 0.0254;
        break;
    }
    return scale;
  }

  function persoOfToken(token) {
    var charId = token.get('represents');
    if (charId === '') {
      return undefined;
    }
    return {
      token: token,
      charId: charId
    };
  }

  //options peut avoir les champs:
  // - strict1 = true si on considère que tok1 doit avoir une taille nulle
  // - strict2
  // - allonge
  function distanceCombat(tok1, tok2, pageId, options) {
    if (pageId === undefined) {
      pageId = tok1.get('pageid');
    }
    options = options || {};
    //perso montés
    var pseudoTok1 = tok1;
    if (!options.strict1) {
      var perso1 = persoOfToken(tok1);
      if (perso1) {
        var attrMonture1 = tokenAttribute(perso1, 'monteSur');
        if (attrMonture1.length > 0) {
          var pseudoPerso1 = persoOfId(attrMonture1[0].get('current'), attrMonture1[0].get('max'), pageId);
          if (pseudoPerso1) pseudoTok1 = pseudoPerso1.token;
        }
      }
    }
    var pseudoTok2 = tok2;
    if (!options.strict2) {
      var perso2 = persoOfToken(tok2);
      if (perso2) {
        var attrMonture2 = tokenAttribute(perso2, 'monteSur');
        if (attrMonture2.length > 0) {
          var pseudoPerso2 = persoOfId(attrMonture2[0].get('current'), attrMonture2[0].get('max'), pageId);
          if (pseudoPerso2) pseudoTok2 = pseudoPerso2.token;
        }
      }
    }
    var scale = computeScale(pageId);
    var pt1 = tokenCenter(pseudoTok1);
    var pt2 = tokenCenter(pseudoTok2);
    var distance_pix = VecMath.length(VecMath.vec(pt1, pt2));
    if (!options.strict1) distance_pix -= tokenSize(pseudoTok1, PIX_PER_UNIT / 2);
    if (!options.strict2) distance_pix -= tokenSize(pseudoTok2, PIX_PER_UNIT / 2);
    if (options.allonge) distance_pix -= (options.allonge * PIX_PER_UNIT) / scale;
    if ((!options.strict1 || !options.strict2) && distance_pix < PIX_PER_UNIT * 1.3) return 0; //cases voisines
    return ((distance_pix / PIX_PER_UNIT) * scale);
  }

  //options:
  //fromTemp si on est en train de supprimer un effet temporaire
  function setState(personnage, etat, value, evt, options) {
    var token = personnage.token;
    var charId = personnage.charId;
    if (value && charAttributeAsBool(personnage, 'immunite_' + etat)) {
      sendChar(charId, 'ne peut pas être ' + stringOfEtat(etat, personnage));
      return false;
    }
    var aff =
      affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
    if (value && etatRendInactif(etat) && isActive(personnage)) {
      if (etat != 'surpris' || !surveillance(personnage))
        removeFromTurnTracker(personnage, evt);
    }
    token.set(cof_states[etat], value);
    if (!value) { //On enlève le save si il y en a un
      removeTokenAttr(personnage, etat + 'Save', evt);
    }
    var pageId = token.get('pageid');
    if (etat == 'aveugle') {
      // On change la vision du token
      var page = getObj('page', pageId);
      var udl = page && page.get('dynamic_lighting_enabled');
      if (udl) {
        if (aff.prev.has_limit_field_of_vision === undefined)
          aff.prev.has_limit_field_of_vision = token.get('has_limit_field_of_vision');
        if (aff.prev.has_limit_field_of_night_vision === undefined)
          aff.prev.has_limit_field_of_night_vision = token.get('has_limit_field_of_night_vision');
      } else {
        if (aff.prev.light_losangle === undefined)
          aff.prev.light_losangle = token.get('light_losangle');
      }
      if (value) {
        if (udl) {
          token.set('has_limit_field_of_vision', true);
          token.set('has_limit_field_of_night_vision', true);
        } else {
          token.set('light_losangle', 0);
        }
        //Normalement, ne peut plus suivre personne ?
        //Si il peut parce qu'il touche ou tient une corde, réutiliser la macro
        //pour suivre
        nePlusSuivre(personnage, pageId, evt);
      } else {
        if (!(options && options.fromTemp))
          removeTokenAttr(personnage, 'aveugleTemp', evt);
        if (udl) {
          token.set('has_limit_field_of_vision', false);
          token.set('has_limit_field_of_night_vision', false);
        } else {
          token.set('light_losangle', 360);
        }
      }
    } else if (value) {
      switch (etat) {
        case 'mort':
          //On s'assure de mettre les PV de la cible à 0 (pour les insta kills sans dommages)
          if (token.get('bar1_value') > 0) updateCurrentBar(personnage, 1, 0, evt);
          nePlusSuivre(personnage, pageId, evt);
          //On libère les personnages enveloppés, si il y en a.
          var attrEnveloppe = tokenAttribute(personnage, 'enveloppe');
          attrEnveloppe.forEach(function(a) {
            var cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              var envDM = a.get('max');
              if (envDM.startsWith('etreinte')) {
                //On a une étreinte, on enlève donc l'état immobilisé
                setState(cible, 'immobilise', false, evt);
              }
              evt.deletedAttributes = evt.deletedAttributes || [];
              var attrCible = tokenAttribute(cible, 'enveloppePar');
              attrCible.forEach(function(a) {
                var cube = persoOfIdName(a.get('current', pageId));
                if (cube === undefined) {
                  evt.deletedAttributes.push(a);
                  a.remove();
                } else if (cube.token.id == personnage.token.id) {
                  sendChar(cible.charId, 'se libère de ' + cube.tokName);
                  toFront(cible.token);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //Si le mort est enveloppé, il est relaché
          attrEnveloppe = tokenAttribute(personnage, 'enveloppePar');
          attrEnveloppe.forEach(function(a) {
            var cube = persoOfIdName(a.get('current'), pageId);
            if (cube) {
              var envDiff = a.get('max');
              if (envDiff.startsWith('etreinte')) {
                //On a une étreinte, on enlève donc l'état immobilisé
                setState(personnage, 'immobilise', false, evt);
              }
              evt.deletedAttributes = evt.deletedAttributes || [];
              var attrCube = tokenAttribute(cube, 'enveloppe');
              attrCube.forEach(function(a) {
                var cible = persoOfIdName(a.get('current', pageId));
                if (cible === undefined) {
                  evt.deletedAttributes.push(a);
                  a.remove();
                } else if (cible.token.id == personnage.token.id) {
                  sendChar(cube.charId, 'relache ' + personnage.tokName);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On libère les personnages agrippés, si il y en a.
          var attrAgrippe = tokenAttribute(personnage, 'agrippe');
          attrAgrippe.forEach(function(a) {
            var cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              var attrCible = tokenAttribute(cible, 'estAgrippePar');
              attrCible.forEach(function(a) {
                var agrippant = persoOfIdName(a.get('current', pageId));
                if (agrippant.token.id == personnage.token.id) {
                  sendChar(cible.charId, 'se libère de ' + agrippant.tokName);
                  toFront(cible.token);
                  if (a.get('max')) setState(cible, 'immobilise', false, evt);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On libère les personnages sous étreinte et immolation
          var attrEtreinteImmole = tokenAttribute(personnage, 'etreinteImmole');
          attrEtreinteImmole.forEach(function(a) {
            var cible = persoOfIdName(a.get('current'), pageId);
            if (cible) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              var attrCible = tokenAttribute(cible, 'etreinteImmolePar');
              attrCible.forEach(function(a) {
                var agrippant = persoOfIdName(a.get('current', pageId));
                if (agrippant.token.id == personnage.token.id) {
                  sendChar(cible.charId, 'se libère de ' + agrippant.tokName);
                  toFront(cible.token);
                  setState(cible, 'immobilise', false, evt);
                  evt.deletedAttributes.push(a);
                  a.remove();
                }
              });
            }
            evt.deletedAttributes.push(a);
            a.remove();
          });
          //On termine les effets temporaires liés au personnage
          var etlAttr = tokenAttribute(personnage, 'effetsTemporairesLies');
          if (etlAttr.length > 0) {
            etlAttr = etlAttr[0];
            evt.deletedAttributes = evt.deletedAttributes || [];
            var etl = etlAttr.get('current').split(',');
            etl.forEach(function(attrId) {
              var attrEffet = getObj('attribute', attrId);
              if (attrEffet === undefined) return;
              var nomAttrEffet = attrEffet.get('name');
              var charId = attrEffet.get('characterid');
              if (estEffetTemp(nomAttrEffet)) {
                finDEffet(attrEffet, effetTempOfAttribute(attrEffet), nomAttrEffet, charId, evt);
              } else if (estEffetCombat(nomAttrEffet)) {
                var mc = messageEffetCombat[effetCombatOfAttribute(attrEffet)].fin;
                if (mc && mc !== '') sendChar(charId, mc);
                evt.deletedAttributes.push(attrEffet);
                attrEffet.remove();
              }
            });
            evt.deletedAttributes.push(etlAttr);
            etlAttr.remove();
          }
          if (charAttributeAsBool(personnage, 'armeeConjuree')) {
            removeFromTurnTracker(personnage, evt);
            personnage.token.remove();
            sendChar(personnage.charId, 'disparaît');
            var armeeChar = getObj('character', personnage.charId);
            if (armeeChar) {
              evt.deletedCharacters = evt.deletedCharacters || [];
              evt.deletedCharacters.push({
                id: personnage.charId,
                name: armeeChar.get('name'),
                avatar: armeeChar.get('avatar'),
                attributes: findObjs({
                  _type: 'attributes',
                  _characterid: personnage.charId
                }),
                abilities: findObjs({
                  _type: 'ability',
                  _characterid: personnage.charId
                })
              });
              armeeChar.remove();
            }
          } else if (!estNonVivant(personnage)) {
            //Cherche si certains peuvent siphoner l'âme
            var allToks =
              findObjs({
                _type: "graphic",
                _pageid: pageId,
                _subtype: "token",
                layer: "objects"
              });
            allToks.forEach(function(tok) {
              if (tok.id == token.id) return;
              var p = persoOfToken(tok);
              if (p === undefined) return;
              if (getState(p, 'mort')) return;
              if (distanceCombat(token, tok, pageId) > 20) return;
              if (charIdAttributeAsBool(p.charId, 'siphonDesAmes')) {
                var bonus = charAttributeAsInt(p, 'siphonDesAmes', 0);
                var soin = rollDePlus(6, {
                  bonus: bonus
                });
                soigneToken(p, soin.val, evt,
                  function(s) {
                    var siphMsg = "siphone l'âme de " + token.get('name') +
                      ". Il récupère ";
                    if (s == soin.val) siphMsg += soin.roll + " pv.";
                    else siphMsg += s + " pv (jet " + soin.roll + ").";
                    sendChar(p.charId, siphMsg);
                  },
                  function() {
                    sendChar(p.charId, "est déjà au maximum de point de vie. Il laisse échapper l'âme de " + token.get('name'));
                  });
              }
            });
          }
          break;
        case 'immobilise':
        case 'surpris':
        case 'assome':
        case 'etourdi':
        case 'paralyse':
        case 'endormi':
        case 'apeure':
          nePlusSuivre(personnage, pageId, evt);
      }
    } else { //value est false
      if (!(options && options.fromTemp))
        removeTokenAttr(personnage, etat + 'Temp', evt);
    }
    if (token.get('bar1_link') !== '') {
      if (charId === '') {
        error("token with a linked bar1 but representing no character", token);
        return true;
      }
      if (etat == 'affaibli') { //special case due to new character sheet
        var attr =
          findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: 'ETATDE'
          }, {
            caseInsensitive: true
          });
        if (value) {
          if (attr.length === 0) {
            attr =
              createObj('attribute', {
                characterid: charId,
                name: 'ETATDE',
                current: 12
              });
            if (evt.attributes)
              evt.attributes.push({
                attribute: attr,
                current: null
              });
            else evt.attributes = [{
              attribute: attr,
              current: null
            }];
          } else {
            attr = attr[0];
            if (parseInt(attr.get('current')) != 12) {
              if (evt.attributes)
                evt.attributes.push({
                  attribute: attr,
                  current: 20
                });
              else evt.attributes = [{
                attribute: attr,
                current: 20
              }];
              attr.set('current', 12);
            }
          }
        } else {
          if (attr.length > 0) {
            attr = attr[0];
            if (parseInt(attr.get('current')) != 20) {
              if (evt.attributes)
                evt.attributes.push({
                  attribute: attr,
                  current: 12
                });
              else evt.attributes = [{
                attribute: attr,
                current: 12
              }];
              attr.set('current', 20);
            }
          }
        }
      } else {
        var attrEtat =
          findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: etat
          });
        if (value) {
          if (attrEtat.length === 0) {
            attrEtat =
              createObj('attribute', {
                characterid: charId,
                name: etat,
                current: value
              });
            if (evt.attributes)
              evt.attributes.push({
                attribute: attrEtat,
                current: null
              });
            else evt.attributes = [{
              attribute: attrEtat,
              current: null
            }];
          }
        } else {
          if (attrEtat.length > 0) {
            attrEtat[0].remove();
            if (evt.deletedAttributes) {
              evt.deletedAttributes.push(attrEtat[0]);
            } else {
              evt.deletedAttributes = [attrEtat[0]];
            }
          }
        }
      }
    }
    if (!value && etatRendInactif(etat) && isActive(personnage) ||
      etat == 'aveugle') updateInit(token, evt);
    return true;
  }

  /*
  function logEvents() {
    var l = eventHistory.length;
    log("Historique de taille " + l);
    eventHistory.forEach(function(evt, i) {
      log("evt " + i);
      log(evt);
    });
  }*/

  /* Événements, utilisés pour les undo, en particulier undo pour refaire
   * une action quand une règle le permet (utilisation de points de chance, etc..)
   * Champ d'un événement (variables evt en général dans le code:
   * id               : identificateur unique (int)
   * type             : description de l'événement (string)
   * affectes         : liste de tokens affectés par l'événement
   * tokens           : liste des tokens créés
   * -> on ne garde pas les tokens effacés, car il est impossible au niveau de l'API de recréer un token si son image n'est pas au bon endroit
   * attributes       : liste de attributs créés ou modifiés
   * deletesAttributes: lites des attributs effacés
   * characters       : liste des personnages créés
   * deletedCharacters: liste des personnages effacés
   * combat           : valeur de la variable d'état combat
   * combat_pageid    : id de la page où se déroule le combat
   * tour             : valeur du tour de combat (si il a changé)
   * init             : valeur de l'initiative dans le tour (si elle a changé)
   * activeTokenId    : id du token actif (si il a changé)
   * updateNextInitSet: valeur de l'ensemble des tokens dont il faut recalculer l'init
   * turnorder        : le turnorder (si il a changé)
   * initiativepage   : true si le turnorder est actif
   * personnage       : le perso qui 'fait' l'événement
   * succes           : stoque si l'attaque était un succès (bool)
   * action           : sauvegarde des paramètres de l'evt, pour la rejouer
   *   - caracteristique : carac testée (pour un jet)
   *   - titre : titre du jet
   *   - playerId : id du joueur qui a lancé l'action
   *   - selected : cibles sélectionnés des l'action
   *   - attaquant: personnage attaquant (TODO: voir si doublon avec personnage)
   *   - cibles: liste des cibles d'attaque, avec leurs tags
   *   - weaponStats: stats de l'arme (ou attaque) utilisée
   *   - rolls: les jets de l'action, pour les avoir à l'identique
   *     les dégâts sont stoqués dans chaque cible, dans cible.rollsDmg
   *     - attack: les jets de l'attaque
   *     - etat_e_index_targetid: save pour entrer dans l'état e
   *     - effet_e_index_targetid: save pour l'effet e
   *     - attaquant_pietinement_targetid: jet de l'attaquant pour le piétinement
   *     - defenseur_pietinement_targetid: jet de du défenseur pour le piétinement
   *   - options : options de l'action
   * attenteResultat  : permet de savoir que le jet est en attente de décision pour savoir si c'est un succès ou non (quand il n'y a pas de difficulté donnée et que le personnage est sous l'emprise d'une malédiction)
   */

  function addEvent(evt) {
    if (evt.id) {
      error("Tentative d'ajouter un événement déjà dans l'historique", evt);
      return;
    }
    evt.id = stateCOF.eventId++;
    eventHistory.push(evt);
    if (eventHistory.length > HISTORY_SIZE) {
      eventHistory.shift();
    }
  }

  function findEvent(id) {
    return eventHistory.find(function(evt) {
      return (evt.id == id);
    });
  }

  function lastEvent() {
    var l = eventHistory.length;
    if (l === 0) return undefined;
    return eventHistory[l - 1];
  }

  //Si evt n'est pas défini, annule le dernier evt
  function undoEvent(evt) {
    if (evt === undefined) {
      if (eventHistory.length === 0) {
        sendChat('COF', "/w GM Historique d'évènements vide");
        return;
      }
      evt = eventHistory.pop();
    } else {
      eventHistory = eventHistory.filter(function(e) {
        return (e.id != evt.id);
      });
    }
    if (evt === undefined) {
      error("No event to undo", eventHistory);
      return;
    }
    sendChat("COF", "/w GM undo " + evt.type);
    if (evt.affectes) undoTokenEffect(evt);
    if (evt.attributes) {
      // some attributes where modified too
      evt.attributes.forEach(function(attr) {
        if (attr.current === null) attr.attribute.remove();
        else {
          var aset = {
            current: attr.current
          };
          if (attr.max !== undefined) aset.max = attr.max;
          if (attr.withWorker) attr.attribute.setWithWorker(aset);
          else attr.attribute.set(aset);
        }
      });
    }
    if (evt.deletedCharacters) {
      evt.deletedCharacters.forEach(function(character) {
        var nameDel = character.name;
        log("Restoring character " + nameDel);
        var newCharacter =
          createObj('character', {
            name: nameDel,
            avatar: character.avatar
          });
        var charId = newCharacter.id;
        var tokens = findObjs({
          _type: 'graphic',
          represents: character.id
        });
        tokens.forEach(function(tok) {
          tok.set('represents', charId);
        });
        eventHistory.forEach(function(evt) {
          if (evt.characters) {
            evt.characters = evt.characters.map(function(oldCharac) {
              if (oldCharac.id == character.id) return newCharacter;
              return oldCharac;
            });
          }
          if (evt.deletedAttributes) {
            evt.deletedAttributes.forEach(function(attr) {
              if (attr.id == character.id) attr.newCharId = charId;
            });
          }
        });
        //Maintenant on remet les attributs
        if (character.attributes) {
          character.attributes.forEach(function(attr) {
            var oldId = attr.id;
            var newAttr = createObj('attribute', {
              characterid: charId,
              name: attr.get('name'),
              current: attr.get('current'),
              max: attr.get('max')
            });
            eventHistory.forEach(function(evt) {
              if (evt.attributes) {
                evt.attributes.forEach(function(attr) {
                  if (attr.attribute.id == oldId) attr.attribute = newAttr;
                });
              }
            });
            tokens.forEach(function(tok) {
              if (tok.get('bar1_link') == oldId)
                tok.set('bar1_link', newAttr.id);
            });
          });
        }
        if (character.abilities) {
          character.abilities.forEach(function(ab) {
            createObj('ability', {
              characterid: charId,
              name: ab.get('name'),
              action: ab.get('action'),
              istokenaction: ab.get('istokenaction')
            });
          });
        }
      });
    }
    // deletedAttributes have a quadratic cost in the size of the history
    if (evt.deletedAttributes) {
      evt.deletedAttributes.forEach(function(attr) {
        var oldId = attr.id;
        var nameDel = attr.get('name');
        log("Restoring attribute " + nameDel);
        var newAttr =
          createObj('attribute', {
            characterid: attr.newCharId || attr.get('characterid'),
            name: nameDel,
            current: attr.get('current'),
            max: attr.get('max')
          });
        eventHistory.forEach(function(evt) {
          if (evt.attributes !== undefined) {
            evt.attributes.forEach(function(attr) {
              if (attr.attribute.id == oldId) attr.attribute = newAttr;
            });
          }
        });
      });
    }
    if (evt.characters) {
      evt.characters.forEach(function(character) {
        var charId = character.id;
        findObjs({
          _type: 'attribute',
          _characterid: charId
        }).forEach(function(attr) {
          attr.remove();
        });
        findObjs({
          _type: 'ability',
          _characterid: charId
        }).forEach(function(ab) {
          ab.remove();
        });
        character.remove();
      });
    }
    if (evt.tokens) {
      evt.tokens.forEach(function(token) {
        token.remove();
      });
    }
    if (_.has(evt, 'combat')) stateCOF.combat = evt.combat;
    if (_.has(evt, 'combat_pageid')) stateCOF.combat_pageid = evt.combat_pageid;
    if (_.has(evt, 'tour')) stateCOF.tour = evt.tour;
    if (_.has(evt, 'init')) stateCOF.init = evt.init;
    if (_.has(evt, 'activeTokenId')) {
      stateCOF.activeTokenId = evt.activeTokenId;
      if (stateCOF.options.affichage.val.init_dynamique.val) {
        var activeToken = getObj('graphic', evt.activeTokenId);
        if (activeToken) {
          threadSync++;
          activateRoundMarker(threadSync, activeToken);
        }
      }
    }
    if (_.has(evt, 'updateNextInitSet'))
      updateNextInitSet = evt.updateNextInitSet;
    if (_.has(evt, 'turnorder'))
      Campaign().set('turnorder', evt.turnorder);
    if (_.has(evt, 'initiativepage'))
      Campaign().set('initiativepage', evt.initiativepage);
    if (evt.chargeFantastique)
      stateCOF.chargeFantastique = evt.chargeFantastique;
  }

  //origin peut être un message ou un nom de joueur
  function sendPlayer(origin, msg) {
    var dest = origin;
    if (origin.who) {
      if (playerIsGM(getPlayerIdFromMsg(origin))) dest = 'GM';
      else dest = origin.who;
    }
    sendChat('COF', '/w "' + dest + '" ' + msg);
  }

  function isCarac(x) {
    switch (x) {
      case 'FOR':
      case 'DEX':
      case 'CON':
      case 'SAG':
      case 'INT':
      case 'CHA':
        return true;
      default:
        return false;
    }
  }

  //msg peut être un message ou un playerId
  function peutController(msg, perso) {
    if (msg === undefined) return true;
    var playerId = getPlayerIdFromMsg(msg);
    if (playerIsGM(playerId)) return true;
    if (msg.selected && msg.selected.length > 0) {
      if (perso.token.id == msg.selected[0]._id) return true;
      var selectedPerso = persoOfId(msg.selected[0]._id);
      if (selectedPerso !== undefined && selectedPerso.charId == perso.charId) return true;
    }
    var character = getObj('character', perso.charId);
    if (character === undefined) return false;
    var cb = character.get('controlledby');
    var res = cb.split(',').find(function(pid) {
      if (pid == 'all') return true;
      return (pid == playerId);
    });
    return (res !== undefined);
  }

  // !cof-confirmer-attaque evtid
  function confirmerAttaque(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "Trop tard pour continuer l'attaque, on est hors combat");
      return;
    }
    var cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-confirmer-attaque", cmd);
      return;
    }
    var evt = findEvent(cmd[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou a été annulée", cmd);
      return;
    }
    var action = evt.action;
    if (action === undefined) {
      error("Erreur interne du bouton de rune de protection : l'évènement n'a pas d'action", cmd);
      return;
    }
    var options = action.currentOptions || {};
    var playerId = getPlayerIdFromMsg(msg);
    var ctrl = playerIsGM(playerId);
    if (!ctrl && options.preDmg) {
      var tokens = _.allKeys(options.preDmg);
      ctrl = tokens.every(function(tid) {
        var perso = persoOfId(tid);
        if (perso === undefined) return true;
        var character = getObj('character', perso.charId);
        if (character === undefined) return true;
        var cb = character.get('controlledby');
        var res = cb.split(',').find(function(pid) {
          return (pid == 'all' || pid == playerId);
        });
        return (res !== undefined);
      });
    }
    if (!ctrl) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    action.choices = action.choices || {};
    action.choices.Continuer = true;
    redoEvent(evt, action);
  }

  function undoTokenEffect(evt) {
    var HTdeclared;
    try {
      HTdeclared = HealthColors;
    } catch (e) {
      if (e.name != "ReferenceError") throw (e);
    }
    _.each(evt.affectes, function(aff) {
      var prev = aff.prev;
      var tok = aff.affecte;
      if (prev === undefined || tok === undefined) {
        error("Pas d'état précédant", aff);
        return;
      }
      var prevTok;
      if (HTdeclared) prevTok = JSON.parse(JSON.stringify(tok));
      _.each(prev, function(val, key) {
        tok.set(key, val);
      });
      if (HTdeclared) HealthColors.Update(tok, prevTok);
      sendChat("COF", "État de " + tok.get("name") + " restauré.");
    });
  }

  function caracOfMod(m) {
    switch (m) {
      case 'FOR':
        return 'force';
      case 'DEX':
        return 'dexterite';
      case 'CON':
        return 'constitution';
      case 'INT':
        return 'intelligence';
      case 'SAG':
        return 'sagesse';
      case 'CHA':
        return 'charisme';
      default:
        return;
    }
  }

  function PNJCaracOfMod(m) {
    return 'pnj_' + m.toLowerCase();
  }

  //Retourne le mod de la caractéristque entière.
  //si carac n'est pas une carac, retourne 0
  function modCarac(perso, carac) {
    if (perso.charId === undefined) perso = {
      charId: perso
    };
    if (persoEstPNJ(perso)) {
      switch (carac) {
        case 'force':
        case 'FORCE':
          return ficheAttributeAsInt(perso, 'pnj_for', 0);
        case 'dexterite':
        case 'DEXTERITE':
          return ficheAttributeAsInt(perso, 'pnj_dex', 0);
        case 'constitution':
        case 'CONSTITUTION':
          return ficheAttributeAsInt(perso, 'pnj_con', 0);
        case 'intelligence':
        case 'INTELLIGENCE':
          return ficheAttributeAsInt(perso, 'pnj_int', 0);
        case 'sagesse':
        case 'SAGESSE':
          return ficheAttributeAsInt(perso, 'pnj_sag', 0);
        case 'charisme':
        case 'CHARISME':
          return ficheAttributeAsInt(perso, 'pnj_cha', 0);
      }
      return 0;
    }
    var res = Math.floor((ficheAttributeAsInt(perso, carac, 10) - 10) / 2);
    if ((carac == 'force' || carac == 'FORCE') && attributeAsBool(perso, 'mutationMusclesHypertrophies')) res += 2;
    else if ((carac == 'DEXTERITE' || carac == 'dexterite') && attributeAsBool(perso, 'mutationSilhouetteFiliforme')) res += 4;
    return res;
  }

  function boutonSimple(action, texte, style) {
    action = action.replace(/%/g, '&#37;').replace(/\)/g, '&#41;').replace(/\?/g, '&#63;').replace(/@/g, '&#64;').replace(/\[/g, '&#91;').replace(/]/g, '&#93;').replace(/"/g, '&#34;').replace(/{/g, '&#123;').replace(/}/g, '&#125;').replace(/\|/g, '&#124;');
    action = action.replace(/\'/g, '&apos;'); // escape quotes
    action = action.replace(/:/g, '&amp;#58;'); // double escape colon
    style = style || '';
    return '<a href="' + action + '"' + style + '>' + texte + '</a>';
  }

  // on, remplace tous les selected par @{character name|attr}
  function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
  }

  //Remplace une macro ou ability par sa définition (récursivement)
  function replaceAction(action, perso, macros, abilities) {
    var remplacement = false;
    if (action.indexOf('#') >= 0) {
      macros = macros || findObjs({
        _type: 'macro'
      });
      macros.forEach(function(m, i) {
        var mName = m.get('name');
        if (mName === '') return;
        mName = '#' + mName;
        if (action.indexOf(mName) >= 0) {
          mName = new RegExp(mName + "\\b", "g");
          action = action.replace(mName, m.get('action'));
          if (!remplacement)
            macros = macros.filter(function(m, k) {
              return (k != i);
            }); //Pour éviter la récursion
          remplacement = true;
        }
      });
    }
    if (action.indexOf('%') >= 0) {
      abilities = abilities || findObjs({
        _type: 'ability',
        _characterid: perso.charId
      });
      abilities.forEach(function(a, i) {
        var aName = a.get('name');
        if (aName === '') return;
        var daName = '%' + aName;
        if (action.indexOf(daName) >= 0) {
          action = action.replace(daName, a.get('action'));
          if (!remplacement) abilities = abilities.splice(i); //Pour éviter la récursion
          remplacement = true;
        }
        daName = '%{selected|' + aName + '}';
        if (action.indexOf(daName) >= 0) {
          action = action.replace(daName, a.get('action'));
          if (!remplacement)
            abilities = abilities.filter(function(m, k) {
              return (k != i);
            }); //Pour éviter la récursion
          remplacement = true;
        }
      });
    }
    if (remplacement) return replaceAction(action, perso, macros, abilities);
    return action;
  }

  function getWeaponStats(perso, attackLabel) {
    var weaponStats = {
      name: 'Attaque',
      attSkill: '@{ATKCAC}',
      attNbDices: 1,
      attDice: 4,
      attDMBonusCommun: 0,
      crit: 20,
      divers: '',
      portee: 0,
      options: '',
    };
    if (attackLabel === undefined) return weaponStats;
    var att = getAttack(attackLabel, perso); //peuple perso.pnj
    if (att === undefined) {
      weaponStats.name = attackLabel;
      return weaponStats;
    }
    weaponStats.label = attackLabel;
    var attPrefix = att.attackPrefix;
    weaponStats.name = att.weaponName;
    weaponStats.attNbDices =
      ficheAttributeAsInt(perso, attPrefix + "armedmnbde", 1);
    weaponStats.attDice = ficheAttributeAsInt(perso, attPrefix + "armedmde", 4);
    weaponStats.crit = ficheAttributeAsInt(perso, attPrefix + "armecrit", 20);
    weaponStats.divers = ficheAttribute(perso, attPrefix + "armespec", '');
    if (perso.pnj) {
      weaponStats.attSkill =
        ficheAttributeAsInt(perso, attPrefix + "armeatk", 0);
      weaponStats.attDMBonusCommun =
        ficheAttributeAsInt(perso, attPrefix + "armedm", 0);
    } else {
      weaponStats.attSkill =
        ficheAttribute(perso, attPrefix + "armeatk", '@{ATKCAC}');
      weaponStats.attSkillDiv =
        ficheAttributeAsInt(perso, attPrefix + "armeatkdiv", 0);
      weaponStats.attCarBonus =
        ficheAttribute(perso, attPrefix + "armedmcar", '@{FOR}');
      weaponStats.attDMBonusCommun =
        ficheAttribute(perso, attPrefix + "armedmdiv", 0);
    }
    weaponStats.portee =
      ficheAttributeAsInt(perso, attPrefix + "armeportee", 0);
    weaponStats.typeAttaque =
      ficheAttribute(perso, attPrefix + 'armetypeattaque', 'Naturel');
    weaponStats.modificateurs =
      ficheAttribute(perso, attPrefix + 'armemodificateurs', '');
    weaponStats.typeDegats =
      ficheAttribute(perso, attPrefix + 'armetypedegats', 'tranchant');
    weaponStats.options = ficheAttribute(perso, attPrefix + 'armeoptions', '');
    weaponStats.options = weaponStats.options.trim();
    switch (weaponStats.typeAttaque) {
      case 'Naturel':
        weaponStats.armeNaturelle = true;
        break;
      case 'Arme 1 main':
        weaponStats.arme = true;
        break;
      case 'Arme 2 mains':
        weaponStats.arme = true;
        weaponStats.deuxMains = true;
        break;
      case 'Sortilege':
        weaponStats.sortilege = true;
        break;
      case 'Arme gauche':
        weaponStats.armeGauche = true;
        break;
      case 'Arme de jet':
        weaponStats.armeDeJet = true;
        break;
      default:
        //On cherche si c'est une arme à 2 mains
        var t = weaponStats.name.toLowerCase();
        if (t.includes('2 mains') || t.includes('deux mains')) {
          weaponStats.deuxMains = true;
        } else {
          t = weaponStats.divers;
          if (t) {
            t = t.toLowerCase();
            if (t.includes('2 mains') || t.includes('deux mains')) {
              weaponStats.deuxMains = true;
            }
          }
        }
    }
    //On cherche si c'est un arc
    var p = weaponStats.name.search(/\barc\b/i);
    if (p >= 0) weaponStats.arc = true;
    else {
      if (weaponStats.divers) {
        p = weaponStats.divers.search(/\barc\b/i);
      }
      if (p >= 0) weaponStats.arc = true;
      else {
        p = weaponStats.modificateurs.search(/\barc\b/i);
        if (p >= 0) weaponStats.arc = true;
      }
    }
    p = weaponStats.name.search(/\barbal([eè])te\b/i);
    if (p >= 0) weaponStats.arbalete = true;
    else {
      if (weaponStats.divers) {
        p = weaponStats.divers.search(/\barbal([eè])te\b/i);
      }
      if (p >= 0) weaponStats.arbalete = true;
      else {
        p = weaponStats.modificateurs.search(/\barbal([eè])te\b/i);
        if (p >= 0) weaponStats.arbalete = true;
      }
    }
    p = weaponStats.name.search(/\bhache\b/i);
    if (p >= 0) weaponStats.hache = true;
    else {
      if (weaponStats.divers) {
        p = weaponStats.divers.search(/\bhache\b/i);
      }
      if (p >= 0) weaponStats.hache = true;
      else {
        p = weaponStats.modificateurs.search(/\barbal([eè])te\b/i);
        if (p >= 0) weaponStats.arbalete = true;
      }
    }
    //Informations dans le champ spécial
    var parse = weaponStats.divers.split(' ');
    var lastParsed;
    parse.forEach(function(p) {
      p = p.trim();
      if (p === '') return;
      if (p.startsWith('+') && lastParsed == 'DEF') {
        var bonus = parseInt(p.substring(1));
        if (!isNaN(bonus) && bonus > 0) {
          weaponStats.bonusDef = weaponStats.bonusDef || 0;
          weaponStats.bonusDef += bonus;
          lastParsed = undefined;
          return;
        }
      }
      lastParsed = p;
    });
    return weaponStats;
  }

  //options peut avoir les champs:
  // - ressource, un attribut
  // - overlay
  // - buttonStyle
  // - attackStats
  function bouton(action, text, perso, options) {
    if (action === undefined || action.trim().length === 0) return text;
    else action = action.trim();
    options = options || {};
    //Expansion des macros et abilities
    action = replaceAction(action, perso);
    var tid = perso.token.id;
    perso.tokName = perso.tokName || perso.token.get('name');
    if (perso.name === undefined) {
      var character = getObj('character', perso.charId);
      if (character) perso.name = character.get('name');
      else perso.name = perso.tokName;
    }
    //Cas de plusieurs actions après expansion
    var actions = action.split('\n');
    //Cherche le picto et le style
    var style = '';
    var picto = '';
    var groupe; //Pour générer un bouton d'attaque de groupe. À revoir
    actions = actions.map(function(act) {
      act = act.trim();
      if (act.startsWith("/as ")) {
        act = "!cof-as" + act.substring(3);
      }
      if (act.charAt(0) == '!') {
        if (act.startsWith('!cof-')) {
          if (options.ressource) act += " --decrAttribute " + options.ressource.id;
          if (picto === '') {
            // Pictos : https://wiki.roll20.net/CSS_Wizardry#Pictos
            switch (act.split(' ', 1)[0].substring(5)) {
              case 'attack':
              case 'attaque':
              case 'confirmer-attaque':
                var portee = 0;
                var sortilege;
                var args = act.split(' --');
                var cmd = args.shift().split(' ');
                var attackStats = options.attackStats;
                if (attackStats === undefined && cmd.length > 3) {
                  var attackLabel = cmd[3].trim();
                  if (!attackLabel.startsWith('?{')) {
                    attackStats = getWeaponStats(perso, attackLabel);
                  }
                }
                if (attackStats) {
                  portee = attackStats.portee;
                  sortilege = attackStats.sortilege;
                  if (attackStats.options) {
                    var firstOptionIndex = act.indexOf(' --');
                    if (firstOptionIndex > 0) {
                      act = act.substring(0, firstOptionIndex) + ' --attaqueOptions ' + attackStats.options + act.substring(firstOptionIndex);
                    } else {
                      act += ' --attaqueOptions ' + attackStats.options;
                    }
                  }
                }
                //On cherche la portée dans les options (ça a la priorité)
                args.forEach(function(o) {
                  if (o.startsWith('portee ')) {
                    var p = parseInt(o.substring(7));
                    if (!isNaN(p) && p >= 0) portee = p;
                  }
                });
                if (sortilege || act.indexOf(' --sortilege') !== -1) {
                  // attaque magique
                  picto = '<span style="font-family: \'Pictos Three\'">g</span> ';
                  style = 'background-color:#9900ff';
                } else if (portee > 0) {
                  // attaque distance
                  picto = '<span style="font-family: \'Pictos Custom\'">[</span> ';
                  style = 'background-color:#48b92c';
                } else {
                  // attaque contact
                  picto = '<span style="font-family: \'Pictos Custom\'">t</span> ';
                  style = 'background-color:#cc0000';
                }
                break;
              case 'lancer-sort':
              case 'injonction':
              case 'injonction-mortelle':
              case 'attaque-magique':
              case 'tueur-fantasmagorique':
              case 'mot-de-pouvoir-immobilise':
                picto = '<span style="font-family: \'Pictos Three\'">g</span> ';
                style = 'background-color:#9900ff';
                break;
              case 'soin':
              case 'transe-guerison':
              case 'delivrance':
              case 'guerir':
              case 'guerison':
              case 'consommer-baie':
                picto = '<span style="font-family: \'Pictos\'">k</span> ';
                style = 'background-color:#ffe599;color:#333';
                break;
              case 'effet':
              case 'effet-temp':
              case 'effet-combat':
              case 'fortifiant':
              case 'set-state':
                picto = '<span style="font-family: \'Pictos\'">S</span> ';
                style = 'background-color:#4a86e8';
                break;
              case 'enduire-poison':
                picto = '<span style="font-family: \'Pictos Three\'">i</span> ';
                style = 'background-color:#05461c';
                break;
              case 'desarmer':
                picto = '<span style="font-family: \'Pictos Custom\'">t</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'surprise':
                picto = '<span style="font-family: \'Pictos\'">e</span> ';
                style = 'background-color:#4a86e8';
                break;
              case 'recharger':
                picto = '<span style="font-family: \'Pictos\'">0</span> ';
                style = 'background-color:#e69138';
                break;
              case 'action-defensive':
                picto = '<span style="font-family: \'Pictos Three\'">b</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'manoeuvre':
                picto = '<span style="font-family: \'Pictos Three\'">d</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'attendre':
                picto = '<span style="font-family: \'Pictos\'">t</span> ';
                style = 'background-color:#999999';
                break;
              case 'dmg':
              case 'bouton-echec-total':
                picto = '<span style="font-family: \'Pictos\'">\'</span> ';
                style = 'background-color:#cc0000';
                break;
              case 'peur':
                picto = '<span style="font-family: \'Pictos\'">`</span> ';
                style = 'background-color:#B445FE';
                break;
              case 'consommables':
                picto = '<span style="font-family: \'Pictos\'">b</span> ';
                style = 'background-color:#ce0f69';
                break;
              case 'liste-actions':
                picto = '<span style="font-family: \'Pictos\'">l</span> ';
                style = 'background-color:#272751';
                break;
            }
          }
        } else if (!act.startsWith('!&#13')) return act; //On ne touche pas aux commandes des autres scripts
      } else {
        if (options.ressource) {
          act = "!cof-utilise-consommable " + tid + ' ' + options.ressource.id + ' ' + act;
          picto = '<span style="font-family: \'Pictos\'">b</span> ';
          style = 'background-color:#ce0f69';
        } else {
          act = "!cof-lancer-sort " + act;
          picto = '<span style="font-family: \'Pictos Three\'">g</span> ';
          style = 'background-color:#9900ff';
        }
      }
      if (act.indexOf('@{selected') !== -1) {
        // cas spécial pour @{selected|token_id} où l'on remplace toutes les occurences par token.id
        act = act.replace(new RegExp(escapeRegExp('@{selected|token_id}'), 'g'), tid);
        act = act.replace(new RegExp(escapeRegExp('@{selected|token_name}'), 'g'), perso.tokName);
        var tmp = act.split('@{selected');
        tmp.forEach(function(elem) {
          if (elem.startsWith('|')) {
            // attribut demandé
            var attribute_name = elem.substring(0, elem.indexOf("}")).substr(1);
            var attrs = findObjs({
              _type: 'attribute',
              _characterid: perso.charId,
              name: attribute_name
            });
            var replacement;
            if (attrs.length === 0)
              replacement = '@{' + perso.name + '|' + attribute_name + '}';
            else
              replacement = attrs[0].get('current');
            act = act.replace(new RegExp(escapeRegExp('@{selected|' + attribute_name + '}'), 'g'), replacement);
          }
        });
      }
      if (act.startsWith('!cof-lancer-sort') && act.indexOf('--lanceur') == -1) {
        act += " --lanceur " + tid;
      }
      if (act.indexOf('@{target|') == -1 &&
        act.indexOf('cof-lancer-sort') == -1 &&
        act.indexOf('cof-surprise') == -1 &&
        act.indexOf('cof-attack') == -1 &&
        act.indexOf('cof-soin') == -1 &&
        act.indexOf('cof-guerison') == -1 &&
        act.indexOf('cof-as ') == -1 &&
        act.indexOf('cof-jouer-son ') == -1 &&
        act.indexOf('cof-utilise-consommable ') == -1 &&
        act.indexOf('--equipe') == -1 &&
        act.indexOf('--enVue') == -1 &&
        act.indexOf('--target ' + tid) == -1) {
        //Si on n'a pas de cible, on fait comme si le token était sélectionné.
        var add_token = " --target " + tid;
        if (act.indexOf(' --allie') >= 0) {
          if (act.indexOf('--lanceur') == -1)
            add_token = " --lanceur " + tid;
          else add_token = ""; //La cible sont les alliés de --lanceur.
        }
        if (act.indexOf(' --message ') != -1) act = act.replace(' --message ', add_token + ' --message ');
        else act += add_token;
      }
      return act;
    });
    text = picto + text;
    var buttonStyle = '';
    if (options.buttonStyle) buttonStyle = ' style="' + options.buttonStyle + '"';
    else if (style !== '') buttonStyle = ' style="' + style + '"';
    var overlay = '';
    if (options.overlay) overlay = ' title="' + options.overlay + '"';
    if (actions.length == 1) {
      action = actions[0];
      var toReturn = boutonSimple(action, text, buttonStyle + overlay);
      if (groupe) {
        toReturn += "<br/>" + boutonSimple(action + " --attaqueDeGroupe ?{Attaque en groupe ?}", text + " (groupe)", buttonStyle + overlay);
      }
      return toReturn;
    } else {
      action = "!cof-multi-command " + actions.join(' --cof-multi-command ');
      return boutonSimple(action, text, buttonStyle + overlay);
    }
  }

  function improve_image(image_url) {
    if (image_url) {
      image_url = image_url.replace('/med.png', '/thumb.png');
      image_url = image_url.replace('/max.png', '/thumb.png');
      var index = image_url.indexOf('?');
      if (index > 0) image_url = image_url.substring(0, index);
      return image_url;
    }
  }

  //Fonction séparée pour pouvoir envoyer un frame à plusieurs joueurs
  // playerId peut être undefined (en particulier pour envoyer au mj)
  function addFramedHeader(display, playerId, chuchote) {
    var perso1 = display.perso1;
    var perso2 = display.perso2;
    var action = display.action;
    var playerBGColor = '#333';
    var playerTXColor = '#FFF';
    var displayname;
    var player;
    if (playerId) player = getObj('player', playerId);
    if (player !== undefined) {
      playerBGColor = player.get("color");
      playerTXColor = (getBrightness(playerBGColor) < 50) ? "#FFF" : "#000";
      displayname = player.get('displayname');
    }
    var res = '/direct ';
    if (chuchote) {
      var who;
      if (chuchote !== true) who = chuchote;
      else who = displayname;
      if (who) res = '/w "' + who + '" ';
      else chuchote = false;
    }
    var name1, name2 = '';
    var avatar1, avatar2;
    if (perso2) {
      var img2 = improve_image(perso2.token.get('imgsrc'));
      if (stateCOF.options.affichage.val.avatar_dans_cadres.val) {
        var character2 = getObj('character', perso2.charId);
        if (character2) img2 = improve_image(character2.get('avatar')) || img2;
      }
      if (img2) {
        avatar2 = '<img src="' + img2 + '" style="width: 50%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
        name2 = perso2.tokName;
        if (name2 === undefined) name2 = perso2.token.get('name');
        name2 = '<b>' + name2 + '</b>';
      }
    }
    if (perso1) {
      var img1 = improve_image(perso1.token.get('imgsrc'));
      if (stateCOF.options.affichage.val.avatar_dans_cadres.val) {
        var character1 = getObj('character', perso1.charId);
        if (character1) img1 = improve_image(character1.get('avatar')) || img1;
      }
      if (img1) {
        avatar1 = '<img src="' + img1 + '" style="width: ' + (avatar2 ? 50 : 100) + '%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
        if (perso1.tokName) name1 = perso1.tokName;
        else name1 = perso1.token.get('name');
        name1 = '<b>' + name1 + '</b>';
      }
    }
    res +=
      '<div class="all_content" style="-webkit-box-shadow: 2px 2px 5px 0px rgba(0,0,0,0.75); -moz-box-shadow: 2px 2px 5px 0px rgba(0,0,0,0.75); box-shadow: 2px 2px 5px 0px rgba(0,0,0,0.75); border: 1px solid #000; border-radius: 6px; -moz-border-radius: 6px; -webkit-border-radius: 6px; overflow: hidden; position: relative;">';
    if (display.image) {
      res +=
        '<div class="line_header" style="overflow:auto; text-align: center; vertical-align: middle; padding: 5px 5px; border-bottom: 1px solid #000; color: ' + playerTXColor + '; background-color: ' + playerBGColor + ';" title=""> ';
      res += '<img src="' + display.image + '" style="width: ' + 100 + '%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
      res += '</div>';
    } else if (avatar1) {
      res +=
        '<div class="line_header" style="overflow:auto; text-align: center; vertical-align: middle; padding: 5px 5px; border-bottom: 1px solid #000; color: ' + playerTXColor + '; background-color: ' + playerBGColor + ';" title=""> ' +
        '<table>';
      if (avatar2) {
        res +=
          '<tr style="text-align: center">' +
          '<td style="width: 44%; vertical-align: middle;">' + name1 + '</td>' +
          '<td style="width: 12%;height: 28px;line-height: 30px;border: 2px solid #900;border-radius: 100%;position: absolute;margin-top: 25px;font-weight: bold;background-color: #EEE;color: #900;">' + 'VS' + '</td>' +
          '<td style="width: 44%; vertical-align: middle;">' + name2 + '</td>' +
          '</tr>' +
          '<tr style="text-align: center">' +
          '<td style="width: 42%; vertical-align: middle;">' + avatar1 + '</td>' +
          '<td style="width: 16%; vertical-align: middle;">&nbsp;</td>' +
          '<td style="width: 42%; vertical-align: middle;">' + avatar2 + '</td>' +
          '</tr>';
      } else {
        var bar1_info = '',
          bar2_info = '',
          bar3_info = '';
        if (chuchote && peutController(playerId, perso1)) {
          // on chuchote donc on peut afficher les informations concernant les barres du Token
          if (perso1.token.get('bar1_link') === '') {
            bar1_info = '<b>PV</b> : ' + perso1.token.get('bar1_value') + ' / ' + perso1.token.get('bar1_max');
          } else {
            var bar1 = getObj('attribute', perso1.token.get('bar1_link'));
            if (bar1)
              bar1_info = '<b>' + bar1.get('name') + '</b> : ' + bar1.get('current') + ' / ' + bar1.get('max') + '';
          }
          if (perso1.token.get('bar2_link') === '') {
            var dmTemp = perso1.token.get('bar2_value');
            if (dmTemp !== '') {
              dmTemp = parseInt(dmTemp);
              if (!isNaN(dmTemp) && dmTemp > 0)
                bar2_info = '<b>DM temp</b> : ' + dmTemp;
            }
          } else {
            var bar2 = findObjs({
              _type: 'attribute',
              _id: perso1.token.get('bar2_link')
            });
            if (bar2 && bar2.length > 0) bar2_info = '<b>' + bar2[0].get('name') + '</b> : ' + bar2[0].get('current') + ' / ' + bar2[0].get('max') + '';
          }
          if (perso1.token.get('bar3_link').length > 0) {
            var bar3 = findObjs({
              _type: 'attribute',
              _id: perso1.token.get('bar3_link')
            });
            if (bar3[0] !== undefined) bar3_info = '<b>' + bar3[0].get('name') + '</b> : ' + bar3[0].get('current') + ' / ' + bar3[0].get('max') + '';
          }
        }
        res +=
          '<tr style="text-align: left">' +
          '<td style="width:25%; vertical-align: middle;">' + avatar1 +
          '</td>' +
          '<td style="width:75%; vertical-align: middle; position: relative;">' +
          '<div>' + name1 + '</div>' +
          '<div style="position: absolute;top: -6px;right: -5px;border: 1px solid #000;background-color: #333;">' +
          '<div style="text-align: right; margin: 0 5px; color: #7cc489">' + bar1_info + '</div>' +
          '<div style="text-align: right; margin: 0 5px; color: #7c9bc4">' + bar2_info + '</div>' +
          '<div style="text-align: right; margin: 0 5px; color: #b21d1d">' + bar3_info + '</div>' +
          '</div>' +
          '</td>' +
          '</tr>';
      }
      res +=
        '</table>' +
        '</div>'; // line_header
    }
    // La ligne de titre
    res +=
      '<div class="line_title" style="font-size: 85%; text-align: left; vertical-align: middle; padding: 5px 5px; border-bottom: 1px solid #000; color: #a94442; background-color: #f2dede;" title=""> ';
    if (display.action_right) {
      res += '<table style="width:100%"><tr><td>' + action + '</td><td style="text-align: right;">' + display.action_right + '</td></tr></table>';
    } else {
      res += action;
    }
    res += '</div>'; // line_title
    res += '<div class="line_content">';
    display.header = res;
  }

  //Si options.chuchote est vrai, la frame est chuchotée au joueur qui fait l'action
  //Si options.chuchote est un nom, on chuchote la frame à ce nom
  //Pour retarder la décision sur la cible de chuchotement, utiliser options.retarder
  function startFramedDisplay(playerId, action, perso, options) {
    options = options || {};
    var display = {
      output: '',
      isOdd: true,
      isfirst: true,
      perso1: perso,
      perso2: options.perso2,
      action: action,
      action_right: options.action_right,
      image: options.image
    };
    if (!options.retarde)
      addFramedHeader(display, playerId, options.chuchote);
    return display;
  }

  function addLineToFramedDisplay(display, line, size, newLine) {
    size = size || 100;
    newLine = (newLine !== undefined) ? newLine : true;
    var background_color, border = '',
      separator = '';
    if (!newLine) display.isOdd = !display.isOdd;
    if (display.isOdd) {
      background_color = "#FFF";
      display.isOdd = false;
    } else {
      background_color = "#f3f3f3";
      display.isOdd = true;
    }
    if (size < 100) background_color = "#fcf8e3";
    if (!display.isfirst) {
      if (newLine) border = "border-top: 1px solid #333;";
    } else display.isfirst = false;
    var formatedLine = '<div style="padding: 0 5px 0; background-color: ' + background_color + '; color: #000;' + border + '">';

    if (!newLine) separator = "border-top: 1px solid #ddd;";
    formatedLine += '<div style="padding: 4px 0; font-size: ' + size + '%;' + separator + '">' + line + '</div>';
    formatedLine += '</div>';
    display.output += formatedLine;
  }

  function startTableInFramedDisplay(display, options) {
    display.output += "<table>";
    display.endColumn = true;
  }

  function endTableInFramedDisplay(display) {
    if (!display.endColumn) display.output += "</tr>";
    display.output += "</table>";
  }

  //newLine indique qu'on commence une nouvelle rangée
  function addCellInFramedDisplay(display, cell, size, newLine, fond) {
    size = size || 100;
    if (display.endColumn) {
      display.output += '<tr>';
      display.endColumn = false;
    } else if (newLine) display.output += '</tr><tr>';
    var color = '#FFF';
    if (fond) color = "#d3d3d3";
    display.output += '<td style="background-color: ' + color + '; font-size: ' + size + '%;">' + cell + '</td>';
  }

  function endFramedDisplay(display) {
    if (display.header === undefined) {
      error("Pas de titre pour le cadre", display);
      return;
    }
    var res = display.header + display.output;
    res += '</div>'; // line_content
    res += '</div>'; // all_content
    return res;
  }

  function bonusTestToutesCaracs(personnage, options, testId, evt, expliquer) {
    if (options && options.cacheBonusToutesCaracs) {
      if (options.cacheBonusToutesCaracs.val !== undefined) {
        return options.cacheBonusToutesCaracs.val;
      }
    }
    var bonus = 0;
    if (attributeAsBool(personnage, 'chantDesHeros')) {
      var bonusChantDesHeros = getValeurOfEffet(personnage, 'chantDesHeros', 1);
      var chantDesHerosIntense = attributeAsInt(personnage, 'chantDesHerosTempeteDeManaIntense', 0);
      bonusChantDesHeros += chantDesHerosIntense;
      expliquer("Chant des héros : +" + bonusChantDesHeros + " au jet");
      bonus += bonusChantDesHeros;
      if (chantDesHerosIntense && evt)
        removeTokenAttr(personnage, 'chantDesHerosTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'benediction')) {
      var bonusBenediction = getValeurOfEffet(personnage, 'benediction', 1);
      var benedictionIntense = attributeAsInt(personnage, 'benedictionTempeteDeManaIntense', 0);
      bonusBenediction += benedictionIntense;
      expliquer("Bénédiction : +" + bonusBenediction + " au jet");
      bonus += bonusBenediction;
      if (benedictionIntense && evt)
        removeTokenAttr(personnage, 'benedictionTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'lameDeLigneePerdue')) {
      expliquer("Lame de lignée perdue : -1 au jet");
      bonus -= 1;
    }
    if (attributeAsBool(personnage, 'strangulation')) {
      var malusStrangulation =
        1 + attributeAsInt(personnage, 'dureeStrangulation', 0);
      expliquer("Strangulation : -" + malusStrangulation + " au jet");
      bonus -= malusStrangulation;
    }
    if (attributeAsBool(personnage, 'nueeDInsectes')) {
      var malusNuee = 2 + attributeAsInt(personnage, 'nueeDInsectesTempeteDeManaIntense', 0);
      expliquer("Nuée d'insectes : -" + malusNuee + " au jet");
      bonus -= malusNuee;
      if (malusNuee > 2 && evt)
        removeTokenAttr(personnage, 'nueeDInsectesTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'nueeDeCriquets')) {
      var malusNueeCriquets =
        3 + attributeAsInt(personnage, 'nueeDeCriquetsTempeteDeManaIntense', 0);
      expliquer("Nuée de criquets : -" + malusNueeCriquets + " au jet");
      bonus -= malusNueeCriquets;
      if (malusNueeCriquets > 3 && evt)
        removeTokenAttr(personnage, 'nueeDeCriquetsTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'etatExsangue')) {
      expliquer("Exsangue : -2 au jet");
      bonus -= 2;
    }
    if (attributeAsBool(personnage, 'putrefactionOutrTombe')) {
      expliquer("Putréfié : -2 au jet");
      bonus -= 2;
    }
    var fortifie = attributeAsInt(personnage, 'fortifie', 0);
    if (fortifie > 0) {
      expliquer("Fortifié : +3 au jet");
      bonus += 3;
      if (evt) {
        fortifie--;
        if (fortifie === 0) {
          removeTokenAttr(personnage, 'fortifie', evt);
        } else {
          setTokenAttr(personnage, 'fortifie', fortifie, evt);
        }
      }
    }
    if (options) {
      if (options.bonus) bonus += options.bonus;
      if (options.chanceRollId && options.chanceRollId[testId]) bonus += options.chanceRollId[testId];
      var malusCasque = false;
      if (options.bonusAttrs) {
        options.bonusAttrs.forEach(function(attr) {
          var bonusAttribut = charAttributeAsInt(personnage, attr, 0);
          switch (attr) {
            case 'perception':
              malusCasque = true;
              if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
                expliquer("Forêt hostile : -5 en perception");
                bonus -= 5;
              }
              break;
            case 'survie':
              if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
                expliquer("Forêt hostile : -5 en survie");
                bonus -= 5;
              }
              break;
            case 'orientation':
              if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
                expliquer("Forêt hostile : -5 en orientation");
                bonusAttribut -= 5;
              }
              break;
            case 'discrétion':
            case 'discretion':
              if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
                expliquer("Forêt hostile : -5 en discrétion");
                bonus -= 5;
              }
              break;
            case 'vigilance':
              malusCasque = true;
              break;
          }
          if (bonusAttribut !== 0) {
            expliquer("Attribut " + attr + " : " + ((bonusAttribut < 0) ? "-" : "+") + bonusAttribut);
            bonus += bonusAttribut;
          }
        });
      }
      if (malusCasque && ficheAttributeAsBool(personnage, 'casque_on', false)) {
        malusCasque = ficheAttributeAsInt(personnage, 'casque_malus', 0);
        if (malusCasque > 0) {
          expliquer("Malus de casque : -" + malusCasque);
          bonus -= malusCasque;
        }
      }
      if (options.cacheBonusToutesCaracs) {
        options.cacheBonusToutesCaracs.val = bonus;
      }
    }
    return bonus;
  }

  var competenceNameRegExp = new RegExp(/^(repeating_competences_.*_)comp_nom$/);
  var competenceTotalRegExp = new RegExp(/^(repeating_competences_.*_)comp_bonusTotal$/);
  var competenceCaracsRegExp = new RegExp(/^(repeating_competences_.*_)comp_caracs$/);
  var competenceCaracRegExp = new RegExp(/^(repeating_competences_.*_)comp_carac$/);

  function validateCompetence(carac, comp, prefix, compInfos, prefixesNom) {
    if (compInfos.total === undefined) return;
    var res = {
      total: compInfos.total,
      bestFit: false
    };
    if (compInfos.carac == carac) res.bestFit = true;
    if (!res.bestFit && compInfos.caracs === undefined) return;
    if (compInfos.caracs && compInfos.caracs.length > 0) {
      if (compInfos.caracs.includes(carac)) res.bestFit = true;
      else if (compInfos.carac === undefined) {
        prefixesNom.delete(prefix);
        return;
      }
    }
    return res;
  }

  //retourne un entier
  // evt n'est défini que si la caractéristique est effectivement utlilisée
  function bonusTestCarac(carac, personnage, options, testId, evt, explications) {
    var expliquer = function(msg) {
      if (explications) explications.push(msg);
    };
    var bonus = 0;
    // D'abord la partie qui dépend de la caractéristique
    if (persoEstPNJ(personnage)) {
      bonus = ficheAttributeAsInt(personnage, PNJCaracOfMod(carac), 0);
    } else {
      bonus = modCarac(personnage, caracOfMod(carac));
      bonus += ficheAttributeAsInt(personnage, carac + "_BONUS", 0);
    }
    expliquer("Bonus de " + carac + " : " + bonus);
    var bonusAspectDuDemon;
    switch (carac) {
      case 'DEX':
        if (attributeAsBool(personnage, 'agrandissement')) {
          expliquer("Agrandi : -2 au jet de DEX");
          bonus -= 2;
        }
        if (attributeAsBool(personnage, 'aspectDuDemon')) {
          bonusAspectDuDemon = getValeurOfEffet(personnage, 'aspectDuDemon', 2);
          expliquer("Aspect du démon : +" + bonusAspectDuDemon + " au jet de DEX");
          bonus += bonusAspectDuDemon;
        }
        break;
      case 'FOR':
        if (attributeAsBool(personnage, 'rayonAffaiblissant')) {
          var malusRayonAffaiblissant = getValeurOfEffet(personnage, 'rayonAffaiblissant', 2);
          expliquer("Affaibli : -" + malusRayonAffaiblissant + " au jet de FOR");
          bonus -= malusRayonAffaiblissant;
        }
        if (attributeAsBool(personnage, 'agrandissement')) {
          expliquer("Agrandi : +2 au jet de FOR");
          bonus += 2;
        }
        if (attributeAsBool(personnage, 'aspectDuDemon')) {
          bonusAspectDuDemon = getValeurOfEffet(personnage, 'aspectDuDemon', 2);
          expliquer("Aspect du démon : +" + bonusAspectDuDemon + " au jet de FOR");
          bonus += bonusAspectDuDemon;
        }
        break;
      case 'CHA':
        if (attributeAsBool(personnage, 'aspectDeLaSuccube')) {
          var bonusAspectDeLaSuccube = getValeurOfEffet(personnage, 'aspectDeLaSuccube', 5);
          expliquer("Aspect de la succube : +" + bonusAspectDeLaSuccube + " au jet de CHA");
          bonus += bonusAspectDeLaSuccube;
        }
        break;
      case 'CON':
        if (attributeAsBool(personnage, 'mutationSilhouetteMassive')) {
          expliquer("Silhouette massive : +5 au jet de CON");
          bonus += 5;
        }
        if (charAttributeAsBool(personnage, 'controleDuMetabolisme')) {
          var modCha = modCarac(personnage, 'charisme');
          if (modCha > 0) {
            expliquer("Controle du métabolisme : +" + modCha + " au jet de CON");
            bonus += modCha;
          }
        }
        if (attributeAsBool(personnage, 'aspectDuDemon')) {
          bonusAspectDuDemon = getValeurOfEffet(personnage, 'aspectDuDemon', 2);
          expliquer("Aspect du démon : +" + bonusAspectDuDemon + " au jet de CON");
          bonus += bonusAspectDuDemon;
        }
        break;
    }
    var bonusCompetence;
    if (options && options.competence) {
      var comp = options.competence.trim().toLowerCase();
      var attributes = findObjs({
        _type: 'attribute',
        _characterid: personnage.charId,
      });
      var competences = {};
      var prefixesNom = new Set();
      var res;
      attributes.find(function(attr) {
        var attrName = attr.get('name');
        var m = competenceNameRegExp.exec(attrName);
        if (m) {
          if (attr.get('current').trim().toLowerCase() != comp) return false;
          prefixesNom.add(m[1]);
          var compInfos = competences[m[1]];
          if (compInfos === undefined) return false;
          res = validateCompetence(carac, comp, m[1], compInfos, prefixesNom);
          if (res === undefined) return false;
          bonusCompetence = res.total;
          return res.bestFit;
        }
        m = competenceCaracRegExp.exec(attrName);
        if (m) {
          competences[m[1]] = competences[m[1]] || {};
          competences[m[1]].carac = attr.get('current');
          if (!prefixesNom.has(m[1])) return false;
          res = validateCompetence(carac, comp, m[1], competences[m[1]], prefixesNom);
          if (res === undefined) return false;
          bonusCompetence = res.total;
          return res.bestFit;
        }
        m = competenceCaracsRegExp.exec(attrName);
        if (m) {
          competences[m[1]] = competences[m[1]] || {};
          competences[m[1]].caracsLimitees = attr.get('current').split(',');
          if (!prefixesNom.has(m[1])) return false;
          res = validateCompetence(carac, comp, m[1], competences[m[1]], prefixesNom);
          if (res === undefined) return false;
          bonusCompetence = res.total;
          return res.bestFit;
        }
        m = competenceTotalRegExp.exec(attrName);
        if (!m) return false;
        competences[m[1]] = competences[m[1]] || {};
        competences[m[1]].total = parseInt(attr.get('current'));
        if (isNaN(competences[m[1]].total)) competences[m[1]] = 0;
        if (!prefixesNom.has(m[1])) return false;
        res = validateCompetence(carac, comp, m[1], competences[m[1]], prefixesNom);
        if (res === undefined) return false;
        bonusCompetence = res.total;
        return res.bestFit;
      });
      if (bonusCompetence === undefined) {
        var found;
        prefixesNom.forEach(function(prefix) {
          if (found) return;
          var compInfos = competences[prefix];
          if (compInfos === undefined)
            compInfos = {
              total: 0,
              carac: 'FOR',
              caracs: []
            };
          else {
            if (compInfos.total === undefined) compInfos.total = 0;
            if (compInfos.carac === undefined) compInfos.carac = 'FOR';
            if (compInfos.caracs === undefined) compInfos.caracs = [];
          }
          var res = validateCompetence(carac, comp, prefix, compInfos, prefixesNom);
          if (res === undefined) return;
          bonusCompetence = res.total;
          found = res.bestFit;
        });
      }
      if (bonusCompetence === undefined) {
        options.bonusAttrs = options.bonusAttrs || [];
        options.bonusAttrs.push(options.competence.toLowerCase().replace(/ /g, '_'));
      } else {
        switch (comp) {
          case 'perception':
            if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
              expliquer("Forêt hostile : -5 en perception");
              bonus -= 5;
            }
            break;
          case 'survie':
            if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
              expliquer("Forêt hostile : -5 en survie");
              bonus -= 5;
            }
            break;
          case 'orientation':
            if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
              expliquer("Forêt hostile : -5 en orientation");
              bonus -= 5;
            }
            break;
          case 'discrétion':
          case 'discretion':
            if (attributeAsBool(personnage, 'foretVivanteEnnemie')) {
              expliquer("Forêt hostile : -5 en discrétion");
              bonus -= 5;
            }
            break;
        }
        var msgComp = "Compétence " + options.competence + " : ";
        if (bonusCompetence === 0) {
          msgComp += 0;
        } else {
          bonus += bonusCompetence;
          if (bonusCompetence > 0) msgComp += "+" + bonusCompetence;
          else msgComp += bonusCompetence;
        }
        expliquer(msgComp);
      }
    }
    if (bonusCompetence === undefined) {
      if (carac == 'DEX') {
        var malusArmure = 0;
        if (ficheAttributeAsInt(personnage, 'DEFARMUREON', 1))
          malusArmure += ficheAttributeAsInt(personnage, 'DEFARMUREMALUS', 0);
        if (ficheAttributeAsInt(personnage, 'DEFBOUCLIERON', 1))
          malusArmure += ficheAttributeAsInt(personnage, 'DEFBOUCLIERMALUS', 0);
        if (malusArmure > 0) {
          expliquer("Armure : -" + malusArmure + " au jet de DEX");
          bonus -= malusArmure;
        }
      }
    }
    // Puis la partie commune
    options = options || {};
    bonus += bonusTestToutesCaracs(personnage, options, testId, evt, expliquer);
    //Pas besoin de mettre la valeur de caractéristique si c'est le seul bonus
    if (explications && explications.length == 1) explications.pop();
    return bonus;
  }

  function computeDice(lanceur, options) {
    options = options || {};
    var nbDe = options.nbDe;
    if (nbDe === undefined) nbDe = 1;
    var plusFort = options.plusFort;
    if (plusFort === undefined) plusFort = true;
    var dice = options.dice;
    if (dice === undefined) dice = deTest(lanceur, options.carac);
    if (attributeAsBool(lanceur, 'malediction')) {
      if (plusFort) {
        if (nbDe > 1) nbDe--;
        else {
          nbDe = 2;
          plusFort = false;
        }
      } else nbDe++;
    }
    var de = nbDe + "d" + dice;
    if (nbDe > 1) {
      if (plusFort) de += "kh1";
      else de += "kl1";
    }
    return de;
  }

  // Test de caractéristique
  // options : bonusAttrs, bonus, roll
  // Après le test, lance callback(testRes, explications
  // testRes.texte est l'affichage du jet de dé
  // testRes.reussite indique si le jet est réussi
  // testRes.echecCritique, testRes.critique pour le type
  // testRes.valeur pour la valeur totale du jet
  // testRes.rerolls pour le texte avec les boutons de rerolls adaptés.
  // testRes.modifiers pour les boutons qui peuvent être activés sur le roll, qu'il soit réussi ou non.
  // Pour que les boutons de rerolls fonctionnent, le type d'évènement doit être supporté par redoEvent()
  // ne rajoute pas evt à l'historique
  function testCaracteristique(personnage, carac, seuil, testId, options, evt, callback) { //asynchrone
    options = options || {};
    var testRes = {};
    var explications = [];
    if (carac == 'SAG' || carac == 'INT' || carac == 'CHA') {
      if (charAttributeAsBool(personnage, 'sansEsprit')) {
        testRes.reussite = true;
        testRes.texte = "(sans esprit : réussite automatique)";
        callback(testRes);
        return;
      }
    }
    var bonusCarac = bonusTestCarac(carac, personnage, options, testId, evt, explications);
    var jetCache = ficheAttributeAsBool(personnage, 'jets_caches', false);
    var testsRatesDuTour;
    var listeTestsRatesDuTour;
    var testDejaRate;
    var adaptable = charAttributeAsInt(personnage, 'adaptable');
    if (adaptable) {
      testsRatesDuTour = tokenAttribute(personnage, 'testsRatesDuTour');
      if (testsRatesDuTour.length > 0) {
        testsRatesDuTour = testsRatesDuTour[0];
        listeTestsRatesDuTour = testsRatesDuTour.get('current').split(' ');
        var testRate = listeTestsRatesDuTour.includes(testId);
        if (testRate) {
          testDejaRate = true;
          bonusCarac += adaptable;
        } else {
          testRate = testsRatesDuTour.get('max').split(' ').includes(testId);
          if (testRate) {
            bonusCarac += adaptable;
          }
        }
      } else testsRatesDuTour = undefined;
    }
    var carSup = nbreDeTestCarac(carac, personnage);
    var de = computeDice(personnage, {
      nbDe: carSup,
      carac: carac
    });
    if (estAffaibli(personnage) && charAttributeAsBool(personnage, 'insensibleAffaibli')) bonusCarac -= 2;
    var plageEC = 1;
    var plageECText = '1';
    if (options.plageEchecCritique) {
      plageEC = options.plageEchecCritique;
      if (plageEC > 1) plageECText = '<' + plageEC;
    }
    var rollExpr = "[[" + de + "cs20cf" + plageECText + "]]";
    try {
      sendChat("", rollExpr, function(res) {
        options.rolls = options.rolls || {};
        var roll = options.rolls[testId] || options.roll || res[0].inlinerolls[0];
        roll.token = personnage.token;
        evt.action = evt.action || {};
        evt.action.rolls = evt.action.rolls || {};
        evt.action.rolls[testId] = roll;
        testRes.roll = roll;
        var d20roll = roll.results.total;
        var bonusText = (bonusCarac > 0) ? "+" + bonusCarac : (bonusCarac === 0) ? "" : bonusCarac;
        testRes.texte = jetCache ? d20roll + bonusCarac : buildinline(roll) + bonusText;
        if (d20roll == 20) {
          testRes.reussite = true;
          testRes.critique = true;
        } else if (d20roll <= plageEC) {
          testRes.reussite = false;
          testRes.echecCritique = true;
          diminueMalediction(personnage, evt);
        } else if (d20roll + bonusCarac >= seuil) {
          testRes.reussite = true;
        } else {
          diminueMalediction(personnage, evt);
          testRes.reussite = false;
        }
        testRes.valeur = d20roll + bonusCarac;
        if (adaptable) {
          if (testRes.reussite) {
            if (testsRatesDuTour && listeTestsRatesDuTour) {
              if (listeTestsRatesDuTour.includes(testId)) {
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: testsRatesDuTour,
                  current: testsRatesDuTour.get('current'),
                });
                listeTestsRatesDuTour = listeTestsRatesDuTour.filter(function(i) {
                  return i != testId;
                });
                testsRatesDuTour.set('current', listeTestsRatesDuTour.join(' '));
              }
            }
          } else if (!testDejaRate) {
            if (testsRatesDuTour && listeTestsRatesDuTour) {
              listeTestsRatesDuTour.push(testId);
              evt.attributes = evt.attributes || [];
              evt.attributes.push({
                attribute: testsRatesDuTour,
                current: testsRatesDuTour.get('current'),
              });
              testsRatesDuTour.set('current', listeTestsRatesDuTour.join(' '));
            } else {
              setTokenAttr(personnage, 'testsRatesDuTour', testId, evt);
            }
          }
        }
        testRes.rerolls = '';
        var pc = pointsDeChance(personnage);
        if (!testRes.echecCritique && pc > 0) {
          testRes.rerolls += '<br/>' +
            boutonSimple("!cof-bouton-chance " + evt.id + " " + testId, "Chance") +
            " (reste " + pc + " PC)";
        }
        if (stateCOF.combat && attributeAsBool(personnage, 'runeForgesort_énergie') &&
          attributeAsInt(personnage, 'limiteParCombat_runeForgesort_énergie', 1) > 0 &&
          (carac == 'FOR' || carac == 'CON' || carac == 'DEX')) {
          testRes.rerolls += '<br/>' + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + testId, "Rune d'énergie");
        }
        if (stateCOF.combat && attributeAsBool(personnage, 'petitVeinard')) {
          testRes.rerolls += '<br/>' + boutonSimple("!cof-bouton-petit-veinard " + evt.id + " " + testId, "Petit veinard");
        }
        if (stateCOF.combat && !testRes.echecCritique &&
          attributeAsBool(personnage, 'prouesse') &&
          (carac == 'FOR' || carac == 'DEX')) {
          testRes.rerolls += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + testId, "Prouesse");
        }
        testRes.modifiers = '';
        if (attributeAsBool(personnage, 'tourDeForce') && carac == 'FOR') {
          testRes.modifiers += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + testId, "Tour de Force");
        }
        if (attributeAsInt(personnage, 'pacteSanglant', 0) >= 3) {
          testRes.modifiers += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + testId, "Pacte sanglant (+3)");
        }
        if (attributeAsInt(personnage, 'pacteSanglant', 0) >= 5) {
          testRes.modifiers += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + testId, "Pacte sanglant (+5)");
        }
        if (jetCache) sendChat('COF', "/w GM Jet caché : " + buildinline(roll) + bonusText);
        callback(testRes, explications);
      });
    } catch (e) {
      error("Erreur pendant l'évaluation de " + rollExpr + " dans un test de caractéristiques");
      log(e.name + ": " + e.message);
    }
  }

  function pointsDeChance(perso) {
    if (!estPJ(perso)) return 0;
    var optionPC = ficheAttributeAsInt(perso, 'option_pc', 1);
    if (optionPC === 0) return 0;
    return ficheAttributeAsInt(perso, 'pc', 3);
  }

  //callback peut prendre en argument une structure avec les champs:
  // - texte: Le texte du jet
  // - total : Le résultat total du jet
  // - echecCritique, critique pour indiquer si 1 ou 20
  // - roll: le inlineroll
  function jetCaracteristique(personnage, carac, options, testId, evt, callback) {
    var explications = [];
    var bonusCarac = bonusTestCarac(carac, personnage, options, testId, evt, explications);
    var carSup = nbreDeTestCarac(carac, personnage);
    var jetCache = ficheAttributeAsBool(personnage, 'jets_caches', false);
    var de = computeDice(personnage, {
      nbDe: carSup,
      carac: carac,
      dice: options.dice
    });
    if (estAffaibli(personnage) && charAttributeAsBool(personnage, 'insensibleAffaibli')) bonusCarac -= 2;
    var bonusText = '';
    if (bonusCarac > 0) {
      bonusText = ' + ' + bonusCarac;
    } else if (bonusCarac < 0) {
      bonusText = ' - ' + (-bonusCarac);
    }
    var plageEC = 1;
    var plageECText = '1';
    if (options && options.plageEchecCritique) {
      plageEC = options.plageEchecCritique;
      if (plageEC > 1) plageECText = '<' + plageEC;
    }
    var rollExpr = "[[" + de + "cs20cf" + plageECText + "]]";
    sendChat("", rollExpr, function(res) {
      options.rolls = options.rolls || {};
      var roll = options.rolls[testId] || res[0].inlinerolls[0];
      evt.action = evt.action || {};
      evt.action.rolls = evt.action.rolls || {};
      evt.action.rolls[testId] = roll;
      roll.token = personnage.token;
      var d20roll = roll.results.total;
      var rtext = jetCache ? d20roll + bonusCarac : buildinline(roll) + bonusText;
      var rt = {
        total: d20roll + bonusCarac,
      };
      if (d20roll <= plageEC) {
        rtext += " -> échec critique";
        rt.echecCritique = true;
      } else if (d20roll == 20) {
        rtext += " -> réussite critique";
        rt.critique = true;
      } else if (bonusCarac !== 0 && !jetCache) rtext += " = " + rt.total;
      rt.texte = rtext;
      rt.roll = roll;
      if (jetCache) sendChat('COF', "/w GM Jet caché de caractéristique : " + buildinline(roll) + bonusText);
      callback(rt, explications);
    });
  }

  function jetPerso(perso, caracteristique, difficulte, titre, playerId, options) {
    options = options || {};
    var evt = options.evt || {
      type: 'jetPerso',
      personnage: perso,
      action: {
        caracteristique: caracteristique,
        difficulte: difficulte,
        titre: titre,
        playerId: playerId,
        options: options
      }
    };
    addEvent(evt);
    var optionsDisplay = {};
    if (options.secret) {
      if (playerIsGM(playerId)) optionsDisplay.chuchote = true;
      else {
        var character = getObj('character', perso.charId);
        if (character) {
          optionsDisplay.chuchote = '"' + character.get('name') + '"';
          var controledByGM = false;
          var charControlledby = character.get('controlledby');
          charControlledby.split(",").forEach(function(controlledby) {
            if (playerIsGM(controlledby)) controledByGM = true;
          });
          if (!controledByGM) optionsDisplay.retarde = true;
        } else optionsDisplay.retarde = true;
      }
    }
    var display = startFramedDisplay(playerId, titre, perso, optionsDisplay);
    var testId = 'jet_' + perso.charId + '_' + caracteristique;
    if (difficulte === undefined) {
      jetCaracteristique(perso, caracteristique, options, testId, evt,
        function(rt, explications) {
          addLineToFramedDisplay(display, "<b>Résultat :</b> " + rt.texte);
          explications.forEach(function(m) {
            addLineToFramedDisplay(display, m, 80);
          });
          addStatistics(playerId, ["Jet de carac", caracteristique], rt.roll);
          // Maintenant, on diminue la malédiction si le test est un échec
          var attrMalediction = tokenAttribute(perso, 'malediction');
          if (attrMalediction.length > 0) {
            if (rt.echecCritique)
              diminueMalediction(perso, evt, attrMalediction);
            else if (!rt.critique) {
              var action = "!cof-resultat-jet " + stateCOF.eventId;
              var ligne = "L'action est-elle ";
              ligne += bouton(action + " reussi", "réussie", perso);
              ligne += " ou " + bouton(action + " rate", "ratée", perso);
              ligne += " ?";
              addLineToFramedDisplay(display, ligne);
              evt.attenteResultat = true;
            }
          }
          var boutonsReroll = '';
          var pc = pointsDeChance(perso);
          if (pc > 0 && !rt.echecCritique) {
            boutonsReroll +=
              '<br/>' + boutonSimple("!cof-bouton-chance " + evt.id + " " + testId, "Chance") +
              " (reste " + pc + " PC)";
          }
          if (stateCOF.combat && attributeAsBool(perso, 'runeForgesort_énergie') &&
            attributeAsInt(perso, 'limiteParCombat_runeForgesort_énergie', 1) > 0 &&
            (caracteristique == 'FOR' || caracteristique == 'CON' || caracteristique == 'DEX')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + testId, "Rune d'énergie");
          }
          if (stateCOF.combat && attributeAsBool(perso, 'petitVeinard')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-bouton-petit-veinard " + evt.id + " " + testId, "Petit veinard");
          }
          if (stateCOF.combat &&
            !rt.echecCritique && attributeAsBool(perso, 'prouesse') &&
            (caracteristique == 'FOR' || caracteristique == 'DEX')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + testId, "Prouesse");
          }
          if (caracteristique == 'FOR' && attributeAsBool(perso, 'tourDeForce')) {
            boutonsReroll += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + testId, "Tour De Force");
          }
          if (attributeAsInt(perso, 'pacteSanglant', 0) >= 3) {
            boutonsReroll += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + testId, "Pacte sanglant (+3)");
          }
          if (attributeAsInt(perso, 'pacteSanglant', 0) >= 5) {
            boutonsReroll += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + testId, "Pacte sanglant (+5)");
          }
          addLineToFramedDisplay(display, boutonsReroll);
          if (optionsDisplay.retarde) {
            addFramedHeader(display, playerId, true);
            sendChat('', endFramedDisplay(display));
            addFramedHeader(display, undefined, 'gm');
            sendChat('', endFramedDisplay(display));
          } else sendChat('', endFramedDisplay(display));
        });
    } else {
      testCaracteristique(perso, caracteristique, difficulte, testId, options, evt,
        function(tr, explications) {
          addLineToFramedDisplay(display, "<b>Résultat :</b> " + tr.texte);
          explications.forEach(function(m) {
            addLineToFramedDisplay(display, m, 80);
          });
          if (tr.reussite) {
            addLineToFramedDisplay(display, "C'est réussi." + tr.modifiers);
          } else {
            var msgRate = "C'est raté." + tr.rerolls + tr.modifiers;
            addLineToFramedDisplay(display, msgRate);
          }
          if (optionsDisplay.retarde) {
            addFramedHeader(display, playerId, true);
            sendChat('', endFramedDisplay(display));
            addFramedHeader(display, undefined, 'gm');
            sendChat('', endFramedDisplay(display));
          } else sendChat('', endFramedDisplay(display));
        });
    }
  }

  //Par construction, msg.content ne doit pas contenir d'option --nom,
  //et commencer par !cof-jet
  function boutonsCompetences(display, perso, carac, msg, fond) {
    var action = msg.content;
    action = action.replace(/ --competences /, '');
    action = action.replace(/ --competences/, ''); //au cas où ce serait le dernier argument
    var args = action.substring(9); //on enlève !cof-jet
    if (!args.startsWith(carac)) action = "!cof-jet " + carac + " " + args;
    var pictoCarac = carac;
    var overlay;
    switch (carac) {
      case 'FOR':
        pictoCarac = '<span style="font-family: \'Pictos\'">S</span>';
        overlay = 'Force';
        break;
      case 'DEX':
        pictoCarac = '<span style="font-family: \'Pictos Custom\'">t</span>';
        overlay = 'Dextérité';
        break;
      case 'CON':
        pictoCarac = '<span style="font-family: \'Pictos\'">k</span>';
        overlay = 'Constitution';
        break;
      case 'INT':
        pictoCarac = '<span style="font-family: \'Pictos Custom\'">y</span>';
        overlay = 'Intelligence';
        break;
      case 'SAG':
        pictoCarac = '&#9775;';
        overlay = 'Sagesse';
        break;
      case 'CHA':
        pictoCarac = '<span style="font-family: \'Pictos\'">w</span>';
        overlay = 'Charisme';
        break;
    }
    var charButtonStyle = ' style="border-radius:10px;" title="' + overlay + '"';
    var cell = boutonSimple(action, pictoCarac, charButtonStyle);
    addCellInFramedDisplay(display, cell, 150, true, fond);
    var comps = [...listeCompetences[carac].list];
    var attributes = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    var prefixes = new Set();
    var prefixesFOR = new Set();
    var caracFound = new Set();
    //D'abord on cherche les compétences qui correspondent à la carac
    attributes.forEach(function(attr) {
      var attrName = attr.get('name');
      var m = competenceCaracRegExp.exec(attrName);
      if (m) {
        prefixesFOR.delete(m[1]);
        caracFound.add(m[1]);
        if (attr.get('current') == carac) prefixes.add(m[1]);
        return;
      }
      m = competenceCaracsRegExp.exec(attrName);
      if (m) {
        if (attr.get('current').includes(carac)) prefixes.add(m[1]);
        return;
      }
      if (carac != 'FOR') return;
      //Pour le cas de la FOR, il faut connaître les compétences avec carac par défaut
      m = competenceNameRegExp.exec(attrName);
      if (!m) return;
      if (caracFound.has(m[1])) return;
      prefixesFOR.add(m[1]);
    });
    if (carac == 'FOR') {
      prefixesFOR.forEach(function(p) {
        prefixes.add(p);
      });
    }
    var compsMinuscules = listeCompetences[carac].elts;
    prefixes.forEach(function(prefix) {
      var nom = prefix + 'comp_nom';
      var nomAttr = attributes.find(function(a) {
        return a.get('name') == nom;
      });
      if (!nomAttr) return;
      var nomComp = nomAttr.get('current');
      var nomCompMinuscule = nomComp.trim().toLowerCase();
      if (compsMinuscules.has(nomCompMinuscule)) return;
      comps.push(nomComp);
    });
    cell = '';
    var sec = false;
    comps.forEach(function(comp) {
      if (sec) cell += ' ';
      else sec = true;
      var buttonStyle = ' style="background-color:#996600; padding:1px 2px; border-radius:5px;"';
      cell += boutonSimple(action + " --nom " + comp, comp, buttonStyle);
    });
    addCellInFramedDisplay(display, cell, 80, false, fond);
  }

  // prend une distance en mètre et retourne une distance dans l'unité
  // utilisée sur la page du personnage
  function scaleDistance(perso, distance) {
    if (perso.scale) return distance * perso.scale;
    var pageId = perso.pageId;
    if (pageId === undefined) {
      pageId = perso.token.get('pageid');
      perso.pageId = pageId;
    }
    var page = getObj("page", pageId);
    if (page === undefined) {
      perso.scale = 1;
      return distance;
    }
    var unit = page.get('scale_units');
    switch (unit) {
      case 'm':
        perso.scale = 1;
        break;
      case 'ft':
        perso.scale = 3.28084;
        break;
      case 'cm':
        perso.scale = 100;
        break;
      case 'km':
        perso.scale = 0.001;
        break;
      case 'mi':
        perso.scale = 0.000621371;
        break;
      case 'in':
        perso.scale = 39.3701;
        break;
      default:
        sendChat('COF', "Attention, unité de mesure de la page (" + unit + ") non reconnue");
        perso.scale = 1;
    }
    return distance * perso.scale;
  }

  function getPageId(playerId) {
    var pageId;
    if (playerIsGM(playerId)) {
      var player = getObj('player', playerId);
      pageId = player.get('lastpage');
    }
    if (pageId === undefined || pageId === "") {
      var pages = Campaign().get('playerspecificpages');
      if (pages && pages[playerId] !== undefined) {
        return pages[playerId];
      }
      return Campaign().get('playerpageid');
    }
    return pageId;
  }

  // si défini, callback est appelé à chaque élément de selected
  // qui n'est pas un personnage
  // iter seulement sur les élément qui correspondent à des personnages
  function iterSelected(selected, iter, callback) {
    selected.forEach(function(sel) {
      var token = getObj('graphic', sel._id);
      if (token === undefined) {
        if (callback !== undefined) callback();
        return;
      }
      var charId = token.get('represents');
      if (charId === undefined || charId === "") {
        if (callback !== undefined) callback();
        return;
      }
      iter({
        token: token,
        charId: charId
      });
    });
  }

  function getWalls(page, pageId, murs) {
    murs = findObjs({
      _type: 'path',
      _pageid: pageId,
      layer: 'walls'
    });
    murs = murs.map(function(path) {
      var p = {
        angle: path.get('rotation') / 180 * Math.PI,
        width: path.get('width'),
        height: path.get('height'),
        top: path.get('top'),
        left: path.get('left'),
        scaleX: path.get('scaleX'),
        scaleY: path.get('scaleY'),
      };
      var chemin = JSON.parse(path.get('_path'));
      if (chemin.length < 2) return [];
      if (chemin[1][0] != 'L') return [];
      chemin = chemin.map(function(v) {
        return translatePathCoordinates(v[1], v[2], p);
      });
      return chemin;
    });
    if (murs) return murs;
    if (!page.get('lightrestrictmove')) return;
    murs = findObjs({
      _type: 'path',
      _pageid: pageId,
      layer: 'walls'
    });
    murs = murs.map(function(path) {
      var p = {
        angle: path.get('rotation') / 180 * Math.PI,
        width: path.get('width'),
        height: path.get('height'),
        top: path.get('top'),
        left: path.get('left'),
        scaleX: path.get('scaleX'),
        scaleY: path.get('scaleY'),
      };
      var chemin = JSON.parse(path.get('_path'));
      if (chemin.length < 2) return [];
      if (chemin[1][0] != 'L') return [];
      chemin = chemin.map(function(v) {
        return translatePathCoordinates(v[1], v[2], p);
      });
      return chemin;
    });
    return murs;
  }

  // callback(selected, playerId)
  function getSelected(msg, callback, options) {
    var playerId = getPlayerIdFromMsg(msg);
    var pageId;
    if (options && options.pageId) pageId = options.pageId;
    else pageId = getPageId(playerId);
    var args = msg.content.split(' --');
    var selected = [];
    var enleveAuxSelected = [];
    var count = args.length - 1;
    var called;
    options = options || {};
    var actif = options.lanceur;
    if (actif === undefined) {
      if (msg.selected !== undefined && msg.selected.length == 1) {
        actif = persoOfId(msg.selected[0]._id, msg.selected[0]._id, pageId);
      }
    }
    var page;
    var murs;
    var pt;
    var target;
    var finalCall = function() {
      called = true;
      var seen = new Set();
      var res = selected.filter(function(sel) {
        if (seen.has(sel._id)) return false;
        seen.add(sel._id);
        var interdit = enleveAuxSelected.find(function(i) {
          return (i._id == sel._id);
        });
        return (interdit === undefined);
      });
      callback(res, playerId, target);
    };
    if (args.length > 1) {
      args.shift();
      args.forEach(function(cmd) {
        count--;
        var cmdSplit = cmd.split(' ');
        switch (cmdSplit[0]) {
          case 'equipe':
            var nomEquipe = 'Equipe' + cmd.substring(cmd.indexOf(' '));
            var equipes = findObjs({
              _type: 'handout',
              name: nomEquipe
            });
            if (equipes.length === 0) {
              error(nomEquipe + " inconnue", msg.content);
              return;
            }
            if (equipes.length > 1) {
              error("Plus d'une " + nomEquipe, cmd);
            }
            count += equipes.length;
            equipes.forEach(function(equipe) {
              equipe.get('notes', function(note) { //asynchrone
                var persos = charactersInHandout(note, nomEquipe);
                var tokens = findObjs({
                  _type: 'graphic',
                  _subtype: 'token',
                  _pageid: pageId,
                  layer: 'objects'
                });
                var uneCible = false;
                tokens.forEach(function(tok) {
                  var tokCharId = tok.get('represents');
                  if (persos.has(tokCharId)) {
                    uneCible = true;
                    selected.push({
                      _id: tok.id
                    });
                  }
                });
                if (!uneCible) {
                  error("Pas de token de l'" + nomEquipe + " sur la page");
                }
                count--;
                if (count === 0) finalCall();
              });
            });
            return;
          case 'allies':
          case 'saufAllies':
            var selection = selected;
            var saufAllies = (cmdSplit[0] == 'saufAllies');
            if (saufAllies) selection = enleveAuxSelected;
            var actives = [];
            var allies = new Set();
            // First get the acting token (in msg.selected)
            if (actif) {
              actives = [actif];
              allies = alliesParPerso[actif.charId] || allies;
              if (saufAllies) allies = (new Set(allies)).add(actif.charId);
            } else {
              if (msg.selected === undefined || msg.selected.length === 0) {
                error("Pas d'allié car pas de token sélectionné", msg);
                return;
              }
              iterSelected(msg.selected, function(personnage) {
                actives.push(personnage);
                var alliesPerso = alliesParPerso[personnage.charId];
                if (alliesPerso) {
                  alliesPerso.forEach(function(ci) {
                    allies.add(ci);
                  });
                }
                if (saufAllies) allies.add(personnage.charId);
              });
            }
            var tokens = findObjs({
              _type: 'graphic',
              _subtype: 'token',
              _pageid: pageId,
              layer: 'objects'
            });
            tokens.forEach(function(tok) {
              var ci = tok.get('represents');
              if (ci === '') return;
              if (!allies.has(ci)) return;
              //On enlève le token actif, mais seulement pour allies
              if (cmdSplit[0] == 'allies') {
                if (actives.indexOf(function(perso) {
                    return perso.charId == ci;
                  }) >= 0) return;
              }
              selection.push({
                _id: tok.id
              });
            });
            return;
          case 'self':
            if (actif) {
              selected.push({
                _id: actif.token.id
              });
              return;
            }
            if (msg.selected === undefined) return;
            msg.selected.forEach(function(obj) {
              var inSelf = selected.findIndex(function(o) {
                return (o._id == obj._id);
              });
              if (inSelf < 0) selected.push(obj);
            });
            return;
          case 'target':
            if (cmdSplit.length < 2) {
              error("Il manque l'id de la cible (après --target)", cmd);
              return;
            }
            selected.push({
              _id: cmdSplit[1]
            });
            return;
          case 'disque':
            if (cmdSplit.length < 3) {
              error("Pas assez d'arguments pour définir un disque", cmdSplit);
              return;
            }
            var centre = persoOfId(cmdSplit[1], cmdSplit[1], pageId);
            if (centre === undefined) {
              error("le premier argument du disque n'est pas un token valide", cmdSplit);
              return;
            }
            var tokenCentre = centre.token;
            target = {
              left: tokenCentre.get('left'),
              top: tokenCentre.get('top')
            };
            var rayon = parseInt(cmdSplit[2]);
            if (isNaN(rayon) || rayon < 0) {
              error("Rayon du disque mal défini", cmdSplit);
              return;
            }
            var portee;
            if (cmdSplit.length > 3) {
              portee = parseInt(cmdSplit[3]);
              if (isNaN(portee) || portee < 0) {
                error("La portée du disque est mal formée", cmdSplit);
                return;
              }
              if (actif === undefined) {
                error("Pas de token sélectionné pour calculer la distance du disque", msg);
                return;
              }
              if (distanceCombat(tokenCentre, actif.token, pageId, {
                  strict1: true
                }) > portee) {
                sendChar(actif.charId, "Le centre de l'effet est placé trop loin (portée " + portee + " m)");
                return;
              }
            }
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            var pc;
            if (murs) {
              pc = {
                x: tokenCentre.get('left'),
                y: tokenCentre.get('top')
              };
            }
            var allToksDisque =
              findObjs({
                _type: "graphic",
                _pageid: pageId,
                _subtype: 'token',
                layer: 'objects'
              });
            allToksDisque.forEach(function(obj) {
              if (portee === 0 && obj.id == actif.token.id) return; //on ne se cible pas si le centre de l'aoe est soi-même
              var objCharId = obj.get('represents');
              if (objCharId === '') return;
              if (getState({
                  token: obj,
                  charId: objCharId
                }, 'mort')) return; //pas d'effet aux morts
              if (obj.get('bar1_max') == 0) return; // jshint ignore:line
              var objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              var distanceCentre = distanceCombat(tokenCentre, obj, pageId, {
                strict1: true
              });
              if (distanceCentre > rayon) return;
              if (murs) {
                if (obstaclePresent(obj.get('left'), obj.get('top'), pc, murs)) return;
              }
              selected.push({
                _id: obj.id
              });
            });
            if (options.targetFx) {
              spawnFx(tokenCentre.get('left'), tokenCentre.get('top'), options.targetFx, pageId);
            }
            if (tokenCentre.get('bar1_max') == 0) { // jshint ignore:line
              //C'est juste un token utilisé pour définir le disque
              tokenCentre.remove(); //On l'enlève, normalement plus besoin
              delete options.targetFx;
            }
            return;
          case 'enVue':
            var observateur = actif;
            if (cmdSplit.length > 1) {
              observateur = persoOfId(cmdSplit[1], cmdSplit[1], pageId);
            }
            if (observateur === undefined) {
              error("Impossible de trouver la personne à partir de laquelle on sélectionne les tokens en vue", msg);
              return;
            }
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            if (murs) {
              pt = pt || {
                x: observateur.token.get('left'),
                y: observateur.token.get('top')
              };
            }
            var tokensEnVue = findObjs({
              _type: 'graphic',
              _pageid: pageId,
              _subtype: 'token',
              layer: 'objects'
            });
            tokensEnVue.forEach(function(obj) {
              if (obj.id == actif.token.id) return; //on ne se cible pas si le centre de l'aoe est soi-même
              var objCharId = obj.get('represents');
              if (objCharId === '') return;
              if (obj.get('bar1_max') == 0) return; // jshint ignore:line
              var objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              if (murs) {
                if (obstaclePresent(obj.get('left'), obj.get('top'), pt, murs)) return;
              }
              selected.push({
                _id: obj.id
              });
            });
            return;
          case 'alliesEnVue':
            if (actif === undefined) {
              error("Impossible de trouver la personne dont on sélectionne les lliés en vue", msg);
              return;
            }
            var alliesEnVue = alliesParPerso[actif.charId];
            if (alliesEnVue === undefined) {
              log("Personnage sans allié", actif);
              return;
            }
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            if (murs) {
              pt = pt || {
                x: actif.token.get('left'),
                y: actif.token.get('top')
              };
            }
            var tokensAlliesEnVue = findObjs({
              _type: 'graphic',
              _pageid: pageId,
              _subtype: 'token',
              layer: 'objects'
            });
            tokensAlliesEnVue.forEach(function(obj) {
              if (obj.id == actif.token.id) return; //on ne se cible pas si le centre de l'aoe est soi-même
              var objCharId = obj.get('represents');
              if (objCharId === '') return;
              if (!alliesEnVue.has(objCharId)) return;
              if (obj.get('bar1_max') == 0) return; // jshint ignore:line
              var objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              if (murs) {
                if (obstaclePresent(obj.get('left'), obj.get('top'), pt, murs)) return;
              }
              selected.push({
                _id: obj.id
              });
            });
            return;
          default:
        }
      });
    }
    if (count === 0) {
      if (selected.length === 0) {
        if (msg.selected) {
          if (!called) {
            var res = msg.selected.filter(function(sel) {
              var interdit = enleveAuxSelected.find(function(i) {
                return (i._id == sel._id);
              });
              return (interdit === undefined);
            });
            callback(res, playerId, target);
          }
          return;
        }
        if (!called) callback([], playerId, target);
        return;
      }
      if (!called) finalCall();
    }
  }

  //msg peut être directement le playerId ou un message
  function getPlayerIdFromMsg(msg) {
    if (msg.playerid === undefined) return msg;
    var playerId = msg.playerid;
    if (playerId == 'API') {
      var nom = msg.who;
      if (nom === undefined) return playerId;
      nom = nom.replace(/ \(GM\)/, '');
      //On regarde si un joueur s'appelle nom
      var players = findObjs({
        type: 'player',
        displayname: nom
      });
      if (players.length === 0) {
        var characters = findObjs({
          type: 'character',
          name: nom
        });
        if (characters.length === 0) {
          error("Impossible de trouver l'id du joueur " + nom, msg);
          return playerId;
        }
        var pids = characters[0].get('controlledby');
        pids = pids.split(',');
        if (pids[0] == 'all') {
          players = findObjs({
            type: 'player'
          });
          playerId = players[0].id;
        } else playerId = pids[0];
      } else playerId = players[0].id;
    }
    return playerId;
  }

  //!cof-jet [carac] [difficulte]
  // - carac : FOR, DEX, CON, INT, SAG, CHA
  // Les tokens sélectionnés sont ceux qui doivent faire le jet
  function jet(msg) {
    var opts = msg.content.split(' --');
    var cmd = opts.shift().split(' ');
    var options = {
      bonusAttrs: []
    };
    opts.forEach(function(o) {
      var args = o.split(' ');
      switch (args[0]) {
        case "nom":
          if (args.length < 2) {
            error("Il manque un argument à l'option " + args[0], opts);
            return;
          }
          args.shift();
          var nom = args.join(' ');
          if (options.nom && options.nom != nom) {
            error("Nom du jet défini deux fois !", options.nom);
          }
          options.nom = nom;
          if (options.competence)
            options.bonusAttrs.push(nom.toLowerCase());
          else options.competence = nom;
          return;
        case "attribut":
          if (args.length < 2) {
            error("Il manque un argument à l'option " + args[0], opts);
            return;
          }
          options.bonusAttrs.push(args[1]);
          return;
        case 'bonus':
          if (args.length < 2) {
            error("Il manque un argument à l'option " + args[0], opts);
            return;
          }
          var bonus = parseInt(args[1]);
          if (isNaN(bonus)) {
            error("Le bonus doit être un nombre", opts);
            return;
          }
          options.bonus = (options.bonus || 0) + bonus;
          return;
        case 'secret':
        case 'competences':
          options[args[0]] = true;
          return;
        case 'plageEchecCritique':
          if (args.length < 2) {
            error("Il manque un argument à l'option " + args[0], opts);
            return;
          }
          var plageEC = parseInt(args[1]);
          if (isNaN(plageEC) || plageEC < 0 || plageEC > 19) {
            error("La plage d'échecs critqiques doit être un nombre positif inférieur à 19", opts);
            return;
          }
          options.plageEchecCritique = plageEC;
      }
    });
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "!cof-jet sans sélection de token");
        log("!cof-jet requiert de sélectionner des tokens");
        return;
      }
      if (cmd.length < 2) { //On demande la carac et la compétence, si définies dans un handout Compétence
        if (options.nom) {
          error("Il manque la caractéristique à utiliser pour la compétence " + options.nom, msg.content);
          return;
        }
        var fond = listeCompetences.nombre > 25;
        iterSelected(selected, function(perso) {
          var display = startFramedDisplay(playerId, "Jet de caractéristique", perso, {
            chuchote: true
          });
          startTableInFramedDisplay(display);
          boutonsCompetences(display, perso, 'FOR', msg);
          boutonsCompetences(display, perso, 'DEX', msg, fond);
          boutonsCompetences(display, perso, 'CON', msg);
          boutonsCompetences(display, perso, 'SAG', msg, fond);
          boutonsCompetences(display, perso, 'INT', msg);
          boutonsCompetences(display, perso, 'CHA', msg, fond);
          endTableInFramedDisplay(display);
          sendChat('', endFramedDisplay(display));
        }); //fin de iterSelected
        return;
      }
      var caracteristique = cmd[1];
      if (!isCarac(caracteristique)) {
        error("Caracteristique '" + caracteristique + "' non reconnue (FOR, DEX, CON, INT, SAG, CHA).", cmd);
        return;
      }
      if (options.competences && options.nom === undefined) {
        iterSelected(selected, function(perso) {
          var display = startFramedDisplay(playerId, "Jet de " + caracteristique, perso, {
            chuchote: true
          });
          addLineToFramedDisplay(display, "Choisissez la compétence");
          startTableInFramedDisplay(display);
          boutonsCompetences(display, perso, caracteristique, msg);
          endTableInFramedDisplay(display);
          sendChat('', endFramedDisplay(display));
        }); //fin de iterSelected
        return;
      }
      var difficulte;
      if (cmd.length > 2) {
        difficulte = parseInt(cmd[2]);
        if (isNaN(difficulte)) difficulte = undefined;
      }
      var titre = "Jet d";
      var nomJet;
      if (options.nom && options.nom.length > 0) {
        nomJet = options.nom;
      } else {
        nomJet = caracOfMod(caracteristique).toLowerCase();
      }
      var nj = nomJet.toLowerCase();
      switch (nj[0]) {
        case 'a':
        case 'e':
        case 'i':
        case 'o':
        case 'u':
          titre += "'<b>";
          break;
        default:
          titre += "e <b>";
      }
      titre += nomJet;
      titre += "</b>";
      if (nj == 'perception') {
        options.bonusAttrs.push('diversionManoeuvreValeur');
      }
      if (options.bonus)
        titre += " (" + ((options.bonus > 0) ? '+' : '') + options.bonus + ")";
      if (difficulte !== undefined) titre += " difficulté " + difficulte;
      iterSelected(selected, function(perso) {
        jetPerso(perso, caracteristique, difficulte, titre, playerId, options);
      }); //fin de iterSelected
    }); //fin de getSelected
  }

  function resultatJet(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("La fonction !cof-resultat-jet n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("Le jet est trop ancien ou éte annulé", args);
      return;
    }
    if (evt.personnage === undefined) {
      error("Erreur interne ", evt);
      return;
    }
    if (evt.attenteResultat) {
      var message = evt.type + " ";
      if (args[2] == 'rate') {
        diminueMalediction(evt.personnage, evt);
        message += "raté.";
      } else message += "réussi.";
      sendChar(evt.personnage.charId, message);
      delete evt.attenteResultat;
    } else {
      sendPlayer(msg, "Résultat déjà décidé");
    }
  }

  var tempeteDeManaCourante = {
    vide: true
  };

  function ajouterOptionTempete(display, option, texte, restant) {
    var line = texte + " : ";
    if (tempeteDeManaCourante[option])
      line += boutonSimple("!cof-tempete-de-mana -" + option, "Oui");
    else if (restant > 0)
      line += boutonSimple("!cof-tempete-de-mana " + option, "Non");
    else line += "Non";
    addLineToFramedDisplay(display, line);
  }

  function optionsDeTempeteDeMana(msg) {
    if (tempeteDeManaCourante.vide) {
      error("Pas de tempête de mana en cours", tempeteDeManaCourante);
      return;
    }
    var perso = tempeteDeManaCourante.perso;
    var cmd = msg.content.split(' ');
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'duree':
        case 'portee':
        case 'rapide':
          if (tempeteDeManaCourante[cmd[1]]) break;
          tempeteDeManaCourante[cmd[1]] = true;
          tempeteDeManaCourante.cout++;
          break;
        case '-duree':
        case '-portee':
        case '-rapide':
        case '-altruiste':
          var opt = cmd[1].substring(1);
          if (tempeteDeManaCourante[opt]) {
            tempeteDeManaCourante[opt] = false;
            tempeteDeManaCourante.cout--;
          }
          break;
        case 'altruiste':
          if (cmd.length < 3) {
            error("Il manque l'id du token pour l'option altruiste de la tempete de mana", cmd);
            return;
          }
          var cible = persoOfId(cmd[2]);
          if (cmd[2] == perso.token.id) cible = undefined;
          if (cible) {
            if (!tempeteDeManaCourante.altruiste) tempeteDeManaCourante.cout++;
          } else {
            if (tempeteDeManaCourante.altruiste) tempeteDeManaCourante.cout--;
          }
          tempeteDeManaCourante.altruiste = cible;
          break;
        default:
          var it = parseInt(cmd[1]);
          if (isNaN(it) || it < 0) {
            error("Argument de !cof-tempete-de-mana inconnu", cmd);
            return;
          }
          if (tempeteDeManaCourante.intense === undefined)
            tempeteDeManaCourante.intense = 0;
          tempeteDeManaCourante.cout += it - tempeteDeManaCourante.intense;
          tempeteDeManaCourante.intense = it;
      }
    }
    var title = "Tempête de mana";
    if (tempeteDeManaCourante.cout) {
      title += " de puissance " + tempeteDeManaCourante.cout;
    }
    var restant = 100;
    if (tempeteDeManaCourante.max) {
      title += " (max " + tempeteDeManaCourante.max + ")";
      restant = tempeteDeManaCourante.max - tempeteDeManaCourante.cout;
    }
    var display = startFramedDisplay(tempeteDeManaCourante.playerId, title, perso, {
      chuchote: true
    });
    if (tempeteDeManaCourante.dureeDeBase &&
      tempeteDeManaCourante.dm === undefined &&
      tempeteDeManaCourante.soins === undefined)
      ajouterOptionTempete(display, "duree", "Durée", restant);
    if (tempeteDeManaCourante.porteeDeBase)
      ajouterOptionTempete(display, "portee", "Portée", restant);
    ajouterOptionTempete(display, "rapide", "Rapide", restant);
    if (tempeteDeManaCourante.altruistePossible) {
      var la = 'Magie altruiste : ';
      if (restant || tempeteDeManaCourante.altruiste) {
        var tla = "Sélectionner";
        if (tempeteDeManaCourante.altruiste) {
          tla = tempeteDeManaCourante.altruiste.token.get('name');
        }
        la += boutonSimple("!cof-tempete-de-mana altruiste @{target|token_id}", tla);
      } else la += 'Non';
      addLineToFramedDisplay(display, la);
    }
    var line = "Magie intense :";
    var magieIntense = 0;
    if (tempeteDeManaCourante.intense)
      magieIntense = tempeteDeManaCourante.intense;
    var maxMagieIntense = magieIntense + restant;
    if (maxMagieIntense > 5 && restant > 0) maxMagieIntense = magieIntense + 1;
    for (var i = 0; i <= maxMagieIntense; i++) {
      if (i == magieIntense) line += " " + i;
      else line += " " + boutonSimple("!cof-tempete-de-mana " + i, i);
    }
    addLineToFramedDisplay(display, line);
    var v = tempeteDeManaCourante.cmd;
    var vopt = '';
    if (tempeteDeManaCourante.cout) {
      vopt = "--tempeteDeMana";
      if (tempeteDeManaCourante.duree) vopt += " duree";
      if (tempeteDeManaCourante.portee) vopt += " portee";
      if (tempeteDeManaCourante.rapide) vopt += " rapide";
      if (tempeteDeManaCourante.altruiste)
        vopt += " altruiste " + tempeteDeManaCourante.altruiste.token.id;
      if (tempeteDeManaCourante.intense)
        vopt += " " + tempeteDeManaCourante.intense;
    }
    v = v.replace(/--tempeteDeMana/, vopt);
    addLineToFramedDisplay(display, boutonSimple(v, "Valider"));
    sendChat("", endFramedDisplay(display));
  }

  function setTempeteDeMana(playerId, perso, cmd, options) {
    tempeteDeManaCourante = {
      perso: perso,
      playerId: playerId,
      cmd: cmd,
      rapide: options.rapide,
      dm: options.dm,
      soins: options.soins,
      intense: options.intense,
      porteeDeBase: options.portee,
      dureeDeBase: options.duree,
      altruistePossible: options.altruiste,
      cout: options.cout || 0
    };
    var max;
    if (options.rang) max = options.rang;
    var mana = options.mana || 0;
    var niveau = ficheAttributeAsInt(perso, 'niveau', 1);
    var cout_par_effet = 1;
    if (reglesOptionelles.mana.val.mana_totale.val) cout_par_effet = 3;
    if (max === undefined || max > niveau - (mana / cout_par_effet))
      max = Math.floor(niveau - (mana / cout_par_effet));
    if (max < 1) {
      sendChar(perso.charId, "ne peut pas dépenser plus de mana en tempête de mana (niveau " + niveau + ", mana déjà dépensée " + mana + ")");
      return;
    }
    tempeteDeManaCourante.max = max;
    optionsDeTempeteDeMana({
      content: '!cof-tempete-de-mana'
    });
  }

  function parseTempeteDeMana(cmd, options) {
    cmd.shift();
    options.tempeteDeMana = {
      cout: 0
    };
    var altruiste = false;
    cmd.forEach(function(ta) {
      switch (ta) {
        case 'portee':
          if (options.tempeteDeManaPortee) break;
          options.tempeteDeMana.cout++;
          options.tempeteDeManaPortee = true;
          altruiste = false;
          break;
        case 'duree':
          if (options.tempeteDeManaDuree) break;
          options.tempeteDeMana.cout++;
          options.tempeteDeManaDuree = true;
          altruiste = false;
          break;
        case 'rapide':
          options.tempeteDeMana.cout++;
          break;
        case 'altruiste':
          options.altruiste = true;
          altruiste = true;
          break;
        default:
          if (altruiste) {
            altruiste = false;
            var cible = persoOfId(ta);
            if (cible) {
              options.tempeteDeMana.cout++;
              options.tempeteDeMana.altruiste = cible;
            }
          } else {
            var intensite = parseInt(ta);
            if (isNaN(ta) || ta <= 0) {
              error("Option de tempête de mana " + ta + " non reconnue", cmd);
              break;
            }
            options.tempeteDeManaIntense = options.tempeteDeManaIntense || 0;
            options.tempeteDeManaIntense += intensite;
            options.tempeteDeMana.cout += intensite;
          }
      }
    });
    options.mana = options.mana || 0;
    if (reglesOptionelles.mana.val.mana_totale.val)
      options.mana += options.tempeteDeMana.cout * 3;
    else options.mana += options.tempeteDeMana.cout;
  }

  function parseCondition(args) {
    if (args.length > 0 && (args[0] == 'crit' || args[0] == 'critique')) {
      return {
        type: 'critique'
      };
    }
    switch (args[0]) {
      case "etat":
        if (args.length < 2) {
          error("condition non reconnue", args);
          return;
        }
        if (_.has(cof_states, args[1])) {
          return {
            type: 'etat',
            etat: args[1],
            text: args[1]
          };
        }
        return {
          type: 'attribut',
          attribute: args[1],
          text: args[1]
        };
      case "etatCible":
        if (args.length < 2) {
          error("condition non reconnue", args);
          return;
        }
        if (_.has(cof_states, args[1])) {
          return {
            type: 'etatCible',
            etat: args[1],
            text: args[1]
          };
        }
        return {
          type: 'attributCible',
          attribute: args[1],
          text: args[1]
        };
      case 'attributCible':
        if (args.length < 3) {
          error("Il manque un argument pour comparer l'attribut de la cible", args);
          return;
        }
        var res = {
          type: 'attributCible',
          attribute: args[1],
          valeur: args[2].toLowerCase(),
          text: args[1] + ' ' + args[2]
        };
        if (args.length > 3) {
          if (args[3] == 'local') {
            res.local = true;
          } else if (args[3] == 'fiche') {
            res.fiche = {};
            if (args.length > 4) {
              res.fiche.def = args[4];
            }
          }
        }
        return res;
      case 'deAttaque':
        if (args.length < 2) {
          error("condition non reconnue", args);
          return;
        }
        var valeurDeAttaque = parseInt(args[1]);
        if (isNaN(valeurDeAttaque)) {
          error("La condition de dé d'attaque doit être un nombre", args);
          // on continue exprès pour tomber dans le cas par défaut
        } else {
          return {
            type: 'deAttaque',
            seuil: valeurDeAttaque,
            text: args[1]
          };
        }
        /* falls through */
      default:
        return {
          type: args[0],
          attribute: args[1],
          text: args[1]
        };
    }
  }

  function closeIte(scope) {
    var ps = scope.parentScope;
    if (ps === undefined) return;
    log("Il manque un endif");
    delete scope.parentScope;
    closeIte(ps);
  }

  function getFx(cmd, argName, obj, funName) {
    if (cmd.length < 2) {
      var errMsg = "Il manque un argument à l'option --" + argName;
      if (funName) errMsg += " de " + funName;
      sendChat("COF", errMsg);
      return;
    }
    if (cmd[1] == 'custom' && cmd.length > 2) {
      var effet = findObjs({
        _type: 'custfx',
        name: cmd[2]
      });
      if (effet.length === 0) {
        sendChat("COF", "L'effet custom " + cmd[2] + " est inconnu.");
        return;
      }
      obj[argName] = effet[0].id;
    } else obj[argName] = cmd[1];
  }

  function parseAttack(msg) {
    // Arguments to cof-attack should be:
    // - attacking token
    // - target token
    // - attack number (referring to the character sheet) or attack name
    // - some optional arguments, preceded by --
    var optArgs = msg.content.split(' --');
    var args = optArgs[0].split(' ');
    args = args.filter(function(a) {
      return a !== '';
    });
    optArgs.shift();
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-attack: " + msg.content, args);
      return;
    }
    var attaquant = persoOfId(args[1]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-attack n'est pas un token valide", args[1]);
      return;
    }
    var targetToken = getObj('graphic', args[2]);
    if (targetToken === undefined) {
      error("le second argument de !cof-attack doit être un token", args[2]);
      return;
    }
    var attackLabel;
    if (args.length > 3) {
      attackLabel = args.slice(3).join(' ').trim();
    }
    var weaponStats = {};
    var attaqueArray;
    try {
      attaqueArray = JSON.parse(attackLabel);
    } catch (e) {}
    if (Array.isArray(attaqueArray) && attaqueArray.length > 4 &&
      attaqueArray[1].length > 1 && attaqueArray[3].length > 3) {
      weaponStats.name = attaqueArray[0].replace(/_/g, ' ');
      weaponStats.attSkill = attaqueArray[1][0];
      weaponStats.attSkillDiv = attaqueArray[1][1];
      weaponStats.crit = attaqueArray[2];
      var weaponDmg = attaqueArray[3];
      weaponStats.attNbDices = weaponDmg[0];
      weaponStats.attDice = weaponDmg[1];
      weaponStats.attCarBonus = weaponDmg[2];
      weaponStats.attDMBonusCommun = weaponDmg[3];
      weaponStats.portee = attaqueArray[4];
      if (attaqueArray.length > 5) {
        weaponStats.divers = attaqueArray[5];
      } else {
        weaponStats.divers = '';
      }
    } else {
      //On trouve l'attaque correspondant au label
      if (attackLabel == -1) { //attaque avec l'arme en main
        weaponStats = armesEnMain(attaquant);
        if (weaponStats === undefined)
          weaponStats = getWeaponStats(attaquant, attackLabel);
      } else weaponStats = getWeaponStats(attaquant, attackLabel);
    }
    //Ajout des options de l'arme
    var wo = weaponStats.options.trim();
    //Pour la partie options, il est possible qu'elle soit déjà passée en ligne de commande
    if (wo !== '' && (optArgs.length < 1 || !optArgs[0].startsWith('attaqueOptions'))) {
      wo = ' ' + wo;
      wo.split(' --').reverse().forEach(function(o) {
        o = o.trim();
        if (o === '') return;
        optArgs.unshift(o);
      });
    }
    if (weaponStats.modificateurs) {
      weaponStats.modificateurs.split(',').reverse().forEach(function(m) {
        m = m.trim();
        if (m === '') return;
        m.split(' ').reverse().forEach(function(m) {
          m = m.trim();
          if (m === '') return;
          optArgs.unshift(m);
        });
      });
    }
    var playerId = getPlayerIdFromMsg(msg);
    // Optional arguments
    var options = {
      sortilege: weaponStats.sortilege,
      hache: weaponStats.hache,
      armeNaturelle: weaponStats.armeNaturelle
    };
    switch (weaponStats.typeDegats) {
      case 'mental':
        options.attaqueMentale = true;
        /* falls through */
      case 'feu':
      case 'froid':
      case 'acide':
      case 'electrique':
      case 'sonique':
      case 'poison':
      case 'maladie':
        options.type = weaponStats.typeDegats;
        break;
      case 'tranchant':
      case 'percant':
      case 'contondant':
      case 'magique':
        options[weaponStats.typeDegats] = true;
        break;
    }
    var lastEtat; //dernier de etats et effets
    var lastType = options.type; //dernier type de dégâts infligés
    var scope = options; //Pour les conditionnelles
    optArgs.forEach(function(arg) {
      arg = arg.trim();
      var cmd = arg.split(' ');
      cmd = cmd.filter(function(c) {
        return c !== '';
      });
      if (cmd.length === 0) cmd = [arg];
      switch (cmd[0]) {
        case 'pressionMortelle':
        case 'ignoreMoitieRD':
        case 'tempDmg':
        case 'vampirise':
        case 'enflamme':
        case 'malediction':
        case 'pietine':
        case 'percute':
        case 'maxDmg':
        case 'ouvertureMortelle':
        case 'seulementVivant':
        case 'etreinteImmole':
          scope[cmd[0]] = true;
          return;
        case 'arc':
        case 'arbalete':
        case 'epieu':
        case 'hache':
        case 'affute':
        case 'choc':
        case 'armeDArgent':
        case 'artificiel':
        case 'asDeLaGachette':
        case 'attaqueMentale':
        case 'auto':
        case 'avecd12':
        case 'demiAuto':
        case 'explodeMax':
        case 'feinte':
        case 'ignoreObstacles':
        case 'mainsDEnergie':
        case 'pasDeDmg':
        case 'pointsVitaux':
        case 'poudre':
        case 'metal':
        case 'ferFroid':
        case 'reroll1':
        case 'reroll2':
        case 'semonce':
        case 'sortilege':
        case 'strigeSuce':
        case 'tirDeBarrage':
        case 'test':
        case 'traquenard':
        case 'tueurDeGeants':
        case 'tueurDeGrands':
        case 'grenaille':
        case 'attaqueArmeeConjuree':
        case 'difficultePVmax':
        case 'difficultePV':
        case 'lamesJumelles':
        case 'riposte':
        case 'secret':
        case 'saufAllies':
        case 'attaqueAssuree':
        case 'attaqueRisquee':
        case 'attaqueOptions':
        case 'tirAveugle':
          options[cmd[0]] = true;
          return;
        case 'm2d20':
        case 'avantage':
          options.avantage = options.avantage || 1;
          options.avantage++;
          return;
        case 'désavantage':
        case 'desavantage':
          options.avantage = options.avantage || 1;
          options.avantage--;
          return;
        case 'avecd12crit':
          options.avecd12 = {
            crit: true
          };
          return;
        case 'tranchant':
        case 'contondant':
        case 'percant':
          options.contondant = undefined;
          options.percant = undefined;
          options.tranchant = undefined;
          options[cmd[0]] = true;
          return;
        case 'nom':
        case 'special':
          if (cmd.length < 1) {
            error("Il manque le nom après l'option --" + cmd[0], cmd);
            return;
          }
          options[cmd[0]] = cmd.slice(1).join(' ').trim();
          return;
        case 'toucher':
        case 'modifiePortee':
          if (cmd.length < 1) {
            error("Il manque la valeur après l'option --" + cmd[0], cmd);
            return;
          }
          var intArg = parseInt(cmd[1]);
          if (isNaN(intArg)) {
            error("valeur de " + cmd[0] + " incorrecte", cmd);
            return;
          }
          options[cmd[0]] = intArg;
          return;
        case 'crit':
          if (cmd.length < 1) {
            error("Il manque la valeur après l'option --crit", cmd);
            return;
          }
          var crit = parseInt(cmd[1]);
          if (isNaN(crit)) {
            error("valeur de critique incorrecte", cmd);
            return;
          }
          if (crit < 2) crit = 2;
          else if (crit > 20) crit = 20;
          options.crit = crit;
          return;
        case 'dm':
          if (cmd.length < 1) {
            error("Il manque la valeur après l'option --dm", cmd);
            return;
          }
          var dm = {
            nbDe: 0,
            dice: 4,
            bonus: 0
          };
          var exprDM = cmd.slice(1).join('').trim().toLowerCase();
          var indexD = exprDM.indexOf('d');
          if (indexD > 0) {
            dm.nbDe = parseInt(exprDM.substring(0, indexD));
            if (isNaN(dm.nbDe) || dm.nbDe < 0) {
              error("Expression de dégâts " + exprDM + " mal formée", cmd);
              return;
            }
            exprDM = exprDM.substring(indexD + 1);
            indexD = exprDM.search(/[+\-]/);
            if (indexD <= 0) {
              dm.dice = parseInt(exprDM);
              if (isNaN(dm.dice) || dm.dice < 1) {
                error("Nombre de faces incorrect dans l'expression des dégâts", cmd);
                return;
              }
              options.dm = dm;
              return;
            }
            exprDM = exprDM.replace('+-', '-');
            dm.dice = parseInt(exprDM.substring(0, indexD));
            if (isNaN(dm.dice) || dm.dice < 1) {
              error("Nombre de faces incorrect dans l'expression des dégâts", cmd);
              return;
            }
            exprDM = exprDM.substring(indexD);
          }
          dm.bonus = parseInt(exprDM);
          if (isNaN(dm.bonus)) {
            error("Expression de dégâts incorrecte", cmd);
            return;
          }
          options.dm = dm;
          return;
        case 'portee':
          if (cmd.length < 1) {
            error("Il manque la valeur après l'option --portee", cmd);
            return;
          }
          var portee = parseInt(cmd[1]);
          if (isNaN(portee) || portee < 0) {
            error("valeur de critique incorrecte", cmd);
            return;
          }
          options.portee = portee;
          return;
        case 'imparable': //deprecated
          options.m2d20 = true;
          return;
        case 'tirDouble':
          if (cmd.length > 1)
            options.tirDouble = {
              label: cmd[1]
            };
          else options.tirDouble = options.tirDouble || true;
          return;
        case 'ignoreRD':
          if (cmd.length < 2) {
            scope.ignoreTouteRD = true;
            return;
          }
          scope.ignoreRD = parseInt(cmd[1]);
          if (isNaN(scope.ignoreRD) || scope.ignoreRD < 1) {
            log("Pas un nombre positif après --ignoreRD, interprété comme ignore toute la RD");
            scope.ignoreRD = undefined;
            scope.ignoreTouteRD = true;
          }
          return;
        case 'magique':
          var niveauMagie = 1;
          if (cmd.length > 1) {
            niveauMagie = parseInt(cmd[1]);
            if (isNaN(niveauMagie) || niveauMagie < 1) {
              error("Le niveau de magie doit être au moins 1", cmd);
              niveauMagie = 1;
            }
          }
          options.magique = niveauMagie;
          return;
        case 'si':
          options.conditionAttaquant = parseCondition(cmd.slice(1));
          return;
        case 'tempsRecharge':
          if (cmd.length < 3) {
            error("Il manque un argument à l'option --tempsRecharge de !cof-attack", cmd);
            return;
          }
          if (!estEffetTemp(cmd[1])) {
            error("Le premier argument de l'option --tempsRecharge doit être un effet temporaire répertorié", cmd);
            return;
          }
          var tr = parseInt(cmd[2]);
          if (isNaN(tr)) {
            error("Le deuxième argument de l'option --tempsRecharge doit être un nombre", cmd);
            return;
          }
          options.tempsRecharge = {
            effet: cmd[1],
            duree: tr
          };
          return;
        case 'plus':
          if (cmd.length < 2) {
            error("Il manque un argument à l'option --plus de !cof-attack", cmd);
            return;
          }
          var val = arg.substring(arg.indexOf(' ') + 1);
          scope.additionalDmg = scope.additionalDmg || [];
          scope.additionalDmg.push({
            value: val,
            type: scope.type
          });
          break;
        case 'plusCrit':
          if (cmd.length < 2) {
            error("Il manque un argument à l'option --plusCrit de !cof-attack", cmd);
            return;
          }
          var valCrit = arg.substring(arg.indexOf(' ') + 1);
          scope.additionalCritDmg = scope.additionalCritDmg || [];
          scope.additionalCritDmg.push({
            value: valCrit,
            type: scope.type
          });
          break;
        case 'effet':
          if (cmd.length < 2) {
            error("Il manque un argument à l'option --effet de !cof-attack", cmd);
            return;
          }
          var effet = cmd[1];
          if (cof_states[effet]) { //remplacer par sa version effet temporaire
            effet += 'Temp';
          }
          if (estEffetTemp(effet)) {
            var duree = 1;
            if (cmd.length > 2) {
              duree = parseInt(cmd[2]);
              if (isNaN(duree) || duree < 1) {
                error(
                  "Le deuxième argument de --effet doit être un nombre positif",
                  cmd);
                return;
              }
            }
            var m = messageOfEffetTemp(effet);
            lastEtat = {
              effet: effet,
              duree: duree,
              message: m,
              typeDmg: lastType
            };
            scope.seulementVivant = scope.seulementVivant || (m && m.seulementVivant);
          } else if (estEffetCombat(effet)) {
            lastEtat = {
              effet: effet,
              typeDmg: lastType
            };
          } else if (estEffetIndetermine(effet)) {
            lastEtat = {
              effet: effet,
              effetIndetermine: true,
              typeDmg: lastType
            };
          } else {
            error(cmd[1] + " n'est pas un effet temporaire répertorié", cmd);
            return;
          }
          scope.effets = scope.effets || [];
          scope.effets.push(lastEtat);
          return;
        case 'valeur':
          if (cmd.length < 2) {
            error("Il manque un argument à l'option --valeur de !cof-attack", cmd);
            return;
          }
          if (scope.effets === undefined || scope.effets.length === 0) {
            error("Il faut un effet avant l'option --valeur", optArgs);
            return;
          }
          scope.effets[0].valeur = cmd[1];
          if (cmd.length > 2) {
            scope.effets[0].valeurMax = cmd[2];
            if (scope.effets[0].effet && scope.effets[0].effet.startsWith('dotGen(')) {
              scope.effets[0].typeDmg = cmd[2];
            }
          }
          return;
        case 'accumuleDuree':
          if (cmd.length < 2) {
            error("Il manque la valeur en argument de l'option --accumuleDuree", cmd);
            return;
          }
          var accumuleDuree = parseInt(cmd[1]);
          if (isNaN(accumuleDuree) || accumuleDuree < 1) {
            error("On ne peut accumuler qu'on nombre strictement positif d'effets", cmd);
            return;
          }
          if (scope.effets === undefined || scope.effets.length === 0) {
            error("Il faut un effet avant l'option --accumuleValeur", optArgs);
            return;
          }
          scope.effets[0].accumuleDuree = accumuleDuree;
          return;
        case 'etatSi':
        case 'etat':
          if (cmd.length < 3 && cmd[0] == 'etatSi') {
            error("Il manque un argument à l'option --etatSi de !cof-attack", cmd);
            return;
          } else if (cmd.length < 2) {
            error("Il manque un argument à l'option --etat de !cof-attack", cmd);
            return;
          }
          var etat = cmd[1];
          if (!_.has(cof_states, etat)) {
            error("Etat non reconnu", cmd);
            return;
          }
          var condition = 'toujoursVrai';
          if (cmd[0] == 'etatSi') {
            condition = parseCondition(cmd.slice(2));
            if (condition === undefined) return;
          }
          scope.etats = scope.etats || [];
          lastEtat = {
            etat: etat,
            condition: condition,
            typeDmg: lastType
          };
          if (cmd[0] == 'etat' && cmd.length > 3) {
            if (!isCarac(cmd[2]) && (cmd[2].length != 6 ||
                !isCarac(cmd[2].substring(0, 3)) || !isCarac(cmd[2].substring(3, 6)))) {
              error("Caractéristique du jet de sauvegarde incorrecte", cmd);
              return;
            }
            lastEtat.saveCarac = cmd[2];
            var opposition = persoOfId(cmd[3]);
            if (opposition) {
              lastEtat.saveDifficulte = cmd[3] + ' ' + opposition.token.get('name');
            } else {
              lastEtat.saveDifficulte = parseInt(cmd[3]);
              if (isNaN(lastEtat.saveDifficulte)) {
                error("Difficulté du jet de sauvegarde incorrecte", cmd);
                delete lastEtat.saveCarac;
                delete lastEtat.saveDifficulte;
              }
            }
          }
          scope.etats.push(lastEtat);
          return;
        case 'psi': //deprecated
          var psil = 0;
          if (scope.additionalDmg) psil = scope.additionalDmg.length;
          if (psil === 0) {
            error("option --psi non précédée d'un --plus", optArgs);
            return;
          }
          var psiCond = parseCondition(cmd.slice(1));
          if (psiCond) {
            var psiDmg = scope.additionalDmg[psil - 1];
            psiDmg.conditions = psiDmg.conditions || [];
            psiDmg.conditions.push(psiCond);
          }
          return;
        case 'peur':
          if (cmd.length < 3) {
            error("Il manque un argument à l'option --peur de !cof-attack", cmd);
            return;
          }
          scope.peur = {
            seuil: parseInt(cmd[1]),
            duree: parseInt(cmd[2])
          };
          if (isNaN(scope.peur.seuil)) {
            error("Le premier argument de --peur doit être un nombre (le seuil)", cmd);
          }
          if (isNaN(scope.peur.duree) || scope.peur.duree <= 0) {
            error("Le deuxième argument de --peur doit être un nombre positif (la durée)", cmd);
          }
          return;
        case 'feu':
        case 'froid':
        case 'acide':
        case 'electrique':
        case 'sonique':
        case 'poison':
        case 'maladie':
        case 'argent':
          lastType = cmd[0];
          var l = 0;
          if (scope.additionalDmg) l = scope.additionalDmg.length;
          if (l > 0) {
            scope.additionalDmg[l - 1].type = cmd[0];
          } else {
            scope.type = cmd[0];
          }
          return;
        case 'nature':
        case 'naturel':
          scope.nature = true;
          return;
        case 'sournoise':
        case 'de6Plus': //deprecated
          if (cmd.length < 2) {
            error("Il manque un argument à l'option --sournoise de !cof-attack", cmd);
            return;
          }
          if (scope.sournoise === undefined) scope.sournoise = 0;
          scope.sournoise += parseInt(cmd[1]);
          if (isNaN(scope.sournoise) || scope.sournoise < 0) {
            error("L'option --sournoise de !cof-attack attend un argument entier positif", cmd);
            return;
          }
          break;
        case 'disparition':
          if (cmd.length < 2) {
            error("Il manque un argument à l'option --disparition de !cof-attack", cmd);
            return;
          }
          var disparition = parseInt(cmd[1]);
          if (isNaN(disparition) || disparition < 0) {
            error("L'option --disparition de !cof-attack attend un argument entier positif", cmd);
            return;
          }
          if (options.disparition === undefined) options.disparition = 0;
          options.disparition += disparition;
          return;
        case 'fx':
          getFx(cmd, 'fx', scope, '!cof-attack');
          return;
        case 'targetFx':
          getFx(cmd, 'targetFx', scope, '!cof-attack');
          return;
        case 'psave':
          var psaveopt = scope;
          var psaveParams = parseSave(cmd);
          if (psaveParams) {
            if (psaveParams.local) {
              var psavel = 0;
              if (scope.additionalDmg) psavel = scope.additionalDmg.length;
              if (psavel > 0) {
                psaveopt = scope.additionalDmg[psavel - 1];
              }
            }
            psaveopt.partialSave = psaveParams;
            psaveopt.attaquant = {...attaquant
            };
          }
          return;
        case 'save':
          if (lastEtat) {
            if (lastEtat.save) {
              error("Redéfinition de la condition de save pour un effet", optArgs);
            }
            var saveParams = parseSave(cmd);
            if (saveParams) {
              lastEtat.save = saveParams;
              return;
            }
            return;
          }
          error("Pas d'effet auquel appliquer le save", optArgs);
          return;
        case 'saveParTour':
        case 'saveParJour':
          if (lastEtat) {
            if (lastEtat[cmd[0]]) {
              error("Redéfinition de la condition de save pour un effet", optArgs);
            }
            var saveParTourParams = parseSave(cmd);
            if (saveParTourParams) {
              lastEtat[cmd[0]] = saveParTourParams;
              return;
            }
            return;
          }
          error("Pas d'effet auquel appliquer le save", optArgs);
          return;
        case "mana":
          if (cmd.length < 2) {
            error("Usage : --mana coût", cmd);
            return;
          }
          var mana = parseInt(cmd[1]);
          if (isNaN(mana) || mana < 0) {
            error("Le coût en mana doit être un nombre positif");
            return;
          }
          if (scope.mana === undefined) scope.mana = 0;
          scope.mana += mana;
          break;
        case "tempeteDeMana":
          parseTempeteDeMana(cmd, options);
          return;
        case "rang":
          if (cmd.length < 2) {
            error("Usage : --rang r", cmd);
            return;
          }
          var rang = parseInt(cmd[1]);
          if (isNaN(rang) || rang < 1) {
            error("Le rang doit être un nombre positif");
            return;
          }
          scope.rang = rang;
          break;
        case "bonusAttaque":
        case "bonusContreBouclier":
          if (cmd.length < 2) {
            error("Usage : --" + cmd[0] + " b", cmd);
            return;
          }
          var bAtt = parseInt(cmd[1]);
          if (isNaN(bAtt)) {
            error("Le bonus (" + cmd[0] + ") doit être un nombre");
            return;
          }
          if (scope[cmd[0]] === undefined) scope[cmd[0]] = 0;
          scope[cmd[0]] += bAtt;
          return;
        case "bonusCritique":
        case "attaqueDeGroupe":
          if (cmd.length < 2) {
            error("Usage : --" + cmd[0] + " b", cmd);
            return;
          }
          var b2Att = parseInt(cmd[1]);
          if (isNaN(b2Att)) {
            error("Le bonus (" + cmd[0] + ") doit être un nombre");
            return;
          }
          if (options[cmd[0]] === undefined) options[cmd[0]] = 0;
          options[cmd[0]] += b2Att;
          return;
        case 'puissant':
          if (cmd.length < 2) {
            scope.puissant = true;
            return;
          }
          switch (cmd[1]) {
            case 'oui':
            case 'Oui':
              scope.puissant = true;
              return;
            case 'non':
            case 'Non':
              scope.puissant = false;
              return;
            case 'duree':
              scope.puissantDuree = true;
              return;
            case 'portee':
              scope.puissantPortee = true;
              return;
            default:
              scope.puissant = attributeAsBool(attaquant, cmd[1] + "Puissant");
          }
          return;
        case "rate":
        case "touche":
        case "critique":
        case "echecCritique":
          if (options.triche === undefined) {
            options.triche = cmd[0];
          } else {
            error("Option incompatible", optArgs);
          }
          return;
        case 'munition':
          if (cmd.length < 2) {
            error("Pour les munitions, il faut préciser le nom", cmd);
            return;
          }
          var tauxPertes = 100; //Par défaut, les munitions sont perdues
          if (cmd.length > 2)
            tauxPertes = parseInt(cmd[2]);
          if (isNaN(tauxPertes) || tauxPertes < 0 || tauxPertes > 100) {
            error("Le taux de pertes des munitions doit être un nombre entre 0 et 100");
            tauxPertes = 100;
          }
          options.munition = {
            nom: cmd[1],
            taux: tauxPertes
          };
          return;
        case "ligne":
          if (options.aoe) {
            error("Deux options pour définir une aoe", args);
            return;
          }
          options.aoe = {
            type: 'ligne'
          };
          return;
        case 'disque':
          if (options.aoe) {
            error("Deux options pour définir une aoe", args);
            return;
          }
          if (cmd.length < 2) {
            error("Il manque le rayon du disque", cmd);
            return;
          }
          options.aoe = {
            type: 'disque',
            rayon: parseInt(cmd[1])
          };
          if (isNaN(options.aoe.rayon) || options.aoe.disque < 0) {
            error("le rayon du disque n'est pas un nombre positif", cmd);
            delete options.aoe;
          }
          return;
        case 'cone':
          if (options.aoe) {
            error("Deux options pour définir une aoe", args);
            return;
          }
          var angle = 90;
          if (cmd.length > 1) {
            angle = parseInt(cmd[1]);
            if (isNaN(angle) || angle < 0 || angle > 360) {
              error("Paramètre d'angle du cone incorrect", cmd);
              angle = 90;
            }
          }
          options.aoe = {
            type: 'cone',
            angle: angle
          };
          return;
        case 'target':
          if (cmd.length < 2) {
            error("Il manque l'id de la cible", cmd);
            return;
          }
          var targetS = persoOfId(cmd[1]);
          if (targetS === undefined) {
            error("Cible supplémentaire invalide", cmd);
            return;
          }
          if (targetToken.id == targetS.token.id) return;
          targetS.tokName = targetS.token.get('name');
          options.ciblesSupplementaires = options.ciblesSupplementaires || [];
          options.ciblesSupplementaires.push(targetS);
          return;
        case 'limiteParJour':
          if (cmd.length < 2) {
            error("Il manque la limite journalière", cmd);
            return;
          }
          var limiteParJour = parseInt(cmd[1]);
          if (isNaN(limiteParJour) || limiteParJour < 1) {
            error("La limite journalière doit être un nombre positif", cmd);
            return;
          }
          scope.limiteParJour = limiteParJour;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            scope.limiteParJourRessource = cmd.join('_');
          }
          return;
        case 'limiteParCombat':
          if (cmd.length < 2) {
            scope.limiteParCombat = 1;
            return;
          }
          var limiteParCombat = parseInt(cmd[1]);
          if (isNaN(limiteParCombat) || limiteParCombat < 1) {
            error("La limite par combat doit être un nombre positif", cmd);
            return;
          }
          scope.limiteParCombat = limiteParCombat;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            scope.limiteParCombatRessource = cmd.join('_');
          }
          return;
        case 'decrAttribute':
          if (cmd.length < 2) {
            error("Erreur interne d'une commande générée par bouton", cmd);
            return;
          }
          var attr = getObj('attribute', cmd[1]);
          if (attr === undefined) {
            attr = tokenAttribute(attaquant, cmd[1]);
            if (attr.length === 0) {
              log("Attribut à changer perdu");
              log(cmd);
              return;
            }
            attr = attr[0];
          }
          scope.decrAttribute = attr.id; //Seulement l'id pour pouvoir cloner
          return;
        case 'incrDmgCoef':
          scope.dmgCoef = (scope.dmgCoef || 1);
          if (cmd.length > 1) {
            var incrDmgCoef = parseInt(cmd[1]);
            if (isNaN(incrDmgCoef)) {
              error("L'option --incrDmgCoef attend un entier", cmd);
              return;
            }
            scope.dmgCoef += incrDmgCoef;
            return;
          }
          scope.dmgCoef++; //Par défaut, incrémente de 1
          return;
        case 'diviseDmg':
          scope.diviseDmg = (scope.diviseDmg || 1);
          if (cmd.length > 1) {
            var diviseDmg = parseInt(cmd[1]);
            if (isNaN(diviseDmg)) {
              error("L'option --diviseDmg attend un entier", cmd);
              return;
            }
            scope.diviseDmg *= diviseDmg;
            return;
          }
          scope.diviseDmg *= 2; //Par défaut, divise par 2
          return;
        case 'incrCritCoef':
          scope.critCoef = (scope.critCoef || 1);
          if (cmd.length > 1) {
            var incrCritCoef = parseInt(cmd[1]);
            if (isNaN(incrCritCoef)) {
              error("L'option --incrCritCoef attend un entier", cmd);
              return;
            }
            scope.critCoef += incrCritCoef;
            return;
          }
          scope.critCoef++; //Par défaut, incrémente de 1
          return;
        case 'if':
          var ifCond = parseCondition(cmd.slice(1));
          if (ifCond === undefined) return;
          var ifThen = {
            parentScope: scope
          };
          scope.ite = scope.ite || [];
          scope.ite.push({
            condition: ifCond,
            then: ifThen
          });
          scope = ifThen;
          return;
        case 'ifSaveFails':
          var save = parseSave(cmd);
          if (save === undefined) return;
          var ifSaveThen = {
            parentScope: scope
          };
          scope.ite = scope.ite || [];
          var ifSaveCond = {
            type: 'save',
            saveCond: save,
            typeDmg: lastType
          };
          scope.ite.push({
            condition: ifSaveCond,
            then: ifSaveThen
          });
          scope = ifSaveThen;
          return;
        case "endif":
          var psEndif = scope.parentScope;
          if (psEndif === undefined) {
            error("--endIf sans --if correspondant", cmd);
            return;
          }
          delete scope.parentScope; //To remove circular dependencies in options
          scope = psEndif;
          return;
        case "else":
          var psElse = scope.parentScope;
          if (psElse === undefined) {
            error("--else sans --if correspondant", cmd);
            return;
          }
          var iteL = psElse.ite[psElse.ite.length - 1];
          if (iteL.else) {
            error("Il y a déjà un --else pour ce --if", cmd);
            return;
          }
          delete scope.parentScope;
          var ifElse = {
            parentScope: psElse
          };
          iteL.else = ifElse;
          scope = ifElse;
          return;
        case 'message':
          if (cmd.length < 2) {
            error("Il manque le message après --message", cmd);
            return;
          }
          scope.messages = scope.messages || [];
          scope.messages.push(cmd.slice(1).join(' '));
          return;
        case 'allonge':
          if (cmd.length < 2) {
            error("Il manque le message après --allonge", cmd);
            return;
          }
          if (options.allonge !== undefined) {
            log("Redéfinition de l'allong");
          }
          options.allonge = parseFloat(cmd[1]);
          if (isNaN(options.allonge)) {
            error("L'argument de --allonge n'est pas un nombre", cmd);
          }
          return;
        case 'enveloppe':
          scope.enveloppe = {
            difficulte: 15,
            type: 'label',
            expression: attackLabel
          };
          if (cmd.length > 1) {
            scope.enveloppe.difficulte = parseInt(cmd[1]);
            if (isNaN(scope.enveloppe.difficulte))
              scope.enveloppe.difficulte = 15;
          }
          if (cmd.length > 3) {
            scope.enveloppe.type = cmd[2];
            scope.enveloppe.expression = cmd[3];
          }
          if (scope.enveloppe.expression === undefined) {
            error("Il n'est pas encore possible d'utiliser l'option --enveloppe sans expression si le label de l'attaque n'est pas défini", cmd);
            scope.enveloppe = undefined;
          }
          return;
        case 'etreinte':
          scope.enveloppe = {
            difficulte: 15,
            type: 'etreinte',
            expression: '1d6',
          };
          if (cmd.length > 1) {
            scope.enveloppe.difficulte = parseInt(cmd[1]);
            if (isNaN(scope.enveloppe.difficulte))
              scope.enveloppe.difficulte = 15;
          }
          if (cmd.length > 2) {
            scope.enveloppe.expression = cmd[2];
          }
          return;
        case 'imgAttack':
        case 'imgAttackEchec':
        case 'imgAttackEchecCritique':
        case 'imgAttackEchecClignotement':
        case 'imgAttackSucces':
        case 'imgAttackSuccesChampion':
        case 'imgAttackSuccesCritique':
          if (cmd.length < 1) {
            error("Il manque une image après --" + cmd[0], cmd);
            return;
          }
          options[cmd[0]] = cmd[1];
          return;
        case 'soundAttack':
        case 'soundAttackEchec':
        case 'soundAttackEchecCritique':
        case 'soundAttackEchecClignotement':
        case 'soundAttackSucces':
        case 'soundAttackSuccesChampion':
        case 'soundAttackSuccesCritique':
          if (cmd.length < 1) {
            error("Il manque le son après --" + cmd[0], cmd);
            return;
          }
          options[cmd[0]] = cmd.slice(1).join(' ');
          return;
          //Anciennes variantes, gardées pour la compatibilité
        case 'img-attack-echec-critique':
        case 'img-attack-echec':
        case 'img-attack-echec-clignotement':
        case 'img-attack-normal-touch':
        case 'img-attack-succes':
        case 'img-attack-champion-succes':
        case 'img-attack-succes-champion':
        case 'img-attack-succes-critique':
          if (cmd.length < 1) {
            error("Il manque une image après --" + cmd[0], cmd);
            return;
          }
          var imgCmd = cmd[0].replace('-a', 'A').replace('-e', 'E').replace('-c', 'C').replace('-n', 'N').replace('-s', 'S').replace('-t', 'T');
          if (imgCmd == 'imgAttackNormalTouch') imgCmd = 'imgAttackSucces';
          if (imgCmd == 'imgAttackChampionSucces') imgCmd = 'imgAttackSuccesChampion';
          options[imgCmd] = cmd[1];
          return;
        case 'sound-attack-echec-critique':
        case 'sound-attack-echec':
        case 'sound-attack-echec-clignotement':
        case 'sound-attack-normal-touch':
        case 'sound-attack-succes':
        case 'sound-attack-champion-succes':
        case 'sound-attack-succes-champion':
        case 'sound-attack-succes-critique':
          if (cmd.length < 1) {
            error("Il manque le son après --" + cmd[0], cmd);
            return;
          }
          var soundCmd = cmd[0].replace('-a', 'A').replace('-e', 'E').replace('-c', 'C').replace('-n', 'N').replace('-s', 'S').replace('-t', 'T');
          if (soundCmd == 'soundAttackNormalTouch') soundCmd = 'soundAttackSucces';
          if (soundCmd == 'soundAttackChampionSucces') soundCmd = 'soundAttackSuccesChampion';
          options[soundCmd] = cmd.slice(1).join(' ');
          return;
        default:
          error("Argument de !cof-attack '" + arg + "' non reconnu", cmd);
      }
    });
    closeIte(scope); //pour fermer les endif mal formés et éviter les boucles
    options.additionalDmg = options.additionalDmg || [];
    if (options.tempeteDeMana) {
      if (options.tempeteDeMana.cout === 0) {
        //On demande de préciser les options
        var optMana = {
          mana: options.mana,
          rang: options.rang,
          portee: true //Pour avoir l'option
        };
        if (!options.pasDeDmg) optMana.dm = true;
        if (options.effets) {
          options.effets.forEach(function(ef) {
            if (ef.effet) {
              if (estEffetTemp(ef.effet)) {
                optMana.dm = optMana.dm || (ef.message && ef.message.dm);
                optMana.soins = optMana.soins || (ef.message && ef.message.soins);
                optMana.duree = true;
              }
            } else if (estEffetCombat(ef.effet)) {
              optMana.dm = optMana.dm || messageEffetCombat[ef.effet].dm;
              optMana.soins = optMana.soins || messageEffetCombat[ef.effet].soins;
            }
          });
        }
        if (options.peur && options.peur.duree) optMana.duree = true;
        setTempeteDeMana(playerId, attaquant, msg.content, optMana);
        return;
      } else {
        if (options.rang && options.tempeteDeMana.cout > options.rang) {
          sendChar(attaquant.charId, "Attention, le coût de la tempête de mana (" + options.tempeteDeMana.cout + ") est supérieur au rang du sort");
        }
      }
    }
    if (options.tempeteDeManaDuree || options.puissantDuree) {
      if (options.pasDeDmg) {
        if (options.peur && options.peur.duree)
          options.peur.duree = options.peur.duree * 2;
        if (options.effets) {
          options.effets.forEach(function(ef) {
            if (ef.effet && ef.duree && !ef.message.dm && !ef.message.soins) {
              ef.duree = ef.duree * 2;
            }
          });
        }
      } else {
        if (options.tempeteDeManaDuree) {
          sendChar(attaquant.charId, "Attention, l'option tempête de mana pour la durée n'est pas prise en compte. Utiliser l'option --pasDeDmg si le sort ne fait pas de DM");
          options.tempeteDeManaDuree = false;
          if (options.tempeteDeMana && options.tempeteDeMana.cout)
            options.tempeteDeMana.cout--;
          if (options.mana) {
            if (reglesOptionelles.mana.val.mana_totale.val) options.mana -= 3;
            else options.mana--;
          }
        }
      }
    }
    attack(playerId, attaquant, targetToken, weaponStats, options);
  }

  // Fait dépenser de la mana, et si pas possible, retourne false
  function depenseMana(personnage, cout, msg, evt) {
    if (isNaN(cout) || cout === 0) return true;
    var token = personnage.token;
    var charId = personnage.charId;
    var manaAttr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: 'PM'
    }, {
      caseInsensitive: true
    });
    var hasMana = false;
    if (manaAttr.length > 0) {
      var manaMax = parseInt(manaAttr[0].get('max'));
      hasMana = !isNaN(manaMax) && manaMax > 0;
    }
    if (hasMana) {
      var bar2 = parseInt(token.get('bar2_value'));
      if (isNaN(bar2)) {
        if (token.get('bar1_link') === '') bar2 = 0;
        else { //devrait être lié à la mana courante
          sendChar(charId, "*** Attention, la barre de mana du token n'est pas liée à la mana de la fiche ***");
          bar2 = parseInt(manaAttr[0].get('current'));
        }
      }
      msg = msg || '';
      if ((reglesOptionelles.mana.val.contrecoup.val && bar2 <= 0) ||
        (!reglesOptionelles.mana.val.contrecoup.val && !reglesOptionelles.mana.val.brulure_de_magie.val && bar2 < cout)) {
        sendChar(charId, " n'a pas assez de points de mana pour " + msg);
        return false;
      } else if (bar2 < cout && (reglesOptionelles.mana.val.contrecoup.val ||
          reglesOptionelles.mana.val.brulure_de_magie.val)) {
        var degats = cout - bar2;
        if (reglesOptionelles.mana.val.brulure_de_magie.val) {
          var famille = ficheAttribute(personnage, 'famille', 'aventurier').trim();
          if (famille == "combattant") degats *= 2;
        }
        var bar1 = parseInt(token.get('bar1_value'));
        var source = reglesOptionelles.mana.val.brulure_de_magie.val ? "de la Brûlure de Magie" : "du Contrecoup";
        updateCurrentBar(personnage, 2, 0, evt);
        updateCurrentBar(personnage, 1, bar1 - degats, evt);
        var pre = (stateCOF.options.affichage.val.depense_mana.val && bar2 != 0) ? "Dépense " + bar2 + " PM et p" : "P";
        sendChar(charId, pre + "erd " + degats + " PV à cause " + source + " pour " + msg);
      } else {
        if (stateCOF.options.affichage.val.depense_mana.val)
          sendChar(charId, "Dépense " + cout + " PM pour " + msg);
        updateCurrentBar(personnage, 2, bar2 - cout, evt);
        var niveau = ficheAttributeAsInt(personnage, 'niveau', 1);
        if (reglesOptionelles.mana.val.mana_totale.val) {
          if (cout > niveau * 3) {
            sendChar(charId, "Attention, la dépense totale de mana est supérieure au niveau * 3");
          }
        } else {
          if (cout > niveau) {
            sendChar(charId, "Attention, la dépense totale de mana est supérieure au niveau");
          }
        }
      }
      return true;
    }
    sendChar(charId, " n'a pas de points de mana, action impossible");
    return false;
  }

  function parseSave(cmd) {
    if (cmd.length < 3) {
      if (cmd.length > 0)
        error("Usage : --" + cmd[0] + " carac seuil", cmd);
      else
        error("parsing de sauvegarde", cmd);
      return;
    }
    var carac1;
    var carac2;
    if (cmd[1].length == 3) {
      carac1 = cmd[1];
      if (!isCarac(cmd[1])) {
        error("Le premier argument de save n'est pas une caractéristique", cmd);
        return;
      }
    } else if (cmd[1].length == 6) { //Choix parmis 2 caracs
      carac1 = cmd[1].substr(0, 3);
      carac2 = cmd[1].substr(3, 3);
      if (!isCarac(carac1) || !isCarac(carac2)) {
        error("Le premier argument de save n'est pas une caractéristique", cmd);
        return;
      }
    } else {
      error("Le premier argument de save n'est pas une caractéristique", cmd);
      return;
    }
    var res = {
      carac: carac1,
      carac2: carac2,
      seuil: parseInt(cmd[2])
    };
    if (isNaN(res.seuil)) {
      error("Le deuxième argument de --psave n'est pas un nombre", cmd);
      return;
    }
    if (cmd.length > 3) {
      var optArgs = cmd.slice(3).join(' ');
      optArgs = optArgs.split(' +');
      optArgs.forEach(function(oa) {
        oa = oa.trim().split(' ');
        switch (oa[0]) {
          case 'carac':
          case 'carac2':
          case 'seuil':
            error("Argument supplémentaire de save inconnu", cmd);
            return;
          case 'tempete':
            var ti = 1;
            if (oa.length > 1) {
              ti = parseInt(oa[1]);
              if (isNaN(ti)) ti = 1;
            }
            res.tempete = ti;
            return;
          default:
            res[oa[0]] = true;
        }
      });
    }
    return res;
  }

  //Si l'attribut est un mod. de caractéristique, va chercher le
  //bon attribut, selon que perso est un PNJ ou nom
  function valAttribute(perso, originalAttr, caracAttr) {
    if (caracAttr) {
      if (persoEstPNJ(perso)) {
        return 10 + ficheAttributeAsInt(perso, PNJCaracOfMod(originalAttr), 0) * 2;
      }
      return ficheAttributeAsInt(perso, caracAttr, 0);
    }
    return charAttributeAsInt(perso, originalAttr, 0);
  }

  function testCondition(cond, attaquant, cibles, deAttaque, options) {
    if (cond == 'toujoursVrai') return true;
    switch (cond.type) {
      case 'moins':
        // Au cas où on utilise les MOD au lieu de l'attribut de base:
        var caracAttr = caracOfMod(cond.attribute);
        var attackerAttr = valAttribute(attaquant, cond.attribute, caracAttr);
        var resMoins = true;
        cibles.forEach(function(target) {
          if (resMoins) {
            var targetAttr = valAttribute(target, cond.attribute, caracAttr);
            if (targetAttr >= attackerAttr) resMoins = false;
          }
        });
        return resMoins;
      case 'etat':
        return (getState(attaquant, cond.etat));
      case 'etatCible':
        var resEtatCible = true;
        cibles.forEach(function(target) {
          if (resEtatCible && !getState(target, cond.etat))
            resEtatCible = false;
        });
        return resEtatCible;
      case 'attribut':
        return (attributeAsBool(attaquant, cond.attribute));
      case 'attributCible':
        var resAttrCible = true;
        if (cond.valeur === undefined) {
          cibles.forEach(function(target) {
            if (resAttrCible && !attributeAsBool(target, cond.attribute))
              resAttrCible = false;
          });
        } else {
          cibles.forEach(function(target) {
            if (resAttrCible) {
              var attr;
              if (cond.fiche) {
                attr = ficheAttribute(target, cond.attribute, cond.fiche.def);
                if (attr === undefined) {
                  resAttrCible = false;
                  return;
                }
                resAttrCible = (attr + '').toLowerCase() == cond.valeur;
                return;
              }
              if (cond.local) attr = tokenAttribute(target, cond.attribute);
              else attr = charAttribute(target.charId, cond.attribute);
              if (attr.length === 0) {
                resAttrCible = false;
                return;
              }
              resAttrCible = (attr[0].get('current') + '').toLowerCase() == cond.valeur;
            }
          });
        }
        return resAttrCible;
      case 'deAttaque':
        if (options && options.auto) return false;
        if (deAttaque === undefined) {
          error("Condition de dé d'attaque non supportée ici", cond);
          return true;
        }
        return deAttaque >= cond.seuil;
      case 'echecCritique':
        if (deAttaque === undefined) {
          error("Condition de dé d'attaque non supportée ici", cond);
          return true;
        }
        return deAttaque == 1;
      case 'touche':
        return cibles.every(function(target) {
          return target.touche;
        });
      case 'critique':
        return cibles.every(function(target) {
          return target.critique;
        });
      default:
        error("Condition non reconnue", cond);
    }
    return false;
  }

  //On copie les champs de scope dans options ou dans target
  function copyBranchOptions(branch, options, target, evt, explications, condInTarget) {
    var opt = options;
    if (condInTarget) opt = target;
    for (var field in branch) {
      switch (field) {
        case 'ite':
          break;
        case 'additionalDmg':
        case 'additionalCritDmg':
        case 'effets':
        case 'etats':
          opt[field] = opt[field] || [];
          opt[field] = opt[field].concat(branch[field]);
          break;
        case 'sournoise':
        case 'mana':
        case 'bonusAttaque':
        case 'bonusContreBouclier':
          opt[field] = opt[field] || 0;
          opt[field] += branch[field];
          break;
        case 'dmgCoef':
        case 'critCoef':
          if (opt[field] === undefined) {
            if (condInTarget) opt[field] = 0;
            else opt[field] = 1;
          }
          opt[field] += branch[field] - 1;
          break;
        case 'diviseDmg':
          if (opt[field] === undefined) {
            opt[field] = 1;
          }
          opt[field] *= branch[field];
          break;
        case 'messages':
          if (condInTarget)
            target.messages = target.messages.concat(branch.messages);
          else { /*jshint loopfunc: true */
            branch.messages.forEach(function(m) {
              explications.push(m);
            });
          }
          break;
        case 'decrAttribute':
          var attr = getObj('attribute', branch.decrAttribute);
          if (attr === undefined) {
            error("Attribut introuvable", branch.decrAttribute);
            break;
          }
          var oldval = parseInt(attr.get('current'));
          if (isNaN(oldval) || oldval < 1) {
            sendChar(attr.get('characterid'), "ne peut plus faire cela");
            break;
          }
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attr,
            current: oldval,
            max: attr.get('max')
          });
          attr.set('current', oldval - 1);
          break;
        default:
          opt[field] = branch[field];
      }
    }
  }

  function callIfAllDone(etat, callback) {
    etat.aTraiter--;
    while (etat.aTraiter === 0 && etat.parent) {
      etat = etat.parent;
      etat.aTraiter--;
    }
    if (etat.aTraiter === 0) callback();
  }

  //Evaluation récursive des if-then-else
  function evalITE(attaquant, target, deAttaque, options, phase, evt, explications, scope, callback, inTarget, etatParent) {
    etatParent = etatParent || {};
    if (scope.ite === undefined || scope.ite.length < 1) {
      etatParent.aTraiter = 1;
      callIfAllDone(etatParent, callback);
      return;
    }
    etatParent.aTraiter = scope.ite.length;
    scope.ite = scope.ite.filter(function(ite) {
      var condInTarget = inTarget;
      var resCondition;
      if (ite.condition == 'toujoursVrai') resCondition = true;
      switch (ite.condition.type) {
        case 'etat':
        case 'attribut':
          resCondition = testCondition(ite.condition, attaquant, [], deAttaque);
          break;
        case 'deAttaque':
          if (options.auto) {
            resCondition = false;
            break;
          }
          if (deAttaque === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          resCondition = testCondition(ite.condition, attaquant, [], deAttaque);
          break;
        case 'moins':
        case 'etatCible':
        case 'attributCible':
          if (target === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          condInTarget = true;
          resCondition = testCondition(ite.condition, attaquant, [target], deAttaque);
          break;
        case 'critique':
        case 'touche':
          if (target === undefined || target.attaqueCalculee === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          condInTarget = true;
          phase = 0;
          resCondition = testCondition(ite.condition, attaquant, [target], deAttaque);
          break;
        case 'echecCritique':
          if (target === undefined || deAttaque === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          condInTarget = true;
          resCondition = testCondition(ite.condition, attaquant, [target], deAttaque);
          break;
        case 'save':
          if (target === undefined) {
            callIfAllDone(etatParent, callback);
            return true;
          }
          var msgPour = " pour résister à un effet";
          var msgRate = ", " + target.tokName + " rate son jet de sauvegarde";
          var saveOpts = {
            msgPour: msgPour,
            msgRate: msgRate,
            attaquant: attaquant,
            rolls: options.rolls,
            chanceRollId: options.chanceRollId,
            type: ite.condition.typeDmg
          };
          var saveId = condInTarget ? 'ifSave_' + etatParent.aTraiter + '_' + target.token.id :
            'ifSave_' + etatParent.aTraiter + '_' + attaquant.token.id;
          if (phase > 0) { //le save a déjà été résolu
            condInTarget = true;
            resCondition = target.saveResults && target.saveResults[saveId];
            break;
          }
          var expliquer = function(msg) {
            target.messages.push(msg);
          };
          save(ite.condition.saveCond, target, saveId, expliquer, saveOpts, evt,
            function(reussite, rolltext) {
              var branch;
              target.saveResults = target.saveResults || {};
              if (reussite) {
                branch = ite.else;
                target.saveResults[saveId] = true;
              } else {
                branch = ite.then; //on teste si le save est raté
                target.saveResults[saveId] = false;
              }
              if (branch === undefined) {
                callIfAllDone(etatParent, callback);
                return;
              }
              copyBranchOptions(branch, options, target, evt, explications, true);
              var etat = {
                parent: etatParent
              };
              evalITE(attaquant, target, deAttaque, options, 0, evt, explications, branch, callback, condInTarget, etat);
            });
          return true; //on ne fait pas la suite, mais on garde l'ite
        default:
          error("Condition non reconnue", ite.condition);
          resCondition = true;
      }
      var branch;
      if (resCondition) branch = ite.then;
      else branch = ite.else;
      if (branch === undefined) {
        callIfAllDone(etatParent, callback);
        return condInTarget; //On garde l'ite si on dépend de la cible
      }
      //On copie les champs de scope dans options ou dans target
      if (phase === 0)
        copyBranchOptions(branch, options, target, evt, explications, condInTarget);
      var etat = {
        parent: etatParent
      };
      evalITE(attaquant, target, deAttaque, options, phase, evt, explications, branch, callback, condInTarget, etat);
      return condInTarget;
    });
  }

  function removeAllAttributes(name, evt, attrs) {
    if (attrs === undefined) {
      attrs = findObjs({
        _type: 'attribute'
      });
    }
    var attrsNamed = allAttributesNamed(attrs, name);
    if (attrsNamed.length === 0) return attrs;
    if (evt.deletedAttributes === undefined) evt.deletedAttributes = [];
    attrsNamed.forEach(function(attr) {
      evt.deletedAttributes.push(attr);
      attr.remove();
    });
    attrs = attrs.filter(function(attr) {
      var ind = attrsNamed.findIndex(function(nattr) {
        return nattr.id == attr.id;
      });
      return (ind == -1);
    });
    return attrs;
  }

  function onGenre(perso, male, female) {
    var sex = ficheAttribute(perso, 'sexe', '');
    if (sex.startsWith('F')) return female;
    return male;
  }

  function messageActivation(perso, message) {
    if (message.activationF) return onGenre(perso, message.activation, message.activationF);
    return message.activation;
  }

  function getValeurOfEffet(perso, effet, def, attrDef) {
    var attrsVal = tokenAttribute(perso, effet + 'Valeur');
    if (attrsVal.length === 0) {
      if (attrDef) return charAttributeAsInt(perso, attrDef, def);
      return def;
    }
    var res = parseInt(attrsVal[0].get('current'));
    if (isNaN(res)) return def;
    return res;
  }

  function getValeurStringOfEffet(perso, effet, def, attrDef) {
    var attrsVal = tokenAttribute(perso, effet + 'Valeur');
    if (attrsVal.length === 0) {
      if (attrDef) {
        var attr = charAttribute(perso, attrDef);
        if (attr.length === 0) return def;
        return attr[0].get('current');
      }
      return def;
    }
    return attrsVal[0].get('current');
  }

  // renvoie la valeur du bonus si il y a un capitaine (ou commandant)
  //evt est optionnel
  function aUnCapitaine(cible, evt, pageId) {
    var charId = cible.charId;
    var attrs = findObjs({
      _type: 'attribute',
      _characterid: charId,
    });
    var attrCapitaine = attrs.find(function(a) {
      return (a.get('name') == 'capitaine');
    });
    if (attrCapitaine === undefined) return false;
    if (pageId === undefined) {
      pageId = cible.token.get('pageid');
    }
    var capitaine = persoOfIdName(attrCapitaine.get('current'), pageId);
    if (evt && capitaine === undefined) {
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attrCapitaine);
      attrCapitaine.remove();
    }
    var capitaineActif = attrs.find(function(a) {
      return (a.get('name') == 'capitaineActif');
    });
    if (capitaine && isActive(capitaine)) {
      if (capitaineActif || !evt) return attrCapitaine.get('max');
      setTokenAttr(cible, 'capitaineActif', true, evt, {
        charAttr: true
      });
      iterSelected(tokensEnCombat(), function(perso) {
        if (perso.charId == charId) updateInit(perso.token, evt);
      });
      return attrCapitaine.get('max');
    }
    if (capitaineActif && evt) {
      removeCharAttr(cible.charId, 'capitaineActif', evt);
      iterSelected(tokensEnCombat(), function(perso) {
        if (perso.charId == charId) updateInit(perso.token, evt);
      });
    }
    return false;
  }

  //ne rajoute pas evt à l'historique
  function persoInit(perso, evt) {
    var initDerivee = charAttribute(perso.charId, 'initiativeDeriveeDe');
    if (initDerivee.length > 0) {
      var charDerive = findObjs({
        _type: 'character',
        name: initDerivee[0].get('current')
      });
      if (charDerive.length > 0) {
        var persoD = {
          charId: charDerive[0].id,
          token: perso.token
        };
        return persoInit(persoD, evt);
      }
    }
    var persoMonte = tokenAttribute(perso, 'estMontePar');
    if (persoMonte.length > 0) {
      var cavalier = persoOfId(persoMonte[0].get('current'), persoMonte[0].get('max'), perso.token.get('pageid'));
      if (cavalier !== undefined) return persoInit(cavalier, evt);
    }
    var init;
    if (persoEstPNJ(perso)) {
      init = ficheAttributeAsInt(perso, 'pnj_init', 10);
    } else {
      init = ficheAttributeAsInt(perso, 'dexterite', 10);
      init += ficheAttributeAsInt(perso, 'INIT_DIV', 0);
      if (stateCOF.setting_arran || stateCOF.setting_mixte)
        init += ficheAttributeAsInt(perso, 'mod_initiative', 0);
    }
    if (attributeAsBool(perso, 'formeDArbre')) init = 7;
    //Règle optionelle : +1d6, à lancer en entrant en combat
    if (reglesOptionelles.initiative.val.initiative_variable.val) {
      var bonusVariable;
      var tokenAUtiliser;
      if (reglesOptionelles.initiative.val.initiative_variable_individuelle.val) { // Un jet par perso mook
        bonusVariable = attributeAsInt(perso, 'bonusInitVariable', 0);
        tokenAUtiliser = perso;
      } else { //Un seul pour tous les mook du même personnage
        bonusVariable = charAttributeAsInt(perso, 'bonusInitVariable', 0);
        tokenAUtiliser = {
          charId: perso.charId
        };
      }
      if (bonusVariable === 0) {
        var rollD6 = rollDePlus(6, {
          deExplosif: true
        });
        bonusVariable = rollD6.val;
        var msg = "entre en combat. ";
        msg += onGenre(perso, 'Il', 'Elle') + " fait " + rollD6.roll;
        msg += " à son jet d'initiative";
        setTokenAttr(tokenAUtiliser, 'bonusInitVariable', bonusVariable, evt, {
          msg: msg
        });
      }
      init += bonusVariable;
    }
    if (getState(perso, 'aveugle')) init -= 5;
    // Voie du compagnon animal rang 2 (surveillance)
    init += attributeAsInt(perso, 'bonusInitEmbuscade', 0);
    // Familier
    if (familier(perso)) init += 2;
    // Sixième sens en sort
    if (attributeAsBool(perso, 'sixiemeSens')) init += 2;
    // Voie du chef d'armée rangs 2 et 3 (Capitaine)
    var bonusCapitaine = aUnCapitaine(perso, evt);
    if (bonusCapitaine) init += parseInt(bonusCapitaine);
    if (charAttributeAsBool(perso, 'graceFeline')) {
      init += modCarac(perso, 'charisme');
    }
    if (attributeAsBool(perso, 'masqueDuPredateur')) {
      init += getValeurOfEffet(perso, 'masqueDuPredateur', modCarac(perso, 'sagesse'));
    }
    if (charAttributeAsBool(perso, 'controleDuMetabolisme')) {
      init += getValeurOfEffet(perso, 'controleDuMetabolisme', modCarac(perso, 'charisme'));
    }
    if (attributeAsBool(perso, 'cadavreAnime')) {
      init -= 2;
    }
    // Voie du pistolero rang 1 (plus vite que son ombre)
    var armeEnMain = tokenAttribute(perso, 'armeEnMain');
    if (armeEnMain.length > 0) {
      var armeL = armeEnMain[0].get('current');
      if (charAttributeAsInt(perso, "charge_" + armeL, 0) > 0) {
        init += charAttributeAsInt(perso, 'initEnMain' + armeL, 0);
      }
    }
    // Réflexes felins de la Voie du pourfendeur
    init += charAttributeAsInt(perso, 'reflexesFelins', 0);
    if (attributeAsBool(perso, 'foretVivanteEnnemie')) {
      init -= 5;
    }
    return init;
  }

  //ne rajoute pas evt à l'historique
  //options: recompute : si pas encore agi, on remet à sa place dans le turn order
  function initiative(selected, evt, recompute) { //set initiative for selected tokens
    // Always called when entering combat mode
    // set the initiative counter, if not yet set
    // Assumption: all tokens that have not acted yet are those before the turn
    // counter.
    // When initiative for token not present, assumes it has not acted
    // When present, stays in same group, but update position according to
    // current initiative.
    // Tokens appearing before the turn are sorted
    if (!Campaign().get('initiativepage')) evt.initiativepage = false;
    if (!stateCOF.combat) { //actions de début de combat
      evt.combat = false;
      evt.combat_pageid = stateCOF.combat_pageid;
      stateCOF.combat = true;
      Campaign().set({
        turnorder: JSON.stringify([{
          id: "-1",
          pr: 1,
          custom: "Tour",
          formula: "+1"
        }]),
        initiativepage: true
      });
      evt.tour = stateCOF.tour;
      stateCOF.tour = 1;
      evt.init = stateCOF.init;
      stateCOF.init = 1000;
      removeAllAttributes('transeDeGuérison', evt);
    }
    if (!Campaign().get('initiativepage')) {
      Campaign().set('initiativepage', true);
    }
    var to = getTurnOrder(evt);
    if (to.pasAgi.length === 0) { // Fin de tour, on met le tour à la fin et on retrie
      to.pasAgi = to.dejaAgi;
      to.dejaAgi = [];
    }
    iterSelected(selected, function(perso) {
      stateCOF.combat_pageid = perso.token.get('pageid');
      if (!isActive(perso)) return;
      var init = persoInit(perso, evt);
      // On place le token à sa place dans la liste du tour
      var dejaIndex =
        to.dejaAgi.findIndex(function(elt) {
          return (elt.id == perso.token.id);
        });
      if (dejaIndex == -1) { //Le personnage doit encore agir
        var push = true;
        to.pasAgi =
          to.pasAgi.filter(function(elt) {
            if (elt.id == perso.token.id) {
              if (recompute) return false; //On enlève le perso des pasAgi
              push = false; //Sinon, comme on ne recalcule pas, on le laisse
              return true;
            }
            return true;
          });
        if (push) {
          if (init >= stateCOF.init) { //On ne peut pas remonter le temps.
            init = stateCOF.init - 1;
            updateNextInit(perso);
          }
          to.pasAgi.push({
            id: perso.token.id,
            pr: init,
            custom: ''
          });
        }
      } else {
        to.dejaAgi[dejaIndex].pr = init;
      }
    });
    setTurnOrder(to, evt);
  }

  function initPerso(personnage, evt, recompute) {
    initiative([{
      _id: personnage.token.id
    }], evt, recompute);
  }

  // triggers sheet workers
  //options peut avoir un champ msg et un champ maxVal
  function setFicheAttr(personnage, attribute, value, evt, options) {
    var charId = personnage.charId;
    if (options && options.msg !== undefined) {
      sendChar(charId, options.msg);
    }
    evt.attributes = evt.attributes || [];
    var attr = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: attribute
    }, {
      caseInsensitive: true
    });
    if (attr.length === 0) {
      var maxval = '';
      if (options && options.maxVal !== undefined) maxval = options.maxVal;
      attr = createObj('attribute', {
        characterid: charId,
        name: attribute,
        current: value,
        max: maxval
      });
      attr.setWithWorker({
        current: value
      });
      evt.attributes.push({
        attribute: attr,
        current: null
      });
      return attr;
    }
    attr = attr[0];
    evt.attributes.push({
      attribute: attr,
      current: attr.get('current'),
      max: attr.get('max'),
      withWorker: true
    });
    var nv = {
      current: value
    };
    if (options && options.maxVal !== undefined) nv.max = options.maxVal;
    attr.setWithWorker(nv);
    return attr;
  }

  // bonus d'attaque d'un token, indépendament des options
  // Mise en commun pour attack et attaque-magique
  function bonusDAttaque(personnage, explications, evt) {
    explications = explications || [];
    var tempAttkMod; // Utilise la barre 3 de l'attaquant
    tempAttkMod = parseInt(personnage.token.get("bar3_value"));
    if (tempAttkMod === undefined || isNaN(tempAttkMod) || tempAttkMod === "") {
      tempAttkMod = 0;
    }
    var attBonus = tempAttkMod;
    var fortifie = attributeAsInt(personnage, 'fortifie', 0);
    if (fortifie > 0) {
      attBonus += 3;
      fortifie--;
      explications.push("Effet du fortifiant => +3 en Attaque. Il sera encore actif pour " + fortifie + " tests");
      if (fortifie === 0) {
        removeTokenAttr(personnage, 'fortifie', evt);
      } else {
        setTokenAttr(personnage, 'fortifie', fortifie, evt);
      }
    }
    attBonus += charAttributeAsInt(personnage, 'actionConcertee', 0);
    if (attributeAsBool(personnage, 'chantDesHeros')) {
      var bonusChantDesHeros = getValeurOfEffet(personnage, 'chantDesHeros', 1);
      var chantDesHerosIntense = attributeAsInt(personnage, 'chantDesHerosTempeteDeManaIntense', 0);
      bonusChantDesHeros += chantDesHerosIntense;
      attBonus += bonusChantDesHeros;
      explications.push("Chant des héros => +" + bonusChantDesHeros + " en Attaque");
      if (chantDesHerosIntense)
        removeTokenAttr(personnage, 'chantDesHerosTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'benediction')) {
      var bonusBenediction = getValeurOfEffet(personnage, 'benediction', 1);
      var benedictionIntense = attributeAsInt(personnage, 'benedictionTempeteDeManaIntense', 0);
      bonusBenediction += benedictionIntense;
      attBonus += bonusBenediction;
      explications.push("Bénédiction => +" + bonusBenediction + " en Attaque");
      if (benedictionIntense)
        removeTokenAttr(personnage, 'benedictionTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'lameDeLigneePerdue')) {
      attBonus -= 1;
      explications.push("Lame de lignée perdue => -1 en Attaque");
    }
    if (attributeAsBool(personnage, 'strangulation')) {
      var malusStrangulation =
        1 + attributeAsInt(personnage, 'dureeStrangulation', 0);
      attBonus -= malusStrangulation;
      explications.push("L'attaquant est étranglé => -" + malusStrangulation + " en Attaque");
    }
    if (getState(personnage, 'renverse')) {
      attBonus -= 5;
      explications.push("Attaquant à terre => -5 en Attaque");
    }
    var attrPosture = tokenAttribute(personnage, 'postureDeCombat');
    if (attrPosture.length > 0) {
      attrPosture = attrPosture[0];
      var posture = attrPosture.get('max');
      var postureVal;
      if (posture.startsWith('ATT')) {
        postureVal = parseInt(attrPosture.get('current'));
        attBonus -= postureVal;
        explications.push("Posture de combat => -" + postureVal + " en Attaque");
      } else if (posture.endsWith('ATT')) {
        postureVal = parseInt(attrPosture.get('current'));
        attBonus += postureVal;
        explications.push("Posture de combat => +" + postureVal + " en Attaque");
      }
    }
    if (attributeAsBool(personnage, 'danseIrresistible')) {
      attBonus -= 4;
      explications.push("En train de danser => -4 en Attaque");
    }
    if (attributeAsBool(personnage, 'cadavreAnime')) {
      attBonus -= 4;
      explications.push("Cadavre animé => -2 en Attaque");
    }
    var bonusCapitaine = aUnCapitaine(personnage, evt);
    if (bonusCapitaine) {
      attBonus += parseInt(bonusCapitaine);
      var msgCapitaine = "Un ";
      if (bonusCapitaine > 2) msgCapitaine += "commandant";
      else msgCapitaine += "capitaine";
      msgCapitaine += " donne des ordres => +" + bonusCapitaine + " en Attaque et aux DMs";
      personnage.bonusCapitaine = bonusCapitaine;
      explications.push(msgCapitaine);
    }
    if (attributeAsBool(personnage, 'forceDeGeant')) {
      var bonusForceDeGeant = getValeurOfEffet(personnage, 'forceDeGeant', 2);
      attBonus += bonusForceDeGeant;
      explications.push("Force de géant => +" + bonusForceDeGeant + " en Attaque");
    }
    if (attributeAsBool(personnage, 'nueeDInsectes')) {
      var malusNuee =
        2 + attributeAsInt(personnage, 'nueeDInsectesTempeteDeManaIntense', 0);
      attBonus -= malusNuee;
      explications.push("Nuée d’insectes => -" + malusNuee + " en Attaque");
      if (malusNuee > 2)
        removeTokenAttr(personnage, 'nueeDInsectesTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'nueeDeCriquets')) {
      var malusNueeCriquets =
        3 + attributeAsInt(personnage, 'nueeDeCriquetsTempeteDeManaIntense', 0);
      attBonus -= malusNueeCriquets;
      explications.push("Nuée de criquets => -" + malusNueeCriquets + " en Attaque");
      if (malusNueeCriquets > 3)
        removeTokenAttr(personnage, 'nueeDeCriquetsTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'etatExsangue')) {
      attBonus -= 2;
      explications.push("Exsangue => -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'armeBrulante')) {
      attBonus -= 2;
      explications.push("Arme brûlante => -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'marcheSylvestre')) {
      attBonus += 2;
      explications.push("Marche sylvestre : +2 en Attaque");
    }
    if (attributeAsBool(personnage, 'prisonVegetale')) {
      attBonus -= getValeurOfEffet(personnage, 'prisonVegetale', 2);
      explications.push("Prison végétale : -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'toiles')) {
      attBonus -= getValeurOfEffet(personnage, 'toiles', 2);
      explications.push("Entravé : -2 en Attaque");
    }
    if (attributeAsBool(personnage, 'masqueDuPredateur')) {
      var bonusMasque = getValeurOfEffet(personnage, 'masqueDuPredateur', modCarac(personnage, 'sagesse'));
      var masqueIntense = attributeAsInt(personnage, 'masqueDuPredateurTempeteDeManaIntense', 0);
      bonusMasque += masqueIntense;
      attBonus += bonusMasque;
      explications.push("Masque du prédateur : +" + bonusMasque + " en Attaque et DM");
      if (masqueIntense)
        removeTokenAttr(personnage, 'masqueDuPredateurTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(personnage, 'armeSecreteBarde')) {
      attBonus -= 10;
      explications.push("Déstabilisé par une action de charme => -10 en Attaque");
    }
    return attBonus;
  }

  function rollNumber(s) {
    return parseInt(s.substring(3, s.indexOf(']')));
  }

  function surveillance(personnage) {
    var surveillance = findObjs({
      _type: 'attribute',
      _characterid: personnage.charId,
      name: 'surveillance'
    });
    if (surveillance.length > 0) {
      var compagnon = surveillance[0].get('current');
      var compToken = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: personnage.token.get('pageid'),
        layer: 'objects',
        name: compagnon
      });
      var compagnonPresent = false;
      compToken.forEach(function(tok) {
        var compCharId = tok.get('represents');
        if (compCharId === '') return;
        compagnon = {
          token: tok,
          charId: compCharId
        };
        compagnonPresent = !getState(compagnon, 'mort') && !getState(compagnon, 'assome') &&
          !getState(compagnon, 'etourdi') && !getState(compagnon, 'endormi') &&
          !getState(compagnon, 'apeure') && !getState(compagnon, 'paralyse');
      });
      return compagnonPresent;
    }
    return false;
  }

  function familier(personnage) {
    var familier = findObjs({
      _type: 'attribute',
      _characterid: personnage.charId,
      name: 'familier'
    });
    if (familier.length > 0) {
      var compagnon = familier[0].get('current');
      var compToken = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: personnage.token.get('pageid'),
        layer: 'objects',
        name: compagnon
      });
      var compagnonPresent = false;
      compToken.forEach(function(tok) {
        var compCharId = tok.get('represents');
        if (compCharId === '') return;
        if (isActive({
            token: tok,
            charId: compCharId
          })) compagnonPresent = true;
      });
      return compagnonPresent;
    }
    return false;
  }

  //Remplis les champs arme et armeGauche de perso
  //renvoie undefined si aucune arme en main principale
  //renvoie l'arme principale sinon
  function armesEnMain(perso) {
    if (perso.armesEnMain) return perso.arme;
    var labelArme = tokenAttribute(perso, 'armeEnMain');
    if (labelArme.length > 0) {
      var labelArmePrincipale = labelArme[0].get('current');
      if (labelArmePrincipale) perso.arme = getWeaponStats(perso, labelArmePrincipale);
      var labelArmeGauche = labelArme[0].get('max');
      if (labelArmeGauche) perso.armeGauche = getWeaponStats(perso, labelArmeGauche);
      perso.armesEnMain = 'calculee';
      return perso.arme;
    }
    return;
  }

  //evt est optionnel
  function defenseOfPerso(attaquant, target, pageId, evt, options) {
    options = options || {};
    if (options.difficultePVmax) {
      var pvmax = parseInt(target.token.get('bar1_max'));
      if (isNaN(pvmax)) {
        error("Points de vie de " + target.token.get('name') + " mal formés",
          target.token.get('bar1_max'));
        return 0;
      }
      return pvmax;
    } else if (options.difficultePV) {
      var pv = parseInt(target.token.get('bar1_value'));
      if (isNaN(pv)) {
        error("Points de vie de " + target.token.get('name') + " mal formés",
          target.token.get('bar1_value'));
        return 0;
      }
      return pv;
    }
    var defDerivee = charAttribute(target.charId, 'defDeriveeDe');
    if (defDerivee.length > 0) {
      var charDerive = findObjs({
        _type: 'character',
        name: defDerivee[0].get('current')
      });
      if (charDerive.length > 0) {
        target.realCharId = target.charId;
        target.charId = charDerive[0].id;
      }
    }
    target.tokName = target.tokName || target.token.get('name');
    var tokenName = target.tokName;
    var explications = target.messages || [];
    var defense = 10;
    if (persoEstPNJ(target)) {
      defense = ficheAttributeAsInt(target, 'pnj_def', 10);
    } else {
      if (target.defautCuirasse === undefined) {
        defense += ficheAttributeAsInt(target, 'DEFARMURE', 0) * ficheAttributeAsInt(target, 'DEFARMUREON', 1);
        defense += ficheAttributeAsInt(target, 'DEFBOUCLIER', 0) * ficheAttributeAsInt(target, 'DEFBOUCLIERON', 1);
        if (attributeAsBool(target, 'armureDuMage')) {
          var bonusArmureDuMage = getValeurOfEffet(target, 'armureDuMage', 4);
          if (defense > 12) defense += bonusArmureDuMage / 2; // On a déjà une armure physique, ça ne se cumule pas.
          else defense += bonusArmureDuMage;
        }
        if (attributeAsBool(target, 'armureDEau')) {
          var bonusArmureDEau = getValeurOfEffet(target, 'armureDEau', 2);
          defense += bonusArmureDEau;
          explications.push("Armure d'eau : +" + bonusArmureDEau + " en DEF");
        }
        defense += ficheAttributeAsInt(target, 'DEFDIV', 0);
      } // Dans le cas contraire, on n'utilise pas ces bonus
      defense += modCarac(target, 'dexterite');
    }
    if (attributeAsBool(target, 'inconfort')) {
      var inconfortValeur = attributeAsInt(target, "inconfortValeur", 0);
      defense -= inconfortValeur;
      explications.push("L'adversaire est gêné par son armure : -" + inconfortValeur + " en DEF");
    }
    var formeDarbre;
    if (attributeAsBool(target, 'formeDArbre')) {
      formeDarbre = true;
      defense = 13;
    }
    if (attributeAsBool(target, 'statueDeBois')) defense = 10;
    // Malus de défense global pour les longs combats
    if (reglesOptionelles.haute_DEF.val.usure_DEF.val && !stateCOF.usureOff && stateCOF.tour > 1)
      defense -= (Math.floor((stateCOF.tour - 1) / reglesOptionelles.haute_DEF.val.usure_DEF.val) * 2);
    // Autres modificateurs de défense
    defense += attributeAsInt(target, 'defenseTotale', 0);
    defense += attributeAsInt(target, 'pacifisme', 0);
    if (attributeAsBool(target, 'aspectDuDemon')) {
      defense += getValeurOfEffet(target, 'aspectDuDemon', 2);
    }
    if (attributeAsBool(target, 'peauDEcorce')) {
      var bonusPeau = getValeurOfEffet(target, 'peauDEcorce', 1, 'voieDesVegetaux');
      var peauIntense = attributeAsInt(target, 'peauDEcorceTempeteDeManaIntense', 0);
      bonusPeau += peauIntense;
      if (reglesOptionelles.divers.val.forme_d_arbre_amelioree.val && formeDarbre) {
        bonusPeau = Math.ceil(bonusPeau * 1.5);
      }
      defense += bonusPeau;
      explications.push("Peau d'écorce : +" + bonusPeau + " en DEF");
      if (peauIntense && evt && !options.test)
        removeTokenAttr(target, 'peauDEcorceTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(target, 'champDeProtection')) {
      var bonusChamp = getValeurOfEffet(target, 'champDeProtection', 2, 'voieDeleTelekinesie');
      var champIntense = attributeAsInt(target, 'champDeProtectionTempeteDeManaIntense', 0);
      bonusChamp += champIntense;
      defense += bonusChamp;
      explications.push("Champ de protection : +" + bonusChamp + " en DEF");
      if (champIntense && evt && !options.test)
        removeTokenAttr(target, 'champDeProtectionTempeteDeManaIntense', evt);
    }
    if (attributeAsBool(target, 'mutationCuirasse')) {
      var bonusMutation = getValeurOfEffet(target, 'mutationCuirasse', 2, 'voieDesMutations');
      defense += bonusMutation;
      explications.push("Cuirasse : +" + bonusMutation + " en DEF");
    }
    if (attributeAsBool(target, 'sixiemeSens')) {
      defense += 2;
      explications.push("Sixième sens : +2 DEF");
    }
    if (getState(target, 'surpris')) defense -= 5;
    if (getState(target, 'renverse')) defense -= 5;
    if (getState(target, 'aveugle') || attributeAsBool(target, 'aveugleManoeuvre')) {
      if (options.distance || !charAttributeAsBool(target, 'radarMental') || (attaquant && estNonVivant(attaquant)))
        defense -= 5;
    }
    if (getState(target, 'etourdi') || attributeAsBool(target, 'peurEtourdi'))
      defense -= 5;
    if (getState(target, 'invisible') && attaquant && !attributeAsBool(attaquant, 'detectionDeLInvisible')) {
      if (options.distance) {
        if (charAttributeAsBool(attaquant, 'tirAveugle') || options.tirAveugle) {
          explications.push("Cible invisible, mais " + attaquant.tokName + " sait tirer à l'aveugle");
        } else {
          defense += 10;
          explications.push("Invisible : +10 en DEF");
        }
      } else {
        defense += 5;
        explications.push("Invisible : +5 en DEF");
      }
    }
    defense += attributeAsInt(target, 'bufDEF', 0);
    defense += attributeAsInt(target, 'actionConcertee', 0);
    if (ficheAttributeAsInt(target, 'DEFARMUREON', 1) === 0) {
      defense += charAttributeAsInt(target, 'vetementsSacres', 0);
      defense += charAttributeAsInt(target, 'armureDeVent', 0);
      if (!options.distance)
        defense += charAttributeAsInt(target, 'dentellesEtRapiere', 0);
    }
    defense += charAttributeAsInt(target, 'esquiveVoleur', 0);
    if (charAttributeAsBool(target, 'graceFeline')) {
      defense += modCarac(target, 'charisme');
    }
    if (charAttributeAsBool(target, 'peauDePierre')) {
      defense += modCarac(target, 'constitution');
    }
    if (charAttributeAsBool(target, 'defenseIntuitive')) {
      defense += modCarac(target, 'sagesse');
    }
    if (attributeAsBool(target, 'armeSecreteBarde')) {
      explications.push(tokenName + " est déstabilisé par une action de charme => -10 en DEF");
      defense -= 10;
    }
    if (options.metal && attributeAsBool(target, 'magnetisme')) {
      var magnetisme = getValeurOfEffet(target, 'magnetisme', 5);
      defense += magnetisme;
      explications.push(tokenName + " contrôle le magnétisme (+" + magnetisme + " DEF)");
    }
    if (attributeAsBool(target, 'diversionManoeuvre')) {
      var diversion = getValeurOfEffet(target, 'diversionManoeuvre', -5);
      defense += diversion;
      explications.push(tokenName + " est victime d'une diversion => " + diversion + " DEF");
    }
    if (options.attaqueMentale && charAttributeAsBool(target, 'bouclierPsi')) {
      defense += 5;
      explications.push(tokenName + " bénéficie d'un bouclier psi => +5 DEF");
    }
    if (attributeAsBool(target, 'monteSur') && charAttributeAsBool(target, 'montureLoyale')) {
      defense += 1;
      explications.push(tokenName + " est sur une monture => +1 DEF");
    }
    var attrsProtegePar = findObjs({
      _type: 'attribute',
      _characterid: target.charId,
    });
    attrsProtegePar.forEach(function(attr) {
      var attrName = attr.get('name');
      if (attrName.startsWith('protegePar_')) {
        var nameProtecteur = attr.get('max');
        if (attr.get('bar1_link') === '') {
          if (attrName != 'protegePar_' + nameProtecteur + '_' + tokenName) return;
        } else if (attrName != 'protegePar_' + nameProtecteur) return;
        var protecteur = persoOfId(attr.get('current'), nameProtecteur, pageId);
        if (protecteur === undefined) {
          if (evt) removeTokenAttr(target, 'protegePar_' + nameProtecteur, evt);
          sendChar(target.charId, "ne peut pas être protégé par " + nameProtecteur + " car aucun token le représentant n'est sur la page");
          return;
        }
        if (!isActive(protecteur)) {
          explications.push(nameProtecteur + " n'est pas en état de protéger " +
            tokenName);
          return;
        }
        var distTargetProtecteur = distanceCombat(target.token, protecteur.token, pageId);
        if (distTargetProtecteur > 0) {
          explications.push(nameProtecteur + " est trop loin de " +
            tokenName + " pour le protéger");
          return;
        }
        if (ficheAttributeAsInt(protecteur, 'DEFBOUCLIERON', 1) === 0) {
          var sujet = onGenre(protecteur, 'il', 'elle');
          explications.push(nameProtecteur +
            " ne porte pas son bouclier, " + sujet + " ne peut pas proteger " +
            tokenName);
          return;
        }
        var defBouclierProtecteur = ficheAttributeAsInt(protecteur, 'DEFBOUCLIER', 0);
        defense += defBouclierProtecteur;
        explications.push(nameProtecteur + " protège " +
          tokenName + " de son bouclier (+" + defBouclierProtecteur + "DEF)");
      }
    });
    var attrPosture = tokenAttribute(target, 'postureDeCombat');
    if (attrPosture.length > 0) {
      attrPosture = attrPosture[0];
      var posture = attrPosture.get('max');
      var postureVal;
      if (posture.startsWith('DEF')) {
        postureVal = parseInt(attrPosture.get('current'));
        defense -= postureVal;
        explications.push("Posture de combat => -" + postureVal + " DEF");
      } else if (posture.endsWith('DEF')) {
        postureVal = parseInt(attrPosture.get('current'));
        defense += postureVal;
        explications.push("Posture de combat => +" + postureVal + " DEF");
      }
    }
    var instinctSurvie = charAttributeAsInt(target, 'instinctDeSurvie', 0);
    if (instinctSurvie > 0 && target.token.get('bar1_value') <= instinctSurvie)
      defense += 5;
    if (attributeAsBool(target, 'danseIrresistible')) {
      defense -= 4;
      explications.push("En train de danser => -4 DEF");
    }
    if (options.sortilege)
      defense += charAttributeAsInt(target, 'DEF_magie', 0);
    if (attributeAsBool(target, 'marcheSylvestre')) {
      defense += 2;
      explications.push("Marche sylvestre => +2 DEF");
    }
    if (attributeAsBool(target, 'prisonVegetale')) {
      defense -= getValeurOfEffet(target, 'prisonVegetale', 2);
      explications.push("Prison végétale => -2 DEF");
    }
    if (attributeAsBool(target, 'toiles')) {
      defense -= getValeurOfEffet(target, 'toiles', 2);
      explications.push("Entravé => -2 DEF");
    }
    if (attributeAsBool(target, 'protectionContreLeMal') &&
      (attaquant && estMauvais(attaquant))) {
      var bonusProtectionContreLeMal = getValeurOfEffet(target, 'protectionContreLeMal', 2);
      defense += bonusProtectionContreLeMal;
      explications.push("Protection contre le mal => +" + bonusProtectionContreLeMal + " DEF");
    }
    var rageBerserk = tokenAttribute(target, 'rageDuBerserk');
    if (rageBerserk.length > 0) {
      rageBerserk = rageBerserk[0].get('current');
      if (rageBerserk == 'furie') {
        defense -= 6;
        explications.push("Furie du berserk => -6 DEF");
      } else {
        defense -= 4;
        explications.push("Rage du berserk => -4 DEF");
      }
    }
    var combatEnPhalange = charAttributeAsBool(target, 'combatEnPhalange');
    if (combatEnPhalange || attributeAsBool(target, 'esquiveFatale')) {
      var tokensContact = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        layer: 'objects'
      });
      tokensContact = tokensContact.filter(function(tok) {
        if (tok.id == target.token.id) return false;
        return distanceCombat(target.token, tok, pageId) === 0;
      });
      var tokensAllies = [];
      var tokensEnnemis = [];
      var allies = alliesParPerso[target.charId] || new Set();
      tokensContact.forEach(function(tok) {
        var ci = tok.get('represents');
        if (ci === '') return; //next token au contact
        if (!isActive({
            token: tok,
            charId: ci
          })) return;
        if (allies.has(ci)) tokensAllies.push(tok);
        else tokensEnnemis.push(tok);
      });
      target.ennemisAuContact = tokensEnnemis;
      if (combatEnPhalange) {
        var defensePhalange = 0;
        tokensEnnemis.forEach(function(tokE) {
          var alliesAuContact = tokensAllies.filter(function(tokA) {
            return distanceCombat(tokE, tokA, pageId) === 0;
          });
          if (alliesAuContact.length > defensePhalange)
            defensePhalange = alliesAuContact.length;
        });
        if (defensePhalange > 0) {
          defense += defensePhalange;
          explications.push("Combat en phalange => +" + defensePhalange + " DEF");
        }
      }
    }
    if (attributeAsBool(target, 'attaqueRisquee')) {
      defense -= 4;
      explications.push("Suite à une attaque risquée, -4 en DEF");
    }
    //gestion de l'épieu
    var armeTarget = armesEnMain(target); //peuple target.arme et armeGauche
    if (armeTarget) {
      if (armeTarget.name.search(/[ée]pieu/i) >= 0 || (armeTarget.divers && armeTarget.name.search(/[ée]pieu/i) >= 0)) {
        var armeAttaquant = tokenAttribute(attaquant, 'armeEnMain');
        if (armeAttaquant.length === 0) {
          defense += 2;
          explications.push("Épieu contre une attaque sans arme => +2 DEF");
        }
      }
    }
    if (options.distance) {
      var bonusCouvert = attributeAsInt(target, 'bonusCouvert');
      if (bonusCouvert) {
        defense += bonusCouvert;
        explications.push("Cible à couvert => +" + bonusCouvert + " DEF");
      }
      if (attributeAsBool(target, 'progresserACouvert')) {
        defense += 5;
        explications.push("Cible à couvert de bouclier => +5 DEF");
      }
    } else {
      if (charAttributeAsBool(target, 'ambidextreDuelliste')) {
        if (target.armeGauche && target.armeGauche.portee === 0) {
          defense += 1;
          explications.push("La cible utilise son arme en main gauche => +1 DEF");
        }
      }
    }
    //Chair à canon
    if (attributeAsInt(target, 'chairACanon', -1) >= 0) {
      if (target.tokName === undefined) target.tokName = target.get('name');
      var tokensChairACanon = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        layer: 'objects'
      });
      target.chairACanon = tokensChairACanon.filter(function(tok) {
        if (tok.id == target.token.id) return false;
        var tokCharId = tok.get('represents');
        if (tokCharId === '') return false;
        if (distanceCombat(target.token, tok, pageId) > 3) return false;
        var pChair = {
          token: tok,
          charId: tokCharId,
        };
        if (getState(pChair, 'mort')) return;
        var tokAttrs = charAttribute(tokCharId, 'chairACanonDe');
        var estChair = tokAttrs.find(function(a) {
          var chairACanonDe = a.get('current').split(",");
          return chairACanonDe.find(function(b) {
            return b.trim() == target.tokName;
          });
        });
        return estChair;
      });
      if (target.chairACanon.length > 0) {
        defense += 5;
        explications.push(target.chairACanon[0].get('name') + " aide " + target.tokName + "! => +5 DEF");
      }
    }
    var bonusCapitaine = aUnCapitaine(target, evt, pageId);
    if (bonusCapitaine && bonusCapitaine > 2) {
      defense += parseInt(bonusCapitaine);
      explications.push(target.tokName + " suit les ordres de son commandant => +" + bonusCapitaine + " en DEF");
    }
    if (attaquant && charAttributeAsBool(target, 'reduireLaDistance')) {
      switch (taillePersonnage(attaquant, 4)) {
        case 5:
          defense += 2;
          explications.push(target.tokName + " réduit la distance => +2 en DEF");
          break;
        case 6:
          defense += 3;
          explications.push(target.tokName + " réduit la distance => +3 en DEF");
          break;
        case 7:
          defense += 4;
          explications.push(target.tokName + " réduit la distance => +4 en DEF");
      }
    }
    if (attributeAsBool(target, 'etreinteImmole')) {
      defense -= 5;
      explications.push(target.tokName + " étreint quelqu'un => -5 en DEF");
    }
    if (attaquant && charAttributeAsBool(target, 'langageSombreHetre') && estElfeNoir(attaquant)) {
      defense += 1;
      explications.push(target.tokName + " comprend le langage sombre => +1 en DEF");
    }
    if (attributeAsBool(target, 'presenceGlaciale')) {
      var defenseGlaciale = getValeurOfEffet(target, 'presenceGlaciale', 4);
      explications.push("Présence glaciale => +" + defenseGlaciale + " en DEF");
      defense += defenseGlaciale;
    }
    if (attributeAsBool(target, 'cyclone')) {
      explications.push("Cyclone => +5 en DEF");
      defense += 5;
    }
    if (options.pacteSanglantDef && options.pacteSanglantDef[target.token.id]) {
      explications.push("Pacte Sanglant => +" + options.pacteSanglantDef[target.token.id] + " en DEF");
      defense += options.pacteSanglantDef[target.token.id];
    }
    var defArme = charAttributeAsInt(target, 'armeBonusDef', 0);
    if (defArme > 0) {
      explications.push("Arme de parade en main => +" + defArme + " en DEF");
      defense += defArme;
    }
    defArme = charAttributeAsInt(target, 'armeGaucheBonusDef', 0);
    if (defArme > 0) {
      explications.push("Arme de parade en main gauche => +" + defArme + " en DEF");
      defense += defArme;
    }
    if (target.realCharId) target.charId = target.realCharId;
    return defense;
  }

  // renvoie l'attribut créé ou mis à jour
  function setAttrDuree(perso, attr, duree, evt, msg) {
    var options = {
      maxVal: getInit(),
    };
    if (msg) options.msg = msg;
    return setTokenAttr(perso, attr, duree, evt, options);
  }
  //Bonus en Attaque qui ne dépendent pas du défenseur
  //attaquant doit avoir un champ tokName
  function bonusAttaqueA(attaquant, weaponName, evt, explications, options) {
    var attBonus = 0;
    if (options.bonusAttaque) attBonus += options.bonusAttaque;
    attBonus += bonusDAttaque(attaquant, explications, evt);
    if (options.tirDouble) {
      attBonus += 2;
      if (options.tirDouble.stats && options.tirDouble.stats.name) {
        explications.push(attaquant.tokName + " tire avec " +
          weaponName + " et " + options.tirDouble.stats.name + " à la fois !");
      } else {
        explications.push(attaquant.tokName + " tire avec 2 " +
          weaponName + "s à la fois !");
      }
    }
    if (options.chance) {
      attBonus += options.chance;
      var pc = options.chance / 10;
      explications.push(pc + " point" + ((pc > 1) ? "s" : "") + " de chance dépensé => +" + options.chance + " en Attaque");
    }
    if (options.semonce) {
      attBonus += 5;
    }
    if (!options.pasDeDmg) {
      if (ficheAttributeAsBool(attaquant, 'attaque_en_puissance_check')) {
        options.attaqueEnPuissance = ficheAttributeAsInt(attaquant, 'attaque_en_puissance', 1);
      }
      if (!options.auto && options.attaqueEnPuissance) {
        attBonus -= 5 * options.attaqueEnPuissance;
        explications.push("Attaque en puissance => -" + (5 * options.attaqueEnPuissance) + " en Attaque et +" + options.attaqueEnPuissance + options.d6 + " DM");
      }
      if (ficheAttributeAsBool(attaquant, 'attaque_assuree_check')) {
        options.attaqueAssuree = true;
      }
      if (options.attaqueAssuree) {
        attBonus += 5;
        explications.push("Attaque assurée => +5 en Attaque et DM/2");
      }
      if (ficheAttributeAsBool(attaquant, 'attaque_dm_temp_check')) {
        options.attaqueDmTemp = true;
      }
      if (options.attaqueDmTemp && !options.tempDmg && !options.sortilege && (options.contact || !options.percant)) {
        options.tempDmg = true;
        if (!options.choc) {
          attBonus -= 2;
          explications.push("Attaque pour assomer => -2 en Attaque");
        }
      }
    }
    if (attaquant.pnj && options.attaqueDeGroupe === undefined) {
      options.attaqueDeGroupe = ficheAttributeAsInt(attaquant, 'attaque_de_groupe', 1);
    }
    if (options.attaqueDeGroupe > 1) {
      var bonusTouche = reglesOptionelles.haute_DEF.val.bonus_attaque_groupe.val * (options.attaqueDeGroupe - 1);
      attBonus += bonusTouche;
      explications.push("Attaque en groupe => +" + bonusTouche + " en Attaque");
    }
    if (attributeAsBool(attaquant, 'criDuPredateur')) {
      attBonus += 1;
      explications.push("Cri du prédateur => +1 en attaque");
    }
    if (attributeAsBool(attaquant, 'baroudHonneurActif')) {
      attBonus += 5;
      explications.push(attaquant.tokName + " porte une dernière attaque et s'effondre");
      mort(attaquant, function(m) {
        explications.push(m);
      }, evt);
      removeTokenAttr(attaquant, 'baroudHonneurActif', evt);
    }
    if (options.sortilege && attributeAsBool(attaquant, 'zoneDeSilence')) {
      attBonus -= 2;
      explications.push("Zone de silence => -2 en Attaque Magique");
    }
    if (attributeAsBool(attaquant, 'inconfort')) {
      var inconfortValeur = attributeAsInt(attaquant, 'inconfortValeur', 0);
      attBonus -= inconfortValeur;
      explications.push("Gêne due à l'armure : -" + inconfortValeur);
    }
    if (attributeAsBool(attaquant, 'monteSur')) {
      if (!options.distance) {
        var cavalierEm = charAttributeAsInt(attaquant, 'cavalierEmerite');
        if (cavalierEm) {
          attBonus += cavalierEm;
          var explCavalierEmerite = "avalier émérite => +" + cavalierEm + " en Attaque";
          if (options.displayName) {
            explCavalierEmerite = attaquant.tokName + " est un c" + explCavalierEmerite;
          } else {
            explCavalierEmerite = 'C' + explCavalierEmerite;
          }
          explications.push(explCavalierEmerite);
        }
      }
      if (charAttributeAsBool(attaquant, 'montureLoyale')) {
        attBonus += 1;
        explications.push("Monture loyale => +1 en Attaque");
      }
    }
    if (options.frappeDuVide) {
      attBonus += 2;
      if (options.pasDeDmg)
        explications.push("Frappe du vide => +2 en Attaque");
      else
        explications.push("Frappe du vide => +2 en Attaque et +1d6 DM");
    }
    if (attributeAsBool(attaquant, 'putrefactionOutreTombe')) {
      attBonus -= 2;
      explications.push("Putréfaction => -2 en Attaque");
    }
    if (options.contact) {
      if (attributeAsBool(attaquant, 'rayonAffaiblissant')) {
        options.rayonAffaiblissant = getValeurOfEffet(attaquant, 'rayonAffaiblissant', 2);
        if (options.rayonAffaiblissant < 0) options.rayonAffaiblissant = 1;
        attBonus -= options.rayonAffaiblissant;
        var msgRA = "Rayon affaiblissant => -" + options.rayonAffaiblissant + " en Attaque";
        if (options.pasDeDmg) explications.push(msgRA);
        else explications.push(msgRA + " et aux DM");
      }
      if (attributeAsBool(attaquant, 'enragé')) {
        attBonus += 5;
        if (options.pasDeDmg)
          explications.push("Enragé => +5 en Attaque");
        else
          explications.push("Enragé => +5 en Attaque et +1d6 DM");
      }
      if (attributeAsBool(attaquant, 'aspectDuDemon')) {
        attBonus += getValeurOfEffet(attaquant, 'aspectDuDemon', 2);
        explications.push("Aspect de démon => +2 en Attaque");
      }
      var rageBerserk = tokenAttribute(attaquant, 'rageDuBerserk');
      if (rageBerserk.length > 0) {
        rageBerserk = rageBerserk[0].get('current');
        if (rageBerserk == 'furie') {
          attBonus += 3;
          if (options.pasDeDmg)
            explications.push("Furie du berserk : +3 en Attaque");
          else
            explications.push("Furie du berserk : +3 en Attaque et +2d6 aux DM");
          options.rageBerserk = 2;
        } else {
          attBonus += 2;
          if (options.pasDeDmg)
            explications.push("Rage du berserk : +2 en Attaque");
          else
            explications.push("Rage du berserk : +2 en Attaque et +1d6 aux DM");
          options.rageBerserk = 1;
        }
      }
      if (ficheAttributeAsBool(attaquant, 'attaque_risquee_check')) {
        options.attaqueRisquee = true;
      }
      if (options.attaqueRisquee) {
        attBonus += 2;
        explications.push("Attaque risquée => +2 en Attaque");
        if (!options.test) {
          setAttrDuree(attaquant, 'attaqueRisquee', 1, evt);
        }
      }
      if (charAttributeAsBool(attaquant, 'ambidextreDuelliste')) {
        if (attaquant.armesEnMain === undefined) armesEnMain(attaquant);
        if (attaquant.armeGauche && attaquant.armeGauche.portee === 0) {
          var bonusArmeGauche = 0;
          if (attaquant.pnj) {
            bonusArmeGauche = attaquant.armeGauche.attSkill;
          } else {
            bonusArmeGauche = attaquant.armeGauche.attSkillDiv;
          }
          var dmArmeGauche = modCarac(attaquant, 'dexterite');
          dmArmeGauche += attaquant.armeGauche.attDMBonusCommun;
          var typeDMGauche = 'normal';
          switch (attaquant.armeGauche.typeDegats) {
            case 'feu':
            case 'froid':
            case 'acide':
            case 'electrique':
            case 'sonique':
            case 'poison':
            case 'maladie':
            case 'magique':
              typeDMGauche = attaquant.armeGauche.typeDegats;
          }
          if (typeDMGauche == 'normal' && attaquant.armeGauche.modificateurs &&
            attaquant.armeGauche.modificateurs.includes("magique")) {
            typeDMGauche = 'magique';
          }
          attaquant.additionalDmg = attaquant.additionalDmg || [];
          attaquant.additionalDmg.push({
            type: typeDMGauche,
            value: dmArmeGauche
          });
          attBonus += bonusArmeGauche;
          var msgAmbidextre = "Attaque ambidextre => +";
          if (bonusArmeGauche) {
            msgAmbidextre += bonusArmeGauche + " en attaque";
            if (options.pasDeDmg) explications.push(msgAmbidextre);
            else msgAmbidextre += " et +";
          }
          if (!options.pasDeDmg)
            explications.push(msgAmbidextre + dmArmeGauche + " aux DMs");
        }
      }
    }
    var frenesie = charAttributeAsInt(attaquant, 'frenesie', 0);
    var pv;
    if (frenesie > 0) {
      pv = parseInt(attaquant.token.get('bar1_value'));
      if (pv <= frenesie) {
        attBonus += 2;
        explications.push("Frénésie => +2 en Attaque");
      }
    }
    if (charAttributeAsBool(attaquant, 'hausserLeTon')) {
      if (pv === undefined)
        pv = parseInt(attaquant.token.get('bar1_value'));
      if (pv <= parseInt(attaquant.token.get('bar1_max') / 2)) {
        attBonus += 5;
        var msgHausserLeTon = "Hausse le ton => +5 en Attaque";
        if (!options.pasDeDmg) {
          msgHausserLeTon += " et +1d6 DM";
          attaquant.additionalDmg = attaquant.additionalDmg || [];
          attaquant.additionalDmg.push({
            type: options.type || 'normal',
            value: '1d6'
          });
        }
        explications.push(msgHausserLeTon);
      }
    }
    if (options.lamesJumelles) {
      var force = modCarac(attaquant, 'force');
      if (force < 2) {
        attBonus += force - 2;
        explications.push("Lames jumelles => " + (force - 2) + " en Attaque");
      }
    }
    if (attributeAsBool(attaquant, 'bonusAttaqueTemp')) {
      var bonusTemp = getValeurOfEffet(attaquant, 'bonusAttaqueTemp', 5);
      attBonus += bonusTemp;
      explications.push("Bonus d'attaque temporaire de " + bonusTemp);
    }
    if (stateCOF.chargeFantastique &&
      stateCOF.chargeFantastique.tokenAttaque == attaquant.token.id) {
      attBonus += 3;
      var msgCharge = "Charge fantastique => +3 en Attaque";
      if (!options.pasDeDmg) {
        msgCharge += " et +1d6 DM";
        attaquant.additionalDmg = attaquant.additionalDmg || [];
        attaquant.additionalDmg.push({
          type: options.type || 'normal',
          value: '1d6'
        });
      }
      explications.push(msgCharge);
    }
    if (attributeAsBool(attaquant, 'enerve')) {
      attBonus -= 2;
      explications.push("Attaquant énervé => -2 en Attaque");
    }
    return attBonus;
  }

  //Bonus d'attaque qui dépendent de la cible
  // si options.aoe, target doit avoir un champ tokName
  function bonusAttaqueD(attaquant, target, portee, pageId, evt, explications, options) {
    var attackingCharId = attaquant.charId;
    attaquant.tokName = attaquant.tokName || attaquant.token.get('name');
    var attBonus = 0;
    if (target.bonusAttaque) attBonus += target.bonusAttaque;
    if (getState(attaquant, 'aveugle')) {
      if (options.distance) {
        if (charAttributeAsBool(attaquant, 'tirAveugle') || options.tirAveugle) {
          explications.push("Attaquant aveuglé, mais il sait tirer à l'aveugle");
        } else {
          attBonus -= 10;
          explications.push("Attaquant aveuglé => -10 en Attaque à distance");
        }
      } else {
        if (!charAttributeAsBool(attaquant, 'radarMental') || estNonVivant(target)) {
          attBonus -= 5;
          explications.push("Attaquant aveuglé => -5 en Attaque");
        }
      }
    } else if (attributeAsBool(attaquant, 'aveugleManoeuvre')) {
      if (options.distance || !charAttributeAsBool(attaquant, 'radarMental') || estNonVivant(target)) {
        attBonus -= 5;
        options.aveugleManoeuvre = true;
        if (options.pasDeDmg)
          explications.push("Attaquant aveuglé => -5 en Attaque");
        else
          explications.push("Attaquant aveuglé => -5 en Attaque et aux DM");
      }
    } else if (getState(attaquant, 'invisible') && !attributeAsBool(target, 'detectionDeLInvisible')) {
      attBonus += 5;
      explications.push("Attaque venant d'un personnage invisible => +5 en Attaque");
    } else if (options.distance && getState(attaquant, 'penombre')) {
      if (options.tirAveugle) {
        explications.push("Attaquant dans la pénombre, mais il sait tirer à l'aveugle");
      } else {
        attBonus -= 5;
        explications.push("Attaquant dans la pénombre => -5 en Attaque à distance");
      }
    }
    if (options.mainsDEnergie) {
      if (options.aoe) error("Mains d'énergie n'est pas compatible avec les AOE", options.aoe);
      // On vérifie si la cible porte une armure
      var targetArmorDef = 0;
      if (persoEstPNJ(target)) {
        if (ficheAttributeAsBool(target, 'DEFARMUREON', false)) targetArmorDef = 5;
      } else {
        targetArmorDef = parseInt(getAttrByName(target.charId, "DEFARMURE"));
      }
      if (isNaN(targetArmorDef) || targetArmorDef === 0) {
        attBonus += 2;
        explications.push("Mains d'énergie => +2 en Attaque (cible sans armure)");
      } else {
        var bonusMain = Math.min(5, 2 + targetArmorDef);
        attBonus += bonusMain;
        explications.push("Mains d'énergie => +" + bonusMain + " en Attaque");
      }
    }
    if (options.aoe === undefined && options.auto === undefined && portee > 0) {
      attBonus -=
        malusDistance(attaquant, target.token, target.distance, portee, pageId,
          explications, options.ignoreObstacles);
    }
    var chasseurEmerite =
      charAttributeAsBool(attaquant, 'chasseurEmerite') && estAnimal(target);
    if (chasseurEmerite) {
      attBonus += 2;
      var explChasseurEmerite = "hasseur émérite => +2 en Attaque";
      if (options.displayName) {
        explChasseurEmerite = attaquant.tokName + ' est un c' + explChasseurEmerite;
      } else {
        explChasseurEmerite = 'C' + explChasseurEmerite;
      }
      if (!options.pasDeDmg) explChasseurEmerite += " et aux DM";
      if (options.aoe) explChasseurEmerite += " contre " + target.tokName;
      explications.push(explChasseurEmerite);
      target.chasseurEmerite = true;
    }
    var ennemiJureAttr = findObjs({
      _type: 'attribute',
      _characterid: attackingCharId,
      name: 'ennemiJure'
    });
    var ennemiJure = false;
    if (ennemiJureAttr.length != 0) {
      var races = ennemiJureAttr[0].get('current');
      races.split(",").forEach(function(race) {
        race = race.trim();
        if (race === '') return;
        if (race == 'mort-vivant') {
          if (estMortVivant(target)) ennemiJure = true;
        } else if (raceIs(target, race)) ennemiJure = true;
      });
    }
    if (ennemiJure) {
      var ejSag = modCarac(attaquant, 'sagesse');
      attBonus += ejSag;
      var explEnnemiJure = "Attaque sur ennemi juré => +" + ejSag + " en attaque";
      if (!options.pasDeDmg) explEnnemiJure += " et +1d6 aux DM";
      if (options.aoe) explEnnemiJure += " contre " + target.tokName;
      explications.push(explEnnemiJure);
      target.ennemiJure = true;
    }
    if (options.armeDArgent) {
      if (estMortVivant(target) || raceIs(target, 'demon') || raceIs(target, 'démon')) {
        attBonus += 2;
        if (options.pasDeDmg)
          explications.push("Arme en argent => +2 en attaque");
        else
          explications.push("Arme en argent => +2 en attaque et +1d6 aux DM");
        target.armeDArgent = true;
      }
    }
    var bonusContreBouclier = options.bonusContreBouclier || 0;
    if (target.bonusContreBouclier) bonusContreBouclier += target.bonusContreBouclier;
    if (bonusContreBouclier) {
      if (ficheAttributeAsInt(target, 'DEFBOUCLIERON', 1) &&
        ficheAttributeAsInt(target, 'DEFBOUCLIER', 0) > 0) {
        attBonus += bonusContreBouclier;
        explications.push("L'adversaire porte un bouclier => " + ((bonusContreBouclier > 0) ? '+' : '') + bonusContreBouclier + " en attaque");
      }
    }
    if (options.tueurDeGeants && estUnGeant(target)) {
      attBonus += 2;
      if (options.pasDeDmg)
        explications.push("Tueur de géant => +2 en Attaque");
      else
        explications.push("Tueur de géant => +2 att. et 2d6 DM");
      target.tueurDeGeants = true;
    }
    var attrFeinte = tokenAttribute(target, 'feinte_' + attaquant.tokName);
    if (attrFeinte.length > 0 && attrFeinte[0].get('current')) {
      var bonusFeinte = charAttributeAsInt(attaquant, 'bonusFeinte', 5);
      attBonus += bonusFeinte;
      var msgFeinte = "Feinte => +" + bonusFeinte + " en attaque";
      if (attrFeinte[0].get('max')) {
        target.feinte = 2;
        if (!options.pasDeDmg) msgFeinte += " et +2d6 DM";
      }
      explications.push(msgFeinte);
    }
    if (attributeAsBool(target, 'expose')) {
      var attrsExposeValeur = tokenAttribute(target, "exposeValeur");
      var expose = false;
      attrsExposeValeur.forEach(function testExpose(attr) {
        if (attr.get("current") == attaquant.token.id) expose = true;
      });
      if (expose) {
        attBonus += 10;
        explications.push("L'adversaire est exposé : +10");
      }
    }
    if (options.contact) {
      if ((attributeAsBool(target, 'criDeGuerre') ||
          attributeAsBool(target, 'criDuPredateur')) &&
        ficheAttributeAsInt(attaquant, 'force', 10) <= ficheAttributeAsInt(target, 'force', 10) &&
        parseInt(attaquant.token.get("bar1_max")) <= parseInt(target.token.get("bar1_max"))) {
        attBonus -= 2;
        explications.push("Effrayé => -2 en Attaque");
      }
    }
    var attrAgrippe = tokenAttribute(attaquant, 'agrippe');
    attrAgrippe.forEach(function(a) {
      var cibleAgrippee = persoOfIdName(a.get('current'), pageId);
      if (cibleAgrippee && cibleAgrippee.id == target.id) {
        attBonus += 5;
        if (options.pasDeDmg)
          explications.push("Cible agrippée => +5 em Attaque");
        else
          explications.push("Cible agrippée => +5 att. et 1d6 DM");
        target.estAgrippee = true;
      }
    });
    if (reglesOptionelles.divers.val.interchangeable_attaque.val) {
      if (interchangeable(target.token, attaquant, pageId).result) {
        attBonus += 3;
        explications.push("Attaque en meute => +3 en Attaque et +2 en DEF");
      }
    }
    if (charAttributeAsBool(attaquant, 'combatEnPhalange')) {
      var tokensContact = findObjs({
        _type: 'graphic',
        _subtype: 'token',
        _pageid: pageId,
        layer: 'objects'
      });
      //On compte tokens au contact de l'attaquant et du défenseur et alliés de l'attaquant
      var allies = alliesParPerso[attaquant.charId];
      if (allies) {
        var alliesAuContact = 0;
        tokensContact.forEach(function(tok) {
          if (tok.id == attaquant.token.id) return;
          if (distanceCombat(target.token, tok, pageId) > 0) return;
          if (distanceCombat(attaquant.token, tok, pageId) > 0) return;
          var ci = tok.get('represents');
          if (ci === '') return;
          if (!isActive({
              token: tok,
              charId: ci
            })) return;
          if (allies.has(ci)) alliesAuContact++;
        });
        if (alliesAuContact > 0) {
          attBonus += alliesAuContact;
          explications.push("Combat en phalange => +" + alliesAuContact + " en Attaque");
        }
      }
    }
    if (options.attaqueEnMeute) {
      var attaqueParMeute = tokenAttribute(target, 'attaqueParMeute');
      if (attaqueParMeute.length > 0) {
        attaqueParMeute = attaqueParMeute[0];
        var attaqueParMeuteCur = attaqueParMeute.get('current');
        var contientAttaquant;
        var autreAttaquant;
        attaqueParMeuteCur.split(' ').forEach(function(mi) {
          if (mi == attaquant.token.id) {
            contientAttaquant = true;
            return;
          }
          autreAttaquant = true;
        });
        if (autreAttaquant) {
          attBonus += options.attaqueEnMeute;
          explications.push("Attaque en meute => +" + options.attaqueEnMeute + " pour toucher");
        }
        if (!contientAttaquant) {
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attaqueParMeute,
            current: attaqueParMeuteCur
          });
          if (attaqueParMeuteCur === '') attaqueParMeuteCur = attaquant.token.id;
          else attaqueParMeuteCur += ' ' + attaquant.token.id;
          attaqueParMeute.set('current', attaqueParMeuteCur);
        }
      } else {
        setTokenAttr(target, 'attaqueParMeute', attaquant.token.id, evt);
      }
    }
    return attBonus;
  }

  function diminueMalediction(lanceur, evt, attr) {
    var attrMalediction = attr || tokenAttribute(lanceur, 'malediction');
    if (attrMalediction.length > 0) {
      attrMalediction = attrMalediction[0];
      var nbMaudit = parseInt(attrMalediction.get('current'));
      if (isNaN(nbMaudit) || nbMaudit < 2) {
        evt.deletedAttributes = evt.deletedAttributes || [];
        evt.deletedAttributes.push(attrMalediction);
        attrMalediction.remove();
      } else {
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attrMalediction,
          current: nbMaudit
        });
        attrMalediction.set('current', nbMaudit - 1);
      }
    }
  }

  function attributesOfClass(perso, classeEffet) {
    var attrs = findObjs({
      _type: 'attribute',
      _characterid: perso.charId
    });
    var res = [];
    attrs.forEach(function(attr) {
      var attrName = attr.get('name');
      var ice = attrName.indexOf('ClasseEffet');
      if (ice < 1) return;
      if (attr.get('current') == classeEffet) {
        var baseAttrName = attrName.replace(/ClasseEffet/, '');
        var baseAttr = attrs.find(function(a) {
          return (a.get('name') == baseAttrName);
        });
        if (baseAttr === undefined) {
          error("On a un attribut " + attrName + ", mais pas d'attribut " + baseAttrName + " pour " + perso.token.get('name'), classeEffet);
          attr.remove();
          return;
        }
        res.push({
          baseAttribute: baseAttr,
          classAttribute: attr
        });
      }
    });
    if (res.length === 0) {
      var ace = tokenAttribute(perso, classeEffet);
      if (ace.length > 0) {
        error(perso.token.get('name') + " a une classe d'effets " + classeEffet + " mais pas d'effet associé", ace);
        ace[0].remove();
      }
    }
    return res;
  }

  //Retourne true si il existe une limite qui empêche de lancer le sort
  //N'ajoute pas l'événement à l'historique
  function limiteRessources(personnage, options, defResource, msg, evt) {
    if (options.mana) {
      if (personnage) {
        if (!depenseMana(personnage, options.mana, msg, evt)) {
          return true;
        }
      } else {
        error("Impossible de savoir qui doit dépenser de la mana", options);
        return true;
      }
    }
    var expliquer = sendChar;
    if (options.secret) expliquer = whisperChar;
    var ressource = '';
    if (defResource !== undefined) ressource = defResource;
    var utilisations;
    if (options.limiteParJour) {
      if (personnage) {
        if (options.limiteParJourRessource)
          ressource = options.limiteParJourRessource;
        ressource = "limiteParJour_" + ressource;
        utilisations =
          attributeAsInt(personnage, ressource, options.limiteParJour);
        if (utilisations === 0) {
          expliquer(personnage.charId, "ne peut plus faire cette action aujourd'hui");
          return true;
        }
        setTokenAttr(personnage, ressource, utilisations - 1, evt);
      } else {
        error("Impossible de savoir à qui appliquer la limite journalière", options);
        return true;
      }
    }
    if (options.limiteParCombat) {
      if (personnage) {
        if (!stateCOF.combat) {
          expliquer(personnage.charId, "ne peut pas faire cette action en dehors des combats");
          return true;
        }
        if (options.limiteParCombatRessource)
          ressource = options.limiteParCombatRessource;
        ressource = "limiteParCombat_" + ressource;
        utilisations =
          attributeAsInt(personnage, ressource, options.limiteParCombat);
        if (utilisations === 0) {
          var msgToSend = msg || "ne peut plus faire cette action pour ce combat";
          expliquer(personnage.charId, msgToSend);
          return true;
        }
        setTokenAttr(personnage, ressource, utilisations - 1, evt);
      } else {
        error("Impossible de savoir à qui appliquer la limite par combat", options);
        return true;
      }
    }
    if (options.dose) {
      if (personnage) {
        var nomDose = options.dose.replace(/_/g, ' ');
        var doses = attributeAsInt(personnage, 'dose_' + options.dose, 0);
        if (doses === 0) {
          expliquer(personnage.charId, "n'a plus de " + nomDose);
          return true;
        }
        setTokenAttr(personnage, 'dose_' + options.dose, doses - 1, evt);
      } else {
        error("Impossible de savoir qui doit dépenser la dose", options);
        return true;
      }
    }
    if (options.limiteAttribut) {
      if (personnage) {
        var nomAttr = options.limiteAttribut.nom;
        var currentAttr = attributeAsInt(personnage, nomAttr, 0);
        if (currentAttr >= options.limiteAttribut.limite) {
          expliquer(personnage.charId, options.limiteAttribut.message);
          return true;
        }
        setTokenAttr(personnage, nomAttr, currentAttr + 1, evt);
      } else {
        error("Impossible de savoir à qui appliquer la limitation", options);
        return true;
      }
    }
    if (options.decrAttribute) {
      var attr = getObj('attribute', options.decrAttribute);
      if (attr === undefined) {
        error("Attribut introuvable", options.decrAttribute);
        return true;
      }
      var oldval = parseInt(attr.get('current'));
      if (isNaN(oldval) || oldval < 1) {
        expliquer(attr.get('characterid'), "ne peut plus faire cela");
        return true;
      }
      evt.attributes = evt.attributes || [];
      evt.attributes.push({
        attribute: attr,
        current: oldval,
        max: attr.get('max')
      });
      attr.set('current', oldval - 1);
    }
    return false;
  }

  //asynchrone
  //callback(resultat, crit, roll1, roll2):
  // resultat peut être 0, 1 ou 2 : 0 = match null, 1 le perso 1 gagne, 2 le perso 2 gagne.
  // crit peut être 1 si un des deux perso a fait une réussite critique et pas l'autre, -1 si un des personnage a fait un échec critique et pas l'autre, et 0 sinon
  function testOppose(rollId, perso1, carac1, options1, perso2, carac2, options2, explications, evt, callback) {
    if (carac2 === undefined) carac2 = carac1;
    var nom1 = perso1.token.get('name');
    var nom2 = perso2.token.get('name');
    jetCaracteristique(perso1, carac1, options1, rollId + "_roll1", evt, function(rt1, expl1) {
      jetCaracteristique(perso2, carac2, options2, rollId + "_roll2", evt, function(rt2, expl2) {
        var reussite;
        var crit = 0;
        if (rt1.total > rt2.total) reussite = 1;
        else if (rt2.total > rt1.total) reussite = 2;
        else reussite = 0;
        if (rt1.echecCritique) {
          if (!rt2.echecCritique) {
            reussite = 2;
            crit = -1;
          }
        } else if (rt2.echecCritique) {
          reussite = 1;
          crit = -1;
        } else if (rt1.critique) {
          if (!rt2.critique) {
            reussite = 1;
            crit = 1;
          }
        } else if (rt2.critique) {
          reussite = 2;
          crit = 1;
        }
        switch (reussite) {
          case 1:
            diminueMalediction(perso2, evt);
            break;
          case 2:
            diminueMalediction(perso1, evt);
            break;
        }
        var texte1 = "Jet de " + carac1 + " de " + nom1 + " : " + rt1.texte;
        if (reussite == 2) {
          if ((carac1 == 'FOR' || carac1 == 'DEX' || carac1 == 'CON') &&
            attributeAsBool(perso1, 'runeForgesort_énergie') &&
            attributeAsInt(perso1, 'limiteParCombat_runeForgesort_énergie', 1) > 0) {
            texte1 += "<br/>" + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + rollId + "_roll1", "Rune d'énergie");
          }
          if (!rt1.echecCritique && !rt2.critique) {
            var pcPerso1 = pointsDeChance(perso1);
            if (pcPerso1 > 0)
              texte1 += "<br/>" + boutonSimple("!cof-bouton-chance " +
                evt.id + " " + rollId + "_roll1", "Chance") + " (reste " + pcPerso1 + " PC)";
            if (stateCOF.combat && attributeAsBool(perso1, 'prouesse') &&
              (carac1 == 'FOR' || carac1 == 'DEX')) {
              texte1 += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + rollId + "_roll1", "Prouesse");
            }
            if (attributeAsBool(perso1, 'tourDeForce') && carac1 == 'FOR') {
              texte1 += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + rollId + "_roll1", "Tour de force");
            }
            if (attributeAsInt(perso1, 'pacteSanglant', 0) >= 3) {
              texte1 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + rollId + "_roll1", "Pacte sanglant (+3)");
            }
            if (attributeAsInt(perso1, 'pacteSanglant', 0) >= 5) {
              texte1 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + rollId + "_roll1", "Pacte sanglant (+5)");
            }
          }
        }
        explications.push(texte1);
        expl1.forEach(function(m) {
          explications.push(m);
        });
        var texte2 = "Jet de " + carac2 + " de " + nom2 + " : " + rt2.texte;
        if (reussite == 1) {
          if ((carac2 == 'FOR' || carac2 == 'DEX' || carac2 == 'CON') &&
            attributeAsBool(perso2, 'runeForgesort_énergie') &&
            attributeAsInt(perso2, 'limiteParCombat_runeForgesort_énergie', 1) > 0) {
            texte2 += "<br/>" + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + rollId + "_roll2", "Rune d'énergie");
          }
          if (!rt2.echecCritique && !rt1.critique) {
            var pcPerso2 = pointsDeChance(perso2);
            if (pcPerso2 > 0)
              texte2 += "<br/>" + boutonSimple("!cof-bouton-chance " +
                evt.id + " " + rollId + "_roll2", "Chance") + " (reste " + pcPerso2 + " PC)";
            if (stateCOF.combat && attributeAsBool(perso2, 'prouesse') &&
              (carac2 == 'FOR' || carac2 == 'DEX')) {
              texte2 += '<br/>' + boutonSimple("!cof-prouesse " + evt.id + " " + rollId + "_roll2", "Prouesse");
            }
            if (attributeAsBool(perso2, 'tourDeForce') && carac2 == 'FOR') {
              texte2 += '<br/>' + boutonSimple("!cof-tour-force " + evt.id + " " + rollId + "_roll2", "Tour de force");
            }
            if (attributeAsInt(perso2, 'pacteSanglant', 0) >= 3) {
              texte2 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 " + rollId + "_roll2", "Pacte sanglant (+3)");
            }
            if (attributeAsInt(perso2, 'pacteSanglant', 0) >= 5) {
              texte2 += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 " + rollId + "_roll2", "Pacte sanglant (+5)");
            }
          }
        }
        explications.push(texte2);
        expl2.forEach(function(m) {
          explications.push(m);
        });
        callback(reussite, crit, rt1.roll, rt2.roll);
      }); //Fin du jet du deuxième perso
    }); //Fin du jet du premier perso
  }

  //targetToken est soit un token, soit une structure avec un champs cibles qui contient toutes les cibles
  function attack(playerId, attaquant, targetToken, weaponStats, options) {
    // Attacker and target infos
    var attackingToken = attaquant.token;
    var attackingCharId = attaquant.charId;
    attaquant.tokName = attaquant.tokName || attaquant.token.get("name");
    var attacker = getObj("character", attackingCharId);
    if (attacker === undefined) {
      error("Unexpected undefined 1", attacker);
      return;
    }
    attaquant.name = attaquant.name || attacker.get("name");
    var pageId = attaquant.token.get('pageid');
    var weaponName = options.nom || weaponStats.name;
    //Options automatically set by some attributes
    if (attributeAsBool(attaquant, 'paralysieRoublard')) {
      if (attributeAsBool(attaquant, 'enragé')) {
        sendChar(attackingCharId, "est trop enragé pour sentir la douleur");
      } else if (charAttributeAsBool(attaquant, 'proprioception')) {
        sendChar(attackingCharId, "est immunisé à la douleur");
      } else {
        sendChar(attackingCharId, "ne peut pas attaquer car il est paralysé de douleur");
        return;
      }
    }
    if (!options.redo && charAttributeAsBool(attaquant, 'fauchage')) {
      var seuilDeFauchage = charAttributeAsInt(attaquant, 'fauchage', 15);
      var seuilFauchage = 10 + modCarac(attaquant, 'force');
      options.etats = options.etats || [];
      options.etats.push({
        etat: 'renverse',
        condition: {
          type: 'deAttaque',
          seuil: seuilDeFauchage
        },
        save: {
          carac: 'FOR',
          carac2: 'DEX',
          seuil: seuilFauchage,
          fauchage: taillePersonnage(attaquant, 4)
        }
      });
    }
    if (options.toucher !== undefined) {
      weaponStats.attSkill = options.toucher;
      weaponStats.attSkillDiv = 0;
    }
    if (options.crit !== undefined) {
      weaponStats.crit = options.crit;
    }
    if (options.dm) {
      weaponStats.attNbDices = options.dm.nbDe;
      weaponStats.attDice = options.dm.dice;
      weaponStats.attDMBonusCommun = options.dm.bonus;
    }
    if (options.portee !== undefined) {
      weaponStats.portee = options.portee;
    }
    if (options.modifiePortee) {
      weaponStats.portee += options.modifiePortee;
    }
    if (!options.epieu && weaponName.search(/[ée]pieu/i) >= 0) {
      options.epieu = true;
    }
    weaponStats.attSkillDiv = parseInt(weaponStats.attSkillDiv);
    weaponStats.attNbDices = parseInt(weaponStats.attNbDices);
    weaponStats.attDice = parseInt(weaponStats.attDice);
    options.d6 = 'd6';
    if (charAttributeAsBool(attaquant, 'tropPetit')) {
      options.d6 = 'd4';
      if (weaponStats.divers && weaponStats.divers.includes('d3')) {
        weaponStats.attDice = 3;
      }
    }
    weaponStats.attDMBonusCommun = parseInt(weaponStats.attDMBonusCommun);
    weaponStats.crit = parseInt(weaponStats.crit);
    var portee = weaponStats.portee;
    if (options.tirDouble && options.tirDouble.label) {
      var stats2 = getWeaponStats(attaquant, options.tirDouble.label);
      if (stats2 === undefined) {
        error("Pas d'arme de label " + options.tirDouble.label + " pour le tir double", attaquant);
        return;
      }
      var tdSkillDiv = parseInt(stats2.attSkillDiv);
      if (!isNaN(tdSkillDiv) && tdSkillDiv < weaponStats.attSkillDiv)
        weaponStats.attSkillDiv = tdSkillDiv;
      stats2.attDMBonusCommun = parseInt(stats2.attDMBonusCommun);
      stats2.attNbDices = parseInt(stats2.attNbDices);
      stats2.attDice = parseInt(stats2.attDice);
      if (stats2.divers && stats2.divers.includes('d3')) stats2.attDice = 3;
      options.tirDouble.stats = stats2;
    }
    if (portee > 0) {
      options.distance = true;
      if (attributeAsBool(attaquant, 'rageDuBerserk')) {
        sendChar(attaquant.charId, "est en rage du berserk, il ne veut attaquer qu'au contact");
        return;
      }
      if (options.puissantPortee || options.tempeteDeManaPortee) {
        portee = portee * 2;
        weaponStats.portee = portee;
      }
    } else {
      options.contact = true;
    }
    //Pour l'option grenaille implicite, il faut vérifier que toutes les charge de l'arme sont des charges de grenaille
    var chargesArme = [];
    var attackLabel = weaponStats.label;
    if (attackLabel) {
      chargesArme = findObjs({
        _type: 'attribute',
        _characterid: attackingCharId,
        name: "charge_" + attackLabel
      });
      if (!options.grenaille && chargesArme.length > 0) {
        var chargesGrenaille = findObjs({
          _type: 'attribute',
          _characterid: attackingCharId,
          name: "chargeGrenaille_" + attackLabel
        });
        if (chargesGrenaille.length > 0) {
          var chargesTotales = parseInt(chargesArme[0].get('current'));
          if (!isNaN(chargesTotales)) {
            var grenailles = parseInt(chargesGrenaille[0].get('current'));
            if (!isNaN(grenailles) && grenailles >= chargesTotales)
              options.grenaille = true;
          }
        }
      }
    }
    if (options.grenaille) {
      portee = portee / 10;
      options.aoe = options.aoe || {
        type: 'cone',
        angle: 90
      };
      weaponStats.attDice -= 2;
      weaponStats.attDMBonusCommun = Math.ceil(weaponStats.attDMBonusCommun / 2);
      if (weaponStats.attDice < 0) weaponStats.attDice = 0;
      if (options.tirDouble && options.tirDouble.stats) {
        options.tirDouble.stats.attDice -= 2;
        if (options.tirDouble.stats.attDice < 0) options.tirDouble.stats.attDice = 0;
      }
      options.auto = true;
      var effet = findObjs({
        _type: 'custfx',
        name: 'grenaille ' + portee
      });
      if (effet.length === 0) {
        effet = createObj('custfx', {
          name: 'grenaille ' + portee,
          definition: {
            "angle": -1,
            "angleRandom": 45,
            "duration": 8,
            "emissionRate": 40,
            "endColour": [130, 130, 130, 0],
            "endColourRandom": [10, 10, 10, 0],
            "lifeSpan": portee * 5,
            "lifeSpanRandom": portee / 2,
            "maxParticles": 200,
            "size": 10,
            "sizeRandom": 3,
            "speed": 12,
            "speedRandom": 3,
            "startColour": [25, 25, 25, 1],
            "startColourRandom": [7, 7, 7, 0.5]
          }
        });
      } else effet = effet[0];
      options.fx = options.fx || effet.id;
    }
    //Détermination de la (ou des) cible(s)
    var nomCiblePrincipale; //Utilise pour le cas mono-cible
    var cibles = [];
    if (options.redo) { //Dans ce cas les cibles sont précisées dans targetToken
      cibles = targetToken;
      if (cibles.length === 0) {
        error("Attaque sans cible", targetToken);
        return;
      } else if (cibles.length == 1) targetToken = cibles[0].token;
      nomCiblePrincipale = cibles[0].tokName;
    } else {
      var murs;
      var pc;
      var page;
      nomCiblePrincipale = targetToken.get('name');
      if (options.aoe) {
        if (options.targetFx) {
          spawnFx(targetToken.get('left'), targetToken.get('top'), options.targetFx, pageId);
        }
        var distanceTarget = distanceCombat(targetToken, attackingToken, pageId, {
          strict1: true,
          strict2: true
        });
        var pta = tokenCenter(attackingToken);
        var ptt = tokenCenter(targetToken);
        switch (options.aoe.type) {
          case 'ligne':
            if (distanceTarget < portee) { //la ligne va plus loin que la cible
              var scale = portee * 1.0 / distanceTarget;
              ptt = [
                Math.round((ptt[0] - pta[0]) * scale) + pta[0],
                Math.round((ptt[1] - pta[1]) * scale) + pta[1]
              ];
            }
            if (targetToken.get('bar1_max') == 0) { // jshint ignore:line
              //C'est juste un token utilisé pour définir la ligne
              if (options.fx) {
                var p1e = {
                  x: attackingToken.get('left'),
                  y: attackingToken.get('top'),
                };
                var p2e = {
                  x: targetToken.get('left'),
                  y: targetToken.get('top'),
                };
                spawnFxBetweenPoints(p1e, p2e, options.fx, pageId);
              }
              cibles = [];
              targetToken.remove(); //On l'enlève, normalement plus besoin
            }
            var allToks =
              findObjs({
                _type: 'graphic',
                _pageid: pageId,
                _subtype: 'token',
                layer: 'objects'
              });
            allToks.forEach(function(obj) {
              if (obj.id == attackingToken.id) return; //on ne se cible pas
              var objCharId = obj.get('represents');
              if (objCharId === '') return;
              var cible = {
                token: obj,
                charId: objCharId
              };
              if (getState(cible, 'mort')) return; //pas de dégâts aux morts
              var pt = tokenCenter(obj);
              var distToTrajectory = VecMath.ptSegDist(pt, pta, ptt);
              if (distToTrajectory > (obj.get('width') + obj.get('height')) / 4 + PIX_PER_UNIT / 4)
                return;
              cible.tokName = obj.get('name');
              var objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              cible.name = objChar.get('name');
              cibles.push(cible);
            });
            break;
          case 'disque':
            if (distanceTarget > portee) {
              sendChar(attackingCharId,
                "Le centre du disque visé est trop loin pour " + weaponName +
                " (distance " + distanceTarget + ", portée " + portee + ")");
              return;
            }
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            if (murs) {
              pc = {
                x: ptt[0],
                y: ptt[1],
              };
            }
            var allToksDisque =
              findObjs({
                _type: "graphic",
                _pageid: pageId,
                _subtype: "token",
                layer: "objects"
              });
            allToksDisque.forEach(function(obj) {
              if (portee === 0 && obj.id == attackingToken.id) return; //on ne se cible pas si le centre de l'aoe est soi-même
              if (obj.get('bar1_max') == 0) return; // jshint ignore:line
              var objCharId = obj.get('represents');
              if (objCharId === '') return;
              var cible = {
                token: obj,
                charId: objCharId
              };
              if (getState(cible, 'mort')) return; //pas de dégâts aux morts
              var distanceCentre =
                distanceCombat(targetToken, obj, pageId, {
                  strict1: true
                });
              if (distanceCentre > options.aoe.rayon) return;
              var objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              if (murs) {
                if (obstaclePresent(obj.get('left'), obj.get('top'), pc, murs)) return;
              }
              cible.name = objChar.get('name');
              cible.tokName = obj.get('name');
              cibles.push(cible);
            });
            if (targetToken.get('bar1_max') == 0) { // jshint ignore:line
              //C'est juste un token utilisé pour définir le disque
              targetToken.remove(); //On l'enlève, normalement plus besoin
            }
            // La nouvelle portée (pour ne rien éliminer à l'étape suivante
            portee += options.aoe.rayon;
            break;
          case 'cone':
            if (options.fx) {
              var p1eC = {
                x: attackingToken.get('left'),
                y: attackingToken.get('top'),
              };
              var p2eC = {
                x: targetToken.get('left'),
                y: targetToken.get('top'),
              };
              spawnFxBetweenPoints(p1eC, p2eC, options.fx, pageId);
            }
            var vecCentre = VecMath.normalize(VecMath.vec(pta, ptt));
            var cosAngle = Math.cos(options.aoe.angle * Math.PI / 360.0);
            //Pour éviter des artfacts d'arrondi:
            cosAngle = (Math.floor(cosAngle * 1000000)) / 1000000;
            if (targetToken.get('bar1_max') == 0) { // jshint ignore:line
              //C'est juste un token utilisé pour définir le cone
              cibles = [];
              targetToken.remove(); //On l'enlève, normalement plus besoin
            }
            page = page || getObj("page", pageId);
            murs = getWalls(page, pageId, murs);
            if (murs) {
              pc = {
                x: pta[0],
                y: pta[1],
              };
            }
            var allToksCone =
              findObjs({
                _type: "graphic",
                _pageid: pageId,
                _subtype: "token",
                layer: "objects"
              });
            allToksCone.forEach(function(obj) {
              if (obj.id == attackingToken.id) return; //on ne se cible pas
              var objCharId = obj.get('represents');
              if (objCharId === '') return;
              var cible = {
                token: obj,
                charId: objCharId
              };
              if (getState(cible, 'mort')) return; //pas de dégâts aux morts
              var pt = tokenCenter(obj);
              var vecObj = VecMath.normalize(VecMath.vec(pta, pt));
              if (VecMath.dot(vecCentre, vecObj) < cosAngle) return;
              // La distance sera comparée à la portée plus loin
              var objChar = getObj('character', objCharId);
              if (objChar === undefined) return;
              if (murs) {
                if (obstaclePresent(pt[0], pt[1], pc, murs)) return;
              }
              cible.name = objChar.get('name');
              cible.tokName = obj.get('name');
              cibles.push(cible);
            });
            break;
          default:
            error("aoe inconnue", options.aoe);
            return;
        }
      } else {
        if (attackingToken.id == targetToken.id && !options.echecTotal) { //même token pour attaquant et cible
          sendChar(attackingCharId,
            "s'attaque " + onGenre(attaquant, "lui", "elle") +
            "-même ? Probablement une erreur à la sélection de la cible. On annule");
          return;
        }
        var targetCharId = targetToken.get("represents");
        if (targetCharId === "") {
          error("Le token ciblé (" + nomCiblePrincipale + ") doit représenter un personnage ", targetToken);
          return;
        }
        var targetChar = getObj("character", targetCharId);
        if (targetChar === undefined) {
          error("Unexpected undefined 2", targetChar);
          return;
        }
        cibles = [{
          token: targetToken,
          charId: targetCharId,
          name: targetChar.get('name'),
          tokName: nomCiblePrincipale
        }];
      }
      if (options.ciblesSupplementaires) {
        options.ciblesSupplementaires.forEach(function(c) {
          var i = cibles.indexOf(function(t) {
            return (t.token.id == c.token.id);
          });
          if (i < 0) cibles.push(c);
        });
      }
    }
    //Les conditions qui peuvent empêcher l'attaque
    if (options.conditionAttaquant !== undefined) {
      if (!testCondition(options.conditionAttaquant, attaquant, cibles)) {
        sendChar(attackingCharId, "ne peut pas utiliser " + weaponName);
        return;
      }
    }
    if (options.avecd12 && ((estAffaibli(attaquant) && !charAttributeAsBool(attaquant, 'insensibleAffaibli')) || getState(attaquant, 'immobilise'))) {
      sendChar(attackingCharId, "ne peut pas utiliser cette capacité quand il est affaibli.");
      return;
    }
    //dernieresCiblesAttaquees contient en current les cibles attaquées, et en max les cibles sur lesquelles on a fait des ripostes
    var attrCiblesAttaquees = tokenAttribute(attaquant, 'dernieresCiblesAttaquees');
    var ripostesDuTour = new Set();
    if (attrCiblesAttaquees.length > 0) {
      ripostesDuTour = new Set(attrCiblesAttaquees[0].get('max').split(' '));
    }
    cibles = cibles.filter(function(target) {
      if (getState(target, 'enseveli')) {
        sendChar(attackingCharId, "impossible d'attaquer un personnage enseveli");
        return false;
      }
      if (attributeAsBool(target, 'ombreMortelle')) {
        sendChar(attackingCharId, "impossible d'attaquer une ombre");
        return false;
      }
      if (options.seulementVivant && estNonVivant(target)) {
        sendChar(attackingCharId, "cette attaque n'affecte que les créatures vivantes");
        return false;
      }
      if (options.attaqueMentale && charAttributeAsBool(target, 'sansEsprit')) {
        sendChar(attackingCharId, "cette attaque n'affecte que les créatures pensantes");
        return false;
      }
      if (options.pointsVitaux && estNonVivant(target)) {
        sendChar(attackingCharId, "La cible n'est pas vraiment vivante : " + attaquant.name + " ne trouve pas de points vitaux");
        return false;
      }
      if (attributeAsBool(attaquant, 'tenuADistanceManoeuvre(' + target.token.id + ')')) {
        sendChar(attackingCharId, "est tenu à distance de " + target.tokName + ", " + onGenre(attaquant, "il", "elle") + " ne peut pas l'attaquer ce tour.");
        return false;
      }
      if (charAttributeAsBool(target, 'armeeConjuree')) {
        return options.attaqueArmeeConjuree;
      }
      if (ripostesDuTour.has(target.token.id)) {
        sendChar(attackingCharId, "a déjà fait une riposte contre " + target.tokName);
        return false;
      }
      return true;
    });
    if (cibles.length === 0) return;
    if (!options.redo) {
      //Prise en compte de la distance
      var optDistance = {};
      if (options.contact) optDistance.allonge = options.allonge;
      // Si l'attaquant est monté, distance mesurée à partir de sa monture
      var pseudoAttackingToken = attackingToken;
      var attrMonture = tokenAttribute(attaquant, 'monteSur');
      if (attrMonture.length > 0) {
        var pseudoAttacker =
          persoOfId(attrMonture[0].get('current'), attrMonture[0].get('max'), pageId);
        if (pseudoAttacker) pseudoAttackingToken = pseudoAttacker.token;
      }
      cibles = cibles.filter(function(target) {
        // Si la cible est montée, distance mesurée vers sa monture
        var pseudoTargetToken = target.token;
        attrMonture = tokenAttribute(target, 'monteSur');
        if (attrMonture.length > 0) {
          var pseudoTarget =
            persoOfId(attrMonture[0].get('current'), attrMonture[0].get('max'), pageId);
          if (pseudoTarget) pseudoTargetToken = pseudoTarget.token;
        }
        target.distance =
          distanceCombat(pseudoAttackingToken, pseudoTargetToken, pageId, optDistance);
        if (options.intercepter || options.interposer) return true;
        if (target.distance > portee && target.msgEsquiveFatale === undefined && !target.chairACanon) {
          if (options.aoe || options.auto) return false; //distance stricte
          if (target.distance > (charAttributeAsBool(attaquant, "tirParabolique") ? 3 : 2) * portee) return false;
          // On peut aller jusqu'à 2x portee si unique cible et jet d'attaque, 3x si le personnage a Tir Parabolique
          return true;
        }
        return true;
      });
    }
    //On enlève les alliés si l'option saufAllies est active
    if (options.saufAllies) {
      var allies = new Set();
      allies = alliesParPerso[attaquant.charId] || allies;
      allies = (new Set(allies)).add(attaquant.charId);
      cibles = cibles.filter(function(target) {
        return !(allies.has(target.charId));
      });
    }
    if (cibles.length === 0) {
      if (options.aoe) {
        sendChar(attackingCharId, "aucune cible dans l'aire d'effet de " + weaponName + ", action annulée");
        return;
      }
      sendChar(attackingCharId, "est hors de portée de " + nomCiblePrincipale + " pour une attaque utilisant " + weaponName + ", action annulée");
      return;
    }
    //On enlève les doublons de cibles qui partagent leurs PVs;
    var ciblesAvecPVsPartages = new Set();
    //va aussi peupler le champ name des cibles
    cibles = cibles.filter(function(target, index) {
      if (target.name === undefined) {
        var targetChar = getObj('character', target.charId);
        if (targetChar === undefined) return false;
        target.name = targetChar.get('name');
      }
      if (ciblesAvecPVsPartages.has(target.name)) return false;
      var ciblePartagee = charAttribute(target.charId, 'PVPartagesAvec');
      if (ciblePartagee.length > 0) {
        if (charAttributeAsBool(target, 'familier')) {
          //c'est le personnage qui a un familier, on le garde en cible prioritaire
          ciblePartagee.forEach(function(attr) {
            ciblesAvecPVsPartages.add(attr.get('current'));
          });
        } else if (persoEstPNJ(target)) {
          //cible la moins prioritaire, on l'enlève si on trouve un autre représentant
          var representantPresent = cibles.find(function(target2, index2) {
            if (index2 < index) return false;
            if (target2.name === undefined) {
              var target2Char = getObj('character', target2.charId);
              if (target2Char === undefined) return false;
              target2.name = target2Char.get('name');
            }
            return ciblePartagee.find(function(cn) {
              return cn == target2.name;
            });
          });
          if (representantPresent) return false;
        } else {
          //N'a pas de familier mais n'est pas un PNJ
          var representantFamilier = cibles.find(function(target2, index2) {
            if (index2 < index) return false;
            if (target2.name === undefined) {
              var target2Char = getObj('character', target2.charId);
              if (target2Char === undefined) return false;
              target2.name = target2Char.get('name');
            }
            var estPartagee = ciblePartagee.find(function(cn) {
              return cn == target2.name;
            });
            if (!estPartagee) return false;
            return charAttributeAsBool(target2, 'familier');
          });
          if (representantFamilier) return false;
        }
      }
      return true;
    });
    var evt = options.evt || {
      type: "Attaque",
      action: {
        playerId: playerId,
        attaquant: attaquant,
        cibles: cibles,
        weaponStats: weaponStats,
        options: options
      }
    };
    if (options.attaqueArmeeConjuree) {
      setAttrDuree(attaquant, 'attaqueArmeeConjuree', 1, evt);
    }
    evt.action = evt.action || {
      options: JSON.parse(JSON.stringify(options)) //pour la chance etc.
    };
    if (options.tempsRecharge) {
      if (attributeAsBool(attaquant, options.tempsRecharge.effet)) {
        sendChar(attackingCharId, "ne peut pas encore utiliser cette attaque");
        return;
      }
      if (options.tempsRecharge.duree > 0) {
        setAttrDuree(attaquant, options.tempsRecharge.effet, options.tempsRecharge.duree, evt);
      }
    }
    //On met à jour l'arme en main, si nécessaire
    if (weaponStats.arme || weaponStats.armeGauche || (weaponStats.divers && weaponStats.divers.toLowerCase().includes('arme'))) {
      options.weaponStats = weaponStats;
      options.messages = options.messages || [];
      degainerArme(attaquant, attackLabel, evt, options);
    }
    var riposte = charAttributeAsBool(attaquant, 'riposte');
    var attaqueEnMeute = charAttributeAsInt(attaquant, 'attaqueEnMeute', 0);
    if (attaqueEnMeute > 0) options.attaqueEnMeute = attaqueEnMeute;
    var attrLienEpique = charAttribute(attaquant.charId, 'lienEpique');
    if (attrLienEpique.length > 0) {
      options.lienEpique = attrLienEpique[0].get('current');
    }
    if (riposte || options.attaqueEnMeute || options.lienEpique) {
      //Dans ce cas, il faut stoquer les cibles attaquées
      //(dans le cas de riposte, pour ne pas les re-proposer en riposte
      var listeCibles =
        cibles.map(function(target) {
          return target.token.id;
        }).join(' ');
      if (attrCiblesAttaquees.length === 0) {
        if (options.riposte) {
          setTokenAttr(attaquant, 'dernieresCiblesAttaquees', '', evt, {
            maxVal: listeCibles
          });
        } else {
          setTokenAttr(attaquant, 'dernieresCiblesAttaquees', listeCibles, evt);
        }
      } else { //L'attribut existe déjà
        attrCiblesAttaquees = attrCiblesAttaquees[0];
        evt.attributes = evt.attributes || [];
        var attaquesDuTour = attrCiblesAttaquees.get('current');
        ripostesDuTour = attrCiblesAttaquees.get('max');
        evt.attributes.push({
          attribute: attrCiblesAttaquees,
          current: attaquesDuTour,
          max: ripostesDuTour,
        });
        if (options.riposte) {
          if (ripostesDuTour === '') ripostesDuTour = listeCibles;
          else ripostesDuTour += ' ' + listeCibles;
          attrCiblesAttaquees.set('max', ripostesDuTour);
        } else {
          if (attaquesDuTour === '') attaquesDuTour = listeCibles;
          else attaquesDuTour += ' ' + listeCibles;
          attrCiblesAttaquees.set('current', attaquesDuTour);
        }
      }
    }
    addEvent(evt);
    //On fait les tests pour les cibles qui bénéficieraient d'un sanctuaire
    var ciblesATraiter = cibles.length;
    var cibleTraitee = function() {
      ciblesATraiter--;
      if (ciblesATraiter === 0) {
        var explications = [];
        if (options.messages) explications = [...options.messages];
        evalITE(attaquant, undefined, undefined, options, 0, evt, explications, options, function() {
          resoudreAttaque(attaquant, cibles, attackLabel, weaponName, weaponStats, playerId, pageId, evt, explications, options, chargesArme);
        });
      }
    };
    var attaqueImpossible = false;
    cibles.forEach(function(cible) {
      if (attaqueImpossible) return;
      cible.messages = [];
      var evalSanctuaire = function() {
        if (attributeAsBool(cible, 'sanctuaire')) {
          var testId = 'sanctuaire_' + cible.token.id;
          testCaracteristique(attaquant, 'SAG', 15, testId, options, evt, function(tr) {
            if (tr.reussite) {
              cible.messages.push(attaquant.tokName + " réussi à passer outre le sanctuaire de " + cible.tokName + " (jet de SAG " + tr.texte + "&ge;15)" + tr.modifiers);
              cibleTraitee();
            } else {
              var msgRate = "ne peut se résoudre à attaquer " + cible.tokName + " (sanctuaire, jet de SAG " + tr.texte + "< 15)" + tr.rerolls + tr.modifiers;
              sendChar(attaquant.charId, msgRate);
              attaqueImpossible = true;
            }
          });
        } else {
          cibleTraitee();
        }
      };
      // Attaque de Disparition avec jet opposé
      if (options.disparition) {
        //L'immunité aux attaques sournoise est testée plus loin et ne devrait
        //pas empêcher le bonus de +5 à l'attaque.
        var rollId = 'disparition_' + cible.token.id;
        var options1 = {...options
        };
        options1.competence = "discrétion";
        var options2 = {...options
        };
        options2.competence = "perception";
        testOppose(rollId, attaquant, "DEX", options1, cible, "SAG", options2,
          cible.messages, evt,
          function(resultat, crit, rt1, rt2) {
            if (resultat != 2) {
              cible.messages.push(attaquant.tokName + " réapparait à côté de " + cible.tokName + " et lui porte une attaque mortelle !");
              // rajout des bonus de sournoise
              options.bonusAttaque = (options.bonusAttaque || 0) + 5;
              options.sournoise = options.sournoise || 0;
              options.sournoise += options.disparition;
              evalSanctuaire();
            } else {
              cible.messages.push(cible.tokName + " repère " + attaquant.tokName + " à temps pour réagir.");
              evalSanctuaire();
            }
          }); //fin de testOppose (asynchrone)
      } else evalSanctuaire();
    });
  }

  // On affiche les options d'attaque à droite
  function afficherOptionsAttaque(perso, opt_display) {
    var action_opts = '!cof-options-d-attaque --target ' + perso.token.id;
    var text_opts = '';
    if (persoEstPNJ(perso) && ficheAttributeAsInt(perso, 'attaque_de_groupe', 1) > 1) {
      text_opts = "Groupe de " + ficheAttributeAsInt(perso, 'attaque_de_groupe', 1);
    }
    if (ficheAttributeAsInt(perso, 'attaque_en_puissance_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "En puissance " + ficheAttributeAsInt(perso, 'attaque_en_puissance', 1);
    }
    if (ficheAttributeAsInt(perso, 'attaque_risquee_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "Risquée";
    }
    if (ficheAttributeAsInt(perso, 'attaque_assuree_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "Assurée";
    }
    if (ficheAttributeAsInt(perso, 'attaque_dm_temp_check')) {
      if (text_opts !== '') text_opts += '<br>';
      text_opts += "Pour assomer";
    }
    if (text_opts === '') text_opts = 'Options';
    opt_display.action_right =
      boutonSimple(action_opts, text_opts,
        'style="color: #a94442; background-color: #f2dede;"');
  }

  // on récupère la valeur de l'action dont chaque Macro #/Ability % est mis dans un tableau 'action'
  //Pour chaque action, on a une commande, un texte et des options.
  //On appelle f(commande, texte, macros, option)
  function treatActions(perso, actionsDuTour, abilities, f) {
    var actions = actionsDuTour.get('action')
      .replace(/\n/gm, '').replace(/\r/gm, '')
      .replace(/%#([^#]*)#/g, '\n!cof-liste-actions $1')
      .replace(/\/\/%/g, '\n\/\/')
      .replace(/\/\/#/g, '\n\/\/')
      .replace(/\/\/!/g, '\n\/\/')
      .replace(/%/g, '\n%').replace(/#/g, '\n#').replace(/!/g, '\n!')
      .split('\n');
    var actionsAAfficher;
    if (actions.length > 0) {
      // Toutes les Macros
      var macros = findObjs({
        _type: 'macro'
      });
      var found;
      var command;
      var options = '';
      // On recherche si l'action existe (Ability % ou Macro #)
      actions.forEach(function(action) {
        action = action.trim();
        if (action === '') return;
        if (action.startsWith('//')) return; //commented out line
        var actionCommands = action.split(' ');
        actionCommands = actionCommands.filter(function(c) {
          return c !== '';
        });
        var actionCmd = actionCommands[0];
        var actionText = actionCmd.replace(/-/g, ' ').replace(/_/g, ' ');
        found = false;
        switch (actionCmd.charAt(0)) {
          case '%':
            // Ability
            actionCmd = actionCmd.substr(1);
            actionText = actionText.substr(1);
            abilities.forEach(function(abilitie, index) {
              if (found) return;
              if (abilitie.get('name') === actionCmd) {
                // l'ability existe
                found = true;
                command = abilitie.get('action').trim();
                if (actionCommands.length > 1) {
                  //On rajoute les options de l'ability
                  command += action.substr(action.indexOf(' '));
                }
                command += options;
                f(command, actionText, macros);
              }
            });
            break;
          case '#':
            // Macro
            //D'abord le cas de #Attaque
            if (actionCmd == '#Attaque' && actionCommands.length > 1) {
              found = true;
              var attackLabel = actionCommands[1].trim();
              var attackStats;
              if (attackLabel == -1) { //attaque avec l'arme en main
                attackStats = armesEnMain(perso);
              } else attackStats = getWeaponStats(perso, attackLabel);
              actionText = attackStats.name;
              action += options;
              f(action, actionText, macros, {
                attackStats: attackStats
              });
            } else {
              actionCmd = actionCmd.substr(1);
              actionText = actionText.substr(1);
              macros.forEach(function(macro, index) {
                if (found) return;
                if (macro.get('name') === actionCmd) {
                  found = true;
                  command = macro.get('action').trim();
                  if (actionCommands.length > 1) {
                    //On rajoute les options de la macro
                    command += action.substr(action.indexOf(' '));
                  }
                  command += options;
                  f(command, actionText, macros);
                }
              });
            }
            break;
          case '!':
            if (actionCmd.toLowerCase() == '!options') {
              found = true;
              if (actionCommands.length > 1) {
                options = action.substring(8); //démarre par ' '
              }
            } else if (actionCmd.toLowerCase() == '!attaques') {
              found = true;
              f('liste des attaques', '', macros, options);
            } else {
              // commande API
              if (actionCommands.length > 1) {
                actionText = actionCommands[1].replace(/-/g, ' ').replace(/_/g, ' ');
              }
              command = action + options;
              f(command, actionText, macros);
              found = true;
            }
        }
        if (found) {
          actionsAAfficher = true;
        } else {
          // Si on n'a toujours rien trouvé, on ajoute un petit log
          log('Ability et macro non trouvé : ' + action);
        }
      });
    }
    return actionsAAfficher;
  }

  function displayAttaqueOpportunite(vid, cibles, type, action, option) {
    var attaquant = persoOfId(vid);
    if (attaquant === undefined) {
      error("Impossible de retrouver le personnage qui pouvait faire une attaque " + type, vid);
      return;
    }
    if (!isActive(attaquant)) return;
    var abilities = findObjs({
      _type: 'ability',
      _characterid: attaquant.charId,
    });
    var actions;
    var actionsParDefaut = true;
    abilities.find(function(a) {
      var an = a.get('name');
      if (an == action) {
        actions = a;
        actionsParDefaut = false;
        return true;
      }
      if (an == '#Actions#') {
        actions = a;
        actionsParDefaut = true;
      } else if (an == '#TurnAction#') {
        actions = a;
        actionsParDefaut = false;
      }
      return false;
    });
    var actionsOpportunite = [];
    if (actions) {
      treatActions(attaquant, actions, abilities, function(command, text, macros, options) {
        if (command == 'liste des attaques') {
          actionsOpportunite.push({
            listeActions: true,
            options: options
          });
        } else {
          command = replaceAction(command, attaquant, macros, abilities);
          if (command.startsWith('!cof-attack')) {
            actionsOpportunite.push({
              command: command,
              text: text,
              options: options
            });
          }
        }
      });
      actionsOpportunite.reverse();
    }
    var opt_display = {
      chuchote: true,
      retarde: true,
    };
    afficherOptionsAttaque(attaquant, opt_display);
    //On crée un display sans le header
    var display = startFramedDisplay(undefined, "Attaque " + type + " possible", attaquant, opt_display);
    cibles.forEach(function(target) {
      target.tokName = target.tokName || target.token.get('name');
      if (target.name === undefined) {
        var targetChar = getObj('character', target.charId);
        if (targetChar === undefined) {
          error('Impossible de trouver le personnage représentant ' + target.tokName, target);
          return;
        }
        target.name = targetChar.get('name');
      }
      addLineToFramedDisplay(display, "contre " + target.tokName, 100, true);
      if (actionsParDefaut) addLineToFramedDisplay(display, listeAttaquesVisibles(attaquant, option, target.token.id));
      actionsOpportunite.forEach(function(action) {
        var opt = action.options;
        if (opt) {
          if (option) opt = option + opt;
        } else opt = option;
        if (action.listeActions) {
          addLineToFramedDisplay(display, listeAttaquesVisibles(attaquant, opt, target.token.id));
          return;
        }
        var cmd = action.command.replace(/@\{target\|token_id\}/g, target.token.id);
        cmd = cmd.replace(/@\{target\|token_name\}/g, target.tokName);
        cmd = cmd.replace(/@\{target\|/g, '@{' + target.name + '|');
        if (opt) cmd += ' ' + opt;
        addLineToFramedDisplay(display, bouton(cmd, action.text, attaquant));
      });
    });
    // on envoie la liste aux joueurs qui gèrent l'attaquant
    var playerIds = getPlayerIds(attaquant);
    playerIds.forEach(function(playerid) {
      addFramedHeader(display, playerid, true);
      sendChat('', endFramedDisplay(display));
    });
    if (playerIds.length === 0) {
      addFramedHeader(display, undefined, 'gm');
      sendChat('', endFramedDisplay(display));
    }
  }

  function ajouteDe6Crit(x, first) {
    var bonusCrit = rollDePlus(6);
    if (first) x.dmgDisplay = "(" + x.dmgDisplay + ")";
    x.dmgDisplay += '+' + bonusCrit.roll;
    x.dmgTotal += bonusCrit.val;
  }

  function immuniseAuType(target, dmgType, attaquant) {
    if (charAttributeAsBool(target, 'immunite_' + dmgType)) return true;
    switch (dmgType) {
      case 'poison':
        if (attaquant && charAttributeAsBool(target, 'sangDeFerIf')) {
          return estElfeNoir(attaquant) || estInsecte(attaquant);
        }
        return false;
      case 'froid':
        return attributeAsBool(target, 'presenceGlaciale');
    }
    return false;
  }

  // Fonction asynchrone
  // displayRes est optionnel, et peut avoir 2 arguments
  // - un texte affichant le jet de dégâts
  // - la valeur finale des dégâts infligés
  // crit est un booléen, il augmente de 1 (ou options.critCoef) le coefficient (option.dmgCoef) et active certains effets
  function dealDamage(target, dmg, otherDmg, evt, crit, options, explications, displayRes) {
    if (target.tokName === undefined) target.tokName = target.token.get('name');
    if (options === undefined) options = {};
    var expliquer = function(msg) {
      if (explications) explications.push(msg);
      else sendChar(target.charId, msg);
    };
    if (options.interposer) {
      return dealDamageAfterOthers(target, crit, {}, evt, expliquer, displayRes, options.interposer, dmg.display, false);
    }
    if (attributeAsBool(target, 'intangible') ||
      attributeAsBool(target, 'ombreMortelle') ||
      (options.aoe === undefined &&
        attributeAsBool(target, 'formeGazeuse'))) {
      expliquer("L'attaque passe à travers de " + target.token.get('name'));
      if (displayRes) displayRes('0', 0);
      return 0;
    }
    if (options.asphyxie) {
      if (charAttributeAsBool(target, 'creatureArtificielle') ||
        estNonVivant(target)) {
        expliquer("L'asphyxie est sans effet sur une créature non-vivante");
        if (displayRes) displayRes('0', 0);
        return 0;
      } else if (estDemon(target)) {
        expliquer("L'asphyxie est sans effet sur un démon");
        if (displayRes) displayRes('0', 0);
        return 0;
      }
    }
    var dmgCoef = options.dmgCoef || 1;
    if (target.dmgCoef) dmgCoef += target.dmgCoef;
    if (options.ferFroid && (estDemon(target) || estFee(target))) dmgCoef += 1;
    var diviseDmg = options.diviseDmg || 1;
    if (target.diviseDmg) diviseDmg *= target.diviseDmg;
    if (options.attaqueDeGroupeDmgCoef) {
      dmgCoef++;
      expliquer("Attaque en groupe > DEF +" + reglesOptionelles.haute_DEF.val.crit_attaque_groupe.val + " => DMGx" + (crit ? "3" : "2"));
    }
    var critCoef = 1;
    if (crit) {
      if (attributeAsBool(target, 'armureLourdeGuerrier') &&
        attributeAsBool(target, 'DEFARMUREON') &&
        attributeAsInt(target, 'DEFARMURE', 0) >= 8) {
        expliquer("L'armure lourde de " + target.token.get('name') + " lui permet d'ignorer les dégâts critiques");
      } else {
        if (options.critCoef) critCoef = options.critCoef;
        if (target.critCoef) critCoef += target.critCoef;
        dmgCoef += critCoef;
        if (attributeAsBool(target, 'armureProtection') && attributeAsBool(target, 'DEFARMUREON')) {
          expliquer("L'armure de protection de " + target.token.get('name') + " le protège du critique");
          diviseDmg++;
        }
        if (attributeAsBool(target, 'bouclierProtection') && attributeAsBool(target, 'DEFBOUCLIERON')) {
          expliquer("Le bouclier de protection de " + target.token.get('name') + " le protège du critique");
          diviseDmg++;
        }
      }
    }
    otherDmg = otherDmg || [];
    var dmgDisplay = dmg.display;
    var dmgTotal = dmg.total;
    if (dmgTotal < 1 && !(dmg.value && dmg.value.startsWith('0'))) {
      dmgDisplay += ' -> 1';
      dmgTotal = 1;
    }
    var showTotal = false;
    if (dmgCoef > 1) {
      dmgDisplay += " X " + dmgCoef;
      dmgTotal = dmgTotal * dmgCoef;
      showTotal = true;
    }
    if (diviseDmg > 1) {
      if (showTotal) dmgDisplay = '(' + dmgDisplay + ')';
      dmgDisplay += " / " + diviseDmg;
      dmgTotal = Math.ceil(dmgTotal / diviseDmg);
      showTotal = true;
    }
    if (crit) {
      var messageCrit = charAttribute(target.charId, 'messageSiCritique');
      if (messageCrit.length > 0) {
        messageCrit = messageCrit[0].get('current');
        expliquer(messageCrit);
      }
      if (attributeAsBool(target, 'memePasMal')) {
        options.memePasMal = (dmgTotal / dmgCoef) * critCoef;
      }
      var firstBonusCritique = true;
      var x = {
        dmgDisplay: dmgDisplay,
        dmgTotal: dmgTotal
      };
      if (options.affute) {
        ajouteDe6Crit(x, firstBonusCritique);
        firstBonusCritique = false;
      }
      if (options.tirFatal) {
        ajouteDe6Crit(x, firstBonusCritique);
        if (options.tirFatal > 1) {
          ajouteDe6Crit(x, false);
        }
      }
      if (target.additionalCritDmg) {
        target.additionalCritDmg.forEach(function(dmSpec) {
          if (firstBonusCritique) {
            x.dmgDisplay = "(" + x.dmgDisplay + ")";
            firstBonusCritique = false;
          }
          x.dmgDisplay += '+' + dmSpec.display;
          x.dmgTotal += dmSpec.total;
        });
      }
      if (options.memePasMal !== undefined) {
        options.memePasMal += x.dmgTotal - dmgTotal;
      }
      dmgDisplay = x.dmgDisplay;
      dmgTotal = x.dmgTotal;
    }
    //On trie les DM supplémentaires selon leur type
    var dmgParType = {};
    otherDmg.forEach(function(d) {
      if (_.has(dmgParType, d.type)) dmgParType[d.type].push(d);
      else dmgParType[d.type] = [d];
    });
    // Dommages de même type que le principal, mais à part, donc non affectés par les critiques
    var mainDmgType = dmg.type;
    var dmgExtra = dmgParType[mainDmgType];
    if (dmgExtra && dmgExtra.length > 0 && !immuniseAuType(target, mainDmgType, options.attaquant)) {
      if (dmgCoef > 1) dmgDisplay = "(" + dmgDisplay + ")";
      showTotal = true;
      var count = dmgExtra.length;
      dmgExtra.forEach(function(d) {
        count--;
        if (d.partialSave && d.partialSave.tempete && options.tempeteDeManaIntense) {
          d.partialSave.seuil += d.partialSave.tempete * options.tempeteDeManaIntense;
        }
        partialSave(d, target, false, d.display, d.total, expliquer, evt,
          function(res) {
            if (res) {
              dmgTotal += res.total;
              dmgDisplay += "+" + res.dmgDisplay;
            } else {
              dmgTotal += d.total;
              dmgDisplay += "+" + d.display;
            }
            if (count === 0) dealDamageAfterDmgExtra(target, mainDmgType, dmgTotal, dmgDisplay, showTotal, dmgParType, dmgExtra, crit, options, evt, expliquer, displayRes);
          });
      });
    } else {
      return dealDamageAfterDmgExtra(target, mainDmgType, dmgTotal, dmgDisplay, showTotal, dmgParType, dmgExtra, crit, options, evt, expliquer, displayRes);
    }
  }

  // Effets quand on rentre en combat
  // attaquant est optionnel
  // ne rajoute pas evt à l'historique
  function entrerEnCombat(attaquant, cibles, explications, evt) {
    var selected = [];
    if (attaquant) {
      selected.push({
        _id: attaquant.token.id
      });
      if (getState(attaquant, 'invisible') && !charAttributeAsBool(attaquant, 'invisibleEnCombat')) {
        explications.push(attaquant.tokName + " redevient visible");
        setState(attaquant, 'invisible', false, evt);
      }
      var pacifisme = tokenAttribute(attaquant, 'pacifisme');
      if (pacifisme.length > 0 && pacifisme[0].get('current') > 0) {
        pacifisme[0].set('current', 0);
        if (attaquant.name === undefined) {
          var attackChar = getObj('character', attaquant.charId);
          if (attackChar) attaquant.name = attackChar.get('name');
          else attaquant.name = attaquant.tokName;
        }
        sendChat("GM", '/w "' + attaquant.name + '" ' + attaquant.tokName + " perd son pacifisme");
      }
      if (attributeAsBool(attaquant, 'sanctuaire')) {
        explications.push(attaquant.tokName + " met fin aux conditions du sanctuaire");
        removeTokenAttr(attaquant, 'sanctuaire', evt);
      }
    }
    cibles.forEach(function(target) {
      selected.push({
        _id: target.token.id
      });
    });
    initiative(selected, evt); //ne recalcule pas l'init
  }

  //L'argument weaponStats est optionnel
  function critEnAttaque(attaquant, weaponStats, options) {
    var crit = 20;
    if (weaponStats) crit = weaponStats.crit;
    if (isNaN(crit) || crit < 1 || crit > 20) {
      error("Le critique n'est pas un nombre entre 1 et 20", crit);
      crit = 20;
    }
    if (charAttributeAsBool(attaquant, 'scienceDuCritique') ||
      (!options.distance && !options.sortilege && charAttributeAsBool(attaquant, 'morsureDuSerpent')) ||
      (crit == 20 && charAttributeAsBool(attaquant, 'ecuyer'))) crit -= 1;
    if (options.bonusCritique) crit -= options.bonusCritique;
    if (options.affute) crit -= 1;
    if (options.contact && charAttributeAsBool(attaquant, 'frappeChirurgicale'))
      crit -= modCarac(attaquant, 'intelligence');
    var attrTirFatal = charAttribute(attaquant.charId, 'tirFatal');
    if (attrTirFatal.length > 0) {
      var armeTirFatal = attrTirFatal[0].get('current');
      if (armeTirFatal == 'true') armeTirFatal = 'arc';
      if (options[armeTirFatal] || weaponStats[armeTirFatal]) {
        crit -= modCarac(attaquant, 'sagesse');
        options.tirFatal = 1;
        if (charAttributeAsInt(attaquant, 'voieDeLArcEtDuCheval', 3) > 4)
          options.tirFatal = 2;
      }
    }
    if (crit < 2) crit = 2;
    return crit;
  }

  //Retourne un tableau de prefixes valides comme attaques de PNJ
  function listeAttaquesPNJ(perso) {
    var attributes = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    var attaques = [];
    attributes.forEach(function(attr) {
      var attrName = attr.get('name');
      var m = attackNamePNJRegExp.exec(attrName);
      if (m) {
        var attPrefix = m[1];
        attaques.push(attPrefix);
      }
    });
    return attaques;
  }

  function computeArmeAtk(attaquant, x) {
    if (x === undefined) return '';
    var attDiv;
    var attCar;
    switch (x) {
      case '@{ATKCAC}':
        if (persoEstPNJ(attaquant)) {
          var atkcac;
          listeAttaquesPNJ(attaquant).forEach(function(attPrefix) {
            if (atkcac === undefined) {
              atkcac = ficheAttributeAsInt(attaquant, attPrefix + 'armeatk');
              return;
            }
            var portee = ficheAttributeAsInt(attaquant, attPrefix + 'armeportee', 0);
            if (portee > 0) return;
            var typeat = ficheAttribute(attaquant, attPrefix + 'armetypeattaque', 'Naturel');
            switch (typeat) {
              case 'Sortilege':
              case 'Arme de jet':
                return;
              default:
                var oatk = ficheAttributeAsInt(attaquant, attPrefix + 'armeatk', atkcac);
                if (oatk > atkcac) atkcac = oatk;
            }
          });
          if (atkcac === undefined) {
            atkcac = ficheAttributeAsInt(attaquant, 'niveau', 0) + 1 + modCarac(attaquant, 'force');
          }
          return atkcac;
        }
        attDiv = ficheAttributeAsInt(attaquant, 'ATKCAC_DIV', 0);
        if (stateCOF.setting_arran ||
          (stateCOF.setting_mixte && ficheAttribute(attaquant, 'option_setting', 'generique') == 'arran')) {
          attDiv += ficheAttributeAsInt(attaquant, 'mod_atkcac', 0);
          attCar = '@{FOR}';
        } else {
          attCar = getAttrByName(attaquant.charId, 'ATKCAC_CARAC');
        }
        break;
      case '@{ATKTIR}':
        if (persoEstPNJ(attaquant)) {
          var atktir;
          listeAttaquesPNJ(attaquant).forEach(function(attPrefix) {
            if (atktir === undefined) {
              atktir = ficheAttributeAsInt(attaquant, attPrefix + 'armeatk');
              return;
            }
            var portee = ficheAttributeAsInt(attaquant, attPrefix + 'armeportee', 0);
            if (portee === 0) return;
            var typeat = ficheAttribute(attaquant, attPrefix + 'armetypeattaque', 'Naturel');
            if (typeat == 'Sortilege') return;
            var oatk = ficheAttributeAsInt(attaquant, attPrefix + 'armeatk', atktir);
            if (oatk > atktir) atktir = oatk;
          });
          if (atktir === undefined) {
            atktir = ficheAttributeAsInt(attaquant, 'niveau', 0) + 1 + modCarac(attaquant, 'dexterite');
          }
          return atktir;
        }
        attDiv = ficheAttributeAsInt(attaquant, 'ATKTIR_DIV', 0);
        if (stateCOF.setting_arran ||
          (stateCOF.setting_mixte && ficheAttribute(attaquant, 'option_setting', 'generique') == 'arran')) {
          attDiv += ficheAttributeAsInt(attaquant, 'mod_atktir', 0);
          attCar = '@{DEX}';
        } else {
          attCar = getAttrByName(attaquant.charId, 'ATKTIR_CARAC');
        }
        break;
      case '@{ATKMAG}':
        if (persoEstPNJ(attaquant)) {
          var atkmag;
          listeAttaquesPNJ(attaquant).forEach(function(attPrefix) {
            if (atkmag === undefined) {
              atkmag = ficheAttributeAsInt(attaquant, attPrefix + 'armeatk');
              return;
            }
            var typeat = ficheAttribute(attaquant, attPrefix + 'armetypeattaque', 'Naturel');
            if (typeat != 'Sortilege') return;
            var oatk = ficheAttributeAsInt(attaquant, attPrefix + 'armeatk', atkmag);
            if (oatk > atkmag) atkmag = oatk;
          });
          if (atkmag === undefined) {
            atkmag = ficheAttributeAsInt(attaquant, 'niveau', 0) + 1 + modCarac(attaquant, 'sagesse');
          }
          return atkmag;
        }
        attDiv = ficheAttributeAsInt(attaquant, 'ATKMAG_DIV', 0);
        if (stateCOF.setting_arran ||
          (stateCOF.setting_mixte && ficheAttribute(attaquant, 'option_setting', 'generique') == 'arran')) {
          attDiv += ficheAttributeAsInt(attaquant, 'mod_atkmag', 0);
          attCar = '@{INT}';
        } else {
          attCar = getAttrByName(attaquant.charId, 'ATKMAG_CARAC');
        }
        break;
      default:
        return x;
    }
    attCar = computeCarExpression(attaquant, attCar);
    if (attCar === undefined) return x;
    return attCar + ficheAttributeAsInt(attaquant, 'niveau', 1) + attDiv;
  }

  //attaquant doit avoir un champ name
  function attackExpression(attaquant, nbDe, dice, crit, plusFort, weaponStats) {
    var de = computeDice(attaquant, {
      nbDe: nbDe,
      dice: dice,
      plusFort: plusFort
    });
    var attackRollExpr = "[[" + de + "cs>" + crit + "cf1]]";
    var attSkillDiv = weaponStats.attSkillDiv;
    if (isNaN(attSkillDiv)) attSkillDiv = 0;
    var attSkillDivTxt = "";
    if (attSkillDiv > 0) attSkillDivTxt = " + " + attSkillDiv;
    else if (attSkillDiv < 0) attSkillDivTxt += attSkillDiv;
    var attackSkillExpr = addOrigin(attaquant.name, "[[" + computeArmeAtk(attaquant, weaponStats.attSkill) + attSkillDivTxt + "]]");
    return attackRollExpr + " " + attackSkillExpr;
  }

  //N'ajoute as evt à l'historique
  function resoudreAttaque(attaquant, cibles, attackLabel, weaponName, weaponStats, playerId, pageId, evt, explications, options, chargesArme) {
    var attackingCharId = attaquant.charId;
    var attackingToken = attaquant.token;
    var attackerName = attaquant.name;
    var attackerTokName = attaquant.tokName;
    attaquant.additionalDmg = [...options.additionalDmg]; // Reset du calcul des dommages additionnels liés à l'attaquant
    var sujetAttaquant = onGenre(attaquant, 'il', 'elle');
    if (options.contact) {
      //Prise en compte du corps élémentaire
      var attrCorpsElem = findObjs({
        _type: 'attribute',
        _characterid: attackingCharId,
        name: 'corpsElementaire'
      });
      attrCorpsElem.forEach(function(attr) {
        var typeCorpsElem = attr.get('current');
        attaquant.additionalDmg.push({
          type: typeCorpsElem,
          value: '1d6',
        });
        explications.push("Corps de " + typeCorpsElem + " => +1d6 DM");
      });
    }
    // Munitions
    if (options.munition) {
      if (attackingToken.get('bar1_link') === '') {
        error("Les munitions ne sont pas supportées pour les tokens qui ne sont pas liées à un personnage", attackingToken);
      }
      var munitionsAttr = findObjs({
        _type: 'attribute',
        _characterid: attackingCharId,
        name: 'munition_' + options.munition.nom
      });
      if (munitionsAttr.length === 0) {
        error("Pas de munition nommée " + options.munition.nom + " pour " + attackerName);
        return;
      }
      munitionsAttr = munitionsAttr[0];
      var munitions = munitionsAttr.get('current');
      if (munitions < 1 || (options.tirDouble && munitions < 2)) {
        sendChar(attackingCharId,
          "ne peut pas utiliser cette attaque, car " + sujetAttaquant +
          " n'a plus de " + options.munition.nom.replace(/_/g, ' '));
        return;
      }
      var munitionsMax = parseInt(munitionsAttr.get('max'));
      if (isNaN(munitionsMax)) {
        error("Attribut de munitions mal formé", munitionsMax);
        return;
      }
      evt.attributes = evt.attributes || [];
      evt.attributes.push({
        attribute: munitionsAttr,
        current: munitions,
        max: munitionsMax
      });
      //On cherche si la munition est empoisonnée
      var poisonAttr = tokenAttribute(attaquant, 'poisonRapide_munition_' + options.munition.nom);
      if (poisonAttr.length > 0) {
        poisonAttr = poisonAttr[0];
        var infosPoisonMunitions = poisonAttr.get('max');
        var infosPoisonMunitionsIndex = infosPoisonMunitions.indexOf(' ');
        var seuilMunitionsEmpoisonnees = parseInt(infosPoisonMunitions.substring(0, infosPoisonMunitionsIndex));
        var nombreMunitionsEmpoisonnees = parseInt(infosPoisonMunitions.substring(infosPoisonMunitionsIndex + 1));
        if (!isNaN(seuilMunitionsEmpoisonnees) && !isNaN(nombreMunitionsEmpoisonnees) && nombreMunitionsEmpoisonnees > 0) {
          attaquant.additionalDmg.push({
            type: 'poison',
            value: poisonAttr.get('current'),
            partialSave: {
              carac: 'CON',
              seuil: seuilMunitionsEmpoisonnees
            }
          });
          explications.push("L'arme est empoisonnée");
          if (nombreMunitionsEmpoisonnees == 1) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(poisonAttr);
            poisonAttr.remove();
          } else {
            evt.attributes.push({
              attribute: poisonAttr,
              current: poisonAttr.get('current'),
              max: infosPoisonMunitions
            });
            poisonAttr.set('max', seuilMunitionsEmpoisonnees + ' ' + (nombreMunitionsEmpoisonnees - 1));
          }
        }
      }
      munitions--;
      if (randomInteger(100) < options.munition.taux) munitionsMax--;
      if (options.tirDouble) {
        munitions--;
        if (randomInteger(100) < options.munition.taux) munitionsMax--;
      }
      explications.push("Il reste " + munitions + " " +
        options.munition.nom.replace(/_/g, ' ') + " à " + attackerTokName);
      munitionsAttr.set('current', munitions);
      munitionsAttr.set('max', munitionsMax);
    }
    // Armes chargées
    if (options.semonce === undefined && options.tirDeBarrage === undefined) {
      if (chargesArme.length > 0) {
        var currentCharge = parseInt(chargesArme[0].get('current'));
        if (isNaN(currentCharge) || currentCharge < 1) {
          sendChar(attackingCharId, "ne peut pas attaquer avec " + weaponName + " car elle n'est pas chargée");
          return;
        }
        if (options.tirDouble &&
          (!options.tirDouble.stats || options.tirDouble.label == attackLabel) &&
          currentCharge < 2) {
          sendChar(attackingCharId,
            "ne peut pas faire de tir double avec ses" + weaponName + "s car " +
            sujetAttaquant + " n'en a pas au moins 2 chargées");
          return;
        }
        evt.attributes = evt.attributes || [];
        if (attackLabel && options.grenaille) {
          var chargesGrenaille = tokenAttribute(attaquant, 'chargeGrenaille_' + attackLabel);
          if (chargesGrenaille.length > 0) {
            var currentChargeGrenaille = parseInt(chargesGrenaille[0].get('current'));
            if (isNaN(currentChargeGrenaille) || currentChargeGrenaille < 1) {
              sendChar(attackingCharId, "ne peut pas attaquer avec " + weaponName + " car elle n'est pas chargée en grenaille");
              return;
            }
            if (options.tirDouble &&
              (!options.tirDouble.stats || options.tirDouble.label == attackLabel) &&
              currentChargeGrenaille < 2) {
              sendChar(attackingCharId,
                "ne peut pas faire de tir double de grenaille avec ses" + weaponName + "s car " +
                sujetAttaquant + " n'en a pas au moins 2 chargées de grenaille");
              return;
            }
            evt.attributes.push({
              attribute: chargesGrenaille[0],
              current: currentChargeGrenaille
            });
            if (options.tirDouble &&
              (!options.tirDouble.stats || options.tirDouble.label == attackLabel)
            ) currentChargeGrenaille -= 2;
            else currentChargeGrenaille -= 1;
            chargesGrenaille[0].set('current', currentChargeGrenaille);
          }
        }
        evt.attributes.push({
          attribute: chargesArme[0],
          current: currentCharge
        });
        if (options.tirDouble &&
          (!options.tirDouble.stats || options.tirDouble.label == attackLabel)) currentCharge -= 2;
        else currentCharge -= 1;
        chargesArme[0].set('current', currentCharge);
        if (currentCharge === 0 &&
          charAttributeAsInt(attaquant, "initEnMain" + attackLabel, 0) > 0) {
          updateNextInit(attaquant);
        }
      }
      if (options.tirDouble && options.tirDouble.label && options.tirDouble.label != attackLabel) {
        var secondLabel = options.tirDouble.label;
        var secondNom = options.tirDouble.stats.name;
        var chargesSecondeArme = findObjs({
          _type: 'attribute',
          _characterid: attackingCharId,
          name: "charge_" + secondLabel
        });
        if (chargesSecondeArme.length > 0) {
          var currentCharge2 = parseInt(chargesSecondeArme[0].get('current'));
          if (isNaN(currentCharge2) || currentCharge2 < 1) {
            sendChar(attackingCharId, "ne peut pas faire de tir double avec " + secondNom + " car ce n'est pas chargé");
            return;
          }
          evt.attributes = evt.attributes || [];
          if (options.grenaille) {
            var chargesGrenaille2 = tokenAttribute(attaquant, 'chargeGrenaille_' + secondLabel);
            if (chargesGrenaille2.length > 0) {
              var currentChargeGrenaille2 = parseInt(chargesGrenaille2[0].get('current'));
              if (isNaN(currentChargeGrenaille2) || currentChargeGrenaille2 < 1) {
                sendChar(attackingCharId, "ne peut pas faire de tir double avec " + secondNom + " car ce n'est pas chargé en grenaille");
                return;
              }
              evt.attributes.push({
                attribute: chargesGrenaille2[0],
                current: currentChargeGrenaille2
              });
              currentChargeGrenaille2 -= 1;
              chargesGrenaille2[0].set('current', currentChargeGrenaille2);
            }
          }
          evt.attributes.push({
            attribute: chargesSecondeArme[0],
            current: currentCharge2
          });
          chargesArme[0].set('current', currentCharge2 - 1);
          if (currentCharge2 == 1 &&
            charAttributeAsInt(attaquant, "initEnMain" + secondLabel, 0) > 0) {
            updateNextInit(attaquant);
          }
        }
      }
    }
    if (limiteRessources(attaquant, options, attackLabel, weaponName, evt)) {
      return;
    }
    // Effets quand on rentre en combat
    entrerEnCombat(attaquant, cibles, explications, evt);
    // On commence par le jet d'attaque de base : juste le ou les dés d'attaque
    // et le modificateur d'arme et de caractéritiques qui apparaissent dans
    // la description de l'attaque. Il faut quand même tenir compte des
    // chances de critique
    var crit = critEnAttaque(attaquant, weaponStats, options);
    var dice = 20;
    var malusAttaque = 0;
    if (!options.auto) {
      if (estAffaibli(attaquant)) {
        if (charAttributeAsBool(attaquant, 'insensibleAffaibli')) {
          malusAttaque = -2;
          explications.push("Attaquant affaibli, mais insensible => -2 en Attaque");
        } else {
          dice = 12;
          explications.push("Attaquant affaibli => D12 au lieu de D20 en Attaque");
        }
      } else if (getState(attaquant, 'immobilise')) {
        dice = 12;
        explications.push("Attaquant immobilisé => D12 au lieu de D20 en Attaque");
      } else if (attributeAsBool(attaquant, 'mortMaisNAbandonnePas')) {
        dice = 12;
        explications.push("Attaquant mort mais n'abandonne pas => D12 au lieu de D20 en Attaque");
      } else {
        var ebriete = attributeAsInt(attaquant, 'niveauEbriete', 0);
        if (ebriete > 0) {
          if (options.distance || options.sortilege || ebriete > 1) {
            dice = 12;
            if (ebriete > 3) ebriete = 3;
            explications.push("Attaquant " + niveauxEbriete[ebriete] + " => D12 au lieu de D20 en Attaque");
          }
        }
      }
    }
    if (options.avecd12) {
      dice = 12;
      if (options.avecd12.crit) crit = Math.floor(crit / 2) + 3;
    }
    var nbDe = 1;
    var plusFort = true;
    if (options.avantage !== undefined) {
      if (options.avantage > 0) nbDe = options.avantage;
      else {
        nbDe = 2 - options.avantage; //désavantage
        plusFort = false;
      }
    }
    // toEvaluateAttack inlines
    // 0: attack roll
    // 1: attack skill expression
    // 2: dé de poudre
    var toEvaluateAttack =
      attackExpression(attaquant, nbDe, dice, crit, plusFort, weaponStats);
    if (options.poudre) toEvaluateAttack += " [[1d20]]";
    try {
      sendChat(attackerName, toEvaluateAttack, function(resAttack) {
        var rollsAttack = resAttack[0];
        if (options.rolls && options.rolls.attack)
          rollsAttack = options.rolls.attack;
        var afterEvaluateAttack = rollsAttack.content.split(' ');
        var attRollNumber = rollNumber(afterEvaluateAttack[0]);
        var attSkillNumber = rollNumber(afterEvaluateAttack[1]);
        var d20roll = rollsAttack.inlinerolls[attRollNumber].results.total;
        var attSkill = rollsAttack.inlinerolls[attSkillNumber].results.total;
        evt.type = 'Attaque';
        evt.succes = true;
        evt.action.playerId = playerId;
        evt.action.attaquant = attaquant;
        evt.action.cibles = cibles;
        evt.action.weaponStats = weaponStats;
        evt.action.rolls = evt.action.rolls || {};
        evt.action.rolls.attack = rollsAttack;
        // debut de la partie affichage
        var action = "<b>Arme</b> : ";
        if (options.sortilege) action = "<b>Sort</b> : ";
        var label_type = BS_LABEL_INFO;
        var target = cibles[0];
        if (options.aoe || cibles.length > 1) {
          target = undefined;
          label_type = BS_LABEL_WARNING;
        }
        action += "<span style='" + BS_LABEL + " " + label_type + "; text-transform: none; font-size: 100%;'>" + weaponName + "</span>";
        var display = startFramedDisplay(playerId, action, attaquant, {
          perso2: target,
          chuchote: options.secret,
          retarde: options.secret,
          auto: options.auto || options.ouvertureMortelle
        });
        // Cas des armes à poudre
        if (options.poudre && !charAttributeAsBool(attaquant, 'chimiste')) {
          var poudreNumber = rollNumber(afterEvaluateAttack[2]);
          var dePoudre = rollsAttack.inlinerolls[poudreNumber].results.total;
          explications.push(
            "Dé de poudre : " + buildinline(rollsAttack.inlinerolls[poudreNumber]));
          if (dePoudre === 1) {
            evt.succes = false;
            if (d20roll === 1) {
              explications.push(
                weaponName + " explose ! L'arme est complètement détruite");
              sendChat("", "[[2d6]]", function(res) {
                var rolls = res[0];
                var explRoll = rolls.inlinerolls[0];
                var r = {
                  total: explRoll.results.total,
                  type: 'normal',
                  display: buildinline(explRoll, 'normal')
                };
                dealDamage(attaquant, r, [], evt, false, options, explications,
                  function(dmgDisplay, dmg) {
                    var dmgMsg = "<b>Dommages pour " + attackerTokName + " :</b> " +
                      dmgDisplay;
                    addLineToFramedDisplay(display, dmgMsg);
                    finaliseDisplay(display, explications, evt, attaquant, cibles, options);
                  });
              });
            } else {
              explications.push(
                "La poudre explose dans " + weaponName +
                ". L'arme est inutilisable jusqu'à la fin du combat");
              sendChat("", "[[1d6]]", function(res) {
                var rolls = res[0];
                var explRoll = rolls.inlinerolls[0];
                var r = {
                  total: explRoll.results.total,
                  type: 'normal',
                  display: buildinline(explRoll, 'normal')
                };
                dealDamage(attaquant, r, [], evt, false, options, explications,
                  function(dmgDisplay, dmg) {
                    var dmgMsg =
                      "<b>Dommages pour " + attackerTokName + " :</b> " +
                      dmgDisplay;
                    addLineToFramedDisplay(display, dmgMsg);
                    finaliseDisplay(display, explications, evt, attaquant, cibles, options);
                  });
              });
            }
            return;
          } else if (d20roll == dePoudre) {
            evt.succes = false;
            addLineToFramedDisplay(display,
              "<b>Attaque :</b> " +
              buildinline(rollsAttack.inlinerolls[attRollNumber]));
            explications.push(weaponName + " fait long feu, le coup ne part pas");
            finaliseDisplay(display, explications, evt, attaquant, cibles, options);
            return;
          }
        }
        if (!options.auto && d20roll > 14 && charAttributeAsBool(attaquant, 'projection')) {
          options.projection = true;
        }
        //Modificateurs en Attaque qui ne dépendent pas de la cible
        var attBonusCommun =
          bonusAttaqueA(attaquant, weaponName, evt, explications, options);
        attBonusCommun += malusAttaque;
        if (options.traquenard) {
          if (attributeAsInt(attaquant, 'traquenard', 0) === 0) {
            sendChar(attackingCharId, "ne peut pas faire de traquenard, car ce n'est pas sa première attaque du combat");
            return;
          }
          options.traquenard = persoInit(attaquant, evt);
        }
        if (attributeAsInt(attaquant, 'traquenard', 0) > 0) {
          setTokenAttr(attaquant, 'traquenard', 0, evt);
        }
        if (options.feinte) explications.push("Mais c'était une feinte...");
        var mainDmgType = options.type || 'normal';
        if (options.sortilege) options.ignoreObstacles = true;
        var echecCritique;
        //Calcul des cibles touchées
        //(et on ajuste le jet pour la triche)
        var ciblesTouchees = [];
        var count = cibles.length;
        cibles.forEach(function(target) {
          // reset les champs de target qui vont être recalculés
          target.additionalDmg = [];
          target.dmgCoef = 0;
          target.critCoef = 0;
          target.diviseDmg = 1;
          if (attributeAsBool(attaquant, 'menaceManoeuvre(' + target.token.id + ')')) {
            explications.push(attaquant.tokName + " attaque " + target.tokName + " malgré la menace. " + target.tokName + " a droit à une attaque au contact gratuite.");
            removeTokenAttr(attaquant, 'menaceManoeuvre(' + target.token.id + ')', evt);
            setTokenAttr(attaquant, 'attaqueMalgreMenace(' + target.token.id + ')', 1, evt);
          } else if (attributeAsBool(attaquant, 'menaceManoeuvre(' + target.token.id + ',crit)')) {
            explications.push(attaquant.tokName + " attaque " + target.tokName + " malgré la menace. " + target.tokName + " a droit à une attaque au contact gratuite (DM x 2 !).");
            removeTokenAttr(attaquant, 'menaceManoeuvre(' + target.token.id + ',crit)', evt);
            setTokenAttr(attaquant, 'attaqueMalgreMenace(' + target.token.id + ')', 2, evt);
          }
          var amm = 'attaqueMalgreMenace(' + attaquant.token.id + ')';
          if (options.contact && cibles.length == 1) {
            if (attributeAsBool(target, amm)) {
              target.messages.push('Attaque automatique suite à une menace ignorée');
              options.auto = true;
              if (attributeAsInt(target, amm, 1) > 1) options.dmFoisDeux = true;
              target.additionalDmg.push({
                type: mainDmgType,
                value: '1d6'
              });
              removeTokenAttr(target, amm, evt);
            } else if (attributeAsBool(attaquant, 'attaqueGratuiteAutomatique(' + target.token.id + ')')) {
              options.auto = true;
              removeTokenAttr(attaquant, 'attaqueGratuiteAutomatique(' + target.token.id + ')', evt);
            }
          }
          evalITE(attaquant, target, d20roll, options, 0, evt, explications, options, function() {
            target.ignoreTouteRD = target.ignoreTouteRD || options.ignoreTouteRD;
            target.ignoreRD = target.ignoreRD || options.ignoreRD;
            target.ignoreMoitieRD = target.ignoreMoitieRD || options.ignoreMoitieRD;
            target.tempDmg = target.tempDmg || options.tempDmg;
            target.enflamme = target.enflamme || options.enflamme;
            target.malediction = target.malediction || options.malediction;
            target.pietine = target.pietine || options.pietine;
            target.percute = target.percute || options.percute;
            target.maxDmg = target.maxDmg || options.maxDmg;
            //Les bonus d'attaque qui dépendent de la cible
            var bad = 0;
            if (!options.auto) bad = bonusAttaqueD(attaquant, target, weaponStats.portee, pageId, evt, target.messages, options);
            var attBonus = attBonusCommun + bad;
            if (options.traquenard) {
              var initTarg = persoInit(target, evt);
              if (options.traquenard >= initTarg) {
                attBonus += 2;
                target.additionalDmg.push({
                  type: mainDmgType,
                  value: '2' + options.d6
                });
                target.messages.push(attackerTokName + " fait un traquenard à " + target.tokName);
              } else {
                target.messages.push(attackerTokName + " n'est pas assez rapide pour faire un traquenard à " + target.tokName);
              }
            }
            var defautCuirasse =
              tokenAttribute(target, 'defautDansLaCuirasse_' + attackerTokName);
            target.crit = crit;
            if (defautCuirasse.length > 0) {
              target.defautCuirasse = true;
              if (target.crit > 2) target.crit -= 1;
            }
            //Defense de la cible
            var defense = 0;
            if (!options.auto) defense = defenseOfPerso(attaquant, target, pageId, evt, options);
            var interchange;
            if (options.aoe === undefined) {
              interchange = interchangeable(attackingToken, target, pageId);
              if (interchange.result) {
                if (reglesOptionelles.divers.val.interchangeable_attaque.val) {
                  defense += 2;
                } else {
                  defense += 5;
                }
              }
            }
            if (target.msgEsquiveFatale) {
              target.messages.push(target.msgEsquiveFatale);
            }
            if (options.etreinteImmole && attributeAsBool(target, 'etreinteImmolePar')) {
              options.auto = true;
              target.etreinteImmole = true;
            }
            var touche = true;
            var critique = false;
            // Calcule si touché, et les messages de dégats et attaque
            if (options.auto) {
              addAttackSound("soundAttackSucces", weaponStats.divers, options);
            } else if (!options.interposer) {
              if (options.triche || options.interventionDivine) {
                var triche = options.triche || options.interventionDivine;
                switch (triche) {
                  case "rate":
                    if (d20roll >= target.crit) {
                      if (target.crit < 2) d20roll = 1;
                      else d20roll = randomInteger(target.crit - 1);
                    }
                    if ((d20roll + attSkill + attBonus) >= defense) {
                      var maxd20roll = defense - attSkill - attBonus - 1;
                      if (maxd20roll >= target.crit) maxd20roll = target.crit - 1;
                      if (maxd20roll < 2) d20roll = 1;
                      else d20roll = randomInteger(maxd20roll);
                    }
                    break;
                  case "touche":
                    if (d20roll == 1) d20roll = randomInteger(dice - 1) + 1;
                    if ((d20roll + attSkill + attBonus) < defense) {
                      var mind20roll = defense - attSkill - attBonus - 1;
                      if (mind20roll < 1) mind20roll = 1;
                      if (mind20roll >= dice) d20roll = dice;
                      else d20roll = randomInteger(dice - mind20roll) + mind20roll;
                    }
                    break;
                  case "critique":
                    if (d20roll < target.crit) {
                      if (target.crit <= dice) d20roll = randomInteger(dice - target.crit + 1) + target.crit - 1;
                      else d20roll = dice;
                    }
                    break;
                  case "echecCritique":
                    if (d20roll > 1) d20roll = 1;
                    break;
                  default:
                    error("Option inconnue", triche);
                }
                // now adjust the roll
                var attackInlineRoll = rollsAttack.inlinerolls[attRollNumber];
                attackInlineRoll.results.total = d20roll;
                attackInlineRoll.results.rolls.forEach(function(roll) {
                  if (roll.type == 'R' && roll.results.length == 1) {
                    roll.results[0].v = d20roll;
                  }
                });
              }
              var attackRoll = d20roll + attSkill + attBonus;
              target.attackRoll = attackRoll;
              var attackResult; // string
              var paralyse = false;
              if (getState(target, 'paralyse')) {
                paralyse = true;
                if (!options.attaqueAssuree)
                  target.messages.push("Cible paralysée => réussite critique automatique");
              }
              if (d20roll >= 15) {
                if (charAttributeAsBool(attaquant, 'champion'))
                  options.champion = true;
                if (options.contact && charAttributeAsBool(attaquant, 'agripper'))
                  options.agripper = true;
                if (options.etreinteImmole) {
                  setTokenAttr(attaquant, 'etreinteImmole', target.token.id + ' ' + target.tokName, evt);
                  setTokenAttr(target, 'etreinteImmolePar', attaquant.token.id + ' ' + attaquant.tokName, evt);
                  setState(target, 'immobilise', true, evt);
                  target.messages.push(attaquant.tokName + " étreint " + target.tokName + " et s'immole !");
                  target.etreinteImmole = true;
                }
              }
              if (d20roll >= 17 && options.contact &&
                charAttributeAsBool(attaquant, 'crocEnJambe')) {
                if (d20roll >= 19 || !estQuadrupede(target)) {
                  setState(target, 'renverse', true, evt);
                  target.messages.push("tombe par terre");
                }
              }
              if (options.attaqueDeGroupe > 1 &&
                reglesOptionelles.haute_DEF.val.crit_attaque_groupe.val > 0 &&
                attackRoll >= (defense + reglesOptionelles.haute_DEF.val.crit_attaque_groupe.val)) {
                options.attaqueDeGroupeDmgCoef = true;
              }
              if (d20roll == 1 && options.chance === undefined) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_DANGER + "'><b>échec&nbsp;critique</b></span>";
                attackResult += addAttackImg("imgAttackEchecCritique", weaponStats.divers, options);
                addAttackSound("soundAttackEchecCritique", weaponStats.divers, options);
                if (options.demiAuto) {
                  target.partialSaveAuto = true;
                  evt.succes = false;
                } else touche = false;
                echecCritique = true;
              } else if ((paralyse || options.ouvertureMortelle || d20roll == 20 ||
                  (d20roll >= target.crit && attackRoll >= defense)) && !options.attaqueAssuree) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>réussite critique</b></span>";
                attackResult += addAttackImg("imgAttackSuccesCritique", weaponStats.divers, options);
                addAttackSound("soundAttackSuccesCritique", weaponStats.divers, options);
                touche = true;
                critique = true;
                if (attributeAsBool(target, 'enerve')) {
                  var faireMouche = charAttributeAsInt(attaquant, 'faireMouche', 0);
                  if (faireMouche > 0) {
                    target.additionalDmg.push({
                      type: mainDmgType,
                      value: faireMouche + options.d6
                    });
                    target.messages.push(attaquant.tokName + " profite de l'ouverture et sont attaque fait mouche !");
                  }
                }
              } else if (options.champion || d20roll == 20 || paralyse) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succès</b></span>";
                attackResult += addAttackImg("imgAttackSuccesChampion", weaponStats.divers, options);
                addAttackSound("soundAttackSuccesChampion", weaponStats.divers, options);
              } else if (attackRoll < defense && d20roll < target.crit) {
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>échec</b></span>";
                attackResult += addAttackImg("imgAttackEchec", weaponStats.divers, options);
                addAttackSound("soundAttackEchec", weaponStats.divers, options);
                evt.succes = false;
                if (options.demiAuto) {
                  target.partialSaveAuto = true;
                } else touche = false;
              } else if (d20roll % 2 && attributeAsBool(target, 'clignotement')) {
                target.messages.push(target.tokName + " disparaît au moment où l'attaque aurait du l" + onGenre(target, 'e', 'a') + " toucher");
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>échec</b></span>";
                attackResult += addAttackImg("imgAttackEchecClignotement", weaponStats.divers, options);
                addAttackSound("soundAttackEchecClignotement", weaponStats.divers, options);
                target.clignotement = true;
                if (options.demiAuto) {
                  target.partialSaveAuto = true;
                } else touche = false;
              } else { // Touché normal
                attackResult = " => <span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succès</b></span>";
                attackResult += addAttackImg("imgAttackSucces", weaponStats.divers, options);
                addAttackSound("soundAttackSucces", weaponStats.divers, options);
              }

              var attRollValue;
              var bonusTexte = '';
              if (attSkill > 0) bonusTexte += "+" + attSkill;
              else if (attSkill < 0) bonusTexte += attSkill;
              if (attBonus > 0) bonusTexte += "+" + attBonus;
              else if (attBonus < 0) bonusTexte += attBonus;
              if (ficheAttributeAsBool(attaquant, 'jets_caches', false)) {
                attRollValue = attackRoll;
                sendChat('COF', "/w GM Jet caché d'attaque : " + buildinline(rollsAttack.inlinerolls[attRollNumber]) + bonusTexte);
              } else {
                attRollValue = buildinline(rollsAttack.inlinerolls[attRollNumber]) + bonusTexte;
              }
              var line = "<b>Attaque</b> ";
              if (options.aoe || cibles.length > 1) {
                line += "contre <b>" + target.tokName + "</b> ";
              }
              line += ":<br>";
              line += attRollValue + ' ';
              if (stateCOF.options.affichage.val.montre_def.val) {
                line += "vs <b>" + defense + "</b> ";
              }
              line += attackResult;
              if (options.test) line += " (" + attackRoll + ")";
              target.attackMessage = line;
              if (touche) {
                if (options.asDeLaGachette && attackRoll > 24) {
                  target.messages.push("As de la gachette => + 1" + options.d6 + " aux DM");
                  target.additionalDmg.push({
                    type: mainDmgType,
                    value: '1' + options.d6
                  });
                }
                if (options.contact && attackRoll > defense + 9 &&
                  charAttributeAsBool(attaquant, 'botteMortelle')) {
                  target.messages.push("Botte mortelle => + 2" + options.d6 + " aux DM");
                  target.additionalDmg.push({
                    type: mainDmgType,
                    value: '2' + options.d6
                  });
                }
                if (attributeAsBool(target, 'momentDePerfection')) {
                  target.messages.push("Grâce à son instant de perfection, " + target.tokName + " évite le coup !");
                  touche = false;
                  evt.succes = false;
                }
              } else { //Effet si on ne touche pas
                if (attributeAsBool(attaquant, 'momentDePerfection')) {
                  target.messages.push("Grâce à son instant de perfection, " + attaquant.tokName + " touche !");
                  touche = true;
                  evt.succes = true;
                } else {
                  // Draw failed effect
                  if (_.has(options, "fx") && options.distance) {
                    var p1 = {
                      x: attackingToken.get('left'),
                      y: attackingToken.get('top')
                    };
                    var p2 = {
                      x: target.token.get('left'),
                      y: target.token.get('top')
                    };
                    // Compute some gaussian deviation in [0, 1]
                    var dev =
                      (Math.random() + Math.random() + Math.random() + Math.random() +
                        Math.random() + 1) / 6;
                    // take into account by how far we miss
                    dev = dev * (d20roll == 1) ? 2 : ((attackRoll - defense) / 20);
                    if (Math.random() > 0.5) dev = -dev;
                    p2.x += dev * (p2.y - p1.y);
                    p2.y += dev * (p2.x - p1.x);
                    spawnFxBetweenPoints(p1, p2, options.fx, pageId);
                  }
                  if (target.clignotement === undefined) {
                    evt.succes = false;
                    diminueMalediction(attaquant, evt);
                  }
                }
              }
            }
            target.touche = touche;
            target.critique = critique;
            target.attaqueCalculee = true;
            if (options.aoe === undefined && interchange.targets.length > 1) { //any target can be affected
              var n = randomInteger(interchange.targets.length);
              target.token = interchange.targets[n - 1];
            }
            if (target.touche) {
              if (attributeAsBool(target, 'imageDecalee')) {
                if (target.rollImageDecalee === undefined) {
                  target.rollImageDecalee = rollDePlus(6);
                }
                var id = target.rollImageDecalee;
                if (id.val > 4) {
                  target.touche = false;
                  target.messages.push(id.roll + ": l'attaque passe à travers l'image de " + target.tokName);
                } else {
                  target.messages.push(id.roll + ": malgré l'image légèrement décalée de " + target.tokName + " l'attaque touche");
                }
              } else if (charAttributeAsBool(target, 'estUneIllusion')) {
                target.touche = false;
                target.messages.push(target.tokName + " disparait et se matérialise un peu plus loin");
              }
            }
            if (target.touche) {
              ciblesTouchees.push(target);
              //Possibilités d'annuler l'attaque
              if (!options.pasDeDmg && isActive(target) &&
                attributeAsBool(target, 'runeForgesort_protection') &&
                attributeAsInt(target, 'limiteParCombat_runeForgesort_protection', 1) > 0) {
                options.preDmg = options.preDmg || {};
                options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                options.preDmg[target.token.id].runeForgesort_protection = true;
              }
              if (!options.auto) {
                //Seulement si elle n'est pas automatiquement réussie
                if (isActive(target)) {
                  if (!options.pasDeDmg && options.contact &&
                    !options.ignoreTouteRD &&
                    attributeAsBool(target, 'encaisserUnCoup')) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].encaisserUnCoup = true;
                  }
                  if (options.distance && !options.sortilege && !options.poudre && cibles.length == 1 && !target.critique &&
                    attributeAsBool(target, 'paradeDeProjectiles')) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].paradeDeProjectiles = true;
                  }
                  if (attributeAsInt(target, 'esquiveAcrobatique', 0) > 0) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].esquiveAcrobatique = true;
                  }
                  if (!options.sortilege && !options.aoe && attributeAsInt(target, 'paradeMagistrale', 0) > 0) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].paradeMagistrale = true;
                  }
                  if (!options.aoe && attributeAsInt(target, 'esquiveFatale', 0) > 0) {
                    if (target.ennemisAuContact === undefined) {
                      error(target.token.get('name') + " a la possibilité d'une esquive fatale, mais les ennemis au contact ne sont pas calculés", target);
                    } else {
                      var ciblesEsquiveFatale = target.ennemisAuContact.filter(function(tok) {
                        return (tok.id != attaquant.token.id);
                      });
                      if (ciblesEsquiveFatale.length > 0) {
                        options.preDmg = options.preDmg || {};
                        options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                        options.preDmg[target.token.id].esquiveFatale = ciblesEsquiveFatale;
                      }
                    }
                  }
                  if (options.sortilege) {
                    if (attributeAsInt(target, 'absorberUnSort', 0) > 0 &&
                      ficheAttributeAsInt(target, 'DEFBOUCLIERON', 1) == 1) {
                      options.preDmg = options.preDmg || {};
                      options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                      options.preDmg[target.token.id].absorberUnSort = true;
                    }
                  } else {
                    if (attributeAsInt(target, 'absorberUnCoup', 0) > 0 &&
                      ficheAttributeAsInt(target, 'DEFBOUCLIERON', 1) == 1) {
                      options.preDmg = options.preDmg || {};
                      options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                      options.preDmg[target.token.id].absorberUnCoup = true;
                    }
                  }
                }
                if (options.sortilege) {
                  if (attributeAsInt(target, 'resistanceALaMagieBarbare', 0) > 0) {
                    options.preDmg = options.preDmg || {};
                    options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                    options.preDmg[target.token.id].resistanceALaMagieBarbare = true;
                  }
                  if (attributeAsBool(target, 'cercleDeProtection')) {
                    var attrs = tokenAttribute(target, 'cercleDeProtectionValeur');
                    if (attrs.length > 0) {
                      var protecteur = persoOfId(attrs[0].get('current'));
                      if (protecteur) {
                        if (attributeAsInt(protecteur, "cercleDeProtectionActif", 0) > 0) {
                          options.preDmg = options.preDmg || {};
                          options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                          options.preDmg[target.token.id].cercleDeProtection = true;
                          options.preDmg[target.token.id].cercleDeProtectionDe = protecteur.token.get("name");
                        }
                      }
                    }
                  }
                }
              }
              if (attributeAsInt(target, 'chairACanon', 0) > 0 &&
                target.chairACanon && target.chairACanon.length > 0) {
                options.preDmg = options.preDmg || {};
                options.preDmg[target.token.id] = options.preDmg[target.token.id] || {};
                options.preDmg[target.token.id].chairACanon = target.chairACanon;
              }
            }
            if (options.feinte) {
              setTokenAttr(target, 'feinte_' + attaquant.tokName, 0, evt, {
                maxVal: target.touche
              });
            }
            count--;
            if (count === 0) {
              resolvePreDmgOptions(attaquant, ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles);
            }
          });
        }); //fin de détermination de toucher des cibles
      }); // fin du jet d'attaque asynchrone
    } catch (e) {
      error("Erreur pendant l'évaluation de " + toEvaluateAttack + " du test d'attaque", weaponStats);
      log(e.name + ": " + e.message);
    }
  }

  function eForFemale(perso) {
    return onGenre(perso, '', 'e');
  }

  function stringOfEtat(etat, perso) {
    if (etat == 'invisible') return etat;
    else if (etat == 'penombre') return "dans la pénombre";
    var etext = etat;
    if (etat.endsWith('e')) {
      etext = etat.substring(0, etat.length - 1) + 'é';
    }
    if (perso === undefined) return etext;
    return etext + eForFemale(perso);
  }

  function findAttackParam(attackParam, divers, options) {
    var param = options[attackParam];
    if (param) return param;
    var subParam = attackParam;
    var subParamIndex = subParam.indexOf('C');
    if (subParamIndex > 0) {
      subParam = subParam.substring(0, subParamIndex);
      param = options[subParam];
      if (param) return param;
    }
    subParamIndex = subParam.indexOf('E');
    if (subParamIndex > 0) {
      subParam = subParam.substring(0, subParamIndex);
      param = options[subParam];
      if (param) return param;
    }
    subParamIndex = subParam.indexOf('S');
    if (subParamIndex > 0) {
      subParam = subParam.substring(0, subParamIndex);
      param = options[subParam];
      if (param) return param;
    }
    var tag = attackParam.replace(/[A-Z]/g, function(c) {
      return '-' + c.toLowerCase();
    });
    tag = '[' + tag + ']';
    if (divers.includes(tag)) {
      var soundAttack = divers.split(tag);
      if (soundAttack.length > 2) {
        param = soundAttack[1];
      }
    }
    return param;
  }

  function playSound(sound) {
    var AMdeclared;
    try {
      AMdeclared = Roll20AM;
    } catch (e) {
      if (e.name != "ReferenceError") throw (e);
    }
    if (AMdeclared) {
      //With Roll20 Audio Master
      sendChat("GM", "!roll20AM --audio,play,nomenu|" + sound);
    } else {
      var jukebox = findObjs({
        type: 'jukeboxtrack',
        title: sound
      });
      jukebox.forEach(function(track) {
        track.set({
          playing: true,
          softstop: false
        });
      });
    }
  }

  function addAttackSound(attackParam, divers, options) {
    var sound = findAttackParam(attackParam, divers, options);
    if (sound) playSound(sound);
  }

  function addAttackImg(attackParam, divers, options) {
    var img = findAttackParam(attackParam, divers, options);
    if (img !== "" && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
      var newLineimg = '<span style="padding: 4px 0;" >  ';
      newLineimg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
      newLineimg += '</span>';
      return newLineimg;
    }
    return '';
  }

  function computeAttackDice(d, maxDmg, options) {
    if (isNaN(d) || d < 0) {
      error("Dé d'attaque incorrect", d);
      return 0;
    }
    var attDice = d;
    if (options.puissant) {
      attDice += 2;
    }
    if (maxDmg) return attDice; //Dans ce cas, pas de reroll ni d'explosion
    if (options.reroll1) attDice += "r1";
    if (options.reroll2) attDice += "r2";
    if (options.explodeMax) attDice += '!';
    else if (options.poudre && reglesOptionelles.divers.val.poudre_explosif.val) attDice += '!p';
    return attDice;
  }

  function computeMainDmgRollExpr(attaquant, target, weaponStats, attNbDices, attDMBonus, options) {
    var attDMArme = weaponStats.attDMBonusCommun;
    if (isNaN(attDMArme) || attDMArme === 0) attDMArme = '';
    else if (attDMArme > 0) attDMArme = '+' + attDMArme;
    attDMBonus = attDMArme + attDMBonus;
    var attNbDicesCible = attNbDices;
    var attDiceCible = computeAttackDice(weaponStats.attDice, target.maxDmg, options);
    var attCarBonusCible =
      computeAttackCarBonus(attaquant, weaponStats.attCarBonus);
    if (options.epieu && !ficheAttributeAsBool(target, 'DEFARMUREON', false)) {
      attNbDicesCible++;
    }
    if (target.pressionMortelle) {
      attNbDicesCible = 1;
      attDiceCible = 6; //TODO : have an option for that
      attCarBonusCible = '';
    }
    if (!options.sortilege && charAttributeAsBool(target, 'immuniteAuxArmes')) {
      if (options.magique) {
        attNbDicesCible = options.magique;
        attDiceCible = '6';
        attCarBonusCible = modCarac(attaquant, 'sagesse');
        if (attCarBonusCible < 1) attCarBonusCible = '';
        else attCarBonusCible = " +" + attCarBonusCible;
      } else {
        target.messages.push(target.tokName + " semble immunisé aux armes ordinaires");
        attNbDicesCible = 0;
        attCarBonusCible = "";
        attDMBonus = "";
      }
    }
    var symbde = 'd';
    if (target.maxDmg) symbde = '*';
    return addOrigin(attaquant.name, attNbDicesCible + symbde + attDiceCible + attCarBonusCible + attDMBonus);
  }

  //retourne le mod de la caractéristique x, undefined si ce n'en est pas une
  function computeCarExpression(perso, x) {
    switch (x) {
      case '@{FOR}':
        return modCarac(perso, 'force');
      case '@{DEX}':
        return modCarac(perso, 'dexterite');
      case '@{CON}':
        return modCarac(perso, 'constitution');
      case '@{INT}':
        return modCarac(perso, 'intelligence');
      case '@{SAG}':
        return modCarac(perso, 'sagesse');
      case '@{CHA}':
        return modCarac(perso, 'charisme');
      default:
        return;
    }
  }

  function addEffetTemporaireLie(perso, attr, evt) {
    var etlAttr = tokenAttribute(perso, 'effetsTemporairesLies');
    if (etlAttr.length === 0) {
      etl = '';
      etlAttr = createObj('attribute', {
        characterid: perso.charId,
        name: 'effetsTemporairesLies',
        current: attr.id,
      });
      evt.attributes.push({
        attribute: etlAttr,
        current: null
      });
      return;
    }
    etlAttr = etlAttr[0];
    var etl = etlAttr.get('current');
    evt.attributes.push({
      attribute: etlAttr,
      current: etl
    });
    if (etl === '') etl = attr.id;
    else etl += ',' + attr.id;
    etlAttr.set('current', etl);
  }

  function computeAttackCarBonus(attaquant, x) {
    if (x === undefined) return '';
    var attCarBonus = x;
    if (isNaN(attCarBonus)) {
      var simplerAttCarBonus = computeCarExpression(attaquant, x);
      if (simplerAttCarBonus !== undefined) {
        attCarBonus = simplerAttCarBonus;
      }
    }
    if (attCarBonus === "0" || attCarBonus === 0) attCarBonus = "";
    else attCarBonus = " + " + attCarBonus;
    return attCarBonus;
  }

  function setEffetTemporaire(target, ef, duree, attaquant, pageId, evt, options) {
    if (ef.effet == 'dedoublement') {
      if (attributeAsBool(target, 'dedouble') ||
        attributeAsBool(target, 'dedoublement')) {
        if (ef.whisper !== undefined) {
          if (ef.whisper === true) {
            whisperChar(target.charId, "a déjà été dédoublé pendant ce combat");
          } else {
            sendChar(target.charId, ef.whisper + " a déjà été dédoublé pendant ce combat");
          }
        } else {
          target.messages.push(target.tokName + " a déjà été dédoublé pendant ce combat");
        }
        return;
      }
      var dedoubleMsg =
        "Un double translucide de " + target.tokName + " apparaît.";
      if (attaquant) {
        if (attaquant.tokName === undefined) attaquant.tokName = attaquant.token.get('name');
        dedoubleMsg += " Il est aux ordres de " + attaquant.tokName;
      }
      if (stateCOF.options.affichage.val.duree_effets.val) dedoubleMsg += " (" + duree + " tours)";
      if (ef.whisper !== undefined) {
        if (ef.whisper === true) {
          whisperChar(target.charId, dedoubleMsg);
        } else {
          sendChar(target.charId, ef.whisper + dedoubleMsg);
        }
      } else {
        target.messages.push(dedoubleMsg);
      }
      setTokenAttr(target, 'dedouble', true, evt);
      copieToken(target, undefined, stateCOF.options.images.val.image_double.val,
        "Double de " + target.tokName, 'dedoublement', duree,
        pageId, evt);
      return;
    }
    if (ef.effet == 'saignementsSang' && charAttributeAsBool(target, 'immuniteSaignement')) {
      if (ef.whisper !== undefined) {
        if (ef.whisper === true) {
          whisperChar(target.charId, "ne peut pas saigner");
        } else {
          sendChar(target.charId, ef.whisper + "ne peut pas saigner");
        }
      } else {
        target.messages.push(target.tokName + " ne peut pas saigner");
      }
      return;
    }
    if (ef.duree) {
      if (ef.typeDmg && (!ef.message || !ef.message.dm) && charAttributeAsBool(target, 'diviseEffet_' + ef.typeDmg)) {
        duree = Math.ceil(duree / 2);
      }
      if (ef.accumuleDuree) {
        if (ef.accumuleDuree > 1 && attributeAsBool(target, ef.effet)) {
          var accumuleAttr = tokenAttribute(target, ef.effet + 'DureeAccumulee');
          if (accumuleAttr.length === 0) {
            setTokenAttr(target, ef.effet + 'DureeAccumulee', duree, evt);
          } else {
            accumuleAttr = accumuleAttr[0];
            var dureeAccumulee = accumuleAttr.get('current') + '';
            if (dureeAccumulee.split(',').length < ef.accumuleDuree - 1) {
              evt.attributes = evt.attributes || [];
              evt.attributes.push({
                attribute: accumuleAttr,
                current: dureeAccumulee
              });
              accumuleAttr.set('current', duree + ',' + dureeAccumulee);
            }
          }
          return; //Pas besoin de réappliquer, effet toujours en cours
        }
      }
      var targetMsg = '';
      if (ef.message && !ef.pasDeMessageDActivation) {
        var msgAct = messageActivation(target, ef.message);
        if (ef.whisper === undefined) {
          targetMsg = target.tokName + " " + msgAct;
        } else if (ef.whisper !== true) {
          targetMsg = ef.whisper + msgAct;
        }
        if (stateCOF.options.affichage.val.duree_effets.val) targetMsg += " (" + duree + " tours)";
        var img = ef.image;
        if (img !== "" && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
          var newLineimg = '<span style="padding: 4px 0;" >  ';
          newLineimg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
          newLineimg += '</span>';
          targetMsg += newLineimg;
        }
        if (ef.whisper === undefined) {
          target.messages.push(targetMsg);
          targetMsg = undefined;
        }
      }
      var attrEffet = setAttrDuree(target, ef.effet, duree, evt, targetMsg);
      if (attaquant && options.mana !== undefined && ef.message && ef.message.prejudiciable) {
        addEffetTemporaireLie(attaquant, attrEffet, evt);
      }
      switch (ef.effet) {
        case 'apeureTemp':
          setState(target, 'apeure', true, evt);
          break;
        case 'aveugleTemp':
          setState(target, 'aveugle', true, evt);
          break;
        case 'ralentiTemp':
          setState(target, 'ralenti', true, evt);
          break;
        case 'paralyseTemp':
          setState(target, 'paralyse', true, evt);
          break;
        case 'immobiliseTemp':
          setState(target, 'immobilise', true, evt);
          break;
        case 'etourdiTemp':
          setState(target, 'etourdi', true, evt);
          break;
        case 'affaibliTemp':
          setState(target, 'affaibli', true, evt);
          break;
        case 'assomeTemp':
          setState(target, 'assome', true, evt);
          break;
        case 'aspectDuDemon':
          //On retire l'autre aspect du Nécromancien si il est présent
          finDEffetDeNom(target, "aspectDeLaSuccube", evt);
          break;
        case 'aspectDeLaSuccube':
          finDEffetDeNom(target, "aspectDuDemon", evt);
          break;
        case 'peauDePierreMag':
          if (ef.valeur === undefined) {
            var rd = 5 + modCarac(target, 'intelligence');
            var absorbe = 40;
            if (options.tempeteDeManaIntence) {
              rd += options.tempeteDeManaIntense;
              absorbe += options.tempeteDeManaIntense * 5;
            }
            setTokenAttr(target, 'peauDePierreMagValeur', rd, evt, {
              maxVal: absorbe
            });
          }
          break;
      }
      if (ef.message && ef.message.statusMarker) {
        affectToken(target.token, 'statusmarkers', target.token.get('statusmarkers'), evt);
        target.token.set('status_' + ef.message.statusMarker, true);
      }
    } else if (ef.effetIndetermine) {
      target.messages.push(target.tokName + " " + messageEffetIndetermine[ef.effet].activation);
      setTokenAttr(target, ef.effet, true, evt);
    } else { //On a un effet de combat
      var effetC = messageEffetCombat[ef.effet];
      target.messages.push(target.tokName + " " + effetC.activation);
      var attrEffetCombat = setTokenAttr(target, ef.effet, true, evt);
      if (attaquant && options.mana !== undefined && effetC.prejudiciable) {
        addEffetTemporaireLie(attaquant, attrEffetCombat, evt);
      }
    }
    if (ef.valeur !== undefined) {
      setTokenAttr(target, ef.effet + 'Valeur', ef.valeur, evt, {
        maxVal: ef.valeurMax
      });
    }
    if (options.tempeteDeManaIntense)
      setTokenAttr(target, ef.effet + 'TempeteDeManaIntense', options.tempeteDeManaIntense, evt);
    if (ef.saveParTour) {
      setTokenAttr(target, ef.effet + 'SaveParTour',
        ef.saveParTour.carac, evt, {
          maxVal: ef.saveParTour.seuil
        });
      if (ef.typeDmg)
        setTokenAttr(target, ef.effet + 'SaveParTourType', ef.typeDmg, evt);
    }
  }

  // Applique toutes les options de preDmg déjà sélectionnées
  // Retourne vrai si l'option "continuer" a déjà été choisie
  function resolvePreDmgOptions(attaquant, ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles) {
    //Sauvegarde de l'état pour pouvoir relancer au niveau de cette fonction
    evt.action.currentOptions = options;
    evt.action.echecCritique = echecCritique;
    evt.action.attackLabel = attackLabel;
    evt.action.attackd20roll = d20roll;
    evt.action.display = JSON.parse(JSON.stringify(display));
    evt.action.display.perso1 = display.perso1;
    evt.action.display.perso2 = display.perso2;
    evt.action.explications = JSON.parse(JSON.stringify(explications));
    evt.action.pageId = pageId;
    evt.action.ciblesTouchees = ciblesTouchees;
    evt.action.choices = options.choices;
    if (evt.action.choices === undefined) {
      if (options.preDmg) {
        addLineToFramedDisplay(display, "<b>Attaque :</b> Touche !");
        finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique);
        return;
      } else {
        attackDealDmg(attaquant, evt.action.ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles);
        return;
      }
    }
    var continuer = evt.action.choices.Continuer;
    var nbCibles = ciblesTouchees.length;
    ciblesTouchees.forEach(function(cible) {
      var finaliseTarget = function() {
        nbCibles--;
        if (nbCibles === 0) {
          if (continuer) {
            delete options.preDmg;
          }
          if (options.preDmg || options.preDmgAnnule) {
            addLineToFramedDisplay(display, "<b>Attaque :</b> Touche !");
            finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique);
            return;
          } else {
            attackDealDmg(attaquant, evt.action.ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles);
          }
        }
      };
      var preDmgToken = evt.action.choices[cible.token.id];
      if (preDmgToken !== undefined) {
        var termineCible = false;
        if (preDmgToken.encaisserUnCoup) {
          appliquerEncaisserUnCoup(cible, options, evt);
          finaliseTarget();
        }
        if (preDmgToken.paradeDeProjectiles) {
          appliquerParadeProjectiles(cible, options, evt);
          explications.push(cible.token.get("name") + " pare le projectile !");
          options.preDmgAnnule = true;
          finaliseTarget();
        }
        if (preDmgToken.runeForgesort_protection) {
          appliquerRuneDeProtection(cible, options, evt);
          finaliseTarget();
        }
        if (preDmgToken.evitementGenerique && preDmgToken.evitementGenerique.length > 0) {
          var nbEvitementsGenerique = preDmgToken.evitementGenerique.length;
          var finaliseTargetPreDmg = function(msg, generalMsg) {
            if (generalMsg !== '' && !continuer && !termineCible) { // rerolls uniquement si pas terminé
              explications.push(msg + generalMsg);
            } else {
              cible.messages.push(msg);
            }
            nbEvitementsGenerique--;
            if (nbEvitementsGenerique === 0) {
              finaliseTarget();
            }
          };
          preDmgToken.evitementGenerique.forEach(function(evitementGenerique) {
            appliquerEvitementGenerique(cible, evitementGenerique.jetAdversaire, evitementGenerique.attribut,
              evitementGenerique.opt, evitementGenerique.attributeName, evitementGenerique.actionName,
              evitementGenerique.tente, evitementGenerique.carac, evitementGenerique.typeAttaque,
              evitementGenerique.msgReussite, pageId, options, evt, finaliseTargetPreDmg);
          });
        } else {
          finaliseTarget();
        }
      } else {
        finaliseTarget();
      }
    });
  }

  function attackDealDmg(attaquant, ciblesTouchees, echecCritique, attackLabel, weaponStats, d20roll, display, options, evt, explications, pageId, cibles) {
    if (cibles.length > ciblesTouchees.length) {
      cibles.forEach(function(target) {
        if (options.test || options.feinte || !target.touche) {
          //On a fini avec cette cible, on imprime ce qui la concerne
          if (target.attackMessage)
            addLineToFramedDisplay(display, target.attackMessage);
          target.messages.forEach(function(expl) {
            addLineToFramedDisplay(display, expl, 80);
          });
        }
      });
    }
    if (ciblesTouchees.length === 0 || options.test || options.feinte) {
      finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique);
      if (echecCritique) {
        if (stateCOF.options.affichage.val.table_crit.val)
          sendChat('COF', "[[1t[Echec-Critique-Contact]]]");
        else sendChat('COF', "/w GM " + suggererEchecCritique(attaquant, weaponStats, cibles, options, evt));
      }
      return;
    }
    var attackingCharId = attaquant.charId;
    var attackingToken = attaquant.token;
    var attackerTokName = attaquant.tokName;
    options.attaquant = attaquant;
    //Les dégâts
    //Dégâts insrits sur la ligne de l'arme
    var mainDmgType = options.type || 'normal';
    var attNbDices = weaponStats.attNbDices;
    if (isNaN(attNbDices) || attNbDices < 0) {
      error("Dés de l'attaque incorrect", attNbDices);
      return;
    }
    if (attNbDices) {
      if (options.tempeteDeManaIntense) {
        attNbDices += options.tempeteDeManaIntense;
      } else if (options.conditionAttaquant &&
        options.conditionAttaquant.type == 'attribut') {
        var attrtdmi =
          options.conditionAttaquant.attribute + "TempeteDeManaIntense";
        var tdmCond = attributeAsInt(attaquant, attrtdmi, 0);
        if (tdmCond) {
          attNbDices += tdmCond;
          removeTokenAttr(attaquant, attrtdmi, evt);
        }
      }
    }
    // Les autres modifications aux dégâts qui ne dépendent pas de la cible
    var attDMBonusCommun = '';
    if (options.rayonAffaiblissant) {
      attDMBonusCommun += " -" + options.rayonAffaiblissant;
    }
    if (attributeAsBool(attaquant, 'masqueDuPredateur')) {
      var bonusMasque = getValeurOfEffet(attaquant, 'masqueDuPredateur', modCarac(attaquant, 'sagesse'));
      if (bonusMasque > 0) attDMBonusCommun += " +" + bonusMasque;
    }
    if (options.rageBerserk) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: options.rageBerserk + options.d6
      });
    }
    if (attributeAsBool(attaquant, 'enragé')) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: '1' + options.d6
      });
    }
    if (options.contact && attributeAsBool(attaquant, 'memePasMalBonus')) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: '1' + options.d6,
      });
      explications.push("Même pas mal => +1" + options.d6 + " DM");
    }
    if (!options.auto && options.attaqueEnPuissance) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: options.attaqueEnPuissance + options.d6
      });
    }
    var attrPosture = tokenAttribute(attaquant, 'postureDeCombat');
    if (attrPosture.length > 0) {
      attrPosture = attrPosture[0];
      var posture = attrPosture.get('max');
      var postureVal;
      if (posture.startsWith('DM')) {
        postureVal = parseInt(attrPosture.get('current'));
        attDMBonusCommun += " -" + postureVal;
        explications.push("Posture de combat => -" + postureVal + " DM");
      } else if (posture.endsWith('DM')) {
        postureVal = parseInt(attrPosture.get('current'));
        attDMBonusCommun += " +" + postureVal;
        explications.push("Posture de combat => +" + postureVal + " DM");
      }
    }
    if (attaquant.bonusCapitaine) attDMBonusCommun += " +" + attaquant.bonusCapitaine;
    // Les autres sources de dégâts
    if (options.distance) {
      if (options.semonce) {
        attaquant.additionalDmg.push({
          type: mainDmgType,
          value: '1' + options.d6
        });
        explications.push("Tir de semonce => +5 en Attaque et +1" + options.d6 + " aux DM");
      }
    } else { //bonus aux attaques de contact
      if (attributeAsBool(attaquant, 'agrandissement')) {
        attDMBonusCommun += "+2";
        explications.push("Agrandissement => +2 aux DM");
      }
      if (attributeAsBool(attaquant, 'forceDeGeant')) {
        var bonusForceDeGeant = getValeurOfEffet(attaquant, 'forceDeGeant', 2);
        attDMBonusCommun += "+" + bonusForceDeGeant;
        explications.push("Force de géant => +" + bonusForceDeGeant + " aux DM");
      }
      if (options.frappeDuVide) {
        attaquant.additionalDmg.push({
          type: mainDmgType,
          value: '1' + options.d6
        });
      }
    }
    var nAEF = 0;
    if (attackLabel) {
      var attrForgeron = 'forgeron(' + attackLabel + ')';
      if (attributeAsBool(attaquant, attrForgeron)) {
        var feuForgeron = getValeurOfEffet(attaquant, attrForgeron, 1, 'voieDuMetal');
        var feuForgeronIntense = attributeAsInt(attaquant, attrForgeron + 'TempeteDeManaIntense', 0);
        if (feuForgeronIntense) {
          feuForgeron = feuForgeron * (1 + feuForgeronIntense);
          removeTokenAttr(attaquant, attrForgeron + 'TempeteDeManaIntense', evt);
        }
        attaquant.additionalDmg.push({
          type: 'feu',
          value: feuForgeron
        });
      }
      var attrAEF = 'armeEnflammee(' + attackLabel + ')';
      if (attributeAsBool(attaquant, attrAEF)) {
        nAEF = 1;
        var AEFIntense = attributeAsInt(attaquant, attrAEF + 'TempeteDeManaIntense', 0);
        if (AEFIntense) {
          nAEF += AEFIntense;
          removeTokenAttr(attaquant, attrAEF + 'TempeteDeManaIntense', evt);
        }
      }
    }
    if (nAEF === 0 && attributeAsBool(attaquant, 'armesEnflammees')) {
      nAEF = 1;
      var AsEFIntense = attributeAsInt(attaquant, 'armesEnflammeesTempeteDeManaIntense', 0);
      if (AsEFIntense) {
        nAEF += AsEFIntense;
        removeTokenAttr(attaquant, 'armesEnflammeesTempeteDeManaIntense', evt);
      }
    }
    if (nAEF > 0) {
      attaquant.additionalDmg.push({
        type: 'feu',
        value: nAEF + 'd6'
      });
    }
    if (attackLabel) {
      var poisonAttr = tokenAttribute(attaquant, 'poisonRapide_' + attackLabel);
      if (poisonAttr.length > 0) {
        poisonAttr = poisonAttr[0];
        attaquant.additionalDmg.push({
          type: 'poison',
          value: poisonAttr.get('current'),
          partialSave: {
            carac: 'CON',
            seuil: poisonAttr.get('max')
          }
        });
        explications.push("L'arme est empoisonnée");
        evt.deletedAttributes = evt.deletedAttributes || [];
        evt.deletedAttributes.push(poisonAttr);
        poisonAttr.remove();
      }
      var attrDmgArme = 'dmgArme(' + attackLabel + ')';
      if (charAttributeAsBool(attaquant, attrDmgArme)) {
        var dmgArme = {
          type: mainDmgType,
          value: '1' + options.d6
        };
        var valDmgArme = tokenAttribute(attaquant, attrDmgArme + 'Valeur');
        if (valDmgArme.length > 0) {
          dmgArme.value = valDmgArme[0].get('current');
          var dmgArmeType = valDmgArme[0].get('max');
          if (dmgArmeType !== '') dmgArme.type = dmgArmeType;
        }
        attaquant.additionalDmg.push(dmgArme);
        explications.push("Arme enduite => +" + dmgArme.value + " aux DM");
      }
    }
    if (options.champion) {
      attaquant.additionalDmg.push({
        type: mainDmgType,
        value: '1' + options.d6
      });
      var msgChampion =
        attaquant.TokName + " est un" + eForFemale(attaquant) + " champion" +
        onGenre(attaquant, '', 'ne') + ", son attaque porte !";
      explications.push(msgChampion);
    }
    /////////////////////////////////////////////////////////////////
    //Tout ce qui dépend de la cible
    var ciblesCount = ciblesTouchees.length; //Pour l'asynchronie
    var attaquesEnTraitrePossibles = {};
    var finCibles = function() {
      ciblesCount--;
      if (ciblesCount === 0) {
        ciblesTouchees.forEach(function(target) {
          if (target.attackMessage) {
            addLineToFramedDisplay(display, target.attackMessage);
          } else if (options.aoe) { //par exemple si attaque automatique
            addLineToFramedDisplay(display, "<b>" + target.tokName + "</b> :");
          }
          if (target.dmgMessage) addLineToFramedDisplay(display, target.dmgMessage, 100, false);
          target.messages.forEach(function(expl) {
            addLineToFramedDisplay(display, expl, 80);
          });
        });
        finaliseDisplay(display, explications, evt, attaquant, cibles, options);
        for (var vid in attaquesEnTraitrePossibles) {
          var voleur = persoOfId(vid);
          if (voleur === undefined) continue;
          var attaqueEnTraitre = tokenAttribute(voleur, 'attaqueEnTraitre');
          if (attaqueEnTraitre.length === 0) {
            error("Impossible de trouver l'attribut d'attaque en traître", voleur);
            continue;
          }
          attaqueEnTraitre = attaqueEnTraitre[0];
          var curAttaqueEnTraitre = parseInt(attaqueEnTraitre.get('current'));
          if (isNaN(curAttaqueEnTraitre)) {
            error("Resource pour attaque en traître mal formée", attaqueEnTraitre);
            continue;
          }
          if (curAttaqueEnTraitre > 0) {
            displayAttaqueOpportunite(vid, attaquesEnTraitrePossibles[vid], "en traître", '#AttaqueEnTraitre#', '--decrAttribute ' + attaqueEnTraitre.id);
          }
        }
      }
    };
    //Le lien épique (+1d6 DM si les 2 attaquent la même cible
    var attaqueParLienEpique = new Set();
    if (options.lienEpique) {
      //On cherche les autres personnages avec le même lien épique
      var allChars = findObjs({
        type: 'character'
      });
      allChars.forEach(function(ch) {
        if (ch.id == attackingCharId) return;
        var attrLienEpique = charAttribute(ch.id, 'lienEpique');
        if (attrLienEpique.length === 0) return;
        if (attrLienEpique[0].get('current') != options.lienEpique) return;
        var attrCibles = charAttribute(ch.id, 'dernieresCiblesAttaquees');
        if (attrCibles.length === 0) return;
        var ciblesAttaquees = attrCibles[0].get('current');
        if (ciblesAttaquees === '') return;
        ciblesAttaquees.split(' ').forEach(function(ci) {
          attaqueParLienEpique.add(ci);
        });
      });
    }
    ciblesTouchees.forEach(function(target) {
      evalITE(attaquant, target, d20roll, options, 1, evt, explications, options, function() {
        target.attaquant = attaquant;
        if (options.enveloppe !== undefined) {
          if (options.enveloppe.type == 'etreinte' && attributeAsBool(target, 'armureDEau')) {
            target.messages.push("L'armure d'eau empêche " + target.tokName + " d'être étreint");
          } else {
            var ligneEnveloppe = attaquant.tokName + " peut ";
            var commandeEnvelopper =
              '!cof-enveloppement ' + attaquant.token.id + ' ' + target.token.id + ' ' +
              options.enveloppe.difficulte + ' ' +
              options.enveloppe.type + ' ' + options.enveloppe.expression;
            var verbeEnv = 'envelopper';
            if (options.enveloppe.type == 'etreinte') verbeEnv = 'étreindre';
            ligneEnveloppe += boutonSimple(commandeEnvelopper, verbeEnv);
            ligneEnveloppe += target.tokName;
            target.messages.push(ligneEnveloppe);
          }
        }
        if (options.agripper) {
          if (attributeAsBool(target, 'armureDEau')) {
            target.messages.push("L'armure d'eau empêche " + target.tokName + " d'être aggripé");
          } else {
            var immobilise = estAussiGrandQue(attaquant, target);
            setTokenAttr(attaquant, 'agrippe', target.token.id + ' ' + target.tokName, evt);
            setTokenAttr(target, 'estAgrippePar', attaquant.token.id + ' ' + attaquant.tokName, evt, {
              maxVal: immobilise
            });
            if (immobilise) setState(target, 'immobilise', true, evt);
            target.messages.push("est agrippé");
          }
        }
        if (!options.redo && options.projection && taillePersonnage(attaquant, 4) > taillePersonnage(target, 4)) {
          var bonusProjection = 5 - taillePersonnage(target, 4);
          var distanceProjetee = rollDePlus(6, {
            bonus: bonusProjection
          }).val;
          var dmgProjection = "3d6";
          if (charAttributeAsBool(target, 'inderacinable')) {
            distanceProjetee /= 2;
            dmgProjection = "floor(" + dmgProjection + "/2)";
          }
          target.effets = target.effets || [];
          target.effets.push({
            effet: 'etourdiTemp',
            duree: 100,
            message: messageOfEffetTemp('etourdiTemp'),
            save: {
              carac: 'CON',
              seuil: 15
            },
            saveParTour: {
              carac: 'CON',
              seuil: 15
            }
          });
          target.additionalDmg.push({
            type: 'normal',
            value: dmgProjection
          });
          target.messages.push(target.tokName + " est projeté sur " + distanceProjetee + " mètres");
        }
        var attDMBonus = attDMBonusCommun;
        //Les modificateurs de dégâts qui dépendent de la cible
        if (target.tempDmg) {
          var forceTarg = modCarac(target, "force");
          if (forceTarg < 0) {
            attDMBonus += " +" + (-forceTarg);
          } else {
            attDMBonus += " -" + forceTarg;
          }
        }
        if (options.pressionMortelle || target.pressionMortelle) {
          var pMortelle = tokenAttribute(target, 'pressionMortelle');
          if (pMortelle.length === 0) {
            sendChar(attackingCharId, "Essaie une pression mortelle, mais aucun point vital de " + target.tokName + " n'a encore été affecté");
            ciblesCount--;
            return;
          }
          target.pressionMortelle = pMortelle;
          attDMBonus = "+ " + pMortelle[0].get('current');
        }
        if (options.distance && !options.grenaille) {
          var tirPrecis = charAttributeAsInt(attaquant, 'tirPrecis', 0);
          if (tirPrecis > 0) {
            var modDex = modCarac(attaquant, 'dexterite');
            if (target.distance <= 5 * modDex) {
              attDMBonus += " + " + tirPrecis;
              target.messages.push("Tir précis : +" + tirPrecis + " DM");
            }
          }
        }
        var sournoise = options.sournoise || 0;
        if (target.sournoise) sournoise += target.sournoise;
        if (sournoise) {
          if (charAttributeAsBool(target, 'immuniteAuxSournoises')) {
            target.messages.push(target.tokName + " est immunisé" + eForFemale(target) + " aux attaques sournoises");
          } else {
            if (options.ouvertureMortelle) {
              target.messages.push("Ouverture mortelle => + 2 x " + sournoise + options.d6 + " DM");
              sournoise = sournoise * 2;
            } else {
              target.messages.push("Attaque sournoise => +" + sournoise + options.d6 + " DM");
            }
            var valueSournoise = sournoise + options.d6;
            if (attributeAsBool(target, 'armureProtection') && attributeAsBool(target, 'DEFARMUREON')) {
              target.messages.push("L'armure de protection de " + target.token.get('name') + " réduit l'attaque sournoise");
              valueSournoise = "ceil(" + valueSournoise + "/2)";
            } else if (attributeAsBool(target, 'bouclierProtection') && attributeAsBool(target, 'DEFBOUCLIERON')) {
              target.messages.push("Le bouclier de protection de " + target.token.get('name') + " réduit l'attaque sournoise");
              valueSournoise = "ceil(" + valueSournoise + "/2)";
            }
            target.additionalDmg.push({
              type: mainDmgType,
              value: valueSournoise
            });
          }
        }
        if (target.chasseurEmerite) {
          attDMBonus += "+2";
        }
        if (target.ennemiJure) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1' + options.d6
          });
        }
        if (target.tueurDeGeants) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '2' + options.d6
          });
        }
        if (target.armeDArgent) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1d6'
          });
        }
        if (target.estAgrippee) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1d6'
          });
        }
        if (options.lienEpique && attaqueParLienEpique.has(target.token.id)) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: '1' + options.d6
          });
          target.messages.push("Lien épique => + 1" + options.d6 + " DM");
        }
        if (target.feinte) {
          target.additionalDmg.push({
            type: mainDmgType,
            value: target.feinte + options.d6
          });
        }
        if (options.tueurDeGrands) {
          var targetTaille = taillePersonnage(target, 4);
          if (targetTaille == 5) {
            target.additionalDmg.push({
              type: mainDmgType,
              value: '1d6'
            });
            target.messages.push("Cible grande => +1d6 DM");
          } else if (targetTaille > 5) {
            target.additionalDmg.push({
              type: mainDmgType,
              value: '2d6'
            });
            target.messages.push("Cible énorme => +2d6 DM");
          }
        }
        if (!options.pasDeDmg) {
          var loupParmiLesLoups = charAttributeAsInt(attaquant, 'loupParmiLesLoups', 0);
          if (loupParmiLesLoups > 0 && estHumanoide(target)) {
            attDMBonus += "+" + loupParmiLesLoups;
            target.messages.push("Loup parmi les loups : +" + loupParmiLesLoups + " DM");
          }
          if (charAttributeAsBool(attaquant, 'langageSombreHetre') && estElfeNoir(target)) {
            attDMBonus += "+1";
            target.messages.push("Langage sombre : +1 DM");
          }
        }
        //Bonus aux DMs dus au défi samouraï
        var defiSamouraiAttr = tokenAttribute(attaquant, 'defiSamourai');
        if (defiSamouraiAttr.length > 0) {
          defiSamouraiAttr = defiSamouraiAttr[0];
          var cibleDefi = defiSamouraiAttr.get('max');
          if (cibleDefi.startsWith(target.token.id)) cibleDefi = true;
          else {
            var cibleDefiSep = cibleDefi.indexOf(' ');
            var cibleDefiName = cibleDefi.substring(cibleDefiSep + 1);
            if (cibleDefiName == target.tokName) {
              var cibleDefiId = cibleDefi.substring(0, cibleDefiSep);
              cibleDefi = persoOfId(cibleDefiId, cibleDefiName, pageId);
              cibleDefi = cibleDefi === undefined || cibleDefi.id == target.id;
            } else cibleDefi = false;
          }
          if (cibleDefi) {
            var bonusDefi = parseInt(defiSamouraiAttr.get('current'));
            target.additionalDmg.push({
              type: mainDmgType,
              value: bonusDefi
            });
            target.messages.push(attackerTokName + " bénéficie d'un bonus de +" + bonusDefi + " aux DMs contre " + target.tokName);
          }
        }

        if (attributeAsBool(attaquant, 'ombreMortelle') ||
          attributeAsBool(attaquant, 'dedoublement') ||
          (charAttributeAsBool(attaquant, 'armeeConjuree') && attributeAsBool(target, 'attaqueArmeeConjuree'))) {
          if (options.divise) options.divise *= 2;
          else options.divise = 2;
        }
        if (options.attaqueAssuree || options.echecTotal) {
          if (options.divise) options.divise *= 2;
          else options.divise = 2;
        }
        var mainDmgRollExpr =
          computeMainDmgRollExpr(attaquant, target, weaponStats, attNbDices,
            attDMBonus, options);
        //Additional damage
        var additionalDmg = attaquant.additionalDmg.concat(target.additionalDmg);
        //On enlève les DM qui ne passent pas les conditions
        additionalDmg = additionalDmg.filter(function(dmSpec) {
          if (dmSpec.conditions === undefined) return true;
          return dmSpec.conditions.every(function(cond) {
            return testCondition(cond, attaquant, [target], d20roll, options);
          });
        });
        if (!options.sortilege && !options.magique &&
          charAttributeAsBool(target, 'immuniteAuxArmes')) {
          additionalDmg = additionalDmg.filter(function(dmSpec) {
            switch (dmSpec.type) {
              case undefined:
              case 'normal':
              case 'poison':
              case 'maladie':
                return false;
              default:
                return true;
            }
          });
        }
        if (options.tirDouble || options.tirDeBarrage || options.dmFoisDeux) {
          if (options.tirDouble && options.tirDouble.stats) {
            var stats2 = options.tirDouble.stats;
            mainDmgRollExpr += " +" +
              computeMainDmgRollExpr(attaquant, target, stats2, stats2.attNbDices,
                attDMBonus, options);
          } else {
            mainDmgRollExpr += " +" + mainDmgRollExpr;
          }
          additionalDmg.forEach(function(dmSpec) {
            dmSpec.value += " +" + dmSpec.Value;
          });
        }
        if (target.etreinteImmole) {
          additionalDmg.push({
            value: mainDmgRollExpr,
            type: 'feu'
          });
        }
        var ExtraDmgRollExpr = "";
        additionalDmg = additionalDmg.filter(function(dmSpec) {
          dmSpec.type = dmSpec.type || 'normal';
          if (dmSpec.type != mainDmgType || isNaN(dmSpec.value)) {
            ExtraDmgRollExpr += " [[" + dmSpec.value + "]]";
            return true;
          }
          // We have the same type and a constant -> should be multiplied by crit
          mainDmgRollExpr += " + " + dmSpec.value;
          return false;
        });
        // ON ajoute le jet pour les dégâts de critiques supplémentaires
        if (target.critique && options.additionalCritDmg) {
          options.additionalCritDmg.forEach(function(dmSpec) {
            ExtraDmgRollExpr += " [[" + dmSpec.value + "]]";
          });
        }
        if (options.aveugleManoeuvre) {
          mainDmgRollExpr += " -5";
        }
        var mainDmgRoll = {
          type: mainDmgType,
          value: mainDmgRollExpr
        };
        // toEvaluateDmg inlines
        // 0 : roll de dégâts principaux
        // 1+ : les rolls de dégâts supplémentaires
        // 1+nb dégâts supplémentaires + : rolls de dégâts critiques
        var toEvaluateDmg = "[[" + mainDmgRollExpr + "]]" + ExtraDmgRollExpr;
        sendChat(attaquant.name, toEvaluateDmg, function(resDmg) {
          var rollsDmg = target.rollsDmg || resDmg[0];
          var afterEvaluateDmg = rollsDmg.content.split(' ');
          var mainDmgRollNumber = rollNumber(afterEvaluateDmg[0]);
          mainDmgRoll.total = rollsDmg.inlinerolls[mainDmgRollNumber].results.total;
          mainDmgRoll.display = buildinline(rollsDmg.inlinerolls[mainDmgRollNumber], mainDmgType, options.magique);
          if (target.critique && options.additionalCritDmg) {
            var firstCritRoll = 1 + additionalDmg.length;
            target.additionalCritDmg = [];
            var rollsCrit = resDmg[0];
            if (target.rollsDmg && target.rollsDmg.length >= firstCritRoll + options.additinalCritDmg.length)
              rollsCrit = target.rollsDmg;
            options.additionalCritDmg.forEach(function(dmSpec, i) {
              var rRoll = rollsCrit.inlinerolls[rollNumber(afterEvaluateDmg[i + firstCritRoll])];
              if (rRoll) {
                target.additionalCritDmg.push(dmSpec);
                dmSpec.total = dmSpec.total || rRoll.results.total;
                var addDmType = dmSpec.type || 'normal';
                dmSpec.display = dmSpec.display || buildinline(rRoll, addDmType, options.magique);
              } else { //l'expression de DM additionel est mal formée
                error("Expression de dégâts de critiques mal formée : " + options.additionalCritDmg[i].value, options.additionalCritDmg[i]);
              }
            });
            if (target.additionalCritDmg.length === 0) delete target.additionalCritDmg;
          }
          var correctAdditionalDmg = [];
          additionalDmg.forEach(function(dmSpec, i) {
            var rRoll = rollsDmg.inlinerolls[rollNumber(afterEvaluateDmg[i + 1])];
            if (rRoll) {
              correctAdditionalDmg.push(dmSpec);
              dmSpec.total = dmSpec.total || rRoll.results.total;
              var addDmType = dmSpec.type;
              dmSpec.display = dmSpec.display || buildinline(rRoll, addDmType, options.magique);
            } else { //l'expression de DM additionel est mal formée
              error("Expression de dégâts supplémentaires mal formée : " + additionalDmg[i].value, additionalDmg[i]);
            }
          });
          additionalDmg = correctAdditionalDmg;
          if (target.touche) { //Devrait être inutile ?
            if (options.tirDeBarrage) target.messages.push("Tir de barrage : undo si la cible décide de ne pas bouger");
            if (options.pointsVitaux) target.messages.push(attackerTokName + " vise des points vitaux mais ne semble pas faire de dégâts");
            if (options.pressionMortelle || target.pressionMortelle) {
              removeTokenAttr(target, 'pressionMortelle', evt);
              target.messages.push(attackerTokName + " libère la pression des points vitaux, l'effet est dévastateur !");
              spawnFx(target.token.get('left'), target.token.get('top'), 'bomb-death', pageId);
            }
            if (options.pasDeDmg === undefined) { //si l'attaque fait des DM, possibilité d'attaque en traître
              if (attaquant.alliesAvecAttaqueEnTraitre === undefined) {
                attaquant.alliesAvecAttaqueEnTraitre = [];
                //On cherche tous les alliés ayant l'attaque en traitre
                var allies = alliesParPerso[attaquant.charId] || new Set();
                allies.forEach(function(ci) {
                  var aet = findObjs({
                    _type: 'attribute',
                    _characterid: ci,
                  });
                  aet.forEach(function(a) {
                    var an = a.get('name');
                    if (an == 'attaqueEnTraitre' ||
                      an.startsWith('attaqueEnTraitre_')) {
                      if (a.get('current')) {
                        iterTokensOfAttribute(ci, pageId, 'attaqueEnTraitre', an,
                          function(tok) {
                            attaquant.alliesAvecAttaqueEnTraitre.push(tok);
                          }, {
                            onlyOnPage: true,
                            possiblementAbsent: true
                          });
                      }
                    }
                  });
                });
              }
              attaquant.alliesAvecAttaqueEnTraitre.forEach(function(tok) {
                if (tok.id == target.id) return;
                if (distanceCombat(target.token, tok, pageId) === 0) {
                  var aetp = attaquesEnTraitrePossibles[tok.id];
                  if (aetp === undefined) {
                    aetp = [];
                    attaquesEnTraitrePossibles[tok.id] = aetp;
                  }
                  aetp.push(target);
                }
              });
            }
            // change l'état de la cible, si spécifié
            if (target.enflamme) {
              var enflammePuissance = 1;
              if (options.puissant) enflammePuissance = 2;
              setTokenAttr(target, 'enflamme', enflammePuissance, evt);
              target.messages.push(target.tokName + " prend feu !");
            }
            if (target.malediction) {
              setTokenAttr(target, 'malediction', 3, evt);
              target.messages.push(target.tokName + " est maudit...");
            }
            // Draw effect, if any
            if (options.fx) {
              //Pour les cones, on fait un seul effet, car c'est bien géré.
              if (!options.aoe || options.aoe.type != 'cone') {
                var p1e = {
                  x: attackingToken.get('left'),
                  y: attackingToken.get('top'),
                };
                var p2e = {
                  x: target.token.get('left'),
                  y: target.token.get('top'),
                };
                spawnFxBetweenPoints(p1e, p2e, options.fx, pageId);
              }
            }
            if (options.targetFx && !options.aoe) {
              spawnFx(target.token.get('left'), target.token.get('top'), options.targetFx, pageId);
            }
            target.rollsDmg = rollsDmg;
            // Compte le nombre de saves pour la synchronisation
            // (On ne compte pas les psave, gérés dans dealDamage)
            var saves = 0;
            //ajoute les états sans save à la cible
            var etats = options.etats;
            if (target.etats) {
              if (etats) etats = etats.concat(target.etats);
              else etats = target.etats;
            }
            if (etats) {
              etats.forEach(function(ce) {
                if (charAttributeAsBool(target, "liberteDAction") && options.sortilege && (
                    ce.etat == 'apeure' ||
                    ce.etat == 'endormi' ||
                    ce.etat == 'etourdi' ||
                    ce.etat == 'immobilise' ||
                    ce.etat == 'paralyse' ||
                    ce.etat == 'ralenti'
                  )) {
                  target.messages.push(target.tokName + " reste libre de ses mouvements !");
                  return;
                }
                if (ce.save) {
                  saves++;
                  return; //on le fera plus tard
                }
                if (testCondition(ce.condition, attaquant, [target], d20roll, options)) {
                  setState(target, ce.etat, true, evt);
                  var msgEtat;
                  if (ce.etat == 'mort')
                    msgEtat = 'tué' + eForFemale(target);
                  else
                    msgEtat = stringOfEtat(ce.etat, target);
                  target.messages.push(target.tokName + " est " + msgEtat + " par l'attaque");
                  if (ce.saveCarac) {
                    setTokenAttr(target, ce.etat + 'Save', ce.saveCarac, evt, {
                      maxVal: ce.saveDifficulte
                    });
                  }
                } else {
                  if (ce.condition.type == "moins") {
                    target.messages.push(
                      "Grâce à sa " + ce.condition.text + ", " + target.tokName +
                      " n'est pas " + stringOfEtat(ce.etat, target));
                  }
                }
              });
            }
            var savesEffets = 0;
            // Ajoute les effets sans save à la cible
            var effets = options.effets;
            if (target.effets) {
              if (effets) effets = effets.concat(target.effets);
              else effets = target.effets;
            }
            if (effets) {
              effets.forEach(function(ef) {
                if (charAttributeAsBool(target, "liberteDAction") && options.sortilege && (
                    ef.effet == 'apeureTemp' ||
                    ef.effet == 'endormiTemp' ||
                    ef.effet == 'etourdiTemp' ||
                    ef.effet == 'immobiliseTemp' ||
                    ef.effet == 'paralyseTemp' ||
                    ef.effet == 'ralentiTemp'
                  )) {
                  target.messages.push(target.tokName + " reste libre de ses mouvements !");
                  return;
                }
                if (ef.save) {
                  saves++;
                  savesEffets++;
                  return; //on le fera plus tard
                }
                if (ef.typeDmg && immuniseAuType(target, ef.typeDmg, attaquant)) {
                  target.messages.push(target.tokName + " ne semble pas affecté par " + stringOfType(ef.typeDmg));
                  return;
                }
                setEffetTemporaire(target, ef, ef.duree, attaquant, pageId, evt, options);
              });
            }
            // Tout ce qui se passe après les saves (autres que saves de diminution des dmg
            var afterSaves = function() {
              if (saves > 0) return; //On n'a pas encore fait tous les saves
              if (options.pasDeDmg ||
                target.utiliseRuneProtection ||
                (additionalDmg.length === 0 && mainDmgRoll.total === 0 && attNbDices === 0)) {
                // Pas de dégâts, donc pas d'appel à dealDamage
                finCibles();
              } else {
                dealDamage(target, mainDmgRoll, additionalDmg, evt, target.critique,
                  options, target.messages,
                  function(dmgDisplay, dmg) {
                    if (options.strigeSuce) {
                      var suce = attributeAsInt(attaquant, 'strigeSuce', 0);
                      if (suce === 0) {
                        setTokenAttr(attaquant, 'bufDEF', -3, evt);
                        target.messages.push(
                          attackerTokName + " s'agrippe à " + target.tokName +
                          " et commence à lui sucer le sang");
                      }
                      if (suce + dmg >= 6) {
                        target.messages.push(
                          "Repus, " + attackerTokName + " se détache et s'envole");
                        target.messages.push(target.tokName + " se sent un peu faible...");
                        setState(target, 'affaibli', true, evt);
                        var defbuf = attributeAsInt(attaquant, 'bufDEF', 0);
                        if (defbuf === -3) {
                          removeTokenAttr(attaquant, 'bufDEF', evt);
                        } else if (defbuf !== 0) {
                          setTokenAttr(attaquant, 'bufDEF', defbuf + 3, evt);
                        }
                      } else {
                        setTokenAttr(attaquant, 'strigeSuce', suce + dmg, evt);
                        if (suce > 0)
                          target.messages.push(
                            attackerTokName + " continue à sucer le sang de " + target.tokName);
                      }
                    }
                    if (options.vampirise || target.vampirise) {
                      soigneToken(attaquant, dmg, evt, function(soins) {
                        target.messages.push(
                          "L'attaque soigne " + attackerTokName + " de " + soins + " PV");
                      });
                    }
                    var absorptionEnergie = attributeAsInt(attaquant, "absorptionEnergie", 0);
                    if (absorptionEnergie > 0) {
                      soigneToken(attaquant, absorptionEnergie, evt, function(soins) {
                        target.messages.push(
                          "L'attaque soigne " + attackerTokName + " de " + soins + " PV");
                      });
                    }
                    target.dmgMessage = "<b>DM :</b> ";
                    if (ficheAttributeAsBool(attaquant, 'jets_caches', false)) {
                      target.dmgMessage += dmg;
                      sendChat('COF', "/w GM Jet caché de dommages : " + dmgDisplay);
                    } else {
                      target.dmgMessage += dmgDisplay;
                    }
                    if (options.contact) {
                      //Les DMs automatiques en cas de toucher une cible
                      if (attributeAsBool(target, 'sousTension')) {
                        ciblesCount++;
                        var exprSousTension = '[[' + getValeurStringOfEffet(target, 'sousTension', '1d6') + ']]';
                        sendChat('', exprSousTension, function(res) {
                          var rolls = res[0];
                          var explRoll = rolls.inlinerolls[0];
                          var r = {
                            total: explRoll.results.total,
                            type: 'electrique',
                            display: buildinline(explRoll, 'electrique', true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg) {
                              var dmgMsg =
                                "<b>Décharge électrique sur " + attackerTokName + " :</b> " +
                                dmgDisplay;
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      }
                      if (attributeAsBool(target, 'sangMordant')) {
                        ciblesCount++;
                        sendChat("", "[[1d6]]", function(res) {
                          var rolls = res[0];
                          var explRoll = rolls.inlinerolls[0];
                          var r = {
                            total: explRoll.results.total,
                            type: 'acide',
                            display: buildinline(explRoll, 'acide', true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg) {
                              var dmgMsg =
                                "<b>Le sang acide gicle sur " + attackerTokName + " :</b> " +
                                dmgDisplay + " DM";
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      }
                      if (options.armeNaturelle && attributeAsBool(target, 'presenceGlaciale')) {
                        ciblesCount++;
                        var exprPresenceGlaciale = '[[';
                        var attrsPGValeur = tokenAttribute(target, 'presenceGlacialeValeur');
                        if (attrsPGValeur.length === 0) exprPresenceGlaciale += '1d6';
                        else exprPresenceGlaciale += attrsPGValeur[0].get('max');
                        exprPresenceGlaciale += ']]';
                        sendChat("", exprPresenceGlaciale, function(res) {
                          var rolls = res[0];
                          var explRoll = rolls.inlinerolls[0];
                          var r = {
                            total: explRoll.results.total,
                            type: 'froid',
                            display: buildinline(explRoll, 'froid', true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg) {
                              var dmgMsg =
                                "<b>" + attackerTokName + " est glacé :</b> " +
                                dmgDisplay + " DM";
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      }
                      var attrDmSiToucheContact = findObjs({
                        _type: 'attribute',
                        _characterid: target.charId,
                        name: 'dmSiToucheContact'
                      });
                      attrDmSiToucheContact.forEach(function(dstc) {
                        ciblesCount++;
                        sendChat("", "[[" + dstc.get('current') + "]]", function(res) {
                          var rolls = res[0];
                          var explRoll = rolls.inlinerolls[0];
                          var type = dstc.get('max');
                          var r = {
                            total: explRoll.results.total,
                            type: type,
                            display: buildinline(explRoll, type, true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg) {
                              var dmgMsg =
                                "<b>" + attackerTokName + " subit :</b> " +
                                dmgDisplay + " DM en touchant " + target.tokName;
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      });
                      var attrCorpsElem = findObjs({
                        _type: 'attribute',
                        _characterid: target.charId,
                        name: 'corpsElementaire'
                      });
                      attrCorpsElem.forEach(function(dstc) {
                        ciblesCount++;
                        sendChat("", "[[1d6]]", function(res) {
                          var rolls = res[0];
                          var explRoll = rolls.inlinerolls[0];
                          var type = dstc.get('current');
                          var r = {
                            total: explRoll.results.total,
                            type: type,
                            display: buildinline(explRoll, type, true)
                          };
                          dealDamage(attaquant, r, [], evt, false, options,
                            target.messages,
                            function(dmgDisplay, dmg) {
                              var dmgMsg =
                                "<b>" + attackerTokName + " subit :</b> " +
                                dmgDisplay + " DM en touchant " + target.tokName;
                              target.messages.push(dmgMsg);
                              finCibles();
                            });
                        });
                      });
                    }
                    finCibles();
                  });
              }
            };
            var expliquer = function(msg) {
              target.messages.push(msg);
            };
            //Ajoute les états avec save à la cible
            var etatsAvecSave = function() {
              if (savesEffets > 0) return; //On n'a pas encore fini avec les effets
              if (etats && saves > 0) {
                etats.forEach(function(ce, index) {
                  if (ce.save) {
                    if (testCondition(ce.condition, attaquant, [target], d20roll, options)) {
                      var msgPour = " pour résister à un effet";
                      var msgEtat;
                      if (ce.etat == 'mort')
                        msgEtat = 'tué' + eForFemale(target);
                      else
                        msgEtat = stringOfEtat(ce.etat, target);
                      var msgRate = ", " + target.tokName + " est " + msgEtat + " par l'attaque";
                      var saveOpts = {
                        msgPour: msgPour,
                        msgRate: msgRate,
                        attaquant: attaquant,
                        rolls: options.rolls,
                        chanceRollId: options.chanceRollId,
                        type: ce.typeDmg
                      };
                      var rollId = 'etat_' + ce.etat + index + '_' + target.token.id;
                      save(ce.save, target, rollId, expliquer, saveOpts, evt,
                        function(reussite, rolltext) {
                          if (!reussite) {
                            setState(target, ce.etat, true, evt);
                            if (ce.saveCarac) {
                              setTokenAttr(target, ce.etat + 'Save', ce.saveCarac, evt, {
                                maxVal: ce.saveDifficulte
                              });
                            }
                          }
                          saves--;
                          afterSaves();
                        });
                    } else {
                      if (ce.condition.type == "moins") {
                        target.messages.push(
                          "Grâce à sa " + ce.condition.text + ", " + target.tokName +
                          " n'est pas " + stringOfEtat(ce.etat, target));
                      }
                      saves--;
                      afterSaves();
                    }
                  }
                });
              } else afterSaves();
            };
            // Ajoute les effets avec save à la cible
            var effetsAvecSave = function() {
              if (effets && savesEffets > 0) {
                effets.forEach(function(ef, index) {
                  if (ef.save) {
                    if (ef.typeDmg && immuniseAuType(target, ef.typeDmg, attaquant)) {
                      target.messages.push(target.tokName + " ne semble pas affecté par " + stringOfType(ef.typeDmg));
                      target['msgImmunite_' + ef.typeDmg] = true;
                      saves--;
                      savesEffets--;
                      etatsAvecSave();
                      return;
                    }
                    var msgPour = " pour résister à un effet";
                    var msgRate = ", " + target.tokName + " ";
                    if (ef.duree && ef.message) {
                      msgRate += messageActivation(target, ef.message);
                      if (stateCOF.options.affichage.val.duree_effets.val) msgRate += " (" + ef.duree + " tours)";
                    } else if (ef.effetIndetermine)
                      msgRate += messageEffetIndetermine[ef.effet].activation;
                    else
                      msgRate += messageEffetCombat[ef.effet].activation;
                    ef.pasDeMessageDActivation = true;
                    var saveOpts = {
                      msgPour: msgPour,
                      msgRate: msgRate,
                      attaquant: attaquant,
                      rolls: options.rolls,
                      chanceRollId: options.chanceRollId,
                      type: ef.typeDmg
                    };
                    var rollId = 'effet_' + ef.effet + index + '_' + target.token.id;
                    var duree = ef.duree;
                    save(ef.save, target, rollId, expliquer, saveOpts, evt,
                      function(reussite, rollText) {
                        if (reussite && duree && ef.save.demiDuree) {
                          reussite = false;
                          duree = Math.ceil(duree / 2);
                          if (stateCOF.options.affichage.val.duree_effets.val) expliquer("La durée est réduite à " + duree + " tours");
                        }
                        if (!reussite) {
                          setEffetTemporaire(target, ef, duree, attaquant, pageId, evt, options);
                        }
                        saves--;
                        savesEffets--;
                        etatsAvecSave();
                      });
                  }
                });
              } else etatsAvecSave();
            };
            var effetPietinement = function() {
              if ((target.pietine || target.percute) && estAussiGrandQue(attaquant, target)) {
                var rollId = 'pietinement' + target.token.id;
                testOppose(rollId, target, 'FOR', options, attaquant, 'FOR',
                  options, target.messages, evt,
                  function(resultat, crit, rt1, rt2) {
                    if (resultat == 2) {
                      target.messages.push(target.tokName + " est piétiné par " + attackerTokName + ", dommages doublés");
                      setState(target, 'renverse', true, evt);
                      target.dmgCoef = (target.dmgCoef || 0) + 1;
                      target.touche++;
                      if (target.percute) {
                        target.messages.push(target.tokName + " est projeté à " +
                          rollDePlus(6, {
                            bonus: 1
                          }).roll + " mètres");
                        effets = effets || [];
                        effets.push({
                          effet: 'etourdiTemp',
                          duree: 100,
                          message: messageOfEffetTemp('etourdiTemp'),
                          save: {
                            carac: 'CON',
                            seuil: 15
                          },
                          saveParTour: {
                            carac: 'CON',
                            seuil: 15
                          }
                        });
                        savesEffets++;
                      }
                    } else {
                      if (resultat === 0) diminueMalediction(attaquant, evt);
                      target.messages.push(target.tokName + " n'est pas piétiné.");
                    }
                    effetsAvecSave();
                  });
              } else effetsAvecSave();
            };
            // Peut faire peur à la cible
            if (options.peur) {
              peurOneToken(target, options.peur.seuil,
                options.peur.duree, {
                  resisteAvecForce: true
                }, target.messages, evt, effetPietinement);
            } else effetPietinement();
          } else {
            evt.succes = false;
            finCibles();
          }
        });
      });
    }); //Fin de la boucle pour toutes cibles
  }

  function suggererEchecCritique(attaquant, weaponStats, cibles, options, evt) {
    var d12roll = randomInteger(12);
    var estMag = options.sortilege;
    var avecArme = weaponStats.arme;
    var estCac = options.contact;
    var boutonCritique = function(action) {
      var b = boutonSimple(action + " --target " + attaquant.token.id,
        "Appliquer", 'background-color:#cc0000');
      return b;
    };
    var msg;
    switch (d12roll) {
      case 1:
        msg = "Échec total : ";
        if (estMag) {
          msg += "le lanceur de sort perd le contrôle de la magie qu'il canalise et subit 1d4 dommages en retour par rang du sort lancé. ";
          msg += boutonCritique("!cof-dmg ?{Rang du sort}d4 --ignoreRD");
        } else {
          msg += "l'attaquant se blesse lui-même et s'inflige la moitié des dégâts de son attaque. L'attaquant ne peut plus attaquer ce tour. ";
          msg += boutonCritique("!cof-bouton-echec-total " + evt.id);
        }
        return msg;
      case 2:
        var difficulte = 0;
        if (estCac) {
          var tailleAttaquant = taillePersonnage(attaquant, 4);
          cibles.forEach(function(cible) {
            difficulte = Math.max(difficulte, 12 - ((tailleAttaquant - taillePersonnage(cible, 4)) * 2));
          });
        } else {
          difficulte = 12;
        }
        msg = "Bousculé (FOR) : l'attaquant est déséquilibré par son attaque ";
        msg += boutonCritique("!cof-set-state renverse true --save FOR " + difficulte);
        return msg;
      case 3:
        if (avecArme) {
          msg = "Maladresse (DEX) : l'attaquant laisse échapper son arme qui tombe hors de portée immédiate.";
          msg += boutonCritique("!cof-degainer --save DEX 12");
          return msg;
        }
        msg = "Déséquilibré (DEX) : l'attaquant est Ralenti pendant 3 tours.";
        msg += boutonCritique("!cof-effet-temp ralentiTemp 3 --save DEX 12");
        return msg;
      case 4:
        msg = "Coup de mou (CON) : l'attaquant est affaibli pendant 3 tours, ou jusqu'à ce qu'il consacre un tour ou 1 PR pour se rétablir.";
        msg += boutonCritique("!cof-effet-temp affaibliTemp 3 --save CON 12");
        return msg;
      case 5:
        if (estCac) {
          msg = "Erreur tactique (INT) : le personnage provoque une attaque (gratuite) d’un adversaire à son contact.";
          msg += boutonCritique("!cof-jet INT 12");
        } else if (estMag) {
          msg = "Aveuglé (INT) : le personnage ne contrôle pas sa puissance et une partie de celle-ci émet un flash qui l'aveugle temporairement.";
          msg += boutonCritique("!cof-effet-temp aveugleTemp 3 --save INT 12 --saveParTour CON 12");
        } else {
          //TODO : Implémenter un bouton "mauvais calcul" réalisant une attaque automatique sur un des Obstacle
          msg = "Mauvais calcul (INT) : le personnage a une chance de toucher une autre cible sur la trajectoire de son tir. Déterminer la cible au hasard et relancer une attaque sur cette nouvelle cible.";
          msg += boutonCritique("!cof-jet INT 12");
        }
        return msg;
      case 6:
        if (estCac) {
          msg = "Exposé (SAG) : l'adversaire dispose d'un bonus de +10 à la touche pendant un round.";
          cibles.forEach(function(cible) {
            msg += boutonCritique("!cof-effet-temp expose 1 --valeur " + cible.token.id + " --save SAG 12");
          });
        } else {
          msg = "Distrait (SAG) : le personnage est Ralenti pendant 3 tours ";
          msg += boutonCritique("!cof-effet-temp ralentiTemp 3 --save SAG 12");
        }
        return msg;
      case 7:
        msg = "Ridicule (CHA) : le personnage fait un faux mouvement à la fois douloureux et ridicule, il subit l’état étourdi pendant un round pour reprendre contenance. ";
        msg += boutonCritique("!cof-effet-temp etourdiTemp 1 --save CHA 12");
        return msg;
      case 8:
        msg = "Inconfort : Une pièce d’armure bouge et elle devient plus gênante que protectrice. Cuir : -1 en DEF et en attaque pour le reste du combat. Maille : -2, Plaque -3. ";
        msg += boutonCritique("!cof-effet-combat inconfort --valeur ?{Malus ?|-1,1|-2,2|-3,3} --save CHA 12");
        return msg;
      default:
        return "L'attaquant s'en tire bien cette fois-ci, pas d'effet particulier";
    }
  }

  //Affichage final d'une attaque
  // attaquant est optionnel, mais si il est présent, cibles doit être un tableau et options un objet
  function finaliseDisplay(display, explications, evt, attaquant, cibles, options, echecCritique) {
    echecCritique = echecCritique || false;
    explications.forEach(function(expl) {
      addLineToFramedDisplay(display, expl, 80);
    });
    if (evt.action) {
      var perso = evt.action.attaquant;
      evt.personnage = perso;
      if (evt.succes === false) {
        var pc = pointsDeChance(perso);
        if (pc > 0 && !echecCritique) {
          addLineToFramedDisplay(display, boutonSimple("!cof-bouton-chance " + evt.id, "Chance") + " (reste " + pc + " PC)");
        }
        if (attributeAsBool(perso, 'runeForgesort_énergie') &&
          attributeAsInt(perso, 'limiteParCombat_runeForgesort_énergie', 1) > 0) {
          addLineToFramedDisplay(display, boutonSimple("!cof-bouton-rune-energie " + evt.id, "Rune d'énergie"));
        }
        if (attributeAsBool(perso, 'petitVeinard')) {
          addLineToFramedDisplay(display, boutonSimple("!cof-bouton-petit-veinard " + evt.id, "Petit veinard"));
        }
        if (attributeAsInt(perso, 'pacteSanglant', 0) >= 3) {
          addLineToFramedDisplay(display, boutonSimple("!cof-pacte-sanglant " + evt.id + " 3", "Pacte sanglant (+3)"));
        }
        if (attributeAsInt(perso, 'pacteSanglant', 0) >= 5) {
          addLineToFramedDisplay(display, boutonSimple("!cof-pacte-sanglant " + evt.id + " 5", "Pacte sanglant (+5)"));
        }
      } else {
        if (evt.action.weaponStats) {
          var attLabel = evt.action.weaponStats.label;
          if (attributeAsBool(perso, 'runeForgesort_puissance(' + attLabel + ')') &&
            attributeAsInt(perso, 'limiteParCombat_runeForgesort_puissance(' + attLabel + ')', 1) > 0) {
            addLineToFramedDisplay(display,
              boutonSimple(
                "!cof-bouton-rune-puissance " + attLabel + ' ' + evt.id,
                "Rune de puissance"));
          }
        }
        if (attributeAsBool(perso, 'kiai') && !attributeAsBool(perso, 'rechargeDuKiai')) {
          addLineToFramedDisplay(display,
            boutonSimple("!cof-bouton-pousser-kiai " + evt.id, "Kiai"));
        }
        if (attributeAsBool(perso, 'petitVeinard')) {
          addLineToFramedDisplay(display, boutonSimple("!cof-bouton-petit-veinard " + evt.id, "Petit veinard") + " pour relancer un dé");
        }
      }
      if (options && options.contact && cibles && attaquant && charAttributeAsBool(attaquant, 'enchainement')) {
        var cibleMorte = cibles.find(function(target) {
          return target.token.get('bar1_value') == 0;
        });
        if (cibleMorte) {
          if (attaquant.ennemisAuContact === undefined) {
            var tokensContact = findObjs({
              _type: 'graphic',
              _subtype: "token",
              _pageid: evt.action.pageId,
              layer: 'objects'
            });
            tokensContact = tokensContact.filter(function(tok) {
              if (tok.id == attaquant.token.id) return false;
              return distanceCombat(attaquant.token, tok, evt.action.pageId) === 0;
            });
            var tokensEnnemis = [];
            var allies = alliesParPerso[attaquant.charId] || new Set();
            tokensContact.forEach(function(tok) {
              var ci = tok.get('represents');
              if (ci === '') return; //next token au contact
              if (!isActive({
                  token: tok,
                  charId: ci
                })) return;
              if (!allies.has(ci)) tokensEnnemis.push(tok);
            });
            attaquant.ennemisAuContact = tokensEnnemis;
          }
          if (attaquant.ennemisAuContact.length > 0) {
            var msgEnchainement = attaquant.token.get('name') + " a droit à une attaque au contact gratuite contre ";
            var sep = "";
            var armeEnMain = tokenAttribute(attaquant, 'armeEnMain');
            var act;
            if (armeEnMain.length === 0) {
              armeEnMain = false;
            } else {
              armeEnMain = armeEnMain[0].get('current');
              act = '!cof-attack ' + attaquant.token.id + ' ';
            }
            msgEnchainement += sep;
            attaquant.ennemisAuContact.forEach(function(tok) {
              if (armeEnMain) {
                msgEnchainement += boutonSimple(act + tok.id + ' ' + armeEnMain, tok.get('name'));
              } else {
                msgEnchainement += tok.get('name');
              }
              sep = ", ou ";
            });
            addLineToFramedDisplay(display, msgEnchainement);
          }
        }
      }
      if (options.preDmg) {
        var cerclesDeProtection = [];
        cibles.forEach(function(target) {
          var preDmgToken = options.preDmg[target.token.id];
          var action;
          if (preDmgToken !== undefined) {
            var nbBoutons = 0;
            var line = target.tokName + " peut :";
            if (preDmgToken.encaisserUnCoup) {
              line += "<br/>" +
                boutonSimple(
                  "!cof-encaisser-un-coup " + evt.id + ' --target ' + target.token.id,
                  "encaisser le coup");
              nbBoutons++;
            }
            if (preDmgToken.paradeDeProjectiles) {
              line += "<br/>" +
                boutonSimple(
                  "!cof-parade-projectiles " + evt.id + ' --target ' + target.token.id,
                  "parer le projectile");
              nbBoutons++;
            }
            if (preDmgToken.esquiveAcrobatique && preDmgToken.esquiveAcrobatique !== 'reroll') {
              action = "!cof-esquive-acrobatique " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "tenter une esquive acrobatique");
              nbBoutons++;
            }
            if (preDmgToken.esquiveFatale) {
              preDmgToken.esquiveFatale.forEach(function(tok) {
                line += "<br/>" +
                  boutonSimple(
                    "!cof-esquive-fatale " + evt.id + ' ' + tok.id,
                    "effectuer une esquive fatale vers " + tok.get('name'));
                nbBoutons++;
              });
            }
            if (preDmgToken.resistanceALaMagieBarbare && preDmgToken.resistanceALaMagieBarbare !== 'reroll') {
              action = "!cof-resister-a-la-magie " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "tenter de résister à la magie");
              nbBoutons++;
            }
            if (preDmgToken.cercleDeProtection && preDmgToken.cercleDeProtectionDe &&
              preDmgToken.cercleDeProtection !== 'reroll') {
              cerclesDeProtection.push({
                nom: preDmgToken.cercleDeProtectionDe,
                target: target
              });
            }
            if (preDmgToken.runeForgesort_protection) {
              line += "<br/>" +
                boutonSimple(
                  "!cof-rune-protection " + evt.id + ' --target ' + target.token.id,
                  "utiliser sa Rune de Protection");
              nbBoutons++;
            }
            if (preDmgToken.chairACanon) {
              preDmgToken.chairACanon.forEach(function(tok) {
                line += "<br/>" + boutonSimple("!cof-chair-a-canon " + target.token.id + ' ' + tok.id + ' ' + evt.id, "utiliser " + tok.get('name') + " comme chair à canon");
                nbBoutons++;
              });
            }
            if (preDmgToken.paradeMagistrale && preDmgToken.paradeMagistrale !== 'reroll') {
              action = "!cof-esquive-magistrale ";
              var actionParade = "esquive acrobatique";
              if (options.contact) {
                if (target.armesEnMain === undefined) armesEnMain(target);
                if (target.arme && !target.arme.portee) {
                  action = "!cof-parade-magistrale ";
                  actionParade = "parade magistrale";
                }
              }
              action += target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "tenter une " + actionParade);
              nbBoutons++;
            }
            if (preDmgToken.absorberUnSort && preDmgToken.absorberUnSort !== 'reroll') {
              action = "!cof-absorber-sort-au-bouclier " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "absorber le sort");
              nbBoutons++;
            }
            if (preDmgToken.absorberUnCoup && preDmgToken.absorberUnCoup !== 'reroll') {
              action = "!cof-absorber-coup-au-bouclier " + target.token.id + ' ' + evt.id;
              line += "<br/>" + boutonSimple(action, "absorber le coup");
              nbBoutons++;
            }
            if (nbBoutons > 0) addLineToFramedDisplay(display, line);
          }
        });
        if (cerclesDeProtection.length > 0) {
          cerclesDeProtection.forEach(function(cercle) {
            addLineToFramedDisplay(display,
              cercle.nom + " peut " + boutonSimple("!cof-cercle-protection " + cercle.target.token.id + ' ' + evt.id,
                "activer le Cercle de Protection"));
          });
        }
        addLineToFramedDisplay(display, boutonSimple("!cof-confirmer-attaque " + evt.id, "Continuer"));
      } else if (evt.action.options && !evt.action.options.auto && evt.action.cibles) {
        evt.action.cibles.forEach(function(target) {
          if (!options.pasDeDmg && target.touche &&
            attributeAsBool(target, 'ignorerLaDouleur') &&
            attributeAsInt(target, 'douleurIgnoree', 0) === 0) {
            addLineToFramedDisplay(display, target.tokName + " peut " +
              boutonSimple("!cof-ignorer-la-douleur " + evt.id + ' --target ' + target.token.id, "ignorer la douleur")
            );
          }
          var attrPacteSanglant = attributeAsInt(target, 'pacteSanglant', 0);
          if (attrPacteSanglant >= 3) {
            var msg = target.tokName + " fait un Pacte sanglant" + boutonSimple("!cof-pacte-sanglant-def " + evt.id + ' 3 ' + target.token.id, "(+3 DEF)");
            if (attrPacteSanglant >= 5) {
              msg += boutonSimple("!cof-pacte-sanglant-def " + evt.id + ' 5 ' + target.token.id, "(+5 DEF)");
            }
            addLineToFramedDisplay(display, msg);
          }
        });
      }
    }
    if (options === undefined || !options.secret) {
      sendChat("", endFramedDisplay(display));
    } else { //option.secret
      var playerIds;
      playerIds = getPlayerIds(attaquant);
      playerIds.forEach(function(playerid) {
        addFramedHeader(display, playerid, true);
        sendChat('', endFramedDisplay(display));
      });
      addFramedHeader(display, undefined, 'gm');
      sendChat('', endFramedDisplay(display));
      cibles.forEach(function(target) {
        var addPlayers = getPlayerIds(target);
        addPlayers.forEach(function(nid) {
          if (!playerIds.includes(nid)) {
            playerIds.push(nid);
            addFramedHeader(display, nid, true);
            sendChat('', endFramedDisplay(display));
          }
        });
      });
    }
    if (attaquant) {
      cibles.forEach(function(target) {
        if (evt.succes == false && options.contact && charAttributeAsBool(target, 'riposteGuerrier')) {
          displayAttaqueOpportunite(target.token.id, [attaquant], "de riposte", '#ActionsRiposte#', '--decrAttribute riposteGuerrier');
        } else if (charAttributeAsBool(target, 'seulContreTous')) {
          displayAttaqueOpportunite(target.token.id, [attaquant], "de riposte", '#ActionsRiposte#');
        } else if (charAttributeAsBool(target, 'riposte')) {
          var attrCiblesDeLaCible = tokenAttribute(target, 'dernieresCiblesAttaquees');
          if (attrCiblesDeLaCible.length > 0) {
            var ripostesDuTour =
              attrCiblesDeLaCible[0].get('max').split(' ');
            ripostesDuTour = new Set(ripostesDuTour);
            if (ripostesDuTour.has(attaquant.token.id)) return;
            ripostesDuTour = attrCiblesDeLaCible[0].get('current').split(' ');
            ripostesDuTour = new Set(ripostesDuTour);
            if (ripostesDuTour.has(attaquant.token.id)) return;
          }
          displayAttaqueOpportunite(target.token.id, [attaquant], "de riposte", '#ActionsRiposte#', '--riposte');
        }
      });
    }
  }

  // RD spécifique au type
  function typeRD(rd, dmgType) {
    if (dmgType === undefined || dmgType == 'normal') return 0;
    return (rd[dmgType] || 0);
  }

  function probaSucces(de, seuil, nbreDe) {
    if (nbreDe == 2) {
      var proba1 = probaSucces(de, seuil, 1);
      return 1 - (1 - proba1) * (1 - proba1);
    }
    if (seuil < 2) seuil = 2; // 1 est toujours un échec
    else if (seuil > 20) seuil = 20;
    return ((de - seuil) + 1) / de;
  }

  function nbreDeTestCarac(carac, perso) {
    var typeJet = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
      name: carac + '_SUP'
    }, {
      caseInsensitive: true
    });
    if (typeJet.length === 0) return 1;
    typeJet = typeJet[0].get('current');
    switch (typeJet) {
      case '@{JETNORMAL}':
      case '@{jetnormal}':
        return 1;
      case '@{JETSUP}':
      case '@{jetsup}':
      case '@{JETSUPHERO}':
      case '@{jetsuphero}':
        return 2;
      default:
        if (typeJet.startsWith('1d')) return 1;
        if (typeJet.startsWith('2d')) return 2;
        error("Jet inconnu", typeJet);
    }
    return 1;
  }

  // Meilleure carac parmis 2 pour un save.
  function meilleureCarac(carac1, carac2, personnage, seuil) {
    var sansEsprit;
    if (carac1 == 'SAG' || carac1 == 'INT' || carac1 == 'CHA') {
      sansEsprit = charAttributeAsBool(personnage, 'sansEsprit');
      if (sansEsprit) return carac1;
    }
    if (sansEsprit === undefined &&
      (carac2 == 'SAG' || carac2 == 'INT' || carac2 == 'CHA')) {
      sansEsprit = charAttributeAsBool(personnage, 'sansEsprit');
      if (sansEsprit) return carac2;
    }
    var options = {
      cacheBonusToutesCaracs: {}
    };
    var bonus1 = bonusTestCarac(carac1, personnage, options);
    if (carac1 == 'DEX') {
      bonus1 += charAttributeAsInt(personnage, 'reflexesFelins', 0);
      bonus1 += charAttributeAsInt(personnage, 'esquiveVoleur', 0);
    }
    var bonus2 = bonusTestCarac(carac2, personnage, options);
    if (carac2 == 'DEX') {
      bonus2 += charAttributeAsInt(personnage, 'reflexesFelins', 0);
      bonus2 += charAttributeAsInt(personnage, 'esquiveVoleur', 0);
    }
    var nbrDe1 = nbreDeTestCarac(carac1, personnage);
    var nbrDe2 = nbreDeTestCarac(carac2, personnage);
    if (estAffaibli(personnage) && charAttributeAsBool(personnage, 'insensibleAffaibli')) seuil += 2;
    var de1 = deTest(personnage, carac1);
    var proba1 = probaSucces(de1, seuil - bonus1, nbrDe1);
    var de2 = deTest(personnage, carac2);
    var proba2 = probaSucces(de2, seuil - bonus2, nbrDe2);
    if (proba2 > proba1) return carac2;
    return carac1;
  }

  //s représente le save, avec une carac, une carac2 optionnelle et un seuil
  //expliquer est une fonction qui prend en argument un string et le publie
  // options peut contenir les champs :
  //   - msgPour : message d'explication à afficher avant le jet
  //   - msgReussite : message à afficher en cas de réussite
  //   - msgRate : message à afficher si l'action rate
  //   - attaquant : le {charId, token} de l'attaquant contre lequel le save se fait (si il y en a un)
  //   - type : le type de dégâts contre lequel on fait le save
  function save(s, target, saveId, expliquer, options, evt, afterSave) {
    var bonus = 0;
    if (s.fauchage) {
      if (s.fauchage <= taillePersonnage(target, 4)) {
        expliquer(target.token.get('name') + " est trop grand pour être fauché.");
        afterSave(true, '');
        return;
      }
      if (charAttributeAsBool(target, 'inderacinable')) {
        expliquer(target.token.get('name') + " est indéracinable.");
        afterSave(true, '');
        return;
      }
    }
    if (options.attaquant &&
      charAttributeAsBool(target, 'protectionContreLeMal') &&
      estMauvais(options.attaquant)) {
      var bonusProtectionContreLeMal = getValeurOfEffet(target, 'protectionContreLeMal', 2);
      bonus += bonusProtectionContreLeMal;
      expliquer("Protection contre le mal => +" + bonusProtectionContreLeMal + " au jet de sauvegarde");
    }
    var bonusAttrs = [];
    var carac = s.carac;
    //Cas où le save peut se faire au choix parmis 2 caracs
    if (s.carac2) {
      carac = meilleureCarac(carac, s.carac2, target, s.seuil);
    }
    if (carac == 'DEX') {
      bonusAttrs.push('reflexesFelins');
      bonusAttrs.push('esquiveVoleur');
    }
    if (options.sortilege) {
      bonusAttrs.push('resistanceALaMagie');
    }
    if (options.type) {
      bonusAttrs.push('bonusSaveContre_' + options.type);
    }
    if (!options.hideSaveTitle) {
      var title = " Jet de " + carac + " " + s.seuil;
      if (options.msgPour) title += options.msgPour;
      expliquer(title);
    }
    var optionsTest = {...options
    };
    optionsTest.bonusAttrs = bonusAttrs;
    optionsTest.bonus = bonus;
    testCaracteristique(target, carac, s.seuil, saveId, optionsTest, evt,
      function(tr) {
        var smsg = target.token.get('name') + " fait " + tr.texte;
        if (tr.reussite) {
          smsg += " => réussite";
          if (options.msgReussite) smsg += options.msgReussite;
          smsg += tr.modifiers;
        } else {
          smsg += " => échec";
          if (options.msgRate) smsg += options.msgRate;
          smsg += tr.rerolls + tr.modifiers;
        }
        expliquer(smsg);
        afterSave(tr.reussite, tr.texte);
      });
  }

  function partialSave(ps, target, showTotal, dmgDisplay, total, expliquer, evt, afterSave) {
    if (ps.partialSave === undefined) {
      afterSave();
      return;
    }
    if ((ps.partialSave.carac == 'CON' || ps.partialSave.carac2 == 'CON') && estNonVivant(target)) {
      expliquer("Les créatures non-vivantes sont immnunisées aux attaques qui demandent un test de constitution");
      afterSave({
        succes: true,
        dmgDisplay: '0',
        total: 0,
        showTotal: false
      });
      return;
    }
    if (target.partialSaveAuto) {
      if (showTotal) dmgDisplay = '(' + dmgDisplay + ')';
      afterSave({
        succes: true,
        dmgDisplay: dmgDisplay + '/2',
        total: Math.ceil(total / 2),
        showTotal: true
      });
      return;
    }
    var saveOpts = {
      msgPour: " pour réduire les dégâts",
      msgReussite: ", dégâts divisés par 2",
      attaquant: ps.attaquant,
      rolls: ps.rolls,
      chanceRollId: ps.chanceRollId,
      type: ps.type
    };
    var saveId = 'parseSave_' + target.token.id;
    save(ps.partialSave, target, saveId, expliquer, saveOpts, evt,
      function(succes, rollText) {
        if (succes) {
          if (showTotal) dmgDisplay = "(" + dmgDisplay + ")";
          dmgDisplay = dmgDisplay + " / 2";
          showTotal = true;
          total = Math.ceil(total / 2);
        }
        afterSave({
          succes: succes,
          dmgDisplay: dmgDisplay,
          total: total,
          showTotal: showTotal
        });
      });
  }

  function getRDS(perso) {
    if (perso.rd) return perso.rd;
    var res = {
      rdt: 0,
      sauf: {}
    };
    //Pour garder un peu de compatibilité, on regarde encore les attributs RD
    var attrs = perso.attrs;
    if (attrs === undefined) {
      attrs = findObjs({
        _type: "attribute",
        _characterid: perso.charId
      });
      perso.attrs = attrs;
    }
    attrs.forEach(function(a) {
      var name = a.get('name');
      if (!name.startsWith('RD_')) return;
      var rds = parseInt(a.get('current'));
      if (isNaN(rds) || rds === 0) return;
      name = name.substring(3);
      if (name.startsWith('sauf_')) {
        name = name.substr(5);
        res.sauf[name] = res.sauf[name] || 0;
        res.sauf[name] += rds;
        return;
      }
      if (name == 'rdt' || name == 'sauf') return;
      res[name] = res[name] || 0;
      res[name] += rds;
    });
    //Fin compatibilité
    if (attributeAsBool(perso, 'formeDArbre')) {
      res.sauf.feu_hache = res.sauf.feu_hache || 0;
      res.sauf.feu_hache += 10;
    }
    if (charAttributeAsBool(perso, 'fievreChene')) res.feu = (res.feu || 0) + 5;
    if (attributeAsBool(perso, 'armureDEau')) {
      res.acide = (res.acide || 0) + 5;
      res.feu = (res.feu || 0) + 5;
    }
    var rd = ficheAttribute(perso, 'RDS', '');
    rd = (rd + '').trim();
    if (rd === '') {
      perso.rd = res;
      return res;
    }
    rd = rd.split(',');
    rd.forEach(function(r) {
      r = r.trim();
      if (r === '') return;
      var rds;
      var index = r.indexOf(':');
      if (index > 0) { //RD à un type particulier
        var type = r.substring(0, index);
        if (type == 'rdt' || type == 'sauf') return;
        rds = parseInt(r.substring(index + 1));
        if (isNaN(rds) || rds === 0) return;
        res[type] = res[type] || 0;
        res[type] += rds;
        return;
      }
      index = r.indexOf('/');
      if (index > 0) { //RD sauf à des types
        rds = parseInt(r.substring(0, index));
        if (isNaN(rds) || rds === 0) return;
        var sauf = r.substring(index + 1);
        res.sauf[sauf] = res.sauf[sauf] || 0;
        res.sauf[sauf] += rds;
        return;
      }
      //finalement, RD totale
      rds = parseInt(r);
      if (isNaN(rds) || rds === 0) return;
      res.rdt += rds;
    });
    perso.rd = res;
    return res;
  }

  function applyRDSauf(rds, dmgType, total, display, options, target, showTotal, remainingRD) {
    options = options || {};
    var typeTrouve = function(t) {
      if (t == dmgType) return true;
      if (options[t]) return true;
      switch (t) {
        case 'tranchant':
        case 'contondant':
        case 'percant':
          return options.sortilege || dmgType != 'normal';
        default:
          return false;
      }
    };
    if (total) {
      for (var saufType in rds) {
        if (saufType == '1') break;
        var rd = rds[saufType];
        if (rd === 0) break;
        var types = saufType.split('_');
        if (types.find(typeTrouve)) break;
        if (target.ignoreMoitieRD) rd = parseInt(rd / 2);
        if (target.ignoreRD && rd > 0) {
          if (target.ignoreRD > rd) {
            target.ignoreRD -= rd;
            break;
          } else {
            rd -= target.ignoreRD;
            target.ignoreRD = 0;
          }
        }
        if (remainingRD) rd += remainingRD;
        if (total < rd) {
          display += " - " + total;
          rds[saufType] -= total;
          total = 0;
          showTotal = true;
        } else {
          display += " - " + rd;
          total -= rd;
          rds[saufType] = 0;
          showTotal = true;
        }
      }
    }
    return {
      total: total,
      display: display,
      showTotal: showTotal
    };
  }

  function stringOfType(t) {
    switch (t) {
      case 'acide':
        return "l'acide";
      case 'electrique':
        return "l'électricité";
      case 'soniqe':
        return "le son";
      case 'maladie':
        return "les maladies";
      case 'argent':
        return "l'argent";
      default:
        return 'le ' + t;
    }
  }

  //On a déterminé les DM du type principal(possiblement après save des dmgExtra, maintenant on applique les résistances, puis on ajoute les DM d'autres types
  function dealDamageAfterDmgExtra(target, mainDmgType, dmgTotal, dmgDisplay, showTotal, dmgParType, dmgExtra, crit, options, evt, expliquer, displayRes) {
    if (options.pointsVitaux && dmgTotal > 0) { //dégâts retardés pour une pression mortelle
      var pMortelle = tokenAttribute(target, 'pressionMortelle');
      var dmgPMort = dmgTotal;
      var numberPMort = 1;
      if (pMortelle.length > 0) {
        dmgPMort += pMortelle[0].get('current');
        numberPMort += pMortelle[0].get('max');
      }
      setTokenAttr(target, 'pressionMortelle', dmgPMort, evt, {
        maxVal: numberPMort
      });
      dmgTotal = 0;
    }

    if (immuniseAuType(target, mainDmgType, options.attaquant)) {
      if (expliquer && !target['msgImmunite_' + mainDmgType]) {
        target.tokName = target.tokName || target.token.get('name');
        expliquer(target.tokName + " ne semble pas affecté par " + stringOfType(mainDmgType));
      }
      dmgTotal = 0;
      dmgDisplay = '0';
      showTotal = false;
    } else if (!target.ignoreTouteRD) {
      var rd = getRDS(target);
      var rdMain = typeRD(rd, mainDmgType);
      if (mainDmgType == 'normal') {
        if (options.tranchant && rd.tranchant) rdMain += rd.tranchant;
        if (options.percant && rd.percant) rdMain += rd.percant;
        if (options.contondant && rd.contondant) rdMain += rd.contondant;
      }
      if (rd.drain && (options.vampirise || target.vampirise)) {
        rdMain += rd.drain;
      }
      if (options.hache && rd.hache) {
        rdMain += rd.hache;
      }
      if (target.ignoreMoitieRD) rdMain = parseInt(rdMain / 2);
      if (target.ignoreRD) {
        if (target.ignoreRD > rdMain) {
          target.ignoreRD -= rdMain;
          rdMain = 0;
        } else {
          rdMain -= target.ignoreRD;
          target.ignoreRD = 0;
        }
      }
      if (rdMain > 0 && dmgTotal > 0) {
        dmgTotal -= rdMain;
        if (dmgTotal < 0) {
          rdMain += dmgTotal;
          dmgTotal = 0;
        }
        dmgDisplay += " - " + rdMain;
        showTotal = true;
      }
      var rdElems = 0;
      if (attributeAsBool(target, 'protectionContreLesElements')) {
        rdElems = getValeurOfEffet(target, 'protectionContreLesElements', 1, 'voieDeLaMagieElementaire') * 2;
      }
      if (rd.elementaire) rdElems += rd.elementaire;
      if (target.ignoreMoitieRD) rdElems = parseInt(rdElems / 2);
      if (rdElems > 0 && dmgTotal > 0 && estElementaire(mainDmgType)) {
        if (dmgTotal > rdElems) {
          dmgDisplay += ' - ' + rdElems;
          dmgTotal -= rdElems;
          rdElems = 0;
        } else {
          dmgDisplay += ' - ' + dmgTotal;
          rdElems -= dmgTotal;
          dmgTotal = 0;
        }
      }
      var additionalType = {
        magique: options.magique,
        tranchant: options.tranchant,
        percant: options.percant,
        contondant: options.contondant,
        sortilege: options.sortilege,
        hache: options.hache,
      };
      var remainingRD = 0;
      if (rdMain < 0) remainingRD = rdMain;
      var resSauf = applyRDSauf(rd.sauf, mainDmgType, dmgTotal, dmgDisplay, additionalType, target, showTotal, remainingRD);
      dmgTotal = resSauf.total;
      dmgDisplay = resSauf.display;
      showTotal = resSauf.showTotal;
      var invulnerable = charAttributeAsBool(target, 'invulnerable');
      var mitigate = function(dmgType, divide, zero) {
        if (!options.sortilege && attributeAsBool(target, 'flou')) {
          divide();
        }
        if (options.attaqueMentale && charAttributeAsBool(target, 'bouclierPsi')) {
          divide();
        }
        if (options.aoe &&
          (attributeAsBool(target, 'protectionDMZone') ||
            attributeAsBool(target, 'protectionDMZone_' + dmgType))) {
          divide();
          expliquer(target.token.get('name') + " est protégé contre les dégâts de zone");
        }
        if (attributeAsBool(target, 'resistanceA_' + dmgType) || charAttributeAsBool(target, 'diviseEffet_' + dmgType)) {
          divide();
        }
        if (attributeAsBool(target, 'resistanceA_nonMagique') && !options.magique && !options.sortilege) {
          divide();
        }
        if (estElementaire(dmgType)) {
          if (invulnerable) {
            divide();
          }
          switch (dmgType) {
            case 'froid':
              if (attributeAsBool(target, 'masqueMortuaire')) divide();
              if (attributeAsBool(target, 'mutationFourrureViolette')) divide();
              break;
            case 'feu':
              if (attributeAsBool(target, 'presenceGlaciale')) divide();
              if (attributeAsBool(target, 'mutationEcaillesRouges')) divide();
              break;
            case 'acide':
              if (attributeAsBool(target, 'mutationEcaillesRouges')) divide();
              break;
            case 'electrique':
              if (attributeAsBool(target, 'mutationFourrureViolette')) divide();
              break;
          }
        } else if (dmgType == 'poison' || dmgType == 'maladie') {
          if (invulnerable ||
            charAttributeAsBool(target, 'creatureArtificielle') ||
            estNonVivant(target)) {
            zero();
          } else if (attributeAsBool(target, 'mutationSangNoir')) {
            divide();
          }
        } else {
          if (options.tranchant && attributeAsBool(target, 'resistanceA_tranchant')) {
            divide();
          } else if (options.percant && attributeAsBool(target, 'resistanceA_percant')) {
            divide();
          } else if (options.contondant && attributeAsBool(target, 'resistanceA_contondant')) {
            divide();
          }
          if (attributeAsBool(target, 'armureMagique')) {
            divide();
          }
        }
      };
      // Damage mitigaters for main damage
      mitigate(mainDmgType,
        function() {
          dmgTotal = Math.ceil(dmgTotal / 2);
          if (dmgExtra) dmgDisplay = "(" + dmgDisplay + ")";
          dmgDisplay += " / 2";
          showTotal = true;
        },
        function() {
          if (dmgTotal > 0) {
            dmgDisplay += '-' + dmgTotal;
            dmgTotal = 0;
          }
        });
    }
    var dmSuivis = {}; //si il faut noter les DMs d'un type particulier
    charAttribute(target.charId, 'vitaliteSurnaturelle').forEach(function(a) {
      var typeVitalite = a.get('max').split(',');
      typeVitalite.forEach(function(tv) {
        if (tv == mainDmgType) dmSuivis[tv] = dmgTotal;
        else dmSuivis[tv] = 0;
      });
    });
    // Other sources of damage
    // First count all other sources of damage, for synchronization
    var count = 0;
    for (var dt in dmgParType) {
      if (immuniseAuType(target, dt, options.attaquant)) {
        if (expliquer && !target['msgImmunite_' + dt]) {
          target.tokName = target.tokName || target.token.get('name');
          expliquer(target.tokName + " ne semble pas affecté par " + stringOfType(dt));
        }
        delete dmgParType[dt];
      } else
        count += dmgParType[dt].length;
    }
    var critOther = crit && reglesOptionelles.dommages.val.crit_elementaire.val;
    var dealOneType = function(dmgType) {
      if (dmgType == mainDmgType) {
        count -= dmgParType[dmgType].length;
        if (count === 0) dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis);
        return; //type principal déjà géré
      }
      showTotal = true;
      var dm = 0;
      var typeDisplay = "";
      var typeCount = dmgParType[dmgType].length;
      dmgParType[dmgType].forEach(function(d) {
        if (d.partialSave && d.partialSave.tempete && options.tempeteDeManaIntense) {
          d.partialSave.seuil += d.partialSave.tempete * options.tempeteDeManaIntense;
        }
        partialSave(d, target, false, d.display, d.total, expliquer, evt,
          function(res) {
            var addTypeDisplay = d.display;
            if (res) {
              dm += res.total;
              if (critOther) {
                dm += res.total;
                if (options.memePasMal) options.memePasMal += res.total;
              }
              addTypeDisplay = res.dmgDisplay;
            } else {
              dm += d.total;
              if (critOther) {
                dm += d.total;
                if (options.memePasMal) options.memePasMal += d.total;
              }
            }
            if (critOther) addTypeDisplay = '(' + addTypeDisplay + ') x2';
            if (typeDisplay === '') typeDisplay = addTypeDisplay;
            else typeDisplay += "+" + addTypeDisplay;
            typeCount--;
            if (typeCount === 0) {
              if (!target.ignoreTouteRD) {
                var rdl = typeRD(rd, dmgType);
                if (dmgType == 'normal') {
                  if (options.tranchant && rd.tranchant) rdl += rd.tranchant;
                  if (options.percant && rd.percant) rdl += rd.percant;
                  if (options.contondant && rd.contondant) rdl += rd.contondant;
                }
                if (target.ignoreMoitieRD) rdl = parseInt(rdl / 2);
                if (target.ignoreRD) {
                  if (target.ignoreRD > rdl) {
                    target.ignoreRD -= rdl;
                    rdl = 0;
                  } else {
                    rdl -= target.ignoreRD;
                    target.ignoreRD = 0;
                  }
                }
                if (rdl > 0 && dm > 0) {
                  dm -= rdl;
                  if (dm < 0) {
                    rdl += dm;
                    dm = 0;
                  }
                  typeDisplay += "-" + rdl;
                }
                if (rdElems > 0 && dm > 0 && estElementaire(dmgType)) {
                  if (dm > rdElems) {
                    typeDisplay += ' - ' + rdElems;
                    dm -= rdElems;
                    rdElems = 0;
                  } else {
                    typeDisplay += ' - ' + dm;
                    rdElems -= dm;
                    dm = 0;
                  }
                }
                var additionalType = {
                  sortilege: options.sortilege,
                  magique: options.magique
                };
                var resSauf = applyRDSauf(rd.sauf, dmgType, dm, typeDisplay, additionalType, target);
                dm = resSauf.total;
                typeDisplay = resSauf.display;
                mitigate(dmgType,
                  function() {
                    dm = Math.ceil(dm / 2);
                    if (dmgParType[dmgType].length > 1) typeDisplay = "(" + typeDisplay + ")";
                    typeDisplay += " / 2";
                  },
                  function() {
                    if (dm > 0) {
                      typeDisplay += "-" + dm;
                      dm = 0;
                    }
                  });
                dmgTotal += dm;
                dmgDisplay += "+" + typeDisplay;
                if (_.has(dmSuivis, dmgType)) {
                  dmSuivis[dmgType] = dm;
                }
              }
            }
            count--;
            if (count === 0) dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis);
          });
      });
    };
    if (count > 0) {
      for (var dmgType in dmgParType) {
        dealOneType(dmgType);
      }
    } else {
      return dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis);
    }
  }

  //Appelé quand on met à 0 PV
  function mort(personnage, expliquer, evt) {
    if (charAttributeAsBool(personnage, 'exsangue') && !attributeAsBool(personnage, 'etatExsangue')) {
      var msg;
      if (expliquer) {
        personnage.tokName = personnage.tokName || personnage.token.get('name');
        expliquer(personnage.tokName + " continue à agir malgré son état");
      } else msg = "continue à agir malgré son état";
      setTokenAttr(personnage, 'etatExsangue', true, evt, {
        msg: msg
      });
      return;
    }
    if (charAttributeAsBool(personnage, 'energieDeLaMort')) {
      personnage.tokName = personnage.tokName || personnage.token.get('name');
      var duree = rollDePlus(6, {
        bonus: 5
      });
      sendChat('', '/w GM ' + personnage.tokName + ' réapparaîtra dans ' + duree.roll + ' tours.');
      var effet = 'messageRetarde(réapparition)';
      setAttrDuree(personnage, effet, duree.val - 1, evt);
      setToken(personnage.token, 'layer', 'gmlayer', evt);
      if (personnage.attaquant) {
        var dm = rollDePlus(6);
        var dmg = {
          type: 'magique',
          display: dm.roll,
          total: dm.val
        };
        var pvMax = parseInt(personnage.token.get('bar1_max'));
        pvMax += dm.val;
        updateCurrentBar(personnage, 1, pvMax, evt, pvMax);
        var explications = [];
        dealDamage(personnage.attaquant, dmg, [], evt, false, {}, explications,
          function(dmgDisplay, dmgFinal) {
            setTokenAttr(personnage, effet + 'Valeur', personnage.tokName + " réapparait avec " + dmgFinal + " PV en plus.", evt);
            var attName = personnage.attaquant.tokName || personnage.attaquant.token.get('name');
            var msg = "se transforme en brume noire qui traverse " + attName + " de part en part avant de disparaître dans une paroi en poussant un hululement inhumain. le froid de la mort inflige " + dmgDisplay + " DM à " + attName;
            if (expliquer) {
              expliquer(personnage.tokName + ' ' + msg);
            } else {
              sendChar(personnage.charId, msg);
            }
          });
      }
      return;
    }
    setState(personnage, 'mort', true, evt);
    var targetPos = {
      x: personnage.token.get('left'),
      y: personnage.token.get('top')
    };
    spawnFxBetweenPoints(targetPos, {
      x: 400,
      y: 400
    }, "splatter-blood");
  }

  function dmgNaturel(options) {
    if (options.nature) return true;
    if (options.artificiel) return false;
    var attaquant = options.attaquant;
    if (attaquant === undefined) return false;
    if (estAnimal(attaquant)) return true;
    if (charAttributeAsBool(attaquant, 'insecte')) return true;
    var attr = findObjs({
      _type: 'attribute',
      _characterid: attaquant.charId,
    });
    var attrProfile = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'PROFIL';
    });
    if (attrProfile.length > 0) {
      if (attrProfile[0].get('current').trim().toLowerCase() == 'insecte') {
        return true;
      }
    }
    var attrRace = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'RACE';
    });
    if (attrRace.length === 0) return false;
    var charRace = attrRace[0].get('current').trim().toLowerCase();
    switch (charRace) {
      case 'insecte':
      case 'ankheg':
      case 'araignée':
      case 'araignee':
      case 'guêpe':
      case 'libellule':
      case 'scarabée':
      case 'scorpion':
      case 'strige':
        return true;
      default:
        return false;
    }
  }

  function testBlessureGrave(target, dmgTotal, expliquer, evt) {
    target.tokName = target.tokName || target.token.get('name');
    if (reglesOptionelles.dommages.val.blessures_graves.val && estPJ(target) && (dmgTotal == 'mort' ||
        dmgTotal >
        (ficheAttributeAsInt(target, 'niveau', 1) +
          ficheAttributeAsInt(target, 'constitution', 10)))) {
      var pr = pointsDeRecuperation(target);
      if (pr.current > 0) {
        expliquer("Les dégâts sont si importants que " + target.tokName + " perd 1 PR");
        enleverPointDeRecuperation(target, evt);
      } else if (getState(target, 'blesse')) {
        if (getState(target, 'mort')) {
          expliquer("Avec la blessure grave, c'est vraiment la fin, " + target.tokName + " ne se relèvera plus...");
        } else {
          expliquer("Les dégâts sont trop importants, et " + target.tokName + " s'effondre");
          mort(target, expliquer, evt);
        }
      } else {
        setState(target, 'blesse', true, evt);
        expliquer("Les dégâts occasionnent une blessure grave !");
      }
    }
  }

  function enlevePVStatueDeBois(perso, pvPerdus, evt) {
    if (pvPerdus <= 0) return;
    var attrs = tokenAttribute(perso, 'statueDeBoisValeur');
    if (attrs.length === 0) return;
    var cur = parseInt(attrs[0].get('current'));
    var attrsB = tokenAttribute(perso, 'statueDeBois');
    if (attrsB.length === 0) {
      error("Attribut pour l'effet status de bois introuvable", cur);
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attrs[0]);
      attrs[0].remove();
    }
    if (isNaN(cur)) {
      finDEffet(attrsB[0], 'statueDeBois', attrsB[0].get('name'), perso.charId, evt);
      return;
    }
    var newCur = cur - pvPerdus;
    if (newCur <= 0) {
      finDEffet(attrsB[0], 'statueDeBois', attrsB[0].get('name'), perso.charId, evt);
      return;
    }
    evt.attributes = evt.attributes || [];
    evt.attributes.push({
      attribute: attrs[0],
      current: cur,
      max: attrs[0].get('max')
    });
    attrs[0].set('current', newCur);
  }

  function finDEffetDeNom(perso, effet, evt, options) { //Supprime l'effet si présent
    var attrs = tokenAttribute(perso, effet);
    if (attrs.length === 0) return;
    attrs = attrs[0];
    options = options || {};
    options.pageId = options.pageId || perso.token.get('pageid');
    finDEffet(attrs, effetTempOfAttribute(attrs), attrs.get('name'), perso.charId, evt, options);
  }

  function dealDamageAfterOthers(target, crit, options, evt, expliquer, displayRes, dmgTotal, dmgDisplay, showTotal, dmSuivis) {
    var charId = target.charId;
    var token = target.token;
    // Now do some dmg mitigation rolls, if necessary
    if ((options.distance || options.aoe) &&
      attributeAsBool(target, 'aCouvert')) {
      if (showTotal) dmgDisplay = "(" + dmgDisplay + ")";
      dmgDisplay += " / 2";
      dmgTotal = Math.ceil(dmgTotal / 2);
      dmSuivis = _.map(dmSuivis, function(d) {
        return Math.ceil(d / 2);
      });
      showTotal = true;
    }
    if (options.partialSave && options.partialSave.tempete && options.tempeteDeManaIntense) {
      options.partialSave.seuil += options.partialSave.tempete * options.tempeteDeManaIntense;
    }
    partialSave(options, target, showTotal, dmgDisplay, dmgTotal,
      expliquer, evt,
      function(saveResult) {
        if (saveResult) {
          if (saveResult.total < dmgTotal) {
            dmgTotal = saveResult.total;
            dmSuivis = _.map(dmSuivis, function(d) {
              return Math.ceil(d / 2);
            });
          }
          dmgDisplay = saveResult.dmgDisplay;
          showTotal = saveResult.showTotal;
        }
        var rdTarget = getRDS(target);
        var rd = rdTarget.rdt || 0;
        if (rd > 0 && !options.aoe && options.attaquant && charAttributeAsBool(options.attaquant, 'ventreMou')) {
          var taille = taillePersonnage(target, 4);
          if (taille > 4) {
            if (target.messages) target.messages.push("Ventre mou => L'attaque ignore la RD dûe à la taille");
            rd -= 3 * (taille - 4);
            if (taille > 6) rd--;
            if (rd < 0) rd = 0;
          }
        }
        if (charAttributeAsBool(target, 'hausserLeTon')) {
          if (parseInt(target.token.get('bar1_value')) <= target.token.get('bar1_max') / 2) {
            rd += 5;
          }
        }
        if (target.attaquant && charAttributeAsBool(target, 'combatKinetique') &&
          !getState(target, 'endormi') && !getState(target, 'assome') &&
          !getState(target, 'mort') && !getState(target, 'surpris') &&
          !getState(target, 'etourdi')) {
          rd += 3;
        }
        if (attributeAsBool(target, 'statueDeBois')) rd += 10;
        if (attributeAsBool(target, 'mutationSilhouetteMassive')) rd += 3;
        if (crit) {
          var rdCrit = charAttributeAsInt(target, 'RD_critique', 0); //pour la compatibilité
          if (ficheAttributeAsBool(target, 'casque_on', false))
            rdCrit += ficheAttributeAsInt(target, 'casque_rd', 0);
          rd += rdCrit;
          if (options.memePasMal) options.memePasMal -= rdCrit;
        }
        if (options.distance) {
          if (rdTarget.distance) rd += rdTarget.distance;
          var piqures = charAttributeAsInt(target, 'piquresDInsectes', 0);
          if (piqures > 0) {
            if (persoEstPNJ(target) || (ficheAttributeAsBool(target, 'DEFARMUREON', false) && ficheAttributeAsInt(target, 'DEFARMURE', 0) > 5)) {
              rd += piqures;
            }
          }
        }
        if (attributeAsBool(target, 'masqueMortuaire')) rd += 2;
        if (rdTarget.nature > 0 && dmgNaturel(options)) rd += rdTarget.nature;
        if (dmgTotal > rd && rdTarget.sauf[1]) {
          if (dmgTotal > rd + rdTarget.sauf[1]) rd += rdTarget.sauf[1];
          else rd = dmgTotal - 1;
        }
        if (target.defautCuirasse) rd = 0;
        if (options.intercepter) rd += options.intercepter;
        if (target.extraRD) {
          rd += target.extraRD;
          expliquer(target.tokName + " dévie le coup sur son armure");
        }
        if (target.ignoreTouteRD) rd = 0;
        else if (target.ignoreMoitieRD) rd = parseInt(rd / 2);
        if (target.ignoreRD) {
          rd -= target.ignoreRD; //rd peut être négatif
        }
        //Option Max Rune de Protection
        if (target.utiliseRuneProtectionMax) {
          rd += target.utiliseRuneProtectionMax;
          if (dmgTotal <= rd) expliquer("La rune de protection absorbe tous les dommages");
          else expliquer("La rune de protection encaisse " + target.utiliseRuneProtectionMax + " dommages");
        }
        //RD PeauDePierre à prendre en compte en dernier
        if (!target.defautCuirasse && !target.ignoreTouteRD && rd < dmgTotal && attributeAsBool(target, 'peauDePierreMag')) {
          var peauDePierreMagValeur = tokenAttribute(target, 'peauDePierreMagValeur');
          if (peauDePierreMagValeur.length === 0) {
            error("compteur de Peau de Pierre non trouvé", target);
          } else {
            peauDePierreMagValeur = peauDePierreMagValeur[0];
            var rdPeauDePierreMax = parseInt(peauDePierreMagValeur.get('current'));
            var peauDePierreAbsorbe = parseInt(peauDePierreMagValeur.get('max'));
            if (isNaN(rdPeauDePierreMax) || isNaN(peauDePierreAbsorbe) || rdPeauDePierreMax < 1 || peauDePierreAbsorbe < 1) {
              error("compteur de Peau de Pierre mal formé", peauDePierreMagValeur);
              finDEffetDeNom(target, "peauDePierreMag", evt);
            } else {
              var rdPeauDePierreMag = rdPeauDePierreMax;
              if (target.ignoreMoitieRD) rdPeauDePierreMag = parseInt(rdPeauDePierreMag / 2);
              if (rd + rdPeauDePierreMag > dmgTotal) {
                rdPeauDePierreMag = dmgTotal - rd;
              }
              if (rdPeauDePierreMag >= peauDePierreAbsorbe) {
                rdPeauDePierreMag = peauDePierreAbsorbe;
                finDEffetDeNom(target, "peauDePierreMag", evt);
              } else {
                peauDePierreAbsorbe -= rdPeauDePierreMag;
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: peauDePierreMagValeur,
                  current: rdPeauDePierreMax,
                  max: peauDePierreAbsorbe
                });
                peauDePierreMagValeur.set('max', peauDePierreAbsorbe);
              }
              rd += rdPeauDePierreMag;
            }
          }
        }
        if (rd > 0) {
          if (showTotal) dmgDisplay = "(" + dmgDisplay + ") - " + rd;
          else {
            dmgDisplay += " - " + rd;
            showTotal = true;
          }
        }
        dmgTotal -= rd;
        for (var dmSuiviType in dmSuivis) {
          if (rd === 0) break;
          dmSuivis[dmSuiviType] -= rd;
          if (dmSuivis[dmSuiviType] < 0) {
            rd = -dmSuivis[dmSuiviType];
            dmSuivis[dmSuiviType] = 0;
          } else rd = 0;
        }
        if (options.metal && attributeAsBool(target, 'magnetisme')) {
          if (showTotal) dmgDisplay = "(" + dmgDisplay + ") / 2";
          else dmgDisplay += " / 2";
          showTotal = true;
          dmgTotal = Math.ceil(dmgTotal / 2);
          if (options.memePasMal)
            options.memePasMal = Math.ceil(options.memePasMal / 2);
          dmSuivis = _.map(dmSuivis, function(d) {
            return Math.ceil(d / 2);
          });
        }
        if (charAttributeAsBool(target, 'commandant')) {
          //On cherche si il y a au moins 4 créatures sous ses ordres à moins de 10 m
          var pageId = target.token.get('pageid');
          var tokens =
            findObjs({
              _type: 'graphic',
              _subtype: 'token',
              layer: 'objects',
              _pageid: pageId
            });
          var nbCreatures = 0;
          tokens.forEach(function(tok) {
            if (tok.id === target.token.id) return;
            var ci = tok.get('represents');
            if (ci === '') return;
            if (distanceCombat(tok, target.token, pageId) > 10) return;
            var attrCom = charAttribute(ci, 'capitaine');
            if (attrCom.length === 0) return;
            var capitaine = persoOfIdName(attrCom[0].get('current'), pageId);
            if (!capitaine || capitaine.token.id != target.token.id) return;
            var perso = {
              token: tok,
              charId: ci
            };
            if (isActive(perso)) nbCreatures++;
          });
          if (nbCreatures > 3) {
            if (showTotal) dmgDisplay = "(" + dmgDisplay + ") / 2";
            else dmgDisplay += " / 2";
            showTotal = true;
            dmgTotal = Math.ceil(dmgTotal / 2);
            if (options.memePasMal)
              options.memePasMal = Math.ceil(options.memePasMal / 2);
            dmSuivis = _.map(dmSuivis, function(d) {
              return Math.ceil(d / 2);
            });
          }
        }
        if (dmgTotal < reglesOptionelles.dommages.val.dm_minimum.val) {
          dmgTotal = reglesOptionelles.dommages.val.dm_minimum.val;
          dmgDisplay += "-> " + reglesOptionelles.dommages.val.dm_minimum.val;
        }
        if (options.divise) {
          dmgTotal = Math.ceil(dmgTotal / options.divise);
          if (options.memePasMal)
            options.memePasMal = Math.ceil(options.memePasMal / options.divise);
          dmSuivis = _.map(dmSuivis, function(d) {
            return Math.ceil(d / options.divise);
          });
          dmgDisplay = "(" + dmgDisplay + ")/" + options.divise;
          showTotal = true;
        }
        if (crit && options.memePasMal && options.memePasMal > 0) {
          dmgTotal -= options.memePasMal;
          if (dmgTotal < 0) {
            options.memePasMal += dmgTotal;
            dmgTotal = 0;
          }
          expliquer("Même pas mal : ignore " + options.memePasMal + " PVs et peut enrager");
          var mpm = attributeAsInt(target, 'memePasMalIgnore', 0);
          setTokenAttr(target, 'memePasMalIgnore', mpm + options.memePasMal, evt);
          setAttrDuree(target, 'memePasMalBonus', 3, evt);
        }
        // compute effect on target
        var bar1 = parseInt(token.get('bar1_value'));
        var pvmax = parseInt(token.get('bar1_max'));
        if (isNaN(bar1)) {
          error("Pas de points de vie chez la cible", token);
          bar1 = 0;
          pvmax = 0;
        } else if (isNaN(pvmax)) {
          pvmax = bar1;
          token.set("bar1_max", bar1);
        }
        var hasMana = (ficheAttributeAsInt(target, 'PM', 0) > 0);
        var tempDmg = 0;
        var estMook = token.get("bar1_link") === '';
        var nameAttrDMTEMP = 'DMTEMP';
        if (hasMana) {
          if (estMook) tempDmg = attributeAsInt(target, 'DMTEMP', 0);
          else tempDmg = ficheAttributeAsInt(target, nameAttrDMTEMP, 0);
        } else {
          tempDmg = parseInt(token.get("bar2_value"));
          if (isNaN(tempDmg)) {
            if (target.tempDmg) { //then try to set bar2 correctly
              if (estMook) {
                token.set("bar2_max", pvmax);
              } else {
                var tmpHitAttr =
                  findObjs({
                    _type: "attribute",
                    _characterid: charId,
                    name: nameAttrDMTEMP
                  }, {
                    caseInsensitive: true
                  });
                var dmTemp;
                if (tmpHitAttr.length === 0) {
                  dmTemp =
                    createObj("attribute", {
                      characterid: charId,
                      name: nameAttrDMTEMP,
                      current: 0,
                      max: pvmax
                    });
                } else {
                  dmTemp = tmpHitAttr[0];
                }
                token.set("bar2_max", pvmax);
                token.set("bar2_link", dmTemp.id);
              }
            }
            tempDmg = 0;
          }
        }
        if (!options.aoe && charAttributeAsBool(target, 'ciblesMultiples')) {
          dmgTotal = 1;
          expliquer("La nuée est constituée de très nombreuses cibles, l'attaque ne lui fait qu'1 DM");
        }
        var pvPerdus = dmgTotal;
        if (target.tempDmg) {
          tempDmg += dmgTotal;
          if (tempDmg > pvmax) {
            pvPerdus -= tempDmg - pvmax;
            tempDmg = pvmax;
          }
          if (hasMana) {
            setTokenAttr(target, nameAttrDMTEMP, tempDmg, evt);
          } else {
            updateCurrentBar(target, 2, tempDmg, evt);
          }
          enlevePVStatueDeBois(target, pvPerdus, evt);
        } else {
          if (bar1 > 0 && bar1 <= dmgTotal &&
            charAttributeAsBool(target, 'instinctDeSurvieHumain')) {
            dmgTotal = Math.floor(dmgTotal / 2);
            dmSuivis = _.map(dmSuivis, function(d) {
              return Math.ceil(d / 2);
            });
            if (dmgTotal < 1) dmgTotal = 1;
            dmgDisplay += "/2";
            showTotal = true;
            expliquer("L'instinct de survie aide à réduire une attaque fatale");
          }
          pvPerdus = dmgTotal;
          bar1 = bar1 - dmgTotal;
          if (crit) { //Vulnérabilité aux critiues
            var vulnerableCritique = charAttributeAsInt(target, 'vulnerableCritique', 0);
            if (vulnerableCritique > 0) {
              if (randomInteger(100) <= vulnerableCritique) {
                expliquer("Le coup critique le fait voler en éclats");
                if (bar1 > 0) {
                  dmgTotal += bar1;
                  pvPerdus += bar1;
                  bar1 = 0;
                }
              } else {
                expliquer("Le coup critique fait vibrer l'adversaire, mais il résiste.");
              }
            }
          }
          if ((crit || bar1 < pvmax / 2) &&
            charAttributeAsBool(target, 'peutEnrager') &&
            !attributeAsBool(target, 'enragé')) {
            setTokenAttr(target, 'enragé', true, evt);
            expliquer(target.tokName + " devient enragé" + eForFemale(target) + ".");
            finDEffetDeNom(target, 'apeureTemp', evt);
            finDEffetDeNom(target, 'peurEtourdi', evt);
            setState(target, 'apeure', false, evt);
          }
          if (bar1 <= 0) {
            var attrFDA = tokenAttribute(target, 'formeDArbre');
            if (attrFDA.length > 0) {
              var effetFDA = finDEffet(attrFDA[0], 'formeDArbre', attrFDA[0].get('name'), charId, evt, {
                pageId: token.get('pageid')
              });
              if (effetFDA && effetFDA.newToken) {
                token = effetFDA.newToken;
                target.token = token;
              }
              var newBar1 = parseInt(token.get('bar1_value'));
              if (isNaN(newBar1) || newBar1 < 0) {
                error("Points de vie de l'ancien token incorrects", newBar1);
              } else {
                bar1 += newBar1;
              }
            }
          }
          //On enregistre les dm suivis
          for (var dmType in dmSuivis) {
            var d = dmSuivis[dmType];
            if (d) {
              var attrDmSuivi = tokenAttribute(target, 'DMSuivis' + dmType);
              if (attrDmSuivi.length > 0) {
                var cd = parseInt(attrDmSuivi[0].get('current'));
                if (cd > 0) d += cd;
                attrDmSuivi[0].set('current', d);
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: attrDmSuivi[0],
                  current: cd
                });
              } else {
                setTokenAttr(target, 'DMSuivis' + dmType, d, evt);
              }
            }
          }
          if (bar1 <= 0) {
            var defierLaMort = charAttributeAsInt(target, 'defierLaMort', 0);
            if (charAttributeAsBool(target, 'sergent') &&
              !attributeAsBool(target, 'sergentUtilise')) {
              expliquer(token.get('name') + " évite l'attaque in-extremis");
              setTokenAttr(target, 'sergentUtilise', true, evt);
              pvPerdus = 0;
            } else if (defierLaMort > 0) {
              pvPerdus += bar1;
              var rollId = 'defierLaMort_' + target.token.id;
              var saveOpts = {
                msgPour: " pour défier la mort",
                msgReussite: ", conserve 1 PV",
                rolls: options.rolls,
                chanceRollId: options.chanceRollId
              };
              save({
                  carac: 'CON',
                  seuil: defierLaMort
                }, target, rollId, expliquer, saveOpts, evt,
                function(reussite, rollText) {
                  if (reussite) {
                    updateCurrentBar(target, 1, 1, evt);
                    bar1 = 1;
                    pvPerdus--;
                    setTokenAttr(target, 'defierLaMort', defierLaMort + 10, evt);
                    enlevePVStatueDeBois(target, pvPerdus, evt);
                  } else {
                    testBlessureGrave(target, dmgTotal, expliquer, evt);
                    updateCurrentBar(target, 1, 0, evt);
                    if (charAttributeAsBool(target, 'durACuire') &&
                      !attributeAsBool(target, 'aAgiAZeroPV')) {
                      var msgAgitZero = token.get('name') + " devrait être mort";
                      msgAgitZero += eForFemale(target) + ", mais ";
                      msgAgitZero += onGenre(target, 'il', 'elle') + " continue à se battre !";
                      expliquer(msgAgitZero);
                      if (!attributeAsBool(target, 'agitAZeroPV'))
                        setAttrDuree(target, 'agitAZeroPV', 1, evt);
                    } else {
                      mort(target, expliquer, evt);
                    }
                  }
                  if (bar1 > 0 && tempDmg >= bar1) { //assomé
                    setState(target, 'assome', true, evt);
                  }
                  if (showTotal) dmgDisplay += " = " + dmgTotal;
                  if (displayRes === undefined) return dmgDisplay;
                  displayRes(dmgDisplay, pvPerdus);
                });
              if (displayRes === undefined) return dmgDisplay;
              return;
            } else {
              testBlessureGrave(target, dmgTotal, expliquer, evt);
              updateCurrentBar(target, 1, 0, evt);
              pvPerdus += bar1;
              if (charAttributeAsBool(target, 'baroudHonneur')) {
                var msgBarroud = token.get('name') + " devrait être mort";
                msgBarroud += eForFemale(target) + ", mais ";
                msgBarroud += onGenre(target, 'il', 'elle') + " continue à se battre !";
                expliquer(msgBarroud);
                setTokenAttr(target, 'baroudHonneurActif', true, evt);
              } else if (attributeAsInt(target, 'increvable', 0) > 0) {
                var msgIncrevable = token.get('name') + " devrait être mort";
                msgIncrevable += eForFemale(target) + ", mais ";
                msgIncrevable += onGenre(target, 'il', 'elle') + " est increvable !";
                expliquer(msgIncrevable);
                setTokenAttr(target, 'increvable', 0, evt);
                setTokenAttr(target, 'increvableActif', true, evt);
              } else if ((attributeAsBool(target, 'enragé') || charAttributeAsBool(target, 'durACuire')) &&
                !attributeAsBool(target, 'aAgiAZeroPV')) {
                var msgAgitZ = token.get('name') + " devrait être mort";
                msgAgitZ += eForFemale(target) + ", mais ";
                msgAgitZ += onGenre(target, 'il', 'elle') + " continue à se battre !";
                expliquer(msgAgitZ);
                if (!attributeAsBool(target, 'agitAZeroPV'))
                  setAttrDuree(target, 'agitAZeroPV', 1, evt);
              } else if (charAttributeAsBool(target, 'nAbandonneJamais')) {
                if (attributeAsBool(target, 'mortMaisNAbandonnePas')) {
                  expliquer(token.get('name') + " est dans un état lamentable, mais continue à bouger. Il faudrait une action limitée pour le réduire en miettes.");
                } else {
                  expliquer(token.get('name') + " est pratiquement détruit, mais continue à bouger !");
                  setTokenAttr(target, 'mortMaisNAbandonnePas', true, evt);
                  setState(target, 'ralenti', true, evt);
                }
              } else {
                mort(target, expliquer, evt);
                testBlessureGrave(target, 'mort', expliquer, evt);
              }
            }
          } else { // bar1>0
            testBlessureGrave(target, dmgTotal, expliquer, evt);
            updateCurrentBar(target, 1, bar1, evt);
            enlevePVStatueDeBois(target, pvPerdus, evt);
          }
        }
        if (bar1 > 0 && tempDmg >= bar1) { //assomé
          setState(target, 'assome', true, evt);
        }
        if (showTotal) dmgDisplay += " = " + dmgTotal;
        if (displayRes === undefined) return dmgDisplay;
        displayRes(dmgDisplay, pvPerdus);
      });
    return dmgDisplay;
  }

  function buildinline(inlineroll, dmgType, magique) {
    var InlineColorOverride = "";
    var values = [];
    var critRoll = false;
    var failRoll = false;
    var critCheck = false;
    var failCheck = false;
    var highRoll = false;
    var lowRoll = false;
    var noHighlight = false;

    inlineroll.results.rolls.forEach(function(roll) {
      var result = processRoll(roll, critRoll, failRoll, highRoll, lowRoll, noHighlight);
      if (result.value.toString().indexOf("critsuccess") != -1) critCheck = true;
      if (result.value.toString().indexOf("critfail") != -1) failCheck = true;
      values.push(result.value);
      critRoll = result.critRoll;
      failRoll = result.failRoll;
      highRoll = result.highRoll;
      lowRoll = result.lowRoll;
      noHighlight = result.noHighlight;
    });

    // Overrides the default coloring of the inline rolls...
    switch (dmgType) {
      case 'normal':
      case 'maladie':
        if (magique)
          InlineColorOverride = ' background-color: #FFFFFF; color: #534200;';
        else
          InlineColorOverride = ' background-color: #F1E6DA; color: #000;';
        break;
      case 'feu':
        InlineColorOverride = ' background-color: #FF3011; color: #440000;';
        break;
      case 'froid':
        InlineColorOverride = ' background-color: #77FFFF; color: #004444;';
        break;
      case 'acide':
        InlineColorOverride = ' background-color: #80BF40; color: #020401;';
        break;
      case 'sonique':
        InlineColorOverride = ' background-color: #E6CCFF; color: #001144;';
        break;
      case 'electrique':
        InlineColorOverride = ' background-color: #FFFF80; color: #222200;';
        break;
      case 'poison':
        InlineColorOverride = ' background-color: #558000; color: #DDAFFF;';
        break;
      case 'argent':
        InlineColorOverride = ' background-color: #F1E6DA; color: #C0C0C0;';
        break;
      default:
        if (critCheck && failCheck) {
          InlineColorOverride = ' background-color: #8FA4D4; color: #061539;';
        } else if (critCheck && !failCheck) {
          InlineColorOverride = ' background-color: #88CC88; color: #004400;';
        } else if (!critCheck && failCheck) {
          InlineColorOverride = ' background-color: #FFAAAA; color: #660000;';
        } else {
          InlineColorOverride = ' background-color: #FFFEA2; color: #000;';
        }
    }
    var expression = inlineroll.expression.replace(/=>|>=/, '&amp;ge;').replace(/>/, '&amp;gt;').replace(/<=|=</, '&amp;le;').replace(/</, '&amp;lt;');
    var rollOut = '<span style="display: inline-block; border-radius: 5px; padding: 0 4px; ' + InlineColorOverride + '" title="' + expression + ' = ' + values.join("");
    rollOut += '" class="a inlinerollresult showtip tipsy-n';
    rollOut += (critCheck && failCheck) ? ' importantroll' : (critCheck ? ' fullcrit' : (failCheck ? ' fullfail' : ''));
    rollOut += '">' + inlineroll.results.total + '</span>';
    return rollOut;
  }

  function processRoll(roll, critRoll, failRoll, highRoll, lowRoll, noHighlight) {
    switch (roll.type) {
      case 'C':
        return {
          value: " " + roll.text + " "
        };
      case 'L':
        if (roll.text.indexOf("HR") != -1) highRoll = parseInt(roll.text.substring(2));
        else highRoll = false;
        if (roll.text.indexOf("LR") != -1) lowRoll = parseInt(roll.text.substring(2));
        else lowRoll = false;
        if (roll.text.indexOf("NH") != -1) {
          // Blocks highlight on an individual roll...
          noHighlight = true;
        }
        // Remove inline tags to reduce clutter...
        roll.text = roll.text.replace(/HR(\d+)/g, "");
        roll.text = roll.text.replace(/LR(\d+)/g, "");
        roll.text = roll.text.replace(/NH/g, "");
        if (roll.text !== "") roll.text = " [" + roll.text + "] ";
        return {
          value: roll.text,
          highRoll: highRoll,
          lowRoll: lowRoll,
          noHighlight: noHighlight
        };
      case 'M':
        roll.expr = roll.expr.toString().replace(/\+/g, " + ");
        return {
          value: roll.expr
        };
      case 'R':
        var rollValues = [];
        roll.results.forEach(function(result) {
          if (result.tableItem !== undefined) {
            rollValues.push(result.tableItem.name);
          } else {
            // Turn off highlighting if true...
            if (noHighlight) {
              critRoll = false;
              failRoll = false;
            } else {
              if (roll.mods) {
                if (roll.mods.customCrit && roll.mods.customCrit.length > 0) {
                  switch (roll.mods.customCrit[0].comp) {
                    case '=':
                    case '==':
                      critRoll = (result.v == roll.mods.customCrit[0].point);
                      break;
                    case '>=':
                    case '=>':
                    case '>':
                      critRoll = (result.v >= roll.mods.customCrit[0].point);
                      break;
                    default:
                      critRoll =
                        (highRoll !== false && result.v >= highRoll ||
                          result.v === roll.sides);
                  }
                }
                if (!critRoll && roll.mods.customFumble && roll.mods.customFumble.length > 0) {
                  switch (roll.mods.customFumble[0].comp) {
                    case '=':
                    case '==':
                      failRoll = (result.v == roll.mods.customFumble[0].point);
                      break;
                    case '<=':
                    case '=<':
                    case '<':
                      failRoll = (result.v <= roll.mods.customFumble[0].point);
                      break;
                    default:
                      failRoll =
                        (lowRoll !== false && result.v <= lowRoll || result.v === 1);
                  }
                }
              } else {
                critRoll =
                  (highRoll !== false && result.v >= highRoll ||
                    result.v === roll.sides);
                failRoll =
                  (!critRoll &&
                    (lowRoll !== false && result.v <= lowRoll || result.v === 1));
              }
            }
            var rv = "<span class='basicdiceroll" + (critRoll ? ' critsuccess' : (failRoll ? ' critfail' : '')) + "'>" + result.v + "</span>";
            rollValues.push(rv);
          }
        });
        var separator = ' + ';
        if (roll.mods && roll.mods.keep) separator = ' , ';
        return {
          value: "(" + rollValues.join(separator) + ")",
          critRoll: critRoll,
          failRoll: failRoll,
          highRoll: highRoll,
          lowRoll: lowRoll,
          noHighlight: noHighlight
        };
      case 'G':
        var grollVal = [];
        roll.rolls.forEach(function(groll) {
          groll.forEach(function(groll2) {
            var result = processRoll(groll2, highRoll, lowRoll, noHighlight);
            grollVal.push(result.value);
            critRoll = critRoll || result.critRoll;
            failRoll = failRoll || result.failRoll;
            highRoll = highRoll || result.highRoll;
            lowRoll = lowRoll || result.lowRoll;
            noHighlight = noHighlight || result.noHighlight;
          });
        });
        return {
          value: "{" + grollVal.join(" ") + "}",
          critRoll: critRoll,
          failRoll: failRoll,
          highRoll: highRoll,
          lowRoll: lowRoll,
          noHighlight: noHighlight
        };
    }
  }

  function getBrightness(hex) {
    hex = hex.replace('#', '');
    var c_r = hexDec(hex.substr(0, 2));
    var c_g = hexDec(hex.substr(2, 2));
    var c_b = hexDec(hex.substr(4, 2));
    return ((c_r * 299) + (c_g * 587) + (c_b * 114)) / 1000;
  }

  function hexDec(hex_string) {
    hex_string = (hex_string + '').replace(/[^a-f0-9]/gi, '');
    return parseInt(hex_string, 16);
  }

  function addOrigin(name, toEvaluate) {
    return toEvaluate.replace(/@{/g, "@{" + name + "|");
  }

  function tokenCenter(tok) {
    return [tok.get('left'), tok.get('top')];
  }

  // Retourne le diamètre d'un disque inscrit dans un carré de surface
  // équivalente à celle du token
  function tokenSizeAsCircle(token) {
    var surface = token.get('width') * token.get('height');
    return Math.sqrt(surface);
  }

  // if token is bigger than thresh reduce the distance by that size
  function tokenSize(tok, thresh) {
    var size = (tok.get('width') + tok.get('height')) / 2;
    if (size > thresh) return ((size - thresh) / 2);
    return 0;
  }


  function malusDistance(perso1, tok2, distanceDeBase, portee, pageId, explications, ignoreObstacles) {
    // Extension de distance pour tir parabolique
    var tirParabolique = charAttributeAsBool(perso1, "tirParabolique");
    var distance = tirParabolique ? Math.max(0, distanceDeBase - portee) : distanceDeBase;

    if (distance === 0) return 0;
    var tok1 = perso1.token;
    var mPortee = (distance <= portee) ? 0 : (Math.ceil(5 * (distance - portee) / portee));
    if (mPortee > 0) {
      explications.push("Distance > " + ((tirParabolique) ? portee * 2 : portee) + " m => -" + mPortee + " en Attaque");
    }
    if (ignoreObstacles || charAttributeAsBool(perso1, 'joliCoup'))
      return mPortee;
    // Now determine if any token is between tok1 and tok2
    var allToks =
      findObjs({
        _type: "graphic",
        _pageid: pageId,
        _subtype: "token",
        layer: "objects"
      });
    var mObstacle = 0;
    var pt1 = tokenCenter(tok1);
    var pt2 = tokenCenter(tok2);
    var distance_pix = VecMath.length(VecMath.vec(pt1, pt2));
    var liste_obstacles = [];
    allToks.forEach(function(obj) {
      if (obj.id == tok1.id || obj.id == tok2.id) return;
      if (roundMarker && obj.id == roundMarker.id) return;
      var objCharId = obj.get('represents');
      var perso = {
        token: obj,
        charId: objCharId
      };
      if (objCharId !== '' && (getState(perso, 'mort') ||
          getState(perso, 'assome') || getState(perso, 'endormi') ||
          attributeAsBool(perso, 'intangible')))
        return;
      //On regarde si le token est une monture d'un des personnages
      var attrMonte = tokenAttribute(perso, 'estMontePar');
      var estMonture = attrMonte.find(function(a) {
        var cid = a.get('current');
        return cid == tok1.id || cid == tok2.id;
      });
      if (estMonture) return;
      var pt = tokenCenter(obj);
      var obj_dist = VecMath.length(VecMath.vec(pt1, pt));
      if (obj_dist > distance_pix) return;
      obj_dist = VecMath.length(VecMath.vec(pt2, pt));
      if (obj_dist > distance_pix) return;
      var distToTrajectory = VecMath.ptSegDist(pt, pt1, pt2);
      // On modélise le token comme un disque
      var rayonObj = tokenSizeAsCircle(obj) / 2;
      if (distToTrajectory > rayonObj) return;
      liste_obstacles.push(obj.get("name"));
      // On calcule un malus proportionnel à l'arc à traverser
      // Pour l'instant, malus = 1 si distance = PIX_PER_UNIT
      var longueurArc = 2 * Math.sqrt(rayonObj * rayonObj - distToTrajectory * distToTrajectory);
      var mToken = longueurArc / PIX_PER_UNIT;
      //malus plus important si l'obstacle est au contact de la cible
      if (distanceCombat(tok2, obj, pageId) === 0) mToken *= 5;
      else mToken *= 3;
      mObstacle += mToken;
    });
    // On ajuste aussi en fonction de la taille de la cible
    mObstacle = mObstacle / (tokenSizeAsCircle(tok2) / PIX_PER_UNIT);
    if (mObstacle > 5) mObstacle = 5;
    else mObstacle = Math.round(mObstacle);
    var res = mPortee + mObstacle;
    if (mObstacle > 0) {
      log("Obstacle" + ((liste_obstacles.length > 1) ? "s" : "") + " trouvé : " + liste_obstacles.join(', '));
      explications.push('Obstacle' + ((liste_obstacles.length > 1) ? 's' : '') + ' sur le trajet => -' + mObstacle + ' en Attaque<br /><span style="font-size: 0.8em; color: #666;">' + liste_obstacles.join(', ') + '</span>');
    }
    return res;
  }

  // Returns all attributes in attrs, with name name or starting with name_
  function allAttributesNamed(attrs, name) {
    var reg = new RegExp("^" + name + "($|_|\\()");
    return attrs.filter(function(obj) {
      var attrName = obj.get('name');
      return reg.test(attrName);
    });
  }

  //Met tous les attributs avec le nom au max
  function resetAttr(attrs, attrName, evt, msg) {
    allAttributesNamed(attrs, attrName).forEach(function(att) {
      var vm = parseInt(att.get("max"));
      if (!isNaN(vm)) {
        var vc = parseInt(att.get("current"));
        if (vc != vm) {
          evt.attributes.push({
            attribute: att,
            current: vc
          });
          att.set("current", vm);
          if (msg) {
            var charId = att.get('characterid');
            var character = getObj('character', charId);
            var name = character.get('name');
            sendChar(charId, '/w "' + name + '" ' + msg);
          }
        }
      }
    });
  }

  // Fait foo sur tous les tokens représentant charId, ayant l'effet donné, et correspondant au nom d'attribut. Pour le cas où le token doit être lié au personnage, on ne prend qu'un seul token, sauf si les options indiquent autrement (soit option.tousLesTokens, soit une fonction options.filterAffected)
  // Ne fonctionne correctement que pour les attributs sans _
  function iterTokensOfAttribute(charId, pageId, attrName, attrNameComplet, foo, options) {
    options = options || {};
    var total = 1; //Nombre de tokens affectés, pour gérer l'asynchronie si besoin
    if (attrNameComplet == attrName) { //token lié au character
      var tokens;
      if (pageId) {
        tokens =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            _pageid: pageId,
            represents: charId
          });
      }
      if (tokens === undefined ||
        (tokens.length === 0 && !options.onlyOnPage)) {
        tokens =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            represents: charId
          });
        tokens = tokens.filter(function(tok) {
          if (tok.get('bar1_link') === '') return false;
          var pid = tok.get('pageid');
          var page = getObj('page', pid);
          if (page) {
            return !(page.get('archived'));
          }
          return false;
        });
      }
      if (tokens.length === 0) {
        if (options.possiblementAbsent) return;
        log("Pas de token pour un personnage");
        log(charId);
        log(attrNameComplet);
        return;
      }
      if (options.tousLesTokens) {
        tokens.forEach(function(tok) {
          foo(tok, tokens.length);
        });
      } else if (options.filterAffected) {
        total = tokens.length;
        tokens.forEach(function(tok) {
          if (options.filterAffected(tok)) foo(tok, total);
        });
      } else foo(tokens[0], 1);
    } else { //token non lié au character
      var tokenName = attrNameComplet.substring(attrNameComplet.indexOf('_') + 1);
      var tNames;
      if (pageId) {
        tNames =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            _pageid: pageId,
            represents: charId,
            name: tokenName,
            bar1_link: ''
          });
      }
      if (tNames === undefined || (tNames.length === 0 && !options.onlyOnPage)) {
        tNames =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            represents: charId,
            name: tokenName,
            bar1_link: ''
          });
        tNames = tNames.filter(function(tok) {
          var pid = tok.get('pageid');
          var page = getObj('page', pid);
          if (page) {
            return !(page.get('archived'));
          }
          return false;
        });
      }
      total = tNames.length;
      if (total > 1) {
        var character = getObj('character', charId);
        var charName = "d'id " + charId;
        if (character) charName = character.get('name');
        error("Attention, il y a plusieurs tokens nommés " + tokenName + ", instances du personnage " + charName, total);
      }
      tNames.forEach(function(tok) {
        foo(tok, total);
      });
    }
  }

  var aura_token_on_turn = false;

  function setTokenInitAura(perso) {
    var token = perso.token;
    if (stateCOF.options.affichage.val.init_dynamique.val) {
      threadSync++;
      activateRoundMarker(threadSync, token);
      return;
    }
    if (aura_token_on_turn) {
      // ennemi => rouge
      var aura2_color = '#CC0000';
      if (estAllieJoueur(perso)) {
        // equipe => vert
        aura2_color = '#59E594';
      }
      token.set('aura2_radius', '0.1');
      token.set('aura2_color', aura2_color);
      token.set('showplayers_aura2', true);
    } else {
      var status = '';
      // Cas des tokens personnalisés
      if (statusForInitEnemy && statusForInitAlly) {
        // ennemi => rouge
        status = statusForInitEnemy;
        if (estAllieJoueur(perso)) {
          // equipe => vert
          status = statusForInitAlly;
        }
      } else status = 'status_flying-flag';
      token.set(status, true);
    }
  }

  //Ne rajoute pas evt à l'historique
  function setActiveToken(tokenId, evt) {
    var pageId = stateCOF.combat_pageid;
    if (stateCOF.activeTokenId) {
      if (tokenId == stateCOF.activeTokenId) return;
      evt.activeTokenId = stateCOF.activeTokenId;
      var prevToken = getObj('graphic', stateCOF.activeTokenId);
      if (prevToken) {
        affectToken(prevToken, 'statusmarkers', prevToken.get('statusmarkers'), evt);
        affectToken(prevToken, 'aura2_radius', prevToken.get('aura2_radius'), evt);
        affectToken(prevToken, 'aura2_color', prevToken.get('aura2_color'), evt);
        affectToken(prevToken, 'showplayers_aura2', prevToken.get('showplayers_aura2'), evt);
        removeTokenFlagAura(prevToken);
      } else {
        if (pageId) {
          prevToken = findObjs({
            _type: 'graphic',
            _subtype: 'token',
            _pageid: pageId,
            name: stateCOF.activeTokenName
          });
        } else {
          prevToken = findObjs({
            _type: 'graphic',
            _subtype: 'token',
            name: stateCOF.activeTokenName
          });
        }
        prevToken.forEach(function(o) {
          affectToken(o, 'statusmarkers', o.get('statusmarkers'), evt);
          affectToken(o, 'aura2_radius', o.get('aura2_radius'), evt);
          affectToken(o, 'aura2_color', o.get('aura2_color'), evt);
          affectToken(o, 'showplayers_aura2', o.get('showplayers_aura2'), evt);
          removeTokenFlagAura(o);
        });
      }
    }
    if (tokenId) {
      var perso = persoOfId(tokenId, tokenId);
      if (perso) {
        //On remet à 0 la liste des cibles attaquées par le personnage
        removeDernieresCiblesAttaquees(perso, evt);
        var token = perso.token;
        var charId = perso.charId;
        // personnage lié au Token
        affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
        affectToken(token, 'aura2_radius', token.get('aura2_radius'), evt);
        affectToken(token, 'aura2_color', token.get('aura2_color'), evt);
        affectToken(token, 'showplayers_aura2', token.get('showplayers_aura2'), evt);
        setTokenInitAura(perso);
        stateCOF.activeTokenId = tokenId;
        stateCOF.activeTokenName = token.get('name');
        turnAction(perso);
        // Gestion de la confusion
        if (attributeAsBool(perso, "confusion")) {
          //Une chance sur deux de ne pas agir
          if (randomInteger(2) < 2) {
            sendChar(charId, "est en pleine confusion. Il ne fait rien ce tour");
            removeTokenFlagAura(token);
          } else {
            //Trouver la créature la plus proche
            var closestToken;
            pageId = token.get('pageid');
            var toksOnPage = findObjs({
              _type: 'graphic',
              _subtype: 'token',
              _pageid: pageId,
              layer: 'objects'
            });
            toksOnPage.forEach(function(tok) {
              if (tok.id == tokenId) return;
              var perso = {
                token: tok
              };
              perso.charId = tok.get('represents');
              if (perso.charId === '') return;
              if (getState(perso, 'mort')) return;
              var dist = distanceCombat(token, tok, pageId);
              if (closestToken) {
                if (dist > closestToken.distance) return;
                if (dist < closestToken.distance) {
                  closestToken = {
                    distance: dist,
                    names: [tok.get('name')]
                  };
                  return;
                }
                closestToken.names.push(tok.get('name'));
                return;
              }
              closestToken = {
                distance: dist,
                names: [tok.get('name')]
              };
            });
            if (closestToken) {
              var r = randomInteger(closestToken.names.length) - 1;
              sendChar(charId,
                "est en pleine confusion. " + onGenre(perso, 'Il', 'Elle') +
                " attaque " + closestToken.names[r] + ".");
            } else {
              sendChar(charId, "est seul et en plein confusion");
            }
          }
        }
        //On enlève aussi les états qui ne durent qu'un tour
        var defenseTotale = tokenAttribute(perso, 'defenseTotale');
        if (defenseTotale.length > 0) {
          defenseTotale = defenseTotale[0];
          var tourDefTotale = defenseTotale.get('max');
          if (tourDefTotale < stateCOF.tour) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(defenseTotale);
            defenseTotale.remove();
          }
        }
      } else {
        error("Impossible de trouver le token dont c'est le tour", tokenId);
        stateCOF.activeTokenId = undefined;
      }
    } else stateCOF.activeTokenId = undefined;
  }

  function sortirDuCombat() {
    stateCOF.usureOff = undefined;
    if (!stateCOF.combat) {
      log("Pas en combat");
      sendChat("GM", "/w GM Le combat est déjà terminé");
      return;
    }
    sendChat("GM", "Le combat est terminé");
    var evt = {
      type: 'fin_combat',
      initiativepage: Campaign().get('initiativepage'),
      turnorder: Campaign().get('turnorder'),
      attributes: [],
      combat: true,
      tour: stateCOF.tour,
      init: stateCOF.init,
      deletedAttributes: [],
      chargeFantastique: stateCOF.chargeFantastique
    };
    stateCOF.combat = false;
    stateCOF.chargeFantastique = undefined;
    stateCOF.armeesDesMorts = undefined;
    setActiveToken(undefined, evt);
    Campaign().set('initiativepage', false);
    var attrs = findObjs({
      _type: 'attribute'
    });
    // Fin des effets qui durent pour le combat
    attrs = removeAllAttributes('soinsDeGroupe', evt, attrs);
    attrs = removeAllAttributes('secondSouffle', evt, attrs);
    attrs = removeAllAttributes('sergentUtilise', evt, attrs);
    attrs = removeAllAttributes('enflamme', evt, attrs);
    attrs = removeAllAttributes('protegerUnAllie', evt, attrs);
    attrs = removeAllAttributes('protegePar', evt, attrs);
    attrs = removeAllAttributes('intercepter', evt, attrs);
    attrs = removeAllAttributes('interposer', evt, attrs);
    attrs = removeAllAttributes('defenseTotale', evt, attrs);
    attrs = removeAllAttributes('dureeStrangulation', evt, attrs);
    attrs = removeAllAttributes('defautDansLaCuirasse', evt, attrs);
    attrs = removeAllAttributes('postureDeCombat', evt, attrs);
    attrs = removeAllAttributes('dedouble', evt, attrs);
    attrs = removeAllAttributes('limiteParCombat', evt, attrs);
    attrs = removeAllAttributes('armeSecreteBardeUtilisee', evt, attrs);
    attrs = removeAllAttributes('attaqueMalgreMenace', evt, attrs);
    attrs = removeAllAttributes('limiteApplicationManoeuvre', evt, attrs);
    attrs = removeAllAttributes('attaqueParMeute', evt, attrs);
    attrs = removeAllAttributes('dernieresCiblesAttaquees', evt, attrs);
    attrs = removeAllAttributes('testsRatesDuTour', evt, attrs);
    attrs = removeAllAttributes('effetsTemporairesLies', evt, attrs);
    attrs = removeAllAttributes('aAgiAZeroPV', evt, attrs);
    attrs = removeAllAttributes('injonctionMortelle', evt, attrs);
    attrs = removeAllAttributes('cercleDeProtectionActif', evt, attrs);
    // Autres attributs
    // Remettre le pacifisme au max
    resetAttr(attrs, 'pacifisme', evt, "retrouve son pacifisme");
    // Remettre le traquenard à 1
    resetAttr(attrs, 'traquenard', evt);
    // Tout le monde recharge ses armes après un combat, non ?
    resetAttr(attrs, 'charge', evt, "recharge ses armes");
    // Et on récupère les munitions récupérables
    resetAttr(attrs, 'munition', evt, "récupère ses munitions");
    // Remettre défier la mort à 10
    resetAttr(attrs, 'defierLaMort', evt);
    resetAttr(attrs, 'increvable', evt);
    // Remettre l'esquive fatale à 1
    resetAttr(attrs, 'esquiveFatale', evt);
    resetAttr(attrs, 'interventionDivine', evt);
    resetAttr(attrs, 'attaqueEnTraitre', evt);
    resetAttr(attrs, 'esquiveAcrobatique', evt);
    resetAttr(attrs, 'resistanceALaMagieBarbare', evt);
    resetAttr(attrs, 'paradeMagistrale', evt);
    resetAttr(attrs, 'petitVeinard', evt);
    resetAttr(attrs, 'chairACanon', evt);
    resetAttr(attrs, 'paradeDeProjectiles', evt);
    resetAttr(attrs, 'prouesse', evt);
    // Réinitialiser le kiai
    resetAttr(attrs, 'kiai', evt);
    // Réinitialiser riposteGuerrier
    resetAttr(attrs, 'riposteGuerrier', evt);
    // On diminue l'ébriété des personnages sous vapeurs éthyliques
    allAttributesNamed(attrs, 'vapeursEthyliques').forEach(function(attr) {
      var veCharId = attr.get('characterid');
      if (veCharId === undefined || veCharId === '') {
        error("Attribut sans personnage associé", attr);
        return;
      }
      iterTokensOfAttribute(veCharId, stateCOF.combat_pageid,
        'vapeursEthyliques', attr.get('name'),
        function(tok) {
          var perso = {
            charId: veCharId,
            token: tok
          };
          removeTokenAttr(perso, 'niveauEbriete', evt, {
            msg: "désaoûle"
          });
        });
    });
    attrs = removeAllAttributes('vapeursEthyliques', evt, attrs);
    // Pour frappe du vide, on rengaine l'arme, cela remet aussi l'attribut
    allAttributesNamed(attrs, 'frappeDuVide').forEach(function(attr) {
      var fdvCharId = attr.get('characterid');
      if (fdvCharId === undefined || fdvCharId === '') {
        error("Attribut sans personnage associé", attr);
        return;
      }
      iterTokensOfAttribute(fdvCharId, stateCOF.combat_pageid,
        'frappeDuVide', attr.get('name'),
        function(tok) {
          var perso = {
            charId: fdvCharId,
            token: tok
          };
          degainerArme(perso, '', evt);
        });
    });
    // On remet en main l'arme par défaut si elle est précisée
    allAttributesNamed(attrs, 'armeParDefaut').forEach(function(attr) {
      var apdCharId = attr.get('characterid');
      if (apdCharId === undefined || apdCharId === '') {
        error("Attribut sans personnage associé", attr);
        return;
      }
      iterTokensOfAttribute(apdCharId, stateCOF.combat_pageid,
        'armeParDefaut', attr.get('name'),
        function(tok) {
          var perso = {
            charId: apdCharId,
            token: tok
          };
          degainerArme(perso, attr.get('current'), evt);
        });
    });
    //Effet de ignorerLaDouleur
    var ilds = allAttributesNamed(attrs, 'douleurIgnoree');
    ilds = ilds.concat(allAttributesNamed(attrs, 'memePasMalIgnore'));
    ilds.forEach(function(ild) {
      var douleur = parseInt(ild.get('current'));
      if (isNaN(douleur)) {
        error("La douleur ignorée n'est pas un nombre", douleur);
        return;
      }
      var charId = ild.get('characterid');
      if (charId === undefined || charId === '') {
        error("Attribut sans personnage", ild);
        return;
      }
      var ildName = ild.get('name');
      if (ildName == 'douleurIgnoree' || ildName == 'memePasMalIgnore') {
        var pvAttr = findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: 'PV'
        }, {
          caseInsensitive: true
        });
        var versionFiche = parseFloat(getAttrByName(charId, 'version'));
        if (isNaN(versionFiche)) versionFiche = 0;
        var estPNJ = getAttrByName(charId, 'type_personnage') == 'PNJ';
        if (estPNJ && versionFiche < 3.7) {
          pvAttr = findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: 'pnj_pv'
          }, {
            caseInsensitive: true
          });
        }
        if (pvAttr.length === 0) {
          error("Personnage sans PV ", charId);
          return;
        }
        pvAttr = pvAttr[0];
        var pv = parseInt(pvAttr.get('current'));
        if (isNaN(pv)) {
          error("PV mal formés ", pvAttr);
          return;
        }
        evt.attributes.push({
          attribute: pvAttr,
          current: pv
        });
        var newPv = pv - douleur;
        if (newPv < 0) newPv = 0;
        pvAttr.set('current', newPv);
        if (pv > 0 && newPv === 0) {
          sendChar(charId, "s'écroule. Il semble sans vie. La douleur qu'il avait ignorée l'a finalement rattrapé...");
        } else {
          var nameAttrDMTEMP = 'DMTEMP';
          if (estPNJ && versionFiche < 3.7) nameAttrDMTEMP = 'pnj_dmtemp';
          var tempDmg = ficheAttributeAsInt(charId, nameAttrDMTEMP, 0);
          if (pv > tempDmg && newPv <= tempDmg) {
            sendChar(charId, "s'écroule, assomé. La douleur qu'il avait ignorée l'a finalement rattrapé...");
          } else {
            sendChar(charId, "subit le contrecoup de la douleur qu'il avait ignorée");
          }
        }
      } else { // ignorer la douleur d'un token
        var tokName = ildName.substring(ildName.indexOf('_') + 1);
        var tokensIld = findObjs({
          _type: 'graphic',
          _subtype: 'token',
          represents: charId,
          name: tokName
        });
        if (tokensIld.length === 0) {
          error("Pas de token nommé " + tokName + " qui aurait ignoré la douleur", ild);
          return;
        }
        if (tokensIld.length > 1) {
          sendChar(charId, "a plusieurs tokens nommés " + tokName + ". Un seul d'entre eux subira l'effet d'ignorer la douleur");
        }
        var tokPv = parseInt(tokensIld[0].get('bar1_value'));
        var tokNewPv = tokPv - douleur;
        if (tokNewPv < 0) tokNewPv = 0;
        var perso = {
          charId: charId,
          token: tokensIld[0]
        };
        updateCurrentBar(perso, 1, tokNewPv, evt);
        //TODO: faire mourrir, assomer
      }
    }); // end forEach on all attributes ignorerLaDouleur
    ilds.forEach(function(ild) {
      evt.deletedAttributes.push(ild);
      ild.remove();
    });
    if (ilds.length > 0) {
      attrs = attrs.filter(function(attr) {
        var ind = ilds.findIndex(function(nattr) {
          return nattr.id == attr.id;
        });
        return (ind == -1);
      });
    }
    // fin des effets temporaires (durée en tours, ou durée = combat)
    attrs.forEach(function(obj) {
      var attrName = obj.get('name');
      var charId = obj.get('characterid');
      if (estEffetTemp(attrName)) {
        finDEffet(obj, effetTempOfAttribute(obj), attrName, charId, evt, {
          pageId: stateCOF.combat_pageid
        });
      } else if (estAttributEffetTemp(attrName)) {
        evt.deletedAttributes.push(obj);
        obj.remove();
      } else if (estEffetCombat(attrName)) {
        var mc = messageEffetCombat[effetCombatOfAttribute(obj)].fin;
        if (mc && mc !== '') sendChar(charId, mc);
        evt.deletedAttributes.push(obj);
        obj.remove();
      } else if (estAttributEffetCombat(attrName)) {
        evt.deletedAttributes.push(obj);
        obj.remove();
      }
    });
    addEvent(evt);
  }

  function pointsDeRecuperation(perso) {
    // retourne les nombre de PR restant
    var attrPR = tokenAttribute(perso, 'pointsDeRecuperation');
    var prc = 5;
    var prm = 5;
    if (attrPR.length > 0) {
      prc = parseInt(attrPR[0].get('current'));
      prm = parseInt(attrPR[0].get('max'));
      return {
        current: prc,
        max: prm
      };
    }
    attrPR = charAttribute(perso.charId, 'pr', {
      caseInsensitive: true
    });
    if (attrPR.length === 0) {
      return {
        current: 5,
        max: 5
      };
    }
    prm = attrPR[0].get('max');
    if (prm === '') prm = 5;
    else {
      prm = parseInt(prm);
      if (isNaN(prm) || prm < 0) prm = 5;
    }
    prc = attrPR[0].get('current');
    if (prc === '') prc = 5;
    else {
      prc = parseInt(prc);
      if (isNaN(prc)) prc = prm;
      else if (prc < 0) prc = 0;
      else if (prc > prm) prc = prm;
    }
    return {
      current: prc,
      max: prm
    };
  }

  function enleverPointDeRecuperation(perso, evt) {
    evt.attributes = evt.attributes || [];
    var attrPR = charAttribute(perso.charId, 'pr', {
      caseInsensitive: true
    });
    if (attrPR.length === 0) {
      attrPR = createObj("attribute", {
        characterid: perso.charId,
        name: 'pr',
        current: 4,
        max: 5
      });
      evt.attributes.push({
        attribute: attrPR,
        current: null
      });
      return;
    }
    var prc = attrPR[0].get('current');
    if (prc === '') prc = 5;
    else prc = parseInt(prc);
    if (isNaN(prc) || prc < 1) {
      sendChat("COF", "Plus de point de récupération à enlever");
      return;
    }
    evt.attributes.push({
      attribute: attrPR[0],
      current: prc
    });
    attrPR[0].set('current', prc - 1);
  }

  function rajouterPointDeRecuperation(perso, evt) {
    evt.attributes = evt.attributes || [];
    var attrPR = charAttribute(perso.charId, 'pr', {
      caseInsensitive: true
    });
    if (attrPR.length === 0) {
      attrPR = createObj("attribute", {
        characterid: perso.charId,
        name: 'pr',
        current: 5,
        max: 5
      });
      evt.attributes.push({
        attribute: attrPR,
        current: null
      });
      return;
    }
    var prmax = attrPR[0].get('max');
    if (prmax === '') prmax = 5;
    else {
      prmax = parseInt(prmax);
      if (isNaN(prmax) || prmax < 0) prmax = 5;
    }
    var prc = attrPR[0].get('current');
    if (prc === '') prc = 5;
    else prc = parseInt(prc);
    if (isNaN(prc) || prc >= prmax) {
      return;
    }
    evt.attributes.push({
      attribute: attrPR[0],
      current: prc
    });
    attrPR[0].set('current', prc + 1);
    return true;
  }

  //Asynchrone
  // ne rajoute pas evt à l'historique
  function soinsEcuyers(ecuyers, manquePV, playerId, evt) {
    ecuyers.forEach(function(ec) {
      var ecuyer = ec.perso;
      var ecuyerDe = ec.ecuyerDe;
      var charChevalier = findObjs({
        _type: 'character',
        name: ecuyerDe
      });
      if (charChevalier.length === 0) {
        error("Pas de chevalier " + ecuyerDe + " pour l'écuyer " + ecuyer.token.get('name'), ec);
        return;
      }
      if (charChevalier.length > 1) {
        error("Plusieurs personnages nommés " + ecuyerDe + ". Attention aux ambiguités.");
      }
      charChevalier = charChevalier[0].id;
      var maxASoigner = modCarac(charChevalier, 'charisme') + 1;
      var allies = alliesParPerso[ecuyer.charId] || new Set();
      var alliesASoigner = [];
      var nbCibles = 0;
      var chevalier;
      var monture;
      manquePV.forEach(function(cible) {
        if (cible.charId == charChevalier) {
          chevalier = cible;
          nbCibles++;
          return;
        }
        if (allies.has(cible.charId)) {
          var montureDe = findObjs({
            _type: 'attribute',
            _characterid: cible.charId,
            name: 'montureDe'
          });
          if (montureDe.length > 0 && montureDe[0].get('current') == ecuyerDe) {
            monture = cible;
            nbCibles++;
            return;
          }
          alliesASoigner.push(cible);
        }
      }); //fin de détermination des cibles
      if (chevalier === undefined && monture === undefined &&
        (maxASoigner < 1 || alliesASoigner.length === 0)) { //Personne à soigner
        return;
      }
      //TODO: utiliser l'id d'un player qui contrôle le chevalier
      var display = startFramedDisplay(playerId, "Services d'écuyer", ecuyer);
      var finSoin = function() {
        nbCibles--;
        if (nbCibles === 0) {
          if (display) sendChat("", endFramedDisplay(display));
        }
      };
      var soigneUneCible = function(c) {
        sendChat('', "[[2d6]]", function(res) {
          var soins = res[0].inlinerolls[0].results.total;
          var soinTxt = buildinline(res[0].inlinerolls[0], 'normal', true);
          var printTrue = function(s) {
            var msgSoin = ecuyer.token.get('name') + ' ';
            if (c.id == ecuyer.token.id) {
              msgSoin = 'se soigne de ';
            } else {
              msgSoin = c.token.get('name') + " récupère ";
            }
            if (s < soins)
              msgSoin += s + " PV. (Le résultat du jet était " + soinTxt + ")";
            else msgSoin += soinTxt + " PV.";
            addLineToFramedDisplay(display, msgSoin);
          };
          soigneToken(c, soins, evt, printTrue);
          finSoin();
        }); //fin du sendChar
      }; // fin de définition de soigneCible
      var peutToutSoigner = (alliesASoigner.length <= maxASoigner);
      if (peutToutSoigner) nbCibles += alliesASoigner.length;
      else if (maxASoigner > 0) nbCibles++; //pour ne pas finir avant d'imprimer les boutons
      if (chevalier) soigneUneCible(chevalier);
      if (monture) soigneUneCible(monture);
      if (peutToutSoigner) {
        alliesASoigner.forEach(soigneUneCible);
      } else if (maxASoigner > 0) {
        addLineToFramedDisplay(display, "Peut prendre soin de (max " + maxASoigner + ") :");
        var attr = setTokenAttr(ecuyer, 'SoinsdEcuyer', maxASoigner, evt);
        var action = "!cof-soin " + ecuyer.token.id + " ";
        alliesASoigner.forEach(function(c) {
          var nom = c.token.get('name');
          addLineToFramedDisplay(display, bouton(action + c.token.id + " 2d6", nom, ecuyer, {
            ressource: attr
          }));
        });
        finSoin();
      }
    }); //fin iteration sur les écuyers
  }

  function parseOptions(msg) {
    var pageId, playerId;
    if (msg.selected && msg.selected.length > 0) {
      var firstSelected = getObj('graphic', msg.selected[0]._id);
      if (firstSelected === undefined) {
        error("Un token sélectionné n'est pas trouvé en interne", msg.selected);
        return;
      }
      pageId = firstSelected.get('pageid');
    } else {
      playerId = getPlayerIdFromMsg(msg);
      pageId = getPageId(playerId);
    }
    var opts = msg.content.split(' --');
    var cmd = opts.shift().split(' ');
    cmd = cmd.filter(function(c) {
      return c !== '';
    });
    var options = {
      pageId: pageId,
      playerId: playerId,
      cmd: cmd
    };
    opts.forEach(function(arg) {
      cmd = arg.trim().split(' ');
      switch (cmd[0]) {
        case 'attaqueMentale':
        case 'seulementVivant':
        case 'repos':
        case 'secret':
        case 'magique':
          options[cmd[0]] = true;
          break;
        case "lanceur":
          if (cmd.length < 2) {
            error("Il faut préciser l'id ou le nom du lanceur", arg);
            return;
          }
          options.lanceur = persoOfId(cmd[1], cmd[1], pageId);
          if (options.lanceur === undefined) {
            error("Argument de --lanceur non valide", cmd);
          }
          return;
        case 'puissant':
          if (cmd.length < 2) {
            options.puissant = "on";
            return;
          }
          switch (cmd[1]) {
            case "oui":
              options.puissant = "on";
              return;
            case "non":
              options.puissant = "off";
              return;
            case "duree":
              options.puissantDuree = true;
              return;
            default:
              error("Option puissant non reconnue", cmd);
          }
          return;
        case "mana":
          if (cmd.length < 2) {
            error("Pas assez d'argument pour --mana", cmd);
            return;
          }
          var cout;
          if (cmd.length > 2 && cmd[1] !== '' && cmd[2] !== '') {
            options.lanceur = persoOfId(cmd[1], cmd[1], pageId);
            if (options.lanceur === undefined) {
              error("Premier argument de --mana non valide", cmd);
              return;
            }
            cout = parseInt(cmd[2]);
          } else {
            cout = parseInt(cmd[1]);
          }
          if (isNaN(cout) || cout < 0) {
            error("Cout en mana incorrect", cmd);
            return;
          }
          options.mana = cout;
          return;
        case "tempeteDeMana":
          parseTempeteDeMana(cmd, options);
          return;
        case "rang":
          if (cmd.length < 2) {
            error("Usage : --rang r", cmd);
            return;
          }
          var rang = parseInt(cmd[1]);
          if (isNaN(rang) || rang < 1) {
            error("Le rang doit être un nombre positif");
            return;
          }
          options.rang = rang;
          break;
        case 'limiteParJour':
          if (cmd.length < 2) {
            error("Il manque la limite journalière", cmd);
            return;
          }
          var limiteParJour = parseInt(cmd[1]);
          if (isNaN(limiteParJour) || limiteParJour < 1) {
            error("La limite journalière doit être un nombre positif", cmd);
            return;
          }
          options.limiteParJour = limiteParJour;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            options.limiteParJourRessource = cmd.join('_');
          }
          return;
        case 'limiteCibleParJour':
          if (cmd.length < 2) {
            error("Il manque la limite journalière", cmd);
            return;
          }
          var limiteCibleParJour = parseInt(cmd[1]);
          if (isNaN(limiteCibleParJour) || limiteCibleParJour < 1) {
            error("La limite journalière doit être un nombre positif", cmd);
            return;
          }
          options.limiteCibleParJour = limiteCibleParJour;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            options.limiteCibleParJourRessource = cmd.join('_');
          }
          return;
        case 'limiteParCombat':
          if (cmd.length < 2) {
            options.limiteParCombat = 1;
            return;
          }
          var limiteParCombat = parseInt(cmd[1]);
          if (isNaN(limiteParCombat) || limiteParCombat < 1) {
            error("La limite par combat doit être un nombre positif", cmd);
            return;
          }
          options.limiteParCombat = limiteParCombat;
          if (cmd.length > 2) {
            cmd.splice(0, 2);
            options.limiteParCombatRessource = cmd.join('_');
          }
          return;
        case "portee":
          if (cmd.length < 2) {
            error("Pas assez d'argument pour --portee n", cmd);
            return;
          }
          var portee;
          if (cmd.length > 2) {
            var tokPortee = persoOfId(cmd[1], cmd[1], pageId);
            if (tokPortee === undefined) {
              error("Premier argument de --portee non valide", cmd);
              return;
            }
            portee = parseInt(cmd[2]);
          } else {
            portee = parseInt(cmd[1]);
          }
          if (isNaN(portee) || portee < 0) {
            error("Portée incorrecte", cmd);
            return;
          }
          options.portee = portee;
          return;
        case 'saveParTour':
          options.saveParTour = parseSave(cmd);
          return;
        case 'save':
          options.save = parseSave(cmd);
          return;
        case 'dose':
          if (cmd.length < 2) {
            error("Il faut le nom de la dose", cmd);
            return;
          }
          options.dose = cmd[1];
          return;
        case 'decrAttribute':
          if (cmd.length < 2) {
            error("Erreur interne d'une commande générée par bouton", opts);
            return;
          }
          var attr = getObj('attribute', cmd[1]);
          if (attr === undefined && options.lanceur) {
            attr = tokenAttribute(options.lanceur, cmd[1]);
            if (attr.length === 0) {
              log("Attribut à changer perdu");
              log(cmd);
              return;
            }
            attr = attr[0];
          }
          if (attr === undefined) {
            log("Attribut à changer perdu");
            log(cmd);
            return;
          }
          options.decrAttribute = attr.id;
          return;
        case 'valeur':
          if (cmd.length < 2) {
            error("Il manque la valeur en argument de l'option --valeur", opts);
            return;
          }
          options.valeur = cmd[1];
          if (cmd.length > 2) options.valeurMax = cmd[2];
          return;
        case 'accumuleDuree':
          if (cmd.length < 2) {
            error("Il manque la valeur en argument de l'option --accumuleDuree", opts);
            return;
          }
          var accumuleDuree = parseInt(cmd[1]);
          if (isNaN(accumuleDuree) || accumuleDuree < 1) {
            error("On ne peut accumuler qu'on nombre strictement positif d'effets", opts);
            return;
          }
          options.accumuleDuree = accumuleDuree;
          return;
        case "nonVivant":
          options.nonVivant = true;
          if (cmd.length > 1) {
            var nonVivantPerso = persoOfId(cmd[1], cmd[1], pageId);
            if (nonVivantPerso) {
              options.nonVivant = charAttributeAsBool(nonVivantPerso, 'nonVivant');
            }
          }
          return;
        case "fx":
          getFx(cmd, 'fx', options);
          return;
        case "targetFx":
          getFx(cmd, 'targetFx', options);
          break;
        case "classeEffet":
          if (cmd.length < 2) {
            sendChat("COF", "Il manque un argument à l'option --classeEffet");
            return;
          }
          options.classeEffet = cmd[1];
          return;
        case 'message':
          if (cmd.length < 2) {
            error("Il manque le message après --message", cmd);
            return;
          }
          options.messages = options.messages || [];
          options.messages.push(cmd.slice(1).join(' '));
          return;
        case 'image':
          if (cmd.length < 2) {
            error("Il manque le nom de l'imageaprès --image", cmd);
            return;
          }
          options.image = cmd[1].replace('&#58;', ':');
          return;
        case 'son':
          if (cmd.length < 2) {
            error("Il manque le nom du son après --son", cmd);
            return;
          }
          options.son = cmd.slice(1).join(' ');
          return;
        case 'feu':
        case 'froid':
        case 'acide':
        case 'electrique':
        case 'sonique':
        case 'poison':
        case 'maladie':
          options.type = cmd[0];
          return;
        case 'bonus':
          if (cmd.length >= 2) {
            var bonus = parseInt(cmd[1]);
            if (!isNaN(bonus)) {
              options.bonus = bonus;
            }
          }
          return;
        default:
          return;
      }
    });
    return options;
  }

  //Si il y a des effets à durée indéterminées, les rappeler au MJ, avec un bouton pour facilement y mettre fin si nécessaire
  function proposerFinEffetsIndetermines() {
    var attrs = findObjs({
      _type: 'attribute'
    });
    attrs = attrs.filter(function(a) {
      return estEffetIndetermine(a.get('name'));
    });
    if (attrs.length === 0) return;
    var display = startFramedDisplay(undefined, "<b>Effets à durée indéterminée actifs</b>", undefined, {
      chuchote: 'gm'
    });
    var attrsParPerso = {};
    attrs.forEach(function(a) {
      var charId = a.get('characterid');
      var attrName = a.get('name');
      var ef = {
        nom: attrName
      };
      var mes = messageEffetIndetermine[attrName];
      if (mes) {
        ef.actif = mes.actif;
        if (attrsParPerso[charId] === undefined) {
          var resLinked = {
            effets: [ef]
          };
          var linkedTokens = findObjs({
            _type: 'graphic',
            represents: charId
          });
          linkedTokens = linkedTokens.filter(function(t) {
            return t.get('bar1_link') !== '';
          });
          if (linkedTokens.length === 0) {
            var character = getObj('character', charId);
            if (character === undefined) {
              error("Attribut sans personnage", a);
              a.remove();
              return;
            }
            resLinked.nomPerso = character.get('name');
          } else {
            resLinked.nomPerso = linkedTokens[0].get('name');
            resLinked.tokenId = linkedTokens[0].id;
          }
          attrsParPerso[charId] = resLinked;
          return;
        }
        attrsParPerso[charId].effets.push(ef);
        return;
      } // on a un attribut de token non lié
      var pn = attrName.indexOf('_');
      if (pn < 1) return;
      ef.nom = attrName.substring(0, pn - 1);
      mes = messageEffetIndetermine[ef.nom];
      if (mes === undefined) return;
      ef.actif = mes.actif;
      var nomPerso = attrName.substring(pn + 1);
      if (attrsParPerso[nomPerso] === undefined) {
        var tokens = findObjs({
          _type: 'graphic',
          represents: charId
        });
        tokens = tokens.filter(function(t) {
          return t.get('bar1_link') === '' && t.get('name') == nomPerso;
        });
        if (tokens.length === 0) {
          error("Attribut de mook sans personnage", a);
          a.remove();
          return;
        }
        attrsParPerso[nomPerso] = {
          nomPerso: nomPerso,
          tokenId: tokens[0].id,
          effets: [ef]
        };
        return;
      }
      attrsParPerso[nomPerso].effets.push(ef);
    });
    _.each(attrsParPerso, function(a) {
      var line = '<b>' + a.nomPerso + "</b> : ";
      a.effets.forEach(function(e) {
        line += e.actif + ' ';
        if (a.tokenId)
          line += boutonSimple('!cof-effet ' + e.nom + ' false --target ' + a.tokenId, 'X');
        else line += "supprimer l'attribut " + e.nom;
      });
      addLineToFramedDisplay(display, line);
    });
    sendChat("", endFramedDisplay(display));
  }

  // Remise à zéro de toutes les limites journalières
  // N'ajoute pas evt à l'historique
  function jour(evt, options) {
    var attrs;
    attrs = removeAllAttributes('pressionMortelle', evt);
    attrs = removeAllAttributes('soinsLegers', evt, attrs);
    attrs = removeAllAttributes('soinsModeres', evt, attrs);
    attrs = removeAllAttributes('fortifie', evt, attrs);
    attrs = removeAllAttributes('limiteParJour', evt, attrs);
    attrs = removeAllAttributes('tueurFantasmagorique', evt, attrs);
    attrs = removeAllAttributes('resisteInjonction', evt, attrs);
    attrs = removeAllAttributes('testsRatesDuTour', evt, attrs);
    //Les élixirs
    attrs = removeAllAttributes('elixirsACreer', evt, attrs);
    attrs = proposerRenouveauElixirs(evt, attrs);
    //Les runes
    attrs = proposerRenouveauRunes(evt, attrs);
    //Les plantes médicinales
    attrs = removeAllAttributes('dose_Plante médicinale', evt, attrs);
    attrs = removeConsommables('Plante médicinale', evt, attrs);
    //On pourrait diviser par 2 le nombre de baies
    //var attrsBaie = allAttributesNamed(attrs, 'dose_Baie_magique');
    //Saves journaliers
    var attrsSave = attrs.filter(function(attr) {
      var attrName = attr.get('name');
      var indexSave = attrName.indexOf('SaveParJour');
      if (indexSave <= 0) return false;
      indexSave = attrName.indexOf('SaveParJourType');
      return indexSave <= 0;
    });
    //Les saves sont asynchrones
    var count = attrsSave.length;
    if (count === 0) {
      proposerFinEffetsIndetermines();
      return;
    }
    var finalize = function() {
      count--;
      if (count > 0) return;
      proposerFinEffetsIndetermines();
    };
    attrsSave.forEach(function(attr) {
      var attrName = attr.get('name');
      var carac = attr.get('current');
      if (!isCarac(carac)) {
        error("Save par jour " + attrName + " mal formé", carac);
        finalize();
        return;
      }
      var seuil = parseInt(attr.get('max'));
      if (isNaN(seuil)) {
        error("Save par jour " + attrName + " mal formé", seuil);
        finalize();
        return;
      }
      var charId = attr.get('characterid');
      var indexSave = attrName.indexOf('SaveParJour');
      var effetC = attrName.substring(0, indexSave);
      attrName = effetC + attrName.substr(indexSave + 11);
      var token;
      iterTokensOfAttribute(charId, undefined, effetC, attrName, function(tok) {
        if (token === undefined) token = tok;
      });
      if (token === undefined) {
        log("Pas de token pour le save " + attrName);
        finalize();
        return;
      }
      var pageId = token.get('pageid');
      var perso = {
        token: token,
        charId: charId
      };
      if (getState(perso, 'mort')) {
        finalize();
        return;
      }
      var attrEffet = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attrName
      });
      if (attrEffet === undefined || attrEffet.length === 0) {
        error("Save sans effet associé " + attrName, attr);
        findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: attr.get('name').replace('SaveParJour', 'SaveParJourType')
        }).forEach(function(a) {
          a.remove();
        });
        attr.remove();
        finalize();
        return;
      }
      attrEffet = attrEffet[0];
      var expliquer = function(msg) {
        sendChar(charId, msg);
      };
      var sujet = onGenre(perso, 'il', 'elle');
      var met = messageEffetIndetermine[effetC];
      if (met === undefined) met = {
        fin: "résiste à l'effet",
        actf: "reste sous l'emprise de l'effet"
      };
      var saveOpts = {
        msgPour: " pour ne plus être sous l'effet " + effetC,
        msgReussite: ", " + sujet + " " + met.fin,
        msgRate: ", " + sujet + " " + met.actif,
        rolls: options.rolls,
        chanceRollId: options.chanceRollId
      };
      var attrType = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attr.get('name').replace('SaveParJour', 'SaveParJourType')
      });
      if (attrType.length > 0) {
        saveOpts.type = attrType[0].get('current');
      }
      var saveId = 'saveParJour_' + effetC + "_" + perso.token.id;
      save({
          carac: carac,
          seuil: seuil
        }, perso, saveId, expliquer, saveOpts, evt,
        function(reussite, texte) { //asynchrone
          if (reussite) {
            finDEffet(attrEffet, effetC, attrName, charId, evt, {
              attrSave: attr,
              pageId: pageId
            });
          }
          count--;
        });
    }); //fin boucle attrSave
  }

  function parseNouveauJour(msg) {
    var options = parseOptions(msg);
    getSelected(msg, function(selection, playerId) {
      options.playerId = playerId;
      if (selection.length === 0) {
        var pageId = getPageId(playerId);
        var tokens =
          findObjs({
            _type: 'graphic',
            _subtype: 'token',
            layer: 'objects',
            _pageid: pageId
          });
        tokens.forEach(function(tok) {
          if (tok.get('represents') === '') return;
          selection.push({
            _id: tok.id
          });
        });
      }
      var persos = [];
      iterSelected(selection, function(perso) {
        persos.push(perso);
      });
      doNouveauJour(persos, options);
    }, options);
  }

  function doNouveauJour(persos, options) {
    var evt = {
      type: "nouveauJour",
      attributes: [],
      action: {
        persos: persos,
        options: options
      }
    };
    addEvent(evt);
    var fromMsg = 'player|' + options.playerId;
    var player = getObj('player', options.playerId);
    if (player) {
      var speaksAs = player.get('speakingas');
      if (speaksAs !== '') fromMsg = speaksAs;
    }
    sendChat(fromMsg, "Un nouveau jour se lève");
    if (stateCOF.combat) sortirDuCombat();
    jour(evt, options);
    if (options.repos) {
      recuperation(persos, true, options.playerId, evt, options);
    }
  }

  function parseRecuperer(msg) {
    if (stateCOF.combat) {
      sendPlayer(msg, "impossible de se reposer en combat");
      return;
    }
    var reposLong = false;
    if (msg.content.includes(' --reposLong')) reposLong = true;
    getSelected(msg, function(selection, playerId) {
      if (selection.length === 0) {
        sendPlayer(msg, "!cof-recuperer sans sélection de tokens");
        log("!cof-recuperer requiert des tokens sélectionnés");
        return;
      }
      var persos = [];
      iterSelected(selection, function(perso) {
        persos.push(perso);
      });
      doRecuperation(persos, reposLong, playerId);
    });
  }

  function doRecuperation(persos, reposLong, playerId, options) {
    var evt = {
      type: "recuperation",
      attributes: [],
      action: {
        persos: persos,
        reposLong: reposLong,
        playerId: playerId,
        options: options
      }
    };
    addEvent(evt);
    recuperation(persos, reposLong, playerId, evt, options);
  }

  //Asynchrone (jets de dés)
  // ne rajoute pas evt à l'historique
  function recuperation(persos, reposLong, playerId, evt, options) {
    options = options || {};
    var manquePV = [];
    var ecuyers = [];
    var count = persos.length;
    var finalize = function() {
      count--;
      if (count === 0) {
        if (ecuyers.length > 0 && manquePV.length > 0) {
          soinsEcuyers(ecuyers, manquePV, playerId, evt);
        }
      }
    };
    persos.forEach(function(perso) {
      if (getState(perso, 'mort')) {
        finalize();
        return;
      }
      if (reposLong) {
        var attrEcuyerDe = findObjs({
          _type: 'attribute',
          _characterid: perso.charId,
          name: 'ecuyerDe'
        });
        if (attrEcuyerDe.length > 0) {
          ecuyers.push({
            perso: perso,
            ecuyerDe: attrEcuyerDe[0].get('current')
          });
        }
      }
      var token = perso.token;
      var charId = perso.charId;
      var character = getObj("character", charId);
      if (character === undefined) {
        finalize();
        return;
      }
      var characterName = character.get("name");
      var pr = pointsDeRecuperation(perso);
      var bar2 = parseInt(token.get("bar2_value"));
      var manaAttr = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'PM'
      }, {
        caseInsensitive: true
      });
      var hasMana = false;
      var dmTemp = bar2;
      var estPNJ = persoEstPNJ(perso);
      var estMook = token.get("bar1_link") === '';
      var nameAttrDMTEMP = 'DMTEMP';
      var versionFiche = parseFloat(ficheAttribute(perso, 'version', 0));
      if (isNaN(versionFiche)) versionFiche = 0;
      if (estPNJ && !estMook && versionFiche < 3.7) nameAttrDMTEMP = 'pnj_dmtemp';
      if (manaAttr.length > 0) { // Récupération des points de mana
        var manaMax = parseInt(manaAttr[0].get('max'));
        hasMana = !isNaN(manaMax) && manaMax > 0;
        if (hasMana) {
          if (estMook) dmTemp = attributeAsInt(perso, 'DMTEMP', 0);
          else dmTemp = ficheAttributeAsInt(perso, nameAttrDMTEMP, 0);
          if (reposLong && (isNaN(bar2) || bar2 < manaMax)) {
            updateCurrentBar(perso, 2, manaMax, evt);
          }
        }
      }
      if (!isNaN(dmTemp) && dmTemp > 0) { // récupération de DM temp
        if (reposLong) dmTemp = 0;
        else dmTemp = Math.max(0, dmTemp - 10);
        if (hasMana) {
          setTokenAttr(perso, nameAttrDMTEMP, dmTemp, evt);
        } else {
          updateCurrentBar(perso, 2, dmTemp, evt);
        }
      }
      var bar1 = parseInt(token.get("bar1_value"));
      var pvmax = parseInt(token.get("bar1_max"));
      if (isNaN(bar1) || isNaN(pvmax)) {
        finalize();
        return;
      }
      if (bar1 >= pvmax && (pr.current == pr.max || !reposLong)) {
        if (!reposLong) {
          sendChat("", characterName + " n'a pas besoin de repos");
        }
        finalize();
        return;
      }
      if (reposLong && charAttributeAsBool(perso, 'montureMagique')) {
        //La monture magique récupère tous ses PV durant la nuit
        updateCurrentBar(perso, 1, pvmax, evt);
        sendChar(charId, "récupère tous ses PV");
        finalize();
        return;
      }
      var dVie = charAttributeAsInt(perso, "DV", 0);
      if (dVie < 4) {
        if (bar1 < pvmax) manquePV.push(perso);
        finalize();
        return; //Si pas de dé de vie, alors pas de PR.
      }
      if (limiteRessources(perso, options, 'repos', 'repos', evt)) {
        if (bar1 < pvmax) manquePV.push(perso);
        finalize();
        return;
      }
      var message;
      if (reposLong && pr.current < pr.max) { // on récupère un PR
        //Sauf si on a une blessure gave
        if (getState(perso, 'blesse')) {
          var testId = 'guérir_blessure_' + perso.token.id;
          testCaracteristique(perso, 'CON', 8, testId, options, evt, function(tr) {
            sendChar(charId, "fait un jet de CON pour guérir de sa blessure");
            var m = "/direct " + onGenre(perso, 'Il', 'Elle') + " fait " + tr.texte;
            if (tr.reussite) {
              sendChar(charId, m + "&ge; 8, son état s'améliore nettement." + tr.modifiers);
              setState(perso, 'blesse', false, evt);
            } else {
              var msgRate = m + "< 8, son état reste préoccupant." + tr.rerolls + tr.modifiers;
              sendChar(charId, msgRate);
            }
            finalize();
          });
          return;
        }
        var affAttr = rajouterPointDeRecuperation(perso, evt);
        if (affAttr === undefined) {
          error("Pas de point de récupérartion à rajouter et pourtant pas au max", token);
          finalize();
          return;
        }
        message =
          "Au cours de la nuit, les points de récupération de " + characterName +
          " passent de " + pr.current + " à " + (pr.current + 1);
        sendChar(charId, message);
        if (bar1 < pvmax) manquePV.push(perso);
        finalize();
        return;
      }
      if (!reposLong) {
        if (pr.current === 0) { //pas possible de récupérer
          message = " a besoin d'une nuit complète pour récupérer";
          sendChar(charId, message);
          finalize();
          return;
        } else { //dépense d'un PR
          enleverPointDeRecuperation(perso, evt);
          pr.current--;
        }
      }
      var conMod = modCarac(perso, 'constitution');
      var niveau = ficheAttributeAsInt(perso, 'niveau', 1);
      var rollExpr = addOrigin(characterName, "[[1d" + dVie + "]]");
      sendChat("COF", rollExpr, function(res) {
        var rollRecupID = "rollRecup_" + perso.token.id;
        options.rolls = options.rolls || {};
        var roll = options.rolls[rollRecupID] ? options.rolls[rollRecupID] : res[0].inlinerolls[0];
        evt.action = evt.action || {};
        evt.action.rolls = evt.action.rolls || {};
        evt.action.rolls[rollRecupID] = roll;
        var dVieRoll = roll.results.total;
        var bonus = conMod + niveau;
        var total = dVieRoll + bonus;
        if (total < 0) total = 0;
        if (bar1 === 0) {
          if (attributeAsBool(perso, 'etatExsangue')) {
            removeTokenAttr(perso, 'etatExsangue', evt, {
              msg: "retrouve des couleurs"
            });
          }
        }
        bar1 += total;
        if (bar1 < pvmax) manquePV.push(perso);
        else bar1 = pvmax;
        updateCurrentBar(perso, 1, bar1, evt);
        if (reposLong) {
          message = "Au cours de la nuit, ";
        } else {
          message = "Après 5 minutes de minutes de repos, ";
        }
        message +=
          characterName + " récupère " + buildinline(roll) + "+" + bonus + " PV. Il lui reste " + pr.current + " points de récupération";
        sendChar(charId, "/direct " + message);
        finalize();
      });
    });
  }

  function recharger(msg) {
    var cmd = msg.content.split(" ");
    if (cmd.length < 2) {
      error("La fonction !cof-recharger attend au moins un argument", msg);
      return;
    }
    var attackLabel = cmd[1];
    var evt = {
      type: 'recharger',
      attributes: []
    };
    var grenaille = false;
    if (msg.content.includes(' --grenaille')) grenaille = true;
    var options = {};
    if (msg.content.includes(' --son')) {
      options = parseOptions(msg);
      options = options || {};
    }
    getSelected(msg, function(selected) {
      if (selected === undefined) {
        sendPlayer(msg, "!cof-recharger sans sélection de tokens");
        log("!cof-recharger requiert des tokens sélectionnés");
        return;
      }
      iterSelected(selected, function(perso) {
        var att = getAttack(attackLabel, perso);
        if (att === undefined) {
          error("Arme " + attackLabel + " n'existe pas pour " + perso.tokName, perso);
          return;
        }
        var weaponName = att.weaponName;
        var attrs =
          findObjs({
            _type: 'attribute',
            _characterid: perso.charId,
            name: "charge_" + attackLabel
          });
        if (attrs.length < 1) {
          perso.tokName = perso.tokName || perso.token.get('name');
          log("Personnage " + perso.tokName + " sans charge " + attackLabel);
          attrs = createObj('attribute', {
            characterid: perso.charId,
            name: 'charge_' + attackLabel,
            current: 0,
            max: 1
          });
        } else attrs = attrs[0];
        var maxCharge = parseInt(attrs.get('max'));
        if (isNaN(maxCharge)) {
          error("max charge mal formée", attrs);
          return;
        }
        var currentCharge = parseInt(attrs.get('current'));
        if (isNaN(currentCharge)) {
          error("charge mal formée", attrs);
          return;
        }
        var attrGrenaille =
          findObjs({
            _type: 'attribute',
            _characterid: perso.charId,
            name: "chargeGrenaille_" + attackLabel
          });
        var currentChargeGrenaille;
        if (currentCharge < maxCharge) {
          if (grenaille) {
            if (attrGrenaille.length < 1) {
              attrGrenaille = createObj('attribute', {
                characterid: perso.charId,
                name: 'chargeGrenaille_' + attackLabel,
                current: 0
              });
            } else attrGrenaille = attrGrenaille[0];
            currentChargeGrenaille = parseInt(attrGrenaille.get('current'));
            if (isNaN(currentChargeGrenaille)) {
              error("charge de grenaille mal formée", attrGrenaille);
              return;
            }
            if (currentChargeGrenaille > currentCharge) currentChargeGrenaille = currentCharge;
            evt.attributes.push({
              attribute: attrGrenaille,
              current: currentChargeGrenaille
            });
            attrGrenaille.set('current', currentChargeGrenaille + 1);
          }
          evt.attributes.push({
            attribute: attrs,
            current: currentCharge
          });
          attrs.set('current', currentCharge + 1);
          updateNextInit(perso);
          if (options.son) playSound(options.son);
          if (grenaille)
            sendChar(perso.charId, "charge " + weaponName + " de grenaille.");
          else
            sendChar(perso.charId, "recharge " + weaponName);
          return;
        } else {
          if (grenaille) { //On peut vouloir changer des charges normales en grenaille
            if (attrGrenaille.length < 1) {
              attrGrenaille = createObj('attribute', {
                characterid: perso.charId,
                name: 'chargeGrenaille_' + attackLabel,
                current: 0
              });
            } else attrGrenaille = attrGrenaille[0];
            currentChargeGrenaille = parseInt(attrGrenaille.get('current'));
            if (isNaN(currentChargeGrenaille)) {
              error("charge de grenaille mal formée", attrGrenaille);
              return;
            }
            if (currentChargeGrenaille < currentCharge) {
              evt.attributes.push({
                attribute: attrGrenaille,
                current: currentChargeGrenaille
              });
              attrGrenaille.set('current', currentChargeGrenaille + 1);
              sendChar(perso.charId, "remplace une charge de " + weaponName + " par de la grenaille.");
              return;
            }
          } else if (attrGrenaille.length > 0) {
            attrGrenaille = attrGrenaille[0];
            currentChargeGrenaille = parseInt(attrGrenaille.get('current'));
            if (isNaN(currentChargeGrenaille)) {
              error("charge de grenaille mal formée", attrGrenaille);
              return;
            }
            if (currentChargeGrenaille > 0) {
              evt.attributes.push({
                attribute: attrGrenaille,
                current: currentChargeGrenaille
              });
              attrGrenaille.set('current', currentChargeGrenaille - 1);
              sendChar(perso.charId, "remplace une charge de grenaille  de " + weaponName + " par une charge normale.");
              return;
            }
          }
        }
        if (maxCharge == 1) {
          sendChar(perso.charId, weaponName + " est déjà chargé");
        } else {
          sendChar(perso.charId, "a déjà tous ses " + weaponName + " chargés");
        }
      });
    });
    addEvent(evt);
  }

  //!cof-bouton-chance [evt.id] [rollId]
  function boutonChance(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-bouton-chance n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou éte annulée", args);
      return;
    }
    var perso = evt.personnage;
    var rollId;
    if (args.length > 2) {
      if (!evt.action) {
        error("Le dernier évènement n'est pas une action", args);
        return;
      }
      var roll = evt.action.rolls[args[2]];
      if (roll === undefined) {
        error("Erreur interne du bouton de chance : roll non identifié", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de chance : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[2];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de chance : l'évenement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var chance = pointsDeChance(perso);
    if (chance <= 0) {
      sendChar(perso.charId, " n'a plus de point de chance à dépenser...");
      return;
    }
    var evtChance = {
      type: 'chance',
      rollId: rollId
    };
    chance--;
    var action = evt.action;
    if (action) { //alors on peut faire le undo
      undoEvent(evt);
      setFicheAttr(perso, 'pc', chance, evtChance, {
        msg: " a dépensé un point de chance. Il lui en reste " + chance
      });
      addEvent(evtChance);
      addChanceToOptions(action.options, rollId);
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'évènement pas encore géré pour la chance", evt);
    addEvent(evtChance);
  }

  //!cof-prouesse [evt.id] [rollId]
  function boutonProuesse(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-prouesse n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou éte annulée", args);
      return;
    }
    var perso = evt.personnage;
    var rollId;
    if (args.length > 2) {
      if (!evt.action) {
        error("Le dernier évènement n'est pas une action", args);
        return;
      }
      var roll = evt.action.rolls[args[2]];
      if (roll === undefined) {
        error("Erreur interne du bouton de chance : roll non identifié", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de prouesse : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[2];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de prouesse : l'évenement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var attrs = tokenAttribute(perso, "prouesse");
    if (attrs.length < 1) {
      error("Resource pour prouesse mal formée", attrs);
      return;
    }
    var curAttribut = attrAsInt(attrs, 0);
    if (curAttribut == 0) {
      error(perso.token.name + " ne peut plus utiliser sa prouesse");
      return;
    }
    var action = evt.action;
    if (action) { //alors on peut faire le undo
      var options = evt.action.options || {};
      options.rolls = action.rolls || {};
      undoEvent(evt);
      var d4 = rollDePlus(4);
      var r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      var evtProuesse = {
        type: 'prouesse',
        rollId: rollId,
        attributes: [{
          attribute: attrs[0],
          current: curAttribut
        }],
        action: {
          rolls: {
            "prouesseDmg": d4
          }
        }
      };
      addEvent(evtProuesse);
      var explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtProuesse, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendChar(perso.charId, "réalise une prouesse et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendChar(perso.charId, expl);
          });
        });
      attrs[0].set('current', curAttribut - 1);

      if (rollId) {
        options.chanceRollId = options.chanceRollId || {};
        options.chanceRollId[rollId] = (options.chanceRollId[rollId] + 5) || 5;
      } else {
        options.chance = (options.chance + 10) || 10;
      }
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'évènement pas encore géré pour la chance", evt);
  }

  //!cof-pacte-sanglant [evt.id] [3|5] [rollId]
  function boutonPacteSanglant(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("La fonction !cof-pacte-sanglant n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou éte annulée", args);
      return;
    }
    var bonus = parseInt(args[2]);
    if (isNaN(bonus)) {
      error("Il manque un choix de bonus au Pacte sanglant", args);
      return;
    }
    var perso = evt.personnage;
    var rollId;
    if (args.length > 3) {
      if (!evt.action) {
        error("Le dernier évènement n'est pas une action", args);
        return;
      }
      var roll = evt.action.rolls[args[3]];
      if (roll === undefined) {
        error("Erreur interne du bouton de pacte sanglant : roll non identifié", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de pacte sanglant : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[3];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de pacte sanglant : l'évenement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var valPacteSanglant = attributeAsInt(perso, 'pacteSanglant', 0);
    if (valPacteSanglant < bonus) {
      error(perso.token.name + " ne peut pas faire ça !");
      return;
    }
    var action = evt.action;
    if (action) { //alors on peut faire le undo
      var options = action.options || {};
      undoEvent(evt);
      var d4 = (valPacteSanglant < 5) ? rollDePlus(4) : rollDePlus(4, {
        nbDes: 2
      });
      var r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      var evtPacteSanglant = {
        type: 'pacteSanglant',
        rollId: rollId,
        action: {
          rolls: {
            "pacteSanglantDmg": d4
          }
        }
      };
      addEvent(evtPacteSanglant);
      var explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtPacteSanglant, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendChar(perso.charId, "réalise un Pacte sanglant et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendChar(perso.charId, expl);
          });
        });
      if (rollId) {
        options.chanceRollId = options.chanceRollId || {};
        options.chanceRollId[rollId] = (options.chanceRollId[rollId] + bonus) || bonus;
      } else {
        options.chance = (options.chance + bonus) || bonus;
      }
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'évènement pas encore géré pour la chance", evt);
  }

  //!cof-pacte-sanglant [evt.id] [3|5] [targetId]
  function boutonPacteSanglantDef(msg) {
    var args = msg.content.split(' ');
    if (args.length < 4) {
      error("La fonction !cof-pacte-sanglant-def n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou éte annulée", args);
      return;
    }
    if (!evt.action) {
      error("Le dernier évènement n'est pas une action", args);
      return;
    }
    var bonus = parseInt(args[2]);
    if (isNaN(bonus)) {
      error("Il manque un choix de bonus au Pacte sanglant", args);
      return;
    }
    var perso = persoOfId([args[3]]);
    if (perso === undefined) {
      error("Erreur interne du bouton de pacte sanglant (DEF) : pas de cible trouvée", args);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var valPacteSanglant = attributeAsInt(perso, 'pacteSanglant', 0);
    if (valPacteSanglant < bonus) {
      error(perso.token.name + " ne peut pas faire ça !");
      return;
    }
    var action = evt.action;
    if (action) { //alors on peut faire le undo
      var options = action.options || {};
      undoEvent(evt);
      var d4 = (valPacteSanglant < 5) ? rollDePlus(4) : rollDePlus(4, {
        nbDes: 2
      });
      var r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      var evtPacteSanglant = {
        type: 'pacteSanglantDEF',
        action: {
          rolls: {
            "pacteSanglantDmg": d4
          }
        }
      };
      addEvent(evtPacteSanglant);
      var explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtPacteSanglant, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendChar(perso.charId, "réalise un Pacte sanglant et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendChar(perso.charId, expl);
          });
        });
      options.pacteSanglantDef = options.pacteSanglantDef || {};
      options.pacteSanglantDef[perso.token.id] = (options.pacteSanglantDef[perso.token.id] + bonus) || bonus;
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'évènement pas encore géré pour la chance", evt);
  }

  //!cof-tour-force [evt.id] [rollId]
  function boutonTourDeForce(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-tour-force n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou éte annulée", args);
      return;
    }
    var perso = evt.personnage;
    var rollId;
    if (args.length > 2) {
      if (!evt.action) {
        error("Le dernier évènement n'est pas une action", args);
        return;
      }
      var roll = evt.action.rolls[args[2]];
      if (roll === undefined) {
        error("Erreur interne du bouton de tour de force : roll non identifié", args);
        return;
      }
      if (roll.token === undefined) {
        error("Erreur interne du bouton de tour de force : roll sans token", args);
        return;
      }
      perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
      rollId = args[2];
    }
    if (perso === undefined) {
      error("Erreur interne du bouton de tour de force : l'évenement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var attrTourDeForce = attributeAsBool(perso, 'tourDeForce');
    if (!attrTourDeForce) {
      error(perso.token.name + " ne peut pas faire ça !");
      return;
    }
    var action = evt.action;
    if (action) { //alors on peut faire le undo
      var options = action.options || {};
      undoEvent(evt);
      var d4 = rollDePlus(4);
      var r = {
        total: d4.val,
        type: 'normal',
        display: d4.roll
      };
      var evtTourDeForce = {
        type: 'tourDeForce',
        rollId: rollId,
        action: {
          rolls: {
            "tourDeForceDmg": d4
          }
        }
      };
      addEvent(evtTourDeForce);
      var explications = [];
      perso.ignoreTouteRD = true;
      dealDamage(perso, r, [], evtTourDeForce, false, {}, explications,
        function(dmgDisplay, dmg) {
          sendChar(perso.charId, "réalise un Tour de force et perd " + dmgDisplay + " PV");
          explications.forEach(function(expl) {
            sendChar(perso.charId, expl);
          });
        });
      if (rollId) {
        options.chanceRollId = options.chanceRollId || {};
        options.chanceRollId[rollId] = (options.chanceRollId[rollId] + 10) || 10;
      } else {
        options.chance = (options.chance + 10) || 10;
      }
      if (redoEvent(evt, action, perso)) return;
    }
    error("Type d'évènement pas encore géré pour la chance", evt);
  }

  //Renvoie true si redo possible, false sinon
  function redoEvent(evt, action, perso) {
    var options = action.options || {};
    options.rolls = action.rolls;
    options.choices = action.choices;
    switch (evt.type) {
      case 'Attaque':
        options.redo = true;
        if (action.cibles) {
          action.cibles.forEach(function(target) {
            delete target.partialSaveAuto;
          });
        }
        attack(action.playerId, action.attaquant, action.cibles, action.weaponStats, options);
        return true;
      case 'attaqueMagique':
        attaqueMagiqueOpposee(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'armeSecrete':
        doArmeSecrete(action.perso, action.cible, options);
        return true;
      case 'boireAlcool':
        doBoireAlcool(action.playerId, action.persos, options);
        return true;
      case 'dmgDirects':
        dmgDirects(action.playerId, action.playerName, action.cibles, action.dmg, options);
        return true;
      case 'degainer':
        doDegainer(action.persos, action.armeLabel, options);
        return true;
      case 'destructionMortsVivants':
        doDestructionDesMortsVivants(action.lanceur, action.playerName, action.dm, options);
        return true;
      case 'echapperEtreinte':
      case 'echapperEnveloppement':
        doEchapperEnveloppement(action.perso, action.etreinte, action.cube, action.difficulte, options);
        return true;
      case 'effetTemp':
        effetTemporaire(action.playerId, action.cibles, action.effet, action.mEffet, action.duree, options);
        return true;
      case 'enduireDePoison':
        doEnduireDePoison(action.perso, action.armeEnduite, action.savePoison, action.forcePoison, action.attribut,
          action.testINT, action.infosAdditionelles, options);
        return true;
      case 'enveloppement':
      case 'étreinte':
        doEnveloppement(action.attaquant, action.cible, action.difficulte, action.type, action.exprDM, options);
        return true;
      case 'injonction':
        injonction(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'injonctionMortelle':
        injonctionMortelle(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'jetPerso':
        jetPerso(perso, action.caracteristique, action.difficulte, action.titre, action.playerId, options);
        return true;
      case 'libererAgrippe':
        doLibererAgrippe(action.perso, action.agrippant, action.attrName, options);
        return true;
      case 'natureNourriciere':
        doNatureNourriciere(action.perso, options);
        return true;
      case 'nextTurn':
        var turnOrder = Campaign().get("turnorder");
        if (turnOrder === '') return false; // nothing in the turn order
        turnOrder = JSON.parse(turnOrder);
        if (turnOrder.length < 1) return false; // Juste le compteur de tour
        var lastTurn = turnOrder.shift();
        turnOrder.push(lastTurn);
        Campaign().set("turnorder", JSON.stringify(turnOrder));
        nextTurn(Campaign(), options);
        return true;
      case 'nouveauJour':
        doNouveauJour(action.persos, options);
        return true;
      case 'peur':
        doPeur(action.cibles, action.difficulte, action.duree, options);
        return true;
      case 'provocation':
        doProvocation(action.voleur, action.cible, options);
        return true;
      case 'rage':
        doRageDuBerserk(action.persos, action.typeRage, options);
        return true;
      case 'recuperation':
        doRecuperation(action.persos, action.reposLong, action.playerId, options);
        return true;
      case 'save_state':
        doSaveState(action.playerId, action.perso, action.etat, action.carac, options, action.opposant, action.seuil);
        return true;
      case 'set_state':
        doSetState(action.cibles, action.etat, action.valeur, options);
        return true;
      case 'sommeil':
        doSommeil(action.lanceur, action.cibles, options, action.ciblesSansSave, action.ciblesAvecSave);
        return true;
      case 'surprise':
        doSurprise(action.cibles, action.testSurprise, action.selected, options);
        return true;
      case 'tourDeForce': //Deprecated
        doTourDeForce(action.perso, action.seuil, options);
        return true;
      case 'tueurFantasmagorique':
        tueurFantasmagorique(action.playerId, action.attaquant, action.cible, options);
        return true;
      case 'vapeursEthyliques':
        doVapeursEthyliques(action.playerId, action.persos, options);
        return true;
      default:
        return false;
    }
  }

  function addChanceToOptions(options, rollId) {
    if (rollId) {
      options.chanceRollId = options.chanceRollId || {};
      options.chanceRollId[rollId] = (options.chanceRollId[rollId] + 10) || 10;
    } else {
      options.chance = (options.chance + 10) || 10;
    }
  }

  function echecTotal(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("La fonction !cof-bouton-echec-total n'a pas assez d'arguments", args);
      return;
    }
    var evt = findEvent(args[1]);
    if (evt === undefined) {
      error("L'action est trop ancienne ou éte annulée", args);
      return;
    }
    var perso = evt.personnage;
    if (perso === undefined) {
      error("Erreur interne du bouton d'échec total: l'évenement n'a pas de personnage", evt);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var action = evt.action;
    if (!action || evt.type != "Attaque") {
      error("Erreur interne du bouton d'échec total: l'évènement n'est pas une attaque", evt);
      return;
    }
    var evtEchecTotal = {
      type: 'echecTotal'
    };
    addEvent(evtEchecTotal);
    // assumes that the original action was undone, re-attack with bonus
    var options = action.options;
    options.auto = true;
    options.echecTotal = true;
    attack(action.playerId, perso, perso.token, action.weaponStats, options);
  }

  function persoUtiliseRuneEnergie(perso, evt) {
    var attr = tokenAttribute(perso, 'runeForgesort_énergie');
    if (attr.length < 1 || attr[0].get('current') < 1) {
      sendChar(perso.charId, "n'a pas de rune d'énergie");
      return false;
    }
    if (limiteRessources(perso, {
        limiteParCombat: 1
      }, "runeForgesort_énergie", "a déjà utilisé sa rune d'énergie durant ce combat", evt)) {
      addEvent(evt);
      return false;
    }
    sendChar(perso.charId, "utilise sa rune d'énergie pour relancer un d20 sur un test d'attaque, de FOR, DEX ou CON");
    return true;
  }

  //!cof-bouton-rune-energie
  function runeEnergie(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser les runes d'énergie qu'en combat");
      return;
    }
    var cmd = msg.content.split(' ');
    var evtARefaire;
    var evt = {
      type: "Rune d'énergie",
      attributes: []
    };
    if (cmd.length > 1) { //On relance pour un événement particulier
      evtARefaire = findEvent(cmd[1]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a été annulée", cmd);
        return;
      }
      var perso = evtARefaire.personnage;
      var action = evtARefaire.action;
      if (action === undefined) {
        error("Impossible de relancer l'action", evtARefaire);
        return;
      }
      var rollId;
      if (cmd.length > 2) {
        var roll = action.rolls[cmd[2]];
        if (roll === undefined) {
          error("Erreur interne du bouton de chance : roll non identifié", cmd);
          return;
        }
        if (roll.token === undefined) {
          error("Erreur interne du bouton de chance : roll sans token", cmd);
          return;
        }
        perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
        rollId = cmd[2];
        evt.rollId = rollId;
      }
      if (perso === undefined) {
        error("Erreur interne du bouton de rune d'énergie : l'évenement n'a pas de personnage", evtARefaire);
        return;
      }
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "pas le droit d'utiliser ce bouton");
        return;
      }
      var carac = action.caracteristque;
      if (carac == 'SAG' || carac == 'INT' || carac == 'CHA') {
        sendChar(perso, "ne peut pas utiliser la rune d'énergie pour un test de " + carac);
        return;
      }
      if (!persoUtiliseRuneEnergie(perso, evt)) return;
      undoEvent(evtARefaire);
      addEvent(evt);
      if (rollId) delete action.rolls[rollId];
      else if (action.rolls && action.rolls.attack) delete action.rolls.attack;
      if (!redoEvent(evtARefaire, action, perso))
        error("Type d'évènement pas supporté par le bouton Rune d'Energie", evt);
    } else { //Juste pour vérifier l'attribut et le diminuer
      getSelected(msg, function(selection) {
        if (selection.length === 0) {
          sendPlayer(msg, 'Pas de token sélectionné pour !cof-rune-energie');
          return;
        }
        iterSelected(selection, function(perso) {
          persoUtiliseRuneEnergie(perso, evt);
        }); //fin iterSelected
        addEvent(evt);
      }); //fin getSelected
    }
  }

  function persoUtiliseRunePuissance(perso, labelArme, evt) {
    var attrName = "runeForgesort_puissance(" + labelArme + ")";
    var attr = tokenAttribute(perso, attrName);
    var arme = getAttack(labelArme, perso);
    if (arme === undefined) {
      error(perso.tokNname + " n'a pas d'arme associée au label " + labelArme, perso);
      return false;
    }
    if (attr.length === 0) {
      sendChar(perso.charId, "n'a pas de rune de puissance sur " + arme.weaponName);
      return false;
    }

    if (limiteRessources(perso, {
        limiteParCombat: 1
      }, attrName, "a déjà utilisé sa rune de puissance durant ce combat", evt)) {
      addEvent(evt);
      return false;
    }
    sendChar(perso.charId, "utilise sa rune de puissance pour obtenir les DM maximum de son arme (");
    return true;
  }

  //!cof-rune-puissance label
  //!cof-bouton-rune-puissance label evt.id
  function runePuissance(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser les runes de puissance qu'en combat");
      return;
    }
    var cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il faut spécifier le label de l'arme sur laquelle la rune de puissance est inscrite", cmd);
      return;
    }
    var labelArme = cmd[1];
    var evtARefaire;
    var evt = {
      type: "Rune de puissance",
      attributes: []
    };
    if (cmd.length > 2) { //On relance pour un événement particulier
      evtARefaire = findEvent(cmd[2]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a été annulée", cmd);
        return;
      }
      var perso = evtARefaire.personnage;
      if (perso === undefined) {
        error("Erreur interne du bouton de rune de puissance : l'évenement n'a pas de personnage", evtARefaire);
        return;
      }
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "pas le droit d'utiliser ce bouton");
        return;
      }
      var action = evtARefaire.action;
      if (action === undefined) {
        error("Impossible de relancer l'action", evtARefaire);
        return;
      }
      var options = action.options || {};
      options.redo = true;
      options.maxDmg = true;
      options.rolls = action.rolls;
      action.cibles.forEach(function(target) {
        delete target.rollsDmg;
      });
      if (!persoUtiliseRunePuissance(perso, labelArme, evt)) return;
      addEvent(evt);
      switch (evtARefaire.type) {
        case 'Attaque':
          undoEvent(evtARefaire);
          attack(action.playerId, perso, action.cibles, action.weaponStats, options);
          return;
        default:
          return;
      }
    } else { //Juste pour vérifier l'attribut et le diminuer
      getSelected(msg, function(selection) {
        if (selection.length === 0) {
          sendPlayer(msg, 'Pas de token sélectionné pour !cof-rune-puissance');
          return;
        }
        iterSelected(selection, function(perso) {
          persoUtiliseRunePuissance(perso, labelArme, evt);
        }); //fin iterSelected
        addEvent(evt);
      }); //fin getSelected
    }
  }

  //!cof-bouton-pousser-kiai evt.id
  function kiai(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut pousser un kiai qu'en combat");
      return;
    }
    var cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il manque l'id de l'attaque sur laquelle pousser le kiai", cmd);
      return;
    }
    var evtARefaire = findEvent(cmd[1]);
    if (evtARefaire === undefined) {
      error("L'action est trop ancienne ou a été annulée", cmd);
      return;
    }
    var perso = evtARefaire.personnage;
    if (perso === undefined) {
      error("Erreur interne du bouton de kiai : l'évenement n'a pas de personnage", evtARefaire);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var action = evtARefaire.action;
    if (action === undefined) {
      error("Impossible de relancer l'action", evtARefaire);
      return;
    }
    var attrKiai = tokenAttribute(perso, 'kiai');
    if (attrKiai.length === 0) {
      error("Le personnage " + perso.token.get('name') + " ne sait pas pousser de kiai", cmd);
      return;
    }
    attrKiai = attrKiai[0];
    var currentKiai = parseInt(attrKiai.get('current'));
    if (isNaN(currentKiai) || currentKiai < 1) {
      sendPlayer(msg, perso.token.get('name') + " ne peut plus pousser de kiai pendant ce combat.");
      return;
    }
    var evt = {
      type: "Kiai",
      attributes: [{
        attribute: attrKiai,
        current: currentKiai
      }]
    };
    attrKiai.set('current', currentKiai - 1);
    if (currentKiai > 1) {
      setAttrDuree(perso, 'rechargeDuKiai', randomInteger(6), evt);
    }
    var options = action.options || {};
    options.redo = true;
    options.maxDmg = true;
    options.rolls = action.rolls;
    action.cibles.forEach(function(target) {
      delete target.rollsDmg;
    });
    addEvent(evt);
    switch (evtARefaire.type) {
      case 'Attaque':
        undoEvent(evtARefaire);
        attack(action.playerId, perso, action.cibles, action.weaponStats, options);
        return;
      default:
        return;
    }
  }

  //Devrait être appelé seulement depuis un bouton
  //!cof-esquive-fatale evtid target_id
  function doEsquiveFatale(msg) {
    var cmd = msg.content.split(' ');
    var evtARefaire;
    var evt = {
      type: "Esquive fatale",
      attributes: []
    };
    if (cmd.length < 3) {
      error("Il manque des arguments à !cof-esquive-fatale", cmd);
      return;
    }
    evtARefaire = findEvent(cmd[1]);
    if (evtARefaire === undefined) {
      error("L'attaque est trop ancienne ou a été annulée", cmd);
      return;
    }
    var action = evtARefaire.action;
    if (action === undefined) {
      error("Impossible d'esquiver l'attaque", evtARefaire);
      return;
    }
    var perso = action.cibles[0];
    if (perso === undefined) {
      error("Erreur interne du bouton de 'esquive fatale : l'évenement n'a pas de personnage", evtARefaire);
      return;
    }
    var adversaire = persoOfId(cmd[2]);
    if (adversaire === undefined) {
      sendPlayer(msg, "Il faut cibler un token valide");
      return;
    }
    var attaquant = action.attaquant;
    if (attaquant.token.id == adversaire.token.id) {
      sendPlayer(msg, "Il faut cibler un autre adversaire que l'attaquant");
      return;
    }
    if (distanceCombat(perso.token, adversaire.token) > 0) {
      sendChar(perso.charId, "doit choisir un adversaire au contact pour l'esquive fatale");
      return;
    }
    var ennemisAuContact = perso.ennemisAuContact;
    if (ennemisAuContact === undefined) {
      error("Ennemis au contact non définis", perso);
    } else {
      var i = ennemisAuContact.find(function(tok) {
        return (tok.id == adversaire.token.id);
      });
      if (i === undefined) {
        sendPlayer(msg, "Il faut cibler un adversaire au contact pour l'esquive fatale");
        return;
      }
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var attr = tokenAttribute(perso, 'esquiveFatale');
    if (attr.length === 0) {
      sendChar(perso.charId, "ne sait pas faire d'esquive fatale");
      return;
    }
    attr = attr[0];
    var dispo = parseInt(attr.get('current'));
    if (isNaN(dispo) || dispo < 1) {
      sendChar(perso.charId, "a déjà fait une esquive fatale durant ce combat");
      return;
    }
    adversaire.tokName = adversaire.token.get('name');
    evt.attributes.push({
      attribute: attr,
      current: dispo
    });
    attr.set('current', 0);
    //On va refaire complètement l'attaque
    undoEvent(evtARefaire);
    addEvent(evt);
    adversaire.msgEsquiveFatale = perso.tokName + " esquive l'attaque qui touche " + adversaire.tokName;
    action.cibles = action.cibles.filter(cible => cible.token.id !== perso.token.id);
    action.cibles.push(adversaire);
    removePreDmg(action.options, perso);
    redoEvent(evtARefaire, action);
  }

  function intercepter(msg) {
    getSelected(msg, function(selected) {
      iterSelected(selected, function(cible) {
        var charId = cible.charId;
        var character = getObj('character', charId);
        if (character === undefined) {
          error("L'argument de !cof-intercepter n'est pas une id de token valide (personnage non défini)", msg.content);
          return;
        }
        cible.tokName = cible.token.get('name');
        cible.name = character.get('name');
        if (attributeAsBool(cible, 'intercepter')) {
          sendChar(charId, " a déjà intercepté une attaque ce tour");
          return;
        }
        var voieMeneur = charAttributeAsInt(cible, "voieDuMeneurDHomme", 0);
        if (voieMeneur < 2) {
          error(cible.tokName + " n'a pas un rang suffisant dans la voie du meneur d'homme pour intercepter l'attaque", voieMeneur);
          return;
        }
        var attaque;
        var lastAct = lastEvent();
        if (lastAct !== undefined) {
          attaque = lastAct.action;
        }
        if (attaque === undefined) {
          sendChar(charId, "la dernière action trouvée n'est pas une attaque, impossible d'intercepter");
          return;
        }
        if (attaque.cibles.length === 0) {
          sendChar(charId, "la dernière attaque n'a touché aucune cible, impossible d'intercepter");
          return;
        }
        if (attaque.cibles.length > 1) {
          sendChar(charId, "la dernière attaque a touché plus d'une cible, impossible d'intercepter");
          return;
        }
        var targetName = attaque.cibles[0].tokName;
        if (targetName === undefined) {
          error("Le token de la dernière attaque est indéfini", attaque);
          return;
        }
        if (distanceCombat(cible.token, attaque.cibles[0].token) > 0) {
          sendChar(charId, " est trop loin de " + targetName + " pour intercepter l'attaque");
          return;
        }
        var evt = {
          type: 'interception'
        };
        setTokenAttr(cible, 'intercepter', true, evt, {
          msg: "se met devant " + targetName + " pour intercepter l'attaque !"
        });
        // On annule l'ancienne action
        undoEvent();
        // Puis on refait en changeant la cible
        var options = attaque.options;
        options.intercepter = voieMeneur;
        options.rolls = attaque.rolls;
        options.evt = evt;
        options.redo = true;
        cible.rollsDmg = attaque.cibles[0].rollsDmg;
        attack(attaque.playerId, attaque.attaquant, [cible], attaque.weaponStats, options);
      });
    });
  }

  //simplement prendre les DM à la place d'un autre
  function interposer(msg) {
    getSelected(msg, function(selected) {
      iterSelected(selected, function(cible) {
        var charId = cible.charId;
        var character = getObj('character', charId);
        if (character === undefined) {
          error("L'argument de !cof-interposer n'est pas une id de token valide (personnage non défini)", msg.content);
          return;
        }
        cible.tokName = cible.token.get('name');
        cible.name = character.get('name');
        if (attributeAsBool(cible, 'interposer')) {
          sendChar(charId, " a déjà intercepté une attaque ce tour");
          return;
        }
        var attaque;
        var lastAct = lastEvent();
        if (lastAct !== undefined) {
          attaque = lastAct.action;
        }
        if (attaque === undefined) {
          sendChar(charId, "la dernière action trouvée n'est pas une attaque, impossible d'intercepter");
          return;
        }
        if (attaque.cibles.length === 0) {
          sendChar(charId, "la dernière attaque n'a touché aucune cible, impossible de s'interposer");
          return;
        }
        if (attaque.cibles.length > 1) {
          sendChar(charId, "la dernière attaque a touché plus d'une cible, impossible de s'interposer en utilisant le script");
          return;
        }
        var target = attaque.cibles[0];
        var targetName = target.tokName;
        if (targetName === undefined) {
          error("Le token de la dernière attaque est indéfini", attaque);
          return;
        }
        if (distanceCombat(cible.token, target.token) > 0) {
          sendChar(charId, " est trop loin de " + targetName + " pour s'interposer");
          return;
        }
        var evt = {
          type: 'interposer'
        };
        setTokenAttr(cible, 'interposer', true, evt, {
          msg: "se met devant " + targetName + " pour intercepter l'attaque !"
        });
        var pvApres = target.token.get('bar1_value');
        // On annule l'ancienne action
        undoEvent();
        // On calcule ensuite les pv perdus, et on les applique au défenseur
        var pvPerdus = target.token.get('bar1_value') - pvApres;
        // Puis on refait en changeant la cible
        var options = attaque.options;
        options.interposer = pvPerdus;
        options.rolls = attaque.rolls;
        options.evt = evt;
        options.redo = true;
        cible.rollsDmg = target.rollsDmg;
        attack(attaque.playerId, attaque.attaquant, [cible], attaque.weaponStats, options);
      });
    });
  }

  function exemplaire(msg) {
    getSelected(msg, function(selected) {
      iterSelected(selected, function(cible) {
        var charId = cible.charId;
        if (attributeAsBool(cible, 'exemplaire')) {
          sendChar(charId, " a déjà montré l'exemple à ce tour");
          return;
        }
        var attaque;
        var lastAct = lastEvent();
        if (lastAct !== undefined) {
          if (lastAct.type == 'Attaque' && lastAct.succes === false) {
            attaque = lastAct.action;
          }
        }
        if (attaque === undefined) {
          sendChar(charId, "la dernière action trouvée n'est pas une attaque ratée, impossible de montrer l'exemple");
          return;
        }
        var attackerName = attaque.attaquant.token.get('name');
        if (attackerName === undefined) {
          error("Le token de la dernière attaque est indéfini", attaque);
          return;
        }
        var evt = {
          type: "Montrer l'exemple"
        };
        setTokenAttr(cible, 'exemplaire', true, evt, {
          msg: "montre l'exemple à " + attackerName
        });
        // On annule l'ancienne action
        undoEvent();
        // Puis on refait
        var options = attaque.options;
        options.evt = evt;
        options.redo = true;
        attack(attaque.playerId, attaque.attaquant, attaque.cibles, attaque.weaponStats, options);
      });
    });
  }

  function interventionDivine(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser petit veinard qu'en combat");
      return;
    }
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Problème de parse options", msg.content);
      return;
    }
    if (cmd.length < 2 || (cmd[1] != "rate" && cmd[1] != "touche")) {
      error("Il manque l'option rate ou touche à Intervention Divine", msg);
      return;
    }
    getSelected(msg, function(selected) {
      iterSelected(selected, function(pretre) {
        var charId = pretre.charId;
        var interventionDivine = tokenAttribute(pretre, 'interventionDivine');
        if (interventionDivine.length === 0) {
          sendChar(pretre.charId, "ne sait pas faire d'intervention Divine");
          return;
        }
        interventionDivine = interventionDivine[0];
        var curinterventionDivine = parseInt(interventionDivine.get('current'));
        if (isNaN(curinterventionDivine)) {
          error("Resource pour Intervention Divine mal formée", interventionDivine);
          return;
        }
        if (curinterventionDivine < 1) {
          sendChar(charId, " a déjà fait une intervention divine ce combat");
          return;
        }
        var evtARefaire = lastEvent();
        var perso = evtARefaire.personnage;
        if (perso === undefined) {
          error("Erreur interne : intervention divine sans personnage", evtARefaire);
          return;
        }
        var action = evtARefaire.action;
        if (action === undefined) {
          error("Impossible de relancer l'action", evtARefaire);
          return;
        }
        var optionsRedo = action.options || {};
        optionsRedo.redo = true;
        var evt = {
          type: "Intervention divine",
          attributes: []
        };
        evt.attributes.push({
          attribute: interventionDivine,
          current: curinterventionDivine
        });
        interventionDivine.set('current', 0);
        addEvent(evt);
        if (evtARefaire.type != 'Attaque') {
          //TODO : Implementer triche sur jetPerso() et echapperEnveloppement()
          error("Intervention Divine ne supporte que les attaques", evtARefaire);
          return;
        }
        undoEvent(evtARefaire);
        if (action.cibles) {
          action.cibles.forEach(function(target) {
            delete target.partialSaveAuto;
          });
        }
        optionsRedo.interventionDivine = cmd[1];
        attack(action.playerId, action.attaquant, action.cibles, action.weaponStats, optionsRedo);
        return;
      });
    });
  }

  //!cof-petit-veinard (avec un token sélectionné)
  //!cof-bouton-petit-veinard evtid
  //sans argument, diminue juste l'attribut, sinon relance l'événement
  function petitVeinard(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser petit veinard qu'en combat");
      return;
    }
    var msgOptions = parseOptions(msg);
    if (msgOptions === undefined) return;
    var cmd = msgOptions.cmd;
    if (cmd === undefined) {
      error("Problème de parse options", msg.content);
      return;
    }
    var evtARefaire;
    var evt = {
      type: "Petit veinard",
      attributes: []
    };
    if (cmd.length > 1) { //On relance pour un événement particulier
      evtARefaire = findEvent(cmd[1]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a été annulée", cmd);
        return;
      }
      var perso = evtARefaire.personnage;
      var rollId;
      if (cmd.length > 2) {
        if (!evtARefaire.action) {
          error("Le dernier évènement n'est pas une action", msg.content);
          return;
        }
        var roll = evtARefaire.action.rolls[cmd[2]];
        if (roll === undefined) {
          error("Erreur interne du bouton de chance : roll non identifié", msg.content);
          return;
        }
        if (roll.token === undefined) {
          error("Erreur interne du bouton de chance : roll sans token", msg.content);
          return;
        }
        perso = persoOfId(roll.token.id, roll.token.name, roll.token.pageId);
        rollId = cmd[2];
      }
      if (perso === undefined) {
        error("Erreur interne du bouton petit veinard : l'évenement n'a pas de personnage", evtARefaire);
        return;
      }
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "pas le droit d'utiliser ce bouton");
        return;
      }
      var action = evtARefaire.action;
      if (action === undefined) {
        error("Impossible de relancer l'action", evtARefaire);
        return;
      }
      var petitVeinardAttr = tokenAttribute(perso, 'petitVeinard');
      if (petitVeinardAttr.length === 0) {
        sendChar(perso.charId, "n'est pas un petit veinard");
        return;
      }
      petitVeinardAttr = petitVeinardAttr[0];
      var pvd = parseInt(petitVeinardAttr.get('current'));
      if (isNaN(pvd) || pvd < 0) pvd = 0;
      if (pvd === 0) {
        sendChar(perso.charId, "a déjà tenté sa chance pour ce combat");
        return;
      }
      evt.attributes.push({
        attribute: petitVeinardAttr,
        current: pvd
      });
      petitVeinardAttr.set('current', pvd - 1);
      undoEvent(evtARefaire);
      addEvent(evt);
      if (rollId) delete action.rolls[rollId];
      else if (action.rolls && action.rolls.attack) delete action.rolls.attack;
      if (!redoEvent(evtARefaire, action, perso))
        error("Type d'évènement pas supporté par le bouton Petit Veinard", evt);
    } else { //Juste pour vérifier l'attribut et le diminuer
      getSelected(msg, function(selection) {
        if (selection.length === 0) {
          sendPlayer(msg, 'Pas de token sélectionné pour !cof-petit-veinard');
          return;
        }
        iterSelected(selection, function(perso) {
          var petitVeinardAttr = tokenAttribute(perso, 'petitVeinard');
          if (petitVeinardAttr.length === 0) {
            sendChar(perso.charId, "n'est pas un petit veinard");
            return;
          }
          petitVeinardAttr = petitVeinardAttr[0];
          var pvd = parseInt(petitVeinardAttr.get('current'));
          if (isNaN(pvd) || pvd < 0) pvd = 0;
          if (pvd === 0) {
            sendChar(perso.charId, "a déjà tenté sa chance pour ce combat");
            return;
          }
          evt.attributes.push({
            attribute: petitVeinardAttr,
            current: pvd
          });
          sendChar(perso.charId, "peut relancer un dé");
          petitVeinardAttr.set('current', pvd - 1);
        }); //fin iterSelected
        addEvent(evt);
      }); //fin getSelected
    }
  }

  function parseSurprise(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Problème de parse options", msg.content);
      return;
    }
    var testSurprise;
    if (cmd.length > 1) {
      testSurprise = parseInt(cmd[1]);
      if (isNaN(testSurprise)) testSurprise = undefined;
    }
    var cibles = [];
    var ciblesSelectionnees;
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "!cof-surprise sans sélection de token");
        log("!cof-surprise requiert de sélectionner des tokens");
        return;
      }
      ciblesSelectionnees = selected;
      iterSelected(selected, function(perso) {
        if (!isActive(perso)) {
          return;
        }
        cibles.push(perso);
      });
    });
    if (cibles.length > 0) {
      doSurprise(cibles, testSurprise, ciblesSelectionnees, options);
    } else {
      error("Pas de cible valable sélectionnée pour la surprise", msg.content);
    }
  }

  function doSurprise(cibles, testSurprise, selected, options) {
    var evt = {
      type: 'surprise',
      action: {
        cibles: cibles,
        testSurprise: testSurprise,
        selected: selected,
        options: options
      }
    };
    addEvent(evt);
    initiative(selected, evt);
    var bonusAttrs = [];
    if (!options.nonVivant) bonusAttrs.push('radarMental');
    var display;
    if (testSurprise === undefined) {
      display = startFramedDisplay(options.playerId, "<b>Surprise !</b>");
    } else {
      display = startFramedDisplay(options.playerId, "Test de surprise difficulté " + testSurprise);
    }
    var tokensToProcess = cibles.length;
    var sendEvent = function() {
      if (tokensToProcess == 1) {
        sendChat("", endFramedDisplay(display));
      }
      tokensToProcess--;
    };
    cibles.forEach(function(perso) {
      var name = perso.token.get('name');
      if (charAttributeAsBool(perso, 'immuniteContreSurprise') ||
        charAttributeAsBool(perso, 'immunite_surpris')
      ) {
        addLineToFramedDisplay(display, name + " n'est pas surpris" + eForFemale(perso));
        sendEvent();
        return;
      }
      var bonusSurprise = 0;
      var bonusMessages = [];
      if (surveillance(perso)) {
        bonusSurprise += 5;
        setTokenAttr(perso, 'bonusInitEmbuscade', 5, evt);
        bonusMessages.push(name + " garde un temps d'avance grâce à son compagnon animal : +5");
        initPerso(perso, evt, true);
      }
      if (attributeAsBool(perso, 'sixiemeSens')) {
        bonusSurprise += 5;
        bonusMessages.push(name + " a un sixième sens : +5");
      }
      if (testSurprise !== undefined) {
        var testId = 'surprise_' + perso.token.id;
        var optionsTest = {...options
        };
        optionsTest.bonus = bonusSurprise;
        optionsTest.bonusAttrs = bonusAttrs;
        optionsTest.competence = 'vigilance';
        testCaracteristique(perso, 'SAG', testSurprise, testId, optionsTest, evt,
          function(tr, explications) {
            var result;
            if (tr.reussite) result = "réussi." + tr.modifiers;
            else {
              result = "raté, " + name + " est surpris";
              result += eForFemale(perso);
              result += tr.rerolls + tr.modifiers;
              setState(perso, 'surpris', true, evt);
            }
            var message = name + " fait " + tr.texte + " : " + result;
            addLineToFramedDisplay(display, message);
            explications.forEach(function(m) {
              addLineToFramedDisplay(display, m, 80);
            });
            bonusMessages.forEach(function(m) {
              addLineToFramedDisplay(display, m, 80);
            });
            sendEvent();
          });
      } else { //no test
        setState(perso, 'surpris', true, evt);
        addLineToFramedDisplay(display, name + " est surpris." + eForFemale(perso));
        sendEvent();
      }
    });
  }

  function interchangeable(attackingToken, target, pageId) { //détermine si il y a assez de tokens
    var token = target.token;
    var charId = target.charId;
    var res = {
      result: false,
      targets: []
    };
    if (!isActive(target)) return res;
    var meuteAttr =
      findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'interchangeable'
      });
    if (meuteAttr.length < 1) return res;
    meuteAttr = parseInt(meuteAttr[0].get('current'));
    if (isNaN(meuteAttr) || meuteAttr <= 0) return res;
    var tokens = findObjs({
      _type: 'graphic',
      _subtype: 'token',
      represents: charId,
      _pageid: pageId
    });
    tokens = tokens.filter(function(tok) {
      return isActive({
        token: tok
      });
    });
    res.result = (tokens.length > meuteAttr);
    // Now select the tokens which could be valid targets
    var p = distanceCombat(attackingToken, token);
    if (p === 0) { //cible au contact, on garde toutes celles au contact
      res.targets = tokens.filter(function(tok) {
        var d = distanceCombat(attackingToken, tok);
        return (d === 0);
      });
    } else { // cible à distance, on garde celles au contact de la cible
      res.targets = tokens.filter(function(tok) {
        var d = distanceCombat(token, tok);
        return (d === 0);
      });
    }
    return res;
  }

  var alliesParPerso = {};
  var listeCompetences = {
    FOR: {
      list: [],
      elts: new Set()
    },
    DEX: {
      list: [],
      elts: new Set()
    },
    CON: {
      list: [],
      elts: new Set()
    },
    SAG: {
      list: [],
      elts: new Set()
    },
    INT: {
      list: [],
      elts: new Set()
    },
    CHA: {
      list: [],
      elts: new Set()
    },
    nombre: 0
  };
  // Appelé uniquement après le "ready" et lorsqu'on modifie un handout (fonctionne après l'ajout et la destruction d'un handout)
  // Du coup, alliesParPerso est toujours à jour
  function changeHandout(hand, prev) {
    if (prev && prev.name && prev.name.startsWith("Equipe ")) {
      var handouts = findObjs({
        _type: 'handout'
      });
      alliesParPerso = {};
      handouts.forEach(parseHandout);
    } else if (hand) {
      parseHandout(hand);
    }
  }

  //pour ce débarasser des balises html
  // et avoir un tableau de lignes
  function linesOfNote(note) {
    note = note.trim();
    if (note.startsWith('<p>')) note = note.substring(3);
    note = note.trim().replace(/<span[^>]*>|<\/span>/g, '');
    note = note.replace(/<p>/g, '<br>');
    note = note.replace(/<\/p>/g, '');
    return note.trim().split('<br>');
  }

  function charactersInHandout(note, nomEquipe) {
    var names = linesOfNote(note);
    var persos = new Set();
    names.forEach(function(name) {
      name = name.replace(/<(?:.|\s)*?>/g, ''); //Pour enlever les <h2>, etc
      name = name.trim();
      if (name.length === 0) return;
      var characters = findObjs({
        _type: 'character',
      });
      characters = characters.filter(function(c) {
        return c.get('name').trim() == name;
      });
      if (characters.length === 0) {
        log(name + " dans l'équipe " + nomEquipe + " est inconnu");
        return;
      }
      if (characters.length > 1) {
        var nonArch = characters.filter(function(c) {
          return !(c.get('archived'));
        });
        if (nonArch.length > 0) characters = nonArch;
        if (characters.length > 1) {
          log(name + " dans l'équipe " + nomEquipe + " est en double");
        }
      }
      characters.forEach(function(character) {
        persos.add(character.id);
      });
    });
    return persos;
  }

  function parseHandout(hand) {
    var handName = hand.get('name').trim();
    if (handName.startsWith("Equipe ")) {
      hand.get('notes', function(note) { // asynchronous
        var persos = charactersInHandout(note, handName);
        persos.forEach(function(charId) {
          var ancien = alliesParPerso[charId];
          if (ancien === undefined) {
            ancien = new Set();
            alliesParPerso[charId] = ancien;
          }
          persos.forEach(function(aci) {
            if (aci == charId) return;
            ancien.add(aci);
          });
        });
      }); //end hand.get('notes')
    } else if (handName == 'Compétences' || handName == 'Competences') {
      listeCompetences = {
        FOR: {
          list: [],
          elts: new Set()
        },
        DEX: {
          list: [],
          elts: new Set()
        },
        CON: {
          list: [],
          elts: new Set()
        },
        SAG: {
          list: [],
          elts: new Set()
        },
        INT: {
          list: [],
          elts: new Set()
        },
        CHA: {
          list: [],
          elts: new Set()
        },
        nombre: 0
      };
      hand.get('notes', function(note) { // asynchronous
        var carac; //La carac dont on spécifie les compétences actuellement
        var lignes = linesOfNote(note);
        lignes.forEach(function(ligne) {
          ligne = ligne.trim();
          var header = ligne.split(':');
          if (header.length > 1) {
            var c = header.shift().trim().toUpperCase();
            if (!isCarac(c)) return;
            carac = c;
            ligne = header.join(':').trim();
          }
          if (ligne.length === 0) return;
          if (carac === undefined) {
            error("Compétences sans caractéristique associée", note);
            return;
          }
          var comps = ligne.split(/, |\/| /);
          comps.forEach(function(comp) {
            if (comp.length === 0) return;
            comp = comp.replace(/_/g, ' ');
            listeCompetences[carac].list.push(comp);
            listeCompetences.nombre++;
            listeCompetences[carac].elts.add(comp.toLowerCase());
          });
        });
      }); //end hand.get(notes)
    }
  }

  function estControlleParJoueur(charId) {
    var character = getObj('character', charId);
    if (character === undefined) return false;
    return character.get('controlledby').length > 0;
  }

  function estPJ(perso) {
    if (persoEstPNJ(perso)) return false;
    var dv = ficheAttributeAsInt(perso, 'DV', 0);
    if (dv === 0) return false;
    if (perso.token.get('bar1_link') === '') return false;
    return estControlleParJoueur(perso.charId);
  }

  function estAllieJoueur(perso) {
    if (estControlleParJoueur(perso.charId)) return true;
    var allies = alliesParPerso[perso.charId];
    if (allies === undefined) return false;
    var res = false;
    allies.forEach(function(p) {
      res = res || estControlleParJoueur(p);
    });
    return res;
  }

  var roundMarker;

  var roundMarkerSpec = {
    represents: '',
    rotation: 0,
    layer: 'objects',
    name: 'Init marker',
    aura1_color: '#ff00ff',
    aura2_color: '#00ff00',
    imgsrc: DEFAULT_DYNAMIC_INIT_IMG,
    shownname: false,
    light_hassight: false,
    has_bright_light_vision: false,
    has_night_vision: false,
  };
  var threadSync = 0;

  function activateRoundMarker(sync, token) {
    if (!stateCOF.combat) {
      if (roundMarker) {
        roundMarker.remove();
        roundMarker = undefined;
        stateCOF.roundMarkerId = undefined;
      }
      threadSync = 0;
      return;
    }
    if (sync != threadSync) return;
    if (token) {
      // Cas spéciaux du cavaliers
      var personnage = persoOfId(token.id);
      var monteSur = tokenAttribute(personnage, 'monteSur');
      var estMontePar = tokenAttribute(personnage, 'estMontePar');
      var monture;
      var cavalier;
      if (monteSur.length > 0) {
        cavalier = personnage;
        var montureTokenId = monteSur[0].get("current");
        monture = persoOfId(montureTokenId);
        if (monture !== undefined) token = monture.token;
      } else if (estMontePar.length > 0) {
        monture = personnage;
        var cavalierId = estMontePar[0].get("current");
        cavalier = persoOfId(cavalierId);
      }
      if (roundMarker) roundMarker.remove();
      roundMarkerSpec._pageid = token.get('pageid');
      roundMarkerSpec.layer = token.get('layer');
      roundMarkerSpec.left = token.get('left');
      roundMarkerSpec.top = token.get('top');
      var width = (token.get('width') + token.get('height')) / 2 * flashyInitMarkerScale;
      roundMarkerSpec.width = width;
      roundMarkerSpec.height = width;
      roundMarkerSpec.imgsrc = stateCOF.options.images.val.image_init.val;
      var localImage;
      var gmNotes = token.get('gmnotes');
      try {
        gmNotes = _.unescape(decodeURIComponent(gmNotes)).replace('&nbsp;', ' ');
        gmNotes = linesOfNote(gmNotes);
        gmNotes.forEach(function(l) {
          if (localImage) return;
          if (l.startsWith('init_aura:')) {
            roundMarkerSpec.imgsrc = l.substring(10).trim();
            localImage = true;
          }
        });
      } catch (uriError) {
        log("Erreur de décodage URI dans la note GM de " + token.get('name') + " : " + gmNotes);
      }
      roundMarker = createObj('graphic', roundMarkerSpec);
      if (roundMarker === undefined && localImage) {
        error("Image locale de " + token.get('name') + " incorrecte (" + roundMarkerSpec.imgsrc + ")", gmNotes);
        roundMarkerSpec.imgsrc = stateCOF.options.images.val.image_init.val;
        roundMarker = createObj('graphic', roundMarkerSpec);
      }
      if (roundMarker === undefined && roundMarkerSpec.imgsrc != DEFAULT_DYNAMIC_INIT_IMG) {
        error("Image d'aura d'initiative incorrecte (" + roundMarkerSpec.imgsrc + ")", gmNotes);
        roundMarkerSpec.imgsrc = DEFAULT_DYNAMIC_INIT_IMG;
        roundMarker = createObj('graphic', roundMarkerSpec);
      }
      if (roundMarker === undefined) {
        error("Impossible de créer le token pour l'aura dynamique", roundMarkerSpec);
        return false;
      }
      stateCOF.roundMarkerId = roundMarker.id;
      // Ne pas amener une monture montée en avant pour éviter de cacher le cavalier
      if (cavalier && monture) {
        toFront(monture.token);
        toFront(cavalier.token);
      } else {
        toFront(token);
      }
      setTimeout(_.bind(activateRoundMarker, undefined, sync), 200);
    } else if (roundMarker) { //rotation
      var rotation = roundMarker.get('rotation');
      roundMarker.set('rotation', (rotation + 1) % 365);
      setTimeout(_.bind(activateRoundMarker, undefined, sync), 100);
    }
  }

  function removeTokenFlagAura(token) {
    if (stateCOF.options.affichage.val.init_dynamique.val) {
      if (roundMarker) {
        roundMarker.remove();
        roundMarker = undefined;
        stateCOF.roundMarkerId = undefined;
      }
      return;
    }
    if (aura_token_on_turn) {
      token.set('aura2_radius', '');
      token.set('showplayers_aura2', false);
    } else {
      // Cas des tokens personnalisés
      if (statusForInitEnemy && statusForInitAlly) {
        token.set(statusForInitAlly, false);
        token.set(statusForInitEnemy, false);
      } else token.set('status_flying-flag', false);
    }
  }

  function listeAttaquesVisibles(perso, options, target) {
    options = options || '';
    target = target || '@{target|token_id}';
    var ligne = '';
    //Cherche toutes les attaques à afficher
    var estPNJ = persoEstPNJ(perso);
    var attributes = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    var attaques = {};
    attributes.forEach(function(attr) {
      var attrName = attr.get('name');
      var m;
      if (estPNJ) m = attackNamePNJRegExp.exec(attrName);
      else m = attackNameRegExp.exec(attrName);
      if (m) {
        var attPrefix = m[1];
        var weaponName = attr.get('current');
        if (weaponName === undefined || weaponName === '') {
          error("Pas de nom pour une attaque");
          return;
        }
        attaques[attPrefix] = weaponName;
      }
    });
    _.forEach(attaques, function(weaponName, attPrefix) {
      var attaqueVisible = ficheAttributeAsInt(perso, attPrefix + 'armeactionvisible', 1);
      if (attaqueVisible === 0) return;
      var attLabel = ficheAttribute(perso, attPrefix + "armelabel", 0);
      var command = "!cof-attack @{selected|token_id} " + target + " " + attLabel + " " + options;
      ligne += bouton(command, weaponName, perso) + '<br />';
    });
    //On ajoute aussi les lancers de feu grégeois, si il y en a
    var attrFeuxGregeois = tokenAttribute(perso, 'elixir_feu_grégeois');
    if (attrFeuxGregeois.length > 0) {
      attrFeuxGregeois = attrFeuxGregeois[0];
      var feuxGregeois = parseInt(attrFeuxGregeois.get('current'));
      if (feuxGregeois > 0) {

        var command = attrFeuxGregeois.get('max').trim();
        ligne += bouton(command, 'Feu grégeois', perso, {
          ressource: attrFeuxGregeois
        });
        ligne += " (reste " + feuxGregeois + ")";
      }
    }
    return ligne;
  }

  //Si listActions est fourni, ça doit faire référence à une ability
  //dont le nom commence et termine par #, contenant une liste d'actions
  //à afficher
  function turnAction(perso, playerId, listActions) {
    var pageId = perso.token.get('pageid');
    // Toutes les Abilities du personnage lié au Token
    var abilities = findObjs({
      _type: 'ability',
      _characterid: perso.charId,
    });
    var title = 'Actions possibles :';
    if (stateCOF.chargeFantastique) title = "Charge fantastique: action d'attaque";
    var opt_display = {
      chuchote: true
    };
    if (listActions) {
      title = listActions;
      var fullListActions = '#' + listActions + '#';
      listActions = abilities.find(function(a) {
        return a.get('name') == fullListActions;
      });
    } else {
      afficherOptionsAttaque(perso, opt_display);
    }
    var actionsDuTour = [];
    var actionsParDefaut = false;
    var formeDarbre = false;
    if (listActions) {
      actionsDuTour = [listActions];
    } else {
      if (!isActive(perso)) {
        if (!getState(perso, 'surpris') || !surveillance(perso)) {
          sendChar(perso.charId, "ne peut pas agir à ce tour");
          return true;
        }
      }
      //On recherche dans le Personnage s'il a une "Ability" dont le nom est #Actions#" ou "#TurnAction#".
      formeDarbre = attributeAsBool(perso, 'formeDArbre');
      if (formeDarbre) {
        actionsDuTour = abilities.filter(function(a) {
          return (a.get('name') == '#FormeArbre#');
        });
        if (actionsDuTour.length === 0) formeDarbre = false;
        else actionsParDefaut = true;
      }
      if (actionsDuTour.length === 0) {
        actionsDuTour = abilities.filter(function(a) {
          switch (a.get('name')) {
            case '#TurnAction#':
              return true;
            case '#Actions#':
              actionsParDefaut = true;
              return true;
            default:
              return false;
          }
        });
      }
    }
    //Si elle existe, on lui chuchotte son exécution
    var actionsAAfficher;
    var ligne = '';
    var command = '';
    //Les dégâts aux personnages enveloppés par perso
    var attrs_enveloppe = tokenAttribute(perso, 'enveloppe');
    attrs_enveloppe.forEach(function(a) {
      var cible = persoOfIdName(a.get('current'), pageId);
      if (cible === undefined) {
        error("Attribut d'enveloppe mal formé ou obsolète", a.get('current'));
        return;
      }
      var enveloppeDM = a.get('max');
      if (enveloppeDM.startsWith('ability ')) {
        enveloppeDM = enveloppeDM.substring(8);
        var abEnveloppe = abilities.find(function(abilitie) {
          return (abilitie.get('name') === enveloppeDM);
        });
        if (abEnveloppe) {
          command = abEnveloppe.get('action').trim();
          command = replaceAction(command, perso);
          command = command.replace(new RegExp(escapeRegExp('@{target|token_id}'), 'g'), cible.token.id);
          ligne += bouton(command, "Infliger DMS à " + cible.tokName, perso) + '<br />';
        }
      } else if (enveloppeDM.startsWith('label ')) {
        actionsAAfficher = true;
        command = '!cof-attack ' + perso.token.id + ' ' + cible.token.id + ' ' + enveloppeDM.substring(6) + ' --auto --acide --effet paralyseTemp [[2d6]] --save CON 15';
        ligne += bouton(command, "Infliger DMs à " + cible.tokName, perso) + '<br />';
      } else if (enveloppeDM.startsWith('etreinte ')) {
        actionsAAfficher = true;
        enveloppeDM = enveloppeDM.substring(9);
        command = '!cof-attack ' + perso.token.id + ' ' + cible.token.id + ' --dm ' + enveloppeDM + ' --auto --nom étreinte ';
        ligne += bouton(command, "Infliger DMs à " + cible.tokName, perso) + '<br />';
      } //else pas reconnu
    });
    if (attributeAsBool(perso, 'enveloppePar')) {
      actionsAAfficher = true;
      command = '!cof-echapper-enveloppement --target ' + perso.token.id;
      ligne += bouton(command, 'Se libérer', perso) + '<br />';
    } else if (getState(perso, 'enseveli')) {
      actionsAAfficher = true;
      ligne += boutonSaveState(perso, 'enseveli') + '<br />';
    } else {
      if (stateCOF.armeesDesMorts) {
        var combattreArmee = false;
        stateCOF.armeesDesMorts.forEach(function(armee) {
          var persoArmee = persoOfId(armee);
          if (persoArmee && distanceCombat(perso.token, persoArmee.token, pageId) <= 20 &&
            (!alliesParPerso[persoArmee.charId] || !alliesParPerso[persoArmee.charId].has(perso.charId))) {
            actionsAAfficher = true;
            combattreArmee = true;
          }
        });
        if (combattreArmee) {
          command = '!cof-defense-armee-des-morts ' + perso.token.id;
          ligne += bouton(command, 'Combattre les Morts-Vivants', perso) + '<br />';
        }
      }
      if (attributeAsBool(perso, 'estAgrippePar')) {
        actionsAAfficher = true;
        command = '!cof-liberer-agrippe ' + perso.token.id;
        ligne += bouton(command, 'Se libérer', perso) + '(action de mvt)<br />';
      }
      if (attributeAsBool(perso, 'etreinteImmolePar')) {
        actionsAAfficher = true;
        command = '!cof-liberer-agrippe ' + perso.token.id;
        ligne += bouton(command, 'Se libérer', perso) + ' (action limitée)<br />';
      }
      if (formeDarbre) {
        actionsAAfficher = true;
        command = '!cof-attack @{selected|token_id} @{target|token_id} ["Branches",["@{selected|niveau}",0],20,[1,6,3,0],0]';
        ligne += bouton(command, 'Attaque', perso) + '<br />';
      }
      //On cherche si il y a une armée conjurée à attaquer
      var attrs_armee =
        findObjs({
          _type: "attribute",
          name: 'armeeConjuree',
        });
      if (attrs_armee.length > 0) {
        var allTokens =
          findObjs({
            _type: "graphic",
            _pageid: pageId,
            _subtype: "token",
            layer: "objects"
          });
        var scale = computeScale(pageId);
        var px = perso.token.get('left');
        var py = perso.token.get('top');
        var pxp = px + 10 * PIX_PER_UNIT / scale;
        var pxm = px - 10 * PIX_PER_UNIT / scale;
        var pyp = py + 10 * PIX_PER_UNIT / scale;
        var pym = py - 10 * PIX_PER_UNIT / scale;
        var ps = tokenSize(perso.token, 0);
        pxp += ps;
        pxm -= ps;
        pyp += ps;
        pym -= ps;
        attrs_armee.forEach(function(aa) {
          var aacid = aa.get('characterid');
          if (aacid == perso.charId) return;
          var invocId = aa.get('current');
          if (invocId == perso.charId) return;
          var allies = alliesParPerso[invocId] || new Set();
          if (allies.has(perso.charId)) return;
          allTokens.forEach(function(t) {
            if (t.get('represents') == aacid) {
              //teste si dans un carré de 20 m de coté autour de l'armée.
              var tx = t.get('left');
              var ty = t.get('top');
              if (tx < pxp && tx > pxm && ty < pyp && ty > pym) {
                command = '!cof-attack ' + perso.token.id + ' ' + t.id + ' ["AttaqueArmée",[0,0],20,[0,6,' + (ficheAttributeAsInt(perso, 'niveau', 1) + 1) + ',0],20] --auto --attaqueArmeeConjuree';
                ligne += bouton(command, "Attaque de l'armée", perso) + '<br />';
              }
            }
          });
        });
      }
      //Les soins pour les élémentaires
      if (charAttributeAsBool(perso, 'corpsElementaire')) {
        command = '!cof-soin 5';
        ligne += bouton(command, "Régénération", perso) + " si source élémentaire proche<br />";
      }
      //Les attaques de la fiche à afficher dans la liste d'actions
      var afficherAttaquesFiche =
        actionsParDefaut ||
        (actionsDuTour.length === 0 && stateCOF.options.affichage.val.actions_par_defaut.val);
      if (afficherAttaquesFiche) {
        ligne += listeAttaquesVisibles(perso);
      }
      //L'action de traverser pour un cyclone
      if (attributeAsBool(perso, 'cyclone')) {
        var labelCyclone = getValeurOfEffet(perso, 'cyclone', 1);
        var diffRenverse = 10 + modCarac(perso, 'force');
        var commandTraverser = "!cof-attack @{selected|token_id} @{target|token_id} " + labelCyclone + " --auto --ifSaveFails DEXFOR " + diffRenverse + " --etat renverse --else --diviseDmg 2 --endif";
        ligne += bouton(commandTraverser, 'Traverser', perso) + '<br />';
      }
      //La liste d'action proprement dite
      if (actionsDuTour.length > 0) {
        actionsAAfficher = treatActions(perso, actionsDuTour[0], abilities, function(command, text, macros, options) {
          if (command == 'liste des attaques') {
            ligne += listeAttaquesVisibles(perso, options);
          } else ligne += bouton(command, text, perso, options) + '<br />';
        });
      } else if (stateCOF.options.affichage.val.actions_par_defaut.val) {
        actionsParDefaut = true;
        abilities.forEach(function(a) {
          var actionAbility = a.get('name').replace(/-/g, ' ').replace(/_/g, ' ');
          command = a.get('action').trim();
          ligne += bouton(command, actionAbility, perso) + '<br />';
        });
      }
      if (actionsParDefaut) {
        actionsAAfficher = true;
        command = "!cof-attendre ?{Nouvelle initiative}";
        ligne += bouton(command, 'Attendre', perso) + '<br />';
        if (!charAttributeAsBool(perso, 'armeeConjuree')) {
          command = "!cof-action-defensive ?{Action défensive|simple|totale}";
          ligne += bouton(command, 'Se défendre', perso) + '<br />';
          var manoeuvreDuelliste = charAttributeAsBool(perso, 'manoeuvreDuelliste');
          if (manoeuvreDuelliste) {
            command = "!cof-manoeuvre @{selected|token_id} @{target|token_id} ?{Manoeuvre?|bloquer|desarmer|renverser|tenirADistance|repousser}";
            ligne += bouton(command, 'Manoeuvres de duelliste', perso) + '<br />';
          }
          if (stateCOF.options.affichage.val.manoeuvres.val) {
            if (manoeuvreDuelliste) {
              command = "!cof-manoeuvre @{selected|token_id} @{target|token_id} ?{Manoeuvre?|aveugler|faireDiversion|menacer}";
              ligne += bouton(command, 'Autres manoeuvres', perso) + '<br />';
            } else {
              command = "!cof-manoeuvre @{selected|token_id} @{target|token_id} ?{Manoeuvre?|aveugler|bloquer|desarmer|faireDiversion|menacer|renverser|tenirADistance|repousser}";
              ligne += bouton(command, 'Manoeuvres', perso) + '<br />';
            }
          }
        }
      }
      for (var etat in cof_states) {
        var saveEtat = boutonSaveState(perso, etat);
        if (saveEtat) {
          ligne += saveEtat + '<br />';
          actionsAAfficher = true;
        }
      }
    }
    if (actionsAAfficher) {
      // on envoie la liste aux joueurs qui gèrent le personnage dont le token est lié
      var lastPlayerid;
      // on récupère les players_ids qui controllent le Token
      var playerIds;
      if (playerId) playerIds = [playerId];
      else playerIds = getPlayerIds(perso);
      playerIds.forEach(function(playerid) {
        lastPlayerid = playerid;
        var display = startFramedDisplay(playerid, title, perso, opt_display);
        addLineToFramedDisplay(display, ligne);
        sendChat('', endFramedDisplay(display));
      });
      // En prime, on l'envoie au MJ, si besoin
      if (stateCOF.options.affichage.val.MJ_voit_actions.val || playerIds.length === 0) {
        opt_display.chuchote = 'gm';
        var display = startFramedDisplay(lastPlayerid, title, perso, opt_display);
        addLineToFramedDisplay(display, ligne);
        sendChat('', endFramedDisplay(display));
      }
    }
    return (actionsDuTour.length > 0 || actionsAAfficher);
  }

  function apiTurnAction(msg) {
    var cmd = msg.content.split(' ');
    var abil;
    if (cmd.length > 1 && !(cmd[1].startsWith('--'))) abil = cmd[1];
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        var actions = turnAction(perso, playerId, abil);
        if (!actions) {
          abil = abil || '';
          sendChar(perso.charId, "n'a pas de liste d'actions " + abil + " définie");
        }
      });
    });
  }

  function removeDernieresCiblesAttaquees(perso, evt) {
    var attrDernieresCibles = tokenAttribute(perso, 'dernieresCiblesAttaquees');
    if (attrDernieresCibles.length > 0) {
      attrDernieresCibles = attrDernieresCibles[0];
      if (charAttributeAsBool(perso, 'attaqueEnMeute')) {
        var dernieresCibles = attrDernieresCibles.get('current');
        var cibles = new Set(dernieresCibles.split(' '));
        cibles.forEach(function(ci) {
          var cible = persoOfId(ci);
          if (cible === undefined) return;
          var attrCibleMeute = tokenAttribute(cible, 'attaqueParMeute');
          if (attrCibleMeute.length > 0) {
            attrCibleMeute = attrCibleMeute[0];
            var cibleMeute = attrCibleMeute.get('current');
            var ensembleCibleMeute = new Set(cibleMeute.split(' '));
            if (ensembleCibleMeute.has(perso.token.id)) {
              ensembleCibleMeute.delete(perso.token.id);
              if (ensembleCibleMeute.size > 0) {
                evt.attributes = evt.attributes || [];
                evt.attributes.push({
                  attribute: attrCibleMeute,
                  current: cibleMeute,
                });
                cibleMeute = '';
                ensembleCibleMeute.forEach(function(ai) {
                  if (cibleMeute === '') cibleMeute = ai;
                  else cibleMeute += ' ' + ai;
                });
                attrCibleMeute.set('current', cibleMeute);
              } else {
                evt.deletedAttributes = evt.deletedAttributes || [];
                evt.deletedAttributes.push(attrCibleMeute);
                attrCibleMeute.remove();
              }
            }
          }
        });
      }
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attrDernieresCibles);
      attrDernieresCibles.remove();
    }
  }

  function getTurnOrder(evt) {
    var turnOrder = Campaign().get('turnorder');
    evt.turnorder = evt.turnorder || turnOrder;
    if (turnOrder === "") {
      turnOrder = [{
        id: "-1",
        pr: 1,
        custom: "Tour",
        formula: "+1"
      }];
      evt.tour = stateCOF.tour;
      stateCOF.tour = 1;
    } else {
      turnOrder = JSON.parse(turnOrder);
    }
    var indexTour = turnOrder.findIndex(function(elt) {
      return (elt.id == "-1" && elt.custom == "Tour");
    });
    if (indexTour == -1) {
      indexTour = turnOrder.length;
      turnOrder.push({
        id: "-1",
        pr: 1,
        custom: "Tour",
        formula: "+1"
      });
      evt.tour = stateCOF.tour;
      stateCOF.tour = 1;
    }
    var res = {
      tour: turnOrder[indexTour],
      pasAgi: turnOrder.slice(0, indexTour),
      dejaAgi: turnOrder.slice(indexTour + 1, turnOrder.length)
    };
    return res;
  }

  //ne rajoute pas evt à l'historique
  function setTurnOrder(to, evt) {
    if (to.pasAgi.length > 0) {
      to.pasAgi.sort(function(a, b) {
        if (a.id == "-1") return 1;
        if (b.id == "-1") return -1;
        if (a.pr < b.pr) return 1;
        if (b.pr < a.pr) return -1;
        // Priorité aux joueurs
        // Premier critère : la barre de PV des joueurs est liée
        var tokenA = getObj('graphic', a.id);
        if (tokenA === undefined) return 1;
        var tokenB = getObj('graphic', b.id);
        if (tokenB === undefined) return -1;
        if (tokenA.get('bar1_link') === '') {
          if (tokenB.get('bar1_link') === '') return 0;
          return 1;
        }
        if (tokenB.get('bar1_link') === '') return -1;
        // Deuxième critère : les joueurs ont un DV
        var charIdA = tokenA.get('represents');
        if (charIdA === '') return 1;
        var charIdB = tokenB.get('represents');
        if (charIdB === '') return -1;
        var persoA = {
          token: tokenA,
          charId: charIdA
        };
        var persoB = {
          token: tokenB,
          charId: charIdB
        };
        var dvA = ficheAttributeAsInt(persoA, "DV", 0);
        var dvB = ficheAttributeAsInt(persoB, "DV", 0);
        if (dvA === 0) {
          if (dvB === 0) return 0;
          return 1;
        }
        if (dvB === 0) return -1;
        //Entre joueurs, priorité à la plus grosse sagesse
        var sagA = ficheAttributeAsInt(persoA, 'sagesse', 10);
        var sagB = ficheAttributeAsInt(persoB, 'sagesse', 10);
        if (sagA < sagB) return 1;
        if (sagA > sagB) return -1;
        return 0;
      });
      setActiveToken(to.pasAgi[0].id, evt);
    }
    to.pasAgi.push(to.tour);
    var turnOrder = to.pasAgi.concat(to.dejaAgi);
    Campaign().set('turnorder', JSON.stringify(turnOrder));
  }

  function attendreInit(msg) {
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("La fonction !cof-attendre : rien à faire, pas de token selectionné", msg);
        return;
      }
      var cmd = msg.content.split(' ');
      if (cmd.length < 2) {
        error("Attendre jusqu'à quelle initiative ?", cmd);
        return;
      }
      var newInit = parseInt(cmd[1]);
      if (isNaN(newInit) || newInit < 1) {
        error("On ne peut attendre que jusqu'à une initiative de 1", cmd);
        newInit = 1;
      }
      var evt = {
        type: "attente"
      };
      var to = getTurnOrder(evt);
      iterSelected(selected, function(perso) {
        var charId = perso.charId;
        var token = perso.token;
        if (!isActive(perso)) return;
        var tokenPos =
          to.pasAgi.findIndex(function(elt) {
            return (elt.id == token.id);
          });
        if (tokenPos == -1) { // token ne peut plus agir
          sendChar(charId, " a déjà agit ce tour");
          return;
        }
        if (newInit < to.pasAgi[tokenPos].pr) {
          to.pasAgi[tokenPos].pr = newInit;
          sendChar(charId, " attend un peu avant d'agir...");
          updateNextInit(perso);
        } else {
          sendChar(charId, " a déjà une initiative inférieure à " + newInit);
        }
      });
      setTurnOrder(to, evt);
      addEvent(evt);
    });
  }

  function statut(msg) { // show some character informations
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Dans !cof-statut : rien à faire, pas de token selectionné", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        var token = perso.token;
        var charId = perso.charId;
        var name = token.get('name');
        var lie = true;
        if (token.get('bar1_link') === '') lie = false;
        var display = startFramedDisplay(playerId, "État de " + name, perso, {
          chuchote: true
        });
        var estPNJ = ficheAttribute(perso, 'type_personnage', 'PJ') == 'PNJ';
        var line;
        var hasMana = false;
        var manaAttr = [];
        if (!estPNJ)
          manaAttr = findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: 'PM'
          }, {
            caseInsensitive: true
          });
        if (manaAttr.length > 0) {
          var manaMax = parseInt(manaAttr[0].get('max'));
          hasMana = !isNaN(manaMax) && manaMax > 0;
        }
        var dmTemp = parseInt(token.get('bar2_value'));
        if (hasMana) { //ne peut pas être un PNJ
          if (lie) {
            dmTemp = ficheAttributeAsInt(perso, 'DMTEMP', 0);
          } else {
            dmTemp = attributeAsInt(perso, 'DMTEMP', 0);
          }
        } else if (lie) {
          var nameAttrDMTEMP = 'DMTEMP';
          var versionFiche = parseFloat(ficheAttribute(perso, 'version', 0));
          if (isNaN(versionFiche)) versionFiche = 0;
          if (estPNJ && versionFiche < 3.7) nameAttrDMTEMP = 'pnj_dmtemp';
          dmTemp = ficheAttributeAsInt(perso, nameAttrDMTEMP, 0);
        }
        if (!isNaN(dmTemp) && dmTemp > 0) {
          line = "Dommages temporaires : " + dmTemp;
          addLineToFramedDisplay(display, line);
        }
        var douleurIgnoree = attributeAsInt(perso, 'douleurIgnoree', 0);
        if (douleurIgnoree > 0) {
          line = "a ignoré " + douleurIgnoree + " pv dans ce combat.";
          addLineToFramedDisplay(display, line);
        }
        var aDV = charAttributeAsInt(perso, 'DV', 0);
        if (aDV > 0) { // correspond aux PJs
          var pr = pointsDeRecuperation(perso);
          line =
            "Points de récupération : " + pr.current + " / " + pr.max;
          addLineToFramedDisplay(display, line);
          if (ficheAttributeAsInt(perso, 'option_pc', 1)) {
            var pc = 3;
            var pc_max = 3;
            var attr_pc = charAttribute(perso.charId, 'pc', {
              caseInsensitive: true
            });
            if (attr_pc !== undefined && attr_pc.length > 0) {
              pc = parseInt(attr_pc[0].get('current'));
              if (isNaN(pc)) pc = 0;
              pc_max = parseInt(attr_pc[0].get('max'));
              if (isNaN(pc_max)) pc_max = 3;
            }
            line = "Points de chance : " + pc + " / " + pc_max;
            addLineToFramedDisplay(display, line);
          }
          var pacifisme =
            findObjs({
              _type: "attribute",
              _characterid: charId,
              name: "pacifisme"
            });
          if (pacifisme.length > 0) {
            pacifisme = parseInt(pacifisme[0].get('current'));
            if (!isNaN(pacifisme)) {
              if (pacifisme > 0) addLineToFramedDisplay(display, "Pacifisme actif");
              else addLineToFramedDisplay(display, "Pacifisme non actif");
            }
          }
        }
        var attrsChar = findObjs({
          _type: 'attribute',
          _characterid: charId
        });
        var attaques = {}; // prefix -> nom de l'arme
        attrsChar.forEach(function(attr) {
          var attrName = attr.get('name');
          var m;
          if (estPNJ) m = attackNamePNJRegExp.exec(attrName);
          else m = attackNameRegExp.exec(attrName);
          if (m) {
            var attPrefix = m[1];
            var weaponName = attr.get('current');
            if (weaponName === undefined || weaponName === '') {
              error("Pas de nom pour une attaque");
              return;
            }
            attaques[attPrefix] = weaponName;
          }
        });
        var armeEnMain =
          attrsChar.find(function(a) {
            return a.get('name') == 'armeEnMain';
          });
        var armeEnMainGauche;
        if (armeEnMain) {
          armeEnMainGauche = armeEnMain.get('max');
          armeEnMain = armeEnMain.get('current');
        }
        _.forEach(attaques, function(nomArme, attPrefix) {
          var armeLabel = getAttrByName(perso.charId, attPrefix + "armelabel");
          var charge = attrsChar.find(function(a) {
            return (a.get('name') == 'charge_' + armeLabel);
          });
          if (charge) {
            charge = parseInt(charge.get('current'));
            if (!isNaN(charge)) {
              if (charge === 0) {
                line = nomArme + " n'est pas chargé";
              } else {
                var grenaille = attrsChar.find(function(a) {
                  return (a.get('name') == 'chargeGrenaille_' + armeLabel);
                });
                if (grenaille) {
                  grenaille = parseInt(grenaille.get('current'));
                  if (isNaN(grenaille) || grenaille < 0) grenaille = 0;
                } else grenaille = 0;
                if (charge == 1) {
                  line = nomArme + " est chargé";
                  if (grenaille) line += " de grenaille";
                } else if (charge > 1) {
                  line = nomArme + " contient encore " + charge + " charges";
                  if (grenaille == charge) line += " de grenaille";
                  else if (grenaille)
                    line += ", dont " + grenaille + " de grenaille";
                }
              }
              if (armeEnMain == armeLabel) line += " et en main";
              else if (armeEnMainGauche == armeLabel) line += " et en main gauche";
              else line += ", pas en main";
              addLineToFramedDisplay(display, line);
            }
          } else if (armeEnMain == armeLabel) {
            addLineToFramedDisplay(display, "tient " + nomArme + " en main.");
          } else if (armeEnMainGauche == armeLabel) {
            addLineToFramedDisplay(display, "tient " + nomArme + " en main gauche.");
          }
          if (attributeAsBool(perso, 'poisonRapide_' + armeLabel)) {
            addLineToFramedDisplay(display, nomArme + " est enduit de poison.");
          }
        });
        if (attributeAsInt(perso, 'enflamme', 0))
          addLineToFramedDisplay(display, "en flammes");
        var attrEnveloppe = tokenAttribute(perso, 'enveloppePar');
        if (attrEnveloppe.length > 0) {
          var cube = persoOfIdName(attrEnveloppe[0].get('current'));
          if (cube) {
            var actE = "est enveloppé dans ";
            if ((attrEnveloppe[0].get('max') + '').startsWith('etreinte')) actE = "est prisonnier de l'étreinte de ";
            addLineToFramedDisplay(display, actE + cube.tokName);
          }
        }
        var pageId = perso.token.get('pageid');
        var defense = defenseOfPerso(undefined, perso, pageId, undefined, {
          test: true
        });

        var defenseMontree;
        var bufDef = attributeAsInt(perso, 'bufDEF', 0);
        if (bufDef > 0) {
          addLineToFramedDisplay(display, "Défense temporairement modifiée de " + bufDef + " (DEF " + defense + ")");
          defenseMontree = true;
        }
        for (var etat in cof_states) {
          if (getState(perso, etat)) {
            var markerName = cof_states[etat].substring(7).split("::")[0];
            var marker = markerCatalog[markerName];
            var etext = stringOfEtat(etat, perso);
            if (marker) {
              etext = "<img src=" + marker.url + "></img> " + etext;
            }
            var saveEtat = boutonSaveState(perso, etat);
            if (saveEtat) etext += ", " + saveEtat;
            addLineToFramedDisplay(display, etext);
          }
        }
        if (ficheAttributeAsInt(perso, 'DEFARMUREON', 1) === 0) {
          var possedeArmure = ficheAttributeAsInt(perso, 'DEFARMURE', 0) > 0;
          if (possedeArmure) addLineToFramedDisplay(display, "Ne porte pas son armure");
          if (charAttributeAsInt(perso, 'vetementsSacres', 0) > 0) {
            if (possedeArmure) addLineToFramedDisplay(display, "  mais bénéficie de ses vêtements sacrés (DEF " + defense + ")");
            else addLineToFramedDisplay(display, "porte des vêtements sacrés (DEF " + defense + ")");
            defenseMontree = true;
          }
          if (charAttributeAsInt(perso, 'armureDeVent', 0) > 0) {
            if (possedeArmure) addLineToFramedDisplay(display, "  mais bénéficie de son armure de vent (DEF " + defense + ")");
            else addLineToFramedDisplay(display, "bénéficie de son armure de vent (DEF " + defense + ")");
            defenseMontree = true;
          }
        }
        if (ficheAttributeAsInt(perso, 'DEFBOUCLIERON', 1) === 0 &&
          ficheAttributeAsInt(perso, 'DEFBOUCLIER', 0))
          addLineToFramedDisplay(display, "Ne porte pas son bouclier");
        if (attributeAsBool(perso, 'etatExsangue')) {
          addLineToFramedDisplay(display, "est exsangue");
        }
        if (attributeAsBool(perso, 'malediction')) {
          addLineToFramedDisplay(display, "est maudit...");
        }
        var allAttrs = findObjs({
          _type: 'attribute',
          _characterid: charId
        });
        allAttrs.forEach(function(attr) {
          var attrName = attr.get('name');
          if (!lie && !attrName.endsWith('_' + name)) return;
          if (estEffetTemp(attrName)) {
            var effet = effetTempOfAttribute(attr);
            var mt = messageEffetTemp[effet];
            if (lie) {
              if (mt.generic) {
                if (attrName.indexOf(')_') > 0) return;
              } else if (effet != attrName) return;
            }
            addLineToFramedDisplay(display, mt.actif);
          } else if (estEffetCombat(attrName)) {
            var effetC = effetCombatOfAttribute(attr);
            if (lie && effetC != attrName) return;
            addLineToFramedDisplay(display, messageEffetCombat[effetC].actif);
          } else if (estEffetIndetermine(attrName)) {
            var effetI = effetIndetermineOfAttribute(attr);
            if (lie && effetI != attrName) return;
            addLineToFramedDisplay(display, messageEffetIndetermine[effetI].actif);
          }
        });
        allAttributesNamed(attrsChar, 'munition').forEach(function(attr) {
          var attrName = attr.get('name');
          var underscore = attrName.indexOf('_');
          if (underscore < 0 || underscore == attrName.length - 1) return;
          var munitionNom = attrName.substring(underscore + 1).replace(/_/g, ' ');
          addLineToFramedDisplay(display, munitionNom + " : " + attr.get('current') + " / " + attr.get('max'));
        });
        var attrPosture = tokenAttribute(perso, 'postureDeCombat');
        if (attrPosture.length > 0) {
          attrPosture = attrPosture[0];
          var posture = attrPosture.get('max');
          var postureMsg = "a une posture ";
          switch (posture.substr(-3, 3)) {
            case 'DEF':
              postureMsg += "défensive";
              break;
            case 'ATT':
              postureMsg += "offensive";
              break;
            case '_DM':
              postureMsg += "puissante";
              break;
            default:
          }
          postureMsg += " mais ";
          switch (posture.substr(0, 3)) {
            case 'DEF':
              postureMsg += "risquée";
              break;
            case 'ATT':
              postureMsg += "moins précise";
              break;
            case 'DM_':
              postureMsg += "moins puissante";
              break;
            default:
          }
          addLineToFramedDisplay(display, postureMsg);
        }
        var rangSoin = charAttributeAsInt(perso, 'voieDesSoins', 0);
        if (rangSoin > 0) {
          var msgSoins;
          var soinsRestants;
          var soins = "";
          var soinsLegers = attributeAsInt(perso, 'soinsLegers', 0);
          if (soinsLegers < rangSoin) {
            soinsRestants = rangSoin - soinsLegers;
            if (soinsRestants > 1) soins = 's';
            msgSoins = "peut encore faire " + soinsRestants + " soin" + soins + " léger" + soins;
            addLineToFramedDisplay(display, msgSoins);
          } else {
            addLineToFramedDisplay(display, "ne peut plus faire de soin léger aujourd'hui");
          }
          if (rangSoin > 1) {
            var soinsModeres = attributeAsInt(perso, 'soinsModeres', 0);
            if (soinsModeres < rangSoin) {
              soinsRestants = rangSoin - soinsModeres;
              if (soinsRestants > 1) soins = 's';
              else soins = '';
              msgSoins = "peut encore faire " + soinsRestants + " soin" + soins + " modéré" + soins;
              addLineToFramedDisplay(display, msgSoins);
            } else {
              addLineToFramedDisplay(display, "ne peut plus faire de soin modéré aujourd'hui");
            }
          }
        }
        var ebriete = attributeAsInt(perso, 'niveauEbriete', 0);
        if (ebriete > 0 && ebriete < niveauxEbriete.length) {
          addLineToFramedDisplay(display, "est " + niveauxEbriete[ebriete]);
        }
        var bonusCouvert = attributeAsInt(perso, 'bonusCouvert');
        if (bonusCouvert) {
          addLineToFramedDisplay(display, "est à couvert (+" + bonusCouvert + " DEF)");
        }
        if (!defenseMontree) {
          var defenseAffichee = 10;
          if (estPNJ) {
            defenseAffichee = ficheAttributeAsInt(perso, 'pnj_def', 10);
          } else {
            defenseAffichee += ficheAttributeAsInt(perso, 'DEFARMURE', 0) * ficheAttributeAsInt(perso, 'DEFARMUREON', 1);
            defenseAffichee += ficheAttributeAsInt(perso, 'DEFBOUCLIER', 0) * ficheAttributeAsInt(perso, 'DEFBOUCLIERON', 1);
            defenseAffichee += ficheAttributeAsInt(perso, 'DEFDIV', 0);
            defenseAffichee += modCarac(perso, 'dexterite');
          }
          if (defense != defenseAffichee)
            addLineToFramedDisplay(display, "Défense actuelle : " + defense);
        }
        sendChat("", endFramedDisplay(display));
      });
    });
  }

  //retourne l'id du suivant si le token actuel était en tête de liste
  function removeFromTurnTracker(perso, evt) {
    removeDernieresCiblesAttaquees(perso, evt);
    var tokenId = perso.token.id;
    var turnOrder = Campaign().get('turnorder');
    if (turnOrder === "" || !stateCOF.combat) {
      return;
    }
    evt.turnorder = evt.turnorder || turnOrder;
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length === 0) return;
    var res;
    if (turnOrder[0].id == tokenId) {
      if (turnOrder.length > 1) {
        res = {
          nextId: turnOrder[1].id
        };
        turnOrder.shift();
      } else {
        res = {
          nextId: false
        };
        turnOrder = [];
      }
    } else {
      turnOrder = turnOrder.filter(
        function(elt) {
          return (elt.id != tokenId);
        });
    }
    Campaign().set('turnorder', JSON.stringify(turnOrder));
    return res;
  }

  function replaceInTurnTracker(tidOld, tidNew, evt) {
    var turnOrder = Campaign().get('turnorder');
    if (turnOrder === "" || !stateCOF.combat) {
      return;
    }
    evt.turnorder = evt.turnorder || turnOrder;
    turnOrder = JSON.parse(turnOrder);
    turnOrder.forEach(function(elt) {
      if (elt.id == tidOld) elt.id = tidNew;
    });
    Campaign().set('turnorder', JSON.stringify(turnOrder));
    if (tidOld == stateCOF.activeTokenId)
      stateCOF.activeTokenId = tidNew;
  }

  function armureMagique(msg) {
    msg.content += " armureMagique";
    effetCombat(msg);
  }

  function bufDef(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("La fonction !cof-buf-def attend un argument", cmd);
      return;
    }
    var buf = parseInt(cmd[1]);
    if (isNaN(buf)) {
      error("Argument de !cof-bu-def invalide", cmd);
      return;
    }
    if (buf === 0) return;
    var message = "";
    if (buf > 0) message = "voit sa défense augmenter";
    else message = "voit sa défense baisser";
    var evt = {
      type: 'other'
    };
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de token sélectionné pour !cof--buf-def");
      }
      iterSelected(selected, function(perso) {
        setTokenAttr(perso, 'bufDEF', buf, evt, {
          msg: message
        });
        setToken(perso.token, 'status_blue', buf, evt);
      });
      if (evt.attributes.length === 0) {
        error("Pas de cible valide sélectionnée pour !cod-buf-def", msg);
        return;
      }
      addEvent(evt);
    });
  }

  function removeBufDef(msg) {
    var evt = {
      type: 'other'
    };
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de token sélectionné pour !cof-remove-buf-def");
      }
      iterSelected(selected, function(perso) {
        removeTokenAttr(perso, 'bufDEF', evt, {
          msg: "retrouve sa défense normale"
        });
        setToken(perso.token, 'status_blue', false, evt);
      });
      addEvent(evt);
    });
  }

  function deTest(personnage, carac) {
    var dice = 20;
    if ((estAffaibli(personnage) && !charAttributeAsBool(personnage, 'insensibleAffaibli')) ||
      getState(personnage, 'immobilise') ||
      attributeAsBool(personnage, 'mortMaisNAbandonnePas'))
      dice = 12;
    else {
      var ebriete = attributeAsInt(personnage, 'niveauEbriete', 0);
      if (ebriete > 2) dice = 12;
      else if (ebriete > 1 && carac != 'CON') dice = 12;
    }
    return dice;
  }

  // Ne pas remplacer les inline rolls, il faut les afficher correctement
  function parseDmgDirects(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("cof-dmg prend les dégats en argument, avant les options",
        msg.content);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "pas de cible trouvée, action annulée");
        return;
      }
      var optArgs = msg.content.split(' --');
      options.aoe = true;
      optArgs.forEach(function(opt) {
        opt = opt.trim().split(' ');
        opt = opt.filter(function(c) {
          return c !== '';
        });
        switch (opt[0]) {
          case 'psave':
            var psaveopt = options;
            if (options.additionalDmg && opt.length > 3 && opt[3] == 'local') {
              var psavel = options.additionalDmg.length;
              if (psavel > 0) {
                psaveopt = options.additionalDmg[psavel - 1];
              }
            }
            var psaveParams = parseSave(opt);
            if (psaveParams) {
              psaveopt.partialSave = psaveParams;
            }
            return;
          case 'asphyxie':
          case 'affute':
          case "metal":
          case 'vampirise':
          case 'magique':
          case 'artificiel':
          case 'tranchant':
          case 'percant':
          case 'contondant':
          case 'tempDmg':
          case 'mortsVivants':
          case 'ignoreMoitieRD':
          case 'maxDmg':
          case 'sortilege':
            options[opt[0]] = true;
            return;
          case "feu":
          case "froid":
          case "acide":
          case "electrique":
          case "sonique":
          case "poison":
          case "maladie":
          case "argent":
            if (options.additionalDmg) {
              var l = options.additionalDmg.length;
              if (l > 0) {
                options.additionalDmg[l - 1].type = opt[0];
              } else {
                options.type = opt[0];
              }
            } else options.type = opt[0];
            return;
          case "nature":
          case "naturel":
            options.nature = true;
            return;
          case "ignoreRD":
            if (opt.length < 2) {
              options.ignoreTouteRD = true;
              return;
            }
            options.ignoreRD = parseInt(opt[1]);
            if (isNaN(options.ignoreRD) || options.ignoreRD < 1) {
              log("Pas un nombre positif après --ignoreRD, interprété comme ignore toute la RD");
              options.ignoreRD = undefined;
              options.ignoreTouteRD = true;
            }
            return;
          case 'attaquant':
            if (opt.length < 2) {
              error("Manque l'id de l'attaquant, option ignorée", optArgs);
              return;
            }
            var attaquant = persoOfId(opt[1]);
            if (attaquant) {
              options.attaquant = attaquant;
              return;
            }
            error("Attaquant non trouvé", opt);
            return;
          case 'titre':
            if (opt.length < 2) {
              error("Il manque le message après --message", cmd);
              return;
            }
            options.titre = opt.slice(1).join(' ');
            return;
        }
      });
      var cibles = [];
      iterSelected(selected, function(perso) {
        cibles.push(perso);
      });
      if (options.return) return;
      //L'expression à lancer est tout ce qui est entre le premier blanc et le premier --
      var debutDmgRollExpr = msg.content.indexOf(' ') + 1;
      var dmgRollExpr = msg.content.substring(debutDmgRollExpr);
      var finDmgRollExpr = msg.content.indexOf(' --');
      if (finDmgRollExpr > debutDmgRollExpr)
        dmgRollExpr = msg.content.substring(debutDmgRollExpr, finDmgRollExpr);
      else dmgRollExpr = msg.content.substring(debutDmgRollExpr);
      dmgRollExpr = dmgRollExpr.trim();
      var dmgType = options.type || 'normal';
      var dmg = {
        type: dmgType,
        value: dmgRollExpr
      };
      if (options.maxDmg) {
        dmgRollExpr = dmgRollExpr.replace(/d([1-9])/g, "*$1");
      }
      var playerName = msg.who;
      if (playerIsGM(playerId)) playerName = 'GM';
      dmgDirects(playerId, playerName, cibles, dmg, options);
    }, options); //fin du getSelected
  }

  function dmgDirects(playerId, playerName, cibles, dmg, options) {
    var evt;
    if (options.evt) {
      evt = options.evt;
    } else {
      evt = {
        type: 'dmgDirects'
      };
      addEvent(evt);
    }
    evt.action = {
      titre: "Dégâts",
      playerId: playerId,
      playerName: playerName,
      cibles: cibles,
      dmg: dmg,
      options: options
    };
    if (options.lanceur && limiteRessources(options.lanceur, options, 'dmg', 'dmg', evt)) return;
    var action = "<b>Dégâts.</b> ";
    if (options.titre) action += options.titre + "<br/>";
    if (options.partialSave) {
      action +=
        " Jet de " + options.partialSave.carac + " difficulté " + options.partialSave.seuil +
        " pour réduire les dégâts";
    }
    try {
      sendChat('', '[[' + dmg.value + ']]', function(resDmg) {
        dmg.roll = dmg.roll || resDmg[0];
        var afterEvaluateDmg = dmg.roll.content.split(' ');
        var dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
        dmg.total = dmg.roll.inlinerolls[dmgRollNumber].results.total;
        dmg.display = buildinline(dmg.roll.inlinerolls[dmgRollNumber], dmg.type, options.magique);
        var display = startFramedDisplay(playerId, action);
        var tokensToProcess = cibles.length;
        var someDmgDone;
        var finalDisplay = function() {
          if (tokensToProcess == 1) {
            if (someDmgDone) {
              sendChat("", endFramedDisplay(display));
            } else {
              sendPlayer(playerName, "Aucune cible valide n'a été sélectionée");
            }
          }
          tokensToProcess--;
        };
        cibles.forEach(function(perso) {
          if (getState(perso, 'mort')) { //pas de dégâts aux morts
            finalDisplay();
            return;
          }
          if (options.mortsVivants && !(estMortVivant(perso))) {
            sendPlayer(playerName, perso.token.get('name') + " n'est pas un mort-vivant");
            finalDisplay();
            return;
          }
          var name = perso.token.get('name');
          var explications = [];
          perso.ignoreRD = options.ignoreRD;
          perso.ignoreTouteRD = options.ignoreTouteRD;
          perso.ignoreMoitieRD = options.ignoreMoitieRD;
          perso.tempDmg = options.tempDmg;
          perso.attaquant = options.lanceur;
          dealDamage(perso, dmg, [], evt, false, options, explications, function(dmgDisplay, dmgFinal) {
            someDmgDone = true;
            addLineToFramedDisplay(display,
              name + " reçoit " + dmgDisplay + " DM");
            explications.forEach(function(e) {
              addLineToFramedDisplay(display, e, 80, false);
            });
            finalDisplay();
          });
        }); //fin forEach
      }); //fin du jet de dés
    } catch (rollError) {
      error("Jet " + dmg.value + " mal formé", dmg);
    }
  }

  function estElementaire(t) {
    if (t === undefined) return false;
    return (t == "feu" || t == "froid" || t == "acide" || t == "electrique");
  }

  function parseSetState(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-set-state", msg.content);
      return;
    }
    var etat = cmd[1];
    var valeur = cmd[2];
    if (valeur == "false" || valeur == "0") valeur = false;
    if (valeur == "true") valeur = true;
    if (!_.has(cof_states, etat)) {
      error("Le premier argument de !cof-set-state n'est pas un état valide", cmd);
      return;
    }
    if (isCarac(cmd[2])) {
      if (cmd.length < 4) {
        error("Il manque la difficulté du jet de sauvegarde.", cmd);
        return;
      }
      valeur = true;
      options.saveParTour = {
        carac: cmd[2]
      };
      var opposition = persoOfId(cmd[3]);
      if (opposition) {
        options.saveParTour.difficulte = cmd[3] + ' ' + opposition.token.get('name');
      } else {
        options.saveParTour.difficulte = parseInt(cmd[3]);
        if (isNaN(options.saveParTour.difficulte)) {
          error("Difficulté du jet de sauvegarde incorrecte", cmd);
          return;
        }
      }
    }
    var cibles = [];
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("Pas de cible pour le changement d'état", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        if (options.seulementVivant && estNonVivant(perso)) {
          sendPlayer(msg, "cet effet n'affecte que les créatures vivantes");
          return;
        }
        cibles.push(perso);
      });
    });
    doSetState(cibles, etat, valeur, options);
  }

  function doSetState(cibles, etat, valeur, options) {
    var evt = {
      type: "set_state",
      action: {
        titre: "Interface Set State",
        cibles: cibles,
        etat: etat,
        valeur: valeur,
        options: options
      }
    };
    addEvent(evt);
    var lanceur = options.lanceur;
    if (lanceur === undefined && cibles.length == 1) lanceur = persoOfId(cibles[0].token.id);
    if (limiteRessources(lanceur, options, etat, etat, evt)) return;
    if (options.messages) {
      options.messages.forEach(function(m) {
        if (lanceur) sendChar(lanceur.charId, m);
        else sendChat('', m);
      });
    }
    cibles.forEach(function(perso) {
      function setEffect() {
        setState(perso, etat, valeur, evt);
        if (options.saveParTour) {
          setTokenAttr(perso, etat + 'Save', options.saveParTour.carac, evt, {
            maxVal: options.saveParTour.difficulte
          });
        }
      }
      if (options.save) {
        var saveOpts = {
          msgPour: " pour résister à l'effet " + stringOfEtat(etat),
          msgRate: ", raté.",
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: options.type
        };
        var expliquer = function(s) {
          sendChar(perso.charId, s);
        };
        var saveId = 'effet_' + etat + '_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt, function(reussite, rollText) {
          if (!reussite) {
            setEffect();
          }
        });
      } else {
        setEffect();
      }
    });
  }

  function textOfSaveState(etat, perso) {
    switch (etat) {
      case 'immobilise':
        return "se libérer";
      case 'aveugle':
        return "retrouver la vue";
      case 'etourdi':
        return "reprendre ses esprits";
      case 'assome':
        return "reprendre conscience";
      case 'renverse':
        return "se relever";
      case 'endormi':
        return "se réveiller";
      case 'apeure':
        return "retrouver du courage";
      case 'enseveli':
        return "sortir de terre";
      default:
        return "ne plus être " + stringOfEtat(etat, perso);
    }
  }

  function parseSaveState(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 4 || !_.has(cof_states, cmd[1])) {
      error("Paramètres de !cof-save-state incorrects", cmd);
      return;
    }
    var etat = cmd[1];
    var carac = cmd[2];
    var carac2;
    if (!isCarac(carac) && carac.length == 6) {
      carac2 = carac.substring(3, 6);
      carac = carac.substring(0, 3);
      if (!isCarac(carac) || !isCarac(carac)) {
        error("Paramètres de !cof-save-state incorrects", cmd);
        return;
      }
    } else {
      error("Paramètres de !cof-save-state incorrects", cmd);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Pas de token sélectionné", msg.content);
        return;
      }
      var pageId = options.pageId;
      if (pageId === undefined) {
        iterSelected(selected, function(perso) {
          if (pageId) return;
          pageId = perso.token.get('pageid');
        });
      }
      var opposant = persoOfId(cmd[3], cmd[4], pageId);
      if (opposant) {
        iterSelected(selected, function(perso) {
          if (!getState(perso, etat)) {
            sendChar(perso.charId, "n'est pas " + stringOfEtat(etat, perso));
            return;
          }
          doSaveState(playerId, perso, etat, carac, options, opposant);
        });
      } else {
        var seuil = parseInt(cmd[3]);
        if (isNaN(seuil)) {
          error("La difficulté n'est pas un nombre", cmd);
          return;
        }
        iterSelected(selected, function(perso) {
          if (!getState(perso, etat)) {
            sendChar(perso.charId, "n'est pas " + stringOfEtat(etat, perso));
            return;
          }
          if (carac2) carac = meilleureCarac(carac, carac2, perso, seuil);
          doSaveState(playerId, perso, etat, carac, options, undefined, seuil);
        });
      }
    });
  }

  function doSaveState(playerId, perso, etat, carac, options, opposant, seuil) {
    var evt = {
      type: "save_state",
      action: {
        titre: "Interface Save State",
        perso: perso,
        etat: etat,
        carac: carac,
        options: options,
        opposant: opposant,
        seuil: seuil,
        playerId: playerId
      }
    };
    addEvent(evt);
    var titre = "Jet de " + carac + " pour " + textOfSaveState(etat, perso);
    if (opposant) {
      var display = startFramedDisplay(playerId, titre, perso, {
        perso2: opposant
      });
      var explications = [];
      var rollId = 'saveState_' + perso.token.id;
      testOppose(rollId, perso, carac, options, opposant, carac,
        options, explications, evt,
        function(resultat, crit, rt1, rt2) {
          if (resultat == 2) {
            explications.push(perso.token.get('name') + " est toujours " + stringOfEtat(etat, perso));
          } else {
            setState(perso, etat, false, evt);
            explications.push(perso.token.get('name') + " n'est plus " + stringOfEtat(etat, perso));
          }
          explications.forEach(function(e) {
            addLineToFramedDisplay(display, e);
          });
          sendChat("", endFramedDisplay(display));
        });
    } else {
      var testId = 'saveState_' + carac + seuil;
      testCaracteristique(perso, carac, seuil, testId, options, evt, function(res) {
        sendChar(perso.charId, titre);
        if (res.reussite) {
          setState(perso, etat, false, evt);
          sendChar(perso.charId, res.texte + " &ge; " + seuil + ", " + perso.token.get('name') + " n'est plus " + stringOfEtat(etat, perso) + res.modifiers);
        } else {
          sendChar(perso.charId, res.texte + " &lt; " + seuil + ", " + perso.token.get('name') + " est toujours " + stringOfEtat(etat, perso) + res.rerolls + res.modifiers);
        }
      });
    }
  }

  //Renvoie false si le personnage n'a pas d'attribut etatSave
  function boutonSaveState(perso, etat) {
    var attr = tokenAttribute(perso, etat + 'Save');
    if (attr.length === 0) return false;
    attr = attr[0];
    var carac = attr.get('current');
    var action = "!cof-save-state " + etat + ' ' + carac + ' ' + attr.get('max');
    if (etat == 'enseveli') action += " --bonus ?{Bonus au jet}";
    var b = bouton(action, "Jet", perso);
    return b + " pour " + textOfSaveState(etat, perso);
  }

  function updateInit(token, evt) {
    if (stateCOF.combat &&
      token.get('pageid') == stateCOF.combat_pageid)
      initiative([{
        _id: token.id
      }], evt, true);
  }

  function updateNextInit(perso) {
    updateNextInitSet.add(perso.token.id);
  }

  //renvoie le nom de l'arme si l'arme est déjà tenue en main
  function degainerArme(perso, labelArme, evt, options) {
    var pageId = perso.pageId;
    if (pageId === undefined) {
      pageId = perso.token.get('pageid');
      perso.pageId = pageId;
    }
    options = options || {};
    var nouvelleArme;
    if (options.weaponStats) nouvelleArme = options.weaponStats;
    else if (labelArme && labelArme !== '') nouvelleArme = getWeaponStats(perso, labelArme);
    if (nouvelleArme && nouvelleArme.armeGauche) options.gauche = true;
    //D'abord, on rengaine l'arme en main, si besoin.
    var armeActuelle = tokenAttribute(perso, 'armeEnMain');
    var labelArmeActuelle;
    var labelArmeActuelleGauche = '';
    var ancienneArme;
    var message = perso.token.get('name') + " ";
    if (armeActuelle.length > 0) {
      armeActuelle = armeActuelle[0];
      if (options.gauche) labelArmeActuelleGauche = armeActuelle.get('max');
      else {
        labelArmeActuelle = armeActuelle.get('current');
        labelArmeActuelleGauche = armeActuelle.get('max');
      }
      if (labelArmeActuelle == labelArme ||
        (options.gauche && labelArmeActuelleGauche == labelArme)) {
        //Pas besoin de dégainer. Pas de message ?
        if (options.weaponStats) return options.weaponStats.name;
        if (nouvelleArme) return nouvelleArme.name;
        return;
      }
      //On dégaine une nouvelle arme
      if (labelArmeActuelle) {
        ancienneArme = getWeaponStats(perso, labelArmeActuelle);
        if (attributeAsBool(perso, 'forgeron(' + labelArmeActuelle + ')')) {
          finDEffetDeNom(perso, 'forgeron(' + labelArmeActuelle + ')', evt);
        }
        if (ancienneArme.bonusDef) {
          var attrBonusDef = tokenAttribute(perso, 'armeBonusDef');
          if (attrBonusDef.length > 0) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(attrBonusDef[0]);
            attrBonusDef[0].remove();
          }
        }
        if (options.messages) message += "rengaine " + ancienneArme.name + " et ";
        else sendChar(perso.charId, "rengaine " + ancienneArme.name);
        if (charAttributeAsInt(perso, "initEnMain" + labelArmeActuelle, 0) > 0)
          updateNextInit(perso);
        if (charAttributeAsBool(perso, 'eclaire_' + labelArmeActuelle)) {
          eteindreUneLumiere(perso, pageId, undefined, 'eclaire_' + labelArmeActuelle, evt);
        }
      }
      if ((!nouvelleArme || nouvelleArme.deuxMains || options.gauche) &&
        labelArmeActuelleGauche) {
        var ancienneArmeGauche = getWeaponStats(perso, labelArmeActuelleGauche);
        if (attributeAsBool(perso, 'forgeron(' + labelArmeActuelleGauche + ')')) {
          finDEffetDeNom(perso, 'forgeron(' + labelArmeActuelleGauche + ')', evt);
        }
        if (ancienneArmeGauche.bonusDef) {
          var attrBonusDefGauche = tokenAttribute(perso, 'armeGaucheBonusDef');
          if (attrBonusDefGauche.length > 0) {
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(attrBonusDefGauche[0]);
            attrBonusDefGauche[0].remove();
          }
        }
        if (options.messages) {
          if (ancienneArme) message += ancienneArmeGauche.name + " et ";
          else message += "rengaine " + ancienneArmeGauche.name + " et ";
        } else sendChar(perso.charId, "rengaine " + ancienneArmeGauche.name);
        if (charAttributeAsBool(perso, 'eclaire_' + labelArmeActuelleGauche)) {
          eteindreUneLumiere(perso, pageId, undefined, 'eclaire_' + labelArmeActuelleGauche, evt);
        }
      }
    } else armeActuelle = undefined;
    //Puis on dégaine
    //mais on vérifie que l'arme existe, sinon c'est juste un ordre de rengainer
    if (nouvelleArme === undefined) {
      if (armeActuelle) {
        removeTokenAttr(perso, 'armeEnMain', evt);
        if (!stateCOF.combat) {
          //Si le perso a la capacité frappe du vide, la réinitialiser
          var attrFDV = tokenAttribute(perso, 'frappeDuVide');
          if (attrFDV.length > 0) {
            if (!attrFDV[0].get('current')) {
              evt.attributes = evt.attributes || [];
              evt.attributes.push({
                attribute: attrFDV[0],
                current: 0,
                max: 1
              });
              attrFDV[0].set('current', 1);
            }
          }
        }
      }
      return;
    }
    if (nouvelleArme.bonusDef) {
      if (nouvelleArme.armeGauche) {
        setTokenAttr(perso, 'armeGaucheBonusDef', nouvelleArme.bonusDef, evt);
      } else {
        setTokenAttr(perso, 'armeBonusDef', nouvelleArme.bonusDef, evt);
      }
    }
    if (nouvelleArme.deuxMains) {
      if (ficheAttributeAsBool(perso, 'DEFBOUCLIER', false) &&
        ficheAttributeAsInt(perso, 'DEFBOUCLIERON', 0)) {
        sendChar(perso.charId, "enlève son bouclier");
        var attrBouclier = findObjs({
          _type: 'attribute',
          _characterid: perso.charId,
          name: 'DEFBOUCLIERON'
        }, {
          caseInsensistive: true
        });
        evt.attributes = evt.attributes || [];
        if (attrBouclier.length > 0) {
          evt.attributes.push({
            attribute: attrBouclier[0],
            current: 1,
            max: ''
          });
          attrBouclier[0].set('current', 0);
        } else {
          attrBouclier = createObj('attribute', {
            characterid: perso.charId,
            name: 'DEFBOUCLIERON',
            current: 0
          });
          evt.attributes.push({
            attribute: attrBouclier,
            current: null
          });
        }
      }
    } else if (ancienneArme && (ancienneArme.deuxMains || options.gauche)) {
      if (ficheAttributeAsBool(perso, 'DEFBOUCLIER', false) &&
        !ficheAttributeAsInt(perso, 'DEFBOUCLIERON', 0)) {
        sendChar(perso.charId, "remet son bouclier");
        evt.attributes = evt.attributes || [];
        var attrBouclierOff = findObjs({
          _type: 'attribute',
          _characterid: perso.charId,
          name: 'DEFBOUCLIERON'
        }, {
          caseInsensistive: true
        }); //devrait être de taille au moins 1, avec valeur courante 0
        evt.attributes.push({
          attribute: attrBouclierOff[0],
          current: 0,
          max: ''
        });
        attrBouclierOff[0].set('current', 1);
      }
    }
    if (attributeAsBool(perso, 'frappeDuVide')) {
      if (options.contact) {
        options.frappeDuVide = true;
      }
      setTokenAttr(perso, 'frappeDuVide', 0, evt);
    }
    if (armeActuelle) {
      evt.attributes = evt.attributes || [];
      var evtAttr = {
        attribute: armeActuelle,
      };
      if (options.gauche) {
        evtAttr.current = armeActuelle.get('current');
        evtAttr.max = labelArmeActuelle;
        evt.attributes.push(evtAttr);
        armeActuelle.set('max', labelArme);
      } else {
        evtAttr.current = labelArmeActuelle;
        evtAttr.max = labelArmeActuelleGauche;
        evt.attributes.push(evtAttr);
        armeActuelle.set('current', labelArme);
      }
    } else {
      if (options.gauche) {
        setTokenAttr(perso, 'armeEnMain', '', evt, {
          maxVal: labelArme
        });
      } else {
        setTokenAttr(perso, 'armeEnMain', labelArme, evt);
      }
    }
    if (options.messages) {
      message += "dégaine " + nouvelleArme.name;
      options.messages.push(message);
    } else sendChar(perso.charId, "dégaine " + nouvelleArme.name);
    var eclaire = 'eclaire_' + labelArme;
    var attrEclaire = charAttribute(perso.charId, eclaire);
    if (attrEclaire.length > 0) {
      var radius = parseInt(attrEclaire[0].get('current'));
      if (isNaN(radius)) {
        error("Attribut " + eclaire + " mal formé", attrEclaire);
      } else {
        var dimRadius = parseInt(attrEclaire[0].get('max'));
        if (isNaN(dimRadius)) dimRadius = '';
        ajouteUneLumiere(perso, eclaire, radius, dimRadius, evt);
      }
    }
    if (charAttributeAsInt(perso, "initEnMain" + labelArme, 0) > 0)
      updateNextInit(perso);
  }

  function parseDegainer(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("commande non formée", msg.content);
      return;
    }
    var armeLabel = '';
    if (cmd.length > 1) armeLabel = cmd[1];
    if (cmd.length > 2 && cmd[2] == 'gauche') options.gauche = true;
    var personnages = [];
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("Qui doit dégainer ?", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        personnages.push(perso);
      });
    });
    doDegainer(personnages, armeLabel, options);
  }

  function doDegainer(persos, armeLabel, options) {
    var evt = {
      type: "degainer",
      attributes: [],
      action: {
        persos: persos,
        armeLabel: armeLabel,
        options: options
      }
    };
    addEvent(evt);
    if (options.son) playSound(options.son);
    persos.forEach(function(perso) {
      function afterSave() {
        var nomArme = degainerArme(perso, armeLabel, evt, options);
        if (nomArme) sendChar(perso.charId, "a déjà " + nomArme + " en main");
      }
      if (options.save) {
        var saveOpts = {
          msgPour: " pour garder son arme en main",
          msgRate: ", raté.",
          rolls: options.rolls,
          chanceRollId: options.chanceRollId
        };
        var expliquer = function(s) {
          sendChar(perso.charId, s);
        };
        var saveId = 'garderArme_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt, function(reussite, rollText) {
          if (!reussite) {
            afterSave();
          }
        });
      } else {
        afterSave();
      }
    });
  }

  function echangeInit(msg) {
    var args = msg.content.split(" ");
    if (args.length < 4) {
      error("Pas assez d'arguments pour !cof-echange-init: " + msg.content, args);
      return;
    }
    var perso1 = persoOfId(args[1], args[1]);
    if (perso1 === undefined) {
      error("le premier argument n'est pas un token valide", args[1]);
      return;
    }
    var perso2 = persoOfId(args[2], args[2]);
    if (perso2 === undefined) {
      error("le second argument n'est pas un token valide", args[2]);
      return;
    }
    var attackBonus = parseInt(args[3]);
    if (isNaN(attackBonus) || attackBonus < 1 || attackBonus > 2) {
      error("Le troisième argument n'est pas un nombre", args[3]);
      return;
    }
    var evt = {
      type: "echange_init"
    };
    var to = getTurnOrder(evt);
    var tourTok1 = to.pasAgi.findIndex(function(t) {
      return (t.id == perso1.token.id);
    });
    var tourTok2 = to.pasAgi.findIndex(function(t) {
      return (t.id == perso2.token.id);
    });
    if (tourTok1 < 0) {
      sendChar(perso1.charId, "a déjà agit, pas moyen d'échanger son initiative");
      return;
    }
    if (tourTok2 < 0) {
      sendChar(perso2.charId, "a déjà agit, pas moyen d'échanger son initiative");
      return;
    }
    var pr1 = to.pasAgi[tourTok1].pr;
    var pr2 = to.pasAgi[tourTok2].pr;
    if (pr1 == pr2) {
      sendChar(perso1.charId, "a la même initiative que " + perso2.token.get('name'));
      return;
    }
    if (pr1 > pr2) {
      setTokenAttr(perso1, 'actionConcertee', attackBonus, evt, {
        msg: "gagne un bonus de " + attackBonus + " à ses attaques et en DEF pour ce tour"
      });
      addEvent(evt);
    }
    to.pasAgi[tourTok1].pr = pr2;
    to.pasAgi[tourTok2].pr = pr1;
    var t1 = to.pasAgi[tourTok1];
    to.pasAgi[tourTok1] = to.pasAgi[tourTok2];
    to.pasAgi[tourTok2] = t1;
    updateNextInit(perso1);
    updateNextInit(perso2);
    to.pasAgi.push(to.tour);
    var turnOrder = to.pasAgi.concat(to.dejaAgi);
    Campaign().set('turnorder', JSON.stringify(turnOrder));
    addEvent(evt);
  }

  function aCouvert(msg) {
    var args = msg.content.split(" ");
    if (args.length < 2) {
      error("Pas assez d'arguments pour !cof-a-couvert: " + msg.content, args);
      return;
    }
    var perso1 = persoOfId(args[1], args[1]);
    if (perso1 === undefined) {
      error("Le premier argument n'est pas un token valide", args[1]);
      return;
    }
    var evt = {
      type: "aCouvert"
    };
    var init = getInit();
    var secret = args.some(function(arg) {
      return arg == '--secret';
    });
    setTokenAttr(perso1, 'aCouvert', 1, evt, {
      msg: "reste à couvert",
      maxVal: init,
      secret: secret
    });
    if (args.length > 2) {
      var perso2 = persoOfId(args[2], args[2]);
      if (perso2 === undefined) {
        error("Le second argument n'est pas un token valide", args[2]);
        addEvent(evt);
        return;
      }
      if (perso2.token.id == perso1.token.id) {
        if (secret) {
          whisperChar(perso1.charId, "s'est ciblé lui-même, il est donc le seul à couvert");
        } else {
          sendChar(perso1.charId, "s'est ciblé lui-même, il est donc le seul à couvert");
        }
        addEvent(evt);
        return;
      }
      var d = distanceCombat(perso1.token, perso2.token);
      if (d > 0) {
        if (secret) {
          whisperChar(perso2.charId, "est trop éloigné de " + perso1.token.get('name') + " pour rester à couvert avec lui");
        } else {
          sendChar(perso2.charId, "est trop éloigné de " + perso1.token.get('name') + " pour rester à couvert avec lui");
        }
      } else {
        setTokenAttr(perso2, 'aCouvert', 1, evt, {
          msg: "suit " + perso1.token.get('name') + " et reste à couvert",
          maxVal: init,
          secret: secret
        });
      }
    }
    addEvent(evt);
  }

  function getInit() {
    return stateCOF.init;
  }

  function parseEffetTemporaire(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-effet-temp", msg.content);
      return;
    }
    var effet = cmd[1];
    var lanceur = options.lanceur;
    var charId;
    if (lanceur) charId = lanceur.charId;
    if (cof_states[effet]) { //remplacer par sa version effet temporaire
      effet += 'Temp';
    }
    if (effet == 'forgeron' || effet == 'armeEnflammee') {
      //Compléter description de l'effet
      if (!lanceur) {
        error("Pas de lanceur pour forgeron ou armeEnflammee", msg.content);
        return;
      }
      var armeActuelle = tokenAttribute(lanceur, 'armeEnMain');
      if (armeActuelle.length === 0) {
        whisperChar(charId, "Pas d'arme en main, impossible de savoir quoi enflammer.");
        return;
      }
      var labelArme = armeActuelle[0].get('current');
      effet = effet + '(' + labelArme + ')';
    } else if (!estEffetTemp(effet)) {
      error(effet + " n'est pas un effet temporaire répertorié", msg.content);
      return;
    }
    if (!options.type && options.valeurMax && effet.startsWith('dotGen(')) {
      options.type = options.valeurMax;
    }
    var pp = effet.indexOf('(');
    var mEffet = (pp > 0) ? messageEffetTemp[effet.substring(effet, pp)] : messageEffetTemp[effet];
    if (mEffet === undefined) {
      error("Impossible de trouver l'effet " + effet, cmd);
      return;
    }
    var duree = parseInt(cmd[2]);
    if (isNaN(duree) || duree < 1) duree = 0; //On veut terminer l'effet
    if (options.puissantDuree || options.tempeteDeManaDuree) duree = duree * 2;
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendChar(charId, "Pas de cible sélectionée pour l'effet");
        return;
      }
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine de l'effet", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) {
            options.lanceur = lanceur;
            charId = lanceur.charId;
          }
        }
      }
      if (lanceur && options.tempeteDeMana) {
        if (options.tempeteDeMana.cout === 0) {
          //On demande de préciser les options
          var optMana = {
            mana: options.mana,
            dm: mEffet.dm,
            soins: mEffet.soins,
            portee: options.portee,
            duree: true,
            rang: options.rang,
            altruiste: options.altruiste
          };
          setTempeteDeMana(playerId, lanceur, msg.content, optMana);
          return;
        } else {
          if (options.rang && options.tempeteDeMana.cout > options.rang) {
            sendChar(charId, "Attention, le coût de la tempête de mana (" + options.tempeteDeMana.cout + ") est supérieur au rang du sort");
          }
          if (selected.length == 1 && options.tempeteDeMana.altruiste) {
            selected[0]._id = options.tempeteDeMana.altruiste.token.id;
            if (options.portee === undefined) options.portee = 0;
          }
        }
      }
      var cibles = [];
      iterSelected(selected, function(perso) {
        if (options.portee !== undefined) {
          if (options.puissantPortee || options.tempeteDeManaPortee) options.portee = options.portee * 2;
          var dist = distanceCombat(lanceur.token, perso.token);
          if (dist > options.portee) {
            sendChar(charId, " est trop loin de " + perso.token.get('name'));
            return;
          }
        }
        if ((mEffet.seulementVivant || options.seulementVivant) &&
          estNonVivant(perso)) {
          sendPlayer(msg, "cet effet n'affecte que les créatures vivantes");
          return;
        }
        if (charAttributeAsBool(perso, 'liberteDAction') &&
          (effet == 'confusion ' ||
            effet == 'charmé ' ||
            effet == 'prisonVegetale' ||
            effet == 'toiles' ||
            effet == 'foretVivanteEnnemie' ||
            ((options.magique || options.mana) &&
              (effet == 'apeureTemp' ||
                effet == 'endormiTemp' ||
                effet == 'etourdiTemp' ||
                effet == 'immobiliseTemp' ||
                effet == 'paralyseTemp' ||
                effet == 'ralentiTemp'))
          )) {
          sendChar(perso.charId, "reste libre de ses mouvements !");
          return;
        }
        cibles.push(perso);
      });
      if (cibles.length == 0) {
        //  sendChar(charId, "Aucune cible éligible sélectionnée");
        return;
      }
      effetTemporaire(playerId, cibles, effet, mEffet, duree, options);
    }, options);
  }

  function effetTemporaire(playerId, cibles, effet, mEffet, duree, options) {
    var evt = {
      type: 'effetTemp',
      action: {
        titre: "Effet Temporaire",
        playerId: playerId,
        cibles: cibles,
        effet: effet,
        mEffet: mEffet,
        duree: duree,
        options: options
      }
    };
    var lanceur = options.lanceur;
    var explications = options.messages || [];
    var whisper = '';
    if (options.secret) {
      var player;
      if (playerId) player = getObj('player', playerId);
      if (player !== undefined) {
        whisper = '/w "' + player.get('displayname') + '" ';
      }
    }
    addEvent(evt);
    if (limiteRessources(lanceur, options, effet, effet, evt)) return;
    entrerEnCombat(lanceur, cibles, explications, evt);
    explications.forEach(function(e) {
      sendChar('', e);
    });
    if (duree > 0) {
      var ef = {
        effet: effet,
        duree: duree,
        acumuleDuree: options.accumuleDuree,
        typeDmg: options.type,
        message: mEffet,
        valeur: options.valeur,
        valeurMax: options.valeurMax,
        saveParTour: options.saveParTour,
        whisper: whisper,
      };
      var setOneEffect = function(perso, d) {
        if (options.limiteCibleParJour) {
          var ressource = effet;
          if (options.limiteCibleParJourRessource)
            ressource = options.limiteCibleParJourRessource;
          ressource = "limiteParJour_" + ressource;
          var utilisations = attributeAsInt(perso, ressource, options.limiteCibleParJour);
          if (utilisations === 0) {
            sendChar(perso.charId, whisper + "ne peut plus bénéficier de " + effet + " aujourd'hui");
            return;
          }
          setTokenAttr(perso, ressource, utilisations - 1, evt);
        }
        setEffetTemporaire(perso, ef, d, options.lanceur, options.pageId, evt, options);
        if (effet.startsWith('forgeron(')) {
          //Il faut dégainer l'arme si elle n'est pas en main, et ajouter une lumière
          var labelArmeForgeron = effet.substring(9, effet.indexOf(')'));
          degainerArme(perso, labelArmeForgeron, evt);
          var feu = getValeurOfEffet(perso, effet, 1, 'voieDuMetal');
          ajouteUneLumiere(perso, effet, feu * 3, feu, evt);
        } else if (effet.startsWith('armeEnflammee(')) {
          var labelArmeEnflammee = effet.substring(14, effet.indexOf(')'));
          degainerArme(perso, labelArmeEnflammee, evt);
          ajouteUneLumiere(perso, effet, 9, 3, evt);
        }
        if (effet == 'cercleDeProtection') {
          var protecteur = options.lanceur || perso;
          if (!attributeAsBool(protecteur, 'cercleDeProtectionActif')) {
            setTokenAttr(protecteur, 'cercleDeProtectionActif', 1, evt, {
              maxVal: 1
            });
          }
        }
        if (effet == 'armeeDesMorts') {
          stateCOF.armeesDesMorts = stateCOF.armeesDesMorts || [];
          stateCOF.armeesDesMorts.push(perso.token.id);
        }
        if (options.puissant) {
          var puissant = true;
          if (options.puissant == "off") puissant = false;
          setTokenAttr(perso, effet + "Puissant", puissant, evt);
        }
        if (lanceur && options.fx) {
          var p1e = {
            x: lanceur.token.get('left'),
            y: lanceur.token.get('top'),
          };
          var p2e = {
            x: perso.token.get('left'),
            y: perso.token.get('top'),
          };
          spawnFxBetweenPoints(p1e, p2e, options.fx, options.pageId);
        }
        if (options.son) playSound(options.son);
        if (options.targetFx) {
          spawnFx(perso.token.get('left'), perso.token.get('top'), options.targetFx, options.pageId);
        }
      };
      cibles.forEach(function(perso) {
        if (options.type && immuniseAuType(perso, options.type, lanceur)) {
          sendChar(perso.charId, "ne semble pas affecté par " + stringOfType(options.type));
          return;
        }
        if (options.save) {
          var saveOpts = {
            msgPour: " pour résister à l'effet " + effet,
            msgRate: ", raté.",
            attaquant: lanceur,
            rolls: options.rolls,
            chanceRollId: options.chanceRollId,
            type: options.type
          };
          var expliquer = function(s) {
            sendChar(perso.charId, s);
          };
          var d = duree;
          var saveId = 'effet_' + effet + "_" + perso.token.id;
          save(options.save, perso, saveId, expliquer, saveOpts, evt,
            function(reussite, rollText) {
              if (reussite && options.save.demiDuree) {
                reussite = false;
                d = Math.ceil(d / 2);
              }
              if (!reussite) {
                setOneEffect(perso, d);
              }
            });
        } else {
          setOneEffect(perso, duree);
        }
      });
    } else { //On met fin à l'effet
      var opt = {
        pageId: options.pageId
      };
      cibles.forEach(function(perso) {
        var attr = tokenAttribute(perso, effet);
        if (attr.length === 0) {
          log(perso.token.get('name') + " n'a pas d'attribut " + effet);
          return;
        }
        finDEffet(attr[0], effetTempOfAttribute(attr[0]), attr[0].get('name'), perso.charId, evt, opt);
      });
    }
  }

  function effetCombat(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-effet-combat", msg.content);
      return;
    }
    var effet = cmd[1];
    if (!estEffetCombat(effet)) {
      error(effet + " n'est pas un effet de combat répertorié", msg.content);
      return;
    }
    var evt = {
      type: 'Effet ' + effet
    };
    var lanceur = options.lanceur;
    var charId;
    if (lanceur) charId = lanceur.charId;
    getSelected(msg, function(selected, playerId) {
      var whisper = '';
      if (options.secret) {
        var player;
        if (playerId) player = getObj('player', playerId);
        if (player !== undefined) {
          whisper = '/w "' + player.get('displayname') + '" ';
        }
      }
      if (selected === undefined || selected.length === 0) {
        sendChar(charId, whisper + "Pas de cible sélectionée pour l'effet");
        return;
      }
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine de l'effet", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) charId = lanceur.charId;
        }
      }
      if (lanceur && options.tempeteDeMana) {
        if (options.tempeteDeMana.cout === 0) {
          //On demande de préciser les options
          var optMana = {
            mana: options.mana,
            dm: messageEffetCombat[effet].dm,
            soins: messageEffetCombat[effet].soins,
            portee: options.portee,
            altruiste: options.altruiste,
            rang: options.rang
          };
          setTempeteDeMana(playerId, lanceur, msg.content, optMana);
          return;
        } else {
          if (options.rang && options.tempeteDeMana.cout > options.rang) {
            sendChar(lanceur.charId, whisper + "Attention, le coût de la tempête de mana (" + options.tempeteDeMana.cout + ") est supérieur au rang du sort");
          }
          if (selected.length == 1 && options.tempeteDeMana.altruiste) {
            selected[0]._id = options.tempeteDeMana.altruiste.token.id;
            if (options.portee === undefined) options.portee = 0;
          }
        }
      }
      if (options.portee !== undefined) {
        if (options.puissantPortee || options.tempeteDeManaPortee) options.portee = options.portee * 2;
        selected = selected.filter(function(sel) {
          var token = getObj('graphic', sel._id);
          var dist = distanceCombat(lanceur.token, token);
          if (dist > options.portee) {
            sendChar(charId, whisper + " est trop loin de " + token.get('name'));
            return false;
          }
          return true;
        });
      }
      if (selected.length === 0) return;
      if (limiteRessources(lanceur, options, effet, effet, evt)) {
        addEvent(evt);
        return;
      }
      initiative(selected, evt);
      var mEffet = messageEffetCombat[effet];
      var actMsg = mEffet.activation;
      var img = options.image;
      if (img !== "" && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
        var newLineimg = '<span style="padding: 4px 0;" >  ';
        newLineimg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
        newLineimg += '</span>';
        actMsg += newLineimg;
      }
      iterSelected(selected, function(perso) {
        var effetAttr = setTokenAttr(perso, effet, true, evt, {
          msg: whisper + actMsg
        });
        if (options.lanceur && options.mana !== undefined && mEffet.prejudiciable) {
          addEffetTemporaireLie(options.lanceur, effetAttr, evt);
        }
        if (options.puissant) {
          var puissant = true;
          if (options.puissant == "off") puissant = false;
          setTokenAttr(perso, effet + 'Puissant', puissant, evt);
        }
        if (options.valeur !== undefined) {
          setTokenAttr(perso, effet + 'Valeur', options.valeur, evt, {
            maxVal: options.valeurMax
          });
        }
        if (options.tempeteDeManaIntense !== undefined) {
          setTokenAttr(perso, effet + "TempeteDeManaIntense", options.tempeteDeManaIntense, evt);
        }
      });
      addEvent(evt);
      if (lanceur && options.fx) {
        iterSelected(selected, function(target) {
          var p1e = {
            x: lanceur.token.get('left'),
            y: lanceur.token.get('top'),
          };
          var p2e = {
            x: target.token.get('left'),
            y: target.token.get('top'),
          };
          spawnFxBetweenPoints(p1e, p2e, options.fx, options.pageId);
        });
      }
      if (options.son) playSound(options.son);
      if (options.targetFx) {
        iterSelected(selected, function(target) {
          spawnFx(target.token.get('left'), target.token.get('top'), options.targetFx, options.pageId);
        });
      }
    });
  }

  function effetIndetermine(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-effet", msg.content);
      return;
    }
    var effet = cmd[1];
    if (!estEffetIndetermine(effet)) {
      error(effet + " n'est pas un effet répertorié", msg.content);
      return;
    }
    var activer;
    switch (cmd[2]) {
      case 'oui':
      case 'Oui':
      case 'true':
        activer = true;
        break;
      case 'non':
      case 'Non':
      case 'false':
        activer = false;
        break;
      default:
        error("Option de !cof-effet inconnue", cmd);
        return;
    }
    var evt = {
      type: 'Effet ' + effet
    };
    var lanceur = options.lanceur;
    var charId;
    if (lanceur) charId = lanceur.charId;
    getSelected(msg, function(selected, playerId) {
      var whisper = '';
      if (options.secret) {
        var player;
        if (playerId) player = getObj('player', playerId);
        if (player !== undefined) {
          whisper = '/w "' + player.get('displayname') + '" ';
        }
      }
      if (selected === undefined || selected.length === 0) {
        sendChar(charId, whisper + "Pas de cible sélectionée pour l'effet");
        return;
      }
      if (lanceur === undefined) {
        if (options.portee) {
          error("Impossible de savoir l'origine de l'effet", options);
          return;
        }
        if (selected.length == 1) {
          lanceur = persoOfId(selected[0]._id);
          if (lanceur) charId = lanceur.charId;
        }
      }
      if (options.portee !== undefined) {
        selected = selected.filter(function(sel) {
          var token = getObj('graphic', sel._id);
          var dist = distanceCombat(lanceur.token, token);
          if (dist > options.portee) {
            sendChar(charId, whisper + " est trop loin de " + token.get('name'));
            return false;
          }
          return true;
        });
      }
      if (selected.length === 0) return;
      if (activer) {
        if (limiteRessources(lanceur, options, effet, effet, evt)) {
          addEvent(evt);
          return;
        }
        if (options.classeEffet) {
          selected = selected.filter(function(sel) {
            var perso = persoOfId(sel._id);
            if (perso === undefined) return false;
            if (attributeAsBool(perso, options.classeEffet)) {
              var attrDeClasse = attributesOfClass(perso, options.classeEffet);
              var mpc = "Non cumulable avec";
              attrDeClasse.forEach(function(attrClasseEffet) {
                var attr = attrClasseEffet.baseAttribute;
                var attrName = attr.get('name');
                if (estEffetIndetermine(attrName))
                  mpc += ' ' + messageEffetIndetermine[effetIndetermineOfAttribute(attr)].actif;
                else mpc += ' ' + attrName;
              });
              sendChar(perso.charId, whisper + mpc);
              return false;
            }
            setTokenAttr(perso, options.classeEffet, true, evt);
            setTokenAttr(perso, effet + 'ClasseEffet', options.classeEffet, evt);
            return true;
          });
        }
        iterSelected(selected, function(perso) {
          setTokenAttr(
            perso, effet, true, evt, {
              msg: whisper + messageEffetIndetermine[effet].activation
            });
          if (effet == 'foretVivanteEnnemie' && stateCOF.combat) {
            updateNextInit(perso);
          }
          if (options.puissant) {
            var puissant = true;
            if (options.puissant == "off") puissant = false;
            setTokenAttr(perso, effet + 'Puissant', puissant, evt);
          }
          if (options.valeur !== undefined) {
            setTokenAttr(perso, effet + 'Valeur', options.valeur, evt, {
              maxVal: options.valeurMax
            });
          }
          if (options.tempeteDeManaIntense !== undefined) {
            setTokenAttr(perso, effet + 'TempeteDeManaIntense', options.tempeteDeManaIntense, evt);
          }
        });
      } else {
        iterSelected(selected, function(perso) {
          //On commence par enlever les attributs de classe d'effet, si besoin
          var ace = tokenAttribute(perso, effet + 'ClasseEffet');
          if (ace.length > 0) {
            var ce = ace[0].get('current');
            removeTokenAttr(perso, ce, evt);
            evt.deletedAttributes = evt.deletedAttributes || [];
            evt.deletedAttributes.push(ace[0]);
            ace[0].remove();
          }
          removeTokenAttr(perso, effet, evt, {
            msg: messageEffetIndetermine[effet].fin
          });
          removeTokenAttr(perso, effet + 'Puissant', evt);
          removeTokenAttr(perso, effet + 'Valeur', evt);
          removeTokenAttr(perso, effet + 'TempeteDeManaIntense', evt);
          if (effet == 'foretVivanteEnnemie' && stateCOF.combat) {
            updateNextInit(perso);
          }
        });
      }
      addEvent(evt);
    });
  }

  function finClasseDEffet(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il manque l'argument de !cof-fin-classe-effet", cmd);
      return;
    }
    var classeEffet = cmd[1];
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("Pas de cible sélectionnée pour la fin d'une classe d'effets", msg);
        return;
      }
      var evt = {
        type: "Fin des effets de classe " + classeEffet,
        deletedAttributes: []
      };
      iterSelected(selected, function(perso) {
        if (attributeAsBool(perso, classeEffet)) {
          var attrDeClasse = attributesOfClass(perso, classeEffet);
          attrDeClasse.forEach(function(adc) {
            var attrName = adc.baseAttribute.get('name');
            if (estEffetIndetermine(attrName))
              sendChar(perso.charId, messageEffetIndetermine[effetIndetermineOfAttribute(adc.baseAttribute)].fin);
            evt.deletedAttributes.push(adc.baseAttribute);
            adc.baseAttribute.remove();
            evt.deletedAttributes.push(adc.classAttribute);
            adc.classAttribute.remove();
          });
          removeTokenAttr(perso, classeEffet, evt);
        }
      });
      addEvent(evt);
    }); //fin de getSelected
  }

  function peurOneToken(target, difficulte, duree, options, messages, evt, callback) {
    var targetName = target.token.get('name');
    if (charAttributeAsBool(target, 'sansPeur') ||
      charAttributeAsBool(target, 'immunitePeur') || //deprecated
      charAttributeAsBool(target, 'immunite_peur') ||
      charAttributeAsBool(target, 'proprioception') ||
      charAttributeAsBool(target, 'sansEsprit') ||
      attributeAsBool(target, 'enragé') ||
      charAttributeAsBool(target, 'liberteDAction')) {
      messages.push(targetName + " est insensible à la peur !");
      callback();
      return;
    }
    var carac = 'SAG'; //carac pour résister
    if (options.resisteAvecForce)
      carac = meilleureCarac('SAG', 'FOR', target, difficulte);
    //chercher si un partenaire a sansPeur pour appliquer le bonus
    var allieSansPeur = 0;
    var allies = alliesParPerso[target.charId];
    if (allies) {
      var pageId = options.pageId || target.token.get('pageid');
      var allTokens;
      allies.forEach(function(cid) {
        if (charIdAttributeAsBool(cid, 'sansPeur')) {
          //On cherche si l'allié est présent sur la même page
          allTokens = allTokens ||
            findObjs({
              _type: "graphic",
              _pageid: pageId,
              _subtype: "token",
              layer: "objects"
            });
          var alliePresent = allTokens.find(function(tok) {
            return tok.get('represents') == cid;
          });
          if (alliePresent)
            allieSansPeur = Math.max(allieSansPeur, 2 + modCarac(cid, 'charisme'));
        }
      });
    }
    var optionsPeur = {...options
    };
    optionsPeur.bonus = allieSansPeur;
    var testId = 'peurOne_' + target.token.id;
    testCaracteristique(target, carac, difficulte, testId, optionsPeur, evt,
      function(tr) {
        var line = "Jet de résistance de " + targetName + " :" + tr.texte;
        var sujet = onGenre(target, 'il', 'elle');
        if (tr.reussite) {
          line += "&gt;=" + difficulte + ",  " + sujet + " résiste à la peur." + tr.modifiers;
        } else {
          line += "&lt;" + difficulte + ", " + sujet + ' ';
          var effet = 'apeureTemp';
          var etat = 'apeure';
          if (options.etourdi) {
            line += "s'enfuit ou reste recroquevillé" + eForFemale(target) + " sur place";
            effet = 'peurEtourdi';
          } else if (options.ralenti) {
            line += "est ralenti" + eForFemale(target);
            effet = 'ralentiTemp';
            etat = 'ralenti';
          } else {
            line += "s'enfuit.";
          }
          line += tr.rerolls + tr.modifiers;
          setState(target, etat, true, evt);
          setAttrDuree(target, effet, duree, evt);
        }
        messages.push(line);
        callback();
      }); //fin testCaracteristique (asynchrone)
  }

  function parsePeur(msg) {
    var optArgs = msg.content.split(' --');
    var cmd = optArgs[0].split(' ');
    if (cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-peur", msg.content);
      return;
    }
    var playerId = getPlayerIdFromMsg(msg);
    var pageId = getPageId(playerId);
    var difficulte = parseInt(cmd[1]);
    if (isNaN(difficulte)) {
      error("Le premier argument de !cof-peur, la difficulté du test de résistance, n'est pas un nombre", cmd);
      return;
    }
    var duree = parseInt(cmd[2]);
    if (isNaN(duree) || duree < 0) {
      error("Le second argument de !cof-peur, la durée, n'est pas un nombre positif", cmd);
      return;
    }
    var options = {};
    options.playerId = playerId;
    options.pageId = pageId;
    optArgs.shift();
    optArgs.forEach(function(opt) {
      var optCmd = opt.split(' ');
      switch (optCmd[0]) {
        case "attaqueMagique":
          error("TODO", opt);
          return;
        case "resisteAvecForce":
        case "etourdi":
        case "ralenti":
        case "effroi":
          options[optCmd[0]] = true;
          return;
        case "portee":
          if (optCmd.length < 2) {
            error("Il manque l'argument de portée", optArgs);
            return;
          }
          options.portee = parseInt(optCmd[1]);
          if (isNaN(options.portee) || options.portee < 0) {
            error("La portée n'est pas un nombre positif", optCmd);
            delete options.portee;
          }
          return;
        case 'lanceur':
          if (optCmd.length < 2) {
            error("Il manque l'argument de lanceur", optArgs);
            return;
          }
          options.lanceur = persoOfId(optCmd[1], optCmd[1]);
          if (options.lanceur) pageId = options.lanceur.token.get('pageid');
          return;
        default:
          return;
      }
    });
    var cibles = [];
    getSelected(msg, function(selected) {
      if (selected === undefined || selected.length === 0) {
        error("Pas de cible sélectionnée pour la peur", msg);
        return;
      }
      iterSelected(selected, function(perso) {
        if (options.portee !== undefined && options.lanceur) {
          var distance = distanceCombat(options.lanceur.token, perso.token, pageId);
          if (distance > options.portee) {
            return;
          }
        }
        cibles.push(perso);
      });
    });
    if (cibles.length > 0) {
      doPeur(cibles, difficulte, duree, options);
    } else {
      error("Aucune cible valable à portée de l'effet de Peur", msg);
    }
  }

  function doPeur(cibles, difficulte, duree, options) {
    var evt = {
      type: 'peur',
      action: {
        cibles: cibles,
        difficulte: difficulte,
        duree: duree,
        options: options
      }
    };
    addEvent(evt);
    var action = "Effet de peur";
    if (options.lanceur) {
      action = "<b>" + options.lanceur.token.get('name') + "</b> ";
      if (options.effroi)
        action += "est vraiment effrayant" + eForFemale(options.lanceur);
      else action = "<b>Capacité</b> : Sort de peur";
    }
    var messages = [];
    entrerEnCombat(options.lanceur, cibles, messages, evt);
    var display = startFramedDisplay(options.playerId, action, options.lanceur);
    var counter = cibles.length;
    var finalDisplay = function() {
      if (counter == 1) {
        messages.forEach(function(message) {
          addLineToFramedDisplay(display, message);
        });
        sendChat("", endFramedDisplay(display));
      }
      counter--;
    };
    cibles.forEach(function(perso) {
      peurOneToken(perso, difficulte, duree, options, messages, evt, finalDisplay);
    });
  }

  function parseAttaqueMagique(msg, type) {
    var options = parseOptions(msg);
    if (options === undefined || options.cmd === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 3) {
      error("Il faut au moins 2 arguments à !cof-attaque-magique", cmd);
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    var cible = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined || cible === undefined) {
      error("Arguments de !cof-attaque-magique", cmd);
      return;
    }
    if (options.portee) {
      var distance = distanceCombat(attaquant.token, cible.token, options.pageId);
      if (distance > options.portee) {
        sendChar(attaquant.charId, "est trop loin de " + cible.token.get('name') +
          " pour l'attaque magique");
        return;
      }
    }
    type = type || "";
    switch (type) {
      case 'tueurFantasmagorique':
        tueurFantasmagorique(getPlayerIdFromMsg(msg), attaquant, cible, options);
        break;
      case 'injonction':
        injonction(getPlayerIdFromMsg(msg), attaquant, cible, options);
        break;
      default:
        attaqueMagiqueOpposee(getPlayerIdFromMsg(msg), attaquant, cible, options);
        break;
    }
  }

  // callback est seulement appelé si on fait le test
  // evt est facultatif ; si absent, en crée un nouveau générique et l'ajoute à l'historique
  function attaqueMagiqueOpposee(playerId, attaquant, cible, options, callback, evt) {
    if (options.attaqueMentale) {
      if (charAttributeAsBool(cible, 'sansEsprit')) {
        sendChar(attaquant.charId, " est sans esprit, " + onGenre(cible, 'il', 'elle') +
          " est immunisé" + onGenre(cible, '', 'e') + " aux attaques mentales.");
        return;
      } else if (charAttributeAsBool(cible, 'liberteDAction')) {
        sendChar(attaquant.charId, cible.token.get("name") + " reste libre de ses actions !");
        return;
      }
    }
    var explications = options.messages || [];
    if (!evt) {
      evt = {
        type: 'attaqueMagique',
        action: {
          titre: "Attaque magique",
          attaquant: attaquant,
          cible: cible,
          options: options
        }
      };
      addEvent(evt);
    } else if (!evt.action) {
      evt.action = {
        titre: "Attaque magique",
        attaquant: attaquant,
        cible: cible,
        options: options
      };
    }
    entrerEnCombat(attaquant, [cible], explications, evt);
    if (limiteRessources(attaquant, options, 'attaqueMagique', "l'attaque magique", evt)) {
      return;
    }
    var bonus1 = bonusDAttaque(attaquant, explications, evt);
    if (bonus1 === 0) bonus1 = "";
    else if (bonus1 > 0) bonus1 = " +" + bonus1;
    var attk1 = addOrigin(attaquant.token.get("name"), "[[" + computeArmeAtk(attaquant, '@{ATKMAG}') +
      bonus1 + "]]");
    var bonus2 = bonusDAttaque(cible, explications, evt);
    if (bonus2 === 0) bonus2 = "";
    else if (bonus2 > 0) bonus2 = " +" + bonus2;
    var attk2 = addOrigin(cible.token.get("name"), "[[" + computeArmeAtk(cible, '@{ATKMAG}') +
      bonus1 + "]]");
    var de1 = computeDice(attaquant);
    var de2 = computeDice(cible);
    var toEvaluate = "[[" + de1 + "]] [[" + de2 + "]] " + attk1 + " " + attk2;
    sendChat("", toEvaluate, function(res) {
      var rolls = res[0];
      options.rolls = options.rolls || {};
      // Determine which roll number correspond to which expression
      var afterEvaluate = rolls.content.split(" ");
      var att1RollNumber = rollNumber(afterEvaluate[0]);
      var att2RollNumber = rollNumber(afterEvaluate[1]);
      var attk1SkillNumber = rollNumber(afterEvaluate[2]);
      var attk2SkillNumber = rollNumber(afterEvaluate[3]);
      var roll1 = (options.rolls && options.rolls.roll1) ? options.rolls.roll1 : rolls.inlinerolls[att1RollNumber];
      var atk1 = (options.rolls && options.rolls.atk1) ? options.rolls.atk1 : rolls.inlinerolls[attk1SkillNumber];
      var roll2 = (options.rolls && options.rolls.roll2) ? options.rolls.roll2 : rolls.inlinerolls[att2RollNumber];
      var atk2 = (options.rolls && options.rolls.atk2) ? options.rolls.atk2 : rolls.inlinerolls[attk2SkillNumber];
      roll1.token = attaquant.token;
      atk1.token = attaquant.token;
      roll2.token = cible.token;
      atk2.token = cible.token;
      evt.action.rolls = evt.action.rolls || {};
      evt.action.rolls.roll1 = roll1;
      evt.action.rolls.atk1 = atk1;
      evt.action.rolls.roll2 = roll2;
      evt.action.rolls.atk2 = atk2;
      var d20roll1 = roll1.results.total;
      var att1Skill = atk1.results.total;
      if (estAffaibli(attaquant) && charAttributeAsBool(attaquant, 'insensibleAffaibli')) att1Skill -= 2;
      var attackRoll1 = d20roll1 + att1Skill;
      if (options.chanceRollId && options.chanceRollId.roll1)
        attackRoll1 += options.chanceRollId.roll1;
      var d20roll2 = roll2.results.total;
      var att2Skill = atk2.results.total;
      if (estAffaibli(cible) && charAttributeAsBool(cible, 'insensibleAffaibli')) att2Skill -= 2;
      var attackRoll2 = d20roll2 + att2Skill;
      if (options.chanceRollId && options.chanceRollId.roll2)
        attackRoll2 += options.chanceRollId.roll2;
      var action = "Attaque magique opposée";
      var reussi;
      if (d20roll1 == 1) {
        if (d20roll2 == 1) reussi = (attackRoll1 >= attackRoll2);
        else reussi = false;
      } else if (d20roll2 == 1) reussi = true;
      else if (d20roll1 == 20) {
        if (d20roll2 == 20) reussi = (attackRoll1 >= attackRoll2);
        else reussi = true;
      } else reussi = (attackRoll1 >= attackRoll2);
      var display = startFramedDisplay(playerId, action, attaquant, {
        perso2: cible
      });
      var line = attaquant.token.get('name') + " fait " + buildinline(roll1);
      if (att1Skill > 0) line += "+" + att1Skill;
      else if (att1Skill < 0) line += att1Skill;
      if (options.chanceRollId && options.chanceRollId.roll1)
        line += "+" + options.chanceRollId.roll1;
      line += " = " + attackRoll1;
      if (!reussi) {
        var pcAttaquant = pointsDeChance(attaquant);
        if (pcAttaquant > 0)
          line += "<br/>" + boutonSimple("!cof-bouton-chance " + evt.id + " roll1", "Chance") +
          " (reste " + pcAttaquant + " PC)";
        if (attributeAsInt(attaquant, 'pacteSanglant', 0) >= 3) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 roll1", "Pacte sanglant (+3)");
        }
        if (attributeAsInt(attaquant, 'pacteSanglant', 0) >= 5) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 roll1", "Pacte sanglant (+5)");
        }
      }
      addLineToFramedDisplay(display, line);
      line = cible.token.get('name') + " fait " + buildinline(roll2);
      if (att2Skill > 0) line += "+" + att2Skill;
      else if (att2Skill < 0) line += att2Skill;
      if (options.chanceRollId && options.chanceRollId.roll2)
        line += "+" + options.chanceRollId.roll2;
      line += " = " + attackRoll2;
      if (reussi) {
        var pcCible = pointsDeChance(cible);
        if (pcCible > 0)
          line += "<br/>" + boutonSimple("!cof-bouton-chance " + evt.id + " roll2", "Chance") +
          " (reste " + pcCible + " PC)";
        if (attributeAsInt(cible, 'pacteSanglant', 0) >= 3) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 3 roll2", "Pacte sanglant (+3)");
        }
        if (attributeAsInt(cible, 'pacteSanglant', 0) >= 5) {
          line += "<br/>" + boutonSimple("!cof-pacte-sanglant " + evt.id + " 5 roll2", "Pacte sanglant (+5)");
        }
      }
      addLineToFramedDisplay(display, line);
      if (reussi) {
        diminueMalediction(cible, evt);
        addLineToFramedDisplay(display, "<b>Attaque réussie !</b>");
      } else {
        diminueMalediction(attaquant, evt);
        addLineToFramedDisplay(display, "<b>L'attaque échoue.</b>");
      }
      explications.forEach(explication => addLineToFramedDisplay(display, explication, 80));
      if (callback) callback(display, reussi);
      else {
        sendChat("", endFramedDisplay(display));
      }
    });
  }

  function injonction(playerId, attaquant, cible, options) {
    options.attaqueMentale = true;
    var evt = {
      type: 'injonction',
      action: {
        titre: "Injonction",
        attaquant: attaquant,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    attaqueMagiqueOpposee(playerId, attaquant, cible, options,
      function(display, reussi) {
        if (reussi) {
          if (attributeAsBool(cible, 'resisteInjonction')) {
            addLineToFramedDisplay(display, cible.token.get('name') + " a déjà résisté à une injonction aujourd'hui, c'est sans effet");
          } else if (charAttributeAsBool(cible, 'liberteDAction')) {
            addLineToFramedDisplay(display, cible.token.get('name') + " reste libre de ses actions !");
          } else {
            addLineToFramedDisplay(display, cible.token.get('name') + " obéit à l'injonction");
          }
          sendChat("", endFramedDisplay(display));
        } else {
          setTokenAttr(cible, 'resisteInjonction', true, evt);
          addLineToFramedDisplay(display, cible.token.get('name') + " n'obéit pas à l'injonction");
          sendChat("", endFramedDisplay(display));
        }
      }, evt);
  }

  function tueurFantasmagorique(playerId, attaquant, cible, options) {
    var evt = {
      type: 'tueurFantasmagorique',
      action: {
        titre: "Tueur Fantasmagorique",
        attaquant: attaquant,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    attaqueMagiqueOpposee(playerId, attaquant, cible, options,
      function(display, reussi) {
        if (reussi) {
          if (estNonVivant(cible)) {
            addLineToFramedDisplay(display, cible.token.get('name') + " n'est pas une créature vivante, il ne peut croire à sa mort");
            sendChat("", endFramedDisplay(display));
            return;
          }
          if (attributeAsBool(cible, 'tueurFantasmagorique')) {
            addLineToFramedDisplay(display, cible.token.get('name') + " a déjà été victime d'un tueur fantasmagorique aujourd'hui, c'est sans effet");
            sendChat("", endFramedDisplay(display));
            return;
          }
          setTokenAttr(cible, 'tueurFantasmagorique', true, evt);
          var s = {
            carac: 'SAG',
            seuil: 10 + modCarac(attaquant, 'charisme')
          };
          var niveauAttaquant = ficheAttributeAsInt(attaquant, 'niveau', 1);
          var niveauCible = ficheAttributeAsInt(cible, 'niveau', 1);
          if (niveauCible > niveauAttaquant)
            s.seuil -= (niveauCible - niveauAttaquant) * 5;
          else if (niveauCible < niveauAttaquant)
            s.seuil += (niveauAttaquant - niveauCible);
          var expliquer = function(message) {
            addLineToFramedDisplay(display, message, 80);
          };
          var saveOpts = {
            msgPour: " pour résister au tueur fantasmagorique",
            attaquant: attaquant,
            rolls: options.rolls,
            chanceRollId: options.chanceRollId,
            type: 'magique'
          };
          var saveId = 'tueurFantasmagorique_' + cible.token.id;
          save(s, cible, saveId, expliquer, saveOpts, evt,
            function(reussiteSave, texte) {
              if (reussiteSave) {
                addLineToFramedDisplay(display, cible.token.get('name') + " perd l'équilibre et tombe par terre");
                setState(cible, 'renverse', true, evt);
              } else { //save raté
                addLineToFramedDisplay(display, cible.token.get('name') + " succombe à ses pires terreurs");
                updateCurrentBar(cible, 1, 0, evt);
                setState(cible, 'mort', true, evt);
              }
              sendChat("", endFramedDisplay(display));
            });
        } else {
          setTokenAttr(cible, 'tueurFantasmagorique', true, evt);
          sendChat("", endFramedDisplay(display));
        }
      }, evt);
  }

  function parseInjonctionMortelle(msg) {
    var options = parseOptions(msg);
    if (options === undefined || options.cmd === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 3) {
      error("Il faut au moins 2 arguments à !cof-injonction-mortelle", cmd);
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    var cible = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined || cible === undefined) {
      error("Arguments de !cof-injonction-mortelle", cmd);
      return;
    }
    var distance = distanceCombat(attaquant.token, cible.token, options.pageId);
    if (distance > 30) {
      sendChar(attaquant.charId, "est trop loin de " + cible.token.get('name') +
        " pour l'injonction mortelle");
      return;
    }
    injonctionMortelle(getPlayerIdFromMsg(msg), attaquant, cible, options);
  }

  function injonctionMortelle(playerId, attaquant, cible, options) {
    var evt = {
      type: 'injonctionMortelle',
      action: {
        titre: "Injonction Mortelle",
        playerId: playerId,
        attaquant: attaquant,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    var explications = options.messages || [];
    entrerEnCombat(attaquant, [cible], explications, evt);
    var display = startFramedDisplay(playerId, evt.action.titre, attaquant, {
      perso2: cible
    });
    explications.forEach(msg => addLineToFramedDisplay(display, msg, 80));
    if (attributeAsBool(cible, 'injonctionMortelle')) {
      addLineToFramedDisplay(display, cible.token.get('name') + " a déjà été victime d'une injonction mortelle ce combat, c'est sans effet");
      sendChat("", endFramedDisplay(display));
      return;
    }
    if (charAttributeAsBool(cible, 'liberteDAction')) {
      addLineToFramedDisplay(display, cible.token.get('name') + " reste libre de ses actions !");
      sendChat("", endFramedDisplay(display));
      return;
    }
    setTokenAttr(cible, 'injonctionMortelle', true, evt);
    var saveOpts = {
      msgPour: " pour résister à l'injonction mortelle",
      msgRate: ", raté.",
      attaquant: attaquant,
      rolls: options.rolls,
      chanceRollId: options.chanceRollId
    };
    var saveId = 'injonctionMortelle_' + cible.token.id;
    var expliquer = function(message) {
      addLineToFramedDisplay(display, message, 80);
    };
    save({
        carac: 'CON',
        seuil: 15,
        type: 'magique'
      }, cible, saveId, expliquer, saveOpts, evt,
      function(reussite, rollText) {
        if (reussite) {
          var nc = attributeAsInt(attaquant, "niveau", 0);
          var dmg = {
            type: 'normal',
            value: '2d6+' + nc
          };
          sendChat('', '[[' + dmg.value + ']]', function(resDmg) {
            dmg.roll = dmg.roll || resDmg[0];
            var afterEvaluateDmg = dmg.roll.content.split(' ');
            var dmgRollNumber = rollNumber(afterEvaluateDmg[0]);
            dmg.total = dmg.roll.inlinerolls[dmgRollNumber].results.total;
            dmg.display = buildinline(dmg.roll.inlinerolls[dmgRollNumber], dmg.type, options.magique);
            var name = cible.token.get('name');
            var explicationsDmg = [];
            cible.attaquant = attaquant;
            dealDamage(cible, dmg, [], evt, false, options, explicationsDmg, function(dmgDisplay, dmgFinal) {
              addLineToFramedDisplay(display,
                name + " reçoit " + dmgDisplay + " DM");
              explicationsDmg.forEach(function(e) {
                addLineToFramedDisplay(display, e, 80, false);
              });
              sendChat("", endFramedDisplay(display));
            });
          });
        } else {
          addLineToFramedDisplay(display, cible.token.get('name') + " meurt sous l'injonction mortelle !", 80);
          updateCurrentBar(cible, 1, 0, evt);
          setState(cible, 'mort', true, evt);
          sendChat("", endFramedDisplay(display));
        }
      });
  }

  function parseSommeil(msg) { //sort de sommeil
    var options = parseOptions(msg);
    if (options === undefined) return;
    var args = options.cmd;
    if (args.length < 2) {
      error("La fonction !cof-sommeil a besoin du nom ou de l'id du lanceur de sort", args);
      return;
    }
    var lanceur = persoOfId(args[1], args[1]);
    if (lanceur === undefined) {
      error("Aucun personnage nommé " + args[1], args);
      return;
    }
    var casterCharId = lanceur.charId;
    var casterChar = getObj('character', casterCharId);
    if (casterChar === undefined) {
      error("Fiche de personnage manquante");
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible sélectionnée pour le sort de sommeil");
        return;
      }
      var cibles = [];
      iterSelected(selected, function(perso) {
        cibles.push(perso);
      });
      doSommeil(lanceur, cibles, options);
    }, {
      lanceur: lanceur
    });
  }

  function doSommeil(lanceur, cibles, options, ciblesSansSave, ciblesAvecSave) {
    var evt = {
      type: 'sommeil',
      action: {
        lanceur: lanceur,
        cibles: cibles,
        ciblesSansSave: ciblesSansSave,
        ciblesAvecSave: ciblesAvecSave,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'sommeil', "lancer un sort de sommeil", evt)) return;
    var casterCharName = lanceur.token.get("name");
    var cha = modCarac(lanceur, 'charisme');
    var attMagText = addOrigin(casterCharName, '[[' + computeArmeAtk(lanceur, '@{ATKMAG}') + ']]');
    sendChat("", "[[1d6]] [[" + attMagText + "]]", function(res) {
      evt.action.rolls = options.rolls || {};
      var rollD6Id = 'sommeilD6';
      var rolls = res[0];
      var afterEvaluate = rolls.content.split(" ");
      var d6RollNumber = rollNumber(afterEvaluate[0]);
      var attMagRollNumber = rollNumber(afterEvaluate[1]);
      var rollD6 = evt.action.rolls[rollD6Id] || rolls.inlinerolls[d6RollNumber];
      evt.action.rolls[rollD6Id] = rollD6;
      var nbTargetsMax = rollD6.results.total + cha;
      var action = "<b>Capacité</b> : Sort de sommeil (max " + nbTargetsMax + " cibles)";
      var display = startFramedDisplay(options.playerId, action, lanceur);
      var attMag = rolls.inlinerolls[attMagRollNumber].results.total;
      var targetsWithSave = [];
      var targetsWithoutSave = [];
      cibles.forEach(function(perso) {
        perso.name = perso.token.get('name');
        if (estNonVivant(perso) || charAttributeAsBool(perso, 'immunite_endormi')) { //le sort de sommeil n'affecte que les créatures vivantes
          addLineToFramedDisplay(display, perso.name + " n'est pas affecté par le sommeil");
          return;
        }
        if (charAttributeAsBool(perso, "liberteDAction")) {
          addLineToFramedDisplay(display, perso.name + " reste libre de ses mouvements !");
          return;
        }
        var pv = perso.token.get('bar1_max');
        if (pv > 2 * attMag) {
          var line = perso.name + " a trop de PV pour être affecté par le sort";
          addLineToFramedDisplay(display, line);
        } else if (pv > attMag) {
          targetsWithSave.push(perso);
        } else {
          targetsWithoutSave.push(perso);
        }
      });
      var ciblesSansSave;
      if (evt.action.ciblesSansSave) {
        ciblesSansSave = evt.action.ciblesSansSave;
        nbTargetsMax -= ciblesSansSave.length;
      } else {
        ciblesSansSave = [];
        var i, r;
        if (targetsWithoutSave.length > nbTargetsMax) {
          i = 0; //position to decide
          while (nbTargetsMax > 0) {
            r = randomInteger(nbTargetsMax) + i;
            ciblesSansSave.push(targetsWithoutSave[r]);
            targetsWithoutSave[r] = targetsWithoutSave[i];
            i++;
            nbTargetsMax--;
          }
        } else {
          ciblesSansSave = targetsWithoutSave;
          nbTargetsMax -= ciblesSansSave.length;
        }
      }
      evt.action.ciblesSansSave = ciblesSansSave;
      ciblesSansSave.forEach(function(t) {
        setState(t, 'endormi', true, evt);
        addLineToFramedDisplay(display, t.name + " s'endort");
      });
      if (nbTargetsMax > 0 && targetsWithSave.length > 0) {
        var ciblesAvecSave;
        if (evt.action.ciblesAvecSave) {
          ciblesAvecSave = evt.action.ciblesAvecSave;
          nbTargetsMax -= ciblesAvecSave.length;
        } else {
          ciblesAvecSave = [];
          if (targetsWithSave.length > nbTargetsMax) {
            var j = 0;
            while (nbTargetsMax > 0) {
              var ra = randomInteger(nbTargetsMax) + j;
              ciblesAvecSave.push(targetsWithSave[ra]);
              targetsWithSave[ra] = targetsWithSave[j];
              j++;
              nbTargetsMax--;
            }
          } else {
            ciblesAvecSave = targetsWithSave;
            nbTargetsMax -= ciblesAvecSave.length;
          }
        }
        var seuil = 10 + cha;
        var tokensToProcess = ciblesAvecSave.length;
        var finalize = function() {
          if (tokensToProcess == 1) {
            sendChat("", endFramedDisplay(display));
          }
          tokensToProcess--;
        };
        evt.action.ciblesAvecSave = ciblesAvecSave;
        ciblesAvecSave.forEach(function(perso) {
          var testId = 'resisteSommeil_' + perso.token.id;
          testCaracteristique(perso, 'SAG', seuil, testId, options, evt,
            function(tr) {
              var line = "Jet de résistance de " + perso.name + ": " + tr.texte;
              var sujet = onGenre(perso, 'il', 'elle');
              if (tr.reussite) {
                line += "&gt;=" + seuil + ",  " + sujet + " ne s'endort pas." + tr.modifiers;
              } else {
                setState(perso, 'endormi', true, evt);
                line += "&lt;" + seuil + ", " + sujet + " s'endort" + tr.rerolls + tr.modifiers;
              }
              addLineToFramedDisplay(display, line);
              finalize();
            });
        });
      } else { // all targets are without save
        sendChat("", endFramedDisplay(display));
      }
    });
  }

  //!cof-attaque-magique-contre-pv {selected|token_id} {target|token_id}
  function attaqueMagiqueContrePV(msg) {
    var options = parseOptions(msg);
    if (options === undefined || options.cmd === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 3) {
      error("Il faut au moins 2 arguments à !cof-attaque-magique-contre-pv", cmd);
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    var cible = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined || cible === undefined) {
      error("Arguments de !cof-attaque-magique-contre-pv incorrects", cmd);
      return;
    }
    if (options.portee !== undefined) {
      var distance = distanceCombat(attaquant.token, cible.token, options.pageId);
      if (distance > options.portee) {
        sendChar(attaquant.charId, "est trop loin de " + cible.token.get('name') +
          " pour l'attaque magique");
        return;
      }
    }
    var pvMax = parseInt(cible.token.get('bar1_max'));
    if (isNaN(pvMax)) {
      error("Token avec des PV max qui ne sont pas un nombre", cible.token);
      return;
    }
    var evt = {
      type: 'Attaque magique',
    };
    addEvent(evt);
    if (limiteRessources(attaquant, options, 'attaque magique', "l'attaque magique", evt)) return;
    var attaquantChar = getObj('character', attaquant.charId);
    if (attaquantChar === undefined) {
      error("Fiche de l'attaquant introuvable");
      return;
    }
    attaquant.tokName = attaquant.token.get('name');
    attaquant.name = attaquantChar.get('name');
    var playerId = options.playerId || getPlayerIdFromMsg(msg);
    var explications = [];
    var bonusA = bonusDAttaque(attaquant, explications, evt);
    if (bonusA === 0) bonusA = "";
    else if (bonusA > 0) bonusA = " +" + bonusA;
    var attMagText = addOrigin(attaquant.name, "[[" + computeArmeAtk(attaquant, '@{ATKMAG}') + bonusA + "]]");
    var de = computeDice(attaquant);
    var action = "<b>Attaque magique</b> (contre pv max)";
    var display = startFramedDisplay(playerId, action, attaquant, {
      perso2: cible
    });
    sendChat("", "[[" + de + "]] " + attMagText, function(res) {
      var rolls = res[0];
      var afterEvaluate = rolls.content.split(" ");
      var attRollNumber = rollNumber(afterEvaluate[0]);
      var attSkillNumber = rollNumber(afterEvaluate[1]);
      var d20roll = rolls.inlinerolls[attRollNumber].results.total;
      var attSkill = rolls.inlinerolls[attSkillNumber].results.total;
      if (estAffaibli(attaquant) && charAttributeAsBool(attaquant, 'insensibleAffaibli')) attSkill -= 2;
      var attackRoll = d20roll + attSkill;
      var line =
        attaquant.tokName + " fait " +
        buildinline(rolls.inlinerolls[attRollNumber]);
      if (attSkill > 0) line += "+" + attSkill + " = " + attackRoll;
      else if (attSkill < 0) line += attSkill + " = " + attackRoll;
      addLineToFramedDisplay(display, line);
      var reussi;
      if (d20roll == 1) reussi = false;
      else if (d20roll == 20) reussi = true;
      else reussi = (attackRoll >= pvMax);
      if (reussi) {
        addLineToFramedDisplay(display, "<b>Attaque réussie !</b>");
      } else {
        diminueMalediction(attaquant, evt);
        addLineToFramedDisplay(display, "<b>L'attaque échoue.</b>");
      }
      sendChat("", endFramedDisplay(display));
    }); //Fin du jet de dés pour l'attaque
  }

  function transeGuerison(msg) {
    if (stateCOF.combat) {
      sendPlayer(msg, "Pas possible de méditer en combat");
      return;
    }
    var options = parseOptions(msg);
    if (options === undefined) return;
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "Pas de cible sélectionnée pour la transe de guérison");
        return;
      }
      var evt = {
        type: "Transe de guérison",
      };
      iterSelected(selected, function(perso) {
        var token = perso.token;
        if (attributeAsBool(perso, 'transeDeGuérison')) {
          sendChar(perso.charId, "a déjà médité depuis le dernier combat");
          return;
        }
        var bar1 = parseInt(token.get("bar1_value"));
        var pvmax = parseInt(token.get("bar1_max"));
        if (isNaN(bar1) || isNaN(pvmax)) return;
        if (bar1 >= pvmax) {
          sendChar(perso.charId, "n'a pas besoin de méditer");
          return;
        }
        var sagMod = modCarac(perso, 'sagesse');
        var niveau = ficheAttributeAsInt(perso, 'niveau', 1);
        var soin = niveau + sagMod;
        if (soin < 0) soin = 0;
        if (bar1 === 0) {
          if (attributeAsBool(perso, 'etatExsangue')) {
            removeTokenAttr(perso, 'etatExsangue', evt, {
              msg: "retrouve des couleurs"
            });
          }
        }
        bar1 += soin;
        if (bar1 > pvmax) {
          soin -= (bar1 - pvmax);
          bar1 = pvmax;
        }
        updateCurrentBar(perso, 1, bar1, evt);
        setTokenAttr(perso, 'transeDeGuérison', true, evt);
        sendChar(perso.charId, "entre en méditation pendant 10 minutes et récupère " + soin + " points de vie.");
      });
      addEvent(evt);
    });
  }

  function raceIs(perso, race) {
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    return (perso.race == race.toLowerCase());
  }

  function estFee(perso) {
    if (charAttributeAsBool(perso, 'fée')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'licorne':
      case 'fee':
      case 'fée':
      case 'pixie':
      case 'lutin':
        return true;
      default:
        return false;
    }
  }

  function estDemon(perso) {
    if (charAttributeAsBool(perso, 'démon')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'démon':
      case 'demon':
      case 'balor':
      case 'marilith':
      case 'quasit':
      case 'succube':
        return true;
      default:
        return false;
    }
  }

  function estMortVivant(perso) {
    if (charAttributeAsBool(perso, 'mortVivant')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'squelette':
      case 'zombie':
      case 'mort-vivant':
      case 'momie':
      case 'goule':
      case 'vampire':
        return true;
      default:
        return false;
    }
  }

  function estNonVivant(perso) {
    return (charAttributeAsBool(perso, 'nonVivant') ||
      attributeAsBool(perso, 'masqueMortuaire') || estMortVivant(perso));
  }

  function estUnGeant(perso) {
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'géant':
      case 'geant':
      case 'ogre':
      case 'ettin':
      case 'cyclope':
        return true;
      default:
        return false;
    }
  }

  function estElfeNoir(perso) {
    if (charAttributeAsBool(perso, 'elfeNoir')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    if (perso.race.includes('elf') && perso.race.includes('noir')) return true;
    switch (perso.race) {
      case 'drider':
        return true;
      default:
        return false;
    }
  }

  //Vrai pour les insectes et araignées
  function estInsecte(perso) {
    if (charAttributeAsBool(perso, 'insecte')) return true;
    if (perso.profil === undefined) {
      perso.profil = ficheAttribute(perso, 'profil', '');
      perso.profil = perso.profil.toLowerCase();
    }
    if (perso.profil == 'insecte') return true;
    if (perso.profil == 'araignée') return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    if (perso.race.includes('elf') && perso.race.includes('noir')) return true;
    switch (perso.race) {
      case 'ankheg':
      case 'araignée':
      case 'araignee':
      case 'insecte':
        return true;
      default:
        return false;
    }
  }

  function estHumanoide(perso) {
    if (charAttributeAsBool(perso, 'humanoide')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'humain':
      case 'nain':
      case 'elfe':
      case 'elfe des bois':
      case 'elfe noir':
      case 'drow':
      case 'halfelin':
      case 'géant':
      case 'geant':
      case 'ange':
      case 'barghest':
      case 'démon':
      case 'doppleganger':
      case 'dryade':
      case 'gnoll':
      case 'gobelin':
      case 'gobelours':
      case 'hobegobelin':
      case 'homme-lézard':
      case 'kobold':
      case 'nymphe':
      case 'ogre':
      case 'orque':
      case 'pixie':
      case 'troll':
        return true;
      default:
        return false;
    }
  }

  function estQuadrupede(perso) {
    if (charAttributeAsBool(perso, 'quadrupede')) return true;
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.toLowerCase();
    }
    if (perso.race === '') return false;
    switch (perso.race) {
      case 'ankheg':
      case 'araignée':
      case 'araignee':
      case 'basilic':
      case 'béhir':
      case 'behir':
      case 'bulette':
      case 'bison':
      case 'centaure':
      case 'cheval':
      case 'chien':
      case 'chimère':
      case 'chimere':
      case 'cockatrice':
      case 'crocodile':
      case 'dragon':
      case 'drider':
      case 'eléphant':
      case 'elephant':
      case 'éléphant':
      case 'mammouth':
      case 'griffon':
      case 'hipogriffe':
      case 'hippogriffe':
      case 'hydre':
      case 'licorne':
      case 'lion':
      case 'loup':
      case 'worg':
      case 'manticore':
      case 'ours':
      case 'panthere':
      case 'panthère':
      case 'pegase':
      case 'pégase':
      case 'pieuvre':
      case 'rat':
      case 'rhinoceros':
      case 'rhinocéros':
      case 'sanglier':
      case 'taureau':
      case 'tigre':
        return true;
      default:
        return false;
    }
  }

  function estAnimal(perso) {
    if (charAttributeAsBool(perso, 'animal')) return true;
    var attr = findObjs({
      _type: 'attribute',
      _characterid: perso.charId,
    });
    var attrProfile = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'PROFIL';
    });
    if (attrProfile.length > 0) {
      if (attrProfile[0].get('current').trim().toLowerCase() == 'animal')
        return true;
    }
    var attrRace = attr.filter(function(a) {
      return a.get('name').toUpperCase() == 'RACE';
    });
    if (attrRace.length === 0) return false;
    var charRace = attrRace[0].get('current').trim().toLowerCase();
    switch (charRace) {
      case 'animal':
      case 'aigle':
      case 'basilic':
      case 'bulette':
      case 'bison':
      case 'calmar':
      case 'chauve-souris':
      case 'cheval':
      case 'chien':
      case 'crocodile':
      case 'dinosaure':
      case 'éléphant':
      case 'eléphant':
      case 'elephant':
      case 'gorille':
      case 'griffon':
      case 'hipogriffe':
      case 'hydre':
      case 'lion':
      case 'loup':
      case 'mammouth':
      case 'manticore':
      case 'ours':
      case 'ours-hibou':
      case 'panthère':
      case 'pegase':
      case 'pégase':
      case 'pieuvre':
      case 'rhinocéros':
      case 'roc':
      case 'sanglier':
      case 'serpent':
      case 'rat':
      case 'taureau':
      case 'tigre':
      case 'wiverne':
        return true;
      default:
        return false;
    }
  }

  function estMauvais(perso) {
    if (charAttributeAsBool(perso, 'mauvais')) return true;
    if (estDemon(perso)) return true; //remplit perso.race
    switch (perso.race) {
      case 'squelette':
      case 'zombie':
      case 'élémentaire':
      case 'momie':
        return true;
      default:
        return false;
    }
  }

  //Retourne un encodage des tailes :
  // 1 : minuscule
  // 2 : très petit
  // 3 : petit
  // 4 : moyen
  // 5 : grand
  // 6 : énorme
  // 7 : colossal
  function taillePersonnage(perso, def) {
    if (perso.taille) return perso.taille;
    switch (ficheAttribute(perso, 'taille', '').trim().toLowerCase()) {
      case "minuscule":
        perso.taille = 1;
        return 1;
      case "très petit":
      case "très petite":
      case "tres petit":
        perso.taille = 2;
        return 2;
      case "petit":
      case "petite":
        perso.taille = 3;
        return 3;
      case "moyen":
      case "moyenne":
      case "normal":
      case "normale":
        perso.taille = 4;
        return 4;
      case "grand":
      case "grande":
        perso.taille = 5;
        return 5;
      case "énorme":
      case "enorme":
        perso.taille = 6;
        return 6;
      case "colossal":
      case "colossale":
        perso.taille = 7;
        return 7;
      default: //On passe à la méthode suivante
    }
    if (perso.race === undefined) {
      perso.race = ficheAttribute(perso, 'race', '');
      perso.race = perso.race.trim().toLowerCase();
    }
    switch (perso.race) {
      case 'lutin':
      case 'fee':
        perso.taille = 2;
        return 2;
      case 'halfelin':
      case 'gobelin':
      case 'kobold':
        perso.taille = 3;
        return 3;
      case 'humain':
      case 'elfe':
      case 'nain':
      case 'demi-elfe':
      case 'demi-orque':
      case 'orque':
      case 'gnome':
      case 'âme-forgée':
        perso.taille = 4;
        return 4;
      case 'centaure':
      case 'demi-ogre':
      case 'ogre':
      case 'minotaure':
        perso.taille = 5;
        return 5;
    }
    perso.taille = def;
    return def;
  }

  function estAussiGrandQue(perso1, perso2) {
    var t1 = taillePersonnage(perso1);
    var t2 = taillePersonnage(perso2);
    if (t1 === undefined || t2 === undefined) return true;
    return t1 >= t2;
  }

  function soigner(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 2) {
      error("Il faut au moins un argument à !cof-soin", cmd);
      return;
    }
    var soigneur = options.lanceur;
    var pageId = options.pageId;
    var cible;
    var argSoin;
    if (cmd.length > 4) {
      error("Trop d'arguments à !cof-soin", cmd);
    }
    if (cmd.length > 2) { //cof-soin lanceur [cible] montant
      if (soigneur === undefined) {
        soigneur = persoOfId(cmd[1], cmd[1]);
        if (soigneur === undefined) {
          error("Le premier argument n'est pas un token valide", cmd[1]);
          return;
        }
        pageId = soigneur.token.get('pageid');
      }
      if (cmd.length > 3) { // on a la cible en argument
        cible = persoOfId(cmd[2], cmd[2], pageId);
        if (cible === undefined) {
          error("Le deuxième argument n'est pas un token valide: " + msg.content, cmd[2]);
          return;
        }
        argSoin = cmd[3];
      } else {
        argSoin = cmd[2];
      }
    } else { //on a juste le montant des soins
      argSoin = cmd[1];
    }
    if (soigneur === undefined && (options.mana || (options.portee !== undefined) || options.limiteParJour || options.limiteParCombat || options.dose)) {
      error("Il faut préciser un soigneur pour ces options d'effet", options);
      return;
    }
    var charId;
    var niveau = 1;
    var rangSoin = 0;
    var soins;
    if (soigneur) {
      charId = soigneur.charId;
      niveau = ficheAttributeAsInt(soigneur, 'niveau', 1);
      rangSoin = charAttributeAsInt(soigneur, 'voieDesSoins', 0);
    }
    var effet = "soins";
    var nbDes = 1;
    if (options.tempeteDeManaIntense) nbDes += options.tempeteDeManaIntense;
    switch (argSoin) {
      case 'leger':
        effet += ' légers';
        if (options.dose === undefined && options.limiteParJour === undefined)
          options.limiteAttribut = {
            nom: 'soinsLegers',
            message: "ne peut plus lancer de sort de soins légers aujourd'hui",
            limite: rangSoin
          };
        var bonusLeger = niveau + charAttributeAsInt(soigneur, 'voieDuGuerisseur', 0);
        soins = "[[" + nbDes + (options.puissant ? "d10" : "d8") + " +" + bonusLeger + "]]";
        if (options.portee === undefined) options.portee = 0;
        break;
      case 'modere':
        effet += ' modérés';
        if (options.dose === undefined && options.limiteParJour === undefined)
          options.limiteAttribut = {
            nom: 'soinsModeres',
            message: "ne peut plus lancer de sort de soins modéréss aujourd'hui",
            limite: rangSoin
          };
        if (options.portee === undefined) options.portee = 0;
        var bonusModere = niveau + charAttributeAsInt(soigneur, 'voieDuGuerisseur', 0);
        soins = "[[" + (nbDes + 1) + (options.puissant ? "d10" : "d8") + " +" + bonusModere + "]]";
        break;
      case 'groupe':
        if (!stateCOF.combat) {
          sendChar(charId, " ne peut pas lancer de soin de groupe en dehors des combats");
          return;
        }
        effet += ' de groupe';
        if (options.dose === undefined && options.limiteParJour === undefined)
          options.limiteAttribut = {
            nom: 'soinsDeGroupe',
            message: " a déjà fait un soin de groupe durant ce combat",
            limite: 1
          };
        if (options.puissant) soins = "[[1d10";
        else soins = "[[" + nbDes + "d8";
        var bonusGroupe = niveau + charAttributeAsInt(soigneur, 'voieDuGuerisseur', 0);
        soins += " + " + bonusGroupe + "]]";
        msg.content += " --alliesEnVue --self";
        if (options.mana === undefined) {
          if (ficheAttributeAsBool(soigneur, 'option_pm', true))
            options.mana = 1;
        }
        break;
      case 'secondSouffle':
        if (!stateCOF.combat) {
          sendChar(charId, " ne peut pas utiliser la capacité second souffle en dehors des combats");
          return;
        }
        effet = "second souffle";
        if (options.dose === undefined && options.limiteParJour === undefined)
          options.limiteAttribut = {
            nom: 'secondSouffle',
            message: " a déjà repris son souffle durant ce combat",
            limite: 1
          };
        soins = "[[1d10+" + niveau + "+" + modCarac(soigneur, 'constitution') +
          "]]";
        cible = soigneur;
        options.recuperation = true;
        break;
      default:
        //TODO : augmenter les dés en cas de tempete de mana intense
        if (options.tempeteDeManaIntense) {
          var firstDicePart = argSoin.match(/[1-9][0-9]*d\d+/i);
          if (firstDicePart && firstDicePart.length > 0) {
            var fdp = firstDicePart[0];
            nbDes = parseInt(fdp) + options.tempeteDeManaIntense;
            argSoin =
              argSoin.replace(fdp, nbDes + fdp.substring(fdp.search(/d/i)));
          } else {
            argSoin = '(' + argSoin + ')*' + (1 + options.tempeteDeManaIntense);
          }
        }
        soins = "[[" + argSoin + "]]";
    }
    var playerId = getPlayerIdFromMsg(msg);
    if (options.tempeteDeMana && soigneur) {
      if (options.tempeteDeMana.cout === 0) {
        //On demande de préciser les options
        var optMana = {
          mana: options.mana,
          rang: options.rang,
          portee: options.portee,
          altruiste: options.altruiste,
          soins: true
        };
        setTempeteDeMana(playerId, soigneur, msg.content, optMana);
        return;
      } else {
        if (options.rang && options.tempeteDeMana.cout > options.rang) {
          sendChar(soigneur.charId, "Attention, le coût de la tempête de mana (" + options.tempeteDeMana.cout + ") est supérieur au rang du sort");
        }
      }
    }
    try {
      sendChat('', soins, function(res) {
        soins = res[0].inlinerolls[0].results.total;
        var soinTxt = buildinline(res[0].inlinerolls[0], 'normal', true);
        if (soins <= 0) {
          sendChar(charId, "ne réussit pas à soigner (total de soins " + soinTxt + ")");
          return;
        }
        var evt = {
          type: effet
        };
        var ressourceLimiteCibleParJour;
        if (options.limiteCibleParJour) {
          ressourceLimiteCibleParJour = effet;
          if (options.limiteCibleParJourRessource)
            ressourceLimiteCibleParJour = options.limiteCibleParJourRessource;
          ressourceLimiteCibleParJour = "limiteParJour_" + ressourceLimiteCibleParJour;
        }
        var limiteATester = true;
        var soinImpossible = false;
        var nbCibles;
        var display;
        var pvsPartages = new Set();
        var iterCibles = function(callback) {
          if (cible) {
            nbCibles = 1;
            callback(cible);
          } else {
            getSelected(msg, function(selected) {
              nbCibles = selected.length;
              if (nbCibles > 1) {
                display = startFramedDisplay(playerId, effet, soigneur);
              } else if (nbCibles === 0) {
                sendChar(charId, "personne à soigner");
                return;
              }
              iterSelected(selected, callback);
            }, {
              lanceur: soigneur
            });
          }
        };
        var finSoin = function() {
          if (nbCibles == 1) {
            if (options.messages) {
              options.messages.forEach(function(message) {
                if (display) addLineToFramedDisplay(display, message);
                else sendChar(charId, message);
              });
            }
            if (display) sendChat("", endFramedDisplay(display));
            addEvent(evt);
          }
          nbCibles--;
        };
        iterCibles(function(cible) {
          if (cible.name === undefined) {
            var cibleChar = getObj('character', cible.charId);
            if (cibleChar === undefined) {
              finSoin();
              return;
            }
            cible.name = cibleChar.get('name');
          }
          if (pvsPartages.has(cible.name)) {
            finSoin();
            return;
          }
          var ciblePartagee = charAttribute(cible.charId, 'PVPartagesAvec');
          ciblePartagee.forEach(function(attr) {
            pvsPartages.add(attr.get('current'));
          });
          if (ressourceLimiteCibleParJour) {
            var utilisations =
              attributeAsInt(cible, ressourceLimiteCibleParJour, options.limiteCibleParJour);
            if (utilisations === 0) {
              sendChar(cible.charId, "ne peut plus bénéficier de " + effet + " aujourd'hui");
              finSoin();
              return;
            }
            setTokenAttr(cible, ressourceLimiteCibleParJour, utilisations - 1, evt);
          }
          if (soinImpossible) {
            finSoin();
            return;
          }
          var token2 = cible.token;
          var nomCible = token2.get('name');
          var sujet = onGenre(cible, 'il', 'elle');
          var Sujet = onGenre(cible, 'Il', 'Elle');
          if (options.portee !== undefined) {
            if (options.puissantPortee || options.tempeteDeManaPortee) options.portee = options.portee * 2;
            var distance = distanceCombat(soigneur.token, token2, pageId);
            if (distance > options.portee) {
              if (display)
                addLineToFramedDisplay(display, "<b>" + nomCible + "</b> : trop loin pour le soin.");
              else
                sendChar(charId,
                  "est trop loin de " + nomCible + " pour le soigner.");
              return;
            }
          }
          if (limiteATester) {
            limiteATester = false;
            if (limiteRessources(soigneur, options, effet, effet, evt)) {
              soinImpossible = true;
              display = undefined;
              finSoin();
              return;
            } else if (display) {
              addLineToFramedDisplay(display, "Résultat des dés : " + soinTxt);
            }
          }
          var callMax = function() {
            if (display) {
              addLineToFramedDisplay(display, "<b>" + nomCible + "</b> : pas besoin de soins.");
            } else {
              var maxMsg = "n'a pas besoin de ";
              if (options.recuperation) {
                maxMsg = "se reposer";
                charId = soigneur.charId;
              } else if (!soigneur || token2.id == soigneur.token.id) {
                maxMsg += "se soigner";
                charId = cible.charId;
              } else {
                maxMsg += "soigner " + nomCible;
              }
              sendChar(charId, maxMsg + ". " + Sujet + " est déjà au maximum de PV");
            }
          };
          var img = options.image;
          var extraImg = '';
          if (img !== "" && img !== undefined && (img.toLowerCase().endsWith(".jpg") || img.toLowerCase().endsWith(".png") || img.toLowerCase().endsWith(".gif"))) {
            extraImg = '<span style="padding: 4px 0;" >  ';
            extraImg += '<img src="' + img + '" style="width: 80%; display: block; max-width: 100%; height: auto; border-radius: 6px; margin: 0 auto;">';
            extraImg += '</span>';
          }
          var printTrue = function(s) {
            if (display) {
              addLineToFramedDisplay(display,
                "<b>" + nomCible + "</b> : + " + s + " PV" + extraImg);
            } else {
              var msgSoin;
              if (!soigneur || token2.id == soigneur.token.id) {
                msgSoin = 'se soigne';
                charId = cible.charId;
              } else {
                msgSoin = 'soigne ' + nomCible;
              }
              msgSoin += " de ";
              if (options.recuperation) msgSoin = "récupère ";
              if (s < soins)
                msgSoin += s + " PV. (Le résultat du jet était " + soinTxt + ")";
              else msgSoin += soinTxt + " PV.";
              msgSoin += extraImg;
              sendChar(charId, msgSoin);
            }
          };
          var pvSoigneur;
          var callTrueFinal = printTrue;
          if (msg.content.includes(' --transfer')) { //paie avec ses PV
            if (soigneur === undefined) {
              error("Il faut préciser qui est le soigneur pour utiliser l'option --transfer", msg.content);
              soinImpossible = true;
              return;
            }
            pvSoigneur = parseInt(soigneur.token.get("bar1_value"));
            if (isNaN(pvSoigneur) || pvSoigneur <= 0) {
              if (display)
                addLineToFramedDisplay(display, "<b>" + nomCible + "</b> : plus assez de PV pour le soigner");
              else
                sendChar(charId,
                  "ne peut pas soigner " + nomCible + ", " + sujet + " n'a plus de PV");
              soinImpossible = true;
              finSoin();
              return;
            }
            if (pvSoigneur < soins) {
              soins = pvSoigneur;
            }
            callTrueFinal = function(s) {
              updateCurrentBar(soigneur, 1, pvSoigneur - s, evt);
              if (pvSoigneur == s) mort(soigneur, undefined, evt);
              printTrue(s);
            };
          }
          if (options.fx) {
            var p1e = {
              x: soigneur.token.get('left'),
              y: soigneur.token.get('top'),
            };
            var p2e = {
              x: cible.token.get('left'),
              y: cible.token.get('top'),
            };
            spawnFxBetweenPoints(p1e, p2e, options.fx, pageId);
          }
          if (options.son) playSound(options.son);
          if (options.targetFx) {
            spawnFx(cible.token.get('left'), cible.token.get('top'), options.targetFx, pageId);
          }
          soigneToken(cible, soins, evt, callTrueFinal, callMax);
          finSoin();
        }); //fin de iterCibles
      }); //fin du sendChat du jet de dés
    } catch (e) {
      if (soins) {
        error("L'expression des soins (" + soins + ") n'est pas bien formée", msg.content);
      } else {
        error("Erreur pendant les soins ", msg.content);
        throw e;
      }
    }
  }

  //Deprecated
  function aoeSoin(msg) {
    var args = msg.content.split(' ');
    if (args.length < 2) {
      error("Pas assez d'arguments pour !cof-aoe-soin: " + msg.content, args);
      return;
    }
    var evt = {
      type: 'soins'
    };
    var soigneur;
    var soins;
    var rollSoins;
    if (args[1] == "groupe") {
      if (msg.selected === undefined || msg.selected.length === 0) {
        error("Il faut sélectionner un token qui lance le sort de soins de groupe", msg);
        return;
      }
      if (msg.selected.length > 1) {
        error("Plusieurs tokens sélectionnés comme lançant le sort de soins de groupe.", msg.selected);
      }
      var persoSoigneur = persoOfId(msg.selected[0]._id);
      if (persoSoigneur === undefined) {
        error("Le token sélectionné ne représente aucun personnage", tokSoigneur);
        return;
      }
      var tokSoigneur = persoSoigneur.token;
      var charIdSoigneur = persoSoigneur.charId;
      var niveau = ficheAttributeAsInt(persoSoigneur, 'niveau', 1);
      if (stateCOF.combat) {
        var dejaSoigne = charAttributeAsBool(persoSoigneur, 'soinsDeGroupe');
        if (dejaSoigne) {
          sendChar(charIdSoigneur, " a déjà fait un soin de groupe durant ce combat");
          return;
        }
        setTokenAttr(persoSoigneur, 'soinsDeGroupe', true, evt);
      }
      if (!depenseMana(persoSoigneur, 1, "lancer un soin de groupe", evt))
        return;
      if (msg.content.includes(' --puissant')) {
        soins = rollDePlus(10, {
          bonus: niveau
        });
      } else {
        soins = rollDePlus(8, {
          bonus: niveau
        });
      }
      rollSoins = soins.roll;
      soins = soins.val;
      soigneur = getObj('character', charIdSoigneur);
      if (soigneur === undefined) {
        error("Fiche du soigneur introuvable");
      }
      msg.content += " --allies --self";
    } else { // soin générique
      soins = parseInt(args[1]);
      rollSoins = soins;
      if (isNaN(soins) || soins < 1) {
        error(
          "L'argument de !cof-aoe-soin doit être un nombre positif",
          msg.content);
        return;
      }
    }
    if (soins <= 0) {
      sendChat('', "Pas de soins (total de soins " + rollSoins + ")");
      return;
    }

    var action = "Soins de groupe (" + rollSoins + ")";
    getSelected(msg, function(selected, playerId) {
      var display = startFramedDisplay(playerId, action, soigneur);
      if (selected.length === 0) {
        addLineToFramedDisplay(display, "Aucune cible sélectionnée pour le soin");
        sendChat("", endFramedDisplay(display));
        addEvent(evt);
        return;
      }
      iterSelected(selected, function(perso) {
        var name = perso.token.get('name');
        var callMax = function() {
          addLineToFramedDisplay(display, "<b>" + name + "</b> : Pas besoin de soins.");
        };
        var callTrue = function(soinsEffectifs) {
          addLineToFramedDisplay(display,
            "<b>" + name + "</b> : + " + soinsEffectifs + " PV");
        };
        soigneToken(perso, soins, evt, callTrue, callMax);
      });
      sendChat("", endFramedDisplay(display));
      addEvent(evt);
    });
  }

  function removeConsommables(nom, evt, attrs) {
    var prefixes = new Set();
    var empty = true;
    attrs = attrs.filter(function(a) {
      var attrName = a.get('name');
      var m = consommableNomRegExp.exec(attrName);
      if (!m) return true;
      if (a.get('current').trim() == nom) {
        prefixes.add(m[1]);
        a.remove();
        empty = false;
        return false;
      }
      return true;
    });
    if (empty) return attrs;
    var regExp = '^(';
    var notFirst = false;
    prefixes.forEach(function(pref) {
      if (notFirst) regExp += '|';
      regExp += pref;
    });
    regExp += ').*?$';
    regExp = new RegExp(regExp);
    attrs = attrs.filter(function(a) {
      if (regExp.test(a.get('name'))) {
        a.remove();
        return false;
      }
      return true;
    });
    return attrs;
  }

  function ajouterConsommable(perso, nom, nb, action, evt) {
    if (perso.token.get('bar1_link') === '') { //Perso non lié, on utilise un attribut
      var attrName = 'dose_' + nom;
      var attr = tokenAttribute(perso, attrName);
      if (attr.length > 0) {
        attr = attr[0];
        var bd = parseInt(attr.get('current'));
        if (!isNaN(bd) && bd > 0) nb += bd;
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attr,
          current: bd,
          max: attr.get('max')
        });
        attr.set({
          current: nb,
          max: action
        });
      } else {
        setTokenAttr(perso, attrName, nb, evt, {
          maxVal: action
        });
      }
    } else { //On va mettre les consommables dans l'équipement
      var attributes = findObjs({
        _type: 'attribute',
        _characterid: perso.charId
      });
      var found = attributes.find(function(attr) {
        var attrName = attr.get('name');
        var m = consommableNomRegExp.exec(attrName);
        if (!m) return false;
        if (attr.get('current').trim() != nom) return false;
        var consoPrefix = m[1];
        var attrEffet = charAttribute(perso.charId, consoPrefix + 'equip_effet');
        if (attrEffet.length === 0) {
          attrEffet = createObj('attribute', {
            characterid: perso.charId,
            name: consoPrefix + 'equip_effet',
            current: action
          });
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attrEffet,
            current: null
          });
        } else if (attrEffet[0].get('current').trim() != action) {
          return false;
        }
        var attrQte = charAttribute(perso.charId, consoPrefix + 'equip_qte');
        if (attrQte.length === 0) {
          attrQte = createObj('attribute', {
            characterid: perso.charId,
            name: consoPrefix + 'equip_qte',
            current: nb + 1,
          });
          evt.attributes = evt.attributes || [];
          evt.attributes.push({
            attribute: attrQte,
            current: null
          });
          return true;
        }
        attrQte = attrQte[0];
        var quantite = parseInt(attrQte.get('current'));
        if (isNaN(quantite) || quantite < 1) quantite = 0;
        attrQte.set('current', quantite + nb);
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attrQte,
          current: quantite
        });
        return true;
      });
      // si le consommable n'a pas été trouvé, on le crée avec une valeur de nb
      if (!found) {
        var pref = 'repeating_equipement_' + generateRowID() + '_';
        var attre = createObj("attribute", {
          name: pref + 'equip_nom',
          current: nom,
          characterid: perso.charId
        });
        evt.attributes = evt.attributes || [];
        evt.attributes.push({
          attribute: attre,
          current: null,
        });
        attre = createObj('attribute', {
          name: pref + 'equip_effet',
          current: action,
          characterid: perso.charId
        });
        evt.attributes.push({
          attribute: attre,
          current: null,
        });
        if (nb > 1) {
          var attrQte = createObj('attribute', {
            characterid: perso.charId,
            name: pref + 'equip_qte',
            current: nb,
          });
          evt.attributes.push({
            attribute: attrQte,
            current: null
          });
        }
      }
    }
  }

  function parseNatureNourriciere(msg) {
    var options = parseOptions(msg);
    getSelected(msg, function(selected) {
      iterSelected(selected, function(lanceur) {
        var charId = lanceur.charId;
        var voieDeLaSurvie = charAttributeAsInt(lanceur, 'voieDeLaSurvie', 0);
        if (voieDeLaSurvie < 1) {
          sendChar(charId, " ne connaît pas la Voie de la Survie ?");
        }
        doNatureNourriciere(lanceur, options);
      });
    });
  }

  function doNatureNourriciere(perso, options) {
    var evt = {
      type: "natureNourriciere",
      action: {
        perso: perso,
        options: options,
        rolls: {}
      }
    };
    addEvent(evt);
    var charId = perso.charId;
    var voieDeLaSurvie = charAttributeAsInt(perso, 'voieDeLaSurvie', 0);
    var trouveBaies = charAttributeAsBool(perso, 'natureNourriciereBaies');
    if (options.rolls && options.rolls.duree) {
      evt.action.rolls.duree = options.rolls.duree;
    } else {
      evt.action.rolls.duree = rollDePlus(6);
    }
    var output = "cherche des herbes. ";
    if (trouveBaies) output = "cherche des baies. ";
    output += "Après " + evt.action.rolls.duree.roll + " heure";
    if (evt.action.rolls.duree.val > 1) output += "s";
    output += ", " + onGenre(perso, "il", "elle");
    var testId = 'natureNourriciere';
    testCaracteristique(perso, 'SAG', 10, testId, options, evt,
      function(tr) {
        var post = "";
        if ((tr.reussite && !trouveBaies) || (trouveBaies && !tr.reussite && tr.valeur > 7)) {
          if (voieDeLaSurvie > 0) {
            output += " revient avec " + voieDeLaSurvie + " plantes médicinales." + tr.modifiers;
            var actionHerbes = "!cof-soin @{selected|token_id} @{selected|token_id} 1d6";
            ajouterConsommable(perso, 'Plante médicinale', voieDeLaSurvie, actionHerbes, evt);
          } else {
            output += " revient avec de quoi soigner les blessés." + tr.modifiers;
          }
        } else if (tr.reussite && trouveBaies) {
          var niveau = ficheAttributeAsInt(perso, 'niveau', 1);
          var actionBaies = "!cof-consommer-baie " + niveau + " --limiteParJour 1 baieMagique";
          var nbBaies = voieDeLaSurvie + Math.floor((tr.valeur - 10) / 2);
          if (nbBaies === 0) nbBaies = 1;
          output += " revient avec " + nbBaies + " baies magiques." + tr.modifiers;
          ajouterConsommable(perso, 'Baie magique', nbBaies, actionBaies, evt);
        } else {
          output += " revient bredouille." + tr.rerolls + tr.modifiers;
        }
        output += "(test de SAG:" + tr.texte + ")";
        output += post;
        sendChar(charId, output);
      });
  }

  function ignorerLaDouleur(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    var evtARefaire = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un événement particulier
      evtARefaire = findEvent(cmd[1]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a été annulée", cmd);
        return;
      }
    }
    getSelected(msg, function(selected) {
      iterSelected(selected, function(chevalier) {
        var charId = chevalier.charId;
        var token = chevalier.token;
        if (attributeAsInt(chevalier, 'douleurIgnoree', 0) > 0) {
          sendChar(charId, "a déjà ignoré la doubleur une fois pendant ce combat");
          return;
        }
        if (evtARefaire === undefined || evtARefaire.type === undefined || !evtARefaire.type.startsWith('Attaque')) {
          sendChar(charId, "s'y prend trop tard pour ignorer la douleur : la dernière action n'était pas une attaque");
          return;
        }
        var aIgnore;
        var evt = {
          type: 'ignorer la douleur'
        };
        var PVid = token.get('bar1_link');
        if (PVid === '') { //token non lié, effets seulement sur le token.
          if (evtARefaire.affecte) {
            var affecte = evtARefaire.affectes[token.id];
            if (affecte && affecte.prev) {
              var lastBar1 = affecte.prev.bar1_value;
              var bar1 = parseInt(token.get('bar1_value'));
              if (isNaN(lastBar1) || isNaN(bar1) || lastBar1 <= bar1) {
                //On regarde la barre 2, peut-être qu'il s'agit de DM temporaires
                var lastBar2 = affecte.prev.bar2_value;
                var bar2 = parseInt(token.get('bar2_value'));
                if (isNaN(lastBar2) || isNaN(bar2) || bar2 <= lastBar2) {
                  sendChar(charId, "ne peut ignorer la douleur : il semble que la dernière attaque ne lui ait pas enlevé de PV");
                  return;
                }
                updateCurrentBar(chevalier, 2, lastBar2, evt);
                setTokenAttr(chevalier, 'douleurIgnoree', bar2 - lastBar2, evt);
                aIgnore = true;
              } else {
                updateCurrentBar(chevalier, 1, lastBar1, evt);
                setTokenAttr(chevalier, 'douleurIgnoree', lastBar1 - bar1, evt);
                aIgnore = true;
              }
            }
          }
        } else { // token lié, il faut regarder l'attribut
          var attrPV = evtARefaire.attributes.find(function(attr) {
            return (attr.attribute.id == PVid);
          });
          if (attrPV) {
            var lastPV = attrPV.current;
            var newPV = attrPV.attribute.get('current');
            if (isNaN(lastPV) || isNaN(newPV) || lastPV <= newPV) {
              sendChar(charId, "ne peut ignorer la douleur : il semble que la dernière attaque ne lui ait pas enlevé de PV");
              return;
            }
            updateCurrentBar(chevalier, 1, lastPV, evt);
            setTokenAttr(chevalier, 'douleurIgnoree', lastPV - newPV, evt);
            aIgnore = true;
          } else { //peut-être qu'il s'agit de DM temporaires
            PVid = token.get('bar2_link');
            attrPV = evtARefaire.attributes.find(function(attr) {
              return (attr.attribute.id == PVid);
            });
            if (attrPV) {
              var lastDmTemp = attrPV.current;
              var newDmTemp = attrPV.attribute.get('current');
              if (isNaN(lastDmTemp) || isNaN(newDmTemp) || newDmTemp <= lastDmTemp) {
                sendChar(charId, "ne peut ignorer la douleur : il semble que la dernière attaque ne lui ait pas augmenté les DM temporaires");
                return;
              }
              updateCurrentBar(chevalier, 2, lastDmTemp, evt);
              setTokenAttr(chevalier, 'douleurIgnoree', newDmTemp - lastDmTemp, evt);
              aIgnore = true;
            }
          }
        }
        if (aIgnore) {
          sendChar(charId, " ignore la douleur de la dernière attaque");
          addEvent(evt);
        } else {
          sendChar(charId, "ne peut ignorer la douleur : il semble que la dernière attaque ne l'ait pas affecté");
        }
      });
    });
  }

  function fortifiant(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("La fonction !cof-fortifiant attend en argument le rang dans la Voie des élixirs du créateur", cmd);
      return;
    }
    var rang = parseInt(cmd[1]);
    if (isNaN(rang) || rang < 1) {
      error("Rang du fortifiant incorrect", cmd);
      return;
    }
    var evt = {
      type: 'fortifiant',
      attributes: []
    };
    addEvent(evt);
    getSelected(msg, function(selection) {
      iterSelected(selection, function(beneficiaire) {
        if (limiteRessources(beneficiaire, options, 'elixir_fortifiant', "boire un fortifiant", evt)) return;
        var soins = rollDePlus(4, {
          bonus: rang
        });
        sendChar(beneficiaire.charId, " boit un fortifiant");
        soigneToken(beneficiaire, soins.val, evt, function(soinsEffectifs) {
          var msgSoins = "et est soigné de ";
          if (soinsEffectifs == soins.val) msgSoins += soins.roll + " PV";
          else msgSoins += soinsEffectifs + " PV (le jet était " + soins.roll + ")";
          sendChar(beneficiaire.charId, msgSoins);
        });
        // Finalement on met l'effet fortifie
        setTokenAttr(beneficiaire, 'fortifie', rang + 1, evt);
      });
    });
  }

  function lancerSort(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    if (options.messages === undefined) options.messages = [];
    if (cmd.length > 1) options.messages.unshift(cmd.slice(1).join(' '));
    if (options.messages.length < 1) {
      options.messages.push("lance un sort");
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        if (options.lanceur) {
          selected = [{
            _id: options.lanceur.token.id
          }];
        } else {
          error("Pas de token sélectionée pour !cof-lancer-sort", cmd);
          return;
        }
      }
      var evt = {
        type: "lancement de sort"
      };
      addEvent(evt);
      if (options.son) playSound(options.son);
      iterSelected(selected, function(lanceur) {
        if (options.tempeteDeMana) {
          if (options.tempeteDeMana.cout === 0) {
            //On demande de préciser les options
            var optMana = {
              mana: options.mana,
              dm: false,
              soins: false,
              duree: true,
              portee: true,
              rang: options.rang,
            };
            setTempeteDeMana(playerId, lanceur, msg.content, optMana);
            return;
          } else {
            if (options.rang && options.tempeteDeMana.cout > options.rang) {
              sendChar(lanceur.charId, "Attention, le coût de la tempête de mana (" + options.tempeteDeMana.cout + ") est supérieur au rang du sort");
            }
          }
        }
        if (limiteRessources(lanceur, options, undefined, "lancer un sort", evt)) return;
        options.messages.forEach(function(m) {
          whisperChar(lanceur.charId, m);
        });
      });
    });
  }

  function emulerAs(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 2) {
      error("Il manque le nom du personnage pour !cof-as", msg.content);
      return;
    }
    cmd.shift();
    var nomPerso = cmd.shift();
    if (nomPerso.charAt(0) == '"') {
      nomPerso = nomPerso.substring(1);
      var inComma = cmd.length;
      while (inComma) {
        nomPerso += ' ' + cmd.shift();
        inComma--;
        if (nomPerso.endsWith('"')) {
          nomPerso = nomPerso.substr(0, nomPerso.length - 1);
          inComma = 0;
        }
      }
    }
    var message = cmd.join(' ');
    sendChat(nomPerso, message);
  }


  function murDeForce(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    var sphere = true;
    var imageSphere = stateCOF.options.images.val.image_mur_de_force.val;
    if (cmd.length > 1) {
      if (cmd[1] == 'mur') sphere = false;
      else if (cmd[1] == 'noImage') imageSphere = undefined;
      else imageSphere = cmd[1].replace('&#58;', ':');
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Aucun personnage sélectionné pour lancer le mur de force");
        return;
      }
      var evt = {
        type: "Mur de force"
      };
      addEvent(evt);
      initiative(selected, evt);
      iterSelected(selected, function(lanceur) {
        if (options.tempeteDeMana) {
          if (options.tempeteDeMana.cout === 0) {
            //On demande de préciser les options
            var optMana = {
              mana: options.mana,
              dm: false,
              soins: false,
              duree: true,
              portee: true,
              rang: options.rang,
            };
            setTempeteDeMana(playerId, lanceur, msg.content, optMana);
            return;
          } else {
            if (options.rang && options.tempeteDeMana.cout > options.rang) {
              sendChar(lanceur.charId, "Attention, le coût de la tempête de mana (" + options.tempeteDeMana.cout + ") est supérieur au rang du sort");
            }
          }
        }
        var charId = lanceur.charId;
        var token = lanceur.token;
        var pageId = token.get('pageid');
        if (limiteRessources(lanceur, options, 'murDeForce', 'lancer un mur de force', evt)) return;
        if (options.son) playSound(options.son);
        whisperChar(charId, "lance un sort de mur de force");
        if (sphere) {
          var scale = computeScale(pageId);
          var diametre = PIX_PER_UNIT * (6 / scale);
          if (options.puissantPortee || options.tempeteDeManaPortee) diametre += diametre;
          if (options.tempeteDeManaIntence)
            diametre *= (1 + options.tempeteDeManaIntense);
          var imageFields = {
            _pageid: pageId,
            imgsrc: imageSphere,
            represents: '',
            left: token.get('left'),
            top: token.get('top'),
            width: diametre,
            height: diametre,
            layer: 'map',
            name: "Mur de force",
            isdrawing: true,
          };
          var newImage = createObj('graphic', imageFields);
          if (newImage) {
            evt.tokens = [newImage];
            toFront(newImage);
            setTokenAttr(lanceur, 'murDeForceId', newImage.id, evt);
            var duree = 5 + modCarac(lanceur, 'charisme');
            if (options.puissantDuree || options.tempeteDeManaDuree) duree += duree;
            setAttrDuree(lanceur, 'murDeForce', duree, evt);
          } else {
            error("Impossible de créer l'image " + options.image, imageFields);
          }
        } else {
          sendChar(charId, '/w "' + token.get('name') + '" ' + "placer l'image du mur sur la carte");
        }
      });
    });
  }

  function tokensEnCombat() {
    var cmp = Campaign();
    var turnOrder = cmp.get('turnorder');
    if (turnOrder === '') return []; // nothing in the turn order
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length === 0) return [];
    var tokens = [];
    turnOrder.forEach(function(a) {
      if (a.id == -1) return;
      tokens.push({
        _id: a.id
      });
    });
    return tokens;
  }

  function devientCapitaine(msg) {
    var cmd = msg.content.split(' ');
    cmd = cmd.filter(function(c) {
      return c !== '';
    });
    if (cmd.length < 2) {
      error("La fonction !cof-capitaine attend en argument l'id du capitaine", cmd);
      return;
    }
    var remove;
    var capitaine;
    var nomCapitaine;
    var bonus = 2;
    var titre = 'capitaine';
    if (cmd[1] == '--aucun') {
      remove = true;
    } else {
      capitaine = persoOfId(cmd[1], cmd[1]);
      if (capitaine === undefined) {
        error("Le premier argument de !cof-lancer-sort doit être un token", cmd[1]);
        return;
      }
      nomCapitaine = capitaine.token.get('name');
      if (cmd.length > 2 && !cmd[2].startsWith('--')) {
        bonus = parseInt(cmd[2]);
        if (isNaN(bonus) || bonus < 0) {
          error("Le bonus de capitaine (second argument) doit être un nombre positif", cmd);
          return;
        }
        if (bonus === 0) remove = true;
        if (bonus > 2) titre = 'commandant';
      }
    }
    var evt = {
      type: 'Capitaine'
    };
    getSelected(msg, function(selected) {
      if (selected.length === 0) {
        error("Pas de token sélectionné pour !cof-capitaine");
        return;
      }
      iterSelected(selected, function(perso) {
        var token = perso.token;
        if (remove) {
          removeCharAttr(perso.charId, 'capitaine', evt);
          removeCharAttr(perso.charId, 'capitaineActif', evt);
          sendChat('COF', "/w GM " + token.get('name') + " n'a plus de capitaine");
        } else {
          if (token.id == capitaine.token.id) return;
          setTokenAttr(perso, 'capitaine', capitaine.token.id + ' ' + nomCapitaine, evt, {
            maxVal: bonus,
            charAttr: true
          });
          sendChat('COF', "/w GM " + nomCapitaine + " est le " + titre + " de " + token.get('name'));
        }
      });
      addEvent(evt);
    });
  }


  function distribuerBaies(msg) {
    if (msg.selected === undefined || msg.selected.length != 1) {
      error("Pour utiliser !cof-distribuer-baies, il faut sélectionner un token", msg);
      return;
    }
    var druide = persoOfId(msg.selected[0]._id);
    if (druide === undefined) {
      error("Erreur de sélection dans !cof-distribuer-baies", msg.selected);
      return;
    }
    var niveau = ficheAttributeAsInt(druide, 'niveau', 1);
    var evt = {
      type: "Distribution de baies magiques"
    };
    var action = "Distribue des baies";
    var mangerBaie = "!cof-consommer-baie " + niveau + " --limiteParJour 1 baieMagique";
    getSelected(msg, function(selected, playerId) {
      var display = startFramedDisplay(playerId, action, druide);
      iterSelected(selected, function(perso) {
        var nom = perso.token.get('name');
        ajouterConsommable(perso, 'Baie magique', 1, mangerBaie, evt);
        var line = nom + " reçoit une baie";
        if (perso.token.id == druide.token.id)
          line = nom + " en garde une pour " + onGenre(druide, "lui", "elle");
        addLineToFramedDisplay(display, line);
      });
      addEvent(evt);
      sendChat("", endFramedDisplay(display));
    }, {
      lanceur: druide
    }); //fin du getSelected
  }

  //!cof-consommer-baie niveau
  function consommerBaie(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 2) {
      error("Il faut un argument à !cof-consommer-baie", cmd);
      return;
    }
    var baie = parseInt(cmd[1]);
    if (isNaN(baie) || baie < 0) {
      error("L'argument de !cof-consommer-baie doit être un nombre positif", cmd);
      return;
    }
    getSelected(msg, function(selection) {
      if (selection === undefined) {
        sendPlayer(msg, "Pas de token sélectionné pour !cof-consommer-baie");
        return;
      }
      var evt = {
        type: "consommer une baie"
      };
      addEvent(evt);
      iterSelected(msg.selected, function(perso) {
        if (limiteRessources(perso, options, 'baieMagique', "a déjà mangé une baie aujourd'hui. Pas d'effet.", evt)) return;
        var soins = rollDePlus(6, {
          bonus: baie
        });
        soigneToken(perso, soins.val, evt, function(soinsEffectifs) {
            var msgSoins = "mange une baie magique. Il est rassasié et récupère ";
            if (soinsEffectifs == soins.val) msgSoins += soins.roll + " points de vie";
            else msgSoins += soinsEffectifs + " PV (le jet était " + soins.roll + ")";
            sendChar(perso.charId, msgSoins);
          },
          function() {
            sendChar(perso.charId, "mange une baie magique. " + onGenre(perso, "Il", "Elle") + " se sent rassasié" + onGenre(perso, '', 'e') + '.');
          });
      });
    }); //fin de getSelected
  }

  function replaceInline(msg) {
    if (msg.inlinerolls) {
      msg.content = _.chain(msg.inlinerolls)
        .reduce(function(m, v, k) {
          m['$[[' + k + ']]'] = v.results.total || 0;
          return m;
        }, {})
        .reduce(function(m, v, k) {
          return m.replace(k, v);
        }, msg.content)
        .value();
    }
  }

  /* Quand on protège un allié, on stocke l'id et le nom du token dans un attribut 'protegerUnAllie' (champs current et max), et pour ce token, on met un
   * attribut 'protegePar_nom' où nom est le nom du token protecteur, et qui contient l'id et le nom du token protecteur
   * Ces attributs disparaissent à la fin des combats */
  function protegerUnAllie(msg) {
    var args = msg.content.split(" ");
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-proteger-un-allie: " + msg.content, args);
      return;
    }
    var protecteur = persoOfId(args[1], args[1]);
    if (protecteur === undefined) {
      error("Le premier argument n'est pas un token valide", args[1]);
      return;
    }
    var tokenProtecteur = protecteur.token;
    var charIdProtecteur = protecteur.charId;
    var nameProtecteur = tokenProtecteur.get('name');
    var pageId = tokenProtecteur.get('pageid');
    var target = persoOfId(args[2], args[2], pageId);
    if (target === undefined) {
      error("Le deuxième argument n'est pas un token valide: " + msg.content, args[2]);
      return;
    }
    var tokenTarget = target.token;
    if (tokenTarget.id == tokenProtecteur.id) {
      sendChar(charIdProtecteur, "ne peut pas se protéger lui-même");
      return;
    }
    var nameTarget = tokenTarget.get('name');
    var evt = {
      type: "Protéger un allié"
    };
    var attrsProtecteur = tokenAttribute(protecteur, 'protegerUnAllie');
    var protegePar = 'protegePar_' + nameProtecteur;
    if (attrsProtecteur.length > 0) { //On protège déjà quelqu'un
      var previousTarget =
        persoOfId(attrsProtecteur[0].get('current'),
          attrsProtecteur[0].get('max'), pageId);
      if (previousTarget) {
        if (previousTarget.token.id == tokenTarget.id) {
          sendChar(charIdProtecteur, "protège déjà " + nameTarget);
          return;
        }
        removeTokenAttr(previousTarget, protegePar, evt, {
          msg: "n'est plus protégé par " + nameProtecteur
        });
      }
    }
    setTokenAttr(protecteur, 'protegerUnAllie',
      tokenTarget.id, evt, {
        msg: "protège " + nameTarget,
        nameTarget
      });
    setTokenAttr(target, protegePar, tokenProtecteur.id, evt, {
      maxVal: nameProtecteur
    });
    addEvent(evt);
  }

  function actionDefensive(msg) {
    var cmd = msg.content.split(' ');
    var def = 2; //pour une défense simple
    var defMsg = "préfère se défendre pendant ce tour";
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'totale':
          def = 4;
          defMsg = "se consacre entièrement à sa défense pendant ce tour";
          break;
        case 'simple':
          def = 2;
          break;
        default:
          error("Argument de !cof-action-defensive non reconnu", cmd);
      }
    }
    var evt = {
      type: "action défensive"
    };
    getSelected(msg, function(selected) {
      initiative(selected, evt);
      iterSelected(selected, function(perso) {
        setTokenAttr(perso, 'defenseTotale', def, evt, {
          msg: defMsg,
          maxVal: stateCOF.tour
        });
      });
      addEvent(evt);
    });
  }

  function strangulation(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-strangulation: " + msg.content, args);
      return;
    }
    var necromancien = persoOfId(args[1], args[1]);
    if (necromancien === undefined) {
      error("Le premier argument n'est pas un token", args[1]);
      return;
    }
    var charId1 = necromancien.charId;
    var pageId = necromancien.token.get('pageid');
    var target = persoOfId(args[2], args[2], pageId);
    if (target === undefined) {
      error("Le deuxième argument n'est pas un token valide: " + msg.content, args[2]);
      return;
    }
    var name2 = target.token.get('name');
    if (!attributeAsBool(target, 'strangulation')) {
      sendChar(charId1, "ne peut pas maintenir la strangulation. Il faut (re)lancer le sort");
      return;
    }
    var evt = {
      type: "Strangulation"
    };
    var dureeStrang = tokenAttribute(target, 'dureeStrangulation');
    var nouvelleDuree = 1;
    if (dureeStrang.length > 0) {
      nouvelleDuree = parseInt(dureeStrang[0].get('current'));
      if (isNaN(nouvelleDuree)) {
        log("Durée de strangulation n'est pas un nombre");
        log(dureeStrang);
        nouvelleDuree = 1;
      } else nouvelleDuree++;
    }
    setTokenAttr(target, 'dureeStrangulation', nouvelleDuree, evt, {
      maxVal: true
    });
    var deStrang = 6;
    if (msg.content.includes(' --puissant')) deStrang = 8;
    var dmgExpr = "[[1d" + deStrang + " ";
    var modInt = modCarac(necromancien, 'intelligence');
    if (modInt > 0) dmgExpr += "+" + modInt;
    else if (modInt < 0) dmgExpr += modInt;
    dmgExpr += "]]";
    sendChat('', dmgExpr, function(res) {
      var dmg = {
        type: 'magique',
        total: res[0].inlinerolls[0].results.total,
        display: buildinline(res[0].inlinerolls[0], 'normal', true),
      };
      dealDamage(target, dmg, [], evt, false, {
          attaquant: necromancien
        }, undefined,
        function(dmgDisplay, dmg) {
          sendChar(charId1, "maintient sa strangulation sur " + name2 + ". Dommages : " + dmgDisplay);
          addEvent(evt);
        });
    });
  }


  function ombreMortelle(msg) {
    var args = msg.content.split(' ');
    if (args.length < 4) {
      error("Pas assez d'arguments pour " + args[0], args);
      return;
    }
    var lanceur = persoOfId(args[1], args[1]);
    if (lanceur === undefined) {
      error("Le premier argument n'est pas un token valide", args[1]);
      return;
    }
    var pageId = lanceur.token.get('pageid');
    var cible = persoOfId(args[2], args[2], pageId);
    if (cible === undefined) {
      error("La cible n'est pas un token valide", args[2]);
      return;
    }
    cible.name = cible.token.get('name');
    var duree = parseInt(args[3]);
    if (isNaN(duree) || duree <= 0) {
      error("La durée doit être un nombre positif", args);
      return;
    }
    var image = stateCOF.options.images.val.image_ombre.val;
    var options = {};
    var opts = msg.content.split(' --');
    opts.shift();
    opts.forEach(function(option) {
      var cmd = option.split(' ');
      switch (cmd[0]) {
        case 'portee':
          if (cmd.length < 2) {
            error("Il manque l'argument de --portee", msg.content);
            return;
          }
          options.portee = parseInt(cmd[1]);
          if (isNaN(options.portee) || options.portee < 0) {
            error("La portée doit être un nombre positif", cmd);
            delete options.portee;
          }
          return;
        case 'mana':
          if (cmd.length < 2) {
            error("Il manque l'argument de --mana", msg.content);
            return;
          }
          options.mana = parseInt(cmd[1]);
          if (isNaN(options.mana) || options.mana < 0) {
            error("Le coût en mana doit être un nombre positif", cmd);
            delete options.mana;
          }
          return;
        case 'image':
          if (cmd.length < 2) {
            error("Il manque l'argument de --image", msg.content);
            return;
          }
          image = cmd[1];
          return;
        default:
          return;
      }
    });
    if (options.portee !== undefined) {
      var distance = distanceCombat(lanceur.token, cible.token, pageId);
      if (distance > options.portee) {
        sendChar(lanceur.charId, "est trop loind de " + cible.name +
          " pour animer son ombre");
        return;
      }
    }
    var evt = {
      type: "Ombre mortelle"
    };
    if (options.mana) {
      var msgMana = "invoquer une ombre mortelle";
      if (!depenseMana(lanceur, options.mana, msgMana, evt)) return;
    }
    copieToken(cible, image, stateCOF.options.images.val.image_ombre.val, "Ombre de " + cible.name, 'ombreMortelle', duree, pageId, evt);
    sendChar(lanceur.charId,
      "anime l'ombre de " + cible.name + ". Celle-ci commence à attaquer " +
      cible.name + "&nbsp;!");
    addEvent(evt);
  }

  function copieToken(cible, image1, image2, nom, effet, duree, pageId, evt) {
    var pv = parseInt(cible.token.get('bar1_value'));
    if (isNaN(pv)) {
      error("Token avec des PV qui ne sont pas un nombre", cible.token);
      return;
    }
    if (pv > 1) pv = Math.floor(pv / 2);
    var pvMax = parseInt(cible.token.get('bar1_max'));
    if (isNaN(pvMax)) {
      error("Token avec des PV max qui ne sont pas un nombre", cible.token);
      return;
    }
    if (pvMax > 1) pvMax = Math.floor(pvMax / 2);
    var tokenFields = {
      _pageid: pageId,
      imgsrc: image1,
      represents: cible.charId,
      left: cible.token.get('left') + 60,
      top: cible.token.get('top'),
      width: cible.token.get('width'),
      height: cible.token.get('height'),
      rotation: cible.token.get('rotation'),
      layer: 'objects',
      name: nom,
      bar1_value: pv,
      bar1_max: pvMax,
      bar2_value: cible.token.get('bar2_value'),
      bar2_max: cible.token.get('bar2_max'),
      bar3_value: cible.token.get('bar3_value'),
      bar3_max: cible.token.get('bar3_max'),
      showname: true,
      showplayers_name: true,
      showplayers_bar1: true,
    };
    var newToken;
    if (image1) newToken = createObj('graphic', tokenFields);
    if (newToken === undefined) {
      tokenFields.imgsrc = cible.token.get('imgsrc').replace('/max.png', '/thumb.png').replace('/med.png', '/thumb.png');
      newToken = createObj('graphic', tokenFields);
      if (newToken === undefined) {
        log(tokenFields.imgsrc);
        if (image2 && image2 != image1) {
          tokenFields.imgsrc = image2;
          newToken = createObj('graphic', tokenFields);
        }
        if (newToken === undefined) {
          error("L'image du token sélectionné n'a pas été uploadé, et l'image par défaut n'est pas correcte. Impossible de créer un token.", tokenFields);
          return;
        }
      }
    }
    evt.tokens = evt.tokens || [];
    evt.tokens.push(newToken);
    var perso = {
      token: newToken,
      charId: cible.charId
    };
    setAttrDuree(perso, effet, duree, evt);
    initPerso(perso, evt);
  }

  //retourne true si le joueur est effectivement déplacé
  function movePlayerToPage(pid, oldPageId, newPageId) {
    if (getObj('player', pid) === undefined) return;
    var c = Campaign();
    var playerPages = c.get('playerspecificpages');
    var playersMainPage = c.get('playerpageid');
    if (!playerPages) playerPages = {};
    if ((playerPages[pid] && playerPages[pid] == oldPageId)) {
      if (playersMainPage == newPageId) {
        c.set('playerspecificpages', false);
        if (_.size(playerPages) > 1) {
          delete playerPages[pid];
          c.set('playerspecificpages', playerPages);
        }
      } else {
        playerPages[pid] = newPageId;
        c.set('playerspecificpages', false);
        c.set('playerspecificpages', playerPages);
      }
    } else if ((!playerPages[pid] && playersMainPage == oldPageId)) {
      playerPages[pid] = newPageId;
      var allPlayers = findObjs({
        _type: 'player'
      });
      var allOnNewPage = allPlayers.every(function(p) {
        if (playerIsGM(p.id)) return true;
        return playerPages[p.id] == newPageId;
      });
      c.set('playerspecificpages', false);
      if (allOnNewPage) {
        Campaign().set('playerpageid', newPageId);
      } else {
        c.set('playerspecificpages', playerPages);
      }
    }
  }

  function findEsc(escaliers, escName, i) {
    var fullEscName = escName + labelsEscalier[i];
    var sortieEscalier = escaliers.find(function(esc) {
      return esc.get('name') == fullEscName;
    });
    if (sortieEscalier === undefined && i > 0) return findEsc(escName, i - 1);
    return sortieEscalier;
  }

  //Attention : ne tient pas compte de la rotation !
  function intersection(pos1, size1, pos2, size2) {
    if (pos1 == pos2) return true;
    if (pos1 < pos2) return ((pos1 + size1 / 2) >= pos2 - size2 / 2);
    return ((pos2 + size2 / 2) >= pos1 - size1 / 2);
  }

  var labelsEscalier = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"];

  function escalier(msg) {
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de sélection de token pour !cof-escalier");
        log("!cof-escalier requiert de sélectionner des tokens");
        return;
      }
      var pageId = getObj('graphic', selected[0]._id).get('pageid');
      var escaliers = findObjs({
        _type: 'graphic',
        _pageid: pageId,
        layer: 'gmlayer'
      });
      if (escaliers.length === 0) {
        sendPlayer(msg, "Pas de token dans le layer GM");
        return;
      }
      var tmaps; //Les passages entre les maps.
      var versLeHaut = true;
      var loop = true;
      if (msg.content) {
        if (msg.content.includes(' bas')) {
          versLeHaut = false;
          loop = false;
        } else if (msg.content.includes(' haut')) {
          versLeHaut = true;
          loop = false;
        }
      }
      iterSelected(selected, function(perso) {
        var token = perso.token;
        var posX = token.get('left');
        var sizeX = token.get('width');
        var posY = token.get('top');
        var sizeY = token.get('height');
        var sortieEscalier;
        escaliers.forEach(function(esc) {
          if (sortieEscalier) return;
          if (intersection(posX, sizeX, esc.get('left'), esc.get('width')) &&
            intersection(posY, sizeY, esc.get('top'), esc.get('height'))) {
            var escName = esc.get('name');
            var l = escName.length;
            if (l > 1) {
              var label = escName.substr(l - 1, 1);
              escName = escName.substr(0, l - 1);
              var i = labelsEscalier.indexOf(label);
              if (versLeHaut) {
                if (i == 11) {
                  if (loop) escName += labelsEscalier[0];
                } else escName += labelsEscalier[i + 1];
              } else {
                if (i === 0) {
                  if (loop) escName += labelsEscalier[11];
                } else escName += labelsEscalier[i - 1];
              }
              var escs = escaliers;
              if (escName.startsWith('tmap_')) {
                if (!tmaps) {
                  tmaps = findObjs({
                    _type: 'graphic',
                    layer: 'gmlayer'
                  });
                  tmaps = tmaps.filter(function(e) {
                    return e.get('name').startsWith('tmap_');
                  });
                }
                escs = tmaps;
              }
              sortieEscalier = escs.find(function(esc2) {
                return esc2.get('name') == escName;
              });
              if (sortieEscalier === undefined && loop) {
                if (i > 0) { //sortie par le plus petit
                  escName = escName.substr(0, l - 1) + 'A';
                  sortieEscalier = escs.find(function(esc2) {
                    return esc2.get('name') == escName;
                  });
                } else {
                  sortieEscalier = findEsc(escs, escName.substr(0, l - 1), 10);
                }
              }
            }
          }
        });
        if (sortieEscalier) {
          var left = sortieEscalier.get('left');
          var top = sortieEscalier.get('top');
          var newPageId = sortieEscalier.get('pageid');
          //Déplacement du token
          if (newPageId == pageId) {
            token.set('left', left);
            token.set('top', top);
          } else {
            //On change de carte, il faut donc copier le token
            var tokenObj = JSON.parse(JSON.stringify(token));
            tokenObj._pageid = newPageId;
            //On met la taille du token à jour en fonction des échelles des cartes.
            var ratio = computeScale(pageId) / computeScale(newPageId);
            if (ratio < 0.9 || ratio > 1.1) {
              if (ratio < 0.25) ratio = 0.25;
              else if (ratio > 4) ratio = 4;
              tokenObj.width *= ratio;
              tokenObj.height *= ratio;
            }
            tokenObj.imgsrc = tokenObj.imgsrc.replace('/med.png', '/thumb.png');
            tokenObj.imgsrc = tokenObj.imgsrc.replace('/max.png', '/thumb.png');
            tokenObj.left = left;
            tokenObj.top = top;
            var newToken = createObj('graphic', tokenObj);
            if (newToken === undefined) {
              error("Impossible de copier le token, et donc de faire le changement de carte", tokenObj);
              return;
            }
          }
          //On déplace ensuite le joueur.
          var character = getObj('character', perso.charId);
          if (character === undefined) return;
          var charControlledby = character.get('controlledby');
          if (charControlledby === '') {
            //Seul le MJ contrôle le personnage
            var players = findObjs({
              _type: 'player',
              online: true
            });
            var gm = players.find(function(p) {
              return playerIsGM(p.id);
            });
            if (gm) {
              if (newPageId != pageId) movePlayerToPage(gm.id, pageId, newPageId);
              sendPing(left, top, newPageId, gm.id, true, gm.id);
            }
          } else {
            charControlledby.split(",").forEach(function(pid) {
              if (newPageId != pageId) movePlayerToPage(pid, pageId, newPageId);
              sendPing(left, top, newPageId, pid, true, pid);
            });
          }
          //Enfin, on efface le token de départ si on a changé de page
          if (newPageId != pageId) token.remove();
          return;
        }
        var err = token.get('name') + " n'est pas sur un escalier";
        if (!loop) {
          if (versLeHaut) err += " qui monte";
          else err += " qui descend";
        }
        sendPlayer(msg, err);
      });
    }); //fin getSelected
  }

  function defautDansLaCuirasse(msg) {
    var args = msg.content.split(' ');
    if (args.length < 3) {
      error("Pas assez d'arguments pour !cof-defaut-dans-la-cuirasse", args);
      return;
    }
    var tireur = persoOfId(args[1], args[1]);
    if (tireur === undefined) {
      error("Le premier argument n'est pas un token valide", args[1]);
      return;
    }
    var pageId = tireur.token.get('pageid');
    var cible = persoOfId(args[2], args[2], pageId);
    if (cible === undefined) {
      error("La cible n'est pas un token valide", args[2]);
      return;
    }
    var evt = {
      type: "Défaut dans la cuirasse"
    };
    setTokenAttr(cible, 'defautDansLaCuirasse_' + tireur.token.get('name'), 2, evt);
    sendChar(tireur.charId, "passe le tour à analyser les points faibles de " + cible.token.get('name'));
    addEvent(evt);
  }

  function postureDeCombat(msg) {
    var args = msg.content.split(' ');
    if (args.length < 4) {
      error("Pas assez d'arguments pour !cof-posture-de-combat", args);
      return;
    }
    var bonus = parseInt(args[1]);
    var attrDebuf = args[2];
    if (attrDebuf != 'DEF' && attrDebuf != 'ATT' && attrDebuf != 'DM') {
      error("L'attribut à débuffer pour la posture de combat est incorrect", args);
      return;
    }
    var attrBuf = args[3];
    if (attrBuf != 'DEF' && attrBuf != 'ATT' && attrBuf != 'DM') {
      error("L'attribut à augmenter pour la posture de combat est incorrect", args);
      return;
    }
    getSelected(msg, function(selected) {
      iterSelected(selected, function(guerrier) {
        if (isNaN(bonus) || bonus < 1) {
          sendPlayer(msg, "choisir un bonus positif (pas " + args[1] + ") pour sa posture de combat");
          return;
        }
        var rang = charAttributeAsInt(guerrier, "voieDuSoldat", 0);
        var charId = guerrier.charId;
        if (rang > 0 && rang < bonus) {
          sendChar(charId, "ne peut choisir qu'un bonus inférieur à " + rang + " pour sa posture de combat");
          return;
        }
        var evt = {
          type: "Posture de combat"
        };
        if (attrBuf == attrDebuf) {
          sendChar(charId, "prend une posture de combat neutre");
          removeTokenAttr(guerrier, 'postureDeCombat', evt);
          addEvent(evt);
          return;
        }
        msg = "prend une posture ";
        switch (attrBuf) {
          case 'DEF':
            msg += "défensive";
            break;
          case 'ATT':
            msg += "offensive";
            break;
          case 'DM':
            msg += "puissante";
            break;
          default:
        }
        msg += " mais ";
        switch (attrDebuf) {
          case 'DEF':
            msg += "risquée";
            break;
          case 'ATT':
            msg += "moins précise";
            break;
          case 'DM':
            msg += "moins puissante";
            break;
          default:
        }
        setTokenAttr(guerrier, 'postureDeCombat', bonus, evt, {
          msg: msg,
          maxVal: attrDebuf + "_" + attrBuf
        });
        addEvent(evt);
      });
    });
  }

  function parseTourDeForce(msg) { // Deprecated
    var options = parseOptions(msg);
    var cmd = options.cmd;
    if (cmd < 2) {
      error("Il manque un argument à !cof-tour-de-force", cmd);
      return;
    }
    var seuil = parseInt(cmd[1]);
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(barbare) {
        if (isNaN(seuil)) {
          sendChar(barbare.charId, "le seuil de difficulté du tour de force doit être un nombre");
          return;
        }
        doTourDeForce(barbare, seuil, options);
      });
    });
  }

  function doTourDeForce(perso, seuil, options) { // Deprecated
    var evt = {
      type: "tourDeForce",
      action: {
        perso: perso,
        seuil: seuil,
        options: options
      }
    };
    addEvent(evt);
    var action = "<b>Capacité</b> : Tour de force";
    var display = startFramedDisplay(options.playerId, action, perso);
    var testId = 'tourDeForce';
    options.bonus = 10;
    testCaracteristique(perso, 'FOR', seuil, testId, options, evt,
      function(tr) {
        addLineToFramedDisplay(display, " Jet de force difficulté " + seuil);
        var smsg = perso.token.get('name') + " fait " + tr.texte;
        if (tr.reussite) {
          smsg += " => réussite";
        } else {
          smsg += " => échec" + tr.rerolls;
        }
        addLineToFramedDisplay(display, smsg);
        var d4 = options.rolls.tourDeForceDmg || rollDePlus(4);
        evt.action.rolls.tourDeForceDmg = d4;
        var r = {
          total: d4.val,
          type: 'normal',
          display: d4.roll
        };
        var explications = [];
        perso.ignoreTouteRD = true;
        dealDamage(perso, r, [], evt, false, {}, explications,
          function(dmgDisplay, dmg) {
            var dmgMsg = "mais cela lui coûte " + dmgDisplay + " PV";
            addLineToFramedDisplay(display, dmgMsg);
            explications.forEach(function(expl) {
              addLineToFramedDisplay(display, expl, 80);
            });
            sendChat('', endFramedDisplay(display));
          });
      });
  }

  function removePreDmg(options, perso, champ, newVal) {
    if (options.preDmg) {
      if (options.preDmg[perso.token.id]) {
        if (champ && options.preDmg[perso.token.id][champ]) {
          if (newVal) options.preDmg[perso.token.id][champ] = newVal;
          else delete options.preDmg[perso.token.id][champ];
        }
        if (champ === undefined || _.isEmpty(options.preDmg[perso.token.id]))
          delete options.preDmg[perso.token.id];
      }
      if (_.isEmpty(options.preDmg)) delete options.preDmg;
    }
  }

  //!cof-encaisser-un-coup, avec la personne qui encaisse sélectionnée
  function doEncaisserUnCoup(msg) {
    var optionsEncaisser = parseOptions(msg);
    if (optionsEncaisser === undefined) return;
    var cmd = optionsEncaisser.cmd;
    var evt = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un événement particulier
      evt = findEvent(cmd[1]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a été annulée", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Personne n'est sélectionné pour encaisser un coup", msg);
        return;
      }
      if (evt === undefined) {
        sendChat('', "Historique d'actions vide, pas d'action trouvée pour encaisser un coup");
        return;
      }
      if (evt.type != 'Attaque' || evt.succes === false) {
        sendChat('', "la dernière action n'est pas une attaque réussie, trop tard pour encaisser le coup d'une action précédente");
        return;
      }
      var action = evt.action;
      if (action.options.distance) {
        sendChat('', "Impossible d'encaisser le dernier coup, ce n'était pas une attaque au contact");
        return;
      }
      var toProceed;
      iterSelected(selected, function(chevalier) {
        if (!attributeAsBool(chevalier, 'encaisserUnCoup')) {
          sendChar(chevalier.charId, "n'est pas placé pour encaisser un coup");
          return;
        }
        if (!peutController(msg, chevalier)) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton");
          return;
        }
        var cible = action.cibles.find(function(target) {
          return (target.token.id === chevalier.token.id);
        });
        if (cible === undefined) {
          sendChar(chevalier.charId, "n'est pas la cible de la dernière attaque");
          return;
        }
        action.choices = action.choices || {};
        action.choices[chevalier.token.id] = action.choices[chevalier.token.id] || {};
        action.choices[chevalier.token.id].encaisserUnCoup = true;
        toProceed = true;
      }); //fin iterSelected
      if (toProceed) {
        redoEvent(evt, action);
      }
    }); //fin getSelected
  }

  function appliquerEncaisserUnCoup(cible, options, evt) {
    removeTokenAttr(cible, 'encaisserUnCoup', evt);
    cible.extraRD =
      ficheAttributeAsInt(cible, 'DEFARMURE', 0) *
      ficheAttributeAsInt(cible, 'DEFARMUREON', 1) +
      ficheAttributeAsInt(cible, 'DEFBOUCLIER', 0) *
      ficheAttributeAsInt(cible, 'DEFBOUCLIERON', 1);
    removePreDmg(options, cible);
  }

  //!cof-parade-projectiles
  function doParadeProjectiles(msg) {
    var optionsParade = parseOptions(msg);
    if (optionsParade === undefined) return;
    var cmd = optionsParade.cmd;
    var evt = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un événement particulier
      evt = findEvent(cmd[1]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a été annulée", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Personne n'est sélectionné pour parer le projectile", msg);
        return;
      }
      if (evt === undefined) {
        sendChat('', "Historique d'actions vide, pas d'action trouvée pour parer le projectile");
        return;
      }
      if (evt.type != 'Attaque' || evt.succes === false) {
        sendChat('', "la dernière action n'est pas une attaque réussie, trop tard pour parer le projectile d'une action précédente");
        return;
      }
      var action = evt.action;
      if (!action.options.distance) {
        sendChat('', "Impossible de parer le projectile, ce n'était pas une attaque au contact");
        return;
      }
      if (action.options.poudre) {
        sendChat('', "Impossible de parer le projectile, il s'agit d'une arme à poudre");
        return;
      }
      if (action.cibles.length > 1) {
        sendChat('', "Impossible de parer un projectile qui touche plusieurs cibles");
        return;
      }
      var toProceed;
      iterSelected(selected, function(moine) {
        if (attributeAsInt(moine, 'paradeDeProjectiles', 0) < 1) {
          sendChar(moine.charId, "ne peut plus parer de projectiles");
          return;
        }
        if (!peutController(msg, moine)) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton");
          return;
        }
        var cible = action.cibles.find(function(target) {
          return (target.token.id === moine.token.id);
        });
        if (cible === undefined) {
          sendChar(moine.charId, "n'est pas la cible de la dernière attaque");
          return;
        }
        action.choices = action.choices || {};
        action.choices[moine.token.id] = action.choices[moine.token.id] || {};
        action.choices[moine.token.id].paradeDeProjectiles = true;
        toProceed = true;
      }); //fin iterSelected
      if (toProceed) {
        redoEvent(evt, action);
      }
    }); //fin getSelected
  }

  function appliquerParadeProjectiles(cible, options, evt) {
    setTokenAttr(cible, 'paradeDeProjectiles', 0, evt, {
      maxVal: 1
    });
    options.preDmgAnnule = true;
    removePreDmg(options, cible);
  }

  // asynchrone : on fait les jets du personnage en opposition
  //eviter id [evtid] [chance]
  function evitementGenerique(msg, verbe, attributeName, actionName, tente, msgDejaFait, carac, typeAttaque, msgReussite, opt) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 1) {
      error("Impossible de trouve la commande !", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Pas assez d'arguments pour " + cmd[0], cmd);
      return;
    }
    var evt;
    var chance;
    if (cmd.length > 2) { //On relance pour un événement particulier
      evt = findEvent(cmd[2]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a été annulée", cmd);
        return;
      }
      chance = cmd.length > 3 && cmd[3] == 'chance';
    } else {
      evt = lastEvent();
    }
    if (evt === undefined) {
      sendChat('', "Historique d'actions vide, pas d'action trouvée pour esquiver");
      return;
    }
    if (evt.type != 'Attaque') {
      sendChat('', "la dernière action n'est pas une attaque réussie, trop tard pour " + verbe + " l'attaque précédente");
      return;
    }
    var perso = persoOfId(cmd[1]);
    if (perso === undefined) {
      error("Le premier argument de " + cmd[0] + " n'est pas un token de personnage", cmd);
      return;
    }
    var action = evt.action;
    var optionsAttaque = action.currentOptions;
    var pageId = action.pageId;
    var cible = action.cibles.find(function(target) {
      return (target.token.id === perso.token.id);
    });
    if (cible === undefined) {
      sendChar(perso.charId, "n'est pas la cible de la dernière attaque");
      return;
    }
    var attributAVerifier = attributeName;
    var persoAttribut = perso;
    if (opt.protecteur) { // c'est un personnage tiers qui protège la cible
      var protecteurAttrs = tokenAttribute(perso, attributeName + 'Valeur');
      if (protecteurAttrs.length < 1) {
        error("Erreur interne dans le bouton de protection, protecteur introuvable", cmd);
        return;
      }
      persoAttribut = persoOfId(protecteurAttrs[0].get("current"));
      attributAVerifier = attributeName + "Actif";
      if (persoAttribut === undefined) {
        error("Erreur interne dans le bouton de protection, protecteur introuvable", cmd);
        return;
      }
      opt.protecteur = persoAttribut;
    }
    if (!peutController(msg, persoAttribut)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    if (opt && opt.condition && !opt.condition(perso)) {
      resolvePreDmgOptions(action.attaquant, action.ciblesTouchees, action.echecCritique, action.attackLabel, action.weaponStats, action.attackd20roll, action.display, optionsAttaque, evt, action.explications, pageId, action.cibles);
    }
    var jetAdversaire = cible.attackRoll;
    if (jetAdversaire === undefined) {
      error("Impossible de trouver le jet de l'attaquant", cible);
      return;
    }
    var attribut = tokenAttribute(persoAttribut, attributAVerifier);
    if (attribut.length === 0) {
      sendChar(persoAttribut.charId, "ne sait pas faire " + actionName);
      return;
    }
    attribut = attribut[0];
    if (opt && opt.attrAsBool) {
      if (!attribut.get('current')) {
        sendChar(persoAttribut.charId, msgDejaFait);
        return;
      }
    } else {
      var curAttribut = parseInt(attribut.get('current'));
      if (isNaN(curAttribut)) {
        error("Resource pour " + actionName + " mal formée", attribut);
        return;
      }
      if (curAttribut < 1) {
        sendChar(persoAttribut.charId, msgDejaFait);
        return;
      }
    }
    action.choices = action.choices || {};
    action.choices[perso.token.id] = action.choices[perso.token.id] || {};
    action.choices[perso.token.id].evitementGenerique = action.choices[perso.token.id].evitementGenerique || [];
    action.choices[perso.token.id].evitementGenerique.push({
      jetAdversaire: jetAdversaire,
      attribut: attribut,
      opt: opt,
      attributeName: attributeName,
      actionName: actionName,
      tente: tente,
      carac: carac,
      typeAttaque: typeAttaque,
      msgReussite: msgReussite
    });
    redoEvent(evt, action);
  }

  function appliquerEvitementGenerique(cible, jetAdversaire, attribut, opt, attributeName, actionName, tente, carac, typeAttaque, msgReussite, pageId, options, evt, callback) {
    var action = evt.action;
    var lanceur = cible;
    if (opt && opt.protecteur) {
      lanceur = opt.protecteur;
    }
    if (opt && opt.attrAsBool) {
      evt.deletedAttributes = evt.deletedAttributes || [];
      evt.deletedAttributes.push(attribut);
    } else {
      var curAttribut = parseInt(attribut.get('current'));
      evt.attributes = evt.attributes || [];
      evt.attributes.push({
        attribute: attribut,
        current: curAttribut
      });
      attribut.set('current', curAttribut - 1);
    }
    var attackRollExpr = "[[" + computeDice(lanceur) + "]]";
    sendChat('', attackRollExpr, function(res) {
      var testId = attributeName + "_" + lanceur.token.id;
      options.rolls = options.rolls || {};
      var attackRoll = options.rolls[testId] || res[0].inlinerolls[0];
      attackRoll.token = lanceur.token;
      evt.action.rolls = evt.action.rolls || {};
      evt.action.rolls[testId] = attackRoll;
      var totalEvitement = attackRoll.results.total;
      var msg = buildinline(attackRoll);
      var attBonus = ficheAttributeAsInt(lanceur, 'niveau', 1);
      if (estAffaibli(lanceur) && charAttributeAsBool(lanceur, 'insensibleAffaibli')) attBonus -= 2;
      switch (typeAttaque) {
        case 'distance':
          attBonus += ficheAttributeAsInt(lanceur, 'ATKTIR_DIV', 0);
          if (stateCOF.setting_arran ||
            (stateCOF.setting_mixte && ficheAttribute(lanceur, 'option_setting', 'generique') == 'arran')) {
            attBonus += ficheAttributeAsInt(lanceur, 'mod_atktir', 0);
          }
          attBonus += modCarac(lanceur, carac);
          break;
        case 'magique':
          attBonus += ficheAttributeAsInt(lanceur, 'ATKMAG_DIV', 0);
          if (stateCOF.setting_arran ||
            (stateCOF.setting_mixte && ficheAttribute(lanceur, 'option_setting', 'generique') == 'arran')) {
            attBonus += ficheAttributeAsInt(lanceur, 'mod_atkmag', 0);
            attBonus += modCarac(lanceur, 'intelligence');
          } else {
            attBonus += modCarac(lanceur, carac);
          }
          break;
        case 'contact':
          attBonus += ficheAttributeAsInt(lanceur, 'ATKCAC_DIV', 0);
          attBonus += modCarac(lanceur, carac);
          break;
        default:
      }
      if (opt && opt.arme && lanceur.arme) {
        actionName = lanceur.arme.nom;
        if (lanceur.arme.attSkillDiv) attBonus += lanceur.arme.attSkillDiv;
      }
      totalEvitement += attBonus;
      if (attBonus > 0) msg += "+" + attBonus;
      else if (attBonus < 0) msg += attBonus;
      if (options.chanceRollId && options.chanceRollId[testId]) {
        totalEvitement += options.chanceRollId[testId];
        msg += "+" + options.chanceRollId[testId];
      }
      var optionsEvitement = {
        displayName: true,
        pasDeDmg: true
      };
      var attEvBonus = bonusAttaqueA(cible, actionName, evt, cible.messages, optionsEvitement);
      var bad = bonusAttaqueD(lanceur, action.attaquant, 0, pageId, evt, cible.messages, optionsEvitement);
      attEvBonus += bad;
      if (opt && opt.bonusAttaque) attEvBonus += opt.bonusAttaque;
      if (attEvBonus > 0) msg += "+" + attEvBonus;
      else if (attEvBonus < 0) msg += attEvBonus;
      msg = lanceur.tokName + " tente " + tente + ". " +
        onGenre(lanceur, "Il", "elle") + " fait " + msg;
      var generalMsg = '';
      if (totalEvitement < jetAdversaire) {
        msg += " => Raté";
        var pc = pointsDeChance(lanceur);
        if (attackRoll.results.total != 1 && pc > 0) {
          generalMsg += '<br/>' +
            boutonSimple("!cof-bouton-chance " + evt.id + " " + testId, "Chance") +
            " (reste " + pc + " PC)";
        }
        if (stateCOF.combat && attributeAsBool(lanceur, 'runeForgesort_énergie') &&
          attributeAsInt(lanceur, 'limiteParCombat_runeForgesort_énergie', 1) > 0 &&
          (carac == 'force' || carac == 'constitution' || carac == 'dexterite')) {
          generalMsg += '<br/>' + boutonSimple("!cof-bouton-rune-energie " + evt.id + " " + testId, "Rune d'énergie");
        }
        if (stateCOF.combat && attributeAsBool(lanceur, 'petitVeinard')) {
          generalMsg += '<br/>' + boutonSimple("!cof-bouton-petit-veinard " + evt.id + " " + testId, "Petit veinard");
        }
        if (generalMsg === '') { //Ne retirer l'option que si aucun reroll possible
          removePreDmg(options, cible, attributeName);
        } else { //Sinon cacher le bouton mais laisser l'option reroll
          removePreDmg(options, cible, attributeName, 'reroll');
        }
      } else { //Évitement réussi
        if (opt && opt.critiqueDevientNormal && cible.critique) {
          cible.critique = false;
          msg += " => Réussi, l'attaque fait des dégâts normaux";
          removePreDmg(options, cible, attributeName);
        } else {
          cible.touche = false;
          if (opt.annule) {
            delete options.preDmg;
            options.preDmgAnnule = true;
            generalMsg += " => Réussi, " + msgReussite;
          } else {
            action.ciblesTouchees = action.ciblesTouchees.filter(function(c) {
              return c.token.id != cible.token.id;
            });
            removePreDmg(options, cible);
            msg += " => Réussi, " + msgReussite;
          }
        }
      }
      callback(msg, generalMsg);
    });
  }

  //!cof-absorber-coup-au-bouclier id [evtid] [chance]
  function absorberCoupAuBouclier(msg) {
    var condition = function(guerrier) {
      if (ficheAttributeAsInt(guerrier, 'DEFBOUCLIERON', 1) != 1) {
        sendChar(guerrier.charId, "ne porte pas son bouclier, il ne peut pas aborber de coup");
        return false;
      }
      return true;
    };
    evitementGenerique(msg, "absorber un coup au bouclier", 'absorberUnCoup',
      "d'absorption de coup au bouclier", "d'absorber un coup au bouclier",
      " a déjà essayé d'absorber un coup au bouclier ce tour", 'force', 'contact', "le coup est absorbé !", {
        attrAsBool: true,
        condition: condition
      });
  }

  //!cof-absorber-sort-au-bouclier id [evtid] [chance]
  function absorberSortAuBouclier(msg) {
    var condition = function(guerrier) {
      if (ficheAttributeAsInt(guerrier, 'DEFBOUCLIERON', 1) != 1) {
        sendChar(guerrier.charId, "ne porte pas son bouclier, il ne peut pas aborber un sort");
        return false;
      }
      return true;
    };
    evitementGenerique(msg, "absorber un sort au bouclier", 'absorberUnSort',
      "d'absorption de sort au bouclier", "d'absorber un sort au bouclier",
      " a déjà essayé d'absorber un sort au bouclier ce tour", 'sagesse', 'magique', "le sort est absorbé !", {
        attrAsBool: true,
        condition: condition
      });
  }

  // asynchrone : on fait les jets du barbare en opposition
  //!cof-resister-a-la-magie id [evtid] [chance]
  function resisterALaMagie(msg) {
    evitementGenerique(msg, 'résister à la magie', 'resistanceALaMagieBarbare',
      'résistance à la magie', "de résister à la magie",
      " a déjà essayé de résister à la magie ce tour",
      'sagesse', 'magique', "il résiste à la magie !", {});
  }

  // asynchrone : on fait les jets du magicien protecteur en opposition
  //!cof-cercle-protection id [evtid] [chance]
  function cercleDeProtection(msg) {
    evitementGenerique(msg, 'activer le cercle de protection', 'cercleDeProtection',
      'activation du cercle de protection', "de bloquer le sort avec le Cercle de Protection",
      " a déjà active le Cercle de Protection ce tour",
      'intelligence', 'magique', "le sort est annulé !", {
        protecteur: true,
        annule: true
      });
  }

  // asynchrone : on fait les jets du barde en opposition
  //!cof-esquive-acrobatique id [evtid] [chance]
  function doEsquiveAcrobatique(msg) {
    evitementGenerique(msg, 'esquiver', 'esquiveAcrobatique',
      'esquive acrobatique', "une esquive acrobatique", " a déjà fait une esquive acrobatique ce tour", 'dexterite', 'distance', "l'attaque est esquivée !", {
        critiqueDevientNormal: true
      });
  }

  function doEsquiveMagistrale(msg) {
    evitementGenerique(msg, 'esquiver', 'paradeMagistrale',
      'esquive acrobatique', "une esquive acrobatique", " a déjà fait une parade magistrale ce tour", 'dexterite', 'distance', "l'attaque est esquivée !", {
        bonusAttaque: -5,
        critiqueDevientNormal: true
      });
  }

  function doParadeMagistrale(msg) {
    evitementGenerique(msg, 'parer', 'paradeMagistrale',
      'parade magistrale', "une parade magistrale", " a déjà fait une parade magistrale ce tour", 'dexterite', 'distance', "l'attaque est parée !", {
        arme: true,
        critiqueDevientNormal: true
      });
  }

  //!cof-chair-a-canon id1 id2 [evt_id]
  // id1 est l'id du pnj récurrent
  // id2 est l'id du token qui se met devant l'attaque
  function doChairACanon(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("pas assez d'argumennts pour !cof-chair-a-canon", cmd);
      return;
    }
    var evtARefaire;
    if (cmd.length > 3) { //On relance pour un événement particulier
      evtARefaire = findEvent(cmd[3]);
      if (evtARefaire === undefined) {
        error("L'action est trop ancienne ou a été annulée", cmd);
        return;
      }
    } else {
      evtARefaire = lastEvent();
    }
    var pnjRec = persoOfId(cmd[1]);
    if (pnjRec === undefined) {
      error("Le premier argument de !cof-chair-a-canon n'est pas un token de personnage", cmd);
      return;
    }
    if (!peutController(msg, pnjRec)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var chairACanon = tokenAttribute(pnjRec, 'chairACanon');
    if (chairACanon.length === 0) {
      sendChar(pnjRec.charId, "ne sait pas utiliser ses sous-fifres pour se défendre");
      return;
    }
    chairACanon = chairACanon[0];
    var curChairACanon = parseInt(chairACanon.get('current'));
    if (isNaN(curChairACanon)) {
      error("Resource pour chair à canon mal formée", chairACanon);
      return;
    }
    if (curChairACanon < 1) {
      sendChar(pnjRec.charId, " a déjà utilisé un sous-fifre ce tour");
      return;
    }
    var sousFifre = persoOfId(cmd[2]);
    if (sousFifre === undefined) {
      error("Le second argument de !cof-chair-a-canon n'est pas un token de personnage", cmd);
      return;
    }
    if (evtARefaire === undefined) {
      sendChat('', "Historique d'actions vide, pas d'action trouvée pour la chair à canon");
      return;
    }
    if (evtARefaire.type != 'Attaque') {
      sendChat('', "la dernière action n'est pas une attaque");
      return;
    }
    var attaque = evtARefaire.action;
    if (attaque === undefined) {
      error("Attaque sans action", evtARefaire);
      return;
    }
    var originalTarget;
    attaque.cibles = attaque.cibles.filter(function(c) {
      if (originalTarget) return true;
      if (c.token.id != cmd[1]) return true;
      originalTarget = c;
      return false;
    });
    if (originalTarget === undefined) {
      error("Impossible de trouver " + pnjRec.token.get('name') + " parmi les cibles de l'attaque", attaque);
      return;
    }
    sousFifre.rollDmg = originalTarget.rollDmg;
    sousFifre.tokName = sousFifre.token.get('name');
    sousFifre.chairACanon = true;
    attaque.cibles.push(sousFifre);
    var optionsRedo = attaque.options;
    optionsRedo.rolls = attaque.rolls;
    var evt = {
      type: "chair à canon",
      attributes: [{
        attribute: chairACanon,
        current: curChairACanon
      }]
    };
    chairACanon.set('current', curChairACanon - 1);
    undoEvent(evtARefaire);
    addEvent(evt);
    removePreDmg(attaque.options, originalTarget);
    redoEvent(evtARefaire, attaque);
  }

  // modifie res et le retourne (au cas où il ne serait pas donné)
  function listRollResults(roll, res) {
    res = res || [];
    switch (roll.type) {
      case 'V': //top-level des rolls
        if (roll.rolls === undefined) break;
        roll.rolls.forEach(function(r) {
          listRollResults(r, res);
        });
        return res;
      case 'R': //jet simple
        if (roll.results === undefined) break;
        roll.results.forEach(function(r) {
          if (r.v) res.push(r.v);
          else if (r.d) res.push(r.d);
          else log("Type de résultat de dé inconnu " + r);
        });
        return res;
      case 'M':
      case 'L':
        return res;
      case 'G':
        if (roll.rolls === undefined) break;
        roll.rolls.forEach(function(ra) {
          ra.forEach(function(r) {
            listRollResults(r, res);
          });
        });
        return res;
      default:
        log("tag inconnu");
    }
    error("Structure de roll inconnue", roll);
    return res;
  }

  //category est un tableau de string, le premier élément étant la catégorie
  //principale, le suivant la sous-catégorie, etc
  //value peut être un nombre, un tableau de nombres, ou un inline roll
  function addStatistics(playerId, category, value) {
    if (stateCOF.statistiques === undefined) return;
    var stat = stateCOF.statistiques;
    if (playerId) {
      var player = getObj('player', playerId);
      if (player) {
        //On utilise l'id roll20 qui semble persistante
        var pid = player.get('d20userid');
        stat[pid] = stat[pid] || {};
        stat = stat[pid];
      }
    }
    if (category) {
      category.forEach(function(cat) {
        stat[cat] = stat[cat] || {};
        stat = stat[cat];
      });
    }
    if (!Array.isArray(value)) {
      if (value.results) value = listRollResults(value.results);
      else value = [value];
    }
    value.forEach(function(v) {
      if (isNaN(v)) {
        error("statistique sur une valeur qui n'est pas un nombre", value);
        return;
      }
      if (typeof v != 'number') v = parseInt(v);
      if (stat.total) stat.total += v;
      else stat.total = v;
      if (stat.nombre) stat.nombre++;
      else stat.nombre = 1;
    });
  }

  function displayStatCategory(stats, indent, categoryName, accum) {
    var res = {
      nombre: 0,
      total: 0,
    };
    if (stats.nombre) { //on peut afficher des résultats
      res.nombre = stats.nombre;
      res.total = stats.total;
    }
    var nindent = indent + "&nbsp;&nbsp;";
    var nAccum = [];
    for (var category in stats) {
      if (category == 'total' || category == 'nombre') break;
      var catRes = displayStatCategory(stats[category], nindent, category, nAccum);
      res.nombre += catRes.nombre;
      res.total += catRes.total;
    }
    var msg = "aucun jet cellecté";
    if (res.nombre > 0) {
      var moyenne = res.total / res.nombre;
      msg = res.nombre + " jet" + ((res.nombre > 1) ? "s" : "") + ", moyenne " + moyenne;
    }
    if (nAccum.length > 0) msg = indent + categoryName + " (" + msg + ") :";
    else msg = indent + categoryName + " : " + msg;
    accum.push(msg);
    nAccum.forEach(function(m) {
      accum.push(m);
    });
    return res;
  }

  function displayStatistics(msg) {
    var stats = stateCOF.statistiques;
    var display = startFramedDisplay(getPlayerIdFromMsg(msg), "Statistiques");
    if (stats === undefined) {
      stats = stateCOF.statistiquesEnPause;
      if (stats)
        addLineToFramedDisplay(display, "Statistiques en pause");
      else {
        addLineToFramedDisplay(display, "Aucune statistique collectée");
        sendChat("COF", endFramedDisplay(display));
        return;
      }
    }
    var tot = {
      total: 0,
      nombre: 0
    };
    var players = findObjs({
      type: 'player'
    });
    var findPlayer = function(pid) {
      return players.find(function(p) {
        return (p.get('d20userid') == pid);
      });
    };
    var addMessages = function(mv) {
      mv.forEach(function(m) {
        addLineToFramedDisplay(display, m);
      });
    };
    for (var category in stats) {
      //first, check if the category is a player id
      var pl = findPlayer(category);
      var catName = category;
      if (pl) catName = pl.get('displayname');
      var accum = [];
      var catRes = displayStatCategory(stats[category], "", catName, accum);
      addMessages(accum);
      tot.total += catRes.total;
      tot.nombre += catRes.nombre;
    }
    addLineToFramedDisplay(display, tot.nombre + " jets au total, dont la somme fait " + tot.total);
    sendChat("COF", endFramedDisplay(display));
  }

  function parseDestructionDesMortsVivants(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var args = options.cmd;
    if (args === undefined || args.length < 2) {
      error("Il faut au moins un argument à !cof-destruction-des-morts-vivants", args);
      return;
    }
    args.shift();
    var dm = args.join(' ');
    dm = dm.replace(/%/g, '&#37;');
    dm = dm.replace(/\)/g, '&#41;');
    dm = dm.replace(/\?/g, '&#63;');
    dm = dm.replace(/@/g, '&#64;');
    dm = dm.replace(/\[/g, '&#91;');
    dm = dm.replace(/\]/g, '&#93;');
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Il faut sélectionner le lanceur de la destruction des morts-vivants");
        return;
      }
      if (selected.length > 1) {
        sendPlayer(msg, "Ne sélectionner qu'un token à la fois pour lancer la destruction des mort-vivants.");
        return;
      }
      var playerName = msg.who;
      if (playerIsGM(playerId)) playerName = 'GM';
      iterSelected(selected, function(lanceur) {
        if (options.tempeteDeMana) {
          if (options.tempeteDeMana.cout === 0) {
            //On demande de préciser les options
            var optMana = {
              mana: options.mana,
              dm: true,
              soins: false,
              duree: false,
              rang: options.rang,
            };
            setTempeteDeMana(playerId, lanceur, msg.content, optMana);
            return;
          } else {
            if (options.rang && options.tempeteDeMana.cout > options.rang) {
              sendChar(lanceur.charId, "Attention, le coût de la tempête de mana (" + options.tempeteDeMana.cout + ") est supérieur au rang du sort");
            }
          }
        }
        if (options.tempeteDeManaIntense) {
          var findNbDes = dm.match(/^([0-9]+)d/);
          if (findNbDes && findNbDes.length > 1) {
            var nbDes = parseInt(findNbDes[1]);
            dm = dm.replace(findNbDes[0], (nbDes + options.tempeteDeManaIntense) + 'd');
          } else {
            log("Pas réussi à trouver le nombre de dés dans " + dm);
          }
        }
        doDestructionDesMortsVivants(lanceur, playerName, dm, options);
      });
    });
  }

  function doDestructionDesMortsVivants(lanceur, playerName, dm, options) {
    var evt = {
      type: "destructionMortsVivants",
      action: {
        lanceur: lanceur,
        playerName: playerName,
        dm: dm,
        options: options
      }
    };
    addEvent(evt);
    if (!depenseMana(lanceur, options.mana, "lancer une destruction des mort-vivants", evt)) {
      return;
    }
    var display = startFramedDisplay(options.playerId,
      "<b>Sort :<b> destruction des morts-vivants", lanceur);
    var name = lanceur.token.get('name');
    var testId = 'destructionDesMortsVivants_' + lanceur.token.id;
    testCaracteristique(lanceur, 'SAG', 13, testId, options, evt,
      function(testRes) {
        var msgJet = "Jet de SAG : " + testRes.texte;
        if (testRes.reussite) {
          addLineToFramedDisplay(display, msgJet + " &ge; 13" + testRes.modifiers);
          sendChat(name, endFramedDisplay(display));
          var optionsDM = {
            sortilege: true,
            lanceur: lanceur,
            aoe: true,
            evt: evt
          };
          var cibles = [];
          var page = getObj("page", options.pageId);
          var murs = getWalls(page, options.pageId);
          var pt;
          if (murs) {
            pt = {
              x: lanceur.token.get('left'),
              y: lanceur.token.get('top')
            };
          }
          var tokensEnVue = findObjs({
            _type: "graphic",
            _pageid: options.pageId,
            _subtype: "token",
            layer: "objects"
          });
          tokensEnVue.forEach(function(obj) {
            if (obj.id == lanceur.token.id) return;
            var objCharId = obj.get('represents');
            if (objCharId === '') return;
            if (obj.get('bar1_max') == 0) return; // jshint ignore:line
            var objChar = getObj('character', objCharId);
            if (objChar === undefined) return;
            if (murs) {
              if (obstaclePresent(obj.get('left'), obj.get('top'), pt, murs)) return;
            }
            var cible = {
              charId: objCharId,
              token: obj
            };
            if (!estMortVivant(cible)) return;
            cibles.push(cible);
          });
          var dmg = {
            type: 'magique',
            value: dm.trim(),
          };
          dmgDirects(options.playerId, playerName, cibles, dmg, optionsDM);
        } else {
          addLineToFramedDisplay(display, msgJet + " < 13");
          var msgRate = name + " ne réussit pas à invoquer son dieu." + testRes.rerolls + testRes.modifiers;
          addLineToFramedDisplay(display, msgRate);
          sendChat(name, endFramedDisplay(display));
        }
      });
  }

  //!cof-enduire-poison label type dm save
  //si label = munition_nom, alors on enduit des munitions et non une arme.
  function parseEnduireDePoison(msg) {
    var options = parseOptions(msg);
    var optArgs = msg.content.split(' --');
    var cmd = options.cmd;
    optArgs.shift();
    if (cmd.length < 5) {
      error("Usage : !cof-enduire-poison L type force save", cmd);
      return;
    }
    var labelArme = cmd[1];
    var typePoison = cmd[2];
    if (typePoison != 'rapide') {
      error("Le seul type de poison géré est rapide, pas " + typePoison, cmd);
    }
    var attribut = 'poisonRapide_' + labelArme;
    var nomMunition;
    var estMunition = labelArme.startsWith('munition_');
    if (estMunition) nomMunition = labelArme.substring(9);
    var forcePoison = cmd[3];
    var savePoison = parseInt(cmd[4]);
    if (isNaN(savePoison)) {
      error("Le dernier argument non optionnel doit être la difficulté du test de CON", cmd);
      return;
    }
    var testINT = 14;
    optArgs.forEach(function(arg) {
      cmd = arg.split(' ');
      switch (cmd[0]) {
        case 'testINT':
          if (cmd.length < 2) {
            error("Il faut un argument à --testINT", cmd);
            return;
          }
          testINT = parseInt(cmd[1]);
          if (isNaN(testINT)) {
            error("Argument de --testINT invalide", cmd);
            testINT = 14;
          }
          return;
      }
    }); //fin du traitement des options
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        var armeEnduite;
        var attr = tokenAttribute(perso, attribut);
        var infosAdditionelles = savePoison;
        if (estMunition) {
          armeEnduite = nomMunition.replace(/_/g, ' ');
          var attrMunitions = tokenAttribute(perso, labelArme);
          if (attrMunitions.length === 0) {
            sendChar(perso.charId, perso.tokName + "n'a pas de munition nommée " + nomMunition);
            return;
          }
          attrMunitions = attrMunitions[0];
          var munitionsCourantes = parseInt(attrMunitions.get('current'));
          var maxMunitions = parseInt(attrMunitions.get('max'));
          if (isNaN(munitionsCourantes) || isNaN(maxMunitions)) {
            error("Attribut de munitions mal formé", attrMunitions);
            return;
          }
          if (munitionsCourantes === 0) {
            sendPlayer(msg, "Plus de munition " + nomMunition);
            return;
          }
          var dejaEnduits = 0;
          if (attr.length > 0) {
            var infos = attr[0].get('max');
            var indexInfos = infos.indexOf(' ');
            if (indexInfos < 1) {
              error("Attribut de poison rapide de munition mal formé (il faudrait la difficulté du save + le nombre de munitions empoisonnées)", infos);
              return;
            }
            var oldSave = parseInt(infos.substring(0, indexInfos));
            dejaEnduits = parseInt(infos.substring(indexInfos + 1));
            if (isNaN(dejaEnduits)) dejaEnduits = 0;
            if (dejaEnduits > 0 && (attr[0].get('current') != forcePoison || oldSave != savePoison)) {
              sendPlayer(msg, "Il y a déjà du poison de force " + attr[0].get('current') + "et de save " + oldSave + " sur les munitions " + armeEnduite + ". Le script ne sait pas gérer différents poisons sur les mêmes munitions.");
              return;
            }
          }
          infosAdditionelles = savePoison + ' ' + (dejaEnduits + 1);
          if (dejaEnduits >= maxMunitions) {
            sendPlayer(msg, "Toutes les munitions " + armeEnduite + " sont déjà enduites de poison");
            return;
          }
        } else {
          var att = getAttack(labelArme, perso);
          if (att === undefined) {
            error(perso.tokNname + " n'a pas d'arme associée au label " + labelArme, cmd);
            return;
          }
          armeEnduite = att.weaponName;
          if (attributeAsBool(perso, attribut)) {
            sendChar(perso.charId, armeEnduite + " est déjà enduit de poison.");
            return;
          }
        }
        doEnduireDePoison(perso, armeEnduite, savePoison, forcePoison, attribut, testINT, infosAdditionelles, options);
      });
    });
  }

  function doEnduireDePoison(perso, armeEnduite, savePoison, forcePoison, attribut, testINT, infosAdditionelles, options) {
    var evt = {
      type: 'enduireDePoison',
      action: {
        perso: perso,
        armeEnduite: armeEnduite,
        savePoison: savePoison,
        forcePoison: forcePoison,
        attribut: attribut,
        testINT: testINT,
        infosAdditionelles: infosAdditionelles,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(perso, options, 'enduirePoison', 'enduire de poison', evt)) return;
    perso.tokName = perso.token.get('name');
    var display = startFramedDisplay(options.playerId, "Essaie d'enduire " + armeEnduite + " de poison", perso);
    //Test d'INT pour savoir si l'action réussit.
    var testId = 'enduireDePoison';
    testCaracteristique(perso, 'INT', testINT, testId, options, evt,
      function(tr) {
        var jet = "Jet d'INT : " + tr.texte;
        if (tr.echecCritique) { //échec critique
          jet += " Échec critique !" + tr.rerolls + tr.modifiers;
          addLineToFramedDisplay(display, jet);
          addLineToFramedDisplay(display, perso.tokName + " s'empoisonne.");
          sendChat('', "[[" + forcePoison + "]]", function(res) {
            var dmgRoll;
            if (options.rolls && options.rolls.enduireSelfDmg) {
              dmgRoll = options.rolls.enduireSelfDmg;
            } else {
              dmgRoll = res[0].inlinerolls[0];
            }
            evt.action.rolls.enduireSelfDmg = dmgRoll;
            var r = {
              total: dmgRoll.results.total,
              type: 'poison',
              display: buildinline(dmgRoll, 'poison')
            };
            options.partialSave = {
              carac: 'CON',
              seuil: savePoison
            };
            var explications = [];
            dealDamage(perso, r, [], evt, false, options, explications,
              function(dmgDisplay, dmg) {
                explications.forEach(function(e) {
                  addLineToFramedDisplay(display, e);
                });
                addLineToFramedDisplay(display, perso.tokName + " subit " + dmgDisplay + " DM");
                sendChat("", endFramedDisplay(display));
              }); //fin de dmg dus à l'échec critique
          }); //fin du jet de dmg
        } else if (tr.reussite) {
          jet += " &ge; " + testINT + tr.modifiers;
          addLineToFramedDisplay(display, jet);
          setTokenAttr(perso, attribut, forcePoison, evt, {
            maxVal: infosAdditionelles
          });
          addLineToFramedDisplay(display, armeEnduite + " est maintenant enduit de poison");
          sendChat("", endFramedDisplay(display));
        } else { //echec normal au jet d'INT
          jet += " < " + testINT + " : échec" + tr.rerolls + tr.modifiers;
          addLineToFramedDisplay(display, jet);
          sendChat("", endFramedDisplay(display));
        }
      }); //fin du test de carac
  }

  var consommableNomRegExp = new RegExp(/^(repeating_equipement_.*_)equip_nom/);
  var consommableQuantiteRegExp = new RegExp(/^(repeating_equipement_.*_)equip_qte/);
  var consommableEffetRegExp = new RegExp(/^(repeating_equipement_.*_)equip_effet/);

  function listeConsommables(msg) {
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        if (perso.token.get('bar1_link') === '') {
          error("La liste de consommables n'est pas au point pour les tokens non liés", perso);
          return;
        }
        var display = startFramedDisplay(playerId, 'Liste de vos consommables :', perso, {
          chuchote: true
        });
        var attributes = findObjs({
          _type: 'attribute',
          _characterid: perso.charId
        });
        var consommables = {}; //map id -> nom, quantite, effet, attr
        attributes.forEach(function(attr) {
          var attrName = attr.get('name').trim();
          var m = consommableNomRegExp.exec(attrName);
          var consoPrefix;
          if (m) {
            consoPrefix = m[1];
            consommables[consoPrefix] = consommables[consoPrefix] || {};
            consommables[consoPrefix].nom = attr.get('current');
            return;
          }
          m = consommableQuantiteRegExp.exec(attrName);
          if (m) {
            consoPrefix = m[1];
            consommables[consoPrefix] = consommables[consoPrefix] || {};
            consommables[consoPrefix].quantite = parseInt(attr.get('current'));
            consommables[consoPrefix].attr = attr;
            return;
          }
          m = consommableEffetRegExp.exec(attrName);
          if (m) {
            consoPrefix = m[1];
            consommables[consoPrefix] = consommables[consoPrefix] || {};
            consommables[consoPrefix].effet = attr.get('current');
            return;
          }
          //Consommables dans des attributs utilisateurs
          if (!(attrName.startsWith('dose_') || attrName.startsWith('consommable_') || attrName.startsWith('elixir_'))) return;
          var consName;
          if (attrName.startsWith("elixir_")) {
            var typeElixir = listeElixirs(5).find(function(i) {
              return "elixir_" + i.attrName == attrName;
            });
            if (typeElixir !== undefined) {
              consName = typeElixir.nom;
            }
          }
          if (consName === undefined) {
            consName = attrName.substring(attrName.indexOf('_') + 1);
            consName = consName.replace(/_/g, ' ');
          }
          var quantite = parseInt(attr.get('current'));
          if (isNaN(quantite) || quantite === 0) return;
          var action = attr.get('max').trim();
          while (consommables[attrName]) {
            attrName += randomInteger(1000);
          }
          consommables[attrName] = {
            nom: consName,
            quantite: quantite,
            effet: action,
            attr: attr,
          };
        }); //fin de la boucle sur les attributs
        var aConsommable;
        _.each(consommables, function(c, prefix) {
          if (c.effet === undefined || c.effet === '' || c.nom === undefined || c.nom === '') return;
          //La quantité est de 1 par défaut sur la fiche
          if (c.quantite === undefined) {
            c.quantite = 1;
            c.attr = createObj('attribute', {
              _characterid: perso.charId,
              name: prefix + 'equip_qte',
              current: 1
            });
          } else if (isNaN(c.quantite) || c.quantite < 1) {
            return;
          }
          aConsommable = true;
          var ligne = c.quantite + ' ';
          ligne += bouton(c.effet, c.nom, perso, {
            ressource: c.attr
          });
          // Pictos : https://wiki.roll20.net/CSS_Wizardry#Pictos
          var overlay = ' title="Cliquez pour échanger"';
          ligne += boutonSimple('!cof-echange-consommable ' + perso.token.id + ' @{target|token_id} ' + c.attr.id, '<span style="font-family:Pictos">r</span>', overlay);
          addLineToFramedDisplay(display, ligne);
        }); //fin de la boucle sur les onsommables
        if (aConsommable)
          addLineToFramedDisplay(display, '<em>Cliquez sur le consommable pour l\'utiliser ou sur <tt><span style="font-family:Pictos">r</span></tt> pour l\'échanger avec un autre personnage.</em>');
        else
          addLineToFramedDisplay(display, "<code>Vous n'avez aucun consommable</code>");
        sendChat('', endFramedDisplay(display));
      });
    }); //fin du getSelected
  }

  // !cof-utilise-consommable tok_id attr_id [msg]
  // utilisation d'un consommable sans action en jeu
  function utiliseConsommable(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Erreur interne d'utilisation de consommables", cmd);
      return;
    }
    cmd.shift();
    var perso = persoOfId(cmd[0]);
    if (perso === undefined) {
      log("Propriétaire perdu");
      sendChat('COF', "Plus possible d'utiliser cette action. Réafficher les consommables.");
      return;
    }
    perso.tokName = perso.token.get('name');
    // Vérifie les droits d'utiliser le consommable
    if (msg.selected && msg.selected.length == 1) {
      var utilisateur = persoOfId(msg.selected[0]._id);
      if (utilisateur === undefined) {
        sendChat('COF', "Le token sélectionné n'est pas valide");
        return;
      }
      var d = distanceCombat(perso.token, utilisateur.token);
      if (d > 0) {
        sendChar(utilisateur.charId, "est trop loin de " + perso.tokName + " pour utiliser ses objets");
        return;
      }
      perso = utilisateur;
    } else {
      //On regarde si le joueur contrôle le token
      if (!peutController(msg, perso)) {
        sendPlayer(msg, "Pas les droits pour ça");
        return;
      }
    }
    //on récupère l'attribut à utiliser
    cmd.shift();
    var attr = getObj('attribute', cmd[0]);
    if (attr === undefined) {
      log("Attribut a changé/perdu");
      log(msg.content);
      sendChat('COF', "Plus possible d'utiliser cette action. Veuillez réafficher les consommables.");
      return;
    }
    //Nom du consommable (pour affichage)
    var consName;
    var quantite = parseInt(attr.get('current'));
    var evt = {
      type: "Utilisation de consommable",
      attributes: [{
        attribute: attr,
        current: quantite,
      }]
    };
    var attrName = attr.get('name').trim();
    //On regarde si c'est un consommable sur la fiche
    var m = consommableQuantiteRegExp.exec(attrName);
    if (m) {
      var consoPrefix = m[1];
      var attrConsName = charAttribute(perso.charId, consoPrefix + 'equip_nom');
      if (attrConsName.length === 0) {
        error("Impossible de trouver le nom du consommable", attr);
        return;
      }
      consName = attrConsName[0].get('current').trim();
    } else {
      consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ').trim();
    }
    if (isNaN(quantite) || quantite < 1) {
      attr.set('current', 0);
      whisperChar(perso.charId + "Vous ne disposez plus de " + consName);
      return;
    }
    if (cmd.length > 1) {
      cmd.shift();
      sendChar(perso.charId, cmd.join(' '));
    }
    attr.set('current', quantite - 1);
    addEvent(evt);
  }

  //!cof-echange-consommable tid1 tid2 attrid
  function echangeConsommable(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 4) {
      error("Erreur interne de consommables", cmd);
      return;
    }
    if (cmd[1] == cmd[2]) {
      sendChat('COF', "Échange avec soi-même, sans effet");
      return;
    }
    //perso1 = token avec qui va échanger le consommable
    var perso1 = persoOfId(cmd[1]);
    if (perso1 === undefined) {
      log("Propriétaire perdu");
      sendChat('COF', "Plus possible d'utiliser cette action. Réafficher les consommables.");
      return;
    }
    perso1.tokName = perso1.token.get('name');
    //perso2 = token avec lequel on va faire l'échange
    var perso2 = persoOfId(cmd[2]);
    if (perso2 === undefined) {
      log("Destinataire perdu");
      sendChat('COF', "Erreur concernant le destinataire. Veuillez réessayer.");
      return;
    }
    perso2.tokName = perso2.token.get('name');
    //On regarde si le joueur contrôle le token
    if (!peutController(msg, perso1)) {
      sendPlayer(msg, "Pas les droits pour ça");
      return;
    }
    //on récupère l'attribut à échanger de perso1
    var attr1 = getObj('attribute', cmd[3]);
    if (attr1 === undefined) {
      log("Attribut a changé/perdu");
      log(cmd);
      sendChat('COF', "Plus possible d'utiliser cette action. Veuillez réafficher les consommables.");
      return;
    }
    var consName;
    var quantite1 = parseInt(attr1.get('current'));
    var evt = {
      type: "Échange de consommable",
      attributes: [{
        attribute: attr1,
        current: quantite1,
      }]
    };
    var effet;
    var attrName = attr1.get('name').trim();
    //On regarde si c'est un consommable sur la fiche
    var m1 = consommableQuantiteRegExp.exec(attrName);
    if (m1) {
      var consoPrefix = m1[1];
      var attrConsName = charAttribute(perso1.charId, consoPrefix + 'equip_nom');
      var attrEffet = charAttribute(perso1.charId, consoPrefix + 'equip_effet');
      if (attrConsName.length === 0 || attrEffet.length === 0) {
        error("Impossible de trouver le nom ou l'effet du consommable", attr1);
        return;
      }
      consName = attrConsName[0].get('current').trim();
      effet = attrEffet[0].get('current').trim();
    } else {
      consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ').trim();
      effet = attr1.get('max').trim();
    }
    if (isNaN(quantite1) || quantite1 < 1) {
      attr1.set('current', 0);
      whisperChar(perso1.charId, "Vous ne disposez plus de " + consName);
      return;
    }
    // on baisse la valeur de 1 du consommable qu'on s'apprête à échanger
    quantite1--;
    attr1.set('current', quantite1);
    // ajout du consommable dans perso2 :
    var attributes = findObjs({
      _type: 'attribute',
      _characterid: perso2.charId
    });
    var quantite2 = 0;
    // on recherche si le consommable existe chez perso2
    var found = attributes.find(function(attr2) {
      var attrName2 = attr2.get('name');
      var m2 = consommableNomRegExp.exec(attrName2);
      if (m2) {
        if (consName != attr2.get('current').trim()) return false;
        var consoPrefix2 = m2[1];
        var attrEffet2 = charAttribute(perso2.charId, consoPrefix2 + 'equip_effet');
        if (attrEffet2.length === 0) {
          attrEffet2 = createObj('attribute', {
            characterid: perso2.charId,
            name: consoPrefix2 + 'equip_effet',
            current: effet
          });
          evt.attributes.push({
            attribute: attrEffet2,
            current: null
          });
        } else if (attrEffet2[0].get('current').trim() != effet) {
          error("Échange dangereux : pas le même effet pour le consommable selon le personnage \n" +
            "Effet chez " + perso1.tokName + " : " + effet + "\n" +
            "Effet chez " + perso2.tokName + " : " + attrEffet2[0].get('current'), attr2.get('name'));
          return false;
        }
        var attrQte2 = charAttribute(perso2.charId, consoPrefix2 + 'equip_qte');
        if (attrQte2.length === 0) {
          quantite2 = 1;
          attrQte2 = createObj('attribute', {
            characterid: perso2.charId,
            name: consoPrefix2 + 'equip_qte',
            current: 2
          });
          evt.attributes.push({
            attribute: attrQte2,
            current: null
          });
          return true;
        }
        attrQte2 = attrQte2[0];
        quantite2 = parseInt(attrQte2.get('current'));
        if (isNaN(quantite2) || quantite2 < 1) quantite2 = 0;
        attrQte2.set('current', quantite2 + 1);
        evt.attributes.push({
          attribute: attrQte2,
          current: quantite2
        });
        return true;
      } else if (!m1 && attrName == attrName2.trim()) {
        if (attr2.get('max').trim() != effet) {
          error("Échange dangereux : pas le même effet pour le consommable selon le personnage \n" +
            "Effet chez " + perso1.tokName + " : " + effet + "\n" +
            "Effet chez " + perso2.tokName + " : " + attr2.get('max'), attr2);
          return false;
        }
        quantite2 = parseInt(attr2.get('current'));
        if (isNaN(quantite2) || quantite2 < 1) quantite2 = 0;
        attr2.set('current', quantite2 + 1);
        evt.attributes.push({
          attribute: attr2,
          current: quantite2,
          max: effet
        });
        return true;
      }
      return false;
    });
    // si le consommable n'a pas été trouvé, on le crée avec une valeur de 1.
    if (!found) {
      if (m1) {
        var pref = 'repeating_equipement_' + generateRowID() + '_';
        var attre = createObj("attribute", {
          name: pref + 'equip_nom',
          current: consName,
          characterid: perso2.charId
        });
        evt.attributes.push({
          attribute: attre,
          current: null,
        });
        attre = createObj("attribute", {
          name: pref + 'equip_effet',
          current: effet,
          characterid: perso2.charId
        });
        evt.attributes.push({
          attribute: attre,
          current: null,
        });
      } else {
        var attr2 = createObj("attribute", {
          name: attrName,
          current: 1,
          max: effet,
          characterid: perso2.charId
        });
        evt.attributes.push({
          attribute: attr2,
          current: null,
        });
      }
    }
    quantite2++;
    // on envoie un petit message précisant la résultante de l'action.
    sendChat('COF', "Echange entre " + perso1.tokName + " et " + perso2.tokName + " terminée.");
    whisperChar(perso1.charId, " Il vous reste " + quantite1 + " " + consName + ".");
    whisperChar(perso2.charId, " Vous possédez désormais " + quantite2 + " " + consName + ".");
    // le MJ est notifié :
    sendChat('COF', "/w GM " + perso1.tokName + " vient de donner <strong>1</strong> " + consName + " à " + perso2.tokName + ".");
    addEvent(evt);
  }

  function parseProvocation(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Problème de parse options", msg.content);
      return;
    }
    if (cmd.length < 3) {
      error("La commande !cof-provocation requiert 2 arguments", cmd);
      return;
    }
    var voleur = persoOfId(cmd[1]);
    if (voleur === undefined) {
      error("Le premier argument de !cof-provocation n'est pas un token valide");
      return;
    }
    var cible = persoOfId(cmd[2]);
    if (cible === undefined) {
      error("Le deuxième argument de !cof-provocation n'est pas un token valide");
      return;
    }
    if (cmd.length > 3 && cmd[3] == 'raillerie') options.raillerie = true;
    doProvocation(voleur, cible, options);
  }

  function doProvocation(voleur, cible, options) {
    var evt = {
      type: 'provocation',
      action: {
        titre: "Provocation",
        voleur: voleur,
        cible: cible,
        options: options,
      }
    };
    addEvent(evt);
    var nomVoleur = voleur.token.get('name');
    var nomCible = cible.token.get('name');
    var titre = 'Provocation';
    var action = 'provocation';
    if (options.raillerie) {
      titre = 'Raillerie';
      action = 'raillerie';
    }
    var display =
      startFramedDisplay(options.playerId, titre, voleur, {
        perso2: cible
      });
    var explications = [];
    var rollId = 'provocation_' + cible.token.id;
    testOppose(rollId, voleur, 'CHA', options, cible, 'INT',
      options, explications, evt,
      function(res, crit, rt1, rt2) {
        explications.forEach(function(l) {
          addLineToFramedDisplay(display, l);
        });
        var reussite;
        switch (res) {
          case 0: //en cas d'égalité, on considère que la provocation est réussie
            diminueMalediction(cible, evt);
            switch (crit) {
              case -1:
                reussite = "Sur un malentendu, la " + action + " réussit...";
                if (options.raillerie) setAttrDuree(cible, 'enerve', 1, evt);
                break;
              case 0:
              case 1:
                reussite = "La " + action + " réussit tout juste.";
                if (options.raillerie) setAttrDuree(cible, 'enerve', 1, evt);
            }
            break;
          case 1:
            switch (crit) {
              case -1:
                reussite = nomCible + " marche complètement, il attaque " + nomVoleur;
                if (options.raillerie) setAttrDuree(cible, 'enerve', 1, evt);
                break;
              case 0:
                if (options.raillerie) {
                  setAttrDuree(cible, 'enerve', 1, evt);
                  reussite = nomVoleur + " a réussi à bien énerver " + nomCible;
                } else reussite = "La provocation réussit.";
                break;
              case 1:
                reussite = "La provocation est une réussite critique !";
                setAttrDuree(cible, 'enerve', 1, evt);
            }
            break;
          case 2:
            switch (crit) {
              case -1:
                reussite = "Échec critique de la " + action + " !";
                break;
              case 0:
                reussite = "La provocation échoue";
                break;
              case 1:
                reussite = nomCible + " voit clair dans le jeu de " + nomCible + ". La provocation échoue.";
            }
        }
        addLineToFramedDisplay(display, reussite);
        sendChat('', endFramedDisplay(display));
      }); //Fin du test opposé
  }

  function enSelle(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il faut 2 arguments pour !cof-en-selle", cmd);
      return;
    }
    var cavalier = persoOfId(cmd[1]);
    if (cavalier === undefined) {
      error("Premier argument de !cof-en-selle incorrect", cmd);
      return;
    }
    if (attributeAsBool(cavalier, 'monteSur')) {
      sendChar(cavalier.charId, " est déjà en selle");
      return;
    }
    var tokenC = cavalier.token;
    var pageId = tokenC.get('pageid');
    var monture = persoOfId(cmd[2], cmd[2], pageId);
    if (monture === undefined || !charAttributeAsBool(monture, 'monture')) {
      sendChar(cavalier.charId, " ne peut pas monter là-dessus");
      log(cmd);
      return;
    }
    var tokenM = monture.token;
    var nomMonture = tokenM.get('name');
    if (attributeAsBool(monture, 'estMontePar')) {
      sendChar(cavalier.charId, " ne peut monter sur " + nomMonture + " car elle a déjà un cavalier");
      return;
    }
    if (distanceCombat(tokenC, tokenM, pageId) > 0) {
      sendChar(cavalier.charId, " est trop loin de " + nomMonture);
      return;
    }
    var evt = {
      type: 'En selle'
    };
    setTokenAttr(cavalier, 'monteSur', tokenM.id, evt, {
      msg: " monte sur " + nomMonture,
      maxVal: nomMonture
    });
    setTokenAttr(monture, 'estMontePar', tokenC.id, evt, {
      maxVal: tokenC.get('name')
    });
    setTokenAttr(monture, 'positionSurMonture', tokenC.get('left') - tokenM.get('left'), evt, {
      maxVal: tokenC.get('top') - tokenM.get('top')
    });
    setTokenAttr(monture, 'directionSurMonture', tokenC.get('rotation') - tokenM.get('rotation'), evt);
    if (stateCOF.combat) {
      updateInit(monture.token, evt);
      if (stateCOF.options.affichage.val.init_dynamique.val) {
        setTokenInitAura(monture);
      }
    }
    addEvent(evt);
  }

  function listeElixirs(rang) {
    var liste = [{
      nom: 'Elixir fortifiant',
      attrName: 'fortifiant',
      action: "!cof-fortifiant $rang",
      rang: 1
    }];
    if (rang < 2) return liste;
    liste.push({
      nom: 'Elixir de feu grégeois',
      attrName: 'feu_grégeois',
      action: "!cof-attack @{selected|token_id} @{target|token_id} Feu Grégeois --auto --dm $rangd6 --feu --psave DEX [[10+@{selected|INT}]] --disque 3 --portee 10 --targetFx burst-fire",
      rang: 2
    });
    if (rang < 3) return liste;
    liste.push({
      nom: 'Elixir de guérison',
      attrName: 'élixir_de_guérison',
      action: "!cof-soin 3d6+$INT",
      rang: 3
    });
    if (rang < 4) return liste;
    liste.push({
      nom: "Elixir d'agrandissement",
      attrName: "potion_d_agrandissement",
      action: "!cof-effet-temp agrandissement [[5+$INT]]",
      rang: 4
    });
    liste.push({
      nom: "Elixir de forme gazeuse",
      attrName: "potion_de_forme_gazeuse",
      action: "!cof-effet-temp formeGazeuse [[1d4+$INT]]",
      rang: 4
    });
    liste.push({
      nom: "Elixir de protection contre les éléments",
      attrName: "potion_de_protection_contre_les_éléments",
      action: "!cof-effet-temp protectionContreLesElements [[5+$INT]] --valeur $rang",
      rang: 4
    });
    liste.push({
      nom: "Elixir d'armure de mage",
      attrName: "potion_d_armure_de_mage",
      action: "!cof-effet-combat armureDuMage",
      rang: 4
    });
    liste.push({
      nom: "Elixir de chute ralentie",
      attrName: "potion_de_chute_ralentie",
      action: "est léger comme une plume.",
      rang: 4
    });
    if (rang < 5) return liste;
    liste.push({
      nom: "Elixir d'invisibilité",
      attrName: "potion_d_invisibilité",
      action: "!cof-set-state invisible true --message se rend invisible ([[1d6+$INT]] minutes)",
      rang: 5
    });
    liste.push({
      nom: "Elixir de vol",
      attrName: "potion_de_vol",
      action: "se met à voler",
      rang: 5
    });
    liste.push({
      nom: "Elixir de respiration aquatique",
      attrName: "potion_de_respiration_aquatique",
      action: "peut respirer sous l'eau",
      rang: 5
    });
    liste.push({
      nom: "Elixir de flou",
      attrName: "potion_de_flou",
      action: "!cof-effet-temp flou [[1d4+$INT]]",
      rang: 5
    });
    liste.push({
      nom: "Elixir de hâte",
      attrName: "potion_de_hâte",
      action: "!cof-effet-temp hate [[1d6+$INT]]",
      rang: 5
    });
    return liste;
  }

  //!cof-creer-elixir token_id elixir
  function creerElixir(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-creer-elixir", msg.content);
      return;
    }
    var forgesort = persoOfId(cmd[1], cmd[1], options.pageId);
    if (forgesort === undefined) {
      if (msg.selected && msg.selected.length == 1) {
        forgesort = persoOfId(msg.selected[0]._id);
      }
      if (forgesort === undefined) {
        error("Impossible de savoir qui crée l'élixir", cmd);
        return;
      }
    }
    var voieDesElixirs = charAttributeAsInt(forgesort, 'voieDesElixirs', 0);
    if (voieDesElixirs < 1) {
      sendChar(forgesort.charId, " ne connaît pas la Voie des Élixirs");
      return;
    }
    var elixir = listeElixirs(voieDesElixirs).find(function(i) {
      return i.attrName == cmd[2];
    });
    if (elixir === undefined) {
      var altElixirs = findObjs({
        _type: 'attribute',
        _characterid: forgesort.charId
      });
      altElixirs.find(function(attr) {
        var attrName = attr.get('name');
        if (!attrName.startsWith('Elixir ')) return false;
        var rang = parseInt(attrName.substring(7));
        if (isNaN(rang) || rang > 3) return false;
        var nomElixir = attr.get('current');
        if (nomElixir != cmd[2]) return false;
        elixir = {
          nom: nomElixir,
          attrName: nomElixir,
          action: attr.get('max'),
          rang: rang
        };
        return true;
      });
      if (elixir === undefined) {
        error(forgesort.token.get('name') + " est incapable de créer " + cmd[2], cmd);
        return;
      }
    }
    var evt = {
      type: "Création d'élixir"
    };
    addEvent(evt);
    if (reglesOptionelles.mana.val.elixirs_sorts.val && ficheAttributeAsBool(forgesort, 'option_pm', true)) {
      if (reglesOptionelles.mana.val.mana_totale.val) {
        switch (elixir.rang) {
          case 1:
            options.mana = 1;
            break;
          case 2:
            options.mana = 3;
            break;
          case 3:
            options.mana = 6;
            break;
          case 4:
            options.mana = 10;
            break;
          case 5:
            options.mana = 15;
            break;
        }
      } else if (elixir.rang > 2) {
        options.mana = elixir.rang - 2;
      }
    }
    // Robustesse DecrAttr multi-cmd
    var elixirsACreer = charAttribute(forgesort.charId, "elixirsACreer");
    if (elixirsACreer.length === 0) {
      error(forgesort.token.get('name') + " ne peut créer d'élixirs " + cmd[2], cmd);
      return;
    }
    options.decrAttribute = elixirsACreer[0].id;
    if (limiteRessources(forgesort, options, 'elixirsACreer', 'élixirs à créer', evt)) return;
    var attrName = 'elixir_' + elixir.attrName;
    var message = "crée un " + elixir.nom;
    var attr = tokenAttribute(forgesort, attrName);
    if (attr.length === 0) {
      var action = elixir.action.replace(/\$rang/g, voieDesElixirs);
      action = action.replace(/\$INT/g, modCarac(forgesort, 'intelligence'));
      setTokenAttr(forgesort, attrName, 1, evt, {
        msg: message,
        maxVal: action
      });
    } else {
      var nb = parseInt(attr[0].get('current'));
      if (isNaN(nb) || nb < 1) nb = 0;
      setTokenAttr(forgesort, attrName, nb + 1, evt, {
        msg: message
      });
    }
  }

  function gestionElixir(msg) {
    getSelected(msg, function(selected, playerId) {
      var player = getObj('player', playerId);
      if (player === undefined) {
        error("Impossible de trouver le joueur", playerId);
        return;
      }
      iterSelected(selected, function(forgesort) {
        var voieDesElixirs = charAttributeAsInt(forgesort, 'voieDesElixirs', 0);
        if (voieDesElixirs < 1) {
          sendChar(forgesort.charId, " ne connaît pas la Voie des Élixirs");
          return;
        }
        var elixirsACreer = voieDesElixirs * 2;
        var attrElixirs = tokenAttribute(forgesort, 'elixirsACreer');
        if (attrElixirs.length === 0) {
          //TODO: ajouter un evenement pour pouvoir faire un undo
          attrElixirs = setTokenAttr(forgesort, 'elixirsACreer', elixirsACreer, {});
        } else {
          attrElixirs = attrElixirs[0];
          elixirsACreer = parseInt(attrElixirs.get('current'));
          if (isNaN(elixirsACreer)) elixirsACreer = 0;
        }
        var titre;
        if (elixirsACreer < 1)
          titre = "Impossible de créer un autre élixir aujourd'hui";
        else titre = "Encore " + elixirsACreer + " élixirs à créer";
        var display = startFramedDisplay(playerId, titre, forgesort, {
          chuchote: true
        });
        listeElixirs(voieDesElixirs).forEach(function(elixir) {
          if (elixir.rang < 4) {
            //Il est possible de changer l'élixir par défaut
            var altElixir = charAttribute(forgesort.charId, 'Elixir ' + elixir.rang);
            if (altElixir.length > 0) {
              elixir.nom = altElixir[0].get('current');
              elixir.attrName = altElixir[0].get('current');
              elixir.action = altElixir[0].get('max');
            }
          }
          var nbElixirs = 0;
          var attr = tokenAttribute(forgesort, 'elixir_' + elixir.attrName);
          if (attr.length > 0) {
            attr = attr[0];
            nbElixirs = parseInt(attr.get('current'));
            if (isNaN(nbElixirs) || nbElixirs < 0) nbElixirs = 0;
          }
          var nomElixir = elixir.nom;
          var options = '';
          var action;
          if (elixirsACreer > 0) {
            action = "!cof-creer-elixir " + forgesort.token.id + ' ' + elixir.attrName;
            options += bouton(action, nbElixirs, forgesort) + ' ';
          } else {
            options = nbElixirs + ' ';
          }
          if (nbElixirs > 0) {
            action = elixir.action;
            action = action.replace(/\$rang/g, voieDesElixirs);
            action = action.replace(/\$INT/g, modCarac(forgesort, 'intelligence'));
            options += bouton(action, nomElixir, forgesort, {
              ressource: attr
            });
          } else {
            options += nomElixir;
          }
          addLineToFramedDisplay(display, options);
        });
        sendChat('', endFramedDisplay(display));
      });
    }); //Fin du getSelected
  }

  function proposerRenouveauElixirs(evt, attrs) {
    var attrsNamed = allAttributesNamed(attrs, 'elixir');
    if (attrsNamed.length === 0) return attrs;
    // Trouver les forgesorts avec des élixirs sur eux
    var forgesorts = {};
    attrsNamed.forEach(function(attr) {
      // Check de l'existence d'un créateur
      var charId = attr.get('_characterid');
      // Check de l'existence d'un token présent pour le personnage
      var tokensPersonnage =
        findObjs({
          _type: 'graphic',
          _subtype: 'token',
          represents: charId
        });
      if (tokensPersonnage.length < 1) {
        error("Impossible de trouver le token du personnage " + charId + " avec un élixir sur la carte");
        return;
      }
      var token;
      if (tokensPersonnage.length > 1) {
        var pageIds = characterPageIds(charId);
        tokensPersonnage.forEach(function(t) {
          if (token) return;
          if (pageIds.has(t.get('pageid'))) token = t;
        });
      }
      if (token === undefined) token = tokensPersonnage[0];
      var personnage = {
        token: tokensPersonnage[0],
        charId: charId
      };
      var voieDesElixirs = charAttributeAsInt(personnage, 'voieDesElixirs');
      //TODO: réfléchir à une solution pour le renouveau des élixirs échangés
      if (voieDesElixirs > 0) {
        var elixirsDuForgesort = forgesorts[charId];
        if (elixirsDuForgesort === undefined) {
          elixirsDuForgesort = {
            forgesort: personnage,
            voieDesElixirs: voieDesElixirs,
            elixirsParRang: {}
          };
        }
        // Check de l'élixir à renouveler
        var nomElixir = attr.get('name');
        var typeElixir = listeElixirs(voieDesElixirs).find(function(i) {
          return "elixir_" + i.attrName == nomElixir;
        });
        if (typeElixir === undefined) {
          error("Impossible de trouver l'élixir à renouveler");
          return;
        }
        // Check des doses
        var doses = attr.get("current");
        if (isNaN(doses)) {
          error("Erreur interne : élixir mal formé");
          return;
        }
        if (doses > 0) {
          // Tout est ok, création de l'item
          var elixirArenouveler = {
            typeElixir: typeElixir,
            doses: doses
          };
          var elixirsParRang = elixirsDuForgesort.elixirsParRang;
          if (elixirsParRang[typeElixir.rang] === undefined) {
            elixirsParRang[typeElixir.rang] = [elixirArenouveler];
          } else elixirsParRang[typeElixir.rang].push(elixirArenouveler);
          forgesorts[charId] = elixirsDuForgesort;
        }
      }
    });
    // Display par personnage
    for (const [forgesortCharId, elixirsDuForgesort] of Object.entries(forgesorts)) {
      // Init du display pour le personnage
      var displayOpt = {
        chuchote: true
      };
      var allPlayers = getPlayerIds({
        charId: forgesortCharId
      });
      var playerId;
      if (allPlayers === undefined || allPlayers.length < 1) {
        displayOpt.chuchote = 'gm';
      } else {
        playerId = allPlayers[0];
      }
      var forgesort = elixirsDuForgesort.forgesort;
      setTokenAttr(forgesort, "elixirsACreer", elixirsDuForgesort.voieDesElixirs * 2, evt);
      var display = startFramedDisplay(allPlayers[0], "Renouveler les élixirs", forgesort, displayOpt);
      var actionToutRenouveler = "";
      // Boucle par rang de rune
      for (const rang in elixirsDuForgesort.elixirsParRang) {
        var elixirsDeRang = elixirsDuForgesort.elixirsParRang[rang];
        if (elixirsDeRang === undefined || elixirsDeRang.length < 1) continue;
        addLineToFramedDisplay(display, "Elixirs de rang " + rang, undefined, true);
        var actionTout = '';
        var ligneBoutons = '';
        // Boucle par élixir de ce rang à renouveler
        for (const i in elixirsDeRang) {
          var elixir = elixirsDeRang[i];
          // Boucle par dose
          for (let j = 0; j < elixir.doses; j++) {
            var action = "!cof-creer-elixir " + forgesort.token.id + " " + elixir.typeElixir.attrName;
            actionTout += action + "\n";
            actionToutRenouveler += action + "\n";
            var nomElixirComplet = elixir.typeElixir.nom;
            ligneBoutons += bouton(action, nomElixirComplet.replace("Elixir de ", "").replace("Elixir d'", ""), forgesort);
          }
        }
        ligneBoutons += bouton(actionTout, "Tout", forgesort, {
          buttonStyle: "background-color: blue;"
        });
        addLineToFramedDisplay(display, ligneBoutons, undefined, true);
      }
      var boutonToutRenouveler =
        bouton(actionToutRenouveler, "Tout renouveler", forgesort, {
          buttonStyle: "background-color: green;"
        });
      addLineToFramedDisplay(display, boutonToutRenouveler, undefined, true);
      sendChar(forgesortCharId, endFramedDisplay(display));
    }
    return removeAllAttributes("elixir", evt, attrs);
  }

  function listeRunes(rang) {
    var liste = [];
    if (rang < 2) return liste;
    liste.push({
      nom: "Rune d'énergie",
      action: "!cof-rune-energie",
      attrName: "runeForgesort_énergie",
      rang: 2
    });
    if (rang < 3) return liste;
    liste.push({
      nom: "Rune de protection",
      action: "!cof-rune-protection",
      attrName: "runeForgesort_protection",
      rang: 3
    });
    if (rang < 4) return liste;
    liste.push({
      nom: "Rune de puissance",
      action: "!cof-rune-puissance",
      attrName: "runeForgesort_puissance",
      rang: 4
    });
    return liste;
  }

  function gestionRunes(msg) {
    getSelected(msg, function(selected, playerId) {
      var player = getObj('player', playerId);
      if (player === undefined) {
        error("Impossible de trouver le joueur", playerId);
        return;
      }
      iterSelected(selected, function(forgesort) {
        var voieDesRunes = charAttributeAsInt(forgesort, 'voieDesRunes', 0);
        if (voieDesRunes < 1) {
          sendChar(forgesort.charId, " ne connaît pas la Voie des Runes.");
          return;
        } else if (voieDesRunes < 2) {
          sendChar(forgesort.charId, " ne peut écrire que des Runes de défense.");
          return;
        }
        var titre = "Création de runes";
        var display = startFramedDisplay(playerId, titre, forgesort, {
          chuchote: true
        });
        listeRunes(voieDesRunes).forEach(function(rune) {
          var action = "!cof-creer-rune " + forgesort.token.id + " @{target|token_id} " + rune.rang;
          if (rune.rang === 4) action += " ?{Numéro de l'arme de la cible?}";
          var options = bouton(action, rune.nom, forgesort);
          addLineToFramedDisplay(display, options);
        });
        sendChat('', endFramedDisplay(display));
      });
    }); //Fin du getSelected
  }

  //!cof-creer-rune token_id rune
  function creerRune(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 4) {
      error("Pas assez d'arguments pour !cof-creer-runes", msg.content);
      return;
    }
    var forgesort = persoOfId(cmd[1], cmd[1], options.pageId);
    if (forgesort === undefined) {
      if (msg.selected && msg.selected.length == 1) {
        forgesort = persoOfId(msg.selected[0]._id);
      }
      if (forgesort === undefined) {
        error("Impossible de savoir qui crée la rune", cmd);
        return;
      }
    }
    var target = persoOfId(cmd[2], cmd[2], options.pageId);
    if (target === undefined) {
      error("Impossible de savoir à qui octroyer la rune", cmd);
      return;
    }
    var voieDesRunes = charAttributeAsInt(forgesort, 'voieDesRunes', 0);
    if (voieDesRunes < 1) {
      sendChar(forgesort.charId, " ne connaît pas la Voie des Runes");
      return;
    } else if (voieDesRunes < 2) {
      sendChar(forgesort.charId, " ne peut écrire que des Runes de défense.");
      return;
    }
    var rune = listeRunes(voieDesRunes).find(function(i) {
      return i.rang == cmd[3];
    });
    if (rune === undefined) {
      error(forgesort.token.get('name') + " est incapable de créer " + cmd[3], cmd);
      return;
    }
    var numeroArme;
    if (rune.rang == 4) {
      if (cmd.length < 5) {
        error("La rune de puissance nécessite de choisir un numéro d'arme.");
        return;
      }
      numeroArme = parseInt(cmd[4]);
    }
    var evt = {
      type: "Création de rune"
    };
    addEvent(evt);
    if (ficheAttributeAsBool(forgesort, 'option_pm', true)) {
      if (reglesOptionelles.mana.val.mana_totale.val) {
        switch (rune.rang) {
          case 2:
            options.mana = 3;
            break;
          case 3:
            options.mana = 6;
            break;
          case 4:
            options.mana = 10;
            break;
        }
      } else if (rune.rang > 2) {
        options.mana = rune.rang - 2;
      }
    }
    var attrName = rune.attrName;
    if (rune.rang === 4) attrName += "(" + numeroArme + ")";
    var message = "reçoit ";
    var typeRune;
    switch (rune.rang) {
      case 2:
        typeRune = "une rune d'énergie";
        break;
      case 3:
        typeRune = "une rune de protection";
        break;
      case 4:
        typeRune = "une rune de puissance sur son arme " + numeroArme;
        break;
    }
    message += typeRune;
    var attr = tokenAttribute(target, attrName);
    if (attr.length !== 0) {
      var nb = parseInt(attr[0].get('current'));
      if (!isNaN(nb) && nb > 0) {
        error("La cible possède déjà une rune " + typeRune, cmd);
        return;
      }
    }
    if (options.mana !== undefined && limiteRessources(forgesort, options, undefined, "créer " + typeRune, evt)) return;
    setTokenAttr(target, attrName, 1, evt, {
      msg: message,
      maxVal: forgesort.charId
    });
    if (rune.rang === 3 && reglesOptionelles.dommages.val.max_rune_protection.val) {
      setTokenAttr(target, "runeProtectionMax", voieDesRunes * 10, evt, {
        maxVal: forgesort.charId
      });
    }
  }

  //TODO: passer pageId en argument au lieu de prendre la page des joueurs
  function proposerRenouveauRunes(evt, attrs) {
    var attrsNamed = allAttributesNamed(attrs, 'runeForgesort');
    if (attrsNamed.length === 0) return attrs;
    // Filtrer par Forgesort, dans l'éventualité qu'il y en ait plusieurs actifs
    var forgesorts = {};
    attrsNamed.forEach(function(attr) {
      // Check de l'existence d'un créateur
      var foundForgesortId = attr.get('max');
      if (foundForgesortId === undefined) {
        error("Impossible de retrouver le créateur de la rune : " + attr);
        return;
      }
      var runesDuForgesort = forgesorts[foundForgesortId];
      if (runesDuForgesort === undefined) {
        // Check de l'existence d'un token présent pour le créateur
        var tokensForgesort =
          findObjs({
            _pageid: Campaign().get("playerpageid"),
            _type: 'graphic',
            _subtype: 'token',
            represents: foundForgesortId
          });
        if (tokensForgesort.length < 1) {
          error("Impossible de trouver le token du forgesort " + foundForgesortId + " sur la carte");
          return;
        }
        var forgesort = {
          token: tokensForgesort[0],
          charId: foundForgesortId
        };
        // Check du perso voie des Runes
        var voieDesRunes = charAttributeAsInt(forgesort, 'voieDesRunes', 0);
        if (voieDesRunes < 1) {
          sendChar(forgesort.charId, " ne connaît pas la Voie des Runes");
          return;
        } else if (voieDesRunes < 2) {
          sendChar(forgesort.charId, " ne peut écrire que des Runes de défense.");
          return;
        }
        runesDuForgesort = {
          forgesort: forgesort,
          voieDesRunes: voieDesRunes,
          runesParRang: {}
        };
      }
      // Check de la présence d'un token pour la cible
      var targetCharId = attr.get('characterid');
      var tokensTarget =
        findObjs({
          _pageid: Campaign().get("playerpageid"),
          _type: 'graphic',
          _subtype: 'token',
          represents: targetCharId
        });
      if (tokensTarget.length < 1) {
        error("Impossible de trouver le token de la cible " + targetCharId + " sur la carte");
        return;
      }
      var target = {
        token: tokensTarget[0],
        charId: targetCharId
      };
      // Check de la rune à renouveler
      var runeName = attr.get('name');
      var typeRune = listeRunes(runesDuForgesort.voieDesRunes).find(function(i) {
        return i.attrName == runeName.split("(")[0];
      });
      if (typeRune === undefined) {
        error("Impossible de trouver la rune à renouveler");
        return;
      }
      // Tout est ok, création de l'item
      var runeARenouveler = {
        target: target,
        typeRune: typeRune,
        runeName: runeName
      };
      var runesParRang = runesDuForgesort.runesParRang;
      if (runesParRang[typeRune.rang] === undefined) {
        runesParRang[typeRune.rang] = [runeARenouveler];
      } else runesParRang[typeRune.rang].push(runeARenouveler);
      forgesorts[foundForgesortId] = runesDuForgesort;
    });
    // Display par personnage
    for (const [forgesortCharId, runesDuForgesort] of Object.entries(forgesorts)) {
      // Init du desplay pour le personnage
      var displayOpt = {
        chuchote: true
      };
      var allPlayers = getPlayerIds({
        charId: forgesortCharId
      });
      var playerId;
      if (allPlayers === undefined || allPlayers.length < 1) {
        displayOpt.chuchote = 'gm';
      } else {
        playerId = allPlayers[0];
      }
      var forgesort = runesDuForgesort.forgesort;
      var display = startFramedDisplay(allPlayers[0], "Renouveler les runes", forgesort, displayOpt);
      var actionToutRenouveler = "";
      // Boucle par rang de rune
      for (const rang in runesDuForgesort.runesParRang) {
        var runesDeRang = runesDuForgesort.runesParRang[rang];
        if (runesDeRang === undefined || runesDeRang.length < 1) continue;
        addLineToFramedDisplay(display, runesDeRang[0].typeRune.nom, undefined, true);
        var actionTout = "";
        var ligneBoutons = "";
        // Boucle par rune de ce rang à renouveler
        for (const i in runesDeRang) {
          var rune = runesDeRang[i];
          var action = "!cof-creer-rune " + forgesort.token.id + " " + rune.target.token.id + " " + rang;
          if (rang == 4) {
            var runeName = rune.runeName;
            action += " " + runeName.substring(runeName.indexOf("(") + 1, runeName.indexOf(")"));
          }
          actionTout += action + "\n";
          actionToutRenouveler += action + "\n";
          ligneBoutons += bouton(action, rune.target.token.get('name'), forgesort);
        }
        ligneBoutons += bouton(actionTout, "Tout", forgesort, {
          buttonStyle: "background-color: blue;"
        });
        addLineToFramedDisplay(display, ligneBoutons, undefined, true);
      }
      var boutonToutRenouveler =
        bouton(actionToutRenouveler, "Tout renouveler", forgesort, {
          buttonStyle: "background-color: green;"
        });
      addLineToFramedDisplay(display, boutonToutRenouveler, undefined, true);
      sendChar(forgesortCharId, endFramedDisplay(display));
    }
    return removeAllAttributes("runeForgesort", evt, attrs);
  }

  function parseRageDuBerserk(msg) {
    var typeRage = 'rage';
    if (msg.content.includes(' --furie')) typeRage = 'furie';
    getSelected(msg, function(selection, playerId) {
      if (selection.length === 0) {
        sendPlayer(msg, "Pas de token sélectionné pour la rage");
        return;
      }
      var options = parseOptions(msg);
      if (options === undefined) return;
      if (options.son) playSound(options.son);
      var persos = [];
      iterSelected(selection, function(perso) {
        persos.push(perso);
      });
      doRageDuBerserk(persos, typeRage, options);
    });
  }

  function doRageDuBerserk(persos, typeRage, options) {
    var evt = {
      type: "rage",
      action: {
        persos: persos,
        typeRage: typeRage,
        options: options
      }
    };
    addEvent(evt);
    persos.forEach(function(perso) {
      var attrRage = tokenAttribute(perso, 'rageDuBerserk');
      if (attrRage.length > 0) {
        attrRage = attrRage[0];
        typeRage = attrRage.get('current');
        var difficulte = 13;
        if (typeRage == 'furie') difficulte = 16;
        //Jet de sagesse difficulté 13 pou 16 pour sortir de cet état
        var display = startFramedDisplay(options.playerId, "Essaie de calmer sa " + typeRage, perso);
        var testId = 'rageDuBerserk_' + perso.token.id;
        testCaracteristique(perso, 'SAG', difficulte, testId, options, evt,
          function(tr) {
            addLineToFramedDisplay(display, "<b>Résultat du jet de SAG :</b> " + tr.texte);
            if (tr.reussite) {
              addLineToFramedDisplay(display, "C'est réussi, " + perso.token.get('name') + " se calme." + tr.modifiers);
              removeTokenAttr(perso, 'rageDuBerserk', evt);
            } else {
              var msgRate = "C'est raté, " + perso.token.get('name') + " reste enragé" + tr.rerolls + tr.modifiers;
              addLineToFramedDisplay(display, msgRate);
            }
            sendChat('', endFramedDisplay(display));
          });
      } else {
        //Le barbare passe en rage
        if (!stateCOF.combat) {
          initiative([{
            _id: perso.token.id
          }], evt);
        }
        setTokenAttr(perso, 'rageDuBerserk', typeRage, evt, {
          msg: "entre dans une " + typeRage + " berserk !"
        });
      }
    });
  }

  //!cof-arme-secrete @{selected|token_id} @{target|token_id}
  function parseArmeSecrete(msg) {
    var options = parseOptions(msg);
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il faut deux arguments à !cof-arme-secrete", cmd);
      return;
    }
    var barde = persoOfId(cmd[1]);
    var cible = persoOfId(cmd[2]);
    if (barde === undefined || cible === undefined) {
      error("Token non valide pour l'arme secrète", cmd);
      return;
    }
    if (attributeAsInt(barde, 'armeSecreteBardeUtilisee')) {
      sendChar(barde.charId, "a déjà utilisé son arme secrète durant ce combat");
      return;
    }
    doArmeSecrete(barde, cible, options);
  }

  function doArmeSecrete(perso, cible, options) {
    var evt = {
      type: 'armeSecrete',
      action: {
        perso: perso,
        cible: cible,
        options: options
      }
    };
    addEvent(evt);
    if (!stateCOF.combat) {
      initiative([{
        _id: perso.token.id
      }, {
        _id: cible.token.id
      }], evt);
    }
    setTokenAttr(perso, 'armeSecreteBardeUtilisee', true, evt);
    var intCible = ficheAttributeAsInt(cible, 'intelligence', 10);
    var testId = 'armeSecreteBarde';
    testCaracteristique(perso, 'CHA', intCible, testId, options, evt, function(tr) {
      var display = startFramedDisplay(options.playerId,
        "Arme secrète", perso, {
          perso2: cible
        });
      var line = "Jet de CHA : " + tr.texte;
      if (tr.reussite) {
        line += " &ge; " + intCible + tr.modifiers;
        addLineToFramedDisplay(display, line);
        addLineToFramedDisplay(display, cible.token.get('name') + " est complètement déstabilisé");
        setAttrDuree(cible, 'armeSecreteBarde', 1, evt);
      } else {
        line += " &lt; " + intCible + tr.rerolls + tr.modifiers;
        addLineToFramedDisplay(display, line);
        addLineToFramedDisplay(display, cible.token.get('name') + " reste insensible au charme de " + perso.token.get('name'));
      }
      sendChat("", endFramedDisplay(display));
    }); //fin testCarac
  }

  function nouveauNomDePerso(nom) {
    var characters = findObjs({
      _type: 'character'
    });
    characters = characters.map(function(c) {
      return c.get('name');
    });
    var trouve = characters.indexOf(nom);
    if (trouve < 0) return nom;
    var n = 2;
    while (1) {
      var nomP = nom + ' ' + n;
      trouve = characters.indexOf(nomP);
      if (trouve < 0) return nomP;
      n++;
    }
  }

  //!cof-animer-arbre lanceur-id target-id [rang]
  function animerUnArbre(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-animer-arbre attend 2 arguments", msg.content);
      return;
    }
    var druide = persoOfId(cmd[1], cmd[1], options.pageId);
    if (druide === undefined) {
      error("Le premier argument de !cof-animer-arbre n'est pas un token valie", cmd);
      return;
    }
    var tokenArbre = getObj('graphic', cmd[2]);
    if (tokenArbre === undefined) {
      error("Le deuxième argument de !cof-animer-arbre n'est pas un token", cmd);
      return;
    }
    if (tokenArbre.get('represents') !== '') {
      sendChar(druide.charId, "ne peut pas animer " + tokenArbre.get('name'));
      return;
    }
    if (options.portee !== undefined) {
      var dist = distanceCombat(druide.token, tokenArbre, options.pageId);
      if (dist > options.portee) {
        sendChar(druide.charId, " est trop loin de l'arbre");
        return;
      }
    }
    var rang = charAttributeAsInt(druide, 'voieDesVegetaux', 3);
    if (cmd.length > 3) { //Le rang est spécifié en argument optionnel
      var cmd3 = parseInt(cmd[3]);
      if (isNaN(cmd3) || cmd3 < 1) {
        error("Le rang n'est pas un nombre valie. On utilise " + rang + " à la place", cmd);
      } else rang = cmd3;
    }
    var evt = {
      type: "Animation d'un arbre"
    };
    addEvent(evt);
    if (limiteRessources(druide, options, 'animerUnArbre', 'animer un arbre', evt)) return;
    if (!stateCOF.combat) {
      initPerso(druide, evt);
    }
    var niveau = ficheAttributeAsInt(druide, 'niveau', 1);
    var nomArbre = nouveauNomDePerso('Arbre animé');
    var avatar = "https://s3.amazonaws.com/files.d20.io/images/42323556/6qxlm965aFhBXGoYFy5fqg/thumb.png?1510582137";
    var specArbre = {
      pv: rang * 10,
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: niveau,
        force: 18,
        pnj_for: 4,
        dexterite: 7,
        pnj_dex: -2,
        constitution: 20,
        pnj_con: 5,
        intelligence: 8,
        pnj_int: -1,
        sagesse: 14,
        pnj_sag: 2,
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 5,
        pnj_def: 13,
        pnj_init: 7,
        RDS: '10/feu_hache',
        race: 'arbre',
        taille: 'grand'
      },
      attaques: [{
        nom: 'Branches',
        atk: niveau,
        dmnbde: 1,
        dmde: 6,
        dm: 3,
        typedegats: 'contondant',
      }],
      attributes: [{
        name: 'arbreAnime',
        current: niveau,
        max: getInit(),
      }]
    };
    var charArbre = createCharacter(nomArbre, options.playerId, avatar, tokenArbre, specArbre);
    evt.characters = [charArbre];
    sendChar(charArbre.id, "commence à s'animer");
    initiative([{
      _id: tokenArbre.id
    }], evt);
  }

  function persoUtiliseRuneProtection(perso, evt) {
    var attr = tokenAttribute(perso, 'runeForgesort_protection');
    if (attr.length < 1 || attr[0].get('current') < 1) {
      sendChar(perso.charId, "n'a pas de rune de protection");
      return false;
    }
    if (limiteRessources(perso, {
        limiteParCombat: 1
      }, "runeForgesort_protection", "a déjà utilisé sa rune de protection durant ce combat", evt)) {
      addEvent(evt);
      return false;
    }
    return true;
  }

  //!cof-rune-protection
  function runeProtection(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "On ne peut utiliser les runes de protection qu'en combat");
      return;
    }
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    var evt = lastEvent();
    if (cmd !== undefined && cmd.length > 1) { //On relance pour un événement particulier
      evt = findEvent(cmd[1]);
      if (evt === undefined) {
        error("L'action est trop ancienne ou a été annulée", cmd);
        return;
      }
    }
    if (evt.type != 'Attaque') {
      sendChat('', "la dernière action n'est pas une attaque réussie, trop tard pour absorber l'attaque précédente");
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error("Personne n'est sélectionné pour utiliser une rune", msg);
        return;
      }
      var action = evt.action;
      iterSelected(selected, function(perso) {
        if (!peutController(msg, perso)) {
          sendPlayer(msg, "pas le droit d'utiliser ce bouton");
          return;
        }
        var cible = action.cibles.find(function(target) {
          return (target.token.id === perso.token.id);
        });
        if (cible === undefined) {
          sendChar(perso.charId, "n'est pas la cible de la dernière attaque");
          return;
        }
        if (!persoUtiliseRuneProtection(perso, evt)) return;
        action.choices = action.choices || {};
        action.choices[perso.token.id] = action.choices[perso.token.id] || {};
        action.choices[perso.token.id].runeForgesort_protection = true;
      }); //fin iterSelected
      redoEvent(evt, action);
    }); //fin getSelected
  }

  function appliquerRuneDeProtection(cible, options, evt) {
    if (reglesOptionelles.dommages.val.max_rune_protection.val) {
      cible.messages.push(cible.tokName + " utilise sa Rune de Protection");
      cible.utiliseRuneProtectionMax = attributeAsInt(cible, 'runeProtectionMax', 30);
    } else {
      cible.messages.push(cible.tokName + " utilise sa Rune de Protection pour annuler les dommages");
      cible.utiliseRuneProtection = true;
    }
    removePreDmg(options, cible);
  }

  //!cof-delivrance @{selected|token_id} @{target|token_id}
  function delivrance(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-delivrance attend 2 arguments", msg.content);
      return;
    }
    var pretre = persoOfId(cmd[1], cmd[1], options.pageId);
    if (pretre === undefined) {
      error("Le premier argument de !cof-delivrance n'est pas un token valide", msg.content);
      return;
    }
    var cible = persoOfId(cmd[2], cmd[2], options.pageId);
    if (cible === undefined) {
      error("Le deuxième argument de !cof-delivrance n'est pas un token valide", msg.content);
      return;
    }
    cible.tokName = cible.token.get('name');
    if (options.portee !== undefined) {
      var dist = distanceCombat(pretre.token, cible.token, options.pageId);
      if (dist > options.portee) {
        sendChar(pretre.charId, " est trop loin de " + cible.tokName);
        return;
      }
    }
    var evt = {
      type: "Délivrance",
      deletedAttributes: []
    };
    addEvent(evt);
    if (limiteRessources(pretre, options, 'délivrance', 'délivrance', evt)) return;
    var attr;
    var display = startFramedDisplay(getPlayerIdFromMsg(msg), 'Délivrance', pretre, {
      perso2: cible
    });
    var printEffet = function(message) {
      addLineToFramedDisplay(display, "La cible " + message);
    };
    var optFin = {
      print: printEffet,
      pageId: options.pageId
    };
    _.each(messageEffetTemp, function(effet, nomEffet) {
      if (effet.prejudiciable) {
        //Attention, ne fonctionne pas avec les effets génériques
        attr = tokenAttribute(cible, nomEffet);
        if (attr.length > 0)
          finDEffet(attr[0], nomEffet, attr[0].get('name'), cible.charId, evt, optFin);
      }
    });
    _.each(messageEffetCombat, function(effet, nomEffet) {
      if (effet.prejudiciable) {
        attr = tokenAttribute(cible, nomEffet);
        if (attr.length > 0) {
          printEffet(effet.fin);
          evt.deletedAttributes.push(attr[0]);
          attr[0].remove();
        }
      }
    });
    if (attributeAsBool(cible, 'malediction')) {
      printEffet("n'est plus maudite");
      removeTokenAttr(cible, 'malediction', evt);
    }
    //On enlève enfin les états préjudiciables
    if (getState(cible, 'aveugle')) {
      printEffet("retrouve la vue");
      setState(cible, 'aveugle', false, evt);
    }
    if (getState(cible, 'affaibli')) {
      printEffet("retrouve des forces");
      setState(cible, 'affaibli', false, evt);
    }
    if (getState(cible, 'etourdi')) {
      printEffet("retrouve ses esprits");
      setState(cible, 'etourdi', false, evt);
    }
    if (getState(cible, 'paralyse')) {
      printEffet("peut à nouveau bouger");
      setState(cible, 'paralyse', false, evt);
    }
    if (getState(cible, 'ralenti')) {
      printEffet("retrouve une vitesse normale");
      setState(cible, 'ralenti', false, evt);
    }
    if (getState(cible, 'endormi')) {
      printEffet("se réveille");
      setState(cible, 'endormi', false, evt);
    }
    if (getState(cible, 'apeure')) {
      printEffet("reprend courage");
      setState(cible, 'apeure', false, evt);
    }
    sendChat('', endFramedDisplay(display));
  }

  //!cof-guerison @{selected|token_id} @{target|token_id}
  function guerison(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-guerison attend le lanceur et la cible en argument", msg.content);
      return;
    }
    var lanceur = persoOfId(cmd[1], cmd[1], options.pageId);
    if (lanceur === undefined) {
      error("Le premier argument de !cof-guerison n'est pas un token valide", msg.content);
      return;
    }
    var cible = persoOfId(cmd[2], cmd[2], options.pageId);
    if (cible === undefined) {
      error("Le deuxième argument de !cof-guerison n'est pas un token valide", msg.content);
      return;
    }
    if (options.dose === undefined && options.decrAttribute === undefined) {
      options.limiteParJour = 1;
    }
    if (options.portee !== undefined) {
      var dist = distanceCombat(lanceur.token, cible.token, options.pageId);
      if (dist > options.portee) {
        sendChar(lanceur.charId, " est trop loin de " + cible.token.get('name'));
        return;
      }
    }
    var evt = {
      type: "Guérison",
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'guérison', 'guérison', evt)) return;
    updateCurrentBar(cible, 1, cible.token.get('bar1_max'), evt);
    if (getState(cible, 'blesse')) {
      setState(cible, 'blesse', false, evt);
    }
    var msgSoin;
    if (lanceur.token.id == cible.token.id) {
      msgSoin = 'se soigne';
    } else {
      msgSoin = 'soigne ' + cible.token.get('name');
    }
    msgSoin += ' de toutes les blessures subies';
    sendChar(lanceur.charId, msgSoin);
  }

  function armeDeContact(perso, arme, labelArmeDefaut, armeContact) {
    if (arme) return arme;
    arme = armesEnMain(perso);
    if (arme === undefined && labelArmeDefaut)
      arme = getWeaponStats(perso, labelArmeDefaut);
    //L'arme doit être une arme de contact ?
    if (armeContact && arme && arme.portee) {
      sendChar(perso.charId, armeContact + " " + arme.name + " est une arme à distance.");
      return;
    }
    if (arme) {
      return arme;
    }
    arme = {
      name: 'Attaque par défaut',
      attSkillDiv: 0,
      attSkill: "@{ATKCAC}",
      crit: 20,
      parDefaut: true,
    };
    return arme;
  }

  function attaqueContactOpposee(playerId, attaquant, defenseur, evt, options, callback) {
    var explications = [];
    options = options || {
      pasDeDmg: true
    };
    options.contact = true;
    attaquant.tokName = attaquant.tokName || attaquant.token.get('name');
    defenseur.tokName = defenseur.tokName || defenseur.token.get('name');
    if (attaquant.name === undefined) {
      var charAttaquant = getObj('character', attaquant.charId);
      if (charAttaquant === undefined) {
        error("Attaquant sans personnage", attaquant);
        return;
      }
      attaquant.name = charAttaquant.get('name');
    }
    if (defenseur.name === undefined) {
      var charDefenseur = getObj('character', defenseur.charId);
      if (charDefenseur === undefined) {
        error("Défenseur sans personnage", defenseur);
        return;
      }
      defenseur.name = charDefenseur.get('name');
    }
    entrerEnCombat(attaquant, [defenseur], explications, evt);
    //Recherche des armes utilisées
    var armeAttaquant = armeDeContact(attaquant, options.armeAttaquant, options.labelArmeAttaquant, options.armeAttaquantContact);
    var armeDefenseur = armeDeContact(defenseur, options.armeDefenseur, options.labelArmeDefenseur, options.armeDefenseurContact);
    var action = options.action || "<b>Attaque opposée</b>";
    if (!armeAttaquant.parDefaut) {
      action += " <span style='" + BS_LABEL + " " + BS_LABEL_INFO + "; text-transform: none; font-size: 100%;'>(" + armeAttaquant.name + ")</span>";
    }
    var display = startFramedDisplay(playerId, action, attaquant, {
      perso2: defenseur
    });
    var critAttaquant = critEnAttaque(attaquant, armeAttaquant, options);
    var dice = 20;
    var malusAttaque = 0;
    if (estAffaibli(attaquant)) {
      if (charAttributeAsBool(attaquant, 'insensibleAffaibli')) {
        malusAttaque = -2;
        explications.push("Attaquant affaibli, mais insensible => -2 en Attaque");
      } else {
        dice = 12;
        explications.push("Attaquant affaibli => D12 au lieu de D20 en Attaque");
      }
    } else if (getState(attaquant, 'immobilise')) {
      dice = 12;
      explications.push("Attaquant immobilisé => D12 au lieu de D20 en Attaque");
    }
    var toEvaluateAttack = attackExpression(attaquant, 1, dice, critAttaquant, true, armeAttaquant);
    sendChat('', toEvaluateAttack, function(resAttack) {
      var rollsAttack = resAttack[0];
      if (options.rolls && options.rolls.attack)
        rollsAttack = options.rolls.attack;
      var afterEvaluateAttack = rollsAttack.content.split(' ');
      var attRollNumber = rollNumber(afterEvaluateAttack[0]);
      var attSkillNumber = rollNumber(afterEvaluateAttack[1]);
      var d20rollAttaquant = rollsAttack.inlinerolls[attRollNumber].results.total;
      var attSkill = rollsAttack.inlinerolls[attSkillNumber].results.total;
      var attBonus =
        bonusAttaqueA(attaquant, armeAttaquant.name, evt, explications, options);
      attBonus += malusAttaque;
      var pageId = options.pageId || attaquant.token.get('pageid');
      attBonus +=
        bonusAttaqueD(attaquant, defenseur, 0, pageId, evt, explications, options);
      var attackRollAttaquant = d20rollAttaquant + attSkill + attBonus;
      var attRollValue = buildinline(rollsAttack.inlinerolls[attRollNumber]);
      attRollValue += (attSkill > 0) ? "+" + attSkill : (attSkill < 0) ? attSkill : "";
      attRollValue += (attBonus > 0) ? "+" + attBonus : (attBonus < 0) ? attBonus : "";
      if (options.bonusAttaqueAttaquant) {
        options.bonusAttaqueAttaquant.forEach(function(bad) {
          attRollValue += (bad.val > 0) ? "+" + bad.val : (bad.val < 0) ? bad.val : "";
          attackRollAttaquant += bad.val;
          if (bad.explication) explications.push(bad.explication);
        });
      }
      addLineToFramedDisplay(display, "Jet de " + attaquant.tokName + " : " + attRollValue);
      var critDefenseur = critEnAttaque(defenseur, armeDefenseur, options);
      dice = 20;
      malusAttaque = 0;
      if (estAffaibli(defenseur)) {
        if (charAttributeAsBool(defenseur, 'insensibleAffaibli')) {
          malusAttaque = -2;
          explications.push("Défenseur affaibli, mais insensible => -2 en Attaque");
        } else {
          dice = 12;
          explications.push("Défenseur affaibli => D12 au lieu de D20 en Attaque");
        }
      } else if (getState(defenseur, 'immobilise')) {
        dice = 12;
        explications.push("Défenseur immobilisé => D12 au lieu de D20 en Attaque");
      }
      toEvaluateAttack = attackExpression(defenseur, 1, dice, critDefenseur, true, armeDefenseur);
      sendChat('', toEvaluateAttack, function(resAttack) {
        var rollsAttack = resAttack[0];
        if (options.rolls && options.rolls.attackDefenseur)
          rollsAttack = options.rolls.attackDefenseur;
        afterEvaluateAttack = rollsAttack.content.split(' ');
        attRollNumber = rollNumber(afterEvaluateAttack[0]);
        attSkillNumber = rollNumber(afterEvaluateAttack[1]);
        var d20rollDefenseur = rollsAttack.inlinerolls[attRollNumber].results.total;
        attSkill = rollsAttack.inlinerolls[attSkillNumber].results.total;
        attBonus =
          bonusAttaqueA(defenseur, armeDefenseur.name, evt, explications, options);
        attBonus += malusAttaque;
        attBonus +=
          bonusAttaqueD(defenseur, attaquant, 0, pageId, evt, explications, options);
        var attackRollDefenseur = d20rollDefenseur + attSkill + attBonus;
        attRollValue = buildinline(rollsAttack.inlinerolls[attRollNumber]);
        attRollValue += (attSkill > 0) ? "+" + attSkill : (attSkill < 0) ? attSkill : "";
        attRollValue += (attBonus > 0) ? "+" + attBonus : (attBonus < 0) ? attBonus : "";
        if (options.bonusAttaqueDefenseur) {
          options.bonusAttaqueDefenseur.forEach(function(bad) {
            attRollValue += (bad.val > 0) ? "+" + bad.val : (bad.val < 0) ? bad.val : "";
            attackRollDefenseur += bad.val;
            if (bad.explication) explications.push(bad.explication);
          });
        }
        addLineToFramedDisplay(display, "Jet de " + defenseur.tokName + " : " + attRollValue);
        var resultat = {
          rollAttaquant: attackRollAttaquant,
          rollDefenseur: attackRollDefenseur,
          armeAttaquant: armeAttaquant
        };
        if (d20rollAttaquant == 1 && d20rollDefenseur > 1) {
          resultat.echec = true;
          resultat.echecCritique = true;
          diminueMalediction(attaquant, evt);
        } else if (d20rollDefenseur == 1 && d20rollAttaquant > 1) {
          resultat.succes = true;
          resultat.echecCritiqueDefenseur = true;
          diminueMalediction(defenseur, evt);
        } else if (d20rollAttaquant >= critAttaquant && d20rollDefenseur < critDefenseur) {
          resultat.succes = true;
          resultat.critique = true;
          diminueMalediction(defenseur, evt);
        } else if (d20rollAttaquant < critAttaquant && d20rollDefenseur >= critDefenseur) {
          resultat.succes = false;
          resultat.critiqueDefenseur = true;
          diminueMalediction(attaquant, evt);
        } else if (attackRollAttaquant < attackRollDefenseur) {
          resultat.echec = true;
          diminueMalediction(attaquant, evt);
        } else {
          resultat.succes = true;
          diminueMalediction(defenseur, evt);
        }
        callback(resultat, display, explications); //evt est mis à jour
      }); //fin du sendchat pour jet du défenseur
    }); //Fin du sendChat pour jet de l'attaquant
  }

  function testAttaqueOpposee(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il faut 2 personnages pour un test d'attaque en opposition", cmd);
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    var defenseur = persoOfId(cmd[2], cmd[2]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-test-attaque-opposee doit être un token valide", cmd[1]);
      return;
    }
    if (defenseur === undefined) {
      error("Le deuxième argument de !cof-test-attaque-opposee doit être un token valide", cmd[2]);
      return;
    }
    var evt = {
      type: "Test d'attaque opposée"
    };
    var options = {
      pasDeDmg: true
    };
    if (cmd.length > 3) options.labelArmeAttaquant = cmd[3];
    var playerId = getPlayerIdFromMsg(msg);
    attaqueContactOpposee(playerId, attaquant, defenseur, evt, options,
      function(res, display, explications) {
        if (res.succes)
          addLineToFramedDisplay(display, attaquant.tokName + " remporte le test");
        else
          addLineToFramedDisplay(display, defenseur.tokName + " remporte le test");
        explications.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
        sendChat("", endFramedDisplay(display));
        addEvent(evt);
      });
  }

  //!cof-desarmer attaquant cible, optionellement un label d'arme
  function desarmer(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il manque des arguments à !cof-desarmer", msg.content);
      return;
    }
    var guerrier = persoOfId(cmd[1], cmd[1]);
    if (guerrier === undefined) {
      error("Le premier argument de !cof-desarmer n'est pas un token valide", cmd);
      return;
    }
    guerrier.tokName = guerrier.token.get('name');
    var cible = persoOfId(cmd[2], cmd[2]);
    if (cible === undefined) {
      error("Le deuxième argument de !cof-desarmer n'est pas un token valide", cmd);
      return;
    }
    cible.tokName = cible.token.get('name');
    var pageId = guerrier.token.get('pageid');
    if (distanceCombat(guerrier.token, cible.token, pageId)) {
      sendChar(guerrier.charId, "est trop loin de " + cible.tokName + " pour le désarmer.");
      return;
    }
    var options = {
      action: "<b>Désarmement</b>",
      armeContact: "doit porter une arme de contact pour désarmer son adversaire.",
      pasDeDmg: true,
      pageId: pageId,
    };
    //On cherche l'arme de la cible. On en aura besoin pour désarmer
    var armeCible;
    var attrArmeCible = tokenAttribute(cible, 'armeEnMain');
    if (attrArmeCible.length > 0) {
      attrArmeCible = attrArmeCible[0];
      armeCible = getWeaponStats(cible, attrArmeCible.get('current'));
      if (armeCible) {
        options.armeDefenseur = armeCible;
        if (armeCible.deuxMains) {
          options.bonusAttaqueDefenseur = [{
            val: 5,
            explication: cible.tokName + " porte une arme à 2 mains => +5 à son jet"
          }];
        }
      }
    } else attrArmeCible = undefined;
    var enleverArmeCible = function() {
      if (attrArmeCible) {
        evt.deletedAttributes = evt.deletedAttributes || [];
        evt.deletedAttributes.push(attrArmeCible);
        attrArmeCible.remove();
      }
    };
    var evt = {
      type: 'Désarmer'
    };
    if (cmd.length > 3) options.labelArmeAttaquant = cmd[3];
    var playerId = getPlayerIdFromMsg(msg);
    attaqueContactOpposee(playerId, guerrier, cible, evt, options,
      function(res, display, explications) {
        var resultat;
        if (res.echecCritique) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_DANGER + "'><b>échec&nbsp;critique</b></span>";
        } else if (res.echecCritiqueDefenseur) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succès</b></span>, " + cible.tokName + " laisse tomber son arme, difficile de la récupérer...";
          enleverArmeCible();
        } else if (res.critique) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>réussite critique</b></span> : " + cible.tokName + " est désarmé, et " + guerrier.tokName + " empêche de reprendre l'arme";
          enleverArmeCible();
        } else if (res.critiqueDefenseur) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>échec</b></span>, " + cible.tokName + " garde son arme bien en main";
        } else if (res.echec) {
          resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_WARNING + "'><b>échec</b></span>, " + guerrier.tokName + " n'a pas réussi à désarmer son adversaire";
        } else { //succès
          enleverArmeCible();
          if (res.rollAttaquant > res.rollDefenseur + 9) {
            resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succès</b></span>, " + guerrier.tokName + " désarme son adversaire et l'empêche de récupérer son arme";
          } else {
            resultat = "<span style='" + BS_LABEL + " " + BS_LABEL_SUCCESS + "'><b>succès</b></span>, " + guerrier.tokName + " désarme son adversaire.";
          }
        }
        addLineToFramedDisplay(display, resultat);
        explications.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
        sendChat("", endFramedDisplay(display));
        addEvent(evt);
      });
  }

  function appliquerBloquer(attaquant, cible, critique, evt, envoyerMessage) {
    var msg;
    if (envoyerMessage) msg = "est bloqué par son adversaire";
    setAttrDuree(cible, 'bloqueManoeuvre', 1, evt, msg);
    if (critique)
      appliquerTenirADistance(attaquant, cible, false, evt, envoyerMessage);
  }

  function appliquerTenirADistance(attaquant, cible, critique, evt, envoyerMessage) {
    var msg;
    if (envoyerMessage) msg = "est tenu à distance par son adversaire";
    setAttrDuree(
      cible, 'tenuADistanceManoeuvre(' + attaquant.token.id + ')', 1, evt, msg);
    if (critique) appliquerBloquer(attaquant, cible, false, evt, envoyerMessage);
  }

  var listeManoeuvres = {
    aveugler: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var duree = 1;
        if (critique) duree = randomInteger(6);
        var msg;
        if (envoyerMessage) msg = "est aveuglé par son adversaire";
        setAttrDuree(
          cible, 'aveugleManoeuvre', duree, evt, msg);
        return critique; //Pour les DMs en plus
      },
      verbe: 'aveugler',
      duelliste: false
    },
    bloquer: {
      appliquer: appliquerBloquer,
      penalitePlusPetit: true,
      verbe: 'bloquer',
      duelliste: true
    },
    desarmer: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var attrArmeCible = tokenAttribute(cible, 'armeEnMain');
        if (attrArmeCible.length > 0) {
          attrArmeCible = attrArmeCible[0];
          evt.deletedAttributes = evt.deletedAttributes || [];
          evt.deletedAttributes.push(attrArmeCible);
          attrArmeCible.remove();
        }
        if (envoyerMessage) {
          var msgDesarme = "est désarmé" + onGenre(cible, '', 'e');
          if (critique) msgDesarme += ", son adversaire lui a pris son arme.";
          else msgDesarme += ".";
          sendChar(cible.charId, msgDesarme);
        }
      },
      verbe: 'désarmer',
      duelliste: true
    },
    faireDiversion: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var msg;
        if (envoyerMessage) msg = "a son attention attirée ailleurs";
        var malus = -5;
        if (critique) malus = -10;
        setAttrDuree(cible, 'diversionManoeuvre', 1, evt, msg);
        setTokenAttr(cible, 'diversionManoeuvreValeur', malus, evt);
      },
      verbe: 'faire diversion sur',
      duelliste: false
    },
    menacer: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var msg;
        if (envoyerMessage) msg = "est sous le coup d'une menace";
        var effet = 'menaceManoeuvre(' + attaquant.token.id;
        if (critique) effet += ',crit';
        effet += ')';
        setAttrDuree(cible, effet, 1, evt, msg);
      },
      verbe: 'menacer',
      duelliste: false
    },
    renverser: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        if (envoyerMessage) sendChar(cible.charId, "tombe au sol");
        setState(cible, 'renverse', true, evt);
        return critique; //Pour les DM en plus
      },
      penalitePlusPetit: true,
      verbe: 'renverser',
      duelliste: true
    },
    repousser: {
      appliquer: function(attaquant, cible, critique, evt, envoyerMessage) {
        var distance = rollDePlus(6);
        if (critique && distance < 3) distance = 3;
        if (envoyerMessage)
          sendChar(cible.charId, "est repoussé" + onGenre(cible, '', 'e') + " et doit reculer de " + distance.roll + "m.");
        if (critique) setState(cible, 'renverse', true, evt);
      },
      penalitePlusPetit: true,
      verbe: 'repousser',
      duelliste: true
    },
    tenirADistance: {
      appliquer: appliquerTenirADistance,
      verbe: 'tenir à distance',
      duelliste: true
    }
  };

  //!cof-appliquer-manoeuvre id1 id2 effet attrId
  //attrId est utilisé pour limiter le nombre d'utilisations
  function appliquerManoeuvre(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 5) {
      error("cof-appliquer-manoeuvre attend 4 arguments", msg.content);
      return;
    }
    if (!_.has(listeManoeuvres, cmd[3])) {
      error("Manoeuvre " + cmd[3] + " inconnue.", cmd);
      return;
    }
    var limiteAttr = getObj('attribute', cmd[4]);
    if (limiteAttr === undefined) {
      sendPlayer(msg, "La manoeuvre a déjà été choisie");
      return;
    }
    var attaquant = persoOfId(cmd[1], cmd[1]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-appliquer-maneuvre n'est pas un token valide", cmd);
      return;
    }
    var cible = persoOfId(cmd[2], cmd[2]);
    if (cible === undefined) {
      error("Le deuxième argument de !cof-appliquer-manoeuvre n'est pas un token valide", cmd);
      return;
    }
    var effet = listeManoeuvres[cmd[3]];
    var evt = {
      type: 'Application de manoeuvre',
      deletedAttributes: [limiteAttr]
    };
    limiteAttr.remove();
    effet.appliquer(attaquant, cible, false, evt, true);
    addEvent(evt);
  }

  //!cof-manoeuvre id1 id2 effet
  function manoeuvreRisquee(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    options.pasDeDmg = true;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 4) {
      error("cof-manoeuvre attend 3 arguments", msg.content);
      return;
    }
    if (!_.has(listeManoeuvres, cmd[3])) {
      sendPlayer(msg, "Manoeuvre " + cmd[3] + " inconnue.");
      return;
    }
    var effet = listeManoeuvres[cmd[3]];
    var attaquant = persoOfId(cmd[1], cmd[1]);
    if (attaquant === undefined) {
      error("Le premier argument de !cof-maneuvre n'est pas un token valide", cmd);
      return;
    }
    attaquant.tokName = attaquant.token.get('name');
    var cible = persoOfId(cmd[2], cmd[2]);
    if (cible === undefined) {
      error("Le deuxième argument de !cof-manoeuvre n'est pas un token valide", cmd);
      return;
    }
    cible.tokName = cible.token.get('name');
    var evt = {
      type: 'manoeuvre'
    };
    if (effet.penalitePlusPetit) {
      var tailleAttaquant = taillePersonnage(attaquant);
      var tailleCible = taillePersonnage(cible);
      if (tailleAttaquant && tailleCible && tailleAttaquant < tailleCible) {
        var penalite = 5 * (tailleAttaquant - tailleCible);
        options.bonusAttaqueAttaquant = [{
          val: penalite,
          explication: attaquant.tokName + " est plus petit que " + cible.tokName + " => " + penalite + " Att"
        }];
      }
    }
    var playerId = getPlayerIdFromMsg(msg);
    var manoeuvreDuelliste = effet.duelliste && charAttributeAsBool(attaquant, 'manoeuvreDuelliste');
    attaqueContactOpposee(playerId, attaquant, cible, evt, options,
      function(res, display, explications) {
        var dmSupp;
        if (res.succes) {
          addLineToFramedDisplay(display, attaquant.tokName + " réussi à " + effet.verbe + " " + cible.tokName);
          dmSupp = effet.appliquer(attaquant, cible, res.critique, evt);
          if (manoeuvreDuelliste && !dmSupp) {
            var pageId = cible.token.get('pageid');
            var defense = defenseOfPerso(attaquant, cible, pageId, evt, options);
            dmSupp = res.rollAttaquant >= defense + 10;
          }
        } else {
          addLineToFramedDisplay(display, attaquant.tokName + " ne réussi pas à " + effet.verbe + " " + cible.tokName);
          //Envoyer à la cible la possibilité d'appliquer un effet de son choix
        }
        explications.forEach(function(expl) {
          addLineToFramedDisplay(display, expl, 80);
        });
        if (dmSupp) {
          addLineToFramedDisplay(display, attaquant.tokName + " fait en plus des dégâts à " + cible.tokName + " (lancer une attaque pour déterminer le montant)", 80);
          setTokenAttr(attaquant, 'attaqueGratuiteAutomatique(' + cible.token.id + ')', true, evt);
        }
        sendChat("", endFramedDisplay(display));
        addEvent(evt);
        /*if (dmSupp) {
           turnAction(attaquant, playerId);
        }*/
        if (!res.succes && !manoeuvreDuelliste) {
          var charCible = getObj('character', cible.charId);
          if (charCible === undefined) {
            error("Cible sans personnage associé", cible);
            return;
          }
          var titre = "Choisir un effet contre " + attaquant.tokName;
          //On crée un display sans le header
          display = startFramedDisplay(undefined, titre, cible, {
            retarde: true
          });
          //Attribut pour empecher plusieurs utilisations
          var attrLimit = createObj('attribute', {
            _characterid: cible.charId,
            name: 'limiteApplicationManoeuvre',
            current: '1'
          });
          for (var man in listeManoeuvres) {
            var appliquerManoeuvre = '!cof-appliquer-manoeuvre ' + cible.token.id + ' ' + attaquant.token.id + ' ' + man + ' ' + attrLimit.id;
            var ligneManoeuvre = boutonSimple(appliquerManoeuvre, man);
            addLineToFramedDisplay(display, ligneManoeuvre, 90);
          }
          // on envoie la liste aux joueurs qui gèrent le voleur
          var playerIds = getPlayerIds(cible);
          playerIds.forEach(function(playerid) {
            addFramedHeader(display, playerid, true);
            sendChat('', endFramedDisplay(display));
          });
          if (playerIds.length === 0) {
            addFramedHeader(display, undefined, 'gm');
            sendChat('', endFramedDisplay(display));
          }
        }
      });
  }

  function sendCommands(from, commands) {
    if (commands.length === 0) return;
    var c = commands.shift();
    if (c.startsWith('!')) {
      _.delay(function() {
        sendChat(from, c);
        sendCommands(from, commands);
      }, 10);
    } else error("multi-commande invalide", c);
  }

  //!cof-multi-command !cmd1 ... --cof-multi-command !cmd2 .. --cof-multi-command !cmd3...
  function multiCommand(msg) {
    var posFirstCommand = msg.content.indexOf('!', 2);
    var commands = msg.content.substr(posFirstCommand).split(' --cof-multi-command ');
    sendCommands(msg.who, commands);
    /* commands.forEach(function(c) {
       if (c.startsWith('!')) sendChat(msg.who, c);
       else error("multi-commande invalide", c);
     });*/
  }

  //Crée un nouveau personnage (de type PNJ par défaut)
  //spec contient les charactéristiques, attributs et abilities
  //  - attributesFiche contient les attributs définis dans la fiche
  //      nom_attribut: valeur
  //  - pv (permet d'être indépendant de PJ ou PNJ)
  //  - attaques, liste d'attaques, chacune avec (nom, atk, nbde, dmde, dm,...)
  //  - attributes autres attributs (name, current, max)
  //  - abilities (name, action), toujours rajoutées à la liste d'actions
  function createCharacter(nom, playerId, avatar, token, spec) {
    var res = createObj('character', {
      name: nom,
      avatar: avatar,
      controlledby: playerId
    });
    if (!res) return;
    var charId = res.id;
    if (token) {
      token.set('represents', charId);
    }
    var attrs = findObjs({
      _type: 'attribute',
      _characterid: charId,
    });
    var attrVersion =
      attrs.find(function(a) {
        return a.get('name').toLowerCase() == 'version';
      });
    if (!attrVersion) {
      createObj('attribute', {
        _characterid: charId,
        name: 'version',
        current: '4.04'
      });
    }
    var pnj = true;
    if (spec.attributesFiche) {
      if (spec.attributesFiche.type_personnage == 'PJ') pnj = false;
      for (var attrName in spec.attributesFiche) {
        /*jshint loopfunc: true */
        var attr =
          attrs.filter(function(a) {
            return a.get('name') == attrName;
          });
        if (attr.length === 0) {
          createObj('attribute', {
            _characterid: charId,
            name: attrName,
            current: spec.attributesFiche[attrName]
          });
        } else {
          attr[0].set('current', spec.attributesFiche[attrName]);
        }
      }
    } //end attributesFiche
    if (pnj) {
      createObj('attribute', {
        _characterid: charId,
        name: 'tab',
        current: 'carac. pnj'
      });
    }
    if (spec.pv) {
      var pvAttr = attrs.filter(function(a) {
        return a.get('name').toUpperCase() == 'PV';
      });
      if (pvAttr.length === 0) {
        pvAttr = createObj('attribute', {
          _characterid: charId,
          name: 'PV',
          current: spec.pv,
          max: spec.pv
        });
      } else {
        pvAttr = pvAttr[0];
        pvAttr.set('current', spec.pv);
        pvAttr.set('max', spec.pv);
      }
      if (pnj) {
        pvAttr = attrs.filter(function(a) {
          return a.get('name').toLowerCase() == 'pnj_pv';
        });
        if (pvAttr.length === 0) {
          pvAttr = createObj('attribute', {
            _characterid: charId,
            name: 'pnj_pv',
            current: spec.pv,
            max: spec.pv
          });
        } else {
          pvAttr = pvAttr[0];
          pvAttr.set('current', spec.pv);
          pvAttr.set('max', spec.pv);
        }
      }
      if (token) {
        token.set('bar1_link', pvAttr.id);
        token.set('bar1_value', spec.pv);
        token.set('bar1_max', spec.pv);
      }
    }
    var actions = '';
    if (spec.actions) actions = spec.actions;
    if (spec.attaques) {
      var maxAttackLabel = 0;
      var prefix_attaques = 'repeating_armes_';
      if (pnj) prefix_attaques = 'repeating_pnjatk_';
      spec.attaques.forEach(function(att) {
        var id = generateRowID();
        var pref = prefix_attaques + id + '_arme';
        _.forEach(att, function(value, field) {
          createObj('attribute', {
            _characterid: charId,
            name: pref + field,
            current: value
          });
        });
        maxAttackLabel++;
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'label',
          current: maxAttackLabel
        });
      });
      createObj('attribute', {
        _characterid: charId,
        name: 'max_attack_label',
        current: maxAttackLabel
      });
    }
    if (spec.attributes) {
      spec.attributes.forEach(function(a) {
        a._characterid = charId;
        createObj('attribute', a);
      });
    }
    if (spec.abilities) {
      spec.abilities.forEach(function(a) {
        a._characterid = charId;
        a.istokenaction = true;
        createObj('ability', a);
        actions += '%' + a.name + ' ';
      });
    }
    createObj('ability', {
      _characterid: charId,
      name: '#Actions#',
      istokenaction: false,
      action: actions
    });
    if (token) setDefaultTokenForCharacter(res, token);
    return res;
  }

  var predateurs = {
    loup: {
      nom: 'Loup',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59094468/bX_aTjrVAbIRHjpRn-HwdQ/max.jpg?1532611383",
      token: "https://s3.amazonaws.com/files.d20.io/images/59489165/3R9Ob68sTiqvNeEhwzwWcg/thumb.png?1533047142",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 1,
        force: 12,
        pnj_for: 1,
        dexterite: 12,
        pnj_dex: 1,
        constitution: 12,
        pnj_con: 1,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 3,
        pnj_def: 14,
        pnj_init: 12,
        race: 'loup',
        taille: 'moyen'
      },
      pv: 9,
      attaques: [{
        nom: 'Morsure',
        atk: 2,
        dmnbde: 1,
        dmde: 6,
        dm: 1,
      }],
      attributes: [],
      abilities: []
    },
    loupAlpha: {
      nom: 'Loup alpha',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59094818/J0yWdxryZFKakJtNGJNNvw/max.jpg?1532612061",
      token: "https://s3.amazonaws.com/files.d20.io/images/60183959/QAMH6WtyoK78aa4zX_mR_Q/thumb.png?1533898482",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 2,
        force: 16,
        pnj_for: 3,
        dexterite: 12,
        pnj_dex: 1,
        constitution: 16,
        pnj_con: 3,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 4,
        pnj_def: 15,
        INIT_DIV: 5,
        pnj_init: 17,
        race: 'loup',
        taille: 'moyen'
      },
      pv: 15,
      attaques: [{
        nom: 'Morsure',
        atk: 4,
        nbde: 1,
        dmde: 6,
        dm: 3,
      }],
      attributes: [{
        name: 'discrétion',
        current: 5
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]] --target @{target|token_id}'
      }, {
        name: 'Attaque-embuscade',
        action: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }]
    },
    worg: {
      nom: 'Grand loup',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/25294798/4dJ_60uP2mw6UJA2elkoXA/max.jpg?1479223790",
      token: "https://s3.amazonaws.com/files.d20.io/images/60184237/smG5o2-siD2pChhPblO_sQ/thumb.png?1533899118",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 3,
        force: 16,
        pnj_for: 3,
        dexterite: 12,
        pnj_dex: 1,
        constitution: 16,
        pnj_con: 3,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 4,
        pnj_int: -3,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 6,
        pnj_def: 17,
        INIT_DIV: 5,
        pnj_init: 17,
        race: 'loup',
        taille: 'moyen'
      },
      pv: 35,
      attaques: [{
        nom: 'Morsure',
        atk: 6,
        dmnbde: 1,
        dmde: 6,
        dm: 5,
      }],
      attributes: [{
        name: 'discrétion',
        current: 5
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]'
      }, {
        name: 'Attaque-embuscade',
        action: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif'
      }]
    },
    lion: {
      nom: 'Lion',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486104/SngxPIGXDJKdCqsbrXxRYQ/max.jpg?1533041390",
      token: "https://s3.amazonaws.com/files.d20.io/images/60184437/df1MT2T6lrfo7st02Htxeg/thumb.png?1533899407",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 4,
        force: 20,
        pnj_for: 5,
        dexterite: 18,
        pnj_dex: 4,
        dex_sup: '@{jetsup}',
        pnj_dex_sup: 'on',
        constitution: 20,
        pnj_con: 5,
        intelligence: 4,
        pnj_int: -3,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 6,
        pnj_cha: -3,
        DEFDIV: 4,
        pnj_def: 18,
        INIT_DIV: 5,
        pnj_init: 23,
        race: 'lion',
        taille: 'grand'
      },
      pv: 30,
      attaques: [{
        nom: 'Morsure',
        atk: 7,
        dmnbde: 2,
        dmde: 6,
        dm: 5,
      }],
      attributes: [{
        name: 'discrétion',
        current: 5
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]'
      }, {
        name: 'Attaque-embuscade',
        action: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif --if deAttaque 15 --message @{selected|token_name} saisit sa proie entre ses crocs et peut faire une attaque gratuite --if moins FOR --etat immobilise FOR @{selected|token_id} --endif --endif'
      }, {
        name: 'Dévorer',
        action: '!cof-attack @{selected|token_id} @{target|token_id} 1 --if deAttaque 15 --message @{selected|token_name} saisit sa proie entre ses crocs et peut faire une attaque gratuite --if moins FOR --etat renverse --etat immobilise FOR @{selected|token_id} --endif --endif'
      }]
    },
    grandLion: {
      nom: 'Grand lion',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486144/8wHs_5WfEIeL_7dKbALHHA/max.jpg?1533041459",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186141/mUZzndi9_sYIzdVVNNka_w/thumb.png?1533903070",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 5,
        force: 22,
        pnj_for: 6,
        dexterite: 18,
        pnj_dex: 3,
        dex_sup: '@{jetsup}',
        pnj_dex_sup: 'on',
        constitution: 20,
        pnj_con: 5,
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 14,
        pnj_cha: 2,
        DEFDIV: 6,
        pnj_def: 20,
        pnj_init: 18,
        race: 'lion',
        taille: 'grand'
      },
      pv: 50,
      attaques: [{
        nom: 'Morsure',
        atk: 9,
        dmnbde: 2,
        dmde: 6,
        dm: 7,
      }],
      attributes: [{
        name: 'discrétion',
        current: 5
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]'
      }, {
        name: 'Attaque-embuscade',
        action: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif --if deAttaque 15 --message @{selected|token_name} saisit sa proie entre ses crocs et peut faire une attaque gratuite --if moins FOR --etat immobilise FOR @{selected|token_id} --endif --endif'
      }, {
        name: 'Dévorer',
        action: '!cof-attack @{selected|token_id} @{target|token_id} 1 --if deAttaque 15 --message @{selected|token_name} saisit sa proie entre ses crocs et peut faire une attaque gratuite --if moins FOR --etat renverse --etat immobilise FOR @{selected|token_id} --endif --endif'
      }]
    },
    oursPolaire: {
      nom: 'Ours polaire',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486216/UssilagWK_2dfVGuPABBpA/max.png?1533041591",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186288/B1uAii9G01GcPfQFNozIbw/thumb.png?1533903333",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 6,
        force: 26,
        pnj_for: 8,
        for_sup: '@{jetsup}',
        pnj_for_sup: 'on',
        dexterite: 11,
        pnj_dex: 0,
        constitution: 26,
        pnj_con: 8,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 10,
        pnj_def: 20,
        pnj_init: 11,
        race: 'ours',
        taille: 'grand'
      },
      pv: 70,
      attaques: [{
        nom: 'Morsure',
        atk: 12,
        dmnbde: 2,
        dmde: 8,
        dm: 7,
      }],
      attributes: [{
        name: 'peutEnrager',
        current: 'true'
      }],
      abilities: [{
        name: 'Charge',
        action: '!cof-attack @{selected|token_id} @{target|token_id} 1 --m2d20 --pietine}'
      }, ]
    },
    tigreDentsDeSabre: {
      nom: 'Tigre à dents de sabre',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486272/f5lUcN3Y9H0thmJPrqa6FQ/max.png?1533041702",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186469/ShcrgpvgXKiQsLVOyg4SZQ/thumb.png?1533903741",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 7,
        force: 26,
        pnj_for: 8,
        for_sup: '@{jetsup}',
        pnj_for_sup: 'on',
        dexterite: 18,
        pnj_dex: 4,
        dex_sup: '@{jetsup}',
        pnj_dex_sup: 'on',
        constitution: 26,
        pnj_con: 8,
        intelligence: 2,
        pnj_int: -4,
        sagesse: 12,
        pnj_sag: 1,
        sag_sup: '@{jetsup}',
        pnj_sag_sup: 'on',
        charisme: 2,
        pnj_cha: -4,
        DEFDIV: 8,
        pnj_def: 22,
        pnj_init: 18,
        race: 'tigre',
        taille: 'grand'
      },
      pv: 90,
      attaques: [{
        nom: 'Morsure',
        atk: 14,
        dmnbde: 2,
        dmde: 6,
        dm: 12,
      }],
      attributes: [{
        name: 'discrétion',
        current: 5
      }],
      abilities: [{
        name: 'Embuscade',
        action: '!cof-surprise [[15 + @{selected|DEX}]]'
      }, {
        name: 'Attaque-embuscade',
        action: '!cof-attack @{selected|token_id} @{target|token_id} 1 --sournoise 1 --if moins FOR --etat renverse --endif --if deAttaque 15 --message @{selected|token_name} saisit sa proie entre ses crocs et peut faire une attaque gratuite --if moins FOR --etat immobilise FOR @{selected|token_id} --endif --endif'
      }, {
        name: 'Dévorer',
        action: '!cof-attack @{selected|token_id} @{target|token_id} 1 --if deAttaque 15 --message @{selected|token_name} saisit sa proie entre ses crocs et peut faire une attaque gratuite --if moins FOR --etat renverse --etat immobilise FOR @{selected|token_id} --endif --endif'
      }]
    },
    oursPrehistorique: {
      nom: 'Ours préhistorique',
      avatar: "https://s3.amazonaws.com/files.d20.io/images/59486323/V6RVSlBbeRJi_aIaIuGGBw/max.png?1533041814",
      token: "https://s3.amazonaws.com/files.d20.io/images/60186633/lNHXvCOsvfPMZDQnqJKQVw/thumb.png?1533904189",
      attributesFiche: {
        type_personnage: 'PNJ',
        niveau: 8,
        force: 32,
        pnj_for: 11,
        dexterite: 10,
        pnj_dex: 0,
        constitution: 32,
        pnj_con: 11,
        con_sup: '@{jetsup}',
        pnj_con_sup: 'on',
        intelligence: 2,
        pnj_int: -4,
        sagesse: 14,
        pnj_sag: 2,
        charisme: 6,
        pnj_cha: -2,
        DEFDIV: 12,
        pnj_def: 22,
        pnj_init: 10,
        RDS: 2,
        race: 'ours',
        taille: 'énorme'
      },
      pv: 110,
      attaques: [{
        nom: 'Griffes',
        atk: 17,
        dmnbde: 3,
        dmde: 6,
        dm: 13,
      }],
      attributes: [{
        name: 'fauchage',
        current: 'true'
      }],
      abilities: [{
        name: 'Charge',
        action: '!cof-attack @{selected|token_id} @{target|token_id} 1 --m2d20 --pietine}'
      }, ]
    }
  };

  function conjurationPredateur(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Pas de commande", msg.content);
      return;
    }
    var renforce = 0;
    if (cmd.length > 1) {
      renforce = parseInt(cmd[1]);
      if (isNaN(renforce)) {
        error("Il faut un nombre comme premier argument de !cof-conjuration-de-predateur");
        renforce = 0;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        error("pas de lanceur pour la conjuration de prédateurs", msg);
        return;
      }
      var evt = {
        type: 'conjuration de prédateurs'
      };
      initiative(selected, evt);
      iterSelected(selected, function(invocateur) {
        var pageId = invocateur.token.get('pageid');
        var niveau = ficheAttributeAsInt(invocateur, 'niveau', 1);
        if (!renforce) {
          renforce = charAttributeAsInt(invocateur, 'voieDeLaConjuration', 0);
          if (renforce == 1) renforce = 0;
        }
        niveau += renforce;
        var predateur;
        if (niveau < 5) predateur = predateurs.loup;
        else if (niveau < 9) predateur = predateurs.loupAlpha;
        else if (niveau < 12) predateur = predateurs.worg;
        else if (niveau < 15) predateur = predateurs.lion;
        else if (niveau < 18) predateur = predateurs.grandLion;
        else if (niveau < 21) predateur = predateurs.oursPolaire;
        else if (niveau < 23) predateur = predateurs.tigreDentsDeSabre;
        else predateur = predateurs.oursPrehistorique;
        var nomPredateur =
          predateur.nom + ' de ' + invocateur.token.get('name');
        var token = createObj('graphic', {
          name: nomPredateur,
          subtype: 'token',
          pageid: pageId,
          imgsrc: predateur.token,
          left: invocateur.token.get('left'),
          top: invocateur.token.get('top'),
          width: 70,
          height: 70,
          layer: 'objects',
          showname: 'true',
          showplayers_bar1: 'true',
          light_hassight: 'true',
          light_angle: 0, //Pour que le joueur ne voit rien par ses yeux
          has_bright_light_vision: true,
          has_limit_field_of_vision: true,
        });
        toFront(token);
        var charPredateur =
          createCharacter(nomPredateur, playerId, predateur.avatar, token, predateur);
        //Tous les prédateurs sont des quadrupèdes
        createObj('attribute', {
          name: 'quadrupede',
          _characterid: charPredateur.id,
          current: true
        });
        //Attribut de predateur conjuré pour la disparition automatique
        createObj('attribute', {
          name: 'predateurConjure',
          _characterid: charPredateur.id,
          current: 5 + modCarac(invocateur, 'charisme'),
          max: getInit()
        });
        evt.characters = [charPredateur];
        evt.tokens = [token];
        initiative([{
          _id: token.id
        }], evt);
      }); //end iterSelected
      addEvent(evt);
    }); //end getSelected
  }

  //!cof-conjuration-armee [dé de DM] --limiteParJour...
  function conjurationArmee(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Problème de parse options", msg.content);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Il faut sélectionner le lanceur de la conjuration d'arméé");
        return;
      }
      iterSelected(selected, function(invocateur) {
        var pageId = invocateur.token.get('pageid');
        var niveau = ficheAttributeAsInt(invocateur, 'niveau', 1);
        var evt = {
          type: "Conjuration d'armée"
        };
        if (limiteRessources(invocateur, options, 'conjurationArmee', "conjurer une armée", evt)) {
          addEvent(evt);
          return;
        }
        var deDM;
        var nbDeDM;
        if (cmd.length > 1) {
          var argDe = cmd[1].split(/d/i);
          if (argDe.length == 2) {
            nbDeDM = parseInt(argDe[0]);
            if (isNaN(nbDeDM) || nbDeDM < 1) nbDeDM = undefined;
            else {
              deDM = parseInt(argDe[1]);
              if (isNaN(deDM) || deDM < 1) deDM = undefined;
            }
          }
        }
        if (deDM === undefined) {
          var rang = charAttributeAsInt(invocateur, 'voieDeLaConjuration', 3);
          if (rang <= 3) {
            deDM = 6;
            nbDeDM = 1;
          } else if (rang == 4) {
            deDM = 10;
            nbDeDM = 1;
          } else {
            deDM = 6;
            nbDeDM = 2;
          }
        }
        var nomArmee = "Armée de " + invocateur.token.get('name');
        var token = createObj('graphic', {
          name: nomArmee,
          subtype: 'token',
          pageid: pageId,
          imgsrc: 'https://s3.amazonaws.com/files.d20.io/images/73283129/-jrKAyQQ1P7zpD09xeTbXw/thumb.png?1549546953',
          left: invocateur.token.get('left'),
          top: invocateur.token.get('top'),
          width: 70,
          height: 70,
          layer: 'objects',
          showname: 'true',
          showplayers_bar1: 'true',
          light_hassight: 'true',
          light_angle: 0, //Pour que le joueur ne voit rien par ses yeux
          has_bright_light_vision: true,
          has_limit_field_of_vision: true,
          aura1_radius: 10,
          aura1_color: "#d56eef",
          aura1_square: true
        });
        toFront(token);
        var avatar = "https://s3.amazonaws.com/files.d20.io/images/73283254/r6sbxbP1QKKtqXyYq-MlLA/max.png?1549547198";
        var attaque = {
          nom: 'Attaque',
          dmnbde: nbDeDM,
          dmde: deDM,
          modificateurs: 'auto',
        };
        var attributes = [{
          name: 'armeeConjuree',
          current: invocateur.charId
        }];
        var charArmee =
          createCharacter(nomArmee, playerId, avatar, token, {
            pv: niveau * 10,
            attaques: [attaque],
            attributes: attributes
          });
        evt.characters = [charArmee];
        evt.tokens = [token];
        if (stateCOF.combat) {
          initiative([{
            _id: token.id
          }], evt);
        }
      });
    });
  }

  function tenebres(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("!cof-tenebres mal formé, il faut un token comme premier argument", msg.content);
      return;
    }
    var necromant = persoOfId(cmd[1], cmd[1], options.pageId);
    if (necromant === undefined) {
      error("Le premier argument de !cof-animer-arbre n'est pas un token valie", cmd);
      return;
    }
    options.lanceur = necromant;
    getSelected(msg, function(selected, playerId, centre) {
      var evt = {
        type: 'tenebres'
      };
      addEvent(evt);
      if (limiteRessources(necromant, options, 'tenebres', 'lancer un sort de ténèbres', evt)) return;
      if (!stateCOF.combat) {
        initPerso(necromant, evt);
      }

      var tokenTenebres = "Ténèbres de " + necromant.token.get('name');
      var token = necromant.token;
      if (centre) {
        token = createObj('graphic', {
          name: tokenTenebres,
          showname: true,
          subtype: 'token',
          pageid: options.pageId,
          imgsrc: 'https://s3.amazonaws.com/files.d20.io/images/192072874/eJXFx20fD931DuBDvzAnQQ/thumb.png?1610469273',
          left: centre.left,
          top: centre.top,
          width: 70,
          height: 70,
          layer: 'objects',
          aura1_radius: 0,
          aura1_color: "#c1c114",
          aura1_square: true,
          aura2_radius: scaleDistance(necromant, 5),
          aura2_color: "#000000",
          showplayers_aura2: true
        });
        evt.tokens = [token];
      }
      var duree = 5 + modCarac(necromant, "intelligence");
      if (stateCOF.options.affichage.val.duree_effets.val) {
        sendChar(necromant.charId, "lance un sort de ténèbres pour " + duree + "tours");
      }
      var effetAveugle = {
        effet: 'aveugleTemp',
        duree: duree
      };
      iterSelected(selected, function(perso) {
        setEffetTemporaire(perso, effetAveugle, duree, undefined, options.pageId, evt, {});
      });
      var effetTenebres = {
        effet: 'tenebres',
        duree: duree,
        valeur: token.id,
        pasDeMessageDActivation: true
      };
      setEffetTemporaire(necromant, effetTenebres, duree, necromant, options.pageId, evt, options);
    }, options);
  }

  var demonInvoque = {
    nom: 'Démon',
    avatar: "https://s3.amazonaws.com/files.d20.io/images/183633585/DWpHYp4SLPCDCMHdmTyKOw/thumb.png?1607339938",
    token: "https://s3.amazonaws.com/files.d20.io/images/183633585/DWpHYp4SLPCDCMHdmTyKOw/thumb.png?1607339938",
    attributesFiche: {
      type_personnage: 'PNJ',
      niveau: 5,
      force: 20,
      pnj_for: 5,
      for_sup: '@{jetsup}',
      pnj_for_sup: 'on',
      dexterite: 14,
      pnj_dex: 2,
      constitution: 18,
      pnj_con: 4,
      con_sup: '@{jetsup}',
      pnj_con_sup: 'on',
      intelligence: 14,
      pnj_int: 2,
      sagesse: 14,
      pnj_sag: 2,
      charisme: 10,
      pnj_cha: 0,
      DEFDIV: 3,
      pnj_def: 17,
      pnj_init: 16,
      race: 'démon',
      taille: 'moyen'
    },
    attaques: [{
      nom: 'Griffes',
      dmnbde: 1,
      dmde: 8,
      dm: 5,
      modificateurs: 'magique'
    }],
    attributes: [],
    abilities: []
  };

  function invocationDemon(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 2) {
      error("!cof-invoquer-demon mal formé, il faut un token comme premier argument", msg.content);
      return;
    }
    var necromant = persoOfId(cmd[1], cmd[1], options.pageId);
    if (necromant === undefined) {
      error("Le premier argument de !cof-invoquer-demon n'est pas un token valie", cmd);
      return;
    }
    options.lanceur = necromant;
    getSelected(msg, function(selected, playerId) {
      var evt = {
        type: 'invocationDemon',
        action: {
          rolls: {}
        }
      };
      addEvent(evt);
      if (limiteRessources(necromant, options, 'tenebres', 'lancer un sort de ténèbres', evt)) return;
      var d6 = rollDePlus(6);
      evt.action.rolls.invocationDemonDmg = d6;
      var r = {
        total: d6.val,
        type: 'normal',
        display: d6.roll
      };
      var explications = [];
      necromant.ignoreTouteRD = true;
      dealDamage(necromant, r, [], evt, false, {}, explications,
        function(dmgDisplay, dmg) {
          if (!stateCOF.combat) {
            initPerso(necromant, evt);
          }
          var tokenDemon = "Démon de " + necromant.token.get('name');
          var token = createObj('graphic', {
            name: tokenDemon,
            showname: 'true',
            subtype: 'token',
            pageid: options.pageId,
            imgsrc: demonInvoque.token,
            left: necromant.token.get('left'),
            top: necromant.token.get('top'),
            width: 70,
            height: 70,
            layer: 'objects',
            showplayers_bar1: 'true',
            light_hassight: 'true',
            light_angle: 0,
            has_bright_light_vision: true,
            has_limit_field_of_vision: true,
          });
          toFront(token);
          var niveau = ficheAttributeAsInt(necromant, "niveau", 1);
          var demon = {...demonInvoque
          };
          demon.pv = niveau * 5;
          demon.attaques[0].atk = niveau;
          var charDemon = createCharacter(tokenDemon, playerId, demonInvoque.avatar, token, demon);
          evt.characters = [charDemon];
          evt.tokens = [token];
          var duree = 5 + modCarac(necromant, "intelligence");
          //Attribut de démon invoqué pour la disparition automatique
          createObj('attribute', {
            name: 'demonInvoque',
            _characterid: charDemon.id,
            current: duree,
            max: getInit()
          });
          //Attribut de démon invoqué pour la disparition automatique
          createObj('attribute', {
            name: 'resistanceA_nonMagique',
            _characterid: charDemon.id,
            current: 'true',
          });
          initiative([{
            _id: token.id
          }], evt);
          var msg = "invoque un démon";
          if (stateCOF.options.affichage.val.duree_effets.val) msg += " pour " + duree + " tours";
          msg += " mais cela lui coûte " + dmgDisplay + " PV";
          sendChar(necromant.charId, msg);
        });
    }, options);
  }

  //Crée les macros utiles au jeu
  var gameMacros = [{
    name: 'Actions',
    action: "!cof-liste-actions",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'Attaque',
    action: "!cof-attack @{selected|token_id} @{target|token_id}",
    visibleto: 'all',
    istokenaction: false
  }, {
    name: 'Consommables',
    action: "!cof-consommables",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'Monter',
    action: "!cof-escalier haut",
    visibleto: 'all',
    istokenaction: true,
    inBar: false
  }, {
    name: 'Descendre',
    action: "!cof-escalier bas",
    visibleto: 'all',
    istokenaction: true,
    inBar: false
  }, {
    name: 'Fin-combat',
    action: "!cof-fin-combat",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Init',
    action: "!cof-init",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Jets',
    action: "!cof-jet",
    visibleto: 'all',
    istokenaction: true,
  }, {
    name: 'Jets-GM',
    action: "!cof-jet --secret",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Nuit',
    action: "!cof-nouveau-jour ?{Repos?|Oui,--repos|Non}",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Repos',
    action: "!cof-recuperation",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Statut',
    action: "!cof-statut",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'Surprise',
    action: "!cof-surprise ?{difficulté}",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Torche',
    action: "!cof-torche @{selected|token_id}",
    visibleto: 'all',
    istokenaction: true,
  }, {
    name: 'Éteindre',
    action: "!cof-eteindre-lumiere ?{Quelle lumière?|Tout}",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'devient',
    action: "!cof-set-state ?{État|mort|surpris|assome|renverse|aveugle|affaibli|etourdi|paralyse|ralenti|immobilise|endormi|apeure|invisible|blesse|encombre} true",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'enlève',
    action: "!cof-set-state ?{État|mort|surpris|assome|renverse|aveugle|affaibli|etourdi|paralyse|ralenti|immobilise|endormi|apeure|invisible|blesse|encombre} false",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, {
    name: 'Suivre',
    action: "!cof-suivre @{selected|token_id} @{target|token_id}",
    visibleto: 'all',
    istokenaction: true
  }, {
    name: 'undo',
    action: "!cof-undo",
    visibleto: '',
    istokenaction: false,
    inBar: true
  }, ];

  function setGameMacros(msg) {
    var playerId = msg.playerid;
    var force = playerIsGM(playerId) && msg.content.includes('--force');
    var inBar = [];
    var allMacros = findObjs({
      _type: 'macro'
    });
    gameMacros.forEach(function(m) {
      var prev =
        allMacros.find(function(macro) {
          return macro.get('name') == m.name;
        });
      if (prev === undefined) {
        m.playerid = playerId;
        createObj('macro', m);
        sendPlayer(msg, "Macro " + m.name + " créée.");
        if (m.inBar) inBar.push(m.name);
      } else if (force) {
        prev.set('action', m.action);
        prev.set('visibleto', m.visibleto);
        prev.set('istokenaction', m.istokenaction);
        sendPlayer(msg, "Macro " + m.name + " réécrite.");
        if (m.inBar) inBar.push(m.name);
      } else {
        sendPlayer(msg, "Macro " + m.name + " déjà présente (utiliser --force pour réécrire).");
      }
    });
    if (inBar.length > 0) {
      sendPlayer(msg, "Macros à mettre dans la barre d'action du MJ : " + inBar.join(', '));
    }
    stateCOF.gameMacros = gameMacros;
  }

  function ajouteLumiere(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("Il faut au moins 2 arguments à !cof-lumiere", cmd);
      return;
    }
    var cible = persoOfId(cmd[1]);
    if (cible === undefined) {
      error("le premier argument de !cof-lumière doit être un token", cmd);
      return;
    }
    var radius = parseInt(cmd[2]);
    if (isNaN(radius) || radius <= 0) {
      error("La distance de vue de la lumière doit être positive", cmd[2]);
      return;
    }
    var dimRadius = '';
    if (cmd.length > 3) {
      dimRadius = parseInt(cmd[3]);
      if (isNaN(dimRadius)) {
        error("La distance de vue de la lumière assombrie doit être un nombre", cmd[3]);
        dimRadius = '';
      }
    }
    var nomToken = 'lumiere';
    if (cmd.length > 4) {
      nomToken = cmd[4].trim();
      if (nomToken === '') nomToken = 'lumiere';
    }
    var evt = {
      type: 'lumiere',
    };
    addEvent(evt);
    if (limiteRessources(options.lanceur, options, 'lumière', "lumière", evt)) return;
    ajouteUneLumiere(cible, nomToken, radius, dimRadius, evt);
  }

  // prend en compte l'unité de mesure utilisée sur la page
  function ajouteUneLumiere(perso, nomLumiere, radius, dimRadius, evt) {
    radius = scaleDistance(perso, radius);
    if (dimRadius !== '') dimRadius = scaleDistance(perso, dimRadius);
    var ct = perso.token;
    var pageId = ct.get('pageid');
    var page = getObj('page', pageId);
    var udl = page && page.get('dynamic_lighting_enabled');
    var brightLight = radius;
    if (udl) {
      if (isNaN(brightLight) || brightLight < 0) {
        error("Lumière avec un rayon négatif", radius);
        return;
      }
    }
    var attrName = 'lumiere';
    if (ct.get('bar1_link') === "") attrName += "_" + ct.get('name');
    if (ct.get('bar1_max')) {
      var lumiereSurPerso;
      //Cas particulier où le personnage est un vrai personnage qui ne fait pas de lumière
      if (!udl && !ct.get('light_radius')) {
        lumiereSurPerso = true;
        setToken(ct, 'light_radius', radius, evt);
        if (dimRadius !== '') setToken(ct, 'light_dimradius', dimRadius, evt);
        setToken(ct, 'light_otherplayers', true, evt);
      } else if (udl && !ct.get('emits_bright_light') && !ct.get('emits_low_light')) {
        lumiereSurPerso = true;
        if (dimRadius !== '') {
          if (dimRadius < 0) dimRadius = 0;
          if (dimRadius < brightLight) {
            setToken(ct, 'emits_low_light', true, evt);
            setToken(ct, 'low_light_distance', brightLight, evt);
            brightLight = dimRadius;
          }
        }
        if (brightLight > 0) {
          setToken(ct, 'emits_bright_light', true, evt);
          setToken(ct, 'bright_light_distance', brightLight, evt);
        }
      }
      if (lumiereSurPerso) {
        var attr1 = createObj('attribute', {
          characterid: perso.charId,
          name: attrName,
          current: nomLumiere,
          max: 'surToken'
        });
        evt.attributes = [{
          attribute: attr1,
          current: null
        }];
        return;
      }
    }
    var tokLumiere = createObj('graphic', {
      _pageid: pageId,
      imgsrc: "https://s3.amazonaws.com/files.d20.io/images/3233035/xHOXBXoAgOHCHs8omiFAYg/thumb.png?1393406116",
      left: ct.get('left'),
      top: ct.get('top'),
      width: 70,
      height: 70,
      layer: 'walls',
      name: nomLumiere,
    });
    if (tokLumiere === undefined) {
      error("Problème lors de la création du token de lumière", perso);
      return;
    }
    evt.tokens = [tokLumiere];
    if (udl) {
      if (dimRadius !== '') {
        if (dimRadius < 0) dimRadius = 0;
        if (dimRadius < brightLight) {
          setToken(tokLumiere, 'emits_low_light', true, evt);
          setToken(tokLumiere, 'low_light_distance', brightLight, evt);
          brightLight = dimRadius;
        }
      }
      if (brightLight > 0) {
        setToken(tokLumiere, 'emits_bright_light', true, evt);
        setToken(tokLumiere, 'bright_light_distance', brightLight, evt);
      }
    } else {
      setToken(tokLumiere, 'light_radius', radius, evt);
      setToken(tokLumiere, 'light_dimradius', dimRadius, evt);
      setToken(tokLumiere, 'light_otherplayers', true, evt);
    }
    if (ct.get('bar1_max')) { //Lumière liée à un token
      var attr = createObj('attribute', {
        characterid: perso.charId,
        name: attrName,
        current: nomLumiere,
        max: tokLumiere.id
      });
      evt.attributes = [{
        attribute: attr,
        current: null
      }];
    } else { //cible temporaire, à effacer7
      ct.remove();
    }
  }

  function eteindreUneLumiere(perso, pageId, al, lumName, evt) {
    if (al === undefined) {
      var attrLumiere = tokenAttribute(perso, 'lumiere');
      al = attrLumiere.find(function(a) {
        return a.get('current') == lumName;
      });
      if (al === undefined) return;
    }
    var lumId = al.get('max');
    if (lumId == 'surToken') {
      //Il faut enlever la lumière sur tous les tokens
      var allTokens = [perso.token];
      if (perso.token.get('bar1_value') !== '') {
        allTokens = findObjs({
          type: 'graphic',
          represents: perso.charId
        });
        allTokens = allTokens.filter(function(tok) {
          return tok.get('bar1_value') !== '';
        });
      }
      allTokens.forEach(function(token) {
        setToken(token, 'light_radius', '', evt);
        setToken(token, 'light_dimradius', '', evt);
        setToken(token, 'emits_bright_light', false, evt);
        setToken(token, 'emits_low_light', false, evt);
      });
      al.remove();
      return;
    }
    var lumiere = getObj('graphic', lumId);
    if (lumiere === undefined) {
      var tokensLumiere = findObjs({
        _type: 'graphic',
        layer: 'walls',
        name: lumName
      });
      if (tokensLumiere.length === 0) {
        log("Pas de token pour la lumière " + lumName);
        al.remove();
        return;
      }
      lumiere = tokensLumiere.shift();
      if (tokensLumiere.length > 0) {
        //On cherche le token le plus proche de perso
        var pos = [perso.token.get('left'), perso.token.get('top')];
        var d =
          VecMath.length(
            VecMath.vec([lumiere.get('left'), lumiere.get('top')], pos));
        var samePage = lumiere.get('pageid') == pageId;
        tokensLumiere.forEach(function(tl) {
          if (tl.get('pageid') != pageId) return;
          if (samePage) {
            var d2 =
              VecMath.length(
                VecMath.vec([tl.get('left'), tl.get('top')], pos));
            if (d2 < d) {
              d = d2;
              lumiere = tl;
            }
          } else {
            lumiere = tl;
          }
        });
      }
    }
    al.remove();
    if (lumiere) lumiere.remove();
  }

  function eteindreLumieres(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    getSelected(msg, function(selected) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de cible sélectionnée pour !cof-eteindre-lumiere");
        return;
      }
      var cmd = options.cmd;
      var groupe;
      if (cmd.length > 1) groupe = cmd[1];
      if (groupe && groupe.toLowerCase() == 'tout') groupe = '';
      var pageId = options.pageId;
      var evt = {
        type: "Eteindre la lumière"
      };
      iterSelected(selected, function(perso) {
        var attrLumiere = tokenAttribute(perso, 'lumiere');
        attrLumiere.forEach(function(al) {
          var lumName = al.get('current');
          if (groupe && !lumName.startsWith(groupe)) return;
          eteindreUneLumiere(perso, pageId, al, lumName, evt);
        });
      });
    }, options);
  }

  function switchTorche(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd.length < 2) {
      error("Il faut préciser le token en argument de !cof-torche");
      return;
    }
    var pageId = options.pageId;
    var perso = persoOfId(cmd[1], cmd[1], pageId);
    if (perso === undefined) {
      error("Token invalide", cmd);
      return;
    }
    var diminueDuree = 0;
    if (cmd.length > 2) {
      //Dans ce cas, c'est pour diminuer la durée de vie de la torche
      diminueDuree = parseInt(cmd[2]);
      if (isNaN(diminueDuree) || diminueDuree <= 0) {
        sendPlayer(msg, "Le deuxième argument de !cof-torche doit être un nombre strictement positif " + msg.content);
        return;
      }
    }
    var evt;
    //On commence par chercher si une torche est allumée
    var torcheAllumee = false;
    var attrLumiere = tokenAttribute(perso, 'lumiere').filter(function(a) {
      return a.get('current').startsWith('torche');
    });
    if (!diminueDuree && attrLumiere.length > 0) {
      torcheAllumee = true;
      evt = {
        type: "Éteindre les torches"
      };
      attrLumiere.forEach(function(al) {
        var lumName = al.get('current');
        eteindreUneLumiere(perso, pageId, al, lumName, evt);
      });
    }
    var nbTorches = 0;
    var tempsTorche = 0;
    var attrTorches = tokenAttribute(perso, 'torches');
    if (attrTorches.length > 0) {
      nbTorches = parseInt(attrTorches[0].get('current'));
      if (isNaN(nbTorches) || nbTorches < 0) {
        error("Nombre de torches incorrect", nbTorches);
        if (evt) addEvent(evt);
        return;
      }
      if (!torcheAllumee && nbTorches === 0) {
        whisperChar(perso.charId, "n'a pas de torche.");
        return;
      }
      tempsTorche = parseInt(attrTorches[0].get('max'));
      if (isNaN(tempsTorche) || tempsTorche < 0) {
        error("Temps restant pour la torche incorrect", tempsTorche);
        if (evt) addEvent(evt);
        return;
      }
      if (tempsTorche === 0) {
        if (nbTorches === 0) { //Donc forcément torcheAllumee
          //On remet l'attribut dans un état convenable
          setTokenAttr(perso, 'torches', 0, evt, {
            maxVal: 60
          });
          addEvent(evt);
          return;
        }
        nbTorches--;
        tempsTorche = 60;
      }
      if (diminueDuree) {
        evt = evt || {
          type: "Diminuer le duree de vie d'une torche"
        };
        var temps = diminueDuree;
        tempsTorche -= diminueDuree;
        if (tempsTorche <= 0) {
          nbTorches--;
          temps += tempsTorche;
          tempsTorche = 60;
          var msgDiminue = "torche épuisée.";
          if (nbTorches === 0) {
            msgDiminue += " Plus de torche !";
          } else if (nbTorches == 1) {
            msgDiminue += " Plus qu'une torche.";
          } else {
            msgDiminue += " Il lui reste " + nbTorches + " torches.";
          }
          whisperChar(perso.charId, msgDiminue);
        }
        setTokenAttr(perso, 'torches', nbTorches, evt, {
          maxVal: tempsTorche
        });
        sendChar(perso.charId, '/w gm temps de torche diminué de ' + temps + ' minutes');
        addEvent(evt);
        return;
      }
      if (torcheAllumee) {
        var msgTorche = "/w gm torche éteinte. ";
        if (nbTorches > 1) {
          msgTorche += "Reste " + (nbTorches - 1) + " torche";
          if (nbTorches > 2) msgTorche += "s neuves";
          else msgTorche += " neuve";
          msgTorche += ", et une torche pouvant encore éclairer " + tempsTorche + " minutes.";
        } else {
          msgTorche += "Elle peut encore éclairer " + tempsTorche + " minutes.";
        }
        sendChar(perso.charId,
          msgTorche +
          boutonSimple("!cof-torche " + perso.token.id + " ?{Durée?}", "Temps depuis allumage"));
        addEvent(evt);
        return;
      }
      evt = {
        type: "Allumer une torche"
      };
      ajouteUneLumiere(perso, 'torche', 13, 7, evt);
      var msgAllume =
        "allume une torche, qui peut encore éclairer pendant " + tempsTorche +
        " minute";
      if (tempsTorche > 1) msgAllume += 's';
      msgAllume += '.';
      if (nbTorches > 1) {
        msgAllume += " Il lui reste encore " + (nbTorches - 1);
        if (nbTorches == 2) msgAllume += " autre torche.";
        else msgAllume += " autres torches.";
      }
      whisperChar(perso.charId, msgAllume);
      addEvent(evt);
      return;
    }
    //On ne tient pas le compte précis des torches
    if (torcheAllumee) {
      whisperChar(perso.charId, "éteint sa torche");
    } else {
      evt = {
        type: "Allumer une torche"
      };
      ajouteUneLumiere(perso, 'torche', 13, 7, evt);
      whisperChar(perso.charId, "allume sa torche");
    }
    addEvent(evt);
  }

  //!cof-options
  //!cof-options opt1 [... optn] val, met l'option à val
  //!cof-options [opt0 ... optk] reset remet toutes les options à leur valeur patr défaut
  //Dans tous les cas, affiche les options du niveau demandé
  function setCofOptions(msg) {
    var playerId = getPlayerIdFromMsg(msg);
    if (!playerIsGM(playerId)) {
      sendPlayer(msg, "Seul le MJ peut changer les options du script");
      return;
    }
    var cmd = msg.content.split(' ');
    var cofOptions = stateCOF.options;
    if (cofOptions === undefined) {
      sendPlayer(msg, "Options non diponibles");
      return;
    }
    var prefix = '';
    var up;
    var defOpt = defaultOptions;
    var newOption;
    var lastCmd;
    var fini;
    cmd.shift();
    cmd.forEach(function(c) {
      if (fini) {
        sendPlayer(msg, "Option " + c + " ignorée");
        return;
      }
      if (c == 'reset') {
        for (var opt in cofOptions) delete cofOptions[opt];
        copyOptions(cofOptions, defOpt);
        fini = true;
      } else if (cofOptions[c]) {
        if (cofOptions[c].type == 'options') {
          if (defOpt[c] === undefined) {
            sendPlayer(msg, "Option " + c + " inconnue dans les options par défaut");
            fini = true;
            return;
          }
          defOpt = defOpt[c].val;
          cofOptions = cofOptions[c].val;
          up = prefix;
          prefix += ' ' + c;
        } else {
          newOption = cofOptions[c];
        }
      } else {
        if (newOption) { //on met newOption à c
          var val = c;
          switch (newOption.type) {
            case 'bool':
              switch (c) {
                case 'oui':
                case 'true':
                case '1':
                  val = true;
                  break;
                case 'non':
                case 'false':
                case '0':
                  val = false;
                  break;
                default:
                  sendPlayer(msg, "L'option " + lastCmd + " ne peut être que true ou false");
                  val = newOption.val;
              }
              break;
            case 'int':
              val = parseInt(c);
              if (isNaN(val)) {
                sendPlayer(msg, "L'option " + lastCmd + " est une valeur entière");
                val = newOption.val;
              }
              break;
          }
          newOption.val = val;
          fini = true;
        } else if (lastCmd) {
          sendPlayer(msg, "L'option " + lastCmd + " ne contient pas de sous-option " + c);
        } else {
          sendPlayer(msg, "Option " + c + " inconnue.");
        }
      }
      lastCmd = c;
    });
    var titre = "Options de COFantasy";
    if (prefix !== '') {
      titre += "<br>" + prefix + ' (';
      titre += boutonSimple('!cof-options' + up, 'retour') + ')';
    }
    var display = startFramedDisplay(playerId, titre, undefined, {
      chuchote: true
    });
    for (var opt in cofOptions) {
      var optVu = opt.replace(/_/g, ' ');
      var line = '<span title="' + cofOptions[opt].explications + '">' +
        optVu + '</span> : ';
      var action = '!cof-options' + prefix + ' ' + opt;
      var displayedVal = cofOptions[opt].val;
      var after = '';
      switch (cofOptions[opt].type) {
        case 'options':
          displayedVal = '<span style="font-family: \'Pictos\'">l</span>';
          break;
        case 'bool':
          action += ' ?{Nouvelle valeur de ' + optVu + '|actif,true|inactif,false}';
          if (displayedVal)
          // Bizarrement, le caractère '*' modifie la suite du tableau
            displayedVal = '<span style="font-family: \'Pictos\'">3</span>';
          else
            displayedVal = '<span style="font-family: \'Pictos\'">*</span>';
          break;
        case 'int':
          action += ' ?{Nouvelle valeur de ' + optVu + '(entier)}';
          break;
        case 'image':
          action += " ?{Entrez l'url pour " + optVu + '}';
          after =
            '<img src="' + displayedVal + '" style="width: 30%; height: auto; border-radius: 6px; margin: 0 auto;">';
          displayedVal = '<span style="font-family: \'Pictos\'">u</span>';
          break;
        default:
          action += ' ?{Nouvelle valeur de ' + optVu + '}';
      }
      line += boutonSimple(action, displayedVal) + after;
      addLineToFramedDisplay(display, line);
    }
    addLineToFramedDisplay(display, boutonSimple('!cof-options' + prefix + ' reset', 'Valeurs par défaut'), 70);
    sendChat('', endFramedDisplay(display));
  }

  function lancerDefiSamourai(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-defi-samourai demande au moins 2 options",
        msg.content);
      return;
    }
    var pageId = options.pageId;
    var samourai = persoOfId(cmd[1], cmd[1], pageId);
    if (samourai === undefined) {
      error("Le token sélectionné n'est pas valide", msg.content);
      return;
    }
    samourai.tokName = samourai.token.get('name');
    if (attributeAsBool(samourai, 'defiSamourai')) {
      sendPlayer(msg, samourai.tokName + " a déjà lancé un défi durant ce combat.");
      return;
    }
    var cible = persoOfId(cmd[2], cmd[2], pageId);
    if (cible === undefined) {
      error("Le deuxième token sélectionné n'est pas valide", msg.content);
      return;
    }
    cible.tokName = cible.token.get('name');
    var evt = {
      type: 'Défi samouraï'
    };
    var explications = [];
    entrerEnCombat(samourai, [cible], explications, evt);
    explications.forEach(function(m) {
      sendChar(samourai.charId, m);
    });
    var bonus;
    if (cmd.length > 3) {
      bonus = parseInt(cmd[3]);
      if (isNaN(bonus) || bonus < 1) {
        error("Bonus de défi de samouraï incorrect", cmd[3]);
        bonus = undefined;
      }
    }
    if (bonus === undefined)
      bonus = charAttributeAsInt(samourai, 'voieDeLHonneur', 2);
    setTokenAttr(samourai, 'defiSamourai', bonus, evt, {
      msg: samourai.tokName + " lance un défi à " + cible.tokName,
      maxVal: cible.token.id + ' ' + cible.tokName
    });
  }

  function parseEnveloppement(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Problème de parse options", msg.content);
      return;
    }
    if (cmd.length < 6) {
      error("Il manque des arguments à !cof-enveloppement", cmd);
      return;
    }
    var cube = persoOfId(cmd[1]);
    if (cube === undefined) {
      error("Token non défini", cmd[1]);
      return;
    }
    if (!peutController(msg, cube)) {
      sendPlayer(msg, "pas le droit d'utiliser ce bouton");
      return;
    }
    var cible = persoOfId(cmd[2]);
    if (cible === undefined) {
      error("Token non défini", cmd[2]);
      return;
    }
    var difficulte = parseInt(cmd[3]);
    if (isNaN(difficulte)) {
      error("Difficulté n'est pas un nombre, on prend 15 par défaut", cmd[3]);
      difficulte = 15;
    }
    var exprDM;
    var type;
    switch (cmd[4]) {
      case 'label':
      case 'ability':
        type = 'enveloppement';
        exprDM = cmd[4] + ' ' + cmd[5];
        break;
      case 'etreinte':
        type = 'étreinte';
        exprDM = cmd[4] + ' ' + cmd[5];
        break;
      default:
        error("Impossible de déterminer les dégâts quand enveloppé", cmd[4]);
        return;
    }
    doEnveloppement(cube, cible, difficulte, type, exprDM, options);
  }

  //!cof-enveloppement cubeId targetId Difficulte Attaque
  //Attaque peut être soit label l, soit ability a, soit etreinte expr
  function doEnveloppement(attaquant, cible, difficulte, type, exprDM, options) {
    var evt = {
      type: type,
      action: {
        titre: "Enveloppement",
        attaquant: attaquant,
        cible: cible,
        difficulte: difficulte,
        type: type,
        exprDM: exprDM,
        options: options,
      }
    };
    addEvent(evt);
    //Choix de la caractéristique pour résister : FOR ou DEX
    var caracRes = meilleureCarac('FOR', 'DEX', cible, 10 + modCarac(attaquant, 'force'));
    var titre = (type == 'étreinte') ? 'Étreinte' : 'Enveloppement';
    var display = startFramedDisplay(options.playerId, titre, attaquant, {
      perso2: cible
    });
    var explications = [];
    var rollId = 'enveloppement_' + cible.token.id;
    testOppose(rollId, attaquant, 'FOR', options, cible, caracRes, options,
      explications, evt,
      function(res, crit, rt1, rt2) {
        var act = " a absorbé ";
        switch (res) {
          case 1:
            if (type == 'étreinte') act = " s'est enroulé autour de ";
            explications.push(attaquant.token.get('name') + act + cible.token.get('name'));
            var attaquantId = attaquant.token.id + ' ' + attaquant.token.get('name');
            var maxval = difficulte;
            if (type == 'étreinte') maxval = 'etreinte ' + difficulte;
            setTokenAttr(cible, 'enveloppePar', attaquantId, evt, {
              maxVal: maxval
            });
            var cibleId = cible.token.id + ' ' + cible.token.get('name');
            cible.token.set('left', attaquant.token.get('left'));
            cible.token.set('right', attaquant.token.get('right'));
            toFront(attaquant.token);
            setTokenAttr(attaquant, 'enveloppe', cibleId, evt, {
              maxVal: exprDM
            });
            if (type == 'étreinte') setState(cible, 'immobilise', true, evt);
            break;
          case 2:
            if (caracRes == 'FOR') {
              if (type == 'étreinte') act = 'étreindre';
              else act = 'absorber';
              explications.push(cible.token.get('name') + " résiste et ne se laisse pas " + act);
            } else {
              if (type == 'étreinte') act = "l'étreinte";
              else act = "l'absorption";
              explications.push(cible.token.get('name') + " évite " + act);
            }
            break;
          default: //match null, la cible s'en sort
            if (type == 'étreinte') act = "l'étreinte";
            else act = "l'enveloppement";
            explications.push(cible.token.get('name') + " échappe de justesse à " + act);
        }
        explications.forEach(function(e) {
          addLineToFramedDisplay(display, e);
        });
        sendChat("", endFramedDisplay(display));
      });
  }

  //!cof-echapper-enveloppement
  function parseEchapperEnveloppement(msg) {
    var options = msg.options || parseOptions(msg);
    if (options === undefined) return;
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "!cof-echapper-enveloppement sans sélection de token");
        log("!cof-echapper-enveloppement requiert de sélectionner des tokens");
        return;
      }
      iterSelected(selected, function(perso) {
        var attr = tokenAttribute(perso, 'enveloppePar');
        if (attr.length === 0) {
          sendPlayer(msg, perso.token.get('name') + " n'est pas englouti.");
          return;
        }
        attr = attr[0];
        var cube = persoOfIdName(attr.get('current'), options.pageId);
        if (cube === undefined) {
          error("Attribut enveloppePar mal formé, on le supprime", attr.get('current'));
          attr.remove();
          return;
        }
        var etreinte = false;
        var maxAttr = attr.get('max') + '';
        if (maxAttr.startsWith('etreinte ')) {
          etreinte = true;
          maxAttr = maxAttr.substring(9);
        }
        var difficulte = parseInt(maxAttr);
        if (isNaN(difficulte)) {
          error("Difficulté mal formée", attr.get('max'));
          difficulte = 15;
        }
        doEchapperEnveloppement(perso, etreinte, cube, difficulte, options);
      });
    });
  }

  function doEchapperEnveloppement(perso, etreinte, cube, difficulte, options) {
    var evt = {
      type: (etreinte) ? "echapperEtreinte" : "echapperEnveloppement",
      personnage: perso,
      action: {
        perso: perso,
        etreinte: etreinte,
        cube: cube,
        difficulte: difficulte,
        options: options,
        rolls: options.rolls || {}
      }
    };
    addEvent(evt);
    var titre = "Tentative de sortir de " + cube.tokName;
    if (etreinte) titre = "Tentative de se libérer de l'etreinte de " + cube.tokName;
    var display = startFramedDisplay(options.playerId, titre, perso, {
      chuchote: options.secret
    });
    var testId = 'enveloppement_' + perso.token.id;
    testCaracteristique(perso, 'FOR', difficulte, testId, options, evt,
      function(tr) {
        addLineToFramedDisplay(display, "<b>Résultat :</b> " + tr.texte);
        if (tr.reussite) {
          addLineToFramedDisplay(display, "C'est réussi, " + perso.token.get('name') + " s'extirpe de " + cube.tokName + tr.modifiers);
          toFront(perso.token);
          evt.deletedAttributes = evt.deletedAttributes || [];
          var attr = tokenAttribute(perso, 'enveloppePar')[0];
          evt.deletedAttributes.push(attr);
          attr.remove();
          if (etreinte) setState(perso, 'immobilise', false, evt);
          attr = tokenAttribute(cube, 'enveloppe');
          attr.forEach(function(a) {
            var ca = persoOfIdName(a.get('current'));
            if (ca && ca.token.id == perso.token.id) {
              evt.deletedAttributes.push(a);
              a.remove();
            }
          });
        } else {
          var msgRate = "C'est raté." + tr.rerolls + tr.modifiers;
          addLineToFramedDisplay(display, msgRate);
        }
        sendChat('', endFramedDisplay(display));
      });
  }

  function parseLibererAgrippe(msg) {
    var options = msg.options || parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) {
      error("Problème de parse options", msg.content);
      return;
    }
    if (cmd.length < 2) {
      error("Il faut l'id du token en argument de !cof-liberer-agrippe", msg.content);
      return;
    }
    var perso = persoOfId(cmd[1], cmd[1], options.pageId);
    var attrName = 'estAgrippePar';
    var attr = tokenAttribute(perso, 'estAgrippePar');
    if (attr.length === 0) {
      attr = tokenAttribute(perso, 'etreinteImmolePar');
      if (attr.length === 0) {
        sendPlayer(msg, perso.tokName + " n'est pas agrippé.");
        return;
      }
      attrName = 'etreinteImmolePar';
    }
    attr = attr[0];
    var agrippant = persoOfIdName(attr.get('current'), options.pageId);
    if (agrippant === undefined) {
      error("Attribut " + attrName + " mal formé, on le supprime", attr.get('current'));
      attr.remove();
      return;
    }
    doLibererAgrippe(perso, agrippant, attrName, options);
  }

  //!cof-liberer-agrippe token_id
  function doLibererAgrippe(perso, agrippant, attrName, options) {
    var evt = {
      type: 'libererAgrippe',
      action: {
        titre: "Se libérer",
        perso: perso,
        agrippant: agrippant,
        attrName: attrName,
        options: options
      }
    };
    addEvent(evt);
    var titre = "Tentative de se libérer de " + agrippant.token.get('name');
    var playerId = options.playerId;
    var display = startFramedDisplay(playerId, titre, perso, {
      chuchote: options.secret
    });
    var explications = [];
    var rollId = 'libererAgrippe_' + perso.token.id;
    var options1 = {...options
    };
    if (attrName == 'etreinteImmolePar') options1.dice = 20;
    testOppose(rollId, perso, 'FOR', options1, agrippant, 'FOR',
      options, explications, evt,
      function(tr, crit, rt1, rt2) {
        explications.forEach(function(e) {
          addLineToFramedDisplay(display, e);
        });
        if (tr == 2) {
          var msgRate = "C'est raté, " + perso.token.get('name') + " est toujours ";
          if (attrName == 'etreinteImmolePar')
            msgRate += "prisonnier de l'étreinte de " + agrippant.token.get('name');
          else msgRate += "agrippé" + eForFemale(perso) + ".";
          addLineToFramedDisplay(display, msgRate);
        } else {
          if (tr === 0)
            addLineToFramedDisplay(display, "Réussi de justesse, " + perso.token.get('name') + " se libère.");
          else //tr == 1
            addLineToFramedDisplay(display, "Réussi, " + perso.token.get('name') + " se libère.");
          toFront(perso.token);
          var attr = tokenAttribute(perso, attrName);
          if (attrName == 'etreinteImmolePar' || attr[0].get('max')) setState(perso, 'immobilise', false, evt);
          evt.deletedAttributes = evt.deletedAttributes || [];
          evt.deletedAttributes.push(attr[0]);
          attr[0].remove();
          var attrAgrippant = 'agrippe';
          if (attrName == 'etreinteImmolePar') attrAgrippant = 'etreinteImmole';
          attr = tokenAttribute(agrippant, attrAgrippant);
          attr.forEach(function(a) {
            var ca = persoOfIdName(a.get('current'));
            if (ca && ca.token.id == perso.token.id) {
              evt.deletedAttributes.push(a);
              a.remove();
            }
          });
        }
        sendChat('', endFramedDisplay(display));
      });
  }

  //!cof-animer-cadavre lanceur cible
  function animerCadavre(msg) {
    var options = msg.options || parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined || cmd.length < 3) {
      error("cof-animer-cadavre attend 2 arguments", msg.content);
      return;
    }
    var lanceur = persoOfId(cmd[1], cmd[1], options.pageId);
    if (lanceur === undefined) {
      error("Le premier argument de !cof-animer-cadavre n'est pas un token valide", msg.content);
      return;
    }
    var cible = persoOfId(cmd[2], cmd[2], options.pageId);
    if (cible === undefined) {
      error("Le deuxième argument de !cof-animer-cadavre n'est pas un token valide", msg.content);
      return;
    }
    cible.tokName = cible.token.get('name');
    if (!getState(cible, 'mort')) {
      sendPlayer(msg, cible.tokName + " n'est pas mort" + eForFemale(cible) + ".");
      return;
    }
    if (attributeAsBool(cible, 'cadavreAnime')) {
      sendPlayer(msg, cible.tokName + " a déjà été animé" + eForFemale(cible) + ".");
      return;
    }
    var niveauLanceur = ficheAttributeAsInt(lanceur, 'niveau', 1);
    var niveauCible = ficheAttributeAsInt(cible, 'niveau', 1);
    if (niveauCible > niveauLanceur) {
      sendPlayer(msg, cible.tokName + " est de NC " + niveauCible + ", supérieur à celui de " + lanceur.token.get('name') + " (" + niveauLanceur + ")");
      return;
    }
    var evt = {
      type: "Animer un cadvre"
    };
    addEvent(evt);
    if (limiteRessources(lanceur, options, 'animerUnCadavre', "animer un cadavre", evt)) return;
    sendChar(lanceur.charId, 'réanime ' + cible.tokName);
    setState(cible, 'mort', false, evt);
    var pvmax = parseInt(cible.token.get("bar1_max"));
    updateCurrentBar(cible, 1, pvmax, evt);
    setTokenAttr(cible, 'cadavreAnime', true, evt, {
      msg: 'se relève'
    });
  }

  var niveauxEbriete = [
    "sobre",
    "pompette",
    "bourré",
    "ivre-mort",
    "en coma éthylique"
  ];

  function augmenteEbriete(personnage, evt, expliquer) {
    personnage.tokName = personnage.tokName || personnage.token.get('name');
    var n = attributeAsInt(personnage, 'niveauEbriete', 0) + 1;
    if (n >= niveauxEbriete.length) {
      expliquer(personnage.tokName + " est déjà en coma éthylique.");
      return;
    }
    expliquer(personnage.tokName + " devient " + niveauxEbriete[n]);
    setTokenAttr(personnage, 'niveauEbriete', n, evt);
  }

  function diminueEbriete(personnage, evt, expliquer) {
    personnage.tokName = personnage.tokName || personnage.token.get('name');
    var n = attributeAsInt(personnage, 'niveauEbriete', 0);
    if (n < 1) return;
    n--;
    if (n >= niveauxEbriete.length) n = niveauxEbriete.length - 1;
    expliquer(personnage.tokName + " redevient " + niveauxEbriete[n]);
    setTokenAttr(personnage, 'niveauEbriete', n, evt);
  }

  function parseVapeursEthyliques(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cibles = [];
    getSelected(msg, function(selected, playerId) {
      if (selected === undefined || selected.length === 0) {
        sendPlayer(msg, "pas de cible trouvée, action annulée");
        return;
      }
      iterSelected(selected, function(perso) {
        cibles.push(perso);
      });
      doVapeursEthyliques(playerId, cibles, options);
    }, options); //fin getSelected
  }

  function doVapeursEthyliques(playerId, persos, options) {
    var evt = {
      type: 'vapeursEthyliques',
      action: {
        playerId: playerId,
        persos: persos,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(options.lanceur, options, 'vapeursEthyliques', "lancer une fiole de vapeurs éthyliques", evt)) {
      addEvent(evt);
      return;
    }
    var display = startFramedDisplay(playerId, 'Vapeurs éthyliques');
    var expliquer = function(m) {
      addLineToFramedDisplay(display, m);
    };
    var explications = [];
    if (options.save) {
      explications.push(" Jet de " + options.save.carac + " " + options.save.seuil + " pour résister à l'alcool");
    }
    entrerEnCombat(options.lanceur, persos, explications, evt);
    explications.forEach(explication => expliquer(explications));
    var count = persos.length;
    var finalize = function() {
      if (count == 1) sendChat('', endFramedDisplay(display));
      count--;
    };
    persos.forEach(function(perso) {
      perso.tokName = perso.tokName || perso.token.get('name');
      if (options.save) {
        var saveOpts = {
          hideSaveTitle: true,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: 'poison'
        };
        var saveId = 'vapeursEthyliques_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt,
          function(succes, rollText) {
            if (!succes) {
              augmenteEbriete(perso, evt, expliquer);
              setTokenAttr(perso, 'vapeursEthyliques', 0, evt, {
                maxVal: options.save.seuil
              });
            }
            finalize();
          });
      } else { //pas de save
        augmenteEbriete(perso, evt, expliquer);
        setTokenAttr(perso, 'vapeursEthyliques', 0, evt);
        finalize();
      }
    });
  }

  function desaouler(msg) {
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Aucune sélection pour !cof-desaouler");
        return;
      }
      var evt = {
        type: 'desaoûler'
      };
      var expliquer = function(s) {
        sendChat('', s);
      };
      iterSelected(selected, function(perso) {
        diminueEbriete(perso, evt, expliquer);
      });
      addEvent(evt);
    });
  }

  function parseBoireAlcool(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var persos = [];
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        persos.push(perso);
      });
      doBoireAlcool(playerId, persos, options);
    }, options); //fin getSelected
  }

  function doBoireAlcool(playerId, persos, options) {
    var evt = {
      type: 'boireAlcool',
      action: {
        playerId: playerId,
        persos: persos,
        options: options
      }
    };
    addEvent(evt);
    if (limiteRessources(options.lanceur, options, 'boireAlcool', "est affecté par l'alcool", evt)) {
      return;
    }
    var display = startFramedDisplay(playerId, 'Alcool');
    var expliquer = function(m) {
      addLineToFramedDisplay(display, m);
    };
    if (options.save) {
      expliquer("Jet de " + options.save.carac + " " + options.save.seuil + " pour résister à l'alcool");
    }
    var count = persos.length;
    var finalize = function() {
      if (count == 1) sendChat('', endFramedDisplay(display));
      count--;
    };
    persos.forEach(function(perso) {
      perso.tokName = perso.tokName || perso.token.get('name');
      if (options.save) {
        var saveOpts = {
          hideSaveTitle: true,
          rolls: options.rolls,
          chanceRollId: options.chanceRollId,
          type: 'poison'
        };
        var saveId = 'boireAlcool_' + perso.token.id;
        save(options.save, perso, saveId, expliquer, saveOpts, evt,
          function(succes, rollText) {
            if (!succes) {
              augmenteEbriete(perso, evt, expliquer);
            }
            finalize();
          });
      } else { //pas de save
        augmenteEbriete(perso, evt, expliquer);
        finalize();
      }
    });
  }

  function jouerSon(msg) {
    var sonIndex = msg.content.indexOf(' ');
    if (sonIndex > 0) {
      //On joue un son
      var son = msg.content.substring(sonIndex + 1);
      playSound(son);
    } else { //On arrête tous les sons
      var AMdeclared;
      try {
        AMdeclared = Roll20AM;
      } catch (e) {
        if (e.name != "ReferenceError") throw (e);
      }
      if (AMdeclared) {
        //With Roll20 Audio Master
        sendChat("GM", "!roll20AM --audio,stop|");
      } else {
        var jukebox = findObjs({
          type: 'jukeboxtrack',
          playing: true
        });
        jukebox.forEach(function(track) {
          track.set('playing', false);
        });
      }
    }
  }

  function bonusCouvert(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    var nouveauBonus = 0;
    if (cmd.length > 1) {
      nouveauBonus = parseInt(cmd[1]);
      if (isNaN(nouveauBonus) || nouveauBonus < 0) {
        error("Il faut un argument positif pour !cof-bonus-couvert", cmd);
        return;
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error('pas de token sélectionné pour !cof-bonus-couvert');
        return;
      }
      var evt = {
        type: 'Bonus couvert'
      };
      addEvent(evt);
      if (limiteRessources(options.lanceur, options, 'bonus couvert', 'bonus couvert', evt)) return;
      iterSelected(selected, function(perso) {
        if (nouveauBonus) {
          setTokenAttr(perso, 'bonusCouvert', nouveauBonus, evt, {
            msg: "se met à couvert",
            secret: options.secret
          });
        } else {
          removeTokenAttr(perso, 'bonusCouvert', evt, {
            msg: "n'est plus à couvert",
            secret: options.secret
          });
        }
      }); //fin iterSelected
    }, options); //fin getSelected
  }

  //!cof-set-attribute nom valeur [max]
  function setAttributeInterface(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    if (cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-set-attribute", cmd);
      return;
    }
    var opt = {secret:options.secret};
    if (cmd.length > 3) {
      opt.maxVal = cmd[3];
    }
    if (options.messages && options.messages.length > 0) 
      opt.msg = options.messages[0];
    getSelected(msg, function(selected, playerId) {
      if (!playerIsGM(playerId)) {
        sendChat('COF', "Seul le MJ peut utiliser la commande !cof-set-attributes");
        return;
      }
      if (selected.length === 0) {
        error('pas de token sélectionné pour !cof-set-attribute');
        return;
      }
      var evt = {
        type: 'Changement attribut'
      };
      addEvent(evt);
      if (limiteRessources(options.lanceur, options, 'changementAttribut', 'changementAttribut', evt)) return;
      iterSelected(selected, function(perso) {
        setTokenAttr(perso, cmd[1], cmd[2], evt, opt);
      }); //fin iterSelected
    }, options);
  }

  //!cof-defense-armee-des-morts tokenId
  function defenseArmeeDesMorts(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    if (cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-defense-armee-des-morts", cmd);
      return;
    }
    var perso = persoOfId(cmd[1]);
    if (perso === undefined) {
      error("Le token renseigné pour !cof-defense-armee-des-morts est inconnu", cmd);
      return;
    }
    if (!peutController(msg, perso)) {
      sendPlayer(msg, "ne peut pas faire ça.");
      return;
    }
    var evt = {
      type: "DefenseArmeeDesMorts"
    };
    addEvent(evt);
    var opt = {
      msg: "se défend contre les morts"
    };
    setTokenAttr(perso, "defenseArmeeDesMorts", true, evt, opt);
  }

  function addLigneOptionAttaque(display, perso, val, texte, attr) {
    var box;
    var action = "!cof-options-d-attaque " + attr + "_check ?{" + texte + "?|";
    if (val) {
      box = '<span style="font-family: \'Pictos\'">3</span>';
      action += "Non|Oui}";
    } else {
      box = ' ';
      action += "Oui|Non}";
    }
    action += " --target " + perso.token.id;
    var ligne = boutonSimple(action, box) + texte;
    addLineToFramedDisplay(display, ligne);
  }

  //!cof-options-d-attaque, affiche les options d'attaque du token sélectionné
  // si on donne reset en argument, remet tout à zéro
  // si on donne en argument option valeur, change la valeur de l'option
  function optionsDAttaque(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    var evt = {
      type: "Option d'attaque"
    };
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        //D'abord on lit les valeurs
        var aepc = ficheAttributeAsBool(perso, 'attaque_en_puissance_check');
        var arc = ficheAttributeAsBool(perso, 'attaque_risquee_check');
        var aac = ficheAttributeAsBool(perso, 'attaque_assuree_check');
        var adtc = ficheAttributeAsBool(perso, 'attaque_dm_temp_check');
        var aep = ficheAttributeAsInt(perso, 'attaque_en_puissance', 1);
        var adg;
        if (persoEstPNJ(perso)) {
          adg = ficheAttributeAsInt(perso, 'attaque_de_groupe', 1);
        }
        if (cmd.length > 1 && cmd[1] == 'reset') {
          if (adg > 1) {
            setFicheAttr(perso, 'attaque_de_groupe', 1, evt);
            adg = 1;
          }
          if (aepc) {
            setFicheAttr(perso, 'attaque_en_puissance_check', 0, evt);
            aepc = false;
          }
          if (arc) {
            setFicheAttr(perso, 'attaque_risquee_check', 0, evt);
            arc = false;
          }
          if (aac) {
            setFicheAttr(perso, 'attaque_assuree_check', 0, evt);
            aac = false;
          }
          if (adtc) {
            setFicheAttr(perso, 'attaque_dm_temp_check', 0, evt);
            adtc = false;
          }
          turnAction(perso, playerId);
          return;
        } else if (cmd.length > 2) {
          switch (cmd[1]) {
            case 'attaque_en_puissance_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!aepc) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  aepc = true;
                  aac = false;
                }
              } else {
                if (aepc) {
                  setFicheAttr(perso, cmd[1], 0, evt);
                  aepc = false;
                }
              }
              break;
            case 'attaque_risquee_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!arc) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  arc = true;
                }
              } else {
                if (arc) {
                  setFicheAttr(perso, cmd[1], 0, evt);
                  arc = false;
                }
              }
              break;
            case 'attaque_assuree_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!aac) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  aac = true;
                  aepc = false;
                }
              } else {
                if (aac) {
                  setFicheAttr(perso, cmd[1], 0, evt);
                  aac = false;
                }
              }
              break;
            case 'attaque_dm_temp_check':
              if (cmd[2] == 'true' || cmd[2] == 'oui' || cmd[2] == 'Oui') {
                if (!adtc) {
                  setFicheAttr(perso, cmd[1], 1, evt);
                  adtc = true;
                }
              } else {
                if (adtc) {
                  setFicheAttr(perso, cmd[1], 0, evt);
                  adtc = false;
                }
              }
              break;
            case 'attaque_de_groupe':
              if (persoEstPNJ(perso)) {
                var nadg = parseInt(cmd[2]);
                if (isNaN(nadg) || nadg < 1) nadg = 1;
                if (nadg != adg) {
                  setFicheAttr(perso, cmd[1], nadg, evt);
                  adg = nadg;
                }
              }
              break;
            case 'attaque_en_puissance':
              var naep = parseInt(cmd[2]);
              if (isNaN(naep) || naep < 1) naep = 1;
              if (naep != aep) {
                setFicheAttr(perso, cmd[1], naep, evt);
                aep = naep;
              }
              break;
            default:
              error("Argument de !cof-options-d-attaque non reconnu", cmd);
              //Mais on peut quand même afficher les options
          }
          turnAction(perso, playerId);
          return;
        }
        var action;
        var title = "Options d'attaque";
        var opt_display = {
          chuchote: true
        };
        if (aepc || arc || aac || adtc || (persoEstPNJ(perso) && adg > 1)) {
          action = "!cof-options-d-attaque reset --target " + perso.token.id;
          opt_display.action_right = boutonSimple(action, 'réinit.');
        }
        var display = startFramedDisplay(playerId, title, perso, opt_display);
        var ligne = '';
        var overlay = '';
        if (persoEstPNJ(perso)) {
          ligne = "Attaque de groupe : ";
          action = "!cof-options-d-attaque attaque_de_groupe ?{Combien d'adversaires par jet?}";
          action += " --target " + perso.token.id;
          overlay = 'title="+2 Att. par créature, si Att > DEF + 5, DM x2, si critique DM x3"';
          ligne += boutonSimple(action, adg, overlay);
          if (adg < 2) {
            ligne += "attaquant";
          } else {
            ligne += "attaquants";
          }
          addLineToFramedDisplay(display, ligne);
        }
        var text;
        action = "!cof-options-d-attaque attaque_en_puissance_check ?{Attaque en puissance?|";
        if (aepc) {
          text = '<span style="font-family: \'Pictos\'">3</span>';
          action += "Non|Oui}";
        } else {
          text = '<span> </span>';
          action += "Oui|Non}";
        }
        action += " --target " + perso.token.id;
        ligne = boutonSimple(action, text) + "Attaque en puissance";
        action = "!cof-options-d-attaque attaque_en_puissance ?{nombre de dés de bonus (-5 att par dé)?}";
        action += " --target " + perso.token.id;
        ligne += "(+" + boutonSimple(action, aep) + "d";
        if (charAttributeAsBool(perso, 'tropPetit')) {
          ligne += "4 DM)";
        } else {
          ligne += "6 DM)";
        }
        addLineToFramedDisplay(display, ligne);
        addLigneOptionAttaque(display, perso, arc, "Attaque risquée", 'attaque_risquee');
        addLigneOptionAttaque(display, perso, aac, "Attaque assurée", 'attaque_assuree');
        addLigneOptionAttaque(display, perso, adtc, "Attaque pour assomer", 'attaque_dm_temp');
        sendChat('', endFramedDisplay(display));
      });
    });
    if (evt.attributes) addEvent(evt);
  }

  //si evt est défini, on ajoute les actions à evt
  function nePlusSuivre(perso, pageId, evt, reutilise) {
    perso.tokName = perso.tokName || perso.token.get('name');
    var attrSuit = tokenAttribute(perso, 'suit');
    if (attrSuit.length > 0) {
      attrSuit = attrSuit[0];
      var idSuivi = attrSuit.get('current');
      var suivi = persoOfIdName(idSuivi, pageId);
      if (evt) {
        evt.attributes = evt.attribute || [];
        evt.attributes.push({
          attribute: attrSuit,
          current: idSuivi,
          max: attrSuit.get('max')
        });
      }
      if (!reutilise) attrSuit.remove();
      if (suivi === undefined) {
        sendChar(perso.charId, "ne suit plus personne");
        return;
      } else {
        sendChar(perso.charId, "ne suit plus " + suivi.token.get('name'));
        var suivantDeSuivi = tokenAttribute(suivi, 'estSuiviPar');
        if (suivantDeSuivi.length > 0) {
          suivantDeSuivi = suivantDeSuivi[0];
          var currentSuivantDeSuivi = suivantDeSuivi.get('current');
          var found;
          var csds = currentSuivantDeSuivi.split(':::').filter(function(idn) {
            if (found) return true;
            var sp = splitIdName(idn);
            if (sp === undefined) return false;
            if (sp.id == perso.id) {
              found = true;
              return false;
            }
            if (sp.name == perso.tokName) {
              found = true;
              return false;
            }
            return true;
          });
          if (csds.length === 0) {
            if (evt) {
              evt.deletedAttributes = evt.deletedAttributes || [];
              evt.deletedAttributes.push(suivantDeSuivi);
            }
            suivantDeSuivi.remove();
          } else {
            if (evt) {
              evt.attributes.push({
                attribute: suivantDeSuivi,
                current: currentSuivantDeSuivi
              });
            }
            suivantDeSuivi.set('current', csds.join(':::'));
          }
        }
      }
      return attrSuit;
    }
  }

  //!cof-suivre @{selected|token_id} @{target|token_id}
  function suivre(msg) {
    var options = parseOptions(msg);
    if (options === undefined) return;
    var cmd = options.cmd;
    if (cmd === undefined) return;
    if (cmd.length < 3) {
      error("Pas assez d'arguments pour !cof-suivre", cmd);
      return;
    }
    var perso = persoOfId(cmd[1], cmd[1], options.pageId);
    if (perso === undefined) {
      error("Token sélectionne incorrect pour !cof-suivre", cmd);
      return;
    }
    var pageId = perso.token.get('pageid');
    var cible = persoOfId(cmd[2], cmd[2], pageId);
    if (cible === undefined) {
      error("Cible incorrecte pour !cof-suivre", cmd);
      return;
    }
    var evt = {
      type: 'Suivre',
      attributes: []
    };
    //D'abord on arrête de suivre si on suivait quelqu'un
    var attrSuit = nePlusSuivre(perso, pageId, evt, true);
    var cibleId = cible.token.id + ' ' + cible.token.get('name');
    var attr = tokenAttribute(cible, 'estSuiviPar');
    var suiveurs;
    if (attr.length === 0) {
      attr = createObj('attribute', {
        characterid: cible.charId,
        name: 'estSuiviPar',
        current: '',
      });
      evt.attributes.push({
        attribute: attr,
        current: null
      });
      suiveurs = [];
    } else {
      attr = attr[0];
      suiveurs = attr.get('current');
      evt.attributes.push({
        attribute: attr,
        current: suiveurs,
      });
      suiveurs = suiveurs.split(':::');
    }
    var xt = perso.token.get('left');
    var yt = perso.token.get('top');
    var xc = cible.token.get('left');
    var yc = cible.token.get('top');
    var distance = Math.floor(Math.sqrt((xc - xt) * (xc - xt) + (yc - yt) * (yc - yt)));
    if (attrSuit) {
      //alors evt contient déjà attrSuit
      attrSuit.set('current', cibleId);
      attrSuit.set('max', distance);
    } else {
      setTokenAttr(perso, 'suit', cibleId, evt, {
        maxVal: distance
      });
    }
    suiveurs.push(perso.token.id + ' ' + perso.token.get('name'));
    attr.set('current', suiveurs.join(':::'));
    sendChar(perso.charId, "suit " + cible.token.get('name'));
    addEvent(evt);
  }

  // !cof-centrer-sur-token tid (ou nom de token)
  function centrerSurToken(msg) {
    var cmd = msg.content.split(' ').filter(function(c) {
      return c !== '';
    });
    if (cmd.length < 2) {
      error("Il faut préciser un token sur lequel se centrer", cmd);
      return;
    }
    var playerId = getPlayerIdFromMsg(msg);
    var pageId;
    if (playerIsGM(playerId)) {
      var p = getObj('player', playerId);
      if (p === undefined) {
        error("Impossible de trouver le joueur qui a lancé la commande", msg);
        return;
      }
      pageId = p.get('_lastpage');
    } else {
      var c = Campaign();
      var ps = c.get('playerspecificpages');
      if (ps) pageId = ps[playerId];
      if (pageId === undefined) pageId = c.get('playerpageid');
    }
    var indexNom = msg.content.indexOf(' ');
    var nom = msg.content.substring(indexNom).trim();
    var perso = persoOfId(cmd[1], nom, pageId);
    if (perso === undefined) {
      error("Impossible de trouver le personnage sur lequel se centrer", cmd);
      return;
    }
    var token = perso.token;
    sendPing(token.get('left'), token.get('top'), pageId, playerId, true, playerId);
  }

  function afficherRichesse(perso, dest) {
    var msg = '';
    var possede;
    var pp = charAttributeAsInt(perso, 'bourse_pp', 0);
    if (pp > 0) {
      msg = pp + " PP";
      possede = true;
    }
    var po = charAttributeAsInt(perso, 'bourse_po', 0);
    if (po > 0) {
      if (possede) msg += ', ';
      else possede = true;
      msg += po + " PO";
    }
    var pa = charAttributeAsInt(perso, 'bourse_pa', 0);
    if (pa > 0) {
      if (possede) msg += ', ';
      else possede = true;
      msg += pa + " PA";
    }
    var pc = charAttributeAsInt(perso, 'bourse_pc', 0);
    if (pc > 0) {
      if (possede) msg += ' et ';
      else possede = true;
      msg += pc + " PC";
    }
    if (possede) msg = 'possède ' + msg;
    else msg = "n'a pas d'argent";
    if (dest) sendPlayer(dest, perso.token.get('name') + ' ' + msg);
    else whisperChar(perso.charId, msg);
  }

  function depenserSous(perso, unite, bourse, depense) {
    if (depense <= 0) return 0;
    var retenue = 0;
    if (bourse[unite] < depense) {
      retenue = Math.ceil((depense - bourse[unite]) / 10);
      bourse[unite] += retenue * 10;
    }
    bourse[unite] -= depense;
    return retenue;
  }

  function ajouteLignePieces(perso, display, unite, nom, piece) {
    var finAction = unite + " --target " + perso.token.id;
    var val = charAttributeAsInt(perso, 'bourse_' + unite, 0);
    var line = '<table style="width:100%"><tr><td>';
    var action =
      "!cof-bourse fixer ?{Nouveau montant de pièces " + piece + " ?} " + finAction;
    line += boutonSimple(action, val) + '<b>' + nom + '</b>';
    line += '</td><td style="text-align: right;">';
    action = "!cof-bourse depenser ?{Pièces " + piece + " à dépenser ?} " + finAction;
    line += boutonSimple(action, 'Dépenser');
    action = "!cof-bourse gagner ?{Pièces " + piece + "  ?} " + finAction;
    line += boutonSimple(action, 'Gagner');
    line += '</td></tr></table>';
    addLineToFramedDisplay(display, line);
  }

  //!cof-bourse [action]
  //Les actions peuvent être depenser val [unite], fixer val unite ou gagner val [unite]
  function gestionBourse(msg) {
    var cmd = msg.content.split(' ').filter(function(c) {
      return c.trim() !== '';
    });
    var action = '';
    var montant;
    var unite = 'pa';
    var depense = {
      pc: 0,
      pa: 0,
      po: 0,
      pp: 0
    };
    if (cmd.length > 1) {
      switch (cmd[1]) {
        case 'depenser':
        case 'dépenser':
        case 'gagner':
        case 'fixer':
          if (cmd.length < 3) {
            error("Il faut spécifier un montant à " + cmd[1], msg.content);
            return;
          }
          montant = parseInt(cmd[2]);
          if (isNaN(montant)) {
            error("montant " + cmd[2] + " incorrect", cmd);
            return;
          }
          if (cmd[1] == 'gagner') {
            montant = -montant;
            action = 'depenser';
          } else if (cmd[1] == 'fixer') {
            if (montant < 0) {
              error("On ne peut avoir qu'un nombre positif de pièces", cmd);
              return;
            }
            action = 'fixer';
          } else action = 'depenser';
          if (cmd.length > 3 && !cmd[3].startsWith('--')) {
            unite = cmd[3].toLowerCase().trim();
            if (unite != 'pp' && unite != 'po' && unite != 'pa' && unite != 'pc') {
              error("Pièces non reconnues : " + cmd[3], cmd);
              return;
            }
            depense[unite] = montant;
          } else if (action == 'fixer') {
            error("Il faut préciser les unités pour !cof-bourse fixer", msg.content);
            return;
          }
          depense.total = depense.pc + 10 * (depense.pa + 10 * (depense.po + 10 * depense.pp));
      }
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        sendPlayer(msg, "Pas de personnage sélectionné pour !cof-bourse");
        return;
      }
      var evt = {
        type: 'bourse'
      };
      iterSelected(selected, function(perso) {
        switch (action) {
          case 'depenser':
            var pc = charAttributeAsInt(perso, 'bourse_pc', 0);
            var pa = charAttributeAsInt(perso, 'bourse_pa', 0);
            var po = charAttributeAsInt(perso, 'bourse_po', 0);
            var pp = charAttributeAsInt(perso, 'bourse_pp', 0);
            if (depense.total < 0) {
              if (depense.pc < 0) {
                pc -= depense.pc;
                setTokenAttr(perso, 'bourse_pc', pc, evt, {
                  charAttr: true
                });
              }
              if (depense.pa < 0) {
                pa -= depense.pa;
                setTokenAttr(perso, 'bourse_pa', pa, evt, {
                  charAttr: true
                });
              }
              if (depense.po < 0) {
                po -= depense.po;
                setTokenAttr(perso, 'bourse_po', po, evt, {
                  charAttr: true
                });
              }
              if (depense.pp < 0) {
                pp -= depense.pp;
                setTokenAttr(perso, 'bourse_pp', pp, evt, {
                  charAttr: true
                });
              }
              addEvent(evt);
              afficherRichesse(perso);
              return;
            }
            var montantPossede = pc + 10 * (pa + 10 * (po + 10 * pp));
            if (montantPossede < depense.total) {
              sendPlayer(msg, perso.token.get('name') + " ne possède pas assez d'argent pour cette dépense");
              afficherRichesse(perso, msg);
              return;
            }
            var bourse = {
              pc: pc,
              pa: pa,
              po: po,
              pp: pp
            };
            // On privilégie les dépenses directes
            var dpp = depense.pp;
            if (dpp <= bourse.pp) {
              bourse.pp -= dpp;
              dpp = 0;
            } else {
              dpp -= bourse.pp;
              bourse.pp = 0;
            }
            var dpo = depense.po;
            if (dpo < bourse.po) {
              bourse.po -= dpo;
              dpo = 0;
            } else {
              dpo -= bourse.po;
              bourse.po = 0;
            }
            var dpa = depense.pa;
            if (dpa <= bourse.pa) {
              bourse.pa -= dpa;
              dpa = 0;
            } else {
              dpa -= bourse.pa;
              bourse.pa = 0;
            }
            var dpc = depense.pc;
            if (dpc < bourse.pc) {
              bourse.pc -= dpc;
              dpc = 0;
            } else {
              dpc -= bourse.pc;
              bourse.pc = 0;
            }
            // Puis on dépense d'abord la petite monnaie
            var v = dpc + 10 * (dpa + 10 * (dpo + 10 * dpp));
            v = depenserSous(perso, 'pc', bourse, v);
            v = depenserSous(perso, 'pa', bourse, v);
            v = depenserSous(perso, 'po', bourse, v);
            v = depenserSous(perso, 'pp', bourse, v);
            if (v > 0) {
              error("Erreur interne de calcul, il reste " + v + " PP à dépenser ??", bourse);
              return;
            }
            if (bourse.pc != pc)
              setTokenAttr(perso, 'bourse_pc', bourse.pc, evt, {
                charAttr: true
              });
            if (bourse.pa != pa)
              setTokenAttr(perso, 'bourse_pa', bourse.pa, evt, {
                charAttr: true
              });
            if (bourse.po != po)
              setTokenAttr(perso, 'bourse_po', bourse.po, evt, {
                charAttr: true
              });
            if (bourse.pp != pp)
              setTokenAttr(perso, 'bourse_pp', bourse.pp, evt, {
                charAttr: true
              });
            addEvent(evt);
            afficherRichesse(perso);
            return;
          case 'fixer':
            addEvent(evt);
            setTokenAttr(perso, 'bourse_' + unite, montant, evt, {
              charAttr: true
            });
            afficherRichesse(perso);
            return;
          default:
            if (selected.length > 1) {
              afficherRichesse(perso, msg);
              return;
            }
            var optionsDisplay = {
              chuchote: true,
              image: 'https://www.on6rm.be/wp-content/uploads/2015/08/vignette_2_bourse-argent.png'
            };
            var titre = "Bourse de " + perso.token.get('name');
            var display = startFramedDisplay(playerId, titre, perso, optionsDisplay);
            ajouteLignePieces(perso, display, 'pp', 'Platine', "de platine");
            ajouteLignePieces(perso, display, 'po', 'Or', "d'or");
            ajouteLignePieces(perso, display, 'pa', 'Argent', "d'argent");
            ajouteLignePieces(perso, display, 'pc', 'Cuivre', "de cuivre");
            sendChat('', endFramedDisplay(display));
        }
      });
    });
  }

  //!cof-mot-de-pouvoir-immobilise --lanceur toid
  function motDePouvoirImmobilise(msg) {
    var options = parseOptions(msg);
    var pageId = options.pageId;
    var evt = {
      type: 'Mot de pouvoir'
    };
    addEvent(evt);
    if (options.lanceur) {
      sendChar(options.lanceur.charId, "Prononce un mot avec la Voix d'une puissance supérieure. Tous ses ennemis sont immobilisés et ses alliés sont galvanisés.");
      var allies = alliesParPerso[options.lanceur.charId];
      if (allies) {
        var tokens = findObjs({
          _type: 'graphic',
          _subtype: 'token',
          _pageid: pageId,
          layer: 'objects'
        });
        tokens.forEach(function(tok) {
          var ci = tok.get('represents');
          if (ci === '') return;
          if (!allies.has(ci)) return;
          var perso = {
            charId: ci,
            token: tok
          };
          setAttrDuree(perso, 'bonusAttaqueTemp', 1, evt);
        });
      }
    }
    getSelected(msg, function(selected, playerId) {
      iterSelected(selected, function(perso) {
        setState(perso, 'immobilise', true, evt);
        setAttrDuree(perso, 'immobiliseTemp', 1, evt);
      });
    }, options);
  }

  // Ajoute evt à l'historique si présent
  // msg n'est pas forcément présent
  function nextTurnChargeFantastique(msg, oldTurnOrder) {
    if (oldTurnOrder) Campaign().set('turnorder', oldTurnOrder);
    var cf = stateCOF.chargeFantastique;
    if (cf === undefined) {
      sendChat("Pas de charge fantastique en cours");
      return;
    }
    if (stateCOF.chargeFantastique.activeTokenId && !peutController(msg, persoOfId(stateCOF.chargeFantastique.activeTokenId))) {
      sendPlayer(msg, "ne peut utiliser ce bouton maintenant");
      return;
    }
    var evt = {
      type: "Tour de charge fantastique",
      chargeFantastique: cf
    };
    var tid, perso;
    if (cf.mouvements && cf.mouvements.length > 0) {
      evt.chargeFantastique.mouvements = [...cf.mouvements];
      evt.chargeFantastique.attaques = cf.attaques;
      tid = cf.mouvements.shift();
      perso = persoOfId(tid);
      if (perso === undefined) {
        error("Personnage en charge fantastique manquant", tid);
        return;
      }
      addEvent(evt);
      var playerIds = getPlayerIds(perso);
      var playerId;
      var optionsDisplay = {
        chuchote: 'gm'
      };
      if (playerIds.length > 0) {
        playerId = playerIds[0];
        optionsDisplay.chuchote = true;
      }
      stateCOF.chargeFantastique.activeTokenId = perso.token.id;
      setTokenInitAura(perso);
      var display = startFramedDisplay(playerId, "Charge fantastique", perso, optionsDisplay);
      addLineToFramedDisplay(display, "Phase de mouvement : déplacez votre token en ligne droite");
      addLineToFramedDisplay(display, "puis " + boutonSimple("!cof-next-charge-fantastique", "cliquez ici"));
      sendChat('', endFramedDisplay(display));
      return;
    }
    if (cf.attaques && cf.attaques.length > 0) {
      evt.chargeFantastique.attaques = [...cf.attaques];
      tid = cf.attaques.shift();
      cf.tokenAttaque = tid;
      if (cf.attaques.length === 0) cf.attaques = undefined;
      perso = persoOfId(tid);
      if (perso === undefined) {
        error("Personnage en charge fantastique manquant", tid);
        return;
      }
      addEvent(evt);
      stateCOF.chargeFantastique.activeTokenId = perso.token.id;
      setTokenInitAura(perso);
      turnAction(perso);
      return;
    }
    stateCOF.chargeFantastique = undefined;
  }

  // !cof-charge-fantastique token_id
  function chargeFantastque(msg) {
    var options = parseOptions(msg);
    var cmd = options.cmd;
    if (!cmd || cmd.length < 2) {
      error("Pas assez d'arguments pour !cof-charge-fantastique", cmd);
      return;
    }
    var chevalier = persoOfId(cmd[1], cmd[1], options.pageId);
    if (chevalier === undefined) {
      error("Le token sélectionné ne représente pas un personnage", cmd);
      return;
    }
    getSelected(msg, function(selected, playerId) {
      if (selected.length === 0) {
        error('pas de token sélectionné pour !cof-charge-fantastique', msg.content);
        return;
      }
      var evt = {
        type: 'Charge fantastique'
      };
      addEvent(evt);
      if (limiteRessources(chevalier, options, 'chargeFantastique', 'charge fantastique', evt)) return;
      sendChar(chevalier.charId, "mène une charge fantastique !");
      initiative(selected, evt);
      stateCOF.chargeFantastique = {};
      var ordreActions = [];
      var chevalierIn;
      iterSelected(selected, function(perso) {
        if (perso.token.id == chevalier.token.id) {
          chevalierIn = true;
          return;
        }
        ordreActions.push({
          init: persoInit(perso, evt),
          perso: perso
        });
      });
      ordreActions.sort(function(p1, p2) {
        if (p1.init < p2.init) return 1;
        if (p1.init > p2.init) return -1;
        // Priorité aux joueurs
        // Premier critère : la barre de PV des joueurs est liée
        if (p1.perso.token.get('bar1_link') === '') {
          if (p2.perso.token.get('bar1_link') === '') return 0;
          return 1;
        }
        if (p2.perso.token.get('bar1_link') === '') return -1;
        // Deuxième critère : les joueurs ont un DV
        var dvA = ficheAttributeAsInt(p1.perso, "DV", 0);
        var dvB = ficheAttributeAsInt(p2.perso, "DV", 0);
        if (dvA === 0) {
          if (dvB === 0) return 0;
          return 1;
        }
        if (dvB === 0) return -1;
        //Entre joueurs, priorité à la plus grosse sagesse
        var sagA = ficheAttributeAsInt(p1.perso, 'sagesse', 10);
        var sagB = ficheAttributeAsInt(p2.perso, 'sagesse', 10);
        if (sagA < sagB) return 1;
        if (sagB > sagA) return -1;
        return 0;
      });
      var mouvements = ordreActions.map(function(p) {
        return p.perso.token.id;
      });
      if (chevalierIn) mouvements.unshift(chevalier.token.id);
      stateCOF.chargeFantastique.mouvements = mouvements;
      stateCOF.chargeFantastique.attaques = [...mouvements];
      nextTurnChargeFantastique();
    }, {
      lanceur: chevalier
    }); //fin du getSelected
  }

  function apiCommand(msg) {
    msg.content = msg.content.replace(/\s+/g, ' '); //remove duplicate whites
    var command = msg.content.split(" ", 1);
    // First replace inline rolls by their values
    replaceInline(msg);
    var evt;
    switch (command[0]) {
      case '!cof-options':
        setCofOptions(msg);
        return;
      case '!cof-jet':
        jet(msg);
        return;
      case '!cof-resultat-jet':
        resultatJet(msg);
        return;
      case '!cof-attack':
        parseAttack(msg);
        return;
      case '!cof-undo':
        undoEvent();
        return;
      case '!cof-confirmer-attaque':
        confirmerAttaque(msg);
        return;
      case '!cof-hors-combat':
      case '!cof-fin-combat':
        sortirDuCombat();
        return;
      case "!cof-nuit": //deprecated
        error("!cof-nuit n'est plus supporté, utiliser !cof-nouveau-jour", msg);
        return;
      case "!cof-jour": //deprecated
        error("!cof-jour n'est plus supporté, utiliser !cof-nouveau-jour", msg);
        return;
      case "!cof-nouveau-jour":
        parseNouveauJour(msg);
        return;
      case "!cof-recuperation":
        parseRecuperer(msg);
        return;
      case "!cof-recharger":
        recharger(msg);
        return;
      case "!cof-bouton-chance":
        boutonChance(msg);
        return;
      case "!cof-bouton-rune-energie":
      case "!cof-rune-energie":
        runeEnergie(msg);
        return;
      case "!cof-rune-puissance":
      case "!cof-bouton-rune-puissance":
        runePuissance(msg);
        return;
      case "!cof-bouton-pousser-kiai":
        kiai(msg);
        return;
      case "!cof-rune-protection":
        runeProtection(msg);
        return;
      case "!cof-surprise":
        parseSurprise(msg);
        return;
      case "!cof-init":
        if (msg.selected === undefined) {
          error("Dans !cof-init : rien à faire, pas de token selectionné", msg);
          return;
        }
        aura_token_on_turn = msg.content.indexOf('--aura') !== -1;
        evt = {
          type: "initiative"
        };
        initiative(msg.selected, evt);
        addEvent(evt);
        return;
      case '!cof-turn-action':
      case '!cof-liste-actions':
        apiTurnAction(msg);
        return;
      case "!cof-attendre":
        attendreInit(msg);
        return;
      case "!cof-statut":
        statut(msg);
        return;
      case "!cof-armure-magique":
        armureMagique(msg);
        return;
      case "!cof-buf-def":
        bufDef(msg);
        return;
      case "!cof-remove-buf-def":
        removeBufDef(msg);
        return;
      case "!cof-aoe": //deprecated
      case "!cof-dmg":
        parseDmgDirects(msg);
        return;
      case "!cof-set-state":
        parseSetState(msg);
        return;
      case "!cof-save-state":
        parseSaveState(msg);
        return;
      case "!cof-degainer":
        parseDegainer(msg);
        return;
      case "!cof-echange-init":
        echangeInit(msg);
        return;
      case "!cof-a-couvert":
        aCouvert(msg);
        return;
      case "!cof-bonus-couvert":
        bonusCouvert(msg);
        return;
      case "!cof-effet-temp":
        parseEffetTemporaire(msg);
        return;
      case "!cof-effet-combat":
        effetCombat(msg);
        return;
      case "!cof-effet":
        effetIndetermine(msg);
        return;
      case "!cof-fin-classe-effet":
        finClasseDEffet(msg);
        return;
      case "!cof-attaque-magique":
        parseAttaqueMagique(msg);
        return;
      case "!cof-injonction":
        parseAttaqueMagique(msg, 'injonction');
        return;
      case "!cof-sommeil":
        parseSommeil(msg);
        return;
      case "!cof-attaque-magique-contre-pv":
        attaqueMagiqueContrePV(msg);
        return;
      case "!cof-transe-guerison":
        transeGuerison(msg);
        return;
      case "!cof-soin":
        soigner(msg);
        return;
      case "!cof-aoe-soin": //Deprecated
        aoeSoin(msg);
        return;
      case "!cof-nature-nourriciere":
        parseNatureNourriciere(msg);
        return;
      case "!cof-ignorer-la-douleur":
        ignorerLaDouleur(msg);
        return;
      case "!cof-fortifiant":
        fortifiant(msg);
        return;
      case "!cof-intercepter":
        intercepter(msg);
        return;
      case "!cof-interposer":
        interposer(msg);
        return;
      case "!cof-esquive-fatale":
        doEsquiveFatale(msg);
        return;
      case "!cof-exemplaire":
        exemplaire(msg);
        return;
      case "!cof-intervention-divine":
        interventionDivine(msg);
        return;
      case "!cof-lancer-sort":
        lancerSort(msg);
        return;
      case "!cof-as":
        emulerAs(msg);
        return;
      case "!cof-peur":
        parsePeur(msg);
        return;
      case "!cof-distribuer-baies":
        distribuerBaies(msg);
        return;
      case "!cof-consommer-baie":
        consommerBaie(msg);
        return;
      case "!cof-proteger-un-allie":
        protegerUnAllie(msg);
        return;
      case "!cof-action-defensive":
        actionDefensive(msg);
        return;
      case "!cof-strangulation":
        strangulation(msg);
        return;
      case "!cof-ombre-mortelle":
        ombreMortelle(msg);
        return;
      case "!cof-escalier":
        escalier(msg);
        return;
      case "!cof-defaut-dans-la-cuirasse":
        defautDansLaCuirasse(msg);
        return;
      case '!cof-posture-de-combat':
        postureDeCombat(msg);
        return;
      case '!cof-mur-de-force':
        murDeForce(msg);
        return;
      case '!cof-capitaine':
        devientCapitaine(msg);
        return;
      case '!cof-tueur-fantasmagorique':
        parseAttaqueMagique(msg, 'tueurFantasmagorique');
        return;
      case '!cof-injonction-mortelle':
        parseInjonctionMortelle(msg);
        return;
      case '!cof-tour-de-force': // Deprecrated
        parseTourDeForce(msg);
        return;
      case '!cof-prouesse':
        boutonProuesse(msg);
        return;
      case '!cof-tour-force':
        boutonTourDeForce(msg);
        return;
      case '!cof-pacte-sanglant':
        boutonPacteSanglant(msg);
        return;
      case '!cof-pacte-sanglant-def':
        boutonPacteSanglantDef(msg);
        return;
      case '!cof-encaisser-un-coup':
        doEncaisserUnCoup(msg);
        return;
      case '!cof-parade-projectiles':
        doParadeProjectiles(msg);
        return;
      case "!cof-esquive-acrobatique":
        doEsquiveAcrobatique(msg);
        return;
      case "!cof-resister-a-la-magie":
        resisterALaMagie(msg);
        return;
      case "!cof-cercle-protection":
        cercleDeProtection(msg);
        return;
      case "!cof-parade-magistrale":
        doParadeMagistrale(msg);
        return;
      case "!cof-esquive-magistrale":
        doEsquiveMagistrale(msg);
        return;
      case "!cof-absorber-au-bouclier":
      case "!cof-absorber-coup-au-bouclier":
        absorberCoupAuBouclier(msg);
        return;
      case "!cof-absorber-sort-au-bouclier":
        absorberSortAuBouclier(msg);
        return;
      case "!cof-chair-a-canon":
        doChairACanon(msg);
        return;
      case "!cof-demarrer-statistiques":
        if (stateCOF.statistiquesEnPause) {
          stateCOF.statistiques = stateCOF.statistiquesEnPause;
          delete stateCOF.statistiquesEnPause;
        } else {
          stateCOF.statistiques = {}; //remet aussi les statistiques à 0
        }
        return;
      case "!cof-arreter-statistiques":
        delete stateCOF.statistiques;
        return;
      case "!cof-pause-statistiques":
        if (stateCOF.statistiques) {
          stateCOF.statistiquesEnPause = stateCOF.statistiques;
          delete stateCOF.statistiques;
        } // sinon, ne pas écraser les statistiques déjà en pause
        return;
      case '!cof-statistiques':
        displayStatistics(msg);
        return;
      case '!cof-destruction-des-morts-vivants':
        parseDestructionDesMortsVivants(msg);
        return;
      case '!cof-enduire-poison':
        parseEnduireDePoison(msg);
        return;
      case '!cof-consommables':
        listeConsommables(msg);
        return;
      case '!cof-utilise-consommable': //Usage interne seulement
        utiliseConsommable(msg);
        return;
      case '!cof-echange-consommable': //Usage interne seulement
        echangeConsommable(msg);
        return;
      case '!cof-provocation':
        parseProvocation(msg);
        return;
      case '!cof-en-selle':
        enSelle(msg);
        return;
      case '!cof-creer-elixir': //usage interne seulement
        creerElixir(msg);
        return;
      case '!cof-elixirs':
        gestionElixir(msg);
        return;
      case '!cof-runes':
        gestionRunes(msg);
        return;
      case '!cof-creer-rune': // usage interne seulement
        creerRune(msg);
        return;
      case '!cof-rage-du-berserk':
        parseRageDuBerserk(msg);
        return;
      case '!cof-arme-secrete':
        parseArmeSecrete(msg);
        return;
      case '!cof-animer-arbre':
        animerUnArbre(msg);
        return;
      case '!cof-delivrance':
      case '!cof-guerir':
        delivrance(msg);
        return;
      case '!cof-guerison':
        guerison(msg);
        return;
      case '!cof-test-attaque-opposee':
        testAttaqueOpposee(msg);
        return;
      case '!cof-manoeuvre':
        manoeuvreRisquee(msg);
        return;
      case '!cof-appliquer-manoeuvre':
        appliquerManoeuvre(msg);
        return;
      case '!cof-desarmer':
        desarmer(msg);
        return;
      case '!cof-tempete-de-mana':
        optionsDeTempeteDeMana(msg);
        return;
      case '!cof-deplacer-token':
        deplacerToken(msg);
        return;
      case '!cof-permettre-deplacement':
        permettreDeplacement(msg);
        return;
      case '!cof-tour-suivant':
        tourSuivant(msg);
        return;
      case '!cof-multi-command':
        multiCommand(msg);
        return;
      case '!cof-conjuration-de-predateur':
        conjurationPredateur(msg);
        return;
      case '!cof-conjuration-armee':
        conjurationArmee(msg);
        return;
      case '!cof-set-macros':
        setGameMacros(msg);
        return;
      case '!cof-lumiere':
        ajouteLumiere(msg);
        return;
      case '!cof-eteindre-lumiere':
        eteindreLumieres(msg);
        return;
      case '!cof-torche':
        switchTorche(msg);
        return;
      case '!cof-defi-samourai':
        lancerDefiSamourai(msg);
        return;
      case '!cof-enveloppement':
        parseEnveloppement(msg);
        return;
      case '!cof-echapper-enveloppement':
        parseEchapperEnveloppement(msg);
        return;
      case '!cof-liberer-agrippe':
        parseLibererAgrippe(msg);
        return;
      case '!cof-animer-cadavre':
        animerCadavre(msg);
        return;
      case '!cof-vapeurs-ethyliques':
        parseVapeursEthyliques(msg);
        return;
      case '!cof-desaouler':
        desaouler(msg);
        return;
      case '!cof-boire-alcool':
        parseBoireAlcool(msg);
        return;
      case '!cof-jouer-son':
        jouerSon(msg);
        return;
      case '!cof-bouton-echec-total':
        echecTotal(msg);
        return;
      case '!cof-usure-off':
        stateCOF.usureOff = true;
        sendChat('COF', "/w GM Pas d'usure de la DEF sur ce combat");
        return;
      case '!cof-set-attribute':
        setAttributeInterface(msg);
        return;
      case '!cof-options-d-attaque':
        optionsDAttaque(msg);
        return;
      case '!cof-petit-veinard':
      case '!cof-bouton-petit-veinard':
        petitVeinard(msg);
        return;
      case '!cof-suivre':
        suivre(msg);
        return;
      case '!cof-centrer-sur-token':
        centrerSurToken(msg);
        return;
      case '!cof-bourse':
        gestionBourse(msg);
        return;
      case '!cof-mot-de-pouvoir-immobilise':
        motDePouvoirImmobilise(msg);
        return;
      case '!cof-charge-fantastique':
        chargeFantastque(msg);
        return;
      case '!cof-next-charge-fantastique':
        nextTurnChargeFantastique(msg);
        return;
      case '!cof-tenebres':
        tenebres(msg);
        return;
      case '!cof-defense-armee-des-morts':
        defenseArmeeDesMorts(msg);
        return;
      case '!cof-invoquer-demon':
        invocationDemon(msg);
        return;
      default:
        error("Commande " + command[0] + " non reconnue.", command);
        return;
    }
  }

  //Attributs possibles :
  // dm : permet d'infliger des dm
  // soins : soigne
  // prejudiciable: est un effet préjudiciable, qui peut être enlevé par délivrance
  // generic: admet un argument entre parenthèses
  // seulementVivant: ne peut s'appliquer qu'aux créatures vivantes
  var messageEffetTemp = {
    sousTension: {
      activation: "se charge d'énergie électrique",
      actif: "est chargé d'énergie électrique",
      fin: "n'est plus chargé d'énergie électrique",
      dm: true
    },
    aCouvert: {
      activation: "reste à couvert",
      actif: "est à couvert",
      fin: "n'est plas à couvert"
    },
    imageDecalee: {
      activation: "décale légèrement son image",
      actif: "a décalé son image",
      fin: "apparaît à nouveau là où il se trouve"
    },
    chantDesHeros: {
      activation: "écoute le chant du barde",
      actif: "est inspiré par le Chant des Héros",
      fin: "n'est plus inspiré par le Chant des Héros"
    },
    benediction: {
      activation: "est touché par la bénédiction",
      activationF: "est touchée par la bénédiction",
      actif: "est béni",
      fin: "l'effet de la bénédiction s'estompe"
    },
    peauDEcorce: {
      activation: "donne à sa peau la consistance de l'écorce",
      actif: "a la peau dure comme l'écorce",
      fin: "retrouve une peau normale"
    },
    rayonAffaiblissant: {
      activation: "est touché par un rayon affaiblissant",
      activationF: "est touchée par un rayon affaiblissant",
      actif: "est sous l'effet d'un rayon affaiblissant",
      fin: "n'est plus affaibli",
      prejudiciable: true
    },
    apeureTemp: {
      activation: "prend peur",
      actif: "est dominé par sa peur",
      fin: "retrouve du courage",
      prejudiciable: true
    },
    peurEtourdi: {
      activation: "prend peur: il peut fuir ou rester recroquevillé",
      activationF: "prend peur: elle peut fuir ou rester recroquevillé",
      actif: "est paralysé par la peur",
      fin: "retrouve du courage et peut à nouveau agir",
      prejudiciable: true
    },
    aveugleTemp: {
      activation: "n'y voit plus rien !",
      actif: "est aveuglé",
      fin: "retrouve la vue",
      prejudiciable: true
    },
    ralentiTemp: {
      activation: "est ralenti : une seule action, pas d'action limitée",
      activationF: "est ralentie : une seule action, pas d'action limitée",
      actif: "est ralenti",
      fin: "n'est plus ralenti",
      prejudiciable: true
    },
    paralyseTemp: {
      activation: "est paralysé : aucune action ni déplacement possible",
      activationF: "est paralysée : aucune action ni déplacement possible",
      actif: "est paralysé",
      fin: "n'est plus paralysé",
      prejudiciable: true
    },
    immobiliseTemp: {
      activation: "est immobilisé : aucun déplacement possible",
      activationF: "est immobilisée : aucun déplacement possible",
      actif: "est immobilisé",
      fin: "n'est plus immobilisé",
      prejudiciable: true
    },
    etourdiTemp: {
      activation: "est étourdi : aucune action et -5 en DEF",
      activationF: "est étourdie : aucune action et -5 en DEF",
      actif: "est étourdi",
      fin: "n'est plus étourdi",
      prejudiciable: true
    },
    affaibliTemp: {
      activation: "se sent faible",
      actif: "est affaibli",
      fin: "se sent moins faible",
      prejudiciable: true
    },
    assomeTemp: {
      activation: "est assomé",
      activationF: "est assomée",
      actif: "est assomé",
      fin: "reprend conscience",
      prejudiciable: true
    },
    aveugleManoeuvre: {
      activation: "est aveuglé par la manoeuvre",
      activationF: "est aveuglée par la manoeuvre",
      actif: "a du mal à voir où sont ses adversaires",
      fin: "retrouve une vision normale",
      prejudiciable: true
    },
    bloqueManoeuvre: {
      activation: "est bloqué par la manoeuvre",
      activationF: "est bloquée par la manoeuvre",
      actif: "est bloqué et ne peut pas se déplacer",
      fin: "peut à nouveau se déplacer",
      prejudiciable: true
    },
    diversionManoeuvre: {
      activation: "est déconcentré",
      activationF: "est déconcentrée",
      actif: "a été perturbé par une diversion",
      fin: "se reconcentre sur le combat",
      prejudiciable: true
    },
    menaceManoeuvre: {
      activation: "est menacé",
      activationF: "est menacée",
      actif: "a été menacée, risque de plus de DM",
      fin: "n'est plus sous la menace",
      prejudiciable: true,
      generic: true
    },
    tenuADistanceManoeuvre: {
      activation: "est tenu à distance",
      activationF: "est tenue à distance",
      actif: "est tenu à distance de son adversaire, il ne peut pas l'attaquer",
      fin: "peut à nouveau attaquer son adversaire",
      prejudiciable: true,
      generic: true
    },
    epeeDansante: {
      activation: "fait apparaître une lame d'énergie lumineuse",
      actif: "contrôle une lame d'énergie lumineuse",
      fin: "La lame d'énergie lumineuse disparaît",
      dm: true
    },
    putrefaction: {
      activation: "vient de contracter une sorte de lèpre fulgurante",
      actif: "est en pleine putréfaction",
      fin: "La putréfaction s'arrête.",
      prejudiciable: true,
      dm: true
    },
    forgeron: {
      activation: "enflamme son arme",
      actif: "a une arme en feu",
      fin: "L'arme n'est plus enflammée.",
      dm: true,
      generic: true
    },
    armeEnflammee: {
      activation: "voit son arme prendre feu",
      actif: "a une arme enflammée",
      fin: "L'arme n'est plus enflammée.",
      dm: true,
      generic: true
    },
    armesEnflammees: {
      activation: "voit ses armes prendre feu",
      actif: "a des armes enflammées",
      fin: "Les armes ne sont plus enflammées.",
      dm: true,
    },
    dotGen: {
      activation: "subit un effet",
      actif: "subit régulièrement des dégâts",
      fin: "ne subit plus ces effets de dégâts",
      dm: true,
      prejudiciable: true,
      generic: true
    },
    rechargeGen: {
      activation: "doit maintenant attendre un peu avant de pouvoir le refaire",
      actif: "attends avant de pouvoir refaire une attaque",
      fin: "a récupéré",
      generic: true
    },
    dmgArme1d6: {
      activation: "enduit son arme d'une huile magique",
      actif: "a une arme plus puissante",
      fin: "L'arme retrouve sa puissance normale",
      dm: true,
      generic: true
    },
    flou: {
      activation: "devient flou",
      activationF: "devient floue",
      actif: "apparaît flou",
      fin: "redevient net"
    },
    agrandissement: {
      activation: "se met à grandir",
      actif: "est vraiment très grand",
      fin: "retrouve sa taille normale"
    },
    formeGazeuse: {
      activation: "semble perdre de la consistance",
      actif: "est en forme gazeuse",
      fin: "retrouve sa consistance normale"
    },
    intangible: {
      activation: "devient translucide",
      actif: "est intangible",
      fin: "redevient solide"
    },
    strangulation: {
      activation: "commence à étouffer",
      actif: "est étranglé",
      fin: "respire enfin",
      prejudiciable: true,
      seulementVivant: true,
      dm: true
    },
    ombreMortelle: {
      activation: "voit son ombre s'animer et l'attaquer !",
      actif: "est une ombre animée",
      fin: "retrouve une ombre normale",
      dm: true
    },
    dedoublement: {
      activation: "voit un double translucide sortir de lui",
      activationF: "voit un double translucide sortir d'elle",
      actif: "est un double translucide",
      fin: "le double disparaît",
      dm: true
    },
    zoneDeSilence: {
      activation: "n'entend plus rien",
      actif: "est totalement sourd",
      fin: "peut à nouveau entendre"
    },
    danseIrresistible: {
      activation: "se met à danser",
      actif: "danse malgré lui",
      fin: "s'arrête de danser",
      prejudiciable: true
    },
    confusion: {
      activation: "ne sait plus très bien ce qu'il fait là",
      activationF: "ne sait plus très bien ce qu'elle fait là",
      actif: "est en pleine confusion",
      fin: "retrouve ses esprits",
      prejudiciable: true
    },
    murDeForce: {
      activation: "fait apparaître un mur de force",
      actif: "en entouré d'un mur de force",
      fin: "voit son mur de force disparaître"
    },
    asphyxie: {
      activation: "commence à manquer d'air",
      actif: "étouffe",
      fin: "peut à nouveau respirer",
      prejudiciable: true,
      seulementVivant: true,
      statusMarker: 'blue',
      dm: true
    },
    forceDeGeant: {
      activation: "devient plus fort",
      activationE: "devient plus forte",
      actif: "a une force de géant",
      fin: "retrouve sa force normale"
    },
    saignementsSang: {
      activation: "commence à saigner du nez, des oreilles et des yeux",
      actif: "saigne de tous les orifices du visage",
      fin: "ne saigne plus",
      prejudiciable: true,
      statusMarker: 'red',
      dm: true
    },
    encaisserUnCoup: {
      activation: "se place de façon à dévier un coup sur son armure",
      actif: "est placé de façon à dévier un coup",
      fin: "n'est plus en position pour encaisser un coup"
    },
    seulContreTous: {
      activation: "se place de façon à faire face à tous ses adversaires",
      actif: "riposte",
      fin: "ne fait plus face à tous ses adversaires"
    },
    absorberUnCoup: {
      activation: "se prépare à absorber un coup avec son bouclier",
      actif: "est prêt à absorber un coup avec son bouclier",
      fin: "n'est plus en position de prendre le prochain coup sur son bouclier"
    },
    absorberUnSort: {
      activation: "se prépare à absorber un sort avec son bouclier",
      actif: "est prêt à absorber un sort avec son bouclier",
      fin: "n'est plus en position de se protéger d'un sort avec son bouclier"
    },
    nueeDInsectes: {
      activation: "est attaqué par une nuée d'insectes",
      activationF: "est attaquée par une nuée d'insectes",
      actif: "est entouré d'une nuée d'insectes",
      fin: "est enfin débarassé des insectes",
      prejudiciable: true,
      dm: true
    },
    nueeDeCriquets: {
      activation: "est attaqué par une nuée de criquets",
      activationF: "est attaquée par une nuée de criquets",
      actif: "est entouré d'une nuée de criquets",
      fin: "est enfin débarassé des criquets",
      prejudiciable: true,
      dm: true
    },
    toiles: {
      activation: "voit des toiles d'araignées apparaître tout autour",
      actif: "est bloqué par des toiles d'araignées",
      fin: "se libère des toiles",
      prejudiciable: true,
      statusMarker: 'cobweb' //À changer
    },
    prisonVegetale: {
      activation: "voit des plantes pousser et s'enrouler autour de ses jambes",
      actif: "est bloqué par des plantes",
      fin: "se libère des plantes",
      prejudiciable: true,
      statusMarker: 'green'
    },
    protectionContreLesElements: {
      activation: "lance un sort de protection contre les éléments",
      actif: "est protégé contre les éléments",
      fin: "n'est plus protégé contre les éléments"
    },
    masqueMortuaire: {
      activation: "prend l'apparence de la mort",
      actif: "semble mort et animé",
      fin: "retrouve une apparence de vivant"
    },
    armeBrulante: {
      activation: "sent son arme lui chauffer la main",
      actif: "se brûle la main sur son arme",
      fin: "sent son arme refroidir",
      dm: true
    },
    armureBrulante: {
      activation: "sent son armure chauffer",
      actif: "brûle dans son armure",
      fin: "sent son armure refroidir",
      dm: true
    },
    masqueDuPredateur: {
      activation: "prend les traits d'un prédateur",
      actif: "a les traits d'un prédateur",
      fin: "redevient normal"
    },
    aspectDeLaSuccube: {
      activation: "acquiert une beauté fascinante",
      actif: "est d'une beauté fascinante",
      fin: "retrouve sa beauté habituelle"
    },
    aspectDuDemon: {
      activation: "prend l’apparence d’un démon",
      actif: "a l’apparence d’un démon",
      fin: "retrouve son apparence habituelle"
    },
    sangMordant: {
      activation: "transforme son sang",
      actif: "a du sang acide",
      fin: "retrouve un sang normal"
    },
    armeSecreteBarde: {
      activation: "est déstabilisé",
      activationF: "est déstabilisée",
      actif: "est déstabilisé par une action de charme",
      fin: "retrouve ses esprits",
      prejudiciable: true
    },
    regeneration: {
      activation: "commence à se régénérer",
      actif: "se régénère",
      fin: "a fini de se régénérer",
      soins: true
    },
    arbreAnime: {
      activation: "commence à bouger",
      actif: "est un arbre animé",
      fin: "redevient un arbre ordinaire"
    },
    magnetisme: {
      activation: "contrôle le magnétisme",
      actif: "contrôle le magnétisme",
      fin: "relache son contrôle du magnétisme"
    },
    hate: {
      activation: "voit son métabolisme s'accélérer",
      actif: "peut faire une action de plus par tour",
      fin: "retrouve un métabolisme normal (plus d'action supplémentaire)"
    },
    ailesCelestes: {
      activation: "sent des ailes célestes lui pousser dans le dos",
      actif: "possède des ailes célestes",
      fin: "n'a plus d'aile céleste. Espérons qu'il était au sol..."
    },
    sanctuaire: {
      activation: "lance un sort de sanctuaire",
      actif: "est protégé par un sanctuaire",
      fin: "n'est plus protégé par le sanctuaire"
    },
    rechargeSouffle: {
      activation: "doit maintenant attendre un peu avant de pouvoir le refaire",
      actif: "attends avant de pouvoir refaire un souffle",
      fin: "a récupéré"
    },
    paralysieRoublard: {
      activation: "est paralysé par la douleur",
      activationF: "est paralysée par la douleur",
      actif: "ne peut pas attaquer ni se déplacer",
      fin: "peut à nouveau attaquer et se déplacer",
      prejudiciable: true,
      seulementVivant: true
    },
    mutationOffensive: {
      activation: "échange une partie de son corps avec celle d'une créature monstrueuse",
      actif: "possède un appendice monstrueux",
      fin: "retrouve un corps normal"
    },
    formeDArbre: {
      activation: "se transorme en arbre",
      actif: "est transformé en arbre",
      fin: "retrouve sa forme normale"
    },
    statueDeBois: {
      activation: "se transforme en statue de bois",
      actif: "est transformé en statue de bois",
      fin: "retrouve sa forme normale",
      prejudiciable: true
    },
    clignotement: {
      activation: "disparaît, puis réapparaît",
      actif: "clignote",
      fin: "ne disparaît plus"
    },
    agitAZeroPV: {
      activation: "continue à agir malgré les blessures",
      actif: "devrait être à terre",
      fin: "subit l'effet de ses blessures"
    },
    predateurConjure: {
      activation: "apparaît depuis un autre plan",
      actif: "est un prédateur conjuré",
      fin: "disparaît",
      dm: true
    },
    champDeProtection: {
      activation: "devient protégé par un champ télékinétique",
      actif: "est protégé par un champ télékinétique",
      fin: "n'est plus sous l'effet d'un champ de protection",
    },
    attaqueArmeeConjuree: {
      activation: "se bat contre une armée conjurée",
      actif: "se bat contre une armée conjurée",
      fin: "ne se bat plus contre l'armée conjurée"
    },
    rechargeDuKiai: {
      activation: "pousse un kiai",
      actif: "ne peut pas encore pousser un autre kiai",
      fin: "peut pousser un autre kiai"
    },
    memePasMalBonus: {
      activation: "enrage suite au coup critique",
      actif: "a subit un coup critique",
      fin: "ne bénéficie plus des effets de même pas mal"
    },
    attaqueRisquee: {
      activation: "fait une attaque risquée",
      actif: "s'est mis en danger par une attaque risquée",
      fin: "retrouve une position moins risquée",
    },
    peauDePierreMag: {
      activation: "transforme sa peau en pierre",
      actif: "voit ses dégâts réduits par sa Peau de pierre",
      fin: "retrouve sa peau normale",
    },
    expose: {
      activation: "s'expose aux attaques de sa cible",
      actif: "est exposé aux attaques de son adversaire",
      fin: "n'est plus exposé",
      prejudiciable: true
    },
    effetRetarde: {
      activation: "il va bientôt se produire quelque chose",
      actif: "s'attend à un effet",
      fin: "effet retardé activé",
      generic: true,
      prejudiciable: true
    },
    messageRetarde: {
      activation: "il va bientôt se produire quelque chose",
      actif: "s'attend à un effet",
      fin: "effet activé",
      generic: true
    },
    detectionDeLInvisible: {
      activation: "voit les choses invibles et cachées",
      actif: "détecte l'invisible",
      fin: "ne voit plus les choses invisibles",
    },
    bonusAttaqueTemp: {
      activation: "affecte son attaque",
      actif: "a son attaque affectée",
      fin: "retrouve son attaque normale",
    },
    enerve: {
      activation: "est énervé par ces railleries",
      activationF: "est énervée par ces railleries",
      actif: "est énervé",
      fin: "retrouve son calme",
      prejudiciable: true
    },
    cercleDeProtection: {
      activation: "est protégé par le Cercle de protection",
      activationF: "est protégée par le Cercle de protection",
      actif: "est dans le Cercle de protection",
      fin: "sort du Cercle de protection",
    },
    tenebres: {
      activation: "lance un sort de Ténèbres",
      actif: "maintient un sort de Ténèbres",
      fin: "les ténèbres se dissipent"
    },
    progresserACouvert: {
      activation: "est à couvert de bouclier",
      actif: "est à couvert de bouclier",
      fin: "n'est plus à couvert de bouclier"
    },
    cyclone: {
      activation: "se transforme en tourbillon de matière élémentaire",
      actif: "est en cyclone",
      fin: "retrouve sa forme habituelle",
    },
    momentDePerfection: {
      activation: "atteint un instant de perfection",
      actif: "semble tout voir au ralenti autour de lui",
      fin: "voit le temps reprendre son cours normal",
    },
    armeeDesMorts: {
      activation: "invoque d'innombrables squelettes émergeant du sol",
      actif: "invoque d'innombrables squelettes",
      fin: "laisse les morts en paix",
    },
    demonInvoque: {
      activation: "apparaît depuis un autre plan",
      actif: "est un démon invoqué",
      fin: "disparaît",
      dm: true
    }
  };

  function buildPatternEffets(listeEffets, postfix) {
    if (postfix && postfix.length === 0) postfix = undefined;
    var expression = "(";
    expression = _.reduce(listeEffets, function(reg, msg, effet) {
      var res = reg;
      if (res !== "(") res += "|";
      res += "^" + effet;
      if (msg.generic) res += "\\([^)_]*\\)";
      res += "(";
      if (postfix) {
        postfix.forEach(function(p, i) {
          if (i) res += "|";
          res += p + "$|" + p + "_";
        });
      } else res += "$|_";
      res += ")";
      return res;
    }, expression);
    expression += ")";
    return new RegExp(expression);
  }

  var patternEffetsTemp = buildPatternEffets(messageEffetTemp);

  function estEffetTemp(name) {
    return (patternEffetsTemp.test(name));
  }

  var patternAttributEffetsTemp = buildPatternEffets(messageEffetTemp, ["Puissant", "Valeur", "SaveParTour", "SaveParTourType", "TempeteDeManaIntense"]);

  function estAttributEffetTemp(name) {
    return (patternAttributEffetsTemp.test(name));
  }

  //On sait déjà que le nom a passé le test estEffetTemp
  function effetTempOfAttribute(attr) {
    var ef = attr.get('name');
    if (ef === undefined || messageEffetTemp[ef]) return ef;
    //D'abord on enlève le nom du token
    var pu = ef.indexOf('_');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetTemp[ef]) return ef;
    }
    //Ensuite on enlève les parties entre parenthèse pour les effets génériques
    pu = ef.indexOf('(');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetTemp[ef]) return ef;
    }
    error("Impossible de déterminer l'effet correspondant à " + ef, attr);
  }

  function messageOfEffetTemp(effetC) {
    var res = messageEffetTemp[effetC];
    if (res) return res;
    var p = effetC.indexOf('(');
    if (p > 0) {
      var ef = effetC.substring(0, p);
      res = messageEffetTemp[ef];
      return res;
    }
    error("Effet temporaire non trouvé", effetC);
  }

  var messageEffetCombat = {
    armureMagique: {
      activation: "est entouré d'un halo magique",
      actif: "est protégé par une armure magique",
      fin: "n'est plus entouré d'un halo magique"
    },
    armureDuMage: {
      activation: "fait apparaître un nuage magique argenté qui le protège",
      actif: "est entouré d'une armure du mage",
      fin: "n'a plus son armure du mage"
    },
    armureDEau: {
      activation: "fait apparaître une couche d'eau de quelques centimètres qui le protège",
      actif: "est entouré d'une armure d'eau'",
      fin: "n'a plus son armure d'eau'"
    },
    armeDArgent: {
      activation: "crée une arme d'argent et de lumière",
      actif: "possède une arme d'argent et de lumière",
      fin: "ne possède plus d'arme d'argent et de lumière",
      dm: true
    },
    criDeGuerre: {
      activation: "pousse son cri de guerre",
      actif: "a effrayé ses adversaires",
      fin: ""
    },
    criDuPredateur: {
      activation: "pousse un hurlement effrayant",
      actif: "a libéré son âme de prédateur",
      fin: ""
    },
    protectionContreLeMal: {
      activation: "reçoit une bénédiction de protection contre le mal",
      actif: "est protégé contre le mal",
      fin: "n'est plus protégé contre le mal"
    },
    rageDuBerserk: {
      activation: "entre dans une rage berserk",
      actif: "est dans une rage berserk",
      fin: "retrouve son calme"
    },
    enragé: {
      activation: "devient enragé",
      actif: "est enragé",
      fin: "retrouve son calme"
    },
    bonusInitEmbuscade: { //Effet interne pour la capacité Surveillance
      activation: "a un temps d'avance en cas d'embuscade",
      actif: "a un temps d'avance",
      fin: ""
    },
    putrefactionOutreTombe: {
      activation: "sent ses chairs pourrir",
      actif: "subit le contrecoup d'une putréfaction",
      fin: "se remet de la putréfaction",
      prejudiciable: true,
      dm: true
    },
    bonusInitVariable: {
      activation: "entre en combat",
      actif: "est en combat",
      fin: ''
    },
    defiSamourai: {
      activation: "lance un défi",
      actif: "a lancé un défi",
      fin: ''
    },
    agrippe: {
      activation: "agrippe sa cible",
      actif: "agrippe sa cible",
      fin: "lache sa cible"
    },
    estAgrippePar: {
      activation: "est agrippé",
      actif: "est agrippé",
      fin: "se libère"
    },
    inconfort: {
      activation: "commence à être gêné par son armure",
      actif: "est gêné par son armure",
      fin: "réajuste son armure",
    },
  };

  var patternEffetsCombat = buildPatternEffets(messageEffetCombat);

  function estEffetCombat(name) {
    return (patternEffetsCombat.test(name));
  }

  var patternAttributEffetsCombat = buildPatternEffets(messageEffetCombat, ["Puissant", "Valeur", "SaveParTour", "SaveParTourType", "TempeteDeManaIntense"]);

  function estAttributEffetCombat(name) {
    return (patternAttributEffetsCombat.test(name));
  }

  function effetCombatOfAttribute(attr) {
    var ef = attr.get('name');
    if (ef === undefined || messageEffetCombat[ef]) return ef;
    //D'abord on enlève le nom du token
    var pu = ef.indexOf('_');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetCombat[ef]) return ef;
    }
    error("Impossible de déterminer l'effet correspondant à " + ef, attr);
  }

  var messageEffetIndetermine = {
    aCheval: { //deprecated, mieux vaut utiliser la commande !cof-en-selle
      activation: "monte sur sa monture",
      actif: "est sur sa monture",
      fin: "descend de sa monture"
    },
    marcheSylvestre: {
      activation: "se deplace maintenant en terrain difficile",
      actif: "profite du terrain difficile",
      fin: "est maintenant en terrain normal"
    },
    foretVivanteEnnemie: {
      activation: "est gêné par la forêt",
      actif: "est désorienté par la forêt",
      fin: "se retrouve dans une forêt normale"
    },
    mutationCuirasse: {
      activation: "endurcit sa peau",
      actif: "a la peau recouverte d'une cuirasse",
      fin: "retrouve une peau normale"
    },
    mutationEcaillesRouges: {
      activation: "recouvre sa peau d'écailles rouges",
      actif: "a la peau recouverte d'écailles rouges",
      fin: "retrouve une peau normale"
    },
    mutationFourrureViolette: {
      activation: "se fait pousser une fourrure violette",
      actif: "a la peau recouverte d'une fourrure violette",
      fin: "retrouve une peau normale"
    },
    mutationOuies: {
      activation: "se fait pousser des ouïes",
      actif: "possède des ouïes",
      fin: "n'a plus d'ouïes"
    },
    mutationSangNoir: {
      activation: "prend un teint plus sombre",
      actif: "a le sang noir",
      fin: "retrouve un sang normal"
    },
    mutationMusclesHypertrophies: {
      activation: "devient plus musclé",
      actif: "a les muscles hypertrophiés",
      fin: "retrouve des muscles normaux",
    },
    mutationSilhouetteFiliforme: {
      activation: "devient plus fin",
      actif: "a une silhouette filiforme",
      fin: "retrouve une silhouette normale",
    },
    mutationSilhouetteMassive: {
      activation: "devient plus massif",
      actif: "a une silhouette massive",
      fin: "retrouve une silhouette normale",
    },
    presenceGlaciale: {
      activation: "transforme son corps en glace vivante",
      actif: "est formé de glace",
      fin: "retrouve un corps normal",
    },
    sixiemeSens: {
      activation: "fait un rituel de divination",
      actif: "sait un peu à l'avance ce qu'il va se passer",
      fin: "l'effet du rituel de divination prend fin",
    },
    charmé: {
      activation: "devient un ami de longue date",
      actif: "est sous le charme de quelqu'un",
      fin: "retrouve ses esprits"
    },
  };

  var patternEffetsIndetermine = buildPatternEffets(messageEffetIndetermine);

  function estEffetIndetermine(name) {
    return (patternEffetsIndetermine.test(name));
  }

  function effetIndetermineOfAttribute(attr) {
    var ef = attr.get('name');
    if (ef === undefined || messageEffetIndetermine[ef]) return ef;
    //D'abord on enlève le nom du token
    var pu = ef.indexOf('_');
    if (pu > 0) {
      ef = ef.substring(0, pu);
      if (messageEffetIndetermine[ef]) return ef;
    }
    error("Impossible de déterminer l'effet correspondant à " + ef, attr);
  }

  function attributeExtending(charId, attrName, effetC, extension) {
    var nameWithExtension = effetC + extension + attrName.substr(effetC.length);
    return findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: nameWithExtension
    });
  }

  //L'argument effetC doit être le nom complet, pas la base
  //evt.deletedAttributes doit être défini
  function enleverEffetAttribut(charId, effetC, attrName, extension, evt) {
    var attrSave = attributeExtending(charId, attrName, effetC, extension);
    attrSave.
    forEach(function(attrS) {
      evt.deletedAttributes.push(attrS);
      attrS.remove();
    });
  }

  //Nom de l'effet, avec la partie générique, mais sans le nom de token
  function effetComplet(effet, attrName) {
    if (effet == attrName) return effet;
    //On a un effet lié à un token ou bien un effet générique
    if (attrName.charAt(effet.length) == '(') {
      var p = attrName.indexOf(')', effet.length);
      if (p > 0) return attrName.substring(0, p + 1);
    }
    return effet;
  }

  function finDEffet(attr, effet, attrName, charId, evt, options) { //L'effet arrive en fin de vie, doit être supprimé
    options = options || {};
    evt.deletedAttributes = evt.deletedAttributes || [];
    var res;
    var newInit = [];
    var efComplet = effetComplet(effet, attrName);
    //Si on a un attrSave, alors on a déjà imprimé le message de fin d'effet
    if (options.attrSave) { //on a un attribut associé à supprimer)
      evt.deletedAttributes.push(options.attrSave);
      options.attrSave.remove();
    } else if (options.gardeAutresAttributs === undefined) { //On cherche si il y en a un
      enleverEffetAttribut(charId, efComplet, attrName, 'SaveParTour', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'SaveParTourType', evt);
    }
    var mEffet = messageEffetTemp[effet];
    if (mEffet && mEffet.statusMarker) {
      iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
        affectToken(token, 'statusmarkers', token.get('statusmarkers'), evt);
        token.set('status_' + mEffet.statusMarker, false);
      }, {
        tousLesTokens: true
      });
    }
    switch (effet) {
      case 'agrandissement': //redonner sa taille normale
        var character = getObj('character', charId);
        if (character === undefined) {
          error("Personnage introuvable");
          return;
        }
        character.get('defaulttoken', function(normalToken) {
          if (normalToken === '') return;
          normalToken = JSON.parse(normalToken);
          var largeWidth = normalToken.width + normalToken.width / 2;
          var largeHeight = normalToken.height + normalToken.height / 2;
          iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
            var width = token.get('width');
            var height = token.get('height');
            affectToken(token, 'width', width, evt);
            token.set('width', normalToken.width);
            affectToken(token, 'height', height, evt);
            token.set('height', normalToken.height);
          }, {
            filterAffected: function(token) {
              if (token.get('width') == largeWidth) return true;
              if (token.get('height') == largeHeight) return true;
              return false;
            }
          });
        });
        break;
      case 'aveugleTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'aveugle', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'ralentiTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'ralenti', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'paralyseTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'paralyse', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'immobiliseTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'immobilise', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'etourdiTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'etourdi', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'affaibliTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'affaibli', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'assomeTemp':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'assome', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'apeureTemp':
      case 'peurEtourdi':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            setState({
              token: token,
              charId: charId
            }, 'apeure', false, evt, {
              fromTemp: true
            });
          }, {
            tousLesTokens: true
          });
        break;
      case 'ombreMortelle':
      case 'dedoublement':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
          token.remove();
        });
        break;
      case 'murDeForce':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
          var attrM = tokenAttribute({
            charId: charId,
            token: token
          }, 'murDeForceId');
          if (attrM.length === 0) return;
          var imageMur = getObj('graphic', attrM[0].get('current'));
          if (imageMur) {
            imageMur.remove();
          }
          attrM[0].remove();
        });
        break;
      case 'regeneration': //faire les soins restants
        var toursRestant = attr.get('current');
        if (toursRestant == 'tourFinal' || isNaN(toursRestant)) break;
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            var perso = {
              token: token,
              charId: charId
            };
            var regen = getValeurOfEffet(perso, 'regeneration', 3);
            var soins = regen * (toursRestant + attributeAsInt(perso, 'regenerationTempeteDeManaIntense', 0));
            soigneToken(perso, soins, evt,
              function(s) {
                options.print = function(m) {}; //Pour ne pas afficher le message final.
                var tempsEffectif = Math.ceil(s / regen);
                sendChar(charId, "récupère encore " + s + " PV en " + tempsEffectif + " tours.");
              });
          });
        break;
      case 'demonInvoque':
      case 'predateurConjure':
      case 'arbreAnime': //effacer le personnage
        //On efface d'abord les attributs et les abilities
        var charAttributes = findObjs({
          _type: 'attribute',
          _characterid: charId
        });
        charAttributes.forEach(
          function(otherAttr) {
            if (otherAttr.id != attr.id) otherAttr.remove();
          }
        );
        var charAbilities = findObjs({
          _type: 'ability',
          _characterid: charId
        });
        charAbilities.forEach(
          function(ab) {
            ab.remove();
          }
        );
        if (effet == 'arbreAnime') {
          iterTokensOfAttribute(charId, options.pageId, effet, attrName,
            function(token) {
              var perso = {
                token: token,
                charId: charId
              };
              var nA = removeFromTurnTracker(perso, evt);
              if (nA) {
                res = res || {};
                res.oldTokenId = token.id;
                res.newTokenId = nA.nextId;
              }
              setToken(token, 'bar1_link', '', evt);
              setToken(token, 'bar1_value', '', evt);
              setToken(token, 'bar1_max', '', evt);
              setToken(token, 'showplayers_bar1', false, evt);
              setToken(token, 'represents', '', evt);
              setToken(token, 'showname', false, evt);
              setToken(token, 'showplayers_name', false, evt);
              setToken(token, 'name', '', evt);
            });
        } else {
          iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
            var perso = {
              token: token,
              charId: charId
            };
            var nP = removeFromTurnTracker(perso, evt);
            if (nP) {
              res = res || {};
              res.oldTokenId = token.id;
              res.newTokenId = nP.nextId;
            }
            token.remove();
          });
        }
        attr.remove();
        if (options.print && mEffet) options.print(mEffet.fin);
        else {
          sendChar(charId, 'disparaît');
          options.print = function(m) {};
        }
        var arbreChar = getObj('character', charId);
        if (arbreChar) {
          evt.deletedCharacters = evt.deletedCharacters || [];
          evt.deletedCharacters.push({
            id: charId,
            name: arbreChar.get('name'),
            avatar: arbreChar.get('avatar'),
            attributes: charAttributes,
            abilities: charAbilities
          });
          arbreChar.remove();
        }
        return res; //Pas besoin de faire le reste, car plus de perso
      case 'formeDArbre':
        var iterTokOptions = {
          filterAffected: function(token) {
            return token.get('layer') == 'objects';
          }
        };
        iterTokensOfAttribute(charId, options.pageId, effet, attrName,
          function(token) {
            var perso = {
              token: token,
              charId: charId
            };
            var tokenChange = attributeAsBool(perso, 'changementDeToken');
            if (tokenChange) {
              var tokenMJ =
                findObjs({
                  _type: 'graphic',
                  _subtype: 'token',
                  _pageid: token.get('pageid'),
                  layer: 'gmlayer',
                  represents: charId,
                  name: token.get('name')
                });
              if (tokenMJ.length === 0) return;
              removeTokenAttr(perso, 'changementDeToken', evt);
              var nouveauToken = tokenMJ[0];
              setToken(nouveauToken, 'layer', 'objects', evt);
              setToken(nouveauToken, 'left', token.get('left'), evt);
              setToken(nouveauToken, 'top', token.get('top'), evt);
              setToken(nouveauToken, 'width', token.get('width'), evt);
              setToken(nouveauToken, 'height', token.get('height'), evt);
              setToken(nouveauToken, 'rotation', token.get('rotation'), evt);
              setToken(nouveauToken, 'bar2_value', token.get('bar2_value'), evt);
              setToken(nouveauToken, 'aura1_radius', token.get('aura1_radius'), evt);
              setToken(nouveauToken, 'aura1_color', token.get('aura1_color'), evt);
              setToken(nouveauToken, 'aura1_square', token.get('aura1_square'), evt);
              setToken(nouveauToken, 'showplayers_aura1', token.get('showplayers_aura1'), evt);
              setToken(nouveauToken, 'aura2_radius', token.get('aura2_radius'), evt);
              setToken(nouveauToken, 'aura2_color', token.get('aura2_color'), evt);
              setToken(nouveauToken, 'aura2_square', token.get('aura2_square'), evt);
              setToken(nouveauToken, 'showplayers_aura2', token.get('showplayers_aura2'), evt);
              setToken(nouveauToken, 'statusmarkers', token.get('statusmarkers'), evt);
              setToken(nouveauToken, 'light_angle', token.get('light_angle'), evt);
              setToken(nouveauToken, 'has_limit_field_of_vision', token.get('has_limit_field_of_vision'), evt);
              setToken(nouveauToken, 'has_limit_field_of_night_vision', token.get('has_limit_field_of_night_vision'), evt);
              if (stateCOF.combat) {
                replaceInTurnTracker(token.id, nouveauToken.id, evt);
              }
              res = res || {};
              res.oldTokenId = token.id;
              res.newTokenId = nouveauToken.id;
              res.newToken = nouveauToken;
              token.remove();
              token = nouveauToken;
              perso.token = nouveauToken;
            }
            var apv = tokenAttribute(perso, 'anciensPV');
            if (apv.length > 0) {
              updateCurrentBar(perso, 1, apv[0].get('current'), evt, apv[0].get('max'));
              removeTokenAttr(perso, 'anciensPV', evt);
              if (stateCOF.combat) {
                newInit.push({
                  _id: token.id
                });
              }
            }
          },
          iterTokOptions);
        break;
      case 'agitAZeroPV':
        iterTokensOfAttribute(charId, options.pageId, effet, attrName, function(token) {
          var perso = {
            charId: charId,
            token: token
          };
          var pv = token.get('bar1_value');
          if (pv == 0) { //jshint ignore:line
            mort(perso, undefined, evt);
          } else {
            //On note qu'il l'a déjà fait pour qu'il ne puisse le refaire dans le combat
            setTokenAttr(perso, 'aAgiAZeroPV', true, evt);
          }
        });
        break;
      case 'forgeron':
      case 'armeEnflammee':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          var perso = {
            token: token,
            charId: charId
          };
          eteindreUneLumiere(perso, options.pageId, undefined, efComplet, evt);
        });
        break;
      case 'effetRetarde':
        if (efComplet.length > 14) {
          var effetRetarde = efComplet.substring(13, efComplet.length - 1);
          if (_.has(cof_states, effetRetarde)) {
            iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
              var perso = {
                token: token,
                charId: charId
              };
              if (getState(perso, 'mort')) return;
              setState(perso, effetRetarde, true, evt);
            });
          } else if (estEffetTemp(effetRetarde)) {
            options.print = function(m) {}; //Pour ne pas afficher le message final.
            var pp = effetRetarde.indexOf('(');
            var mEffetRetarde = (pp > 0) ? messageEffetTemp[effetRetarde.substring(effetRetarde, pp)] : messageEffetTemp[effetRetarde];
            var ef = {
              effet: effetRetarde,
              duree: 1,
              message: mEffetRetarde,
              whisper: true,
            };
            iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
              var perso = {
                token: token,
                charId: charId
              };
              if (getState(perso, 'mort')) return;
              if (!stateCOF.combat) {
                sendChat('', "Il restait un effet retardé " + effetRetarde + " qui devait se déclencher pour " + token.get('name'));
                return;
              }
              var duree = getValeurOfEffet(perso, efComplet, 1);
              ef.duree = duree;
              setEffetTemporaire(perso, ef, duree, undefined, options.pageId, evt, {});
            });
          } else {
            options.print = function(m) {}; //Pour ne pas afficher le message final.
            iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
              var perso = {
                token: token,
                charId: charId
              };
              if (getState(perso, 'mort')) return;
              var val = true;
              var valAttr = tokenAttribute(perso, efComplet + 'Valeur');
              if (valAttr.length > 0) val = valAttr[0].get('current');
              whisperChar(charId, effetRetarde + ' ' + val);
              setTokenAttr(perso, effetRetarde, val, evt, {});
            });
          }
        }
        break;
      case 'messageRetarde':
        if (efComplet.length > 16) {
          var messageRetarde = efComplet.substring(15, efComplet.length - 1);
          iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
            whisperChar(charId, messageRetarde);
            //Puis on regarde si il y a une valeur à afficher
            var perso = {
              token: token,
              charId: charId
            };
            var valAttr = tokenAttribute(perso, efComplet + 'Valeur');
            if (valAttr.length > 0)
              whisperChar(charId, valAttr[0].get('current'));
          });
        }
        break;
      case 'tenebres':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          //Puis on regarde si il y a une valeur à afficher
          var perso = {
            token: token,
            charId: charId
          };
          var valAttr = tokenAttribute(perso, efComplet + 'Valeur');
          var tokenTenebres = getObj('graphic', valAttr[0].get('current'));
          if (tokenTenebres) tokenTenebres.remove();
        });
        break;
      case 'armeeDesMorts':
        iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
          token.set("aura2_radius", 0);
          if (stateCOF.armeesDesMorts) {
            var index = stateCOF.armeesDesMorts.indexOf(token.id);
            if (index > -1) stateCOF.armeesDesMorts.splice(index, 1);
          }
        });
        break;
      default:
    }
    if (options.attrSave === undefined && charId) {
      var estMort = true;
      iterTokensOfAttribute(charId, options.pageId, efComplet, attrName, function(token) {
        estMort = estMort && getState({
          charId: charId,
          token: token
        }, 'mort');
      });
      if (!estMort && mEffet) {
        if (options.print) options.print(mEffet.fin);
        else {
          if (attrName == efComplet)
            sendChar(charId, mEffet.fin);
          else {
            var tokenName = attrName.substring(attrName.indexOf('_') + 1);
            sendChat('', tokenName + ' ' + mEffet.fin);
          }
        }
      }
    }
    if (options.gardeAutresAttributs === undefined && charId) {
      enleverEffetAttribut(charId, efComplet, attrName, 'Puissant', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'Valeur', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'TempeteDeManaIntense', evt);
      enleverEffetAttribut(charId, efComplet, attrName, 'DureeAccumulee', evt);
    }
    evt.deletedAttributes.push(attr);
    attr.remove();
    if (newInit.length > 0) initiative(newInit, evt, true);
    return res;
  }

  //asynchrone
  // effet est le nom complet de l'effet
  function degatsParTour(charId, pageId, effet, attrName, dmg, type, msg, evt, options, callback) {
    options = options || {};
    var count = -1;
    iterTokensOfAttribute(charId, pageId, effet, attrName,
      function(token, total) {
        if (count < 0) count = total;
        var perso = {
          token: token,
          charId: charId
        };
        var dmgExpr = dmg;
        var tdmi = attributeAsInt(perso, effet + "TempeteDeManaIntense", 0);
        if (dmg.de) {
          if (tdmi) {
            dmgExpr = (tdmi + dmg.nbDe) + 'd' + dmg.de;
            removeTokenAttr(perso, effet + "TempeteDeManaIntense", evt);
          } else dmgExpr = dmg.nbDe + 'd' + dmg.de;
        } else if (dmg.cst) {
          if (tdmi) {
            dmgExpr = dmg.cst * (1 + tdmi);
            removeTokenAttr(perso, effet + "TempeteDeManaIntense", evt);
          } else dmgExpr = dmg.cst;
        } else if (options.dotGen) {
          //alors dmg = '' et type = ''
          var valAttr = tokenAttribute(perso, effet + 'Valeur');
          if (valAttr.length === 0) {
            //Par défaut, 1d6 DM normaux
            dmgExpr = "1d6";
            type = 'normal';
          } else {
            dmgExpr = valAttr[0].get('current');
            type = valAttr[0].get('max');
            if (type === '') type = 'normal';
          }
        }
        sendChat('', "[[" + dmgExpr + "]]", function(res) {
          var rolls = res[0];
          var dmgRoll = rolls.inlinerolls[0];
          var r = {
            total: dmgRoll.results.total,
            type: type,
            display: buildinline(dmgRoll, type)
          };
          dealDamage(perso, r, [], evt, false, options, undefined,
            function(dmgDisplay, dmg) {
              if (dmg > 0) {
                var msgDm;
                if (msg) msgDm = msg + '. ' + onGenre(perso, 'Il', 'Elle');
                else msgDm = '';
                if (effet == attrName) {
                  sendChar(charId, msgDm + " subit " + dmgDisplay + " DM");
                } else {
                  var tokenName = attrName.substring(attrName.indexOf('_') + 1);
                  sendChat('', tokenName + ' ' + msgDm + " subit " + dmgDisplay + " DM");
                }
              }
              count--;
              if (count === 0) callback();
            });
        }); //fin sendChat du jet de dé
      }); //fin iterTokensOfAttribute
  }

  //asynchrone
  function soigneParTour(charId, pageId, effet, attrName, soinsExpr, msg, evt, options, callback) {
    options = options || {};
    msg = msg || '';
    var count = -1;
    iterTokensOfAttribute(charId, pageId, effet, attrName,
      function(token, total) {
        if (count < 0) count = total;
        var perso = {
          token: token,
          charId: charId
        };
        var tdmi = attributeAsInt(perso, effet + "TempeteDeManaIntense", 0);
        if (tdmi) {
          soinsExpr = "(" + soinsExpr + ")*" + (1 + tdmi);
          removeTokenAttr(perso, effet + "TempeteDeManaIntense", evt);
        }
        var localSoinsExpr = soinsExpr;
        if (options.valeur) {
          var attrsVal = tokenAttribute(perso, options.valeur);
          if (attrsVal.length > 0) localSoinsExpr = attrsVal[0].get('current');
        }
        sendChat('', "[[" + localSoinsExpr + "]]", function(res) {
          var rolls = res[0];
          var soinRoll = rolls.inlinerolls[0];
          var soins = soinRoll.results.total;
          var displaySoins = buildinline(soinRoll, 'normal', true);
          soigneToken(perso, soins, evt,
            function(s) {
              if (s < soins) sendChar(charId, "récupère tous ses PV.");
              else sendChar(charId, "récupère " + displaySoins + " PV.");
              count--;
              if (count === 0) callback();
            },
            function() {
              count--;
              if (count === 0) callback();
            });
        }); //fin sendChat du jet de dé
      }); //fin iterTokensOfAttribute
  }

  // gestion des effets qui se déclenchent à la fin de chaque tour
  // N'ajoute pas evt à l'historique
  // Asynchrone (à cause des saves par tour)
  function changementDeTour(tour, attrs, evt, pageId, options) {
    // Enlever les bonus d'un tour
    attrs = removeAllAttributes('actionConcertee', evt, attrs);
    attrs = removeAllAttributes('intercepter', evt, attrs);
    attrs = removeAllAttributes('interposer', evt, attrs);
    attrs = removeAllAttributes('exemplaire', evt, attrs);
    attrs = removeAllAttributes('peutEtreDeplace', evt, attrs);
    attrs = removeAllAttributes('attaqueMalgreMenace', evt, attrs);
    resetAttr(attrs, 'attaqueEnTraitre', evt);
    resetAttr(attrs, 'esquiveAcrobatique', evt);
    resetAttr(attrs, 'paradeDeProjectiles', evt);
    resetAttr(attrs, 'resistanceALaMagieBarbare', evt);
    resetAttr(attrs, 'paradeMagistrale', evt);
    resetAttr(attrs, 'chairACanon', evt);
    resetAttr(attrs, 'riposteGuerrier', evt);
    resetAttr(attrs, 'prouesse', evt);
    resetAttr(attrs, 'cercleDeProtectionActif', evt);
    // Pour défaut dans la cuirasse, on diminue si la valeur est 2, et on supprime si c'est 1
    var defautsDansLaCuirasse = allAttributesNamed(attrs, 'defautDansLaCuirasse');
    defautsDansLaCuirasse.forEach(function(attr) {
      if (attr.get('current') < 2) {
        if (evt.deletedAttributes) evt.deletedAttributes.push(attr);
        else evt.deletedAttributes = [attr];
        attr.remove();
      } else {
        var prevAttr = {
          attribute: attr,
          current: 2
        };
        evt.attributes.push(prevAttr);
        attr.set('current', 1);
      }
    });
    // Pour la feinte, on augmente la valeur, et on supprime si la valeur est 2
    var feinte = allAttributesNamed(attrs, 'feinte');
    feinte.forEach(function(attr) {
      var valFeinte = parseInt(attr.get('current'));
      if (isNaN(valFeinte) || valFeinte > 0) {
        evt.deletedAttributes.push(attr);
        attr.remove();
      } else {
        var prevAttr = {
          attribute: attr,
          current: 0
        };
        evt.attributes.push(prevAttr);
        attr.set('current', 1);
      }
    });
    //Les tests ratés
    var trTour = allAttributesNamed(attrs, 'testsRatesDuTour');
    trTour.forEach(function(tr) {
      var curTr = tr.get('current');
      if (curTr === '') {
        evt.deletedAttributes.push(tr);
        tr.remove();
      } else {
        var maxTr = tr.get('max');
        evt.attributes.push({
          attribute: tr,
          current: curTr,
          max: maxTr
        });
        tr.set('max', curTr);
        tr.set('current', '');
      }
    });
    var vapeth = allAttributesNamed(attrs, 'vapeursEthyliques');
    vapeth.forEach(function(attr) {
      var ve = parseInt(attr.get('current'));
      if (isNaN(ve)) ve = 0;
      evt.attributes.push({
        attribute: attr,
        current: 0
      });
      attr.set('current', ve + 1);
      var veCharId = attr.get('characterid');
      if (veCharId === undefined || veCharId === '') {
        error("Attribut sans personnage associé", attr);
        return;
      }
      var veSeuil = parseInt(attr.get('max'));
      if (isNaN(veSeuil)) veSeuil = 0;
      veSeuil -= Math.floor(ve / 2);
      iterTokensOfAttribute(veCharId, stateCOF.combat_pageid,
        'vapeursEthyliques', attr.get('name'),
        function(tok) {
          var perso = {
            charId: veCharId,
            token: tok
          };
          var testId = 'vapeursEthyliques_' + perso.token.id;
          testCaracteristique(perso, 'CON', veSeuil, testId, options, evt, function(testRes) {
            var res = "tente un jet de CON " + veSeuil + " pour combattre les vapeurs éthyliques " + testRes.texte;
            if (testRes.reussite) {
              res += " => réussi." + testRes.modifiers;
              var expliquer;
              if (attr.get('name') == 'vapeursEthyliques') {
                expliquer = function(s) {
                  sendChar(veCharId, s);
                };
              } else {
                perso.tokName = tok.get('name');
                expliquer = function(s) {
                  sendChat('', perso.tokName + ' ' + s);
                };
              }
              expliquer(res);
              diminueEbriete(perso, evt, expliquer);
            } else {
              res += " => raté" + testRes.rerolls + testRes.modifiers;
              sendChar(veCharId, res);
            }
          });
        });
    });
    // nouveau tour : enlever le statut surpris
    // et faire les actions de début de tour
    var selected = [];
    updateNextInitSet.forEach(function(id) {
      selected.push({
        _id: id
      });
    });
    findObjs({
      _type: 'graphic',
      _subtype: 'token',
      _pageid: pageId
    }).forEach(function(tok) {
      var charId = tok.get('represents');
      if (charId === '') return;
      var perso = {
        token: tok,
        charId: charId
      };
      if (getState(perso, 'surpris')) { //surprise
        setState(perso, 'surpris', false, {});
        selected.push({
          _id: tok.id
        });
      }
      if (getState(perso, 'enseveli')) {
        var degats = randomInteger(6) + randomInteger(6);
        var dmg = {
          type: 'magique',
          total: degats,
          display: degats
        };
        degats = dealDamage(perso, dmg, [], evt);
        sendChar(charId, " est écrasé ! " +
          onGenre(perso, 'Il', 'Elle') + " subit " + degats + " DM");
      }
      var enflammeAttr = tokenAttribute(perso, 'enflamme');
      if (enflammeAttr.length > 0) {
        var enflamme = parseInt(enflammeAttr[0].get('current'));
        // Pour ne pas faire les dégâts plusieurs fois (plusieurs tokens pour un même personnage), on utilise la valeur max de l'attribut
        var dernierTourEnflamme = parseInt(enflammeAttr[0].get('max'));
        if ((isNaN(dernierTourEnflamme) || dernierTourEnflamme < tour) &&
          !isNaN(enflamme) && enflamme > 0) {
          var d6Enflamme = randomInteger(6);
          var feu = d6Enflamme + enflamme - 1;
          var dmgEnflamme = {
            type: 'feu',
            total: feu,
            display: feu
          };
          if (getState(perso, 'mort')) {
            sendChat('', "Le cadavre de " + perso.token.get('name') + " continue de brûler");
          } else {
            feu = dealDamage(perso, dmgEnflamme, [], evt);
            sendChar(charId, " est en flamme ! " +
              onGenre(perso, 'Il', 'Elle') + " subit " + feu + " DM");
          }
          if (d6Enflamme < 3) {
            sendChar(charId, " les flammes s'éteignent");
            removeTokenAttr(perso, 'enflamme', evt);
          } else {
            enflammeAttr[0].set('max', tour);
          }
        }
      }
      var vitaliteSurnatAttr = charAttribute(perso.charId, 'vitaliteSurnaturelle');
      if (vitaliteSurnatAttr.length > 0) {
        var vitaliteSurnat = vitaliteSurnatAttr[0].get('current');
        var regenereMemeMort;
        if ((vitaliteSurnat + '').trim().endsWith('+')) {
          vitaliteSurnat = vitaliteSurnat.substr(0, vitaliteSurnat.length - 1);
          regenereMemeMort = true;
        }
        if (regenereMemeMort || !getState(perso, 'mort')) {
          vitaliteSurnat = parseInt(vitaliteSurnat);
          if (vitaliteSurnat > 0) {
            soigneToken(perso, vitaliteSurnat, evt,
              function(s) {
                sendChar(charId, 'récupère ' + s + ' PVs.');
              },
              function() {}, {
                saufDMType: vitaliteSurnatAttr[0].get('max').split(',')
              }
            );
          }
        }
      }
      var increvableActif = tokenAttribute(perso, 'increvableActif');
      if (increvableActif.length > 0) {
        increvableActif[0].remove();
        var soins = randomInteger(6) + randomInteger(6) + randomInteger(6) + modCarac(perso, 'constitution');
        soigneToken(perso, soins, evt, function(soinsEffectifs) {
          var msgSoins = "est increvable et récupère ";
          if (soinsEffectifs == soins) msgSoins += soins + " points de vie";
          else msgSoins += soinsEffectifs + " PV (le jet était " + soins + ")";
          sendChar(perso.charId, msgSoins);
        });
      }
    });
    setActiveToken(undefined, evt);
    initiative(selected, evt, true); // met Tour à la fin et retrie
    updateNextInitSet = new Set();
    // Saves à faire à la fin de chaque tour
    var attrsSave = attrs.filter(function(attr) {
      var attrName = attr.get('name');
      var indexSave = attrName.indexOf('SaveParTour');
      if (indexSave < 0) return false;
      var indexSaveType = attrName.indexOf('SaveParTourType');
      if (indexSaveType > 0) return false;
      return estEffetTemp(attrName.substring(0, indexSave));
    });
    //Les saves sont asynchrones
    attrsSave.forEach(function(attr) {
      var attrName = attr.get('name');
      var carac = attr.get('current');
      if (!isCarac(carac)) {
        error("Save par tour " + attrName + " mal formé", carac);
        return;
      }
      var seuil = parseInt(attr.get('max'));
      if (isNaN(seuil)) {
        error("Save par tour " + attrName + " mal formé", seuil);
        return;
      }
      var charId = attr.get('characterid');
      var indexSave = attrName.indexOf('SaveParTour');
      var effetC = attrName.substring(0, indexSave);
      attrName = effetC + attrName.substr(indexSave + 11);
      var token;
      iterTokensOfAttribute(charId, pageId, effetC, attrName, function(tok) {
        if (token === undefined) token = tok;
      });
      if (token === undefined) {
        log("Pas de token pour le save " + attrName);
        return;
      }
      var perso = {
        token: token,
        charId: charId
      };
      if (getState(perso, 'mort')) {
        return;
      }
      var attrEffet = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attrName
      });
      if (attrEffet === undefined || attrEffet.length === 0) {
        error("Save sans effet temporaire " + attrName, attr);
        findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: attr.get('name').replace('SaveParTour', 'SaveParTourType')
        }).forEach(function(a) {
          a.remove();
        });
        attr.remove();
        return;
      }
      attrEffet = attrEffet[0];
      var expliquer = function(msg) {
        sendChar(charId, msg);
      };
      var msgPour = " pour ne plus être sous l'effet de ";
      if (effetC.startsWith('dotGen('))
        msgPour += effetC.substring(7, effetC.indexOf(')'));
      else msgPour += effetC;
      var sujet = onGenre(perso, 'il', 'elle');
      var met = messageOfEffetTemp(effetC);
      var msgReussite = ", " + sujet + " " + met.fin;
      var msgRate = ", " + sujet + " " + met.actif;
      var saveOpts = {
        msgPour: msgPour,
        msgReussite: msgReussite,
        msgRate: msgRate,
        rolls: options.rolls,
        chanceRollId: options.chanceRollId
      };
      var attrType = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: attr.get('name').replace('SaveParTour', 'SaveParTourType')
      });
      if (attrType.length > 0) {
        saveOpts.type = attrType[0].get('current');
      }
      var saveId = 'saveParTour_' + attrEffet.id + '_' + perso.token.id;
      save({
          carac: carac,
          seuil: seuil
        }, perso, saveId, expliquer, saveOpts, evt,
        function(reussite, texte) { //asynchrone
          if (reussite) {
            finDEffet(attrEffet, effetTempOfAttribute(attrEffet), attrName, charId, evt, {
              attrSave: attr,
              pageId: pageId
            });
          }
        });
    }); //fin boucle attrSave
    //les effets d'aura possiblement aussi -> aucun ordre garanti
    var auras = attrs.filter(function(a) {
      return a.get('name').trim() == 'aura';
    });
    var allTokens;
    var gmId;
    auras.forEach(function(aura) {
      var portee = parseInt(aura.get('current'));
      if (isNaN(portee) || portee < 0) return;
      var charId = aura.get('characterid');
      if (!allTokens) {
        allTokens = findObjs({
          _type: "graphic",
          _pageid: pageId,
          _subtype: "token",
          layer: "objects"
        });
        allTokens = allTokens.filter(function(t) {
          var cid = t.get('represents');
          if (cid === '') return false;
          var c = getObj('character', cid);
          if (c === undefined) {
            t.remove();
            return false;
          }
          return true;
        });
      }
      var targets = {};
      //For each token representing that character
      allTokens.forEach(function(auraToken) {
        if (auraToken.get('represents') != charId) return;
        var tokName;
        //On cherche ensuite les tokens à portee
        allTokens.forEach(function(tok) {
          if (tok.id == auraToken.id) return;
          if (tok.get('represents') == charId) return;
          if (distanceCombat(auraToken, tok, pageId) > portee) return;
          tokName = tokName || auraToken.get('name');
          targets[tok.id] = tokName;
        });
      });
      if (_.isEmpty(targets)) return;
      if (!gmId) {
        var gm = findObjs({
          _type: "player"
        }).find(function(p) {
          return playerIsGM(p.id);
        });
        if (gm) gmId = gm.id;
        else {
          error("Impossible de trouver un MJ");
          return;
        }
      }
      var effet = aura.get('max');
      if (effet.includes('$TOKEN')) {
        //On groupe les cibles par token qui génère l'aura
        var targetsPerSource = {};
        _.forEach(targets, function(auraTokName, tid) {
          targetsPerSource[auraTokName] = targetsPerSource[auraTokName] || new Set();
          targetsPerSource[auraTokName].add(tid);
        });
        _.forEach(targetsPerSource, function(tset, auraTokenName) {
          var effetFinal = effet.replace(/\$TOKEN/g, auraTokenName);
          tset.forEach(function(tid) {
            effetFinal += " --target " + tid;
          });
          sendChat('player|' + gmId, effetFinal);
        });
      } else {
        //Toutes les cibles ensemble
        _.forEach(targets, function(auraTokenName, tid) {
          effet += " --target " + tid;
        });
        sendChat('player|' + gmId, effet);
      }
    });
    var armeesDesMorts = allAttributesNamed(attrs, 'armeeDesMorts');
    var degatsArmeeFull = {};
    var degatsArmeeDefense = {};
    armeesDesMorts.forEach(function(armee) {
      var charId = armee.get('characterid');
      var allies = alliesParPerso[charId] || new Set();
      if (!allTokens) {
        allTokens = findObjs({
          _type: "graphic",
          _pageid: pageId,
          _subtype: "token",
          layer: "objects"
        });
        allTokens = allTokens.filter(function(t) {
          var cid = t.get('represents');
          if (cid === '') return false;
          var c = getObj('character', cid);
          if (c === undefined) {
            t.remove();
            return false;
          }
          return true;
        });
      }
      //For each token representing that character
      allTokens.forEach(function(auraToken) {
        if (auraToken.get('represents') != charId) return;
        //On cherche ensuite les tokens à portee
        allTokens.forEach(function(tok) {
          if (tok.id == auraToken.id) return;
          var tokRepresents = tok.get('represents');
          if (tokRepresents == charId) return;
          if (allies.has(tokRepresents)) return;
          if (degatsArmeeDefense[tok.id] != undefined || degatsArmeeFull[tok.id] != undefined) return;
          if (distanceCombat(auraToken, tok, pageId) > 20) return;
          var perso = persoOfToken(tok);
          if (attributeAsBool(perso, "defenseArmeeDesMorts")) {
            degatsArmeeDefense[tok.id] = perso;
          } else {
            degatsArmeeFull[tok.id] = perso;
          }
        });
      });
      if (!gmId) {
        var gm = findObjs({
          _type: "player"
        }).find(function(p) {
          return playerIsGM(p.id);
        });
        if (gm) gmId = gm.id;
        else {
          error("Impossible de trouver un MJ");
          return;
        }
      }
    });
    var targetLine = "";
    Object.keys(degatsArmeeFull).forEach(function(tokId) {
      targetLine += " --target " + tokId;
    });
    if (targetLine != "")
      sendChat('player|' + gmId, "!cof-dmg 3d6" + targetLine + " --titre Dégâts des morts-vivants animés");
    targetLine = "";
    Object.keys(degatsArmeeDefense).forEach(function(tokId) {
      targetLine += " --target " + tokId;
    });
    if (targetLine != "")
      sendChat('player|' + gmId, "!cof-dmg 1d6" + targetLine + " --titre Dégâts des morts-vivants animés sur les cibles qui les combattent");
    removeAllAttributes("defenseArmeeDesMorts", evt, attrs);
  }

  //evt a un champ attributes et un champ deletedAttributes
  //evt est ajouté à l'historique à la fin de cette fonction
  function nextTurnOfActive(active, attrs, evt, pageId, options) {
    if (active === undefined) return;
    if (active.id == "-1" && active.custom == "Tour") { //Nouveau tour
      var tour = parseInt(active.pr);
      if (isNaN(tour)) {
        error("Tour invalide", active);
        return;
      }
      evt.tour = tour - 1;
      evt.updateNextInitSet = updateNextInitSet;
      active.pr = tour - 1; // préparation au calcul de l'undo
      sendChat("GM", "Début du tour " + tour);
      stateCOF.tour = tour;
      stateCOF.init = 1000;
      addEvent(evt);
      changementDeTour(tour, attrs, evt, pageId, options);
    } else { // change the active token
      addEvent(evt);
      setActiveToken(active.id, evt);
    }
  }

  function nextTurn(cmp, options) {
    if (!cmp.get('initiativepage')) return;
    var turnOrder = cmp.get('turnorder');
    var pageId = stateCOF.combat_pageid;
    if (pageId === undefined) {
      pageId = cmp.get('playerpageid');
      stateCOF.combat_pageid = pageId;
    }
    if (turnOrder === '') return; // nothing in the turn order
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length < 1) return; // Juste le compteur de tour
    var evt = {
      type: 'nextTurn',
      attributes: [],
      deletedAttributes: []
    };
    var active = turnOrder[0];
    var lastHead = turnOrder.pop();
    turnOrder.unshift(lastHead);
    evt.turnorder = JSON.stringify(turnOrder);
    if (stateCOF.chargeFantastique) {
      //cmp.set('turnorder', evt.turnorder);
      if (stateCOF.chargeFantastique.attaques) {
        nextTurnChargeFantastique(undefined, evt.turnorder);
        return;
      }
      stateCOF.chargeFantastique = undefined;
    }
    var attrs = findObjs({
      _type: 'attribute'
    });
    // Si on a changé d'initiative, alors diminue les effets temporaires
    var init = parseInt(active.pr);
    if (active.id == "-1" && active.custom == "Tour") init = 0;
    var count = 0; // pour l'aspect asynchrone des effets temporaires
    if (stateCOF.init > init) {
      var attrsTemp = attrs.filter(function(obj) {
        if (!estEffetTemp(obj.get('name'))) return false;
        var obji = obj.get('max');
        return (init < obji && obji <= stateCOF.init);
      });
      evt.init = stateCOF.init;
      stateCOF.init = init;
      // Boucle sur les effets temps peut être asynchrone à cause des DM
      count = attrsTemp.length;
      attrsTemp.forEach(function(attr) {
        var charId = attr.get('characterid');
        var effet = effetTempOfAttribute(attr);
        if (effet === undefined) {
          //erreur, on stoppe tout
          log(attr);
          count--;
          return;
        }
        var attrName = attr.get('name');
        var effetC = effetComplet(effet, attrName);
        var v = attr.get('current');
        var effetActif = true;
        if (v == 'tourFinal') { //L'effet arrive en fin de vie, doit être supprimé
          //Sauf si on a accumulé plusieurs fois l'effet
          var accumuleAttr = attributeExtending(charId, attrName, effetC, 'DureeAccumulee');
          if (accumuleAttr.length > 0) {
            accumuleAttr = accumuleAttr[0];
            var dureeAccumulee = accumuleAttr.get('current') + '';
            var listeDureeAccumulee = dureeAccumulee.split(',');
            evt.attributes.push({
              attribute: attr,
              current: 'tourFinal'
            });
            var nDuree = parseInt(listeDureeAccumulee.pop());
            if (isNaN(nDuree)) {
              v = 'tourFinal';
              count--;
              effetActif = false;
            } else v = nDuree;
            attr.set('current', nDuree);
            if (listeDureeAccumulee.length === 0) {
              evt.deletedAttributes.push(accumuleAttr);
              accumuleAttr.remove();
            } else {
              evt.attributes.push({
                attribute: accumuleAttr,
                current: dureeAccumulee
              });
              accumuleAttr.set('current', listeDureeAccumulee.join(','));
            }
          } else {
            var effetFinal = finDEffet(attr, effet, attrName, charId, evt, {
              pageId: pageId
            });
            if (effetFinal && effetFinal.oldTokenId == active.id) {
              active.id = effetFinal.newTokenId;
              if (active.id === undefined) {} else if (active.id == '-1') {
                active.custom = 'Tour';
              }
            }
            count--;
            effetActif = false;
          }
        }
        if (effetActif) { //Effet encore actif
          evt.attributes.push({
            attribute: attr,
            current: v
          });
          if (v > 1) attr.set('current', v - 1);
          else attr.set('current', 'tourFinal');
          switch (effet) { //rien après le switch, donc on sort par un return
            case 'putrefaction': //prend 1d6 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  nbDe: 1,
                  de: 6
                }, 'maladie',
                "pourrit", evt, {
                  magique: true
                },
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'asphyxie': //prend 1d6 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  nbDe: 1,
                  de: 6
                }, 'normal',
                "ne peut plus respirer", evt, {
                  asphyxie: true
                },
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'saignementsSang': //prend 1d6 DM
              if (charIdAttributeAsBool(charId, 'immuniteSaignement')) {
                count--;
                if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                return;
              }
              degatsParTour(charId, pageId, effet, attrName, {
                  nbDe: 1,
                  de: 6
                }, 'normal',
                "saigne par tous les orifices du visage", evt, {
                  magique: true
                },
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'armureBrulante': //prend 1d4 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  nbDe: 1,
                  de: 4
                }, 'feu',
                "brûle dans son armure", evt, {},
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'nueeDInsectes': //prend 1 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  cst: 1
                }, 'normal',
                "est piqué par les insectes", evt, {},
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'nueeDeCriquets': //prend 1 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  cst: 2
                }, 'normal',
                "est piqué par les criquets", evt, {},
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'armeBrulante': //prend 1 DM
              degatsParTour(charId, pageId, effet, attrName, {
                  cst: 1
                }, 'feu',
                "se brûle avec son arme", evt, {},
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            case 'regeneration': //soigne
              soigneParTour(charId, pageId, effet, attrName, 3, "régénère", evt, {
                  valeur: 'regenerationValeur'
                },
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });

              return;
            case 'strangulation':
              var nameDureeStrang = 'dureeStrangulation';
              if (effet != attrName) { //concerne un token non lié
                nameDureeStrang += attrName.substring(attrName.indexOf('_'));
              }
              var dureeStrang = findObjs({
                _type: 'attribute',
                _characterid: charId,
                name: nameDureeStrang
              });
              if (dureeStrang.length === 0) {
                var attrDuree = createObj('attribute', {
                  characterid: charId,
                  name: nameDureeStrang,
                  current: 0,
                  max: false
                });
                evt.attributes.push({
                  attribute: attrDuree,
                  current: null
                });
              } else {
                var strangUpdate = dureeStrang[0].get('max');
                if (strangUpdate) { //a été mis à jour il y a au plus 1 tour
                  evt.attributes.push({
                    attribute: dureeStrang[0],
                    current: dureeStrang[0].get('current'),
                    max: strangUpdate
                  });
                  dureeStrang[0].set('max', false);
                } else { //Ça fait trop longtemps, on arrête tout
                  sendChar(charId, messageEffetTemp[effet].fin);
                  attr.set('current', v);
                  evt.attributes.pop(); //On enlève des attributs modifiés pour mettre dans les attribute supprimés.
                  evt.deletedAttributes.push(attr);
                  attr.remove();
                  evt.deletedAttributes.push(dureeStrang[0]);
                  dureeStrang[0].remove();
                }
              }
              count--;
              return;
            case 'dotGen':
              degatsParTour(charId, pageId, effetC, attrName, {}, '', "", evt, {
                  dotGen: true
                },
                function() {
                  count--;
                  if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
                });
              return;
            default:
              count--;
              return;
          }
        }
      }); //fin de la boucle sur tous les attributs d'effets
    }
    if (count === 0) nextTurnOfActive(active, attrs, evt, pageId, options);
  }

  //Fonction appelée par !cof-tour-suivant
  function tourSuivant(msg) {
    if (!stateCOF.combat) {
      sendPlayer(msg, "Vous n'êtes pas en combat");
      return;
    }
    var cmp = Campaign();
    var turnOrder = cmp.get('turnorder');
    if (turnOrder === '') {
      error("Personne n'est en combat", turnOrder);
      return;
    }
    turnOrder = JSON.parse(turnOrder);
    if (turnOrder.length < 1) {
      error("Personne n'est en combat", turnOrder);
      return;
    }
    var active = turnOrder.shift();
    var persoActif = persoOfId(active.id);
    if (persoActif === undefined) {
      error("Impossible de trouver le personnage actif", active);
      return;
    }
    if (!peutController(msg, persoActif)) {
      sendPlayer(msg, "Ce n'est pas votre tour (personnage actif : " + persoActif.token.get('name') + ")");
      return;
    }
    turnOrder.push(active);
    if (turnOrder[0].id == "-1" && turnOrder[0].custom == "Tour") {
      //Il faut aussi augmenter la valeur du tour
      var tour = parseInt(turnOrder[0].pr);
      if (isNaN(tour)) {
        error("Tour invalide", turnOrder);
        return;
      }
      turnOrder[0].pr = tour + 1;
    }
    cmp.set('turnorder', JSON.stringify(turnOrder));
    nextTurn(cmp);
  }

  //when set is true, sets the version, when false, remove it
  function scriptVersionToCharacter(character, set) {
    var charId = character.id;
    var attrs = findObjs({
      _type: 'attribute',
      _characterid: charId,
      name: 'scriptVersion',
    }, {
      caseInsensitive: true
    });
    if (attrs.length === 0) {
      if (set) {
        createObj('attribute', {
          characterid: charId,
          name: 'scriptVersion',
          current: true,
          max: state.COFantasy.version
        });
      }
    } else {
      if (set) {
        attrs[0].setWithWorker({
          current: true,
          max: state.COFantasy.version
        });
      } else {
        attrs[0].setWithWorker({
          current: false
        });
      }
    }
  }

  function destroyToken(token) { //to remove unused local attributes
    var charId = token.get('represents');
    if (charId === "") return;
    var perso = {
      charId: charId,
      token: token
    };
    nePlusSuivre(perso, token.get('pageid'));
    if (token.get('bar1_link') !== "") return;
    var endName = "_" + token.get('name');
    var tokAttr = findObjs({
      _type: 'attribute',
      _characterid: charId
    });
    tokAttr = tokAttr.filter(function(obj) {
      return obj.get('name').endsWith(endName);
    });
    if (tokAttr.length > 0) {
      log("Removing token local attributes");
      log(tokAttr);
      tokAttr.forEach(function(attr) {
        attr.remove();
      });
    }
  }

  function nePeutPasBouger(perso) {
    if (attributeAsBool(perso, 'peutEtreDeplace')) return false;
    if (isActive(perso)) {
      if (getState(perso, 'immobilise')) return true;
      if (attributeAsBool(perso, 'bloqueManoeuvre')) return true;
      if (attributeAsBool(perso, 'enveloppePar')) return true;
      if (attributeAsBool(perso, 'prisonVegetale')) return true;
      if (attributeAsBool(perso, 'toiles')) return true;
      return false;
    }
    return true;
  }

  function permettreDeplacement(msg) {
    getSelected(msg, function(selected) {
      var evt = {
        type: 'Permettre le déplacement pour un tour'
      };
      iterSelected(selected, function(perso) {
        setTokenAttr(perso, 'peutEtreDeplace', true, evt);
      });
      addEvent(evt);
    });
  }

  function determinant(xa, ya, xb, yb) {
    return xa * yb - ya * xb;
  }

  //Calcule si le segment [a,b] intersecte le segment [c,d]
  function segmentIntersecte(a, b, c, d) {
    var d1 = determinant(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);
    var d2 = determinant(b.x - a.x, b.y - a.y, d.x - a.x, d.y - a.y);
    if (d1 > 0 && d2 > 0) return false;
    if (d1 < 0 && d2 < 0) return false;
    d1 = determinant(d.x - c.x, d.y - c.y, a.x - c.x, a.y - c.y);
    d2 = determinant(d.x - c.x, d.y - c.y, b.x - c.x, b.y - c.y);
    if (d1 > 0 && d2 > 0) return false;
    if (d1 < 0 && d2 < 0) return false;
    return true;
  }

  //traduction des coordonées de path en coordonées réelles sur la carte
  function translatePathCoordinates(x, y, p) {
    //D'abord on calcule les coordonnées relatives au centre
    x -= p.width / 2;
    y -= p.height / 2;
    //Puis on applique le scale
    x *= p.scaleX;
    y *= p.scaleY;
    //Puis on fait la rotation
    var c = Math.cos(p.angle);
    var s = Math.sin(p.angle);
    x = c * x + s * y;
    y = c * y - s * x;
    //Et finalement on ajoute les coordonnées du centre
    x += p.left;
    y += p.top;
    return {
      x: x,
      y: y
    };
  }

  //vérifie si de la nouvelle position on peut voir le suivi
  function obstaclePresent(nsx, nsy, pt, murs) {
    var ps = {
      x: nsx,
      y: nsy
    };
    var obstacle = murs && murs.find(function(path) {
      if (path.length === 0) return false;
      var pc = path[0];
      return path.find(function(v, i) {
        if (i === 0) return false;
        if (segmentIntersecte(ps, pt, pc, v)) return true;
        pc = v;
        return false;
      });
    });
    return obstacle;
  }

  //Réagit au déplacement manuel d'un token.
  function moveToken(token, prev) {
    var charId = token.get('represents');
    if (charId === '') return;
    var perso = {
      token: token,
      charId: charId
    };
    var pageId = token.get('pageid');
    var x = token.get('left');
    var y = token.get('top');
    var deplacement = prev && (prev.left != x || prev.top != y);
    if (!deplacement) return;
    if (nePeutPasBouger(perso)) {
      whisperChar(charId, "ne peut pas se déplacer.");
      sendChat('COF', "/w GM " +
        '<a href="!cof-deplacer-token ' + x + ' ' + y + ' --target ' + token.id + '">Déplacer </a>' +
        '<a href="!cof-permettre-deplacement --target ' + token.id + '">Décoincer</a>');
      token.set('left', prev.left);
      token.set('top', prev.top);
      return;
    } else {
      //On regarde d'abord si perso est sur une monture
      var attrMonteSur = tokenAttribute(perso, 'monteSur');
      if (attrMonteSur.length > 0) {
        var monture = persoOfId(attrMonteSur[0].get('current'), attrMonteSur[0].get('max'), pageId);
        attrMonteSur[0].remove();
        if (monture === undefined) {
          sendChar(charId, "descend de sa monture");
          return;
        } else {
          sendChar(charId, "descend de " + monture.token.get('name'));
          removeTokenAttr(monture, 'estMontePar');
          removeTokenAttr(monture, 'positionSurMonture');
        }
        if (stateCOF.combat) {
          var evt = {
            type: "initiative"
          };
          updateInit(monture.token, evt);
          // Réadapter l'init_dynamique au token du perso
          if (stateCOF.options.affichage.val.init_dynamique.val) {
            setTokenInitAura(perso);
          }
        }
      }
      //si non, perso est peut-être une monture
      var attrMontePar = tokenAttribute(perso, 'estMontePar');
      attrMontePar.forEach(function(a) {
        var cavalier = persoOfId(a.get('current'), a.get('max'), pageId);
        if (cavalier === undefined) {
          a.remove();
          return;
        }
        var position = tokenAttribute(perso, 'positionSurMonture');
        if (position.length > 0) {
          var dx = parseInt(position[0].get('current'));
          var dy = parseInt(position[0].get('max'));
          if (!(isNaN(dx) || isNaN(dy))) {
            x += dx;
            y += dy;
          }
        }
        cavalier.token.set('left', x);
        cavalier.token.set('top', y);
        cavalier.token.set('rotation', token.get('rotation') + attributeAsInt(perso, 'directionSurMonture', 0));
      });
      //Si le token suivait quelqu'un, ce n'est plus le cas
      if (prev.suit === undefined) nePlusSuivre(perso, pageId);
      //On bouge tous les tokens qui suivent le personnage
      var attrSuivi = tokenAttribute(perso, 'estSuiviPar');
      var page = getObj('page', pageId);
      if (page === undefined) {
        error("Impossible de trouver la page du token", perso);
        return;
      }
      if (attrSuivi.length > 0) {
        var width = page.get('width') * PIX_PER_UNIT;
        var height = page.get('height') * PIX_PER_UNIT;
        var pt = {
          x: x,
          y: y
        };
        var murs = getWalls(page, pageId, prev.murs);
        var distance =
          Math.sqrt((x - prev.left) * (x - prev.left) + (y - prev.top) * (y - prev.top));
        attrSuivi.forEach(function(as) {
          var suivants = as.get('current').split(':::');
          var removedSuivant;
          suivants = suivants.filter(function(idn) {
            var suivant = persoOfIdName(idn, pageId);
            if (suivant === undefined) {
              removedSuivant = true;
              return false;
            }
            var sw = suivant.token.get('width');
            var sh = suivant.token.get('height');
            if (sw > width) return false;
            if (sh > width) return false;
            var sx = suivant.token.get('left');
            var sy = suivant.token.get('top');
            //On essaie de garder la même position par rapport au token, en supposant qu'on était derrière lui
            var attrSuit = tokenAttribute(suivant, 'suit');
            var dp;
            if (attrSuit.length > 0) {
              dp = parseInt(attrSuit[0].get('max'));
            }
            if (dp === undefined || isNaN(dp) || dp < 1) {
              dp = Math.sqrt((prev.left - sx) * (prev.left - sx) + (prev.top - sy) * (prev.top - sy));
            }
            var nsx = x + (prev.left - x) * dp / distance;
            var nsy = y + (prev.top - y) * dp / distance;
            if (nsx < 0) nsx = 0;
            if (nsy < 0) nsy = 0;
            if (nsx + sw / 2 > width) nsx = Math.floor(width - sw / 2);
            if (nsy + sh / 2 > height) nsy = Math.floor(height - sh / 2);
            //vérifie si de la nouvelle position on peut voir le suivi
            if (obstaclePresent(nsx, nsy, pt, murs)) {
              //On essaie de suivre le chemin du token, à la lace
              //D'abord se déplacer vers l'ancienne position de perso, au maximum de distance pixels
              var distLoc = distance;
              if (distLoc - dp < 5) {
                nsx = prev.left;
                nsy = prev.top;
              } else {
                if (dp > distLoc) {
                  nsx = sx + (prev.left - sx) * distLoc / dp;
                  nsy = sy + (prev.top - sy) * distLoc / dp;
                  if (obstaclePresent(nsx, nsy, pt, murs)) {
                    sendChar(suivant.charId, "ne peut plus suivre " + perso.token.get('name') + " car " + onGenre(suivant, 'il', 'elle') + " ne " + onGenre(perso, 'le', 'la') + " voit plus");
                    removeTokenAttr(suivant, 'suit');
                    removedSuivant = true;
                    return false;
                  }
                } else {
                  //On part de l'ancienne position, et on peut encore avancer
                  distLoc -= dp;
                  nsx = prev.left + (x - prev.left) * distLoc / distance;
                  nsy = prev.top + (y - prev.top) * distLoc / distance;
                  if (obstaclePresent(nsx, nsy, pt, murs)) {
                    nsx = prev.left;
                    nsy = prev.top;
                  }
                }
              }
            }
            suivant.token.set('left', nsx);
            suivant.token.set('top', nsy);
            var sprev = {
              left: sx,
              top: sy,
              suit: true,
              murs: murs
            };
            moveToken(suivant.token, sprev); //pour faire suivre ceux qui le suivent
            return true;
          });
          if (removedSuivant) {
            if (suivants.length === 0) {
              as.remove();
            } else {
              as.set('current', suivants.join(':::'));
            }
          }
        });
      }
      // Update position du token d'initiative dynamique
      if (stateCOF.options.affichage.val.init_dynamique.val) {
        if (roundMarker && (
            (!stateCOF.chargeFantastique && stateCOF.activeTokenId == token.id) ||
            (stateCOF.chargeFantastique && stateCOF.chargeFantastique.activeTokenId == token.id))) {
          roundMarker.set('left', x);
          roundMarker.set('top', y);
        } else if (roundMarker) {
          // Cas spéciaux du cavaliers : au tour du cavalier, l'init_dynamique suit la monture
          var estMontePar = tokenAttribute(perso, "estMontePar");
          if (estMontePar.length > 0 && stateCOF.activeTokenId == estMontePar[0].get("current")) {
            var cavalierId = estMontePar[0].get("current");
            var cavalier = persoOfId(cavalierId);
            roundMarker.set('left', cavalier.token.get('left'));
            roundMarker.set('top', cavalier.token.get('top'));
          }
        }
      }
      //On déplace les tokens de lumière, si il y en a
      var attrLumiere = tokenAttribute(perso, 'lumiere');
      attrLumiere.forEach(function(al) {
        var lumId = al.get('max');
        if (lumId == 'surToken') return;
        var lumiereExiste;
        var lumiere = getObj('graphic', lumId);
        if (lumiere && lumiere.get('pageid') != pageId) {
          lumiere = undefined;
          lumiereExiste = true;
        }
        if (lumiere === undefined) {
          var tokensLumiere = findObjs({
            _type: 'graphic',
            _pageid: pageId,
            layer: 'walls',
            name: al.get('current')
          });
          if (tokensLumiere.length === 0) {
            if (lumiereExiste) return;
            log("Pas de token pour la lumière " + al.get('current'));
            al.remove();
            return;
          }
          lumiere = tokensLumiere.shift();
          if (tokensLumiere.length > 0) {
            //On cherche le token le plus proche de la position précédente
            var d =
              VecMath.length(
                VecMath.vec([lumiere.get('left'), lumiere.get('top')], [prev.left, prev.top]));
            tokensLumiere.forEach(function(tl) {
              var d2 =
                VecMath.length(
                  VecMath.vec([tl.get('left'), tl.get('top')], [prev.left, prev.top]));
              if (d2 < d) {
                d = d2;
                lumiere = tl;
              }
            });
          }
        }
        if (lumiere === undefined) {
          if (lumiereExiste) return;
          log("Pas de token pour la lumière " + al.get('current'));
          al.remove();
          return;
        }
        lumiere.set('left', x);
        lumiere.set('top', y);
      });
    }
    var attrEnveloppe = tokenAttribute(perso, 'enveloppe');
    attrEnveloppe.forEach(function(a) {
      var cible = persoOfIdName(a.get('current'), pageId);
      if (cible === undefined) {
        a.remove();
        return;
      }
      cible.token.set('left', x);
      cible.token.set('top', y);
    });
  }

  function deplacerToken(msg) {
    var cmd = msg.content.split(' ');
    if (cmd.length < 3) {
      error("Il manque un argument à !cof-deplacer-token", cmd);
      return;
    }
    getSelected(msg, function(selected) {
      if (selected.length === 0) {
        error("Il faut sélectionner un token", cmd);
        return;
      }
      if (selected.length > 1) {
        error("Déplacement de plusieurs tokens au même endroit", selected);
        return;
      }
      iterSelected(selected, function(perso) {
        perso.token.set('left', cmd[1]);
        perso.token.set('top', cmd[2]);
        moveToken(perso.token);
      });
    });
  }

  //Si le token représente un personnage et avec la barre de vie non liée,
  // assure un nom unique en ajoutant un numéro
  // On en profite aussi pour mettre certaines valeurs par défaut
  function renameToken(token, tokenName) {
    var charId = token.get('represents');
    if (charId === undefined || charId === '') return;
    var perso = {
      token: token,
      tokName: tokenName,
      charId: charId
    };
    var pageId = token.get('pageid');
    //Vision
    var visionNoir = charAttributeAsInt(perso, 'visionDansLeNoir', 0);
    if (visionNoir > 0) {
      visionNoir = scaleDistance(perso, visionNoir);
      var page = getObj('page', pageId);
      var udl = page && page.get('dynamic_lighting_enabled');
      if (udl) {
        token.set('has_night_vision', true);
        //token.set('night_vision_tint', '#555555');
        token.set('night_vision_distance', visionNoir);
      } else {
        token.set('light_radius', visionNoir);
        token.set('light_dimradius', -1);
        token.set('light_otherplayers', false);
        token.set('light_hassight', true);
        token.set('light_angle', 360);
      }
    }
    if (token.get('bar1_link') !== '') return;
    var copyOf = 0;
    var tokenBaseName = tokenName;
    if (tokenBaseName.includes('%%NUMBERED%%')) {
      if (typeof TokenNameNumber !== 'undefined') return; //On laisse tokenNameNumber gérer ça
      tokenBaseName = tokenBaseName.replace('%%NUMBERED%%', '');
    } else {
      // On regarde si le nom se termine par un entier
      var lastSpace = tokenBaseName.lastIndexOf(' ');
      if (lastSpace > 0) {
        copyOf = +tokenBaseName.substring(lastSpace + 1);
        if (isNaN(copyOf)) copyOf = 0;
        else tokenBaseName = tokenBaseName.substring(0, lastSpace);
      }
    }
    var otherTokens = findObjs({
      _type: 'graphic',
      //_pageid: token.get('pageid'),
      represents: charId
    });
    otherTokens = otherTokens.filter(function(tok) {
      var pid = tok.get('pageid');
      var page = getObj('page', pid);
      if (page) {
        return !(page.get('archived'));
      }
      return false;
    });
    var numero = 1;
    var nePasModifier = false;
    if (typeof TokenNameNumber !== 'undefined' && tokenBaseName.length > 0) {
      if (!isNaN(tokenBaseName[tokenBaseName.length - 1]))
        nePasModifier = true;
    }
    otherTokens.forEach(function(ot) {
      if (ot.id == token.id) return;
      var name = ot.get('name');
      if (nePasModifier && name == tokenBaseName) nePasModifier = false;
      if (name.startsWith(tokenBaseName)) {
        var suffixe = name.replace(tokenBaseName + ' ', '');
        if (isNaN(suffixe)) return;
        var n = parseInt(suffixe);
        if (n == copyOf) {
          if (ot.get('pageid') == pageId) copyOf = 0;
        }
        if (n >= numero) numero = n + 1;
      }
    });
    if (nePasModifier || copyOf > 0) return;
    token.set('name', tokenBaseName + ' ' + numero);
  }

  function initTokenMarkers(token) {
    var charId = token.get('represents');
    if (charId === undefined || charId === '') return; // Si token lié à un perso
    if (token.get('bar1_link') === '') return; // Si unique
    var perso = {
      tokem: token,
      charId: charId
    };
    // Boucle sur les états de cof_states
    Object.keys(cof_states).forEach(function(etat) {
      // Récupère la valeur de l'état sur la fiche
      var attributeFicheValue;
      if (etat == 'affaibli') { // Cas particulier affaibli sur la fiche perso
        attributeFicheValue = (ficheAttributeAsInt(perso, 'affaibli', 20) == 12);
      } else { // Autre cas
        attributeFicheValue = ficheAttributeAsBool(perso, etat, false);
      }
      // Récupère la valeur de l'état sur le token
      var attributeTokenValue = token.get(cof_states[etat]);
      // En fonction des cas appel token.set avec true ou false
      if (attributeFicheValue === true && attributeTokenValue === false) {
        token.set(cof_states[etat], true);
      } else if (attributeFicheValue === false && attributeTokenValue === true) {
        token.set(cof_states[etat], false);
      }
    });
  }


  function addToken(token, nb) {
    var tokenName = token.get('name');
    //La plupart du temps, il faut attendre un peu que le nom soit affecté
    if (tokenName !== '') {
      renameToken(token, tokenName);
      initTokenMarkers(token);
      return;
    }
    nb = nb || 1;
    if (nb > 10) return; //Tant pis, peut-être que le nom est vide
    _.delay(function() {
      addToken(token, nb + 1);
    }, 50);
  }

  // Surveillance sur le changement d'état du token
  function changeMarker(token, prev) {
    var charId = token.get('represents');
    if (charId === undefined || charId === '') return; // Uniquement si token lié à un perso
    var perso = {
      token: token,
      charId: charId
    };
    var evt = {
      type: "set_state",
    };
    affectToken(token, 'statusmarkers', prev.statusmarkers, evt);
    var currentMarkers = [];
    var markers = token.get("statusmarkers");
    if (markers !== '') {
      currentMarkers = markers.split(',');
    }
    var previousMarkers = [];
    if (prev.statusmarkers !== '') {
      previousMarkers = prev.statusmarkers.split(',');
    }
    // Pour tous les markers disparus
    previousMarkers.forEach(function(marker) {
      if (currentMarkers.includes(marker)) return;
      var etat = etat_de_marker[marker];
      if (etat) {
        setState(perso, etat, false, evt);
      }
    });
    // Ensuite les markers apparuts
    currentMarkers.forEach(function(marker) {
      if (previousMarkers.includes(marker)) return;
      var etat = etat_de_marker[marker];
      if (etat) {
        var succes = setState(perso, etat, true, evt);
        if (!succes) token.set('status_' + marker, false);
      }
    });
    addEvent(evt);
  }

  function initAllMarkers(campaign) {
    var currentMap = getObj('page', campaign.get('playerpageid'));
    var tokens = findObjs({
      _pageid: currentMap.id,
      _type: 'graphic',
      _subtype: 'token'
    });
    tokens.forEach(initTokenMarkers);
  }

  return {
    apiCommand: apiCommand,
    nextTurn: nextTurn,
    destroyToken: destroyToken,
    moveToken: moveToken,
    changeHandout: changeHandout,
    addToken: addToken,
    changeMarker: changeMarker,
    initAllMarkers: initAllMarkers,
    setStateCOF: setStateCOF,
    scriptVersionToCharacter: scriptVersionToCharacter,
  };

}();

on("change:handout", function(obj, prev) {
  COFantasy.changeHandout(obj, prev);
});

on("destroy:handout", function(prev) {
  COFantasy.changeHandout(undefined, prev);
});

on('ready', function() {
  var scriptVersion = '2.16';
  on('add:token', COFantasy.addToken);
  on("change:graphic:statusmarkers", COFantasy.changeMarker);
  on("change:campaign:playerpageid", COFantasy.initAllMarkers);
  state.COFantasy = state.COFantasy || {
    combat: false,
    tour: 0,
    init: 1000,
    eventId: 0,
    version: scriptVersion,
  };
  COFantasy.setStateCOF();
  if (state.COFantasy.version === undefined) {
    state.COFantasy.eventId = 0;
  }
  var handout = findObjs({
    _type: 'handout'
  });
  var strReg;
  var regName;
  var regText;
  var attrs;
  var macros;
  if (state.COFantasy.version < 1.0) {
    log("Mise à jour des attributs et macros vers la version 1.0");
    //Mise à jour des effets temporaires avec _
    strReg = "(rayon_affaiblissant|peau_d_ecorce|chant_des_heros|image_decalee|a_couvert|sous_tension|forgeron_|armeEnflammee)";
    regName = new RegExp("^" + strReg);
    regText = new RegExp(strReg);
    attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      var attrName = attr.get('name');
      if (regName.test(attrName)) {
        attrName = attrName.replace(/rayon_affaiblissant/, 'rayonAffaiblissant');
        attrName = attrName.replace(/peau_d_ecorce/, 'peauDEcorce');
        attrName = attrName.replace(/chant_des_heros/, 'chantDesHeros');
        attrName = attrName.replace(/image_decalee/, 'imageDecalee');
        attrName = attrName.replace(/a_couvert/, 'aCouvert');
        attrName = attrName.replace(/sous_tension/, 'sousTension');
        attrName = attrName.replace(/forgeron_([^_\s)]*)/, 'forgeron($1)');
        attrName = attrName.replace(/armeEnflammee([^_\s)]*)/, 'armeEnflammee($1)');
        attr.set('name', attrName);
      }
      //Pour les consommables, il faut aussi changer le champ max;
      var attrMax = attr.get('max');
      if (regText.test(attrMax)) {
        attrMax = attrMax.replace(/rayon_affaiblissant/g, 'rayonAffaiblissant');
        attrMax = attrMax.replace(/peau_d_ecorce/g, 'peauDEcorce');
        attrMax = attrMax.replace(/chant_des_heros/g, 'chantDesHeros');
        attrMax = attrMax.replace(/image_decalee/g, 'imageDecalee');
        attrMax = attrMax.replace(/a_couvert/g, 'aCouvert');
        attrMax = attrMax.replace(/sous_tension/g, 'sousTension');
        attrMax = attrMax.replace(/forgeron_([^_\s)]*)/g, 'forgeron($1)');
        attrMax = attrMax.replace(/armeEnflammee([^_\s)]*)/g, 'armeEnflammee($1)');
        attr.set('max', attrMax);
      }
    });
    macros = findObjs({
      _type: 'macro'
    }).concat(findObjs({
      _type: 'ability'
    }));
    macros.forEach(function(m) {
      var action = m.get('action');
      if (regText.test(action)) {
        action = action.replace(/rayon_affaiblissant/g, 'rayonAffaiblissant');
        action = action.replace(/peau_d_ecorce/g, 'peauDEcorce');
        action = action.replace(/chant_des_heros/g, 'chantDesHeros');
        action = action.replace(/image_decalee/g, 'imageDecalee');
        action = action.replace(/a_couvert/g, 'aCouvert');
        action = action.replace(/sous_tension/g, 'sousTension');
        action = action.replace(/forgeron_([^_\s)]*)/g, 'forgeron($1)');
        action = action.replace(/armeEnflammee([^_\s)]*)/g, 'armeEnflammee($1)');
        m.set('action', action);
      }
    });
    log("Mise à jour effectuée.");
  }
  if (state.COFantasy.version < 2.0) {
    log("Mise à jour des attributs et macros vers la version 2.0");
    strReg = "(--argent)";
    regName = new RegExp("^" + strReg);
    regText = new RegExp(strReg);
    attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      var attrName = attr.get('name');
      if (regName.test(attrName)) {
        attrName = attrName.replace(/--argent/, '--armeDArgent');
        attr.set('name', attrName);
      }
      //Pour les consommables, il faut aussi changer le champ max;
      var attrMax = attr.get('max');
      if (regText.test(attrMax)) {
        attrMax = attrMax.replace(/--argent/g, '--armeDArgent');
        attr.set('max', attrMax);
      }
    });
    macros = findObjs({
      _type: 'macro'
    }).concat(findObjs({
      _type: 'ability'
    }));
    macros.forEach(function(m) {
      var action = m.get('action');
      if (regText.test(action)) {
        action = action.replace(/--argent/g, '--armeDArgent');
        m.set('action', action);
      }
    });
    //On met un attribut scriptVersion dans toutes les fiches
    findObjs({
      _type: 'character'
    }).forEach(function(c) {
      createObj('attribute', {
        characterid: c.id,
        name: 'scriptVersion',
        current: true,
        max: scriptVersion
      });
    });
    state.COFantasy.scriptSheets = true;
    log("Mise à jour effectuée.");
  }
  if (state.COFantasy.version < 2.02) {
    attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      var attrName = attr.get('name');
      if (attrName == 'mort-vivant') attr.set('name', 'mortVivant');
    });
    log("Mise à jour effectuée.");
  }
  if (state.COFantasy.version < 2.03) {
    attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(attr) {
      var attrName = attr.get('name');
      if (attrName == 'runeDEnergie') attr.set('name', 'runeForgesort_énergie');
      if (attrName == 'runeDeProtection') attr.set('name', 'runeForgesort_protection');
      if (attrName.includes('runeDePuissance')) {
        attr.set('name', 'runeForgesort_puissance(' + attrName.substring(attrName.indexOf("(") + 1, attrName.indexOf(")")) + ')');
      }
    });
    log("Mise à jour des runes effectuée.");
  }
  if (state.COFantasy.version < 2.04) {
    attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      var attrName = a.get('name');
      if (!attrName.startsWith('RD_')) return;
      if (attrName == 'RD_critique') return;
      var rds = parseInt(a.get('current'));
      if (isNaN(rds) || rds < 1) {
        a.remove();
        return;
      }
      var cid = a.get('characterid');
      var attrRD = 'RDS';
      var versionFiche = parseFloat(getAttrByName(cid, 'version'));
      if (isNaN(versionFiche)) versionFiche = 0;
      if (versionFiche < 3.7 && getAttrByName(cid, 'type_personnage') == 'PNJ') attrRD = 'pnj_rd';
      var attrRDS = findObjs({
        _type: 'attribute',
        _characterid: cid,
        name: attrRD
      }, {
        caseInsensitive: true
      });
      if (attrRDS.length === 0) {
        attrRDS = createObj('attribute', {
          characterid: cid,
          name: attrRD,
          current: '',
          max: ''
        });
      } else attrRDS = attrRDS[0];
      var rdPerso = attrRDS.get('current');
      attrName = attrName.substring(3);
      if (attrName.startsWith('sauf_')) {
        attrName = attrName.substr(5);
        if (rdPerso.trim() === '') rdPerso = rds + '/' + attrName;
        else rdPerso += ', ' + rds + '/' + attrName;
        attrRDS.set('current', rdPerso);
        a.remove();
        return;
      }
      if (attrName == 'rdt' || attrName == 'sauf') return;
      if (rdPerso.trim() === '') rdPerso = attrName + ':' + rds;
      else rdPerso += ', ' + attrName + ':' + rds;
      attrRDS.set('current', rdPerso);
      a.remove();
    });
    log("Mise à jour de la RD effectuée");
  }
  if (state.COFantasy.version < 2.05) {
    attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      var attrName = a.get('name');
      if (!attrName.startsWith('dose_') && !attrName.startsWith('consommable_')) return;
      var action = a.get('max');
      if (!action.startsWith('!cof-lancer-sort')) return;
      var mana = action.charAt(17);
      var message = action.substring(19);
      a.set("max", "!cof-lancer-sort --message " + message + " --mana " + mana);
    });
    log("Mise à jour des consommables !cof-lancer-sort effectuée");
    macros = findObjs({
      _type: 'macro'
    }).concat(findObjs({
      _type: 'ability'
    }));
    macros.forEach(function(m) {
      var macro = m.get("action");
      if (!macro.startsWith('!cof-lancer-sort')) return;
      var mana = macro.charAt(17);
      var message = macro.substring(19);
      m.set("action", "!cof-lancer-sort --message " + message + " --mana " + mana);
    });
    log("Mise à jour des ability & macros !cof-lancer-sort effectuée");
  }
  if (state.COFantasy.version < 2.10) {
    var tokens = findObjs({
      _type: 'graphic',
      _subtype: 'token'
    });
    tokens.forEach(function(token) {
      var charId = token.get('represents');
      if (charId === '') return;
      var bar1_link = token.get('bar1_link');
      if (bar1_link === '') return;
      var attrLie = getObj('attribute', bar1_link);
      if (attrLie === undefined) return;
      if (attrLie.get('name') != 'pnj_pv') return;
      var attrPV = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'PV'
      }, {
        caseInsensitive: true
      });
      if (attrPV.length === 0) return;
      token.set('bar1_link', attrPV[0].id);
    });
    var characters = findObjs({
      _type: 'character',
    });
    var charsToTreat = characters.length;
    var removeAttrs = function() {
      charsToTreat--;
      if (charsToTreat > 0) return;
      log("Supression des attributs obsolètes");
      var attrs = findObjs({
        _type: 'attribute',
      });
      attrs.forEach(function(a) {
        switch (a.get('name')) {
          case 'PR1':
          case 'PR2':
          case 'PR3':
          case 'PR4':
          case 'PR5':
          case 'pnj_pv':
          case 'pnj_dmtemp':
          case 'pnj_rd':
            a.remove();
        }
      });
    };
    if (charsToTreat === 0) removeAttrs();
    var pageId = Campaign().get('playerpageid');
    characters.forEach(function(character) {
      character.get('defaulttoken', function(token) {
        if (token === '') {
          removeAttrs();
          return;
        }
        token = JSON.parse(token);
        if (!token) {
          removeAttrs();
          return;
        }
        var bar1_link = token.bar1_link;
        if (bar1_link === '') {
          removeAttrs();
          return;
        }
        var attrLie = getObj('attribute', bar1_link);
        if (attrLie === undefined) {
          removeAttrs();
          return;
        }
        if (attrLie.get('name') != 'pnj_pv') {
          removeAttrs();
          return;
        }
        var attrPV = findObjs({
          _type: 'attribute',
          _characterid: character.id,
          name: 'PV'
        }, {
          caseInsensitive: true
        });
        if (attrPV.length === 0) {
          removeAttrs();
          return;
        }
        token.bar1_link = attrPV[0].id;
        token.pageid = pageId;
        token.imgsrc = token.imgsrc.replace('/med.png', '/thumb.png');
        token.imgsrc = token.imgsrc.replace('/max.png', '/thumb.png');
        var newToken = createObj('graphic', token);
        if (newToken) {
          setDefaultTokenForCharacter(character, newToken);
          newToken.remove();
        } else {
          log('Impossible de créer un token pour ' + token.name);
          log(token);
        }
        removeAttrs();
      });
    });
    log("Mise à jour des attributs et tokens effectuée");
  }
  if (state.COFantasy.version < 2.11) {
    attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      if (a.get('name') != 'capitaine') return;
      var nomCapitaine = a.get('current');
      var idCapitaine = a.get('max');
      var na = {
        current: idCapitaine + ' ' + nomCapitaine,
        max: 2
      };
      a.set(na);
    });
    log("Mise à jour des attributs de capitaine effectuée");
  }
  if (state.COFantasy.version < 2.12) {
    attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      var attrName = a.get('name');
      if (!attrName.startsWith('dose_') && !attrName.startsWith('consommable_')) return;
      var charId = a.get('characterid');
      //On ne passe dans la liste que pour les persos de type PJ
      var typePerso = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'type_personnage',
      }, {
        caseInsensitive: true
      });
      if (typePerso.length > 0 && typePerso[0].get('current') != 'PJ') return;
      var consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ');
      if (consName === '') return;
      var quantite = parseInt(a.get('current'));
      if (isNaN(quantite) || quantite < 0) return;
      var pref = 'repeating_equipement_' + generateRowID() + '_';
      var versionFiche = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'version',
      }, {
        caseInsensitive: true
      });
      if (versionFiche.length === 0) versionFiche = 0;
      else versionFiche = parseFloat(versionFiche[0].get('current'));
      if (versionFiche < 4.01) {
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip-nom',
          current: consName
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip-qte',
          current: quantite
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip-effet',
          current: a.get('max').trim(),
        });
      } else {
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip_nom',
          current: consName
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip_qte',
          current: quantite
        });
        createObj('attribute', {
          _characterid: charId,
          name: pref + 'equip_effet',
          current: a.get('max').trim(),
        });
      }
      a.remove();
    });
    log("Déplacement des attributs de consommables vers la fiche");
  }
  if (state.COFantasy.version < 2.13) {
    //On enlève les attributs obsolètes de la verison 4.00 de la fiche
    attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      if (a.get('name').toLowerCase() == 'equip-div') {
        if (a.get('current') === '') {
          a.remove();
          return;
        }
        var charId = a.get('characterid');
        var newAttr = findObjs({
          _type: 'attribute',
          _characterid: charId,
          name: 'equip_div',
        }, {
          caseInsensitive: true
        });
        newAttr = newAttr.filter(function(na) {
          if (na.get('current') === '') {
            na.remove();
            return false;
          }
          return true;
        });
        if (newAttr.length === 0) {
          a.set('name', 'equip_div');
        } else {
          var character = getObj('character', charId);
          if (character === undefined) return;
          sendChat("COFantasy", "Supprimer l'attribut 'equip-div' du personnage" + character.get('name'));
          log("Supprimer l'attribut 'equip-div' du personnage" + character.get('name'));
          log("valeur courante " + newAttr[0].get('current'));
          log("Ancienne valeur " + a.get('current'));
          return;
        }
      }
    });
  }
  if (state.COFantasy.version < 2.14) {
    //Migration des éléments de règles optionnels
    //Divers
    if (state.COFantasy.options.regles.val.poudre_explosif) {
      state.COFantasy.options.regles.val.divers.val.poudre_explosif.val = state.COFantasy.options.regles.val.poudre_explosif.val;
      delete state.COFantasy.options.regles.val.poudre_explosif;
    }
    if (state.COFantasy.options.regles.val.forme_d_arbre_amelioree) {
      state.COFantasy.options.regles.val.divers.val.forme_d_arbre_amelioree.val = state.COFantasy.options.regles.val.forme_d_arbre_amelioree.val;
      delete state.COFantasy.options.regles.val.forme_d_arbre_amelioree;
    }
    if (state.COFantasy.options.regles.val.interchangeable_attaque) {
      state.COFantasy.options.regles.val.divers.val.interchangeable_attaque.val = state.COFantasy.options.regles.val.interchangeable_attaque.val;
      delete state.COFantasy.options.regles.val.interchangeable_attaque;
    }
    //Dommages
    if (state.COFantasy.options.regles.val.dm_minimum) {
      state.COFantasy.options.regles.val.dommages.val.dm_minimum.val = state.COFantasy.options.regles.val.dm_minimum.val;
      delete state.COFantasy.options.regles.val.dm_minimum;
    }
    if (state.COFantasy.options.regles.val.crit_elementaire) {
      state.COFantasy.options.regles.val.dommages.val.crit_elementaire.val = state.COFantasy.options.regles.val.crit_elementaire.val;
      delete state.COFantasy.options.regles.val.crit_elementaire;
    }
    if (state.COFantasy.options.regles.val.blessures_graves) {
      state.COFantasy.options.regles.val.dommages.val.blessures_graves.val = state.COFantasy.options.regles.val.blessures_graves.val;
      delete state.COFantasy.options.regles.val.blessures_graves;
    }
    //Haute DEF
    if (state.COFantasy.options.regles.val.usure_DEF) {
      state.COFantasy.options.regles.val.haute_DEF.val.usure_DEF.val = state.COFantasy.options.regles.val.usure_DEF.val;
      delete state.COFantasy.options.regles.val.usure_DEF;
    }
    if (state.COFantasy.options.regles.val.generer_options_attaques) {
      log("Options d'attaques supprimées ; veuiller utiliser le bouton 'Options' de la liste d'Actions à la place");
      sendChat('COFantasy', "Options d'attaques supprimées ; veuiller utiliser le bouton 'Options' de la liste d'Actions à la place");
      delete state.COFantasy.options.regles.val.generer_options_attaques;
    }
    if (state.COFantasy.options.regles.val.generer_attaque_groupe) {
      log("Attaques de groupe supprimées ; veuiller utiliser le bouton 'Options' de la liste d'Actions à la place");
      sendChat('COFantasy', "Options d'attaques supprimées ; veuiller utiliser le bouton 'Options' de la liste d'Actions à la place");
      delete state.COFantasy.options.regles.val.generer_attaque_groupe;
    }
    if (state.COFantasy.options.regles.val.bonus_attaque_groupe) {
      state.COFantasy.options.regles.val.haute_DEF.val.bonus_attaque_groupe.val = state.COFantasy.options.regles.val.bonus_attaque_groupe.val;
      delete state.COFantasy.options.regles.val.bonus_attaque_groupe;
    }
    if (state.COFantasy.options.regles.val.crit_attaque_groupe) {
      state.COFantasy.options.regles.val.haute_DEF.val.crit_attaque_groupe.val = state.COFantasy.options.regles.val.crit_attaque_groupe.val;
      delete state.COFantasy.options.regles.val.crit_attaque_groupe;
    }
    //Initiative
    if (state.COFantasy.options.regles.val.initiative_variable) {
      state.COFantasy.options.regles.val.initiative.val.initiative_variable.val = state.COFantasy.options.regles.val.initiative_variable.val;
      delete state.COFantasy.options.regles.val.initiative_variable;
    }
    if (state.COFantasy.options.regles.val.initiative_variable_individuelle) {
      state.COFantasy.options.regles.val.initiative.val.initiative_variable_individuelle.val = state.COFantasy.options.regles.val.initiative_variable_individuelle.val;
      delete state.COFantasy.options.regles.val.initiative_variable_individuelle;
    }
    //Mana
    if (state.COFantasy.options.regles.val.mana_totale) {
      state.COFantasy.options.regles.val.mana.val.mana_totale.val = state.COFantasy.options.regles.val.mana_totale.val;
      delete state.COFantasy.options.regles.val.mana_totale;
    }
    if (state.COFantasy.options.regles.val.elixirs_sorts) {
      state.COFantasy.options.regles.val.mana.val.elixirs_sorts.val = state.COFantasy.options.regles.val.elixirs_sorts.val;
      delete state.COFantasy.options.regles.val.elixirs_sorts;
    }
    log("Règles optionelles mises à jour");
  }
  if (state.COFantasy.version < 2.15) {
    attrs = findObjs({
      _type: 'attribute',
    });
    attrs.forEach(function(a) {
      var attrName = a.get('name');
      if (!attrName.startsWith('dose_') && !attrName.startsWith('consommable_')) return;
      var charId = a.get('characterid');
      //On ne passe dans la liste que pour les persos de type PNJ
      var typePerso = findObjs({
        _type: 'attribute',
        _characterid: charId,
        name: 'type_personnage',
      }, {
        caseInsensitive: true
      });
      if (typePerso.length > 0 && typePerso[0].get('current') == 'PJ') return;
      var consName = attrName.substring(attrName.indexOf('_') + 1);
      consName = consName.replace(/_/g, ' ');
      if (consName === '') return;
      var quantite = parseInt(a.get('current'));
      if (isNaN(quantite) || quantite < 0) return;
      var pref = 'repeating_equipement_' + generateRowID() + '_';
      createObj('attribute', {
        _characterid: charId,
        name: pref + 'equip_nom',
        current: consName
      });
      createObj('attribute', {
        _characterid: charId,
        name: pref + 'equip_qte',
        current: quantite
      });
      createObj('attribute', {
        _characterid: charId,
        name: pref + 'equip_effet',
        current: a.get('max').trim(),
      });
      a.remove();
    });
    log("Déplacement des attributs de consommables de PNJs vers la fiche");
  }
  if (state.COFantasy.version < 2.16) {
    attrs = findObjs({
      _type: 'attribute',
    });
    var handouts = findObjs({
      _type: 'handout'
    });
    var handhoutComp = handouts.find(function(h) {
      var handName = h.get('name');
      return (handName == 'Compétences' || handName == 'Competences');
    });
    if (handhoutComp) {
      var listeCompetences = {
        FOR: [],
        DEX: [],
        CON: [],
        SAG: [],
        INT: [],
        CHA: [],
        nombre: 0
      };
      handhoutComp.get('notes', function(note) { // asynchronous
        var carac; //La carac dont on spécifie les compétences actuellement
        note = note.trim();
        if (note.startsWith('<p>')) note = note.substring(3);
        note = note.trim().replace(/<span[^>]*>|<\/span>/g, '');
        note = note.replace(/<p>/g, '<br>');
        note = note.replace(/<\/p>/g, '');
        var lignes = note.trim().split('<br>');
        lignes.forEach(function(ligne) {
          ligne = ligne.trim();
          var header = ligne.split(':');
          if (header.length > 1) {
            var c = header.shift().trim().toUpperCase();
            if (c != 'FOR' && c != 'CON' && c != 'DEX' && c != 'INT' && c != 'SAG' && c != 'CHA') return;
            carac = c;
            ligne = header.join(':').trim();
          }
          if (ligne.length === 0) return;
          if (carac === undefined) {
            log("Compétences sans caractéristique associée");
            return;
          }
          var comps = ligne.split(/, |\/| /);
          comps.forEach(function(comp) {
            if (comp.length === 0) return;
            listeCompetences[carac].push(comp);
            listeCompetences.nombre++;
          });
        });
        var compToCarac = {};
        listeCompetences.FOR.forEach(function(c) {
          compToCarac[c] = 'FOR';
          compToCarac[c.toLowerCase()] = 'FOR';
        });
        listeCompetences.CON.forEach(function(c) {
          compToCarac[c] = 'CON';
          compToCarac[c.toLowerCase()] = 'CON';
        });
        listeCompetences.DEX.forEach(function(c) {
          compToCarac[c] = 'DEX';
          compToCarac[c.toLowerCase()] = 'DEX';
        });
        listeCompetences.INT.forEach(function(c) {
          compToCarac[c] = 'INT';
          compToCarac[c.toLowerCase()] = 'INT';
        });
        listeCompetences.SAG.forEach(function(c) {
          compToCarac[c] = 'SAG';
          compToCarac[c.toLowerCase()] = 'SAG';
        });
        listeCompetences.CHA.forEach(function(c) {
          compToCarac[c] = 'CHA';
          compToCarac[c.toLowerCase()] = 'CHA';
        });
        attrs.forEach(function(a) {
          var attrName = a.get('name');
          switch (attrName) {
            case 'RACE':
              a.set('name', 'race');
              return;
            case 'PROFIL':
              a.set('name', 'profil');
              return;
            case 'NIVEAU':
              a.set('name', 'niveau');
              return;
            case 'SEXE':
              a.set('name', 'sexe');
              return;
            case 'AGE':
              a.set('name', 'age');
              return;
            case 'TAILLE':
              a.set('name', 'taille');
              return;
            case 'POIDS':
              a.set('name', 'poids');
              return;
            case 'FORCE':
              a.set('name', 'force');
              return;
            case 'DEXTERITE':
              a.set('name', 'dexterite');
              return;
            case 'CONSTITUTION':
              a.set('name', 'constitution');
              return;
            case 'INTELLIGENCE':
              a.set('name', 'intelligence');
              return;
            case 'SAGESSE':
              a.set('name', 'sagesse');
              return;
            case 'CHARISME':
              a.set('name', 'charisme');
              return;
          }
          //Les compétences
          var charId = a.get('characterid');
          //On ne bouge les compétences que pour les persos de type PJ
          var typePerso = findObjs({
            _type: 'attribute',
            _characterid: charId,
            name: 'type_personnage',
          }, {
            caseInsensitive: true
          });
          if (typePerso.length > 0 && typePerso[0].get('current') != 'PJ') return;
          if (compToCarac[attrName] === undefined) return;
          var prefix = 'repeating_competences_' + generateRowID() + '_comp_';
          var attrSpec = {
            characterid: charId
          };
          attrSpec.name = prefix + 'nom';
          attrSpec.current = attrName;
          createObj('attribute', attrSpec);
          attrSpec.name = prefix + 'bonus';
          attrSpec.current = a.get('current');
          var attrBonus = createObj('attribute', attrSpec);
          attrSpec.name = prefix + 'bonusTotal';
          createObj('attribute', attrSpec);
          attrSpec.name = prefix + 'carac';
          attrSpec.current = compToCarac[attrName];
          createObj('attribute', attrSpec);
          var attrMalus;
          if ((attrSpec.current == 'DEX' && attrName != 'crochetage' && attrName != 'désamorçage') ||
            (attrSpec.current == 'CON' && attrName == 'survie') ||
            attrName == 'natation' || attrName == 'escalade') {
            attrSpec.name = prefix + 'malus';
            attrSpec.current = 'armure';
            attrMalus = createObj('attribute', attrSpec);
            attrBonus.setWithWorker('current', a.get('current'));
            attrMalus.setWithWorker('current', 'armure');
          } else if (attrName == 'perception' || attrName == 'vigilance') {
            attrSpec.name = prefix + 'malus';
            attrSpec.current = 'casque';
            attrMalus = createObj('attribute', attrSpec);
            attrBonus.setWithWorker('current', a.get('current'));
            attrMalus.setWithWorker('current', 'casque');
          }
          a.remove();
        });
      }); //end hand.get(notes)
    } else {
      attrs.forEach(function(a) {
        var attrName = a.get('name');
        switch (attrName) {
          case 'RACE':
            a.set('name', 'race');
            return;
          case 'PROFIL':
            a.set('name', 'profil');
            return;
          case 'NIVEAU':
            a.set('name', 'niveau');
            return;
          case 'SEXE':
            a.set('name', 'sexe');
            return;
          case 'AGE':
            a.set('name', 'age');
            return;
          case 'TAILLE':
            a.set('name', 'taille');
            return;
          case 'POIDS':
            a.set('name', 'poids');
            return;
          case 'FORCE':
            a.set('name', 'force');
            return;
          case 'DEXTERITE':
            a.set('name', 'dexterite');
            return;
          case 'CONSTITUTION':
            a.set('name', 'constitution');
            return;
          case 'INTELLIGENCE':
            a.set('name', 'intelligence');
            return;
          case 'SAGESSE':
            a.set('name', 'sagesse');
            return;
          case 'CHARISME':
            a.set('name', 'charisme');
            return;
        }
      });
    }
    log("Mise à jour des attributs de compétence effectué");
  }
  state.COFantasy.version = scriptVersion;
  if (state.COFantasy.options.affichage.val.fiche.val) {
    if (!state.COFantasy.scriptSheets) {
      findObjs({
        _type: 'character'
      }).forEach(function(c) {
        COFantasy.scriptVersionToCharacter(c, true);
      });
      state.COFantasy.scriptSheets = true;
    }
  } else {
    if (state.COFantasy.scriptSheets) {
      findObjs({
        _type: 'character'
      }).forEach(function(c) {
        COFantasy.scriptVersionToCharacter(c, false);
      });
    }
    state.COFantasy.scriptSheets = false;
  }
  handout.forEach(function(hand) {
    COFantasy.changeHandout(hand);
  });
  COF_loaded = true;
  log("COFantasy " + scriptVersion + " loaded");
});

on("chat:message", function(msg) {
  "use strict";
  if (COF_loaded && msg.type == "api" && msg.content.startsWith('!cof-')) {
    try {
      COFantasy.apiCommand(msg);
    } catch (e) {
      sendChat('COF', "Erreur durant l'exécution de " + msg.content);
      log("Erreur durant l'exécution de " + msg.content);
      log(msg);
      var errMsg = e.name;
      if (e.lineNumber) errMsg += " at " + e.lineNumber;
      else if (e.number) errMsg += " at " + e.number;
      errMsg += ': ' + e.message;
      sendChat('COF', errMsg);
      log(errMsg);
    }
  }
});

on("change:campaign:turnorder", COFantasy.nextTurn);
on("destroy:token", COFantasy.destroyToken);
on("change:token", COFantasy.moveToken);
on("add:character", function(c) {
  if (COF_loaded) {
    COFantasy.scriptVersionToCharacter(c, true);
  }
});
